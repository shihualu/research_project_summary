diff --git a/.arcconfig b/.arcconfig
index 72b0ebff7..e5b788da0 100644
--- a/.arcconfig
+++ b/.arcconfig
@@ -1,5 +1,11 @@
 {
   "project_id" : "facebook-android-sdk",
   "conduit_uri" : "https://phabricator.fb.com/api/",
-  "copyright_holder" : "Facebook"
+  "copyright_holder" : "Facebook",
+  "phutil_libraries" : {
+    "android-sdk-arcanist" : "internal/arcanist"
+  },
+  "arcanist_configuration" : "FacebookAndroidSDKArcanistConfiguration",
+  "unit_engine" : "AndroidSdkUnitTestEngine",
+  "lint_engine" : "AndroidSdkLintEngine"
 }
diff --git a/.buckconfig b/.buckconfig
new file mode 100644
index 000000000..cfa58a9e4
--- /dev/null
+++ b/.buckconfig
@@ -0,0 +1,18 @@
+# .buckconfig.local is in .gitignore, so you do not have to worry about checking your
+# personal customizations to Buck into the repo.
+
+[java]
+    # This makes it possible to determine the package of a
+    # Java file from the path alone.
+    src_roots = /facebook/src/, /samples/HelloFacebookSample/src/
+
+    # We target gingerbread. Ensure that libraries target that.
+    source_level = 6
+    target_level = 6
+
+[build]
+    build_dependencies = FIRST_ORDER_ONLY
+
+[alias]
+    sdk = //facebook:android-sdk
+    hello-facebook = //samples/HelloFacebookSample:app
diff --git a/.buckversion b/.buckversion
new file mode 100644
index 000000000..f2e2f6494
--- /dev/null
+++ b/.buckversion
@@ -0,0 +1 @@
+62a21e0436bc4b72db9aa7fc2237d9cdf162b29f
diff --git a/.gitignore b/.gitignore
index 3233b9c7b..e5c341ccc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,6 +14,7 @@ gen/
 
 # Local configuration file (sdk path, etc)
 local.properties
+local.gradle
 
 # Proguard folder generated by Eclipse
 proguard/
@@ -28,6 +29,20 @@ proguard/
 .gradle
 build
 
+# Buck
+/buck-cache/
+/buck-out/
+/.buckconfig.local
+/.buckd
+/.nobuckcheck
+/.bucktestselectors
+
+# vim temp files
+*.swp
+
+# Arc generated
+.phutil_module_cache
+
 *~
 *.DS_Store
 *java#
@@ -38,8 +53,6 @@ target/
 .gradle/
 build/
 facebook/doc/
-facebook/lint.xml
 facebook/tests/lint.xml
 facebook/tests/assets/config.json
-.idea/
-*.iml
\ No newline at end of file
+gradle-app.setting
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 000000000..7ed80e8f8
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,8 @@
+language: android
+
+# Override the install and test so that we don't run integration tests
+install: 
+  - ./gradlew assemble
+
+script:
+  - ./gradlew :junitTests:test -i
diff --git a/LICENSE.txt b/LICENSE.txt
index 261eeb9e9..bdb9fc54b 100644
--- a/LICENSE.txt
+++ b/LICENSE.txt
@@ -1,201 +1,17 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
+Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+copy, modify, and distribute this software in source code or binary form for use
+in connection with the web services and APIs provided by Facebook.
+
+As with any software that integrates with the Facebook platform, your use of
+this software is subject to the Facebook Developer Principles and Policies
+[http://developers.facebook.com/policy/]. This copyright notice shall be
+included in all copies or substantial portions of the software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/README.mdown b/README.mdown
index c52e978a9..fb35fc7b7 100644
--- a/README.mdown
+++ b/README.mdown
@@ -1,27 +1,43 @@
 Facebook SDK for Android
 ========================
 
+[![Build Status](https://travis-ci.org/facebook/facebook-android-sdk.svg?branch=master)](https://travis-ci.org/facebook/facebook-android-sdk.svg?branch=master)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.facebook.android/facebook-android-sdk/badge.svg?style=flat)](https://maven-badges.herokuapp.com/maven-central/com.facebook.android/facebook-android-sdk)
+
 This open-source library allows you to integrate Facebook into your Android app.
 
-Learn more about about the provided samples, documentation, integrating the SDK into your app, accessing source code, and more at https://developers.facebook.com/android
+Learn more about about the provided samples, documentation, integrating the SDK into your app, accessing source code, and more at https://developers.facebook.com/docs/android
 
 TRY IT OUT
+----------
+1. Check-out the tutorials available online at https://developers.facebook.com/docs/android/getting-started
+2. Start coding! Visit https://developers.facebook.com/docs/android/ for tutorials and reference documentation.
 
-1. Check-out the tutorials available online at https://developers.facebook.com/docs/getting-started/facebook-sdk-for-android/3.0/
+FEATURES
+--------
+* Login - https://developers.facebook.com/docs/facebook-login
+* Sharing - https://developers.facebook.com/docs/sharing
+* App Links - https://developers.facebook.com/docs/applinks
+* Graph API - https://developers.facebook.com/docs/android/graph
 
-2. Start coding! Visit https://developers.facebook.com/android for tutorials and reference documentation.
+GIVE FEEDBACK
+-------------
+Please report bugs or issues to https://developers.facebook.com/bugs/
 
-LICENSE
+You can also join the Facebook Developers Group on Facebook (https://www.facebook.com/groups/fbdevelopers/) or ask questions on Stack Overflow (http://facebook.stackoverflow.com)
 
-Except as otherwise noted, the Facebook SDK for Android is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html).
+LICENSE
+-------
+Except as otherwise noted, the Facebook SDK for Android is licensed under the Facebook Platform License (https://github.com/facebook/facebook-android-sdk/blob/master/LICENSE.txt).
 
 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.
 
 DEVELOPER TERMS
+---------------
 
 - By enabling Facebook integrations, including through this SDK, you can share information with Facebook, including information about peopleâ€™s use of your app. Facebook will use information received in accordance with our Data Use Policy (https://www.facebook.com/about/privacy/), including to provide you with insights about the effectiveness of your ads and the use of your app.  These integrations also enable us and our partners to serve ads on and off Facebook.
 
-- You may limit your sharing of information with us by updating the Insights control in the developer tool (https://developers.facebook.com/apps/<app_id>/advanced).
+- You may limit your sharing of information with us by updating the Insights control in the developer tool (https://developers.facebook.com/apps/[app_id]/settings/advanced).
 
 - If you use a Facebook integration, including to share information with us, you agree and confirm that you have provided appropriate and sufficiently prominent notice to and obtained the appropriate consent from your users regarding such collection, use, and disclosure (including, at a minimum, through your privacy policy). You further agree that you will not share information with us about children under the age of 13.
 
diff --git a/build.gradle b/build.gradle
index 2d3bec743..1296bf37b 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,6 +4,12 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.7.+'
+        classpath 'com.android.tools.build:gradle:1.0.0'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
     }
 }
diff --git a/facebook/.classpath b/facebook/.classpath
deleted file mode 100644
index 7bc01d9a9..000000000
--- a/facebook/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/facebook/.project b/facebook/.project
deleted file mode 100644
index d0551a112..000000000
--- a/facebook/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>FacebookSDK</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/facebook/AndroidManifest.xml b/facebook/AndroidManifest.xml
index 2f9284fb0..859055cbd 100644
--- a/facebook/AndroidManifest.xml
+++ b/facebook/AndroidManifest.xml
@@ -1,22 +1,26 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="com.facebook.android">
+      package="com.facebook">
     <application/>
-    <uses-sdk android:minSdkVersion="8" />
+    <uses-sdk android:minSdkVersion="9" />
 </manifest>
diff --git a/facebook/BUCK b/facebook/BUCK
new file mode 100644
index 000000000..d6a6dfcfe
--- /dev/null
+++ b/facebook/BUCK
@@ -0,0 +1,26 @@
+build_config(
+  name = 'config-debug',
+  package = 'com.facebook',
+  debug = True,
+)
+
+android_resource(
+  name = 'res',
+  res = 'res',
+  package = 'com.facebook',
+  deps = [
+  ],
+)
+
+android_library(
+  name = 'android-sdk',
+  srcs = glob(['src/**/*.java']) + [':config-debug'],
+  deps = [
+    ':res',
+    '//libs:android-support-v4',
+    '//libs:bolts',
+  ],
+  visibility = [
+    'PUBLIC',
+  ],
+)
diff --git a/facebook/TestApp/AndroidManifest.xml b/facebook/TestApp/AndroidManifest.xml
deleted file mode 100644
index cccc2923d..000000000
--- a/facebook/TestApp/AndroidManifest.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="com.facebook.sdk"
-      android:versionCode="1"
-      android:versionName="1.0">
-    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">
-        <activity android:name="StatusActivity"
-                  android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/facebook/TestApp/ant.properties b/facebook/TestApp/ant.properties
deleted file mode 100644
index b0971e891..000000000
--- a/facebook/TestApp/ant.properties
+++ /dev/null
@@ -1,17 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
diff --git a/facebook/TestApp/build.gradle b/facebook/TestApp/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/facebook/TestApp/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/facebook/TestApp/build.xml b/facebook/TestApp/build.xml
deleted file mode 100644
index ea49a3fca..000000000
--- a/facebook/TestApp/build.xml
+++ /dev/null
@@ -1,83 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="FacebookSdk" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/facebook/TestApp/proguard-project.txt b/facebook/TestApp/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/facebook/TestApp/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/facebook/TestApp/project.properties b/facebook/TestApp/project.properties
deleted file mode 100644
index b0620672e..000000000
--- a/facebook/TestApp/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-
diff --git a/facebook/TestApp/res/drawable-hdpi/ic_launcher.png b/facebook/TestApp/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 8074c4c57..000000000
Binary files a/facebook/TestApp/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/drawable-ldpi/ic_launcher.png b/facebook/TestApp/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 1095584ec..000000000
Binary files a/facebook/TestApp/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/drawable-mdpi/ic_launcher.png b/facebook/TestApp/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/facebook/TestApp/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/layout/main.xml b/facebook/TestApp/res/layout/main.xml
deleted file mode 100644
index 2c0cc449a..000000000
--- a/facebook/TestApp/res/layout/main.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    >
-<TextView
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:text="SDK Unit Tests"
-    />
-</LinearLayout>
-
diff --git a/facebook/TestApp/res/values/strings.xml b/facebook/TestApp/res/values/strings.xml
deleted file mode 100644
index 520cc92a7..000000000
--- a/facebook/TestApp/res/values/strings.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_name">StatusActivity</string>
-</resources>
diff --git a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
deleted file mode 100644
index 317e5567f..000000000
--- a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.sdk;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-public class StatusActivity extends Activity
-{
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-    }
-}
diff --git a/facebook/ant.properties b/facebook/ant.properties
deleted file mode 100644
index b206ddecc..000000000
--- a/facebook/ant.properties
+++ /dev/null
@@ -1,2 +0,0 @@
-jar.libs.dir=../lib
-java.compilerargs=-Xlint -Werror
\ No newline at end of file
diff --git a/facebook/build.gradle b/facebook/build.gradle
index 6d2068d08..e29663199 100644
--- a/facebook/build.gradle
+++ b/facebook/build.gradle
@@ -1,7 +1,14 @@
 apply plugin: 'com.android.library'
 
+repositories {
+    mavenCentral()
+}
+
+project.group = 'com.facebook.android'
+
 dependencies {
-    compile 'com.android.support:support-v4:13.0.+'
+    compile 'com.android.support:support-v4:[21,22)'
+    compile 'com.parse.bolts:bolts-android:1.2.0'
 }
 
 android {
@@ -9,8 +16,12 @@ android {
     buildToolsVersion buildToolsVersionValue
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
@@ -20,8 +31,101 @@ android {
             res.srcDirs = ['res']
         }
     }
+}
 
-    lintOptions {
-        abortOnError false
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+def isSnapshot = version.endsWith('-SNAPSHOT')
+def ossrhUsername = hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+def ossrhPassword = hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+
+task setVersion {
+    // The version will be derived from source
+    project.version = null
+    def sdkVersionFile = file('src/com/facebook/FacebookSdkVersion.java')
+    sdkVersionFile.eachLine {
+        def matcher = (it =~ /(?:.*BUILD = \")(.*)(?:\".*)/)
+        if (matcher.matches()) {
+            project.version = matcher[0][1]
+            return
+        }
     }
+    if (project.version.is('unspecified')) {
+        throw new GradleScriptException('Version could not be found.', null)
+    }
+}
+
+uploadArchives {
+    repositories.mavenDeployer {
+        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+        repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
+            authentication(userName: ossrhUsername, password: ossrhPassword)
+        }
+
+        snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
+            authentication(userName: ossrhUsername, password: ossrhPassword)
+        }
+
+        pom.project {
+            name 'Facebook-Android-SDK'
+            artifactId = 'facebook-android-sdk'
+            packaging 'aar'
+            description 'Facebook Android SDK'
+            url 'https://github.com/facebook/facebook-android-sdk'
+
+            scm {
+                connection 'scm:git@github.com:facebook/facebook-android-sdk.git'
+                developerConnection 'scm:git@github.com:facebook/facebook-android-sdk.git'
+                url 'https://github.com/facebook/facebook-android-sdk'
+            }
+
+            licenses {
+                license {
+                    name 'Facebook Platform License'
+                    url 'https://github.com/facebook/facebook-android-sdk/blob/master/LICENSE.txt'
+                    distribution 'repo'
+                }
+            }
+
+            developers {
+                developer {
+                    id 'facebook'
+                    name 'Facebook'
+                }
+            }
+        }
+    }
+}
+
+uploadArchives.dependsOn(setVersion)
+
+signing {
+    required { !isSnapshot && gradle.taskGraph.hasTask("uploadArchives") }
+    sign configurations.archives
+}
+
+task androidJavadocs(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.sourceFiles
+}
+
+artifacts {
+    archives androidSourcesJar
+    archives androidJavadocsJar
+}
+
+afterEvaluate {
+    androidJavadocs.classpath += project.android.libraryVariants.toList().first().javaCompile.classpath
 }
diff --git a/facebook/build.xml b/facebook/build.xml
deleted file mode 100644
index d85ad3e64..000000000
--- a/facebook/build.xml
+++ /dev/null
@@ -1,83 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="facebook" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/facebook/junitTests/build.gradle b/facebook/junitTests/build.gradle
new file mode 100644
index 000000000..680019b55
--- /dev/null
+++ b/facebook/junitTests/build.gradle
@@ -0,0 +1,48 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.github.jcandksolutions.gradle:android-unit-test:2.1.1'
+    }
+}
+
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 18
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "com.facebook.junittests"
+        minSdkVersion 9
+        targetSdkVersion 18
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+apply plugin: 'android-unit-test'
+
+dependencies {
+    def powerMockVersion = '1.6.1'
+
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:18.+'
+    compile project(':facebook')
+
+    testCompile 'junit:junit:4.12'
+    testCompile 'org.robolectric:robolectric:2.4'
+
+    // PowerMock brings in the mockito dependency
+    testCompile "org.powermock:powermock-module-junit4:$powerMockVersion"
+    testCompile "org.powermock:powermock-module-junit4-rule:$powerMockVersion"
+    testCompile "org.powermock:powermock-classloading-xstream:$powerMockVersion"
+    testCompile "org.powermock:powermock-api-mockito:$powerMockVersion"
+}
diff --git a/samples/FriendPickerSample/proguard-project.txt b/facebook/junitTests/proguard-rules.pro
similarity index 62%
rename from samples/FriendPickerSample/proguard-project.txt
rename to facebook/junitTests/proguard-rules.pro
index f2fe1559a..c65732a17 100644
--- a/samples/FriendPickerSample/proguard-project.txt
+++ b/facebook/junitTests/proguard-rules.pro
@@ -1,11 +1,8 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
 # Add project specific ProGuard rules here.
 # By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
+# in /Users/gokhanc/android-sdk-macosx/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
 #
 # For more details, see
 #   http://developer.android.com/guide/developing/tools/proguard.html
diff --git a/facebook/junitTests/src/main/AndroidManifest.xml b/facebook/junitTests/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..f1eecc854
--- /dev/null
+++ b/facebook/junitTests/src/main/AndroidManifest.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.junittests" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/facebook/junitTests/src/main/assets/ShareOpenGraphUtilityTests_actionJSON.json b/facebook/junitTests/src/main/assets/ShareOpenGraphUtilityTests_actionJSON.json
new file mode 100644
index 000000000..688967288
--- /dev/null
+++ b/facebook/junitTests/src/main/assets/ShareOpenGraphUtilityTests_actionJSON.json
@@ -0,0 +1,18 @@
+{
+  "type": "myActionType",
+  "myObject": {
+    "fbsdk:create_object":true,
+    "myString": "value",
+    "myInt": 42,
+    "myBoolean": true,
+    "myStringArray": [
+      "string1",
+      "string2",
+      "string3"
+    ],
+    "myObject": {
+      "fbsdk:create_object":true,
+      "myPi": 3.14
+    }
+  }
+}
diff --git a/facebook/junitTests/src/main/java/com/facebook/junittests/MainActivity.java b/facebook/junitTests/src/main/java/com/facebook/junittests/MainActivity.java
new file mode 100644
index 000000000..da299bbe4
--- /dev/null
+++ b/facebook/junitTests/src/main/java/com/facebook/junittests/MainActivity.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.junittests;
+
+import android.support.v7.app.ActionBarActivity;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
+
+import com.facebook.FacebookSdk;
+
+
+public class MainActivity extends ActionBarActivity {
+    private static String APP_ID = "1234";
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        FacebookSdk.sdkInitialize(getApplicationContext());
+        FacebookSdk.setApplicationId(APP_ID);
+        setContentView(R.layout.activity_main);
+    }
+
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        // Inflate the menu; this adds items to the action bar if it is present.
+        getMenuInflater().inflate(R.menu.menu_main, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle action bar item clicks here. The action bar will
+        // automatically handle clicks on the Home/Up button, so long
+        // as you specify a parent activity in AndroidManifest.xml.
+        int id = item.getItemId();
+
+        //noinspection SimplifiableIfStatement
+        if (id == R.id.action_settings) {
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+}
diff --git a/facebook/junitTests/src/main/res/drawable-hdpi/ic_launcher.png b/facebook/junitTests/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 000000000..96a442e5b
Binary files /dev/null and b/facebook/junitTests/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/facebook/junitTests/src/main/res/drawable-mdpi/ic_launcher.png b/facebook/junitTests/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 000000000..359047dfa
Binary files /dev/null and b/facebook/junitTests/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/facebook/junitTests/src/main/res/drawable-xhdpi/ic_launcher.png b/facebook/junitTests/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..71c6d760f
Binary files /dev/null and b/facebook/junitTests/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/facebook/junitTests/src/main/res/drawable-xxhdpi/ic_launcher.png b/facebook/junitTests/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..4df189464
Binary files /dev/null and b/facebook/junitTests/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/facebook/junitTests/src/main/res/layout/activity_main.xml b/facebook/junitTests/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..48c48a2c6
--- /dev/null
+++ b/facebook/junitTests/src/main/res/layout/activity_main.xml
@@ -0,0 +1,45 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                tools:context=".MainActivity">
+
+    <TextView
+        android:text="@string/hello_world"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+
+    <com.facebook.login.widget.LoginButton
+        android:id="@+id/login_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_horizontal"
+        android:layout_marginTop="30dp"
+        android:layout_marginBottom="30dp" />
+
+
+</RelativeLayout>
diff --git a/facebook/junitTests/src/main/res/menu/menu_main.xml b/facebook/junitTests/src/main/res/menu/menu_main.xml
new file mode 100644
index 000000000..2d51a5a10
--- /dev/null
+++ b/facebook/junitTests/src/main/res/menu/menu_main.xml
@@ -0,0 +1,29 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto"
+      xmlns:tools="http://schemas.android.com/tools"
+      tools:context=".MainActivity">
+    <item android:id="@+id/action_settings"
+          android:title="@string/action_settings"
+          android:orderInCategory="100"
+          app:showAsAction="never"/>
+</menu>
diff --git a/facebook/junitTests/src/main/res/values-w820dp/dimens.xml b/facebook/junitTests/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 000000000..72bb51545
--- /dev/null
+++ b/facebook/junitTests/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,26 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/facebook/junitTests/src/main/res/values/dimens.xml b/facebook/junitTests/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..c936db986
--- /dev/null
+++ b/facebook/junitTests/src/main/res/values/dimens.xml
@@ -0,0 +1,25 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/facebook/junitTests/src/main/res/values/strings.xml b/facebook/junitTests/src/main/res/values/strings.xml
new file mode 100644
index 000000000..93feb6823
--- /dev/null
+++ b/facebook/junitTests/src/main/res/values/strings.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+
+    <string name="app_name">junitTests</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
diff --git a/facebook/junitTests/src/main/res/values/styles.xml b/facebook/junitTests/src/main/res/values/styles.xml
new file mode 100644
index 000000000..a7a50cfc1
--- /dev/null
+++ b/facebook/junitTests/src/main/res/values/styles.xml
@@ -0,0 +1,27 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/facebook/junitTests/src/test/java/com/facebook/AccessTokenCacheTest.java b/facebook/junitTests/src/test/java/com/facebook/AccessTokenCacheTest.java
new file mode 100644
index 000000000..c0f3b723c
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/AccessTokenCacheTest.java
@@ -0,0 +1,274 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+
+import com.facebook.internal.Utility;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.powermock.api.support.membermodification.MemberModifier.stub;
+
+@PrepareForTest( {
+        AccessTokenCache.class,
+        FacebookSdk.class,
+        LegacyTokenHelper.class,
+        Utility.class})
+public class AccessTokenCacheTest extends FacebookPowerMockTestCase {
+
+    private final String TOKEN_STRING = "A token of my esteem";
+    private final String USER_ID = "1000";
+    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
+    private final Date EXPIRES = new Date(2025, 5, 3);
+    private final Date LAST_REFRESH = new Date(2023, 8, 15);
+    private final String APP_ID = "1234";
+
+    private SharedPreferences sharedPreferences;
+    @Mock private LegacyTokenHelper cachingStrategy;
+    private AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory
+            cachingStrategyFactory;
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(FacebookSdk.class);
+        sharedPreferences = Robolectric.application.getSharedPreferences(
+                AccessTokenManager.SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
+        sharedPreferences.edit().clear().commit();
+        cachingStrategyFactory = mock(
+                AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory.class);
+        when(cachingStrategyFactory.create()).thenReturn(cachingStrategy);
+        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
+                new JSONObject().put("id", "1000"));
+    }
+
+
+    @Test
+    public void testLoadReturnsFalseIfNoCachedToken() {
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken accessToken = cache.load();
+
+        assertNull(accessToken);
+        PowerMockito.verifyZeroInteractions(cachingStrategy);
+    }
+
+    @Test
+    public void testLoadReturnsFalseIfNoCachedOrLegacyToken() {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken accessToken = cache.load();
+
+        assertNull(accessToken);
+    }
+
+    @Test
+    public void testLoadReturnsFalseIfEmptyCachedTokenAndDoesNotCheckLegacy() {
+
+        JSONObject jsonObject = new JSONObject();
+        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
+                jsonObject.toString()).commit();
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken accessToken = cache.load();
+
+        assertNull(accessToken);
+        verifyZeroInteractions(cachingStrategy);
+    }
+
+    @Test
+    public void testLoadReturnsFalseIfNoCachedTokenAndEmptyLegacyToken() {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        when(cachingStrategy.load()).thenReturn(new Bundle());
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken accessToken = cache.load();
+
+        assertNull(accessToken);
+    }
+
+    @Test
+    public void testLoadValidCachedToken() throws JSONException {
+        AccessToken accessToken = createAccessToken();
+        JSONObject jsonObject = accessToken.toJSONObject();
+        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
+                jsonObject.toString()).commit();
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken loadedAccessToken = cache.load();
+
+        assertNotNull(loadedAccessToken);
+        assertEquals(accessToken, loadedAccessToken);
+    }
+
+    @Test
+    public void testLoadSetsCurrentTokenIfNoCachedTokenButValidLegacyToken() {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        AccessToken accessToken = createAccessToken();
+        when(cachingStrategy.load()).thenReturn(
+                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        AccessToken loadedAccessToken = cache.load();
+
+        assertNotNull(loadedAccessToken);
+        assertEquals(accessToken, loadedAccessToken);
+    }
+
+    @Test
+    public void testLoadSavesTokenWhenUpgradingFromLegacyToken() throws JSONException {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        AccessToken accessToken = createAccessToken();
+        when(cachingStrategy.load()).thenReturn(
+                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+        cache.load();
+
+        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
+
+        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
+                new JSONObject(sharedPreferences.getString(
+                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
+        assertEquals(accessToken, savedAccessToken);
+    }
+
+    @Test
+    public void testLoadClearsLegacyCacheWhenUpgradingFromLegacyToken() {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        AccessToken accessToken = createAccessToken();
+        when(cachingStrategy.load()).thenReturn(
+                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));
+
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+        cache.load();
+
+        verify(cachingStrategy, times(1)).clear();
+    }
+
+    @Test
+    public void testSaveRequiresToken() {
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        try {
+            cache.save(null);
+            fail();
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testSaveWritesToCacheIfToken() throws JSONException {
+        AccessToken accessToken = createAccessToken();
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        cache.save(accessToken);
+
+        verify(cachingStrategy, never()).save(any(Bundle.class));
+        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
+
+        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
+                new JSONObject(sharedPreferences.getString(
+                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
+        assertEquals(accessToken, savedAccessToken);
+    }
+
+    @Test
+    public void testClearCacheClearsCache() {
+        AccessToken accessToken = createAccessToken();
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        cache.save(accessToken);
+
+        cache.clear();
+
+        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
+        verify(cachingStrategy, never()).clear();
+    }
+
+    @Test
+    public void testClearCacheClearsLegacyCache() {
+        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);
+
+        AccessToken accessToken = createAccessToken();
+        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
+
+        cache.save(accessToken);
+
+        cache.clear();
+
+        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
+        verify(cachingStrategy, times(1)).clear();
+    }
+
+    private AccessToken createAccessToken() {
+        return createAccessToken(TOKEN_STRING, USER_ID);
+    }
+
+    private AccessToken createAccessToken(String tokenString, String userId) {
+        return new AccessToken(
+                tokenString,
+                APP_ID,
+                userId,
+                PERMISSIONS,
+                null,
+                AccessTokenSource.WEB_VIEW,
+                EXPIRES,
+                LAST_REFRESH);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/AccessTokenManagerTest.java b/facebook/junitTests/src/test/java/com/facebook/AccessTokenManagerTest.java
new file mode 100644
index 000000000..796c329e4
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/AccessTokenManagerTest.java
@@ -0,0 +1,232 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.internal.Utility;
+
+import org.json.JSONException;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import static org.mockito.Mockito.*;
+import static org.junit.Assert.*;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+import static org.powermock.api.support.membermodification.MemberMatcher.method;
+import static org.powermock.api.support.membermodification.MemberModifier.suppress;
+
+@PrepareForTest({FacebookSdk.class, AccessTokenCache.class, Utility.class})
+public class AccessTokenManagerTest extends FacebookPowerMockTestCase {
+
+    private final String TOKEN_STRING = "A token of my esteem";
+    private final String USER_ID = "1000";
+    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
+    private final Date EXPIRES = new Date(2025, 5, 3);
+    private final Date LAST_REFRESH = new Date(2023, 8, 15);
+    private final String APP_ID = "1234";
+
+    private LocalBroadcastManager localBroadcastManager;
+    private AccessTokenCache accessTokenCache;
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(FacebookSdk.class);
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);
+        suppress(method(Utility.class, "clearFacebookCookies"));
+
+        localBroadcastManager = LocalBroadcastManager.getInstance(Robolectric.application);
+        accessTokenCache = mock(AccessTokenCache.class);
+    }
+
+    @Test
+    public void testRequiresLocalBroadcastManager() {
+        try {
+            AccessTokenManager accessTokenManager = new AccessTokenManager(null, accessTokenCache);
+            fail();
+        } catch (NullPointerException ex) {
+        }
+    }
+
+    @Test
+    public void testRequiresTokenCache() {
+        try {
+            AccessTokenManager accessTokenManager = new AccessTokenManager(localBroadcastManager,
+                    null);
+            fail();
+        } catch (NullPointerException ex) {
+        }
+    }
+
+    @Test
+    public void testDefaultsToNoCurrentAccessToken() {
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        assertNull(accessTokenManager.getCurrentAccessToken());
+    }
+
+    @Test
+    public void testCanSetCurrentAccessToken() {
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        AccessToken accessToken = createAccessToken();
+
+        accessTokenManager.setCurrentAccessToken(accessToken);
+
+        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
+    }
+
+    @Test
+    public void testChangingAccessTokenSendsBroadcast() {
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        AccessToken accessToken = createAccessToken();
+
+        accessTokenManager.setCurrentAccessToken(accessToken);
+
+        final Intent intents[] = new Intent[1];
+        final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                intents[0] = intent;
+            }
+        };
+
+        localBroadcastManager.registerReceiver(broadcastReceiver,
+                new IntentFilter(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED));
+
+        AccessToken anotherAccessToken = createAccessToken("another string", "1000");
+
+        accessTokenManager.setCurrentAccessToken(anotherAccessToken);
+
+        localBroadcastManager.unregisterReceiver(broadcastReceiver);
+
+        Intent intent = intents[0];
+
+        assertNotNull(intent);
+
+        AccessToken oldAccessToken =
+                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN);
+        AccessToken newAccessToken =
+                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN);
+
+        assertEquals(accessToken.getToken(), oldAccessToken.getToken());
+        assertEquals(anotherAccessToken.getToken(), newAccessToken.getToken());
+    }
+
+    @Test
+    public void testLoadReturnsFalseIfNoCachedToken() {
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        boolean result = accessTokenManager.loadCurrentAccessToken();
+
+        assertFalse(result);
+    }
+
+    @Test
+    public void testLoadReturnsTrueIfCachedToken() {
+        AccessToken accessToken = createAccessToken();
+        when(accessTokenCache.load()).thenReturn(accessToken);
+
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        boolean result = accessTokenManager.loadCurrentAccessToken();
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void testLoadSetsCurrentTokenIfCached() {
+        AccessToken accessToken = createAccessToken();
+        when(accessTokenCache.load()).thenReturn(accessToken);
+
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        accessTokenManager.loadCurrentAccessToken();
+
+        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
+    }
+
+    @Test
+    public void testSaveWritesToCacheIfToken() throws JSONException {
+        AccessToken accessToken = createAccessToken();
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        accessTokenManager.setCurrentAccessToken(accessToken);
+
+        verify(accessTokenCache, times(1)).save(any(AccessToken.class));
+    }
+
+    @Test
+    public void testSetEmptyTokenClearsCache() {
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        accessTokenManager.setCurrentAccessToken(null);
+
+        verify(accessTokenCache, times(1)).clear();
+    }
+
+    @Test
+    public void testLoadDoesNotSave() {
+        AccessToken accessToken = createAccessToken();
+        when(accessTokenCache.load()).thenReturn(accessToken);
+
+        AccessTokenManager accessTokenManager = createAccessTokenManager();
+
+        accessTokenManager.loadCurrentAccessToken();
+
+        verify(accessTokenCache, never()).save(any(AccessToken.class));
+    }
+
+    private AccessTokenManager createAccessTokenManager() {
+        return new AccessTokenManager(localBroadcastManager, accessTokenCache);
+    }
+
+    private AccessToken createAccessToken() {
+        return createAccessToken(TOKEN_STRING, USER_ID);
+    }
+
+    private AccessToken createAccessToken(String tokenString, String userId) {
+        return new AccessToken(
+                tokenString,
+                APP_ID,
+                userId,
+                PERMISSIONS,
+                null,
+                AccessTokenSource.WEB_VIEW,
+                EXPIRES,
+                LAST_REFRESH);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/AccessTokenTest.java b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTest.java
new file mode 100644
index 000000000..9c4db5d7d
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTest.java
@@ -0,0 +1,377 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+import com.facebook.internal.Utility;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+import static org.powermock.api.support.membermodification.MemberModifier.stub;
+
+@PrepareForTest( {Utility.class})
+public final class AccessTokenTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() throws Exception {
+        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
+                new JSONObject().put("id", "1000"));
+    }
+
+    @Test
+    public void testNullTokenThrows() {
+        try {
+            AccessToken token = new AccessToken(
+                    null,
+                    "1234",
+                    "1000",
+                    Utility.arrayList("something"),
+                    Utility.arrayList("something_else"),
+                    AccessTokenSource.CLIENT_TOKEN,
+                    new Date(),
+                    new Date());
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void testEmptyTokenThrows() {
+        try {
+            AccessToken token = new AccessToken(
+                    "",
+                    "1234",
+                    "1000",
+                    Utility.arrayList("something"),
+                    Utility.arrayList("something_else"),
+                    AccessTokenSource.CLIENT_TOKEN,
+                    new Date(),
+                    new Date());
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void testNullUserIdThrows() {
+        try {
+            AccessToken token = new AccessToken(
+                    "a token",
+                    "1234",
+                    null,
+                    Utility.arrayList("something"),
+                    Utility.arrayList("something_else"),
+                    AccessTokenSource.CLIENT_TOKEN,
+                    new Date(),
+                    new Date());
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void testEmptyUserIdThrows() {
+        try {
+            AccessToken token = new AccessToken(
+                    "a token",
+                    "1234",
+                    "",
+                    Utility.arrayList("something"),
+                    Utility.arrayList("something_else"),
+                    AccessTokenSource.CLIENT_TOKEN,
+                    new Date(),
+                    new Date());
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void testCreateFromRefreshFailure() {
+        AccessToken accessToken = new AccessToken(
+                "a token",
+                "1234",
+                "1000",
+                Utility.arrayList("stream_publish"),
+                null,
+                AccessTokenSource.WEB_VIEW,
+                null,
+                null);
+
+        String token = "AnImaginaryTokenValue";
+
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", "AnImaginaryTokenValue");
+        bundle.putString("expires_in", "60");
+
+        try {
+            AccessToken.createFromRefresh(accessToken, bundle);
+            fail("Expected exception");
+        } catch (FacebookException ex) {
+            assertEquals("Invalid token source: " + AccessTokenSource.WEB_VIEW, ex.getMessage());
+        }
+    }
+
+    @Test
+    public void testCacheRoundtrip() {
+        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
+        Set<String> declinedPermissions = Utility.hashSet("no you may not", "no soup for you");
+        String token = "AnImaginaryTokenValue";
+        Date later = TestUtils.nowPlusSeconds(60);
+        Date earlier = TestUtils.nowPlusSeconds(-60);
+        String applicationId = "1234";
+
+        Bundle bundle = new Bundle();
+        LegacyTokenHelper.putToken(bundle, token);
+        LegacyTokenHelper.putExpirationDate(bundle, later);
+        LegacyTokenHelper.putSource(
+                bundle,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
+        LegacyTokenHelper.putPermissions(bundle, permissions);
+        LegacyTokenHelper.putDeclinedPermissions(bundle, declinedPermissions);
+        LegacyTokenHelper.putApplicationId(bundle, applicationId);
+
+        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isExpired());
+
+        Bundle cache = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
+        TestUtils.assertEqualContents(bundle, cache);
+    }
+
+    @Test
+    public void testFromCacheWithMissingApplicationId() {
+        String token = "AnImaginaryTokenValue";
+        String applicationId = "1234";
+
+        Bundle bundle = new Bundle();
+        LegacyTokenHelper.putToken(bundle, token);
+        // no app id
+
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        FacebookSdk.setApplicationId(applicationId);
+
+        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
+
+        assertEquals(applicationId, accessToken.getApplicationId());
+    }
+
+    @Test
+    public void testCachePutGet() {
+        Bundle bundle = new Bundle();
+
+        for (String token : new String[] { "", "A completely random token value" }) {
+            LegacyTokenHelper.putToken(bundle, token);
+            assertEquals(token, LegacyTokenHelper.getToken(bundle));
+        }
+
+        for (Date date : new Date[] { new Date(42), new Date() }) {
+            LegacyTokenHelper.putExpirationDate(bundle, date);
+            assertEquals(date, LegacyTokenHelper.getExpirationDate(bundle));
+
+            LegacyTokenHelper.putLastRefreshDate(bundle, date);
+            assertEquals(date, LegacyTokenHelper.getLastRefreshDate(bundle));
+        }
+
+        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
+            LegacyTokenHelper.putExpirationMilliseconds(bundle, milliseconds);
+            assertEquals(
+                    milliseconds,
+                    LegacyTokenHelper.getExpirationMilliseconds(bundle));
+
+            LegacyTokenHelper.putLastRefreshMilliseconds(bundle, milliseconds);
+            assertEquals(
+                    milliseconds,
+                    LegacyTokenHelper.getLastRefreshMilliseconds(bundle));
+        }
+
+        for (AccessTokenSource source : AccessTokenSource.values()) {
+            LegacyTokenHelper.putSource(bundle, source);
+            assertEquals(source, LegacyTokenHelper.getSource(bundle));
+        }
+
+        String userId = "1000";
+
+        List<String> normalList = Arrays.asList("", "Another completely random token value");
+        List<String> emptyList = Arrays.asList();
+        HashSet<String> normalArrayList = new HashSet<String>(normalList);
+        HashSet<String> emptyArrayList = new HashSet<String>();
+        @SuppressWarnings("unchecked")
+        List<Collection<String>> permissionLists = Arrays
+                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
+        for (Collection<String> list : permissionLists) {
+            LegacyTokenHelper.putPermissions(bundle, list);
+            TestUtils.assertSamePermissions(
+                    list,
+                    LegacyTokenHelper.getPermissions(bundle));
+        }
+        normalArrayList.add(null);
+    }
+
+    @Test
+    public void testRoundtripJSONObject() throws JSONException {
+        AccessToken accessToken = new AccessToken(
+                "a token",
+                "1234",
+                "1000",
+                Arrays.asList("permission_1", "permission_2"),
+                Arrays.asList("declined permission_1", "declined permission_2"),
+                AccessTokenSource.WEB_VIEW,
+                new Date(2015, 3, 3),
+                new Date(2015, 1, 1));
+
+        JSONObject jsonObject = accessToken.toJSONObject();
+
+        AccessToken deserializedAccessToken = AccessToken.createFromJSONObject(jsonObject);
+
+        assertEquals(accessToken, deserializedAccessToken);
+    }
+
+    @Test
+    public void testParceling() throws IOException {
+        String token = "a token";
+        String appId = "1234";
+        String userId = "1000";
+        Set<String> permissions = new HashSet<String>(
+                Arrays.asList("permission_1", "permission_2"));
+        Set<String> declinedPermissions = new HashSet<String>(
+                Arrays.asList("permission_3"));
+        AccessTokenSource source = AccessTokenSource.WEB_VIEW;
+        AccessToken accessToken1 = new AccessToken(
+                token,
+                appId,
+                userId,
+                permissions,
+                declinedPermissions,
+                source,
+                null,
+                null);
+
+        AccessToken accessToken2 = TestUtils.parcelAndUnparcel(accessToken1);
+        assertEquals(accessToken1, accessToken2);
+        assertEquals(token, accessToken2.getToken());
+        assertEquals(appId, accessToken2.getApplicationId());
+        assertEquals(permissions, accessToken2.getPermissions());
+        assertEquals(declinedPermissions, accessToken2.getDeclinedPermissions());
+        assertEquals(accessToken1.getExpires(), accessToken2.getExpires());
+        assertEquals(accessToken1.getLastRefresh(), accessToken2.getLastRefresh());
+        assertEquals(accessToken1.getUserId(), accessToken2.getUserId());
+    }
+
+    @Test
+    public void testPermissionsAreImmutable() {
+        Set<String> permissions = Utility.hashSet("go to Jail", "do not pass Go");
+        AccessToken accessToken = new AccessToken(
+                "some token",
+                "1234",
+                "1000",
+                permissions,
+                null,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                new Date(),
+                new Date());
+
+        permissions = accessToken.getPermissions();
+
+        try {
+            permissions.add("can't touch this");
+            fail();
+        } catch (UnsupportedOperationException ex) {
+        }
+    }
+
+    @Test
+    public void testCreateFromExistingTokenDefaults() {
+        final String token = "A token of my esteem";
+        final String applicationId = "1234";
+        final String userId = "1000";
+
+        AccessToken accessToken = new AccessToken(
+                token,
+                applicationId,
+                userId,
+                null,
+                null,
+                null,
+                null,
+                null);
+
+        assertEquals(token, accessToken.getToken());
+        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertEquals(0, accessToken.getPermissions().size());
+        assertEquals(applicationId, accessToken.getApplicationId());
+        assertEquals(userId, accessToken.getUserId());
+        // Allow slight variation for test execution time
+        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
+        assertTrue(delta < 1000);
+    }
+
+    @Test
+    public void testAccessTokenConstructor() {
+        final String token = "A token of my esteem";
+        final Set<String> permissions = Utility.hashSet("walk", "chew gum");
+        final Set<String> declinedPermissions = Utility.hashSet("jump");
+        final Date expires = new Date(2025, 5, 3);
+        final Date lastRefresh = new Date(2023, 8, 15);
+        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
+        final String applicationId = "1234";
+        final String userId = "1000";
+
+        AccessToken accessToken = new AccessToken(
+                token,
+                applicationId,
+                userId,
+                permissions,
+                declinedPermissions,
+                source,
+                expires,
+                lastRefresh);
+
+        assertEquals(token, accessToken.getToken());
+        assertEquals(expires, accessToken.getExpires());
+        assertEquals(lastRefresh, accessToken.getLastRefresh());
+        assertEquals(source, accessToken.getSource());
+        assertEquals(permissions, accessToken.getPermissions());
+        assertEquals(declinedPermissions, accessToken.getDeclinedPermissions());
+        assertEquals(applicationId, accessToken.getApplicationId());
+        assertEquals(userId, accessToken.getUserId());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/AccessTokenTestHelper.java b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTestHelper.java
new file mode 100644
index 000000000..49bda1adf
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTestHelper.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+public final class AccessTokenTestHelper {
+
+    public static Bundle toLegacyCacheBundle(AccessToken accessToken) {
+        Bundle bundle = new Bundle();
+
+        LegacyTokenHelper.putToken(bundle, accessToken.getToken());
+        LegacyTokenHelper.putDate(
+                bundle,
+                LegacyTokenHelper.EXPIRATION_DATE_KEY,
+                accessToken.getExpires());
+        LegacyTokenHelper.putPermissions(bundle, accessToken.getPermissions());
+        LegacyTokenHelper.putDeclinedPermissions(
+                bundle, accessToken.getDeclinedPermissions());
+        LegacyTokenHelper.putSource(bundle, accessToken.getSource());
+        LegacyTokenHelper.putDate(
+                bundle,
+                LegacyTokenHelper.LAST_REFRESH_DATE_KEY,
+                accessToken.getLastRefresh());
+        LegacyTokenHelper.putApplicationId(
+                bundle, accessToken.getApplicationId());
+
+        return bundle;
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/AccessTokenTrackerTest.java b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTrackerTest.java
new file mode 100644
index 000000000..3bbfa5910
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/AccessTokenTrackerTest.java
@@ -0,0 +1,158 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import static org.junit.Assert.*;
+import static org.powermock.api.mockito.PowerMockito.*;
+
+@PrepareForTest( { FacebookSdk.class })
+public class AccessTokenTrackerTest extends FacebookPowerMockTestCase {
+
+    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
+    private final Date EXPIRES = new Date(2025, 5, 3);
+    private final Date LAST_REFRESH = new Date(2023, 8, 15);
+    private final String APP_ID = "1234";
+    private final String USER_ID = "1000";
+
+    private LocalBroadcastManager localBroadcastManager;
+    private TestAccessTokenTracker accessTokenTracker = null;
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(FacebookSdk.class);
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);
+
+        localBroadcastManager = LocalBroadcastManager.getInstance(Robolectric.application);
+    }
+
+    @After
+    public void after() throws Exception {
+        if (accessTokenTracker != null && accessTokenTracker.isTracking()) {
+            accessTokenTracker.stopTracking();
+        }
+    }
+
+    @Test
+    public void testRequiresSdkToBeInitialized() {
+        try {
+            when(FacebookSdk.isInitialized()).thenReturn(false);
+
+            accessTokenTracker = new TestAccessTokenTracker();
+
+            fail();
+        } catch (FacebookSdkNotInitializedException exception) {
+        }
+    }
+
+    @Test
+    public void testDefaultsToTracking() {
+        accessTokenTracker = new TestAccessTokenTracker();
+
+        assertTrue(accessTokenTracker.isTracking());
+    }
+
+    @Test
+    public void testCanTurnTrackingOff() {
+        accessTokenTracker = new TestAccessTokenTracker();
+
+        accessTokenTracker.stopTracking();
+
+        assertFalse(accessTokenTracker.isTracking());
+    }
+
+    @Test
+    public void testCanTurnTrackingOn() {
+        accessTokenTracker = new TestAccessTokenTracker();
+
+        accessTokenTracker.stopTracking();
+        accessTokenTracker.startTracking();
+
+        assertTrue(accessTokenTracker.isTracking());
+    }
+
+    @Test
+    public void testCallbackCalledOnBroadcastReceived() throws Exception {
+        accessTokenTracker = new TestAccessTokenTracker();
+
+        AccessToken oldAccessToken = createAccessToken("I'm old!");
+        AccessToken currentAccessToken = createAccessToken("I'm current!");
+
+        sendBroadcast(oldAccessToken, currentAccessToken);
+
+
+        assertNotNull(accessTokenTracker.currentAccessToken);
+        assertEquals(currentAccessToken.getToken(), accessTokenTracker.currentAccessToken.getToken());
+        assertNotNull(accessTokenTracker.oldAccessToken);
+        assertEquals(oldAccessToken.getToken(), accessTokenTracker.oldAccessToken.getToken());
+    }
+
+    private AccessToken createAccessToken(String tokenString) {
+        return new AccessToken(
+                tokenString,
+                APP_ID,
+                USER_ID,
+                PERMISSIONS,
+                null,
+                AccessTokenSource.WEB_VIEW,
+                EXPIRES,
+                LAST_REFRESH);
+    }
+
+    private void sendBroadcast(AccessToken oldAccessToken, AccessToken currentAccessToken) {
+        Intent intent = new Intent(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED);
+
+        intent.putExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN, oldAccessToken);
+        intent.putExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN, currentAccessToken);
+
+        localBroadcastManager.sendBroadcast(intent);
+    }
+
+    class TestAccessTokenTracker extends AccessTokenTracker {
+
+        public AccessToken currentAccessToken;
+        public AccessToken oldAccessToken;
+
+        public TestAccessTokenTracker() {
+            super();
+        }
+
+        @Override
+        protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+            AccessToken currentAccessToken) {
+            this.oldAccessToken = oldAccessToken;
+            this.currentAccessToken = currentAccessToken;
+        }
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ApplicationTest.java b/facebook/junitTests/src/test/java/com/facebook/ApplicationTest.java
new file mode 100644
index 000000000..8754c0cfe
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ApplicationTest.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+
+import com.facebook.junittests.MainActivity;
+
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import static org.junit.Assert.*;
+
+public class ApplicationTest extends FacebookTestCase {
+    @Test
+    public void testCreateActivity() throws Exception {
+        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
+        assertTrue(activity != null);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ErrorClassificationTest.java b/facebook/junitTests/src/test/java/com/facebook/ErrorClassificationTest.java
new file mode 100644
index 000000000..960ec3658
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ErrorClassificationTest.java
@@ -0,0 +1,102 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import com.facebook.internal.FacebookRequestErrorClassification;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class ErrorClassificationTest extends FacebookTestCase {
+
+    @Test
+    public void testDefaultErrorClassification() {
+        FacebookRequestErrorClassification errorClassification =
+                FacebookRequestErrorClassification.getDefaultErrorClassification();
+        // Test transient takes precedence
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_INVALID_TOKEN,
+                        0,
+                        true)
+        );
+
+        assertEquals(
+                FacebookRequestError.Category.LOGIN_RECOVERABLE,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_INVALID_SESSION,
+                        0,
+                        false)
+        );
+
+        assertEquals(
+                FacebookRequestError.Category.LOGIN_RECOVERABLE,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_INVALID_TOKEN,
+                        0,
+                        false)
+        );
+
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_SERVICE_UNAVAILABLE,
+                        0,
+                        false)
+        );
+
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_APP_TOO_MANY_CALLS,
+                        0,
+                        false)
+        );
+
+
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_RATE,
+                        0,
+                        false)
+        );
+
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_USER_TOO_MANY_CALLS,
+                        0,
+                        false)
+        );
+
+
+        assertEquals(
+                FacebookRequestError.Category.TRANSIENT,
+                errorClassification.classify(
+                        FacebookRequestErrorClassification.EC_TOO_MANY_USER_ACTION_CALLS,
+                        0,
+                        false)
+        );
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/FacebookContentProviderTest.java b/facebook/junitTests/src/test/java/com/facebook/FacebookContentProviderTest.java
new file mode 100644
index 000000000..7818efc8f
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/FacebookContentProviderTest.java
@@ -0,0 +1,194 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.util.Pair;
+
+import com.facebook.internal.NativeAppCallAttachmentStore;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import static org.junit.Assert.*;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@PrepareForTest({ NativeAppCallAttachmentStore.class })
+public class FacebookContentProviderTest extends FacebookPowerMockTestCase {
+    private static final String APP_ID = "12345";
+    private static final UUID CALL_ID = UUID.randomUUID();
+    private static final String ATTACHMENT_NAME = "attachMe";
+
+    private FacebookContentProvider providerUnderTest;
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(NativeAppCallAttachmentStore.class);
+        providerUnderTest = new FacebookContentProvider();
+    }
+
+    @Test
+    public void testGetAttachmentUrl() {
+        String url = FacebookContentProvider.getAttachmentUrl(APP_ID, CALL_ID, ATTACHMENT_NAME);
+        assertEquals("content://com.facebook.app.FacebookContentProvider" +
+                APP_ID + "/" + CALL_ID + "/" + ATTACHMENT_NAME, url);
+    }
+
+    @Test
+    public void testOnCreate() throws Exception {
+        assertTrue(providerUnderTest.onCreate());
+    }
+
+    @Test
+    public void testQuery() throws Exception {
+        assertNull(providerUnderTest.query(null, null, null, null, null));
+    }
+
+    @Test
+    public void testGetType() throws Exception {
+        assertNull(providerUnderTest.getType(null));
+    }
+
+    @Test
+    public void testInsert() throws Exception {
+        assertNull(providerUnderTest.insert(null, null));
+    }
+
+    @Test
+    public void testDelete() throws Exception {
+        assertEquals(0, providerUnderTest.delete(null, null, null));
+    }
+
+    @Test
+    public void testUpdate() throws Exception {
+        assertEquals(0, providerUnderTest.update(null, null, null, null));
+    }
+
+    @SuppressWarnings("unused")
+    @Test
+    public void testOpenFileWithNullUri() throws Exception {
+        try {
+            ParcelFileDescriptor pfd = providerUnderTest.openFile(null, "r");
+            fail("expected FileNotFoundException");
+        } catch (FileNotFoundException e) {
+        }
+    }
+
+    @SuppressWarnings("unused")
+    @Test
+    public void testOpenFileWithBadPath() throws Exception {
+        try {
+            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/"), "r");
+            fail("expected FileNotFoundException");
+        } catch (FileNotFoundException e) {
+        }
+    }
+
+    @SuppressWarnings("unused")
+    @Test
+    public void testOpenFileWithoutCallIdAndAttachment() throws Exception {
+        try {
+            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo"), "r");
+            fail("expected FileNotFoundException");
+        } catch (FileNotFoundException e) {
+        }
+    }
+
+    @SuppressWarnings("unused")
+    @Test
+    public void testOpenFileWithBadCallID() throws Exception {
+        try {
+            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo/bar"), "r");
+            fail("expected FileNotFoundException");
+        } catch (FileNotFoundException e) {
+        }
+    }
+
+    @Test
+    public void testOpenFileWithUnknownUri() throws Exception {
+        try {
+            ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(UUID.randomUUID());
+            assertNotNull(pfd);
+            pfd.close();
+
+            fail("expected FileNotFoundException");
+        } catch (FileNotFoundException e) {
+        }
+    }
+
+    @Test
+    public void testOpenFileWithKnownUri() throws Exception {
+        MockAttachmentStore.addAttachment(CALL_ID, ATTACHMENT_NAME);
+
+        ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(CALL_ID);
+        assertNotNull(pfd);
+        pfd.close();
+    }
+
+    private ParcelFileDescriptor getTestAttachmentParcelFileDescriptor(UUID callId)
+            throws Exception {
+        when(NativeAppCallAttachmentStore.openAttachment(callId, ATTACHMENT_NAME))
+                .thenReturn(MockAttachmentStore.openAttachment(callId, ATTACHMENT_NAME));
+
+        Uri uri = Uri.parse(
+                FacebookContentProvider.getAttachmentUrl(APP_ID, callId, ATTACHMENT_NAME));
+
+        return providerUnderTest.openFile(uri, "r");
+    }
+
+    static class MockAttachmentStore {
+        private static List<Pair<UUID, String>> attachments = new ArrayList<>();
+        private static final String DUMMY_FILE_NAME = "dummyfile";
+
+        public static void addAttachment(UUID callId, String attachmentName) {
+            attachments.add(new Pair<>(callId, attachmentName));
+        }
+
+        public static File openAttachment(UUID callId, String attachmentName)
+                throws FileNotFoundException {
+            if (attachments.contains(new Pair<>(callId, attachmentName))) {
+                File cacheDir = Robolectric.application.getCacheDir();
+                File dummyFile = new File(cacheDir, DUMMY_FILE_NAME);
+                if (!dummyFile.exists()) {
+                    try {
+                        dummyFile.createNewFile();
+                    } catch (IOException e) {
+                    }
+                }
+
+                return dummyFile;
+            }
+
+            throw new FileNotFoundException();
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java b/facebook/junitTests/src/test/java/com/facebook/FacebookGraphRequestErrorTest.java
similarity index 80%
rename from facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
rename to facebook/junitTests/src/test/java/com/facebook/FacebookGraphRequestErrorTest.java
index 63377e889..3b03fbf66 100644
--- a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/FacebookGraphRequestErrorTest.java
@@ -1,27 +1,35 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
-import com.facebook.sdk.tests.R;
+import com.facebook.junittests.R;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
 
-public class FacebookRequestErrorTests extends FacebookTestCase {
+public class FacebookGraphRequestErrorTest extends FacebookTestCase {
     public static final String ERROR_SINGLE_RESPONSE =
             "{\n" +
             "  \"error\": {\n" +
@@ -158,50 +166,55 @@
             "  }\n" +
             "}";
 
+    @Test
     public void testClientException() {
         final String errorMsg = "some error happened";
-        FacebookRequestError error = new FacebookRequestError(null, new FacebookException(errorMsg));
+        FacebookRequestError error =
+                new FacebookRequestError(null, new FacebookException(errorMsg));
         assertEquals(errorMsg, error.getErrorMessage());
-        assertEquals(FacebookRequestError.Category.CLIENT, error.getCategory());
+        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
         assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
         assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
-        assertEquals(0, error.getUserActionMessageId());
     }
 
+    @Test
     public void testSingleRequestWithoutBody() throws JSONException {
         JSONObject withStatusCode = new JSONObject();
         withStatusCode.put("code", 400);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCode, withStatusCode, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCode, withStatusCode, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
     }
 
+    @Test
     public void testSingleErrorWithBody() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 400);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
         assertEquals("Unknown path components: /unknown", error.getErrorMessage());
         assertEquals("OAuthException", error.getErrorType());
         assertEquals(2500, error.getErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
     }
 
+    @Test
     public void testBatchRequest() throws JSONException {
         JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
         assertEquals(2, batchResponse.length());
         JSONObject firstResponse = (JSONObject) batchResponse.get(0);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(firstResponse, batchResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        firstResponse, batchResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
         assertEquals("An active access token must be used to query information about the current user.",
@@ -209,69 +222,75 @@ public void testBatchRequest() throws JSONException {
         assertEquals("OAuthException", error.getErrorType());
         assertEquals(2500, error.getErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
     }
 
+    @Test
     public void testSingleThrottledError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 403);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(403, error.getRequestStatusCode());
         assertEquals("Application request limit reached", error.getErrorMessage());
         assertNull(error.getErrorType());
         assertEquals(4, error.getErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.THROTTLING, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
     }
 
+    @Test
     public void testSingleServerError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 500);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(500, error.getRequestStatusCode());
         assertEquals("Some Server Error", error.getErrorMessage());
         assertNull(error.getErrorType());
         assertEquals(2, error.getErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.SERVER, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
     }
 
+    @Test
     public void testSinglePermissionError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 400);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
-        assertEquals("(#200) Requires extended permission: publish_actions", error.getErrorMessage());
+        assertEquals(
+                "(#200) Requires extended permission: publish_actions",
+                error.getErrorMessage());
         assertEquals("OAuthException", error.getErrorType());
         assertEquals(200, error.getErrorCode());
         assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.PERMISSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_permissions, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
     }
 
+    @Test
     public void testSingleWebLoginError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 400);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
         assertEquals("User need to login", error.getErrorMessage());
@@ -279,17 +298,18 @@ public void testSingleWebLoginError() throws JSONException {
         assertEquals(102, error.getErrorCode());
         assertEquals(459, error.getSubErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_RETRY, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_web_login, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
     }
 
+    @Test
     public void testSingleReloginError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 400);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
         assertEquals("User need to relogin", error.getErrorMessage());
@@ -297,17 +317,18 @@ public void testSingleReloginError() throws JSONException {
         assertEquals(102, error.getErrorCode());
         assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_reconnect, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
     }
 
+    @Test
     public void testSingleReloginDeletedAppError() throws JSONException {
         JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
         JSONObject withStatusCodeAndBody = new JSONObject();
         withStatusCodeAndBody.put("code", 400);
         withStatusCodeAndBody.put("body", originalResponse);
         FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+                FacebookRequestError.checkResponseAndCreateError(
+                        withStatusCodeAndBody, originalResponse, null);
         assertNotNull(error);
         assertEquals(400, error.getRequestStatusCode());
         assertEquals("User need to relogin", error.getErrorMessage());
@@ -315,7 +336,6 @@ public void testSingleReloginDeletedAppError() throws JSONException {
         assertEquals(190, error.getErrorCode());
         assertEquals(458, error.getSubErrorCode());
         assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_relogin, error.getUserActionMessageId());
+        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
     }
 }
diff --git a/facebook/junitTests/src/test/java/com/facebook/FacebookPowerMockTestCase.java b/facebook/junitTests/src/test/java/com/facebook/FacebookPowerMockTestCase.java
new file mode 100644
index 000000000..fe94ceeaa
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/FacebookPowerMockTestCase.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+// ShadowLog is used to redirect the android.util.Log calls to System.out
+@Config(shadows = {ShadowLog.class})
+@RunWith(RobolectricTestRunner.class)
+@PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*", "org.json.*" })
+
+/**
+ * Base class for PowerMock tests.
+ * Important: the classes that derive from this should end with Test (i.e. not Tests) otherwise the
+ * gradle task "test" doesn't pick them up.
+ */
+public abstract class FacebookPowerMockTestCase {
+    @Rule
+    public PowerMockRule rule = new PowerMockRule();
+
+    @Before
+    public void setUp() {
+        ShadowLog.stream = System.out;
+        MockitoAnnotations.initMocks(this);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/FacebookSdkPowerMockTest.java b/facebook/junitTests/src/test/java/com/facebook/FacebookSdkPowerMockTest.java
new file mode 100644
index 000000000..cc8d157d5
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/FacebookSdkPowerMockTest.java
@@ -0,0 +1,195 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.ConditionVariable;
+
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.reflect.Whitebox;
+import org.robolectric.Robolectric;
+
+import java.util.concurrent.Executor;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.powermock.api.support.membermodification.MemberMatcher.method;
+import static org.powermock.api.support.membermodification.MemberModifier.stub;
+
+@PrepareForTest({ FacebookSdk.class, Utility.class })
+public final class FacebookSdkPowerMockTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() {
+        Whitebox.setInternalState(FacebookSdk.class, "callbackRequestCodeOffset", 0xface);
+        Whitebox.setInternalState(FacebookSdk.class, "sdkInitialized", false);
+        stub(method(Utility.class, "loadAppSettingsAsync")).toReturn(null);
+
+    }
+
+    @Test
+    public void testGetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                condition.open();
+            }
+        });
+
+        boolean success = condition.block(5000);
+        assertTrue(success);
+    }
+
+    @Test
+    public void testSetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        final Runnable runnable = new Runnable() {
+            @Override
+            public void run() { }
+        };
+
+        final Executor executor = new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                assertEquals(runnable, command);
+                command.run();
+
+                condition.open();
+            }
+        };
+
+        Executor original = FacebookSdk.getExecutor();
+        try {
+            FacebookSdk.setExecutor(executor);
+            FacebookSdk.getExecutor().execute(runnable);
+
+            boolean success = condition.block(5000);
+            assertTrue(success);
+        } finally {
+            FacebookSdk.setExecutor(original);
+        }
+    }
+
+    @Test
+    public void testFacebookDomain() {
+        FacebookSdk.setFacebookDomain("beta.facebook.com");
+
+        String graphUrlBase = ServerProtocol.getGraphUrlBase();
+        assertEquals("https://graph.beta.facebook.com", graphUrlBase);
+
+        FacebookSdk.setFacebookDomain("facebook.com");
+    }
+
+    @Test
+    public void testLoadDefaults() throws Exception {
+        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
+        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());
+
+        assertEquals("1234", FacebookSdk.getApplicationId());
+        assertEquals("abcd", FacebookSdk.getClientToken());
+    }
+
+
+    private Context mockContextWithAppIdAndClientToken() throws Exception {
+        Bundle bundle = mock(Bundle.class);
+
+        when(bundle.get(FacebookSdk.APPLICATION_ID_PROPERTY)).thenReturn("1234");
+        when(bundle.getString(FacebookSdk.CLIENT_TOKEN_PROPERTY)).thenReturn("abcd");
+        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
+        applicationInfo.metaData = bundle;
+
+        PackageManager packageManager = mock(PackageManager.class);
+        when(packageManager.getApplicationInfo("packageName", PackageManager.GET_META_DATA))
+                .thenReturn(applicationInfo);
+
+        Context context = mock(Context.class);
+        when(context.getPackageName()).thenReturn("packageName");
+        when(context.getPackageManager()).thenReturn(packageManager);
+        return context;
+    }
+
+    @Test
+    public void testLoadDefaultsDoesNotOverwrite() throws Exception {
+        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
+        FacebookSdk.setApplicationId("hello");
+        FacebookSdk.setClientToken("world");
+
+        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());
+
+        assertEquals("hello", FacebookSdk.getApplicationId());
+        assertEquals("world", FacebookSdk.getClientToken());
+    }
+
+    @Test
+    public void testRequestCodeOffsetAfterInit() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+
+        try {
+            FacebookSdk.sdkInitialize(Robolectric.application, 1000);
+            fail();
+        } catch (FacebookException exception) {
+            assertEquals(FacebookSdk.CALLBACK_OFFSET_CHANGED_AFTER_INIT, exception.getMessage());
+        }
+    }
+
+    @Test
+    public void testRequestCodeOffsetNegative() throws Exception {
+        try {
+            // last bit set, so negative
+            FacebookSdk.sdkInitialize(Robolectric.application, 0xFACEB00C);
+            fail();
+        } catch (FacebookException exception) {
+            assertEquals(FacebookSdk.CALLBACK_OFFSET_NEGATIVE, exception.getMessage());
+        }
+    }
+
+    @Test
+    public void testRequestCodeOffset() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application, 1000);
+        assertEquals(1000, FacebookSdk.getCallbackRequestCodeOffset());
+    }
+
+    @Test
+    public void testRequestCodeRange() {
+        FacebookSdk.sdkInitialize(Robolectric.application, 1000);
+        assertTrue(FacebookSdk.isFacebookRequestCode(1000));
+        assertTrue(FacebookSdk.isFacebookRequestCode(1099));
+        assertFalse(FacebookSdk.isFacebookRequestCode(999));
+        assertFalse(FacebookSdk.isFacebookRequestCode(1100));
+        assertFalse(FacebookSdk.isFacebookRequestCode(0));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/FacebookTestCase.java b/facebook/junitTests/src/test/java/com/facebook/FacebookTestCase.java
new file mode 100644
index 000000000..9d8579759
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/FacebookTestCase.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import org.junit.Before;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+// ShadowLog is used to redirect the android.util.Log calls to System.out
+@Config(shadows = {ShadowLog.class})
+@RunWith(RobolectricTestRunner.class)
+
+/**
+ * Base class for Robolectric tests.
+ * Important: the classes that derive from this should end with Test (i.e. not Tests) otherwise the
+ * gradle task "test" doesn't pick them up.
+ */
+public abstract class FacebookTestCase {
+    @Before
+    public void setUp() {
+        ShadowLog.stream = System.out;
+        MockitoAnnotations.initMocks(this);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/GraphErrorTest.java b/facebook/junitTests/src/test/java/com/facebook/GraphErrorTest.java
new file mode 100644
index 000000000..ad84cdbf5
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/GraphErrorTest.java
@@ -0,0 +1,88 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import com.facebook.internal.FacebookRequestErrorClassification;
+import com.facebook.internal.Utility;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+
+import static org.junit.Assert.*;
+import static org.powermock.api.mockito.PowerMockito.doNothing;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+import static org.powermock.api.support.membermodification.MemberMatcher.method;
+import static org.powermock.api.support.membermodification.MemberModifier.stub;
+import static org.powermock.api.support.membermodification.MemberModifier.suppress;
+
+@PrepareForTest( {
+        AccessToken.class,
+        AccessTokenCache.class,
+        FacebookSdk.class,
+        GraphRequest.class,
+        Utility.class
+})
+public final class GraphErrorTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(FacebookSdk.class);
+        suppress(method(Utility.class, "clearFacebookCookies"));
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);
+        stub(method(AccessTokenCache.class, "save")).toReturn(null);
+    }
+
+    @Test
+    public void testAccessTokenResetOnTokenError() throws JSONException, IOException {
+        AccessToken accessToken = mock(AccessToken.class);
+        AccessToken.setCurrentAccessToken(accessToken);
+
+        JSONObject errorBody = new JSONObject();
+        errorBody.put("message", "Invalid OAuth access token.");
+        errorBody.put("type", "OAuthException");
+        errorBody.put("code", FacebookRequestErrorClassification.EC_INVALID_TOKEN);
+        JSONObject error = new JSONObject();
+        error.put("error", errorBody);
+        String errorString = error.toString();
+
+        HttpURLConnection connection = mock(HttpURLConnection.class);
+        when(connection.getResponseCode()).thenReturn(400);
+
+        GraphRequest request = mock(GraphRequest.class);
+        when(request.getAccessToken()).thenReturn(accessToken);
+        GraphRequestBatch batch = new GraphRequestBatch(request);
+
+        assertNotNull(AccessToken.getCurrentAccessToken());
+        GraphResponse.createResponsesFromString(errorString, connection, batch);
+        assertNull(AccessToken.getCurrentAccessToken());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/GraphRequestTest.java b/facebook/junitTests/src/test/java/com/facebook/GraphRequestTest.java
new file mode 100644
index 000000000..7f9104600
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/GraphRequestTest.java
@@ -0,0 +1,338 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.facebook.internal.GraphUtil;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.share.internal.ShareInternalUtility;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+
+import java.net.HttpURLConnection;
+
+import static org.junit.Assert.*;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@PrepareForTest( { FacebookSdk.class, AccessTokenManager.class })
+public class GraphRequestTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() {
+        mockStatic(FacebookSdk.class);
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        when(FacebookSdk.getApplicationId()).thenReturn("1234");
+        when(FacebookSdk.getClientToken()).thenReturn("5678");
+    }
+
+    @Test
+    public void testCreateRequest() {
+        GraphRequest request = new GraphRequest();
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @Test
+    public void testCreatePostRequest() {
+        JSONObject graphObject = new JSONObject();
+        GraphRequest request = GraphRequest.newPostRequest(null, "me/statuses", graphObject, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.POST, request.getHttpMethod());
+        assertEquals("me/statuses", request.getGraphPath());
+        assertEquals(graphObject, request.getGraphObject());
+    }
+
+    @Test
+    public void testCreateMeRequest() {
+        GraphRequest request = GraphRequest.newMeRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me", request.getGraphPath());
+    }
+
+    @Test
+    public void testCreateMyFriendsRequest() {
+        GraphRequest request = GraphRequest.newMyFriendsRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me/friends", request.getGraphPath());
+    }
+
+    @Test
+    public void testCreateUploadPhotoRequest() {
+        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
+
+        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(null, image, null, null);
+        assertTrue(request != null);
+
+        Bundle parameters = request.getParameters();
+        assertTrue(parameters != null);
+
+        assertTrue(parameters.containsKey("picture"));
+        assertEquals(image, parameters.getParcelable("picture"));
+        assertEquals("me/photos", request.getGraphPath());
+    }
+
+    @Test
+    public void testCreatePlacesSearchRequestWithLocation() {
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, location, 1000, 50, null, null);
+
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
+    }
+
+    @Test
+    public void testCreatePlacesSearchRequestWithSearchText() {
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);
+
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
+    }
+
+    @Test
+    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
+        try {
+            GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequestRequiresObject() {
+        try {
+            ShareInternalUtility.newPostOpenGraphObjectRequest(null, null, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequestRequiresObjectType() {
+        try {
+            JSONObject object = GraphUtil.createOpenGraphObjectForPost(null);
+            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyObjectType() throws JSONException {
+        try {
+            JSONObject object = GraphUtil.createOpenGraphObjectForPost("");
+            object.put("title", "bar");
+            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequestRequiresTitle() {
+        try {
+            JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
+            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyTitle() throws JSONException {
+        try {
+            JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
+            object.put("title", "");
+            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphObjectRequest() throws JSONException {
+        JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
+        object.put("title", "bar");
+        GraphRequest request = ShareInternalUtility.newPostOpenGraphObjectRequest(
+                null,
+                object,
+                null);
+        assertNotNull(request);
+    }
+
+    @Test
+    public void testNewPostOpenGraphActionRequestRequiresAction() {
+        try {
+            ShareInternalUtility.newPostOpenGraphActionRequest(null, null, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphActionRequestRequiresActionType() {
+        try {
+            JSONObject action = GraphUtil.createOpenGraphActionForPost(null);
+            ShareInternalUtility.newPostOpenGraphActionRequest(null, action, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphActionRequestRequiresNonEmptyActionType() {
+        try {
+            JSONObject action = GraphUtil.createOpenGraphActionForPost("");
+            ShareInternalUtility.newPostOpenGraphActionRequest(null, action, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @Test
+    public void testNewPostOpenGraphActionRequest() {
+        JSONObject action = GraphUtil.createOpenGraphActionForPost("foo");
+        GraphRequest request = ShareInternalUtility.newPostOpenGraphActionRequest(
+                null,
+                action,
+                null);
+        assertNotNull(request);
+    }
+
+    @Test
+    public void testSetHttpMethodToNilGivesDefault() {
+        GraphRequest request = new GraphRequest();
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+
+        request.setHttpMethod(null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @Test
+    public void testExecuteBatchWithNullRequestsThrows() {
+        try {
+            GraphRequest.executeBatchAndWait((GraphRequest[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testExecuteBatchWithZeroRequestsThrows() {
+        try {
+            GraphRequest.executeBatchAndWait(new GraphRequest[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @Test
+    public void testExecuteBatchWithNullRequestThrows() {
+        try {
+            GraphRequest.executeBatchAndWait(new GraphRequest[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testToHttpConnectionWithNullRequestsThrows() {
+        try {
+            GraphRequest.toHttpConnection((GraphRequest[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testToHttpConnectionWithZeroRequestsThrows() {
+        try {
+            GraphRequest.toHttpConnection(new GraphRequest[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @Test
+    public void testToHttpConnectionWithNullRequestThrows() {
+        try {
+            GraphRequest.toHttpConnection(new GraphRequest[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testSingleGetToHttpRequest() throws Exception {
+        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
+        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);
+
+        assertTrue(connection != null);
+
+        assertEquals("GET", connection.getRequestMethod());
+        assertEquals("/" + ServerProtocol.getAPIVersion() + "/TourEiffel",
+            connection.getURL().getPath());
+
+        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));
+
+        Uri uri = Uri.parse(connection.getURL().toString());
+        assertEquals("android", uri.getQueryParameter("sdk"));
+        assertEquals("json", uri.getQueryParameter("format"));
+    }
+
+    @Test
+    public void testBuildsClientTokenIfNeeded() throws Exception {
+        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
+        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);
+
+        assertTrue(connection != null);
+
+        Uri uri = Uri.parse(connection.getURL().toString());
+        String accessToken = uri.getQueryParameter("access_token");
+        assertNotNull(accessToken);
+        assertTrue(accessToken.contains(FacebookSdk.getApplicationId()));
+        assertTrue(accessToken.contains(FacebookSdk.getClientToken()));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/GraphUtilTest.java b/facebook/junitTests/src/test/java/com/facebook/GraphUtilTest.java
new file mode 100644
index 000000000..a89fcf846
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/GraphUtilTest.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import com.facebook.internal.GraphUtil;
+import com.facebook.internal.NativeProtocol;
+
+import org.json.JSONObject;
+import org.junit.Test;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import static org.junit.Assert.*;
+
+public class GraphUtilTest extends FacebookTestCase {
+    @Test
+    public void testIsOpenGraphObjectForPost() {
+        JSONObject jsonObject = mock(JSONObject.class);
+        when(jsonObject.optBoolean(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)).thenReturn(true);
+        assertTrue(GraphUtil.isOpenGraphObjectForPost(jsonObject));
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java b/facebook/junitTests/src/test/java/com/facebook/LegacyTokenCacheTest.java
similarity index 64%
rename from facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
rename to facebook/junitTests/src/test/java/com/facebook/LegacyTokenCacheTest.java
index bab3fb38f..03bece4c9 100644
--- a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/LegacyTokenCacheTest.java
@@ -1,34 +1,49 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
+
 import com.facebook.internal.Utility;
-import junit.framework.Assert;
+
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
 
 import java.lang.reflect.Array;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
 
+import static org.junit.Assert.*;
+import static org.powermock.api.support.membermodification.MemberModifier.stub;
 
-public final class SharedPreferencesTokenCacheTests extends AndroidTestCase {
+@PrepareForTest( {Utility.class})
+public final class LegacyTokenCacheTest extends FacebookPowerMockTestCase {
 
     private static final String BOOLEAN_KEY = "booleanKey";
     private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
@@ -52,9 +67,20 @@
 
     private static Random random = new Random((new Date()).getTime());
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Override
+    public void setUp() {
+        super.setUp();
+
+        FacebookSdk.sdkInitialize(Robolectric.application);
+    }
+
+    @Before
+    public void before() throws Exception {
+        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
+                new JSONObject().put("id", "1000"));
+    }
+
+    @Test
     public void testAllTypes() {
         Bundle originalBundle = new Bundle();
 
@@ -80,38 +106,36 @@ public void testAllTypes() {
 
         ensureApplicationContext();
 
-        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
+        LegacyTokenHelper cache = new LegacyTokenHelper(Robolectric.application);
         cache.save(originalBundle);
 
-        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
+        LegacyTokenHelper cache2 = new LegacyTokenHelper(Robolectric.application);
         Bundle cachedBundle = cache2.load();
 
-        Assert.assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
+        assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
         assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
+        assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
         assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
+        assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
         assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
+        assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
         assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
+        assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
         assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY));
+        assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
         assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY));
+        assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
         assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
+        assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
         assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
+        assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
         assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
                 STRING_LIST_KEY));
-        Assert.assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
+        assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
                 cachedBundle.getSerializable(SERIALIZABLE_KEY));
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testMultipleCaches() {
         Bundle bundle1 = new Bundle(), bundle2 = new Bundle();
 
@@ -122,84 +146,90 @@ public void testMultipleCaches() {
 
         ensureApplicationContext();
 
-        SharedPreferencesTokenCachingStrategy cache1 = new SharedPreferencesTokenCachingStrategy(getContext());
-        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
+        LegacyTokenHelper cache1 = new LegacyTokenHelper(Robolectric.application);
+        LegacyTokenHelper cache2 = new LegacyTokenHelper(Robolectric.application, "CustomCache");
 
         cache1.save(bundle1);
         cache2.save(bundle2);
 
         // Get new references to make sure we are getting persisted data.
         // Reverse the cache references for fun.
-        cache1 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
-        cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
+        cache1 = new LegacyTokenHelper(Robolectric.application, "CustomCache");
+        cache2 = new LegacyTokenHelper(Robolectric.application);
 
         Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();
 
-        Assert.assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
-        Assert.assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
-        Assert.assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
-        Assert.assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
+        assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
+        assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
+        assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
+        assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testCacheRoundtrip() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
         String token = "AnImaginaryTokenValue";
         Date later = TestUtils.nowPlusSeconds(60);
         Date earlier = TestUtils.nowPlusSeconds(-60);
+        String applicationId = "1234";
 
-        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
+        LegacyTokenHelper cache =
+                new LegacyTokenHelper(Robolectric.application);
         cache.clear();
 
         Bundle bundle = new Bundle();
-        TokenCachingStrategy.putToken(bundle, token);
-        TokenCachingStrategy.putExpirationDate(bundle, later);
-        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
-        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
-        TokenCachingStrategy.putPermissions(bundle, permissions);
+        LegacyTokenHelper.putToken(bundle, token);
+        LegacyTokenHelper.putExpirationDate(bundle, later);
+        LegacyTokenHelper.putSource(
+                bundle,
+                AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
+        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
+        LegacyTokenHelper.putPermissions(bundle, permissions);
+        LegacyTokenHelper.putDeclinedPermissions(
+                bundle,
+                Utility.arrayList("whatever"));
+        LegacyTokenHelper.putApplicationId(bundle, applicationId);
 
         cache.save(bundle);
         bundle = cache.load();
 
-        AccessToken accessToken = AccessToken.createFromCache(bundle);
+        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
         TestUtils.assertSamePermissions(permissions, accessToken);
         assertEquals(token, accessToken.getToken());
         assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
+        assertTrue(!accessToken.isExpired());
 
-        Bundle cachedBundle = accessToken.toCacheBundle();
+        Bundle cachedBundle = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
         TestUtils.assertEqualContents(bundle, cachedBundle);
     }
 
     private static void assertArrayEquals(Object a1, Object a2) {
-        Assert.assertNotNull(a1);
-        Assert.assertNotNull(a2);
-        Assert.assertEquals(a1.getClass(), a2.getClass());
-        Assert.assertTrue("Not an array", a1.getClass().isArray());
+        assertNotNull(a1);
+        assertNotNull(a2);
+        assertEquals(a1.getClass(), a2.getClass());
+        assertTrue("Not an array", a1.getClass().isArray());
 
         int length = Array.getLength(a1);
-        Assert.assertEquals(length, Array.getLength(a2));
+        assertEquals(length, Array.getLength(a2));
         for (int i = 0; i < length; i++) {
             Object a1Value = Array.get(a1, i);
             Object a2Value = Array.get(a2, i);
 
-            Assert.assertEquals(a1Value, a2Value);
+            assertEquals(a1Value, a2Value);
         }
     }
 
     private static void assertListEquals(List<?> l1, List<?> l2) {
-        Assert.assertNotNull(l1);
-        Assert.assertNotNull(l2);
+        assertNotNull(l1);
+        assertNotNull(l2);
 
         Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
         while (i1.hasNext() && i2.hasNext()) {
-            Assert.assertEquals(i1.next(), i2.next());
+            assertEquals(i1.next(), i2.next());
         }
 
-        Assert.assertTrue("Lists not of the same length", !i1.hasNext());
-        Assert.assertTrue("Lists not of the same length", !i2.hasNext());
+        assertTrue("Lists not of the same length", !i1.hasNext());
+        assertTrue("Lists not of the same length", !i2.hasNext());
     }
 
     private static void putInt(String key, Bundle bundle) {
@@ -337,7 +367,7 @@ private void ensureApplicationContext() {
         long waitedFor = 0;
         try {
             // Don't hold up execution for too long.
-            while (getContext().getApplicationContext() == null && waitedFor <= 2000) {
+            while (Robolectric.application.getApplicationContext() == null && waitedFor <= 2000) {
                 Thread.sleep(50);
                 waitedFor += 50;
             }
diff --git a/facebook/junitTests/src/test/java/com/facebook/PowerMockIntegrationTest.java b/facebook/junitTests/src/test/java/com/facebook/PowerMockIntegrationTest.java
new file mode 100644
index 000000000..873299207
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/PowerMockIntegrationTest.java
@@ -0,0 +1,46 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import static org.powermock.api.mockito.PowerMockito.*;
+import static org.junit.Assert.*;
+
+/**
+ * This test makes sure PowerMock integration works.
+ */
+@PrepareForTest( { FacebookSdk.class })
+public class PowerMockIntegrationTest extends FacebookPowerMockTestCase {
+
+    @Test
+    public void testStaticMethodOverrides() {
+        mockStatic(FacebookSdk.class);
+        String applicationId = "1234";
+
+        when(FacebookSdk.getApplicationId()).thenReturn(applicationId);
+        assertEquals(applicationId, FacebookSdk.getApplicationId());
+
+        String clientToken = "clienttoken";
+        when(FacebookSdk.getClientToken()).thenReturn(clientToken);
+        assertEquals(clientToken, FacebookSdk.getClientToken());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ProfileCacheTest.java b/facebook/junitTests/src/test/java/com/facebook/ProfileCacheTest.java
new file mode 100644
index 000000000..f9c122793
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ProfileCacheTest.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import static org.junit.Assert.*;
+
+public final class ProfileCacheTest extends FacebookTestCase {
+    @Before
+    public void before() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        Robolectric.application.getSharedPreferences(
+                ProfileCache.SHARED_PREFERENCES_NAME,
+                Context.MODE_PRIVATE)
+                .edit().
+                clear().
+                commit();
+    }
+
+    @Test
+    public void testEmptyCase() {
+        ProfileCache cache = new ProfileCache();
+        assertNull(cache.load());
+    }
+
+    @Test
+    public void testSaveGetAndClear() {
+        ProfileCache cache = new ProfileCache();
+        Profile profile1 = ProfileTest.createDefaultProfile();
+        cache.save(profile1);
+        Profile profile2 = cache.load();
+        ProfileTest.assertDefaultObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+
+        profile1 = ProfileTest.createMostlyNullsProfile();
+        cache.save(profile1);
+        profile2 = cache.load();
+        ProfileTest.assertMostlyNullsObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+
+        cache.clear();
+        assertNull(cache.load());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ProfileManagerTest.java b/facebook/junitTests/src/test/java/com/facebook/ProfileManagerTest.java
new file mode 100644
index 000000000..921ade1a6
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ProfileManagerTest.java
@@ -0,0 +1,89 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.InputMismatchException;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.powermock.api.mockito.PowerMockito.mock;
+
+@PrepareForTest( { ProfileCache.class })
+public class ProfileManagerTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+    }
+
+    @Test
+    public void testLoadCurrentProfileEmptyCache() {
+        ProfileCache profileCache = mock(ProfileCache.class);
+        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
+        ProfileManager profileManager = new ProfileManager(
+                localBroadcastManager,
+                profileCache
+        );
+        assertFalse(profileManager.loadCurrentProfile());
+        verify(profileCache, times(1)).load();
+    }
+
+    @Test
+    public void testLoadCurrentProfileWithCache() {
+        ProfileCache profileCache = mock(ProfileCache.class);
+        Profile profile = ProfileTest.createDefaultProfile();
+        when(profileCache.load()).thenReturn(profile);
+        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
+        ProfileManager profileManager = new ProfileManager(
+                localBroadcastManager,
+                profileCache
+        );
+        assertTrue(profileManager.loadCurrentProfile());
+        verify(profileCache, times(1)).load();
+
+        // Verify that we don't save it back
+        verify(profileCache, never()).save(any(Profile.class));
+
+        // Verify that we broadcast
+        verify(localBroadcastManager).sendBroadcast(any(Intent.class));
+
+        // Verify that if we set the same (semantically) profile there is no additional broadcast.
+        profileManager.setCurrentProfile(ProfileTest.createDefaultProfile());
+        verify(localBroadcastManager, times(1)).sendBroadcast(any(Intent.class));
+
+        // Verify that if we unset the profile there is a broadcast
+        profileManager.setCurrentProfile(null);
+        verify(localBroadcastManager, times(2)).sendBroadcast(any(Intent.class));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ProfileTest.java b/facebook/junitTests/src/test/java/com/facebook/ProfileTest.java
new file mode 100644
index 000000000..7ff282054
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ProfileTest.java
@@ -0,0 +1,147 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.net.Uri;
+import android.os.Parcel;
+
+import org.json.JSONObject;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import static org.junit.Assert.*;
+
+public final class ProfileTest extends FacebookTestCase {
+    static final String ID = "ID";
+    static final String ANOTHER_ID = "ANOTHER_ID";
+    static final String FIRST_NAME = "FIRST_NAME";
+    static final String MIDDLE_NAME = "MIDDLE_NAME";
+    static final String LAST_NAME = "LAST_NAME";
+    static final String NAME = "NAME";
+    static final Uri LINK_URI = Uri.parse("https://www.facebook.com/name");
+
+    public static Profile createDefaultProfile() {
+        return new Profile(
+                ID,
+                FIRST_NAME,
+                MIDDLE_NAME,
+                LAST_NAME,
+                NAME,
+                LINK_URI
+        );
+    }
+
+    static void assertDefaultObjectGetters(Profile profile) {
+        assertEquals(ID, profile.getId());
+        assertEquals(FIRST_NAME, profile.getFirstName());
+        assertEquals(MIDDLE_NAME, profile.getMiddleName());
+        assertEquals(LAST_NAME, profile.getLastName());
+        assertEquals(NAME, profile.getName());
+        assertEquals(LINK_URI, profile.getLinkUri());
+    }
+
+    static Profile createMostlyNullsProfile() {
+        return new Profile(ANOTHER_ID, null, null, null, null, null);
+    }
+
+    static void assertMostlyNullsObjectGetters(Profile profile) {
+        assertEquals(ANOTHER_ID, profile.getId());
+        assertNull(profile.getFirstName());
+        assertNull(profile.getMiddleName());
+        assertNull(profile.getLastName());
+        assertNull(profile.getName());
+        assertNull(profile.getLinkUri());
+    }
+
+
+    @Test
+    public void testProfileCtorAndGetters() {
+        Profile profile = createDefaultProfile();
+        assertDefaultObjectGetters(profile);
+
+        profile = createMostlyNullsProfile();
+        assertMostlyNullsObjectGetters(profile);
+    }
+
+    @Test
+    public void testHashCode() {
+        Profile profile1 = createDefaultProfile();
+        Profile profile2 = createDefaultProfile();
+        assertEquals(profile1.hashCode(), profile2.hashCode());
+
+        Profile profile3 = createMostlyNullsProfile();
+        assertNotEquals(profile1.hashCode(), profile3.hashCode());
+    }
+
+    @Test
+    public void testEquals() {
+        Profile profile1 = createDefaultProfile();
+        Profile profile2 = createDefaultProfile();
+        assertEquals(profile1, profile2);
+
+        Profile profile3 = createMostlyNullsProfile();
+        assertNotEquals(profile1, profile3);
+    }
+
+    @Test
+    public void testJsonSerialization() {
+        Profile profile1 = createDefaultProfile();
+        JSONObject jsonObject = profile1.toJSONObject();
+        Profile profile2 = new Profile(jsonObject);
+        assertDefaultObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+
+        // Check with nulls
+        profile1 = createMostlyNullsProfile();
+        jsonObject = profile1.toJSONObject();
+        profile2 = new Profile(jsonObject);
+        assertMostlyNullsObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+    }
+
+    @Test
+    public void testParcelSerialization() {
+        Profile profile1 = createDefaultProfile();
+        Profile profile2 = TestUtils.parcelAndUnparcel(profile1);
+
+        assertDefaultObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+
+        // Check with nulls
+        profile1 = createMostlyNullsProfile();
+        profile2 = TestUtils.parcelAndUnparcel(profile1);
+        assertMostlyNullsObjectGetters(profile2);
+        assertEquals(profile1, profile2);
+    }
+
+    @Test
+    public void testGetSetCurrentProfile() {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        Profile profile1 = createDefaultProfile();
+        Profile.setCurrentProfile(profile1);
+        assertEquals(ProfileManager.getInstance().getCurrentProfile(), profile1);
+        assertEquals(profile1, Profile.getCurrentProfile());
+
+        Profile.setCurrentProfile(null);
+        assertNull(ProfileManager.getInstance().getCurrentProfile());
+        assertNull(Profile.getCurrentProfile());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ProfileTrackerTest.java b/facebook/junitTests/src/test/java/com/facebook/ProfileTrackerTest.java
new file mode 100644
index 000000000..ede333d17
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ProfileTrackerTest.java
@@ -0,0 +1,89 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import static org.junit.Assert.*;
+
+public class ProfileTrackerTest extends FacebookPowerMockTestCase {
+    @Test
+    public void testStartStopTrackingAndBroadcast() {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        LocalBroadcastManager localBroadcastManager =
+                LocalBroadcastManager.getInstance(Robolectric.application);
+        TestProfileTracker testProfileTracker = new TestProfileTracker();
+        // Starts tracking
+        assertTrue(testProfileTracker.isTracking());
+
+        testProfileTracker.stopTracking();
+        assertFalse(testProfileTracker.isTracking());
+        sendBroadcast(localBroadcastManager, null, ProfileTest.createDefaultProfile());
+        assertFalse(testProfileTracker.isCallbackCalled);
+        testProfileTracker.startTracking();
+        assertTrue(testProfileTracker.isTracking());
+        Profile profile = ProfileTest.createDefaultProfile();
+        sendBroadcast(localBroadcastManager, null, profile);
+        assertNull(testProfileTracker.oldProfile);
+        assertEquals(profile, testProfileTracker.currentProfile);
+        assertTrue(testProfileTracker.isCallbackCalled);
+
+        Profile profile1 = ProfileTest.createMostlyNullsProfile();
+        Profile profile2 = ProfileTest.createDefaultProfile();
+        sendBroadcast(localBroadcastManager, profile1, profile2);
+        ProfileTest.assertMostlyNullsObjectGetters(testProfileTracker.oldProfile);
+        ProfileTest.assertDefaultObjectGetters(testProfileTracker.currentProfile);
+        assertEquals(profile1, testProfileTracker.oldProfile);
+        assertEquals(profile2, testProfileTracker.currentProfile);
+
+        testProfileTracker.stopTracking();
+    }
+
+    private static void sendBroadcast(
+            LocalBroadcastManager localBroadcastManager,
+            Profile oldProfile,
+            Profile currentProfile) {
+        Intent intent = new Intent(ProfileManager.ACTION_CURRENT_PROFILE_CHANGED);
+
+        intent.putExtra(ProfileManager.EXTRA_OLD_PROFILE, oldProfile);
+        intent.putExtra(ProfileManager.EXTRA_NEW_PROFILE, currentProfile);
+
+        localBroadcastManager.sendBroadcast(intent);
+    }
+
+    static class TestProfileTracker extends ProfileTracker {
+        Profile oldProfile;
+        Profile currentProfile;
+        boolean isCallbackCalled = false;
+
+        @Override
+        protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
+            this.oldProfile = oldProfile;
+            this.currentProfile = currentProfile;
+            isCallbackCalled = true;
+        }
+    }
+
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/ProgressNoopOutputStreamTest.java b/facebook/junitTests/src/test/java/com/facebook/ProgressNoopOutputStreamTest.java
new file mode 100644
index 000000000..99c8fa237
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/ProgressNoopOutputStreamTest.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import static org.junit.Assert.*;
+
+
+public class ProgressNoopOutputStreamTest extends FacebookTestCase {
+    private ProgressNoopOutputStream stream;
+
+    @Before
+    public void before() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        stream = new ProgressNoopOutputStream(null);
+    }
+
+    @After
+    public void after() throws Exception {
+        stream.close();
+    }
+
+    @Test
+    public void testSetup() {
+        assertEquals(0, stream.getMaxProgress());
+        assertTrue(stream.getProgressMap().isEmpty());
+    }
+
+    @Test
+    public void testWriting() {
+        assertEquals(0, stream.getMaxProgress());
+
+        stream.write(0);
+        assertEquals(1, stream.getMaxProgress());
+
+        final byte[] buf = new byte[8];
+
+        stream.write(buf);
+        assertEquals(9, stream.getMaxProgress());
+
+        stream.write(buf, 2, 2);
+        assertEquals(11, stream.getMaxProgress());
+
+        stream.addProgress(16);
+        assertEquals(27, stream.getMaxProgress());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/ProgressOutputStreamTests.java b/facebook/junitTests/src/test/java/com/facebook/ProgressOutputStreamTest.java
similarity index 50%
rename from facebook/tests/src/com/facebook/ProgressOutputStreamTests.java
rename to facebook/junitTests/src/test/java/com/facebook/ProgressOutputStreamTest.java
index fa3f7ffd3..6d5fa2053 100644
--- a/facebook/tests/src/com/facebook/ProgressOutputStreamTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/ProgressOutputStreamTest.java
@@ -1,66 +1,68 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.Request;
-import com.facebook.RequestBatch;
-import com.facebook.RequestProgress;
-
-import static android.test.MoreAsserts.*;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.robolectric.Robolectric;
 
 import java.io.ByteArrayOutputStream;
-import java.lang.Exception;
-import java.lang.Override;
 import java.util.HashMap;
 import java.util.Map;
 
-public class ProgressOutputStreamTests extends AndroidTestCase {
+import static org.junit.Assert.*;
+
+public class ProgressOutputStreamTest extends FacebookTestCase {
     private static final int MAX_PROGRESS = 10;
 
-    private Request r1, r2;
-    private Map<Request, RequestProgress> progressMap;
-    private RequestBatch requests;
+    private GraphRequest r1, r2;
+    private Map<GraphRequest, RequestProgress> progressMap;
+    private GraphRequestBatch requests;
     private ProgressOutputStream stream;
 
-    @Override
-    protected void setUp() throws Exception {
-        r1 = new Request(null, "4");
-        r2 = new Request(null, "4");
+    @Before
+    public void before() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        r1 = new GraphRequest(null, "4");
+        r2 = new GraphRequest(null, "4");
 
-        progressMap = new HashMap<Request, RequestProgress>();
+        progressMap = new HashMap<GraphRequest, RequestProgress>();
         progressMap.put(r1, new RequestProgress(null, r1));
         progressMap.get(r1).addToMax(5);
         progressMap.put(r2, new RequestProgress(null, r2));
         progressMap.get(r2).addToMax(5);
 
-        requests = new RequestBatch(r1, r2);
+        requests = new GraphRequestBatch(r1, r2);
 
         ByteArrayOutputStream backing = new ByteArrayOutputStream();
         stream = new ProgressOutputStream(backing, requests, progressMap, MAX_PROGRESS);
     }
 
-    @Override
-    protected void tearDown() throws Exception {
+    @After
+    public void after() throws Exception {
         stream.close();
     }
 
-    @SmallTest
+    @Test
     public void testSetup() {
         assertEquals(0, stream.getBatchProgress());
         assertEquals(MAX_PROGRESS, stream.getMaxProgress());
@@ -71,7 +73,7 @@ public void testSetup() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testWriting() {
         try {
             assertEquals(0, stream.getBatchProgress());
@@ -97,4 +99,4 @@ public void testWriting() {
             fail(ex.getMessage());
         }
     }
-}
\ No newline at end of file
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/TestUtils.java b/facebook/junitTests/src/test/java/com/facebook/TestUtils.java
new file mode 100644
index 000000000..47e2a024d
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/TestUtils.java
@@ -0,0 +1,272 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.facebook.internal.FileLruCache;
+import com.facebook.internal.Utility;
+
+import junit.framework.Assert;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class TestUtils {
+    private static long CACHE_CLEAR_TIMEOUT = 100;
+    public static final double DOUBLE_EQUALS_DELTA = 0.00001;
+
+
+    public static <T extends Serializable> T serializeAndUnserialize(final T t) {
+        try {
+            ByteArrayOutputStream os = new ByteArrayOutputStream();
+            new ObjectOutputStream(os).writeObject(t);
+            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+
+            @SuppressWarnings("unchecked")
+            T ret = (T) (new ObjectInputStream(is)).readObject();
+
+            return ret;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } catch (ClassNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static <E extends Parcelable> E parcelAndUnparcel(final E object) {
+        final Parcel writeParcel = Parcel.obtain();
+        final Parcel readParcel = Parcel.obtain();
+        try {
+            writeParcel.writeParcelable(object, 0);
+            final byte[] bytes = writeParcel.marshall();
+            readParcel.unmarshall(bytes, 0, bytes.length);
+            readParcel.setDataPosition(0);
+            return readParcel.readParcelable(object.getClass().getClassLoader());
+        } finally {
+            writeParcel.recycle();
+            readParcel.recycle();
+        }
+    }
+
+    public static Date nowPlusSeconds(final long offset) {
+        return new Date(new Date().getTime() + (offset * 1000L));
+    }
+
+    public static void assertSamePermissions(final Collection<String> expected, final AccessToken actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual.getPermissions());
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.getPermissions().contains(p));
+            }
+            for (String p : actual.getPermissions()) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    public static void assertSamePermissions(final Collection<String> expected, final Collection<String> actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual);
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+            for (String p : actual) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    public static void assertAtLeastExpectedPermissions(final Collection<String> expected, final Collection<String> actual) {
+        if (expected != null) {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+        }
+    }
+
+    public static void assertEqualContents(final Bundle a, final Bundle b) {
+        for (String key : a.keySet()) {
+            if (!b.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+            Assert.assertEquals(a.get(key), b.get(key));
+        }
+        for (String key : b.keySet()) {
+            if (!a.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+        }
+    }
+
+    @TargetApi(16)
+    public static void assertEquals(final JSONObject expected, final JSONObject actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (areEqual(expected, actual)) {
+            return;
+        }
+        Assert.failNotEquals("", expected, actual);
+    }
+
+    @TargetApi(16)
+    public static void assertEquals(final JSONArray expected, final JSONArray actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (areEqual(expected, actual)) {
+            return;
+        }
+        Assert.failNotEquals("", expected, actual);
+    }
+
+    private static boolean areEqual(final JSONObject expected, final JSONObject actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+
+        final Iterator<String> expectedKeysIterator = expected.keys();
+        final HashSet<String> expectedKeys = new HashSet<String>();
+        while (expectedKeysIterator.hasNext()) {
+            expectedKeys.add(expectedKeysIterator.next());
+        }
+
+        final Iterator<String> actualKeysIterator = actual.keys();
+        while (actualKeysIterator.hasNext()) {
+            final String key = actualKeysIterator.next();
+            if (!areEqual(expected.opt(key), actual.opt(key))) {
+                return false;
+            }
+            expectedKeys.remove(key);
+        }
+        return expectedKeys.size() == 0;
+    }
+
+    private static boolean areEqual(final JSONArray expected, final JSONArray actual) {
+        // JSONObject.equals does not do an order-independent comparison, so we need to check values that are JSONObject
+        // manually
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+        if (expected.length() != actual.length()) {
+            return false;
+        }
+
+        final int length = expected.length();
+        for (int i = 0; i < length; ++i) {
+            if (!areEqual(expected.opt(i), actual.opt(i))) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private static boolean areEqual(final Object expected, final Object actual) {
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+        if ((expected instanceof JSONObject) && (actual instanceof JSONObject)) {
+            return areEqual((JSONObject)expected, (JSONObject)actual);
+        }
+        if ((expected instanceof JSONArray) && (actual instanceof JSONArray)) {
+            return areEqual((JSONArray)expected, (JSONArray)actual);
+        }
+        return expected.equals(actual);
+    }
+
+    public static void clearFileLruCache(final FileLruCache cache) throws InterruptedException {
+        // since the cache clearing happens in a separate thread, we need to wait until
+        // the clear is complete before we can check for the existence of the old files
+        synchronized (cache) {
+            cache.clearCache();
+            FacebookSdk.getExecutor().execute(new Runnable() {
+                @Override
+                public void run() {
+                    synchronized (cache) {
+                        cache.notifyAll();
+                    }
+                }
+            });
+            cache.wait(CACHE_CLEAR_TIMEOUT);
+        }
+        // sleep a little more just to make sure all the files are deleted.
+        Thread.sleep(CACHE_CLEAR_TIMEOUT);
+    }
+
+    public static void deleteLruCacheDirectory(final FileLruCache cache) {
+        File directory = new File(cache.getLocation());
+        directory.delete();
+    }
+
+    public static void clearAndDeleteLruCacheDirectory(final FileLruCache cache)
+            throws InterruptedException {
+        clearFileLruCache(cache);
+        deleteLruCacheDirectory(cache);
+    }
+
+    public static String getAssetFileStringContents(final Context context, final String assetPath) throws IOException {
+        InputStream inputStream = null;
+        BufferedReader reader = null;
+        try {
+            final AssetManager assets = context.getResources().getAssets();
+            inputStream = assets.open(assetPath);
+            reader = new BufferedReader(new InputStreamReader(inputStream));
+            final StringBuilder sb = new StringBuilder();
+            String line;
+            while ((line = reader.readLine()) != null) {
+                sb.append(line).append("\n");
+            }
+            return sb.toString();
+        } finally {
+            Utility.closeQuietly(inputStream);
+            Utility.closeQuietly(reader);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/AppLinkDataTests.java b/facebook/junitTests/src/test/java/com/facebook/applinks/AppLinkDataTest.java
similarity index 65%
rename from facebook/tests/src/com/facebook/AppLinkDataTests.java
rename to facebook/junitTests/src/test/java/com/facebook/applinks/AppLinkDataTest.java
index 42a22c9b5..dcb63d8ba 100644
--- a/facebook/tests/src/com/facebook/AppLinkDataTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/applinks/AppLinkDataTest.java
@@ -1,11 +1,38 @@
-package com.facebook;
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.applinks;
 
 import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
 
-public class AppLinkDataTests extends FacebookTestCase {
+import com.facebook.FacebookTestCase;
+import com.facebook.applinks.AppLinkData;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class AppLinkDataTest extends FacebookTestCase {
     private static final String TARGET_URI_STRING = "http://test.app/foo";
     private static final String FB_REF_KEY = "fb_ref";
     private static final String FB_REF_VALUE = "foobar";
@@ -18,37 +45,37 @@
 
     private static final String JSON_DATA_REGULAR =
             "{"
-            + "\"version\":2,"
-            + "\"bridge_args\": {\"method\": \"applink\"},"
-            + "\"method_args\": {"
-            + "    \"ref\": \"" + FB_REF_VALUE + "\","
-            + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\""
-            + "  }"
-            + "}";
+                    + "\"version\":2,"
+                    + "\"bridge_args\": {\"method\": \"applink\"},"
+                    + "\"method_args\": {"
+                    + "    \"ref\": \"" + FB_REF_VALUE + "\","
+                    + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\""
+                    + "  }"
+                    + "}";
 
     private static final String JSON_DATA_REGULAR_WITH_NESTED_ARRAY =
             "{"
-            + "\"version\":2,"
-            + "\"bridge_args\": {\"method\": \"applink\"},"
-            + "\"method_args\": {"
-            + "    \"ref\": \"" + FB_REF_VALUE + "\","
-            + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\","
-            + "    \"other\": [ [1, 2], [3, 4] ]"
-            + "  }"
-            + "}";
+                    + "\"version\":2,"
+                    + "\"bridge_args\": {\"method\": \"applink\"},"
+                    + "\"method_args\": {"
+                    + "    \"ref\": \"" + FB_REF_VALUE + "\","
+                    + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\","
+                    + "    \"other\": [ [1, 2], [3, 4] ]"
+                    + "  }"
+                    + "}";
 
     private static final String JSON_DATA_WITH_REFERER_DATA =
             "{"
-            + "\"version\":2,"
-            + "\"bridge_args\": {\"method\": \"applink\"},"
-            + "\"method_args\": {"
-            + "    \"referer_data\" : {"
-            + "      \"" + FB_REF_KEY + "\": \"" + FB_REF_VALUE + "\","
-            + "      \"" + EXTRA_ARGS_KEY + "\": \"" + EXTRA_ARGS_VALUE + "\""
-            + "    },"
-            + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\""
-            + "  }"
-            + "}";
+                    + "\"version\":2,"
+                    + "\"bridge_args\": {\"method\": \"applink\"},"
+                    + "\"method_args\": {"
+                    + "    \"referer_data\" : {"
+                    + "      \"" + FB_REF_KEY + "\": \"" + FB_REF_VALUE + "\","
+                    + "      \"" + EXTRA_ARGS_KEY + "\": \"" + EXTRA_ARGS_VALUE + "\""
+                    + "    },"
+                    + "    \"" + TARGET_URL_KEY + "\": \"" + TARGET_URI_STRING + "\""
+                    + "  }"
+                    + "}";
 
 
     private static class MockActivityWithAppLinkData extends Activity {
@@ -89,6 +116,7 @@ public Intent getIntent() {
         }
     }
 
+    @Test
     public void testCreateFromAlApplinkData() {
         AppLinkData appLinkData = AppLinkData.createFromActivity(new MockActivityWithAppLinkData());
         assertNotNull("app link data not null", appLinkData);
@@ -103,6 +131,7 @@ public void testCreateFromAlApplinkData() {
         assertEquals("extra param", EXTRA_ARGS_VALUE, refererData.getString(EXTRA_ARGS_KEY));
     }
 
+    @Test
     public void testCreateFromJson() {
         AppLinkData appLinkData = AppLinkData.createFromActivity(new MockActivityWithJsonData(false));
         assertNotNull("app link data not null", appLinkData);
@@ -115,12 +144,13 @@ public void testCreateFromJson() {
         assertNull("referer data", refererData);
     }
 
+    @Test
     public void testCreateFromJsonWithNestedArray() {
         AppLinkData appLinkData = AppLinkData.createFromActivity(new MockActivityWithErrorJsonData());
         assertNull(appLinkData);
     }
 
-
+    @Test
     public void testCreateFromJsonWithRefererData() {
         AppLinkData appLinkData = AppLinkData.createFromActivity(new MockActivityWithJsonData(true));
         assertNotNull("app link data not null", appLinkData);
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/BundleJSONConverterTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/BundleJSONConverterTest.java
new file mode 100644
index 000000000..986acd464
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/BundleJSONConverterTest.java
@@ -0,0 +1,156 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+package com.facebook.internal;
+
+import android.os.Bundle;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+public class BundleJSONConverterTest extends FacebookTestCase {
+
+    @Test
+    public void testSimpleValues() throws JSONException {
+        ArrayList<String> arrayList = new ArrayList<String>();
+        arrayList.add("1st");
+        arrayList.add("2nd");
+        arrayList.add("third");
+
+        Bundle innerBundle1 = new Bundle();
+        innerBundle1.putInt("inner", 1);
+
+        Bundle innerBundle2 = new Bundle();
+        innerBundle2.putString("inner", "2");
+        innerBundle2.putStringArray("deep list", new String[] {"7", "8"});
+
+        innerBundle1.putBundle("nested bundle", innerBundle2);
+
+
+        Bundle b = new Bundle();
+        b.putBoolean("boolValue", true);
+        b.putInt("intValue", 7);
+        b.putLong("longValue", 5000000000l);
+        b.putDouble("doubleValue", 3.14);
+        b.putString("stringValue", "hello world");
+        b.putStringArray("stringArrayValue", new String[] {"first", "second"});
+        b.putStringArrayList("stringArrayListValue", arrayList);
+        b.putBundle("nested", innerBundle1);
+
+
+        JSONObject json = BundleJSONConverter.convertToJSON(b);
+        assertNotNull(json);
+
+        assertEquals(true, json.getBoolean("boolValue"));
+        assertEquals(7, json.getInt("intValue"));
+        assertEquals(5000000000l, json.getLong("longValue"));
+        assertEquals(3.14, json.getDouble("doubleValue"), TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals("hello world", json.getString("stringValue"));
+
+        JSONArray jsonArray = json.getJSONArray("stringArrayValue");
+        assertEquals(2, jsonArray.length());
+        assertEquals("first", jsonArray.getString(0));
+        assertEquals("second", jsonArray.getString(1));
+
+        jsonArray = json.getJSONArray("stringArrayListValue");
+        assertEquals(3, jsonArray.length());
+        assertEquals("1st", jsonArray.getString(0));
+        assertEquals("2nd", jsonArray.getString(1));
+        assertEquals("third", jsonArray.getString(2));
+
+        JSONObject innerJson = json.getJSONObject("nested");
+        assertEquals(1, innerJson.getInt("inner"));
+        innerJson = innerJson.getJSONObject("nested bundle");
+        assertEquals("2", innerJson.getString("inner"));
+
+        jsonArray = innerJson.getJSONArray("deep list");
+        assertEquals(2, jsonArray.length());
+        assertEquals("7", jsonArray.getString(0));
+        assertEquals("8", jsonArray.getString(1));
+
+        Bundle finalBundle = BundleJSONConverter.convertToBundle(json);
+        assertNotNull(finalBundle);
+
+        assertEquals(true, finalBundle.getBoolean("boolValue"));
+        assertEquals(7, finalBundle.getInt("intValue"));
+        assertEquals(5000000000l, finalBundle.getLong("longValue"));
+        assertEquals(3.14, finalBundle.getDouble("doubleValue"), TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals("hello world", finalBundle.getString("stringValue"));
+
+        List<String> stringList = finalBundle.getStringArrayList("stringArrayValue");
+        assertEquals(2, stringList.size());
+        assertEquals("first", stringList.get(0));
+        assertEquals("second", stringList.get(1));
+
+        stringList = finalBundle.getStringArrayList("stringArrayListValue");
+        assertEquals(3, stringList.size());
+        assertEquals("1st", stringList.get(0));
+        assertEquals("2nd", stringList.get(1));
+        assertEquals("third", stringList.get(2));
+
+        Bundle finalInnerBundle = finalBundle.getBundle("nested");
+        assertEquals(1, finalInnerBundle.getInt("inner"));
+        finalBundle = finalInnerBundle.getBundle("nested bundle");
+        assertEquals("2", finalBundle.getString("inner"));
+
+        stringList = finalBundle.getStringArrayList("deep list");
+        assertEquals(2, stringList.size());
+        assertEquals("7", stringList.get(0));
+        assertEquals("8", stringList.get(1));
+    }
+
+    @Test
+    public void testUnsupportedValues() throws JSONException {
+        Bundle b = new Bundle();
+        b.putShort("shortValue", (short)7);
+
+        boolean exceptionCaught = false;
+        try {
+            BundleJSONConverter.convertToJSON(b);
+        } catch (IllegalArgumentException a) {
+            exceptionCaught = true;
+        }
+        assertTrue(exceptionCaught);
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(10);
+        JSONObject json = new JSONObject();
+        json.put("arrayValue", jsonArray);
+
+        exceptionCaught = false;
+        try {
+            BundleJSONConverter.convertToBundle(json);
+        } catch (IllegalArgumentException a) {
+            exceptionCaught = true;
+        }
+        assertTrue(exceptionCaught);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/CallbackManagerImplPowerMockTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/CallbackManagerImplPowerMockTest.java
new file mode 100644
index 000000000..cd599c259
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/CallbackManagerImplPowerMockTest.java
@@ -0,0 +1,178 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Intent;
+
+import com.facebook.FacebookPowerMockTestCase;
+import com.facebook.FacebookSdk;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.reflect.Whitebox;
+import org.robolectric.Robolectric;
+
+import java.util.HashMap;
+
+import bolts.Capture;
+
+import static org.junit.Assert.*;
+
+@PrepareForTest({ CallbackManagerImpl.class })
+public final class CallbackManagerImplPowerMockTest extends FacebookPowerMockTestCase {
+
+    @Before
+    public void before() {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        // Reset the static state every time so tests don't interfere with each other.
+        Whitebox.setInternalState(
+                CallbackManagerImpl.class,
+                "staticCallbacks",
+                new HashMap<Integer, CallbackManagerImpl.Callback>());
+    }
+
+    @Test
+    public void testStaticRegisterValidations() {
+        try {
+            CallbackManagerImpl.registerStaticCallback(
+                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
+            fail();
+        } catch (NullPointerException exception) { }
+    }
+
+    @Test
+    public void testRegisterValidations() {
+        CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
+        try {
+            callbackManagerImpl.registerCallback(
+                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
+            fail();
+        } catch (NullPointerException exception) { }
+    }
+
+    @Test
+    public void testCallbackExecuted() {
+        final Capture<Boolean> capture = new Capture(false);
+
+        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
+
+        callbackManagerImpl.registerCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        capture.set(true);
+                        return true;
+                    }
+                });
+        callbackManagerImpl.onActivityResult(
+                FacebookSdk.getCallbackRequestCodeOffset(),
+                1,
+                new Intent());
+        assertTrue(capture.get());
+    }
+
+    @Test
+    public void testRightCallbackExecuted() {
+        final Capture<Boolean> capture = new Capture(false);
+
+        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
+
+        callbackManagerImpl.registerCallback(
+                123,
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        capture.set(true);
+                        return true;
+                    }
+                });
+        callbackManagerImpl.registerCallback(
+                456,
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return false;
+                    }
+                });
+        callbackManagerImpl.onActivityResult(
+                123,
+                1,
+                new Intent());
+        assertTrue(capture.get());
+    }
+
+    @Test
+    public void testStaticCallbackExecuted() {
+        final Capture<Boolean> capture = new Capture(false);
+
+        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
+
+        callbackManagerImpl.registerStaticCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        capture.set(true);
+                        return true;
+                    }
+                });
+        callbackManagerImpl.onActivityResult(
+                FacebookSdk.getCallbackRequestCodeOffset(),
+                1,
+                new Intent());
+        assertTrue(capture.get());
+    }
+
+    @Test
+    public void testStaticCallbackSkipped() {
+        final Capture<Boolean> capture = new Capture(false);
+        final Capture<Boolean> captureStatic = new Capture(false);
+
+        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
+
+        callbackManagerImpl.registerCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        capture.set(true);
+                        return true;
+                    }
+                });
+        callbackManagerImpl.registerStaticCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        captureStatic.set(true);
+                        return true;
+                    }
+                });
+        callbackManagerImpl.onActivityResult(
+                FacebookSdk.getCallbackRequestCodeOffset(),
+                1,
+                new Intent());
+        assertTrue(capture.get());
+        assertFalse(captureStatic.get());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/FacebookRequestErrorClassificationTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/FacebookRequestErrorClassificationTest.java
new file mode 100644
index 000000000..d6ec8b7c3
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/FacebookRequestErrorClassificationTest.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookTestCase;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class FacebookRequestErrorClassificationTest extends FacebookTestCase {
+    private final String errorClassificationJSON =
+        "{" +
+        "   \"android_sdk_error_categories\": [" +
+        "      {" +
+        "         \"name\": \"other\"," +
+        "         \"items\": [" +
+        "           { \"code\": 102, \"subcodes\": [ 459, 464 ] }," +
+        "           { \"code\": 190, \"subcodes\": [ 459, 464 ] }" +
+        "         ]" +
+        "      }," +
+        "      {" +
+        "         \"name\": \"login_recoverable\"," +
+        "         \"items\": [ { \"code\": 102 }, { \"code\": 190 } ]," +
+        "         \"recovery_message\": \"Please log into this app again to reconnect your Facebook account.\"" +
+        "      }," +
+        "      {" +
+        "         \"name\": \"transient\"," +
+        "         \"items\": [ { \"code\": 1 }, { \"code\": 2 }, { \"code\": 4 }, { \"code\": 9 }, { \"code\": 17 }, { \"code\": 341 } ]" +
+        "      }" +
+        "   ]," +
+        "   \"id\": \"233936543368280\"" +
+        "}";
+
+
+    @Test
+    public void testX() throws Exception {
+        JSONObject serverResponse = new JSONObject(errorClassificationJSON);
+        JSONArray jsonArray = serverResponse.getJSONArray("android_sdk_error_categories");
+        FacebookRequestErrorClassification errorClassification =
+                FacebookRequestErrorClassification.createFromJSON(jsonArray);
+        assertNotNull(errorClassification);
+        assertNull(errorClassification.getRecoveryMessage(FacebookRequestError.Category.OTHER));
+        assertNull(errorClassification.getRecoveryMessage(FacebookRequestError.Category.TRANSIENT));
+        assertNotNull(errorClassification.getRecoveryMessage(
+                FacebookRequestError.Category.LOGIN_RECOVERABLE));
+        assertEquals(2, errorClassification.getOtherErrors().size());
+        assertEquals(2, errorClassification.getLoginRecoverableErrors().size());
+        assertEquals(6, errorClassification.getTransientErrors().size());
+        // test subcodes
+        assertEquals(2, errorClassification.getOtherErrors().get(102).size());
+        assertNull(errorClassification.getLoginRecoverableErrors().get(102));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/FileLruCacheTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/FileLruCacheTest.java
new file mode 100644
index 000000000..cc57d2e0b
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/FileLruCacheTest.java
@@ -0,0 +1,441 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+
+import com.facebook.FacebookSdk;
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Random;
+
+import static org.junit.Assert.*;
+
+public final class FileLruCacheTest extends FacebookTestCase {
+    private static final Random random = new Random();
+
+    @Before
+    public void before() {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+    }
+
+    @Test
+    public void testCacheOutputStream() throws Exception {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache("testCacheOutputStream", limitCacheSize(2*dataSize));
+
+        try {
+            put(cache, key, data);
+            checkValue(cache, key, data);
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheInputStream() throws Exception {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+        InputStream stream = new ByteArrayInputStream(data);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache("testCacheInputStream", limitCacheSize(2*dataSize));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            InputStream wrapped = cache.interceptAndPut(key, stream);
+            consumeAndClose(wrapped);
+            checkValue(cache, key, data);
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheClear() throws Exception {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            put(cache, key, data);
+            checkValue(cache, key, data);
+
+            TestUtils.clearFileLruCache(cache);
+            assertEquals(false, hasValue(cache, key));
+            assertEquals(0, cache.sizeInBytesForTest());
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheClearMidBuffer() throws Exception {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+        String key2 = "b";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            put(cache, key, data);
+            checkValue(cache, key, data);
+            OutputStream stream = cache.openPutStream(key2);
+            Thread.sleep(200);
+
+            TestUtils.clearFileLruCache(cache);
+
+            stream.write(data);
+            stream.close();
+
+            assertEquals(false, hasValue(cache, key));
+            assertEquals(false, hasValue(cache, key2));
+            assertEquals(0, cache.sizeInBytesForTest());
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testSizeInBytes() throws Exception {
+        int count = 17;
+        int dataSize = 53;
+        int cacheSize = count * dataSize;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache("testSizeInBytes", limitCacheSize(2*cacheSize));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            for (int i = 0; i < count; i++) {
+                put(cache, i, data);
+
+                // The size reported by sizeInBytes includes a version/size token as well
+                // as a JSON blob that records the name.  Verify that the cache size is larger
+                // than the data content but not more than twice as large.  This guarantees
+                // that sizeInBytes is doing at least approximately the right thing.
+                int totalDataSize = (i + 1) * dataSize;
+                assertTrue(cache.sizeInBytesForTest() > totalDataSize);
+                assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
+            }
+            for (int i = 0; i < count; i++) {
+                String key = Integer.valueOf(i).toString();
+                checkValue(cache, key, data);
+            }
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheSizeLimit() throws Exception {
+        int count = 64;
+        int dataSize = 32;
+        int cacheSize = count * dataSize / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we do not set the limit to 2x to make sure we hit the limit well before we have
+        // added all the data.
+        FileLruCache cache = new FileLruCache("testCacheSizeLimit", limitCacheSize(cacheSize));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            for (int i = 0; i < count; i++) {
+                put(cache, i, data);
+
+                // See comment in testSizeInBytes for why this is not an exact calculation.
+                //
+                // This changes verification such that the final cache size lands somewhere
+                // between half and full quota.
+                int totalDataSize = (i + 1) * dataSize;
+                assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize / 2));
+                assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
+            }
+
+            // sleep for a bit to make sure the trim finishes
+            Thread.sleep(200);
+
+            // Verify that some keys exist and others do not
+            boolean hasValueExists = false;
+            boolean hasNoValueExists = false;
+
+            for (int i = 0; i < count; i++) {
+                String key = Integer.valueOf(i).toString();
+                if (hasValue(cache, key)) {
+                    hasValueExists = true;
+                    checkValue(cache, key, data);
+                } else {
+                    hasNoValueExists = true;
+                }
+            }
+
+            assertEquals(true, hasValueExists);
+            assertEquals(true, hasNoValueExists);
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheCountLimit() throws Exception {
+        int count = 64;
+        int dataSize = 32;
+        int cacheCount = count / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we only limit by count, and we allow half of the entries.
+        FileLruCache cache = new FileLruCache("testCacheCountLimit", limitCacheCount(cacheCount));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            for (int i = 0; i < count; i++) {
+                put(cache, i, data);
+            }
+
+            // sleep for a bit to make sure the trim finishes
+            Thread.sleep(200);
+
+            // Verify that some keys exist and others do not
+            boolean hasValueExists = false;
+            boolean hasNoValueExists = false;
+
+            for (int i = 0; i < count; i++) {
+                if (hasValue(cache, i)) {
+                    hasValueExists = true;
+                    checkValue(cache, i, data);
+                } else {
+                    hasNoValueExists = true;
+                }
+            }
+
+            assertEquals(true, hasValueExists);
+            assertEquals(true, hasNoValueExists);
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testCacheLru() throws IOException, InterruptedException {
+        int keepCount = 10;
+        int otherCount = 5;
+        int dataSize = 64;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit by count, and allow all the keep keys plus one other.
+        FileLruCache cache = new FileLruCache("testCacheLru", limitCacheCount(keepCount + 1));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            for (int i = 0; i < keepCount; i++) {
+                put(cache, i, data);
+            }
+
+            // Make sure operations are separated by enough time that the file timestamps are all different.
+            // On the test device, it looks like lastModified has 1-second resolution, so we have to wait at
+            // least a second to guarantee that updated timestamps will come later.
+            Thread.sleep(1000);
+            for (int i = 0; i < otherCount; i++) {
+                put(cache, keepCount + i, data);
+                Thread.sleep(1000);
+
+                // By verifying all the keep keys, they should be LRU and survive while the others do not.
+                for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
+                    checkValue(cache, keepIndex, data);
+                }
+                Thread.sleep(200);
+            }
+
+            // All but the last other key should have been pushed out
+            for (int i = 0; i < (otherCount - 1); i++) {
+                String key = Integer.valueOf(keepCount + i).toString();
+                assertEquals(false, hasValue(cache, key));
+            }
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    @Test
+    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
+        final int count = 5;
+        final int dataSize = 81;
+        final int threadCount = 31;
+        final int iterationCount = 10;
+        final byte[] data = generateBytes(dataSize);
+
+        final FileLruCache cache = new FileLruCache(
+                "testConcurrentWritesToSameKey", limitCacheCount(count+1));
+        try {
+            TestUtils.clearFileLruCache(cache);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    for (int iterations = 0; iterations < iterationCount; iterations++) {
+                        for (int i = 0; i < count; i++) {
+                            put(cache, i, data);
+                        }
+                    }
+                }
+            };
+
+            // Create a bunch of threads to write a set of keys repeatedly
+            Thread[] threads = new Thread[threadCount];
+            for (int i = 0; i < threads.length; i++) {
+                threads[i] = new Thread(run);
+            }
+
+            for (Thread thread : threads) {
+                thread.start();
+            }
+
+            for (Thread thread : threads) {
+                thread.join(10 * 1000, 0);
+            }
+
+            // Verify that the file state ended up consistent in the end
+            for (int i = 0; i < count; i++) {
+                checkValue(cache, i, data);
+            }
+        } finally {
+            TestUtils.clearAndDeleteLruCacheDirectory(cache);
+        }
+    }
+
+    byte[] generateBytes(int n) {
+        byte[] bytes = new byte[n];
+        random.nextBytes(bytes);
+        return bytes;
+    }
+
+    FileLruCache.Limits limitCacheSize(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setByteCount(n);
+        return limits;
+    }
+
+    FileLruCache.Limits limitCacheCount(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setFileCount(n);
+        return limits;
+    }
+
+    void put(FileLruCache cache, int i, byte[] data) {
+        put(cache, Integer.valueOf(i).toString(), data);
+    }
+
+    void put(FileLruCache cache, String key, byte[] data) {
+        try {
+            OutputStream stream = cache.openPutStream(key);
+            assertNotNull(stream);
+
+            stream.write(data);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void checkValue(FileLruCache cache, int i, byte[] expected) {
+        checkValue(cache, Integer.valueOf(i).toString(), expected);
+    }
+
+    void checkValue(FileLruCache cache, String key, byte[] expected) {
+        try {
+            InputStream stream = cache.get(key);
+            assertNotNull(stream);
+
+            checkInputStream(expected, stream);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    boolean hasValue(FileLruCache cache, int i) {
+        return hasValue(cache, Integer.valueOf(i).toString());
+    }
+
+    boolean hasValue(FileLruCache cache, String key) {
+        InputStream stream = null;
+
+        try {
+            stream = cache.get(key);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+
+        return stream != null;
+    }
+
+    void checkInputStream(byte[] expected, InputStream actual) {
+        try {
+            for (int i = 0; i < expected.length; i++) {
+                int b = actual.read();
+                assertEquals(((int)expected[i]) & 0xff, b);
+            }
+
+            int eof = actual.read();
+            assertEquals(-1, eof);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void consumeAndClose(InputStream stream) {
+        try {
+            byte[] buffer = new byte[1024];
+            while (stream.read(buffer) > -1) {
+                // these bytes intentionally ignored
+            }
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/model/JsonUtilTests.java b/facebook/junitTests/src/test/java/com/facebook/internal/JsonUtilTest.java
similarity index 63%
rename from facebook/tests/src/com/facebook/model/JsonUtilTests.java
rename to facebook/junitTests/src/test/java/com/facebook/internal/JsonUtilTest.java
index 8f6b60b34..c3cf07344 100644
--- a/facebook/tests/src/com/facebook/model/JsonUtilTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/JsonUtilTest.java
@@ -1,36 +1,42 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.model;
+package com.facebook.internal;
 
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.facebook.FacebookTestCase;
 
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map.Entry;
 import java.util.Set;
 
-public final class JsonUtilTests extends AndroidTestCase {
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+
+public final class JsonUtilTest extends FacebookTestCase {
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectClear() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
@@ -41,7 +47,7 @@ public void testJsonObjectClear() throws JSONException {
         assertEquals(0, jsonObject.length());
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectContainsValue() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
@@ -52,7 +58,7 @@ public void testJsonObjectContainsValue() throws JSONException {
         assertFalse(JsonUtil.jsonObjectContainsValue(jsonObject, "Fred"));
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectEntrySet() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
@@ -63,7 +69,7 @@ public void testJsonObjectEntrySet() throws JSONException {
         assertEquals(2, entrySet.size());
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectKeySet() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
@@ -76,7 +82,7 @@ public void testJsonObjectKeySet() throws JSONException {
         assertFalse(keySet.contains("world"));
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectPutAll() throws JSONException {
         HashMap<String, Object> map = new HashMap<String, Object>();
         map.put("hello", "world");
@@ -89,7 +95,7 @@ public void testJsonObjectPutAll() throws JSONException {
         assertEquals(2, jsonObject.length());
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @Test
     public void testJsonObjectValues() throws JSONException {
         JSONObject jsonObject = new JSONObject();
         jsonObject.put("hello", "world");
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/NativeAppCallAttachmentStoreTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/NativeAppCallAttachmentStoreTest.java
new file mode 100644
index 000000000..e4aff2a8d
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/NativeAppCallAttachmentStoreTest.java
@@ -0,0 +1,111 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.graphics.Bitmap;
+
+import com.facebook.FacebookTestCase;
+
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import static org.junit.Assert.*;
+
+
+public class NativeAppCallAttachmentStoreTest extends FacebookTestCase {
+    private static final UUID CALL_ID = UUID.randomUUID();
+    private static final String ATTACHMENT_NAME = "hello";
+
+    @Override
+    public void setUp() {
+        super.setUp();
+    }
+
+    private Bitmap createBitmap() {
+        return Bitmap.createBitmap(20, 20, Bitmap.Config.ALPHA_8);
+    }
+
+    private List<NativeAppCallAttachmentStore.Attachment> createAttachments(
+            UUID callId, Bitmap bitmap) {
+        List<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>();
+        attachments.add(NativeAppCallAttachmentStore.createAttachment(callId, bitmap));
+
+        return attachments;
+    }
+
+    @Test
+    public void testAddAttachmentsForCallWithNullCallId() throws Exception {
+        try {
+            List<NativeAppCallAttachmentStore.Attachment> attachments =
+                    createAttachments(null, createBitmap());
+            NativeAppCallAttachmentStore.addAttachments(attachments);
+            fail("expected exception");
+        } catch (NullPointerException ex) {
+            assertTrue(ex.getMessage().contains("callId"));
+        }
+    }
+
+    @Test
+    public void testAddAttachmentsForCallWithNullBitmap() throws Exception {
+        try {
+            List<NativeAppCallAttachmentStore.Attachment> attachments =
+                    createAttachments(CALL_ID, null);
+            NativeAppCallAttachmentStore.addAttachments(attachments);
+            fail("expected exception");
+        } catch (NullPointerException ex) {
+            assertTrue(ex.getMessage().contains("attachmentBitmap"));
+        }
+    }
+
+    @Test
+    public void testGetAttachmentsDirectory() throws Exception {
+        File dir = NativeAppCallAttachmentStore.getAttachmentsDirectory();
+        assertNotNull(dir);
+        assertTrue(
+                dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
+    }
+
+    @Test
+    public void testGetAttachmentsDirectoryForCall() throws Exception {
+        NativeAppCallAttachmentStore.ensureAttachmentsDirectoryExists();
+        File dir = NativeAppCallAttachmentStore.getAttachmentsDirectoryForCall(CALL_ID, false);
+        assertNotNull(dir);
+        assertTrue(
+                dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
+        assertTrue(dir.getAbsolutePath().contains(CALL_ID.toString()));
+    }
+
+    @Test
+    public void testGetAttachmentFile() throws Exception {
+        NativeAppCallAttachmentStore.ensureAttachmentsDirectoryExists();
+        File dir = NativeAppCallAttachmentStore.getAttachmentFile(CALL_ID, ATTACHMENT_NAME, false);
+        assertNotNull(dir);
+        assertTrue(
+                dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
+        assertTrue(dir.getAbsolutePath().contains(CALL_ID.toString()));
+        assertTrue(dir.getAbsolutePath().contains(ATTACHMENT_NAME.toString()));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/NativeProtocolVersionTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/NativeProtocolVersionTest.java
new file mode 100644
index 000000000..58f330a41
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/NativeProtocolVersionTest.java
@@ -0,0 +1,167 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.test.suitebuilder.annotation.SmallTest;
+
+import com.facebook.FacebookTestCase;
+
+import org.junit.Test;
+
+import java.util.TreeSet;
+
+import static org.junit.Assert.*;
+
+
+public class NativeProtocolVersionTest extends FacebookTestCase {
+    @Test
+    public void testSdkOlderThanApp_versionSpecOpen() {
+        // Base case where a feature was enabled a while ago and the SDK and Native app have been updated
+        // since then.
+        int[] versionSpec = new int[] {3};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @Test
+    public void testSdkNewerThanApp_versionSpecOpen() {
+        // Base case where a feature was enabled a while ago and the SDK and Native app have been updated
+        // since then.
+        int[] versionSpec = new int[] {3};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @Test
+    public void testSdkOlderThanApp_versionSpecDisabled() {
+        // Case where a feature was enabled AND disabled a while ago and the SDK and Native app have been
+        // updated since then.
+        int[] versionSpec = new int[] {1,3,7,8};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @Test
+    public void testSdkNewerThanApp_versionSpecDisabled() {
+        // Case where a feature was enabled AND disabled a while ago and the SDK and Native app have been
+        // updated since then.
+        int[] versionSpec = new int[] {1,3,6,7};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @Test
+    public void testSdkOlderThanApp_versionSpecNewerAndEnabled() {
+        // Case where the sdk and app are older, but the app is still enabled
+        int[] versionSpec = new int[] {1,3,7,9,10,11,12,13};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @Test
+    public void testSdkNewerThanApp_versionSpecNewerAndEnabled() {
+        // Case where the sdk and app are older, but the app is still enabled
+        int[] versionSpec = new int[] {1,3,7,9,10,11,12,13};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, 7);
+    }
+
+    @Test
+    public void testSdkOlderThanApp_versionSpecNewerAndDisabled() {
+        // Case where the sdk and app are older, and the app is a disabled version
+        int[] versionSpec = new int[] {1,3,7,8,10,11,12,13};
+        int latestSdkVersion = 7;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7,8};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    @Test
+    public void testSdkNewerThanApp_versionSpecNewerAndDisabled() {
+        // Case where the sdk and app are older, and the app is a disabled version
+        int[] versionSpec = new int[] {1,3,6,7,10,11,12,13};
+        int latestSdkVersion = 8;
+        int[] availableFbAppVersions = new int[] {1,2,3,4,5,6,7};
+
+        int resultVersion = NativeProtocol.computeLatestAvailableVersionFromVersionSpec(
+                getTreeSetFromIntArray(availableFbAppVersions),
+                latestSdkVersion,
+                versionSpec);
+
+        assertEquals(resultVersion, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+    }
+
+    private TreeSet<Integer> getTreeSetFromIntArray(int[] array) {
+        TreeSet<Integer> treeSet = new TreeSet<Integer>();
+        for (int a : array) {
+            treeSet.add(a);
+        }
+
+        return treeSet;
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/ShareInternalUtilityTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/ShareInternalUtilityTest.java
new file mode 100644
index 000000000..0376ecce8
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/ShareInternalUtilityTest.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+package com.facebook.internal;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.share.internal.ShareInternalUtility;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Test;
+
+import java.util.Iterator;
+import java.util.Locale;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public class ShareInternalUtilityTest extends FacebookTestCase {
+
+    @Test
+    public void testRemoveNamespaceFromNullOGJsonObject() {
+        assertNull(ShareInternalUtility.removeNamespacesFromOGJsonObject(null, false));
+    }
+
+    @Test
+    public void testRemoveNamespaceFromComplexOGJsonObject() {
+        try {
+            JSONObject testObject = getJsonOGActionTestObject();
+            testObject = ShareInternalUtility.removeNamespacesFromOGJsonObject(testObject, false);
+            JSONObject expectedResult = getJsonOGActionTestObjectWithoutNamespace();
+            if(!simpleJsonObjComparer(testObject, expectedResult)){
+                fail(String.format(
+                        Locale.ROOT,
+                        "Actual: %s\nExpected: %s",
+                        testObject.toString(),
+                        expectedResult.toString()));
+            }
+        } catch (JSONException ex) {
+            // Fail
+            assertNotNull(ex);
+        }
+    }
+
+    private static JSONObject getJsonOGActionTestObject() throws JSONException {
+        JSONObject testAction = new JSONObject();
+        testAction.put("og:field", 1);
+        testAction.put("namespaced:custom:field", 3);
+
+        JSONObject testOGContent = getJsonOGContentTestObject();
+        testAction.put("namespaced:content", testOGContent);
+        testAction.put("array", getJsonOGArrayTestObject());
+
+        return testAction;
+    }
+
+    private static JSONObject getJsonOGActionTestObjectWithoutNamespace() throws JSONException {
+        JSONObject testAction = new JSONObject();
+        testAction.put("field", 1);
+        testAction.put("custom:field", 3);
+
+        JSONObject testOGContent = getJsonOGContentTestObjectWithoutNamespace();
+        testAction.put("content", testOGContent);
+        testAction.put("array", getJsonOGArrayTestObjectWithoutNamespace());
+
+        return testAction;
+    }
+
+    private static JSONArray getJsonOGArrayTestObject() throws JSONException {
+        JSONArray testArray = new JSONArray();
+        testArray.put(10);
+        testArray.put(getJsonOGContentTestObject());
+        return testArray;
+    }
+
+    private static JSONArray getJsonOGArrayTestObjectWithoutNamespace() throws JSONException {
+        JSONArray testArray = new JSONArray();
+        testArray.put(10);
+        testArray.put(getJsonOGContentTestObjectWithoutNamespace());
+        return testArray;
+    }
+
+    private static JSONObject getJsonOGContentTestObject() throws JSONException {
+        JSONObject testOGContent = new JSONObject();
+        testOGContent.put("fbsdk:create", true);
+        testOGContent.put("namespaced:field", 4);
+        testOGContent.put("og:field", 5);
+        testOGContent.put("custom:namespaced:field", 6);
+
+        JSONObject innerContent = new JSONObject();
+        innerContent.put("namespaced:field", 7);
+        innerContent.put("og:field", 8);
+        testOGContent.put("namespaced:innerContent", innerContent);
+        return testOGContent;
+    }
+
+    private static JSONObject getJsonOGContentTestObjectWithoutNamespace() throws JSONException {
+        JSONObject testOGContent = new JSONObject();
+        testOGContent.put("fbsdk:create", true);
+        testOGContent.put("field", 5);
+
+        JSONObject innerContent = new JSONObject();
+        innerContent.put("field", 8);
+        JSONObject innerData = new JSONObject();
+        innerData.put("field", 7);
+        innerContent.put("data", innerData);
+
+        JSONObject data = new JSONObject();
+        data.put("field", 4);
+        data.put("namespaced:field", 6);
+        data.put("innerContent", innerContent);
+
+        testOGContent.put("data", data);
+        return testOGContent;
+    }
+
+    private boolean simpleJsonObjComparer(JSONObject obj1, JSONObject obj2) {
+        if (obj1.names().length() != obj2.names().length()) {
+            return false;
+        }
+
+        Iterator<String> keys = obj1.keys();
+        while (keys.hasNext()) {
+            try {
+                String key = keys.next();
+                Object value1 = obj1.get(key);
+                Object value2 = obj2.get(key);
+                if (!jsonObjectValueComparer(value1, value2)){
+                    return false;
+                }
+            } catch (Exception ex) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean simpleJsonArrayComparer(JSONArray array1, JSONArray array2)
+            throws JSONException{
+        if(array1.length() != array2.length()) {
+            return  false;
+        }
+
+        for(int i = 0; i < array1.length(); ++i) {
+            if (!jsonObjectValueComparer(array1.get(i), array2.get(i))){
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private boolean jsonObjectValueComparer(Object value1, Object value2)
+    throws JSONException{
+        if (value1 instanceof JSONObject) {
+            if (!simpleJsonObjComparer((JSONObject) value1, (JSONObject) value2)) {
+                return false;
+            }
+        } else if (value1 instanceof JSONArray) {
+            if (!simpleJsonArrayComparer((JSONArray) value1, (JSONArray) value2)) {
+                return false;
+            }
+        } else if (value1 != value2) {
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/UtilityIntersectRangeTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/UtilityIntersectRangeTest.java
new file mode 100644
index 000000000..d134cffc7
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/UtilityIntersectRangeTest.java
@@ -0,0 +1,105 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.FacebookTestCase;
+
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static org.junit.Assert.*;
+
+
+public class UtilityIntersectRangeTest extends FacebookTestCase {
+
+    @Test
+    public void testIntersectRangesBothEmpty() {
+        int[] range1 = new int[0];
+        int[] range2 = new int[0];
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @Test
+    public void testIntersectRangesOneEmpty() {
+        int[] range1 = new int[0];
+        int[] range2 = new int[]{1, 10};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @Test
+    public void testIntersectRangesBothSameAndClosed() {
+        int[] range1 = new int[]{20, 30};
+        int[] range2 = new int[]{20, 30};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30}));
+    }
+
+    @Test
+    public void testIntersectRangesNoIntersect() {
+        int[] range1 = new int[]{20, 30};
+        int[] range2 = new int[]{30, 50};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @Test
+    public void testIntersectRangesSubsets() {
+        int[] range1 = new int[]{20, 100};
+        int[] range2 = new int[]{30, 40, 50, 60, 99, 100};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{30, 40, 50, 60, 99, 100}));
+    }
+
+    @Test
+    public void testIntersectRangesOverlap() {
+        int[] range1 = new int[]{20, 40, 60, 80};
+        int[] range2 = new int[]{10, 30, 50, 70};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70}));
+    }
+
+    @Test
+    public void testIntersectRangesDifferentLengthsClosed() {
+        int[] range1 = new int[]{20, 40, 60, 80};
+        int[] range2 = new int[]{10, 30, 50, 70, 90, 110};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70}));
+    }
+
+    @Test
+    public void testIntersectRangesDifferentLengthsOneOpen() {
+        int[] range1 = new int[]{10, 30, 50, 70, 90, 110};
+        int[] range2 = new int[]{20, 40, 60};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70, 90, 110}));
+    }
+
+    @Test
+    public void testIntersectRangesDifferentLengthsBothOpen() {
+        int[] range1 = new int[]{10, 30, 50};
+        int[] range2 = new int[]{20, 40, 60};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60}));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/internal/UtilityTest.java b/facebook/junitTests/src/test/java/com/facebook/internal/UtilityTest.java
new file mode 100644
index 000000000..205e3107f
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/UtilityTest.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.os.Parcel;
+
+import com.facebook.FacebookTestCase;
+
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+public class UtilityTest extends FacebookTestCase {
+
+    @Test
+    public void testStringMapToParcel() {
+        // Test null
+        assertNull(roundtrip(null));
+
+        HashMap<String, String> map = new HashMap<>();
+
+        // Test empty
+        assertEquals(0, roundtrip(map).size());
+
+        // Test regular
+        map.put("a", "100");
+        map.put("b", null);
+        map.put("c", "hello");
+
+        Map<String, String> result = roundtrip(map);
+        assertEquals(3, result.size());
+        assertEquals(map, result);
+        assertEquals("100", result.get("a"));
+        assertNull(result.get("b"));
+        assertEquals("hello", result.get("c"));
+    }
+
+    private Map<String, String> roundtrip(Map<String, String> input) {
+        Parcel parcel = Parcel.obtain();
+        try {
+            Utility.writeStringMapToParcel(parcel, input);
+            parcel.setDataPosition(0);
+            return Utility.readStringMapFromParcel(parcel);
+        } finally {
+            parcel.recycle();
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/ValidateTests.java b/facebook/junitTests/src/test/java/com/facebook/internal/ValidateTest.java
similarity index 57%
rename from facebook/tests/src/com/facebook/internal/ValidateTests.java
rename to facebook/junitTests/src/test/java/com/facebook/internal/ValidateTest.java
index 54d164b6e..60c1fde4a 100644
--- a/facebook/tests/src/com/facebook/internal/ValidateTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/ValidateTest.java
@@ -1,35 +1,42 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Validate;
+import com.facebook.FacebookTestCase;
 
 import java.util.Arrays;
 
-public class ValidateTests extends AndroidTestCase {
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+
+public class ValidateTest extends FacebookTestCase {
     
-    @SmallTest
+    @Test
     public void testNotNullOnNonNull() {
         Validate.notNull("A string", "name");
     }
 
-    @SmallTest
+    @Test
     public void testNotNullOnNull() {
         try {
             Validate.notNull(null, "name");
@@ -38,12 +45,12 @@ public void testNotNullOnNull() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testNotEmptyOnNonEmpty() {
         Validate.notEmpty(Arrays.asList(new String[] { "hi" }), "name");
     }
 
-    @SmallTest
+    @Test
     public void testNotEmptylOnEmpty() {
         try {
             Validate.notEmpty(Arrays.asList(new String[] {}), "name");
@@ -52,12 +59,12 @@ public void testNotEmptylOnEmpty() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testNotNullOrEmptyOnNonEmpty() {
         Validate.notNullOrEmpty("hi", "name");
     }
 
-    @SmallTest
+    @Test
     public void testNotNullOrEmptyOnEmpty() {
         try {
             Validate.notNullOrEmpty("", "name");
@@ -66,7 +73,7 @@ public void testNotNullOrEmptyOnEmpty() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testNotNullOrEmptyOnNull() {
         try {
             Validate.notNullOrEmpty(null, "name");
@@ -75,12 +82,12 @@ public void testNotNullOrEmptyOnNull() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testOneOfOnValid() {
         Validate.oneOf("hi", "name", "hi", "there");
     }
 
-    @SmallTest
+    @Test
     public void testOneOfOnInvalid() {
         try {
             Validate.oneOf("hit", "name", "hi", "there");
@@ -89,12 +96,12 @@ public void testOneOfOnInvalid() {
         }
     }
 
-    @SmallTest
+    @Test
     public void testOneOfOnValidNull() {
         Validate.oneOf(null, "name", "hi", "there", null);
     }
 
-    @SmallTest
+    @Test
     public void testOneOfOnInvalidNull() {
         try {
             Validate.oneOf(null, "name", "hi", "there");
diff --git a/facebook/tests/src/com/facebook/internal/WorkQueueTests.java b/facebook/junitTests/src/test/java/com/facebook/internal/WorkQueueTest.java
similarity index 88%
rename from facebook/tests/src/com/facebook/internal/WorkQueueTests.java
rename to facebook/junitTests/src/test/java/com/facebook/internal/WorkQueueTest.java
index 793911245..983410c58 100644
--- a/facebook/tests/src/com/facebook/internal/WorkQueueTests.java
+++ b/facebook/junitTests/src/test/java/com/facebook/internal/WorkQueueTest.java
@@ -1,44 +1,44 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
 import com.facebook.FacebookTestCase;
-import com.facebook.internal.WorkQueue;
 
+import org.junit.Test;
+
+import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.concurrent.Executor;
-import java.security.SecureRandom;
 
-public class WorkQueueTests extends FacebookTestCase {
+import static org.junit.Assert.*;
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+public class WorkQueueTest extends FacebookTestCase {
+
+    @Test
     public void testEmptyValidate() {
         WorkQueue manager = new WorkQueue();
         manager.validate();
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testRunSomething() {
         CountingRunnable run = new CountingRunnable();
         assertEquals(0, run.getRunCount());
@@ -57,9 +57,7 @@ public void testRunSomething() {
         assertEquals(1, run.getRunCount());
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testRunSequence() {
         final int workTotal = 100;
 
@@ -81,9 +79,7 @@ public void testRunSequence() {
         assertEquals(workTotal, run.getRunCount());
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testRunParallel() {
         final int workTotal = 100;
 
@@ -105,9 +101,7 @@ public void testRunParallel() {
         assertEquals(workTotal, run.getRunCount());
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testSimpleCancel() {
         CountingRunnable run = new CountingRunnable();
         ScriptableExecutor executor = new ScriptableExecutor();
@@ -122,9 +116,7 @@ public void testSimpleCancel() {
         assertEquals(0, executor.getPendingCount());
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
+    @Test
     public void testMoveToFront() {
         final int firstCount = 8;
         final int highCount = 17;
@@ -175,8 +167,7 @@ public void testMoveToFront() {
     }
 
     // Test cancelling running work item, completed work item
-
-    @LargeTest
+    @Test
     public void testThreadStress() {
         WorkQueue manager = new WorkQueue();
         ArrayList<StressRunnable> runnables = new ArrayList<StressRunnable>();
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/GetTokenLoginMethodHandlerTest.java b/facebook/junitTests/src/test/java/com/facebook/login/GetTokenLoginMethodHandlerTest.java
new file mode 100644
index 000000000..4f5e86e10
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/GetTokenLoginMethodHandlerTest.java
@@ -0,0 +1,137 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Intent;
+import android.os.Bundle;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.TestUtils;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Utility;
+
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@PrepareForTest( { LoginClient.class })
+public class GetTokenLoginMethodHandlerTest extends LoginHandlerTestCase {
+
+    @Test
+    public void testGetTokenHandlesSuccessWithAllPermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS,
+            new ArrayList<String>(PERMISSIONS));
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH,
+            new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+        bundle.putString(NativeProtocol.EXTRA_USER_ID, USER_ID);
+
+        GetTokenLoginMethodHandler handler = new GetTokenLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.getTokenCompleted(request, bundle);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);
+
+        AccessToken token = result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
+    }
+
+    @Test
+    public void testGetTokenHandlesSuccessWithOnlySomePermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS,
+            new ArrayList<String>(Arrays.asList("go outside")));
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH,
+            new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        GetTokenLoginMethodHandler handler = new GetTokenLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        handler.getTokenCompleted(request, bundle);
+
+        verify(mockLoginClient, never()).completeAndValidate(any(LoginClient.Result.class));
+        verify(mockLoginClient, times(1)).tryNextHandler();
+    }
+
+    @Test
+    public void testGetTokenHandlesNoResult() {
+        GetTokenLoginMethodHandler handler = new GetTokenLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        handler.getTokenCompleted(request, null);
+
+        verify(mockLoginClient, never()).completeAndValidate(any(LoginClient.Result.class));
+        verify(mockLoginClient, times(1)).tryNextHandler();
+    }
+
+
+    @Test
+    public void testFromNativeLogin() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        String userId = "1000";
+
+        long nowSeconds = new Date().getTime() / 1000;
+        Intent intent = new Intent();
+        intent.putExtra(NativeProtocol.EXTRA_ACCESS_TOKEN, token);
+        intent.putExtra(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, nowSeconds + 60L);
+        intent.putExtra(NativeProtocol.EXTRA_PERMISSIONS, permissions);
+        intent.putExtra(NativeProtocol.EXTRA_USER_ID, userId);
+
+        AccessToken accessToken = GetTokenLoginMethodHandler.createAccessTokenFromNativeLogin(
+                intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, "1234");
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
+        assertTrue(!accessToken.isExpired());
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/KatanaProxyLoginMethodHandlerTest.java b/facebook/junitTests/src/test/java/com/facebook/login/KatanaProxyLoginMethodHandlerTest.java
new file mode 100644
index 000000000..c0b044900
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/KatanaProxyLoginMethodHandlerTest.java
@@ -0,0 +1,166 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookSdk;
+import com.facebook.TestUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.Date;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@PrepareForTest( { LoginClient.class })
+public class KatanaProxyLoginMethodHandlerTest extends LoginHandlerTestCase {
+    private final static String SIGNED_REQUEST_STR = "ggarbage.eyJhbGdvcml0aG0iOiJITUFDSEEyNTYiLCJ"
+            + "jb2RlIjoid2h5bm90IiwiaXNzdWVkX2F0IjoxNDIyNTAyMDkyLCJ1c2VyX2lkIjoiMTIzIn0";
+
+    @Before
+    @Override
+    public void before() throws Exception {
+        super.before();
+        FacebookSdk.sdkInitialize(Robolectric.application);
+    }
+
+    @Test
+    public void testProxyAuthHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putLong("expires_in", EXPIRES_IN_DELTA);
+        bundle.putString("access_token", ACCESS_TOKEN);
+        bundle.putString("signed_request", SIGNED_REQUEST_STR);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        when(mockLoginClient.getPendingRequest()).thenReturn(request);
+
+        handler.tryAuthorize(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);
+
+        AccessToken token = result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
+    }
+
+    @Test
+    public void testProxyAuthHandlesCancel() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.tryAuthorize(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.CANCEL, result.code);
+
+        assertNull(result.token);
+        assertNotNull(result.errorMessage);
+        assertTrue(result.errorMessage.contains(ERROR_MESSAGE));
+    }
+
+    @Test
+    public void testProxyAuthHandlesCancelErrorMessage() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "access_denied");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.tryAuthorize(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.CANCEL, result.code);
+
+        assertNull(result.token);
+    }
+
+    @Test
+    public void testProxyAuthHandlesDisabled() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "service_disabled");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.tryAuthorize(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        verify(mockLoginClient, never()).completeAndValidate(any(LoginClient.Result.class));
+        verify(mockLoginClient, times(1)).tryNextHandler();
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/LoginClientTest.java b/facebook/junitTests/src/test/java/com/facebook/login/LoginClientTest.java
new file mode 100644
index 000000000..cd2919827
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/LoginClientTest.java
@@ -0,0 +1,175 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookPowerMockTestCase;
+import com.facebook.FacebookSdk;
+import com.facebook.TestUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+import java.util.HashSet;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@PrepareForTest({ LoginClient.class })
+public class LoginClientTest extends FacebookPowerMockTestCase {
+
+    private static final String ACCESS_TOKEN = "An access token for user 1";
+    private static final String USER_ID = "1001";
+    private static final String APP_ID = "2002";
+
+
+    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
+    private static final HashSet<String> PERMISSIONS = new HashSet<String>(
+        Arrays.asList("go outside", "come back in"));
+    private static final String ERROR_MESSAGE = "This is bad!";
+
+    @Mock private Fragment mockFragment;
+
+    @Before
+    public void before() throws Exception {
+        FragmentActivity activity =
+            Robolectric.buildActivity(FragmentActivity.class).create().get();
+        when(mockFragment.getActivity()).thenReturn(activity);
+    }
+
+    @Test
+    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+        LoginClient.Request request = createRequest(ACCESS_TOKEN);
+
+        AccessToken token = new AccessToken(
+                ACCESS_TOKEN,
+                APP_ID,
+                USER_ID,
+                PERMISSIONS,
+                null,
+                null,
+                null,
+                null);
+        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);
+
+        LoginClient.OnCompletedListener listener = mock(LoginClient.OnCompletedListener.class);
+
+        LoginClient client = new LoginClient(mockFragment);
+        client.setOnCompletedListener(listener);
+
+        client.completeAndValidate(result);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+            ArgumentCaptor.forClass(LoginClient.Result.class);
+
+        verify(listener).onCompleted(resultArgumentCaptor.capture());
+
+        result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);
+
+        AccessToken resultToken = result.token;
+        assertNotNull(resultToken);
+        assertEquals(ACCESS_TOKEN, resultToken.getToken());
+
+        // We don't care about ordering.
+        assertEquals(PERMISSIONS, resultToken.getPermissions());
+    }
+
+    @Test
+    public void testRequestParceling() {
+        LoginClient.Request request = createRequest(ACCESS_TOKEN);
+
+        LoginClient.Request unparceledRequest = TestUtils.parcelAndUnparcel(request);
+
+        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, unparceledRequest.getLoginBehavior());
+        assertEquals(new HashSet<String>(PERMISSIONS), unparceledRequest.getPermissions());
+        assertEquals(DefaultAudience.FRIENDS, unparceledRequest.getDefaultAudience());
+        assertEquals("1234", unparceledRequest.getApplicationId());
+        assertEquals("5678", unparceledRequest.getAuthId());
+        assertFalse(unparceledRequest.isRerequest());
+    }
+
+    @Test
+    public void testResultParceling() {
+        LoginClient.Request request = new LoginClient.Request(
+                LoginBehavior.SUPPRESS_SSO,
+                null,
+                DefaultAudience.EVERYONE,
+                null,
+                null);
+        request.setRerequest(true);
+        AccessToken token1 = new AccessToken(
+                "Token2",
+                "12345",
+                "1000",
+                null,
+                null,
+                null,
+                null,
+                null);
+        LoginClient.Result result = new LoginClient.Result(
+                request,
+                LoginClient.Result.Code.SUCCESS,
+                token1,
+                "error 1",
+                "123"
+        );
+
+        LoginClient.Result unparceledResult = TestUtils.parcelAndUnparcel(result);
+        LoginClient.Request unparceledRequest = unparceledResult.request;
+
+        assertEquals(LoginBehavior.SUPPRESS_SSO, unparceledRequest.getLoginBehavior());
+        assertEquals(new HashSet<String>(), unparceledRequest.getPermissions());
+        assertEquals(DefaultAudience.EVERYONE, unparceledRequest.getDefaultAudience());
+        assertEquals(null, unparceledRequest.getApplicationId());
+        assertEquals(null, unparceledRequest.getAuthId());
+        assertTrue(unparceledRequest.isRerequest());
+
+        assertEquals(LoginClient.Result.Code.SUCCESS, unparceledResult.code);
+        assertEquals(token1, unparceledResult.token);
+        assertEquals("error 1", unparceledResult.errorMessage);
+        assertEquals("123", unparceledResult.errorCode);
+    }
+
+
+    protected LoginClient.Request createRequest(String previousAccessTokenString) {
+        return new LoginClient.Request(
+                LoginBehavior.SSO_WITH_FALLBACK,
+                new HashSet<String>(PERMISSIONS),
+                DefaultAudience.FRIENDS,
+                "1234",
+                "5678");
+    }
+
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/LoginHandlerTestCase.java b/facebook/junitTests/src/test/java/com/facebook/login/LoginHandlerTestCase.java
new file mode 100644
index 000000000..cd256a96a
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/LoginHandlerTestCase.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.support.v4.app.FragmentActivity;
+
+import com.facebook.FacebookPowerMockTestCase;
+
+import org.junit.Before;
+import org.robolectric.Robolectric;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashSet;
+
+import static org.junit.Assert.assertTrue;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+public abstract class LoginHandlerTestCase extends FacebookPowerMockTestCase {
+    protected static final String ACCESS_TOKEN = "An access token";
+    protected static final String USER_ID = "1000";
+    protected static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
+    protected static final HashSet<String> PERMISSIONS = new HashSet<String>(
+            Arrays.asList("go outside", "come back in"));
+    protected static final String ERROR_MESSAGE = "This is bad!";
+
+    protected FragmentActivity activity;
+    protected LoginClient mockLoginClient;
+
+    @Before
+    public void before() throws Exception {
+        mockLoginClient = mock(LoginClient.class);
+        activity = Robolectric.buildActivity(FragmentActivity.class).create().get();
+        when(mockLoginClient.getActivity()).thenReturn(activity);
+    }
+
+    protected LoginClient.Request createRequest() {
+        return createRequest(null);
+    }
+
+    protected LoginClient.Request createRequest(String previousAccessTokenString) {
+
+        return new LoginClient.Request(
+                LoginBehavior.SSO_WITH_FALLBACK,
+                new HashSet<String>(PERMISSIONS),
+                DefaultAudience.FRIENDS,
+                "1234",
+                "5678");
+    }
+
+    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference,
+                                                long deltaInMsec) {
+
+        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
+        assertTrue(delta < deltaInMsec);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/LoginManagerTest.java b/facebook/junitTests/src/test/java/com/facebook/login/LoginManagerTest.java
new file mode 100644
index 000000000..eadbb97e1
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/LoginManagerTest.java
@@ -0,0 +1,565 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.FacebookActivity;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookPowerMockTestCase;
+import com.facebook.FacebookSdk;
+import com.facebook.FacebookSdkNotInitializedException;
+import com.facebook.Profile;
+
+import org.apache.maven.profiles.ProfileManager;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.*;
+
+@PrepareForTest({ FacebookSdk.class, AccessToken.class, Profile.class})
+public class LoginManagerTest extends FacebookPowerMockTestCase {
+
+    private static final String MOCK_APP_ID = "1234";
+    private static final String USER_ID = "1000";
+    private final String TOKEN_STRING = "A token of my esteem";
+    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
+    private final Date EXPIRES = new Date(2025, 5, 3);
+    private final Date LAST_REFRESH = new Date(2023, 8, 15);
+
+    @Mock private Activity mockActivity;
+    @Mock private Fragment mockFragment;
+    @Mock private Context mockApplicationContext;
+    @Mock private PackageManager mockPackageManager;
+    @Mock private FacebookCallback<LoginResult> mockCallback;
+    @Mock private ThreadPoolExecutor threadExecutor;
+    @Mock private FragmentActivity mockFragmentActivity;
+
+    @Before
+    public void before() throws Exception {
+        mockStatic(FacebookSdk.class);
+        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(null);
+        stub(method(AccessToken.class, "setCurrentAccessToken")).toReturn(null);
+        stub(method(Profile.class, "fetchProfileForCurrentAccessToken")).toReturn(null);
+
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        when(FacebookSdk.getApplicationId()).thenReturn(MOCK_APP_ID);
+        when(FacebookSdk.getApplicationContext()).thenReturn(mockApplicationContext);
+        when(FacebookSdk.getExecutor()).thenReturn(threadExecutor);
+        when(mockFragment.getActivity()).thenReturn(mockFragmentActivity);
+
+        // We use mocks rather than RobolectricPackageManager because it's simpler to not
+        // have to specify Intents. Default to resolving all intents to something.
+        ResolveInfo resolveInfo = new ResolveInfo();
+        when(mockApplicationContext.getPackageManager()).thenReturn(mockPackageManager);
+        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt()))
+                .thenReturn(resolveInfo);
+    }
+
+    @Test
+    public void testRequiresSdkToBeInitialized() {
+        try {
+            when(FacebookSdk.isInitialized()).thenReturn(false);
+
+            LoginManager loginManager = new LoginManager();
+
+            fail();
+        } catch (FacebookSdkNotInitializedException exception) {
+        }
+    }
+
+    @Test
+    public void testGetInstance() {
+        LoginManager loginManager = LoginManager.getInstance();
+        assertNotNull(loginManager);
+    }
+
+    @Test
+    public void testLoginBehaviorDefaultsToSsoWithFallback() {
+        LoginManager loginManager = new LoginManager();
+        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, loginManager.getLoginBehavior());
+    }
+
+    @Test
+    public void testCanChangeLoginBehavior() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
+        assertEquals(LoginBehavior.SSO_ONLY, loginManager.getLoginBehavior());
+    }
+
+    @Test
+    public void testDefaultAudienceDefaultsToFriends() {
+        LoginManager loginManager = new LoginManager();
+        assertEquals(DefaultAudience.FRIENDS, loginManager.getDefaultAudience());
+    }
+
+    @Test
+    public void testCanChangeDefaultAudience() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
+        assertEquals(DefaultAudience.EVERYONE, loginManager.getDefaultAudience());
+    }
+
+    @Test
+    public void testLogInWithReadAndActivityThrowsIfPublishPermissionGiven() {
+        LoginManager loginManager = new LoginManager();
+        try {
+            loginManager.logInWithReadPermissions(mockActivity,
+                Arrays.asList("public_profile", "publish_actions"));
+            fail();
+        } catch(FacebookException exception) {
+        }
+    }
+
+    @Test
+    public void testLogInWithPublishAndActivityThrowsIfPublishPermissionGiven() {
+        LoginManager loginManager = new LoginManager();
+        try {
+            loginManager.logInWithPublishPermissions(mockActivity,
+                Arrays.asList("public_profile", "publish_actions"));
+            fail();
+        } catch(FacebookException exception) {
+        }
+    }
+
+    @Test
+    public void testLogInThrowsIfCannotResolveFacebookActivity() {
+        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt())).thenReturn(null);
+
+        LoginManager loginManager = new LoginManager();
+
+        try {
+            loginManager.logInWithReadPermissions(mockActivity,
+                Arrays.asList("public_profile", "user_friends"));
+            fail();
+        } catch(FacebookException exception) {
+        }
+    }
+
+    @Test
+    public void testLogInThrowsIfCannotStartFacebookActivity() {
+        doThrow(new ActivityNotFoundException()).when(mockActivity)
+            .startActivityForResult(any(Intent.class), anyInt());
+
+        LoginManager loginManager = new LoginManager();
+
+        try {
+            loginManager.logInWithReadPermissions(mockActivity,
+                Arrays.asList("public_profile", "user_friends"));
+            fail();
+        } catch(FacebookException exception) {
+        }
+    }
+
+    @Test
+    public void testRequiresNonNullActivity() {
+        try {
+            LoginManager loginManager = new LoginManager();
+            loginManager.logInWithReadPermissions((Activity) null,
+                Arrays.asList("public_profile", "user_friends"));
+            fail();
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testRequiresNonNullFragment() {
+        try {
+            LoginManager loginManager = new LoginManager();
+            loginManager.logInWithReadPermissions((Fragment) null,
+                    Arrays.asList("public_profile", "user_friends"));
+            fail();
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @Test
+    public void testLogInWithReadDoesNotThrowWithReadPermissions() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+    }
+
+    @Test
+    public void testLogInWithReadListCreatesPendingRequestWithCorrectValues() {
+        LoginManager loginManager = new LoginManager();
+        // Change some defaults so we can verify the pending request picks them up.
+        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
+        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
+                Arrays.asList("public_profile", "user_friends"));
+    }
+
+    @Test
+    public void testLogInWithReadAndAccessTokenCreatesReauthRequest() {
+        AccessToken accessToken = createAccessToken();
+        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);
+
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        LoginClient.Request request = loginManager.getPendingLoginRequest();
+        assertNotNull(loginManager.getPendingLoginRequest());
+    }
+
+    public void implTestLogInCreatesPendingRequestWithCorrectValues(
+            LoginManager loginManager,
+            Collection<String> expectedPermissions) {
+
+        LoginClient.Request request = loginManager.getPendingLoginRequest();
+
+        assertNotNull(request);
+
+        assertEquals(MOCK_APP_ID, request.getApplicationId());
+        assertEquals(LoginBehavior.SSO_ONLY, request.getLoginBehavior());
+        assertEquals(DefaultAudience.EVERYONE, request.getDefaultAudience());
+
+        Set<String> permissions = request.getPermissions();
+        for (String permission : expectedPermissions) {
+            assertTrue(permissions.contains(permission));
+
+        }
+    }
+
+    @Test
+    public void testLogInWithReadAndActivityStartsFacebookActivityWithCorrectRequest() {
+
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(mockActivity).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
+        Intent intent = intentArgumentCaptor.getValue();
+
+        ComponentName componentName = intent.getComponent();
+        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
+        assertEquals(LoginBehavior.SSO_WITH_FALLBACK.name(), intent.getAction());
+    }
+
+    @Test
+    public void testLogInWithReadAndFragmentStartsFacebookActivityWithCorrectRequest() {
+
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockFragment,
+                Arrays.asList("public_profile", "user_friends"));
+
+        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(mockFragment).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
+        Intent intent = intentArgumentCaptor.getValue();
+
+        ComponentName componentName = intent.getComponent();
+        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
+        assertEquals(LoginBehavior.SSO_WITH_FALLBACK.name(), intent.getAction());
+    }
+
+    @Test
+    public void testLogInWitPublishDoesNotThrowWithPublishPermissions() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithPublishPermissions(mockActivity,
+            Arrays.asList("publish_actions", "publish_stream"));
+    }
+
+    @Test
+    public void testLogInWithPublishListCreatesPendingRequestWithCorrectValues() {
+        LoginManager loginManager = new LoginManager();
+        // Change some defaults so we can verify the pending request picks them up.
+        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
+        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
+        loginManager.logInWithPublishPermissions(mockActivity,
+            Arrays.asList("publish_actions", "publish_stream"));
+
+        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
+            Arrays.asList("publish_actions", "publish_stream"));
+    }
+
+    @Test
+    public void testLogInWithPublishAndAccessTokenCreatesReauthRequest() {
+        AccessToken accessToken = createAccessToken();
+        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);
+
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithPublishPermissions(mockActivity,
+            Arrays.asList("publish_actions", "publish_stream"));
+
+        assertNotNull(loginManager.getPendingLoginRequest());
+    }
+
+    @Test
+    public void testOnActivityResultReturnsFalseIfNoPendingRequest() {
+        LoginManager loginManager = new LoginManager();
+
+        Intent intent = createSuccessResultIntent();
+
+        boolean result = loginManager.onActivityResult(0, intent);
+
+        assertFalse(result);
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCode() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_CANCELED, null, mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onCancel();
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCodeEvenWithData() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        Intent intent = createSuccessResultIntent();
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_CANCELED, intent, mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onCancel();
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnCancelResultCode() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+                Arrays.asList("public_profile", "user_friends"));
+
+        loginManager.onActivityResult(Activity.RESULT_CANCELED, null, mockCallback);
+
+        verifyStatic(never());
+        AccessToken.setCurrentAccessToken(any(AccessToken.class));
+    }
+
+    @Test
+    public void testOnActivityResultHandlesMissingCallbackOnCancelResultCode() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_CANCELED,
+                null);
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnNullData() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, null, mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnMissingResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        Intent intent = createSuccessResultIntent();
+        intent.removeExtra(LoginFragment.RESULT_KEY);
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, intent, mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnErrorResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, createErrorResultIntent(), mockCallback);
+
+        ArgumentCaptor<FacebookException> exceptionArgumentCaptor =
+                ArgumentCaptor.forClass(FacebookException.class);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onError(exceptionArgumentCaptor.capture());
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+        assertEquals("foo: bar", exceptionArgumentCaptor.getValue().getMessage());
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_CANCELED, createCancelResultIntent(), mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, times(1)).onCancel();
+        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnErrorResultCode() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        loginManager.onActivityResult(
+                Activity.RESULT_CANCELED,
+                createErrorResultIntent(),
+                mockCallback);
+
+        verifyStatic(never());
+        AccessToken.setCurrentAccessToken(any(AccessToken.class));
+    }
+
+    @Test
+    public void testOnActivityResultReturnsTrueAndCallsCallbackOnSuccessResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);
+
+        assertTrue(result);
+        verify(mockCallback, never()).onError(any(FacebookException.class));
+        verify(mockCallback, times(1)).onSuccess(isA(LoginResult.class));
+    }
+
+    @Test
+    public void testOnHandlesMissingCallbackkOnSuccessResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, createSuccessResultIntent(), null);
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void testOnActivityResultSetsCurrentAccessTokenOnSuccessResult() {
+        LoginManager loginManager = new LoginManager();
+        loginManager.logInWithReadPermissions(mockActivity,
+            Arrays.asList("public_profile", "user_friends"));
+
+        boolean result = loginManager.onActivityResult(
+                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);
+
+        verifyStatic(times(1));
+        AccessToken.setCurrentAccessToken(eq(createAccessToken()));
+    }
+
+    private Intent createSuccessResultIntent() {
+        Intent intent = new Intent();
+
+        LoginClient.Request request = mock(LoginClient.Request.class);
+
+        AccessToken accessToken = createAccessToken();
+        LoginClient.Result result = LoginClient.Result.createTokenResult(request, accessToken);
+        intent.putExtra(LoginFragment.RESULT_KEY, result);
+
+        return intent;
+    }
+
+    private Intent createErrorResultIntent() {
+        Intent intent = new Intent();
+
+        LoginClient.Request request = mock(LoginClient.Request.class);
+
+        LoginClient.Result result = LoginClient.Result.createErrorResult(request, "foo", "bar");
+        intent.putExtra(LoginFragment.RESULT_KEY, result);
+
+        return intent;
+    }
+
+    private Intent createCancelResultIntent() {
+        Intent intent = new Intent();
+
+        LoginClient.Request request = mock(LoginClient.Request.class);
+
+        LoginClient.Result result = LoginClient.Result.createCancelResult(request, null);
+        intent.putExtra(LoginFragment.RESULT_KEY, result);
+
+        return intent;
+    }
+
+    private AccessToken createAccessToken() {
+        return new AccessToken(
+                TOKEN_STRING,
+                MOCK_APP_ID,
+                USER_ID,
+                PERMISSIONS,
+                null,
+                AccessTokenSource.WEB_VIEW,
+                EXPIRES,
+                LAST_REFRESH);
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/LoginResultTest.java b/facebook/junitTests/src/test/java/com/facebook/login/LoginResultTest.java
new file mode 100644
index 000000000..ba985e7ba
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/LoginResultTest.java
@@ -0,0 +1,111 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookSdk;
+import com.facebook.FacebookTestCase;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+
+public class LoginResultTest extends FacebookTestCase {
+
+    private final Set<String> EMAIL_SET = new HashSet<String>(){{ add("email"); }};
+    private final Set<String> LIKES_EMAIL_SET = new HashSet<String>(){{
+        add("user_likes");
+        add("email");
+    }};
+    private final Set<String> PROFILE_EMAIL_SET = new HashSet<String>(){{
+        add("user_profile");
+        add("email");
+    }};
+
+    @Before
+    public void before() throws Exception {
+        FacebookSdk.sdkInitialize(Robolectric.application);
+    }
+
+    @Test
+    public void testInitialLogin() {
+        LoginClient.Request request = createRequest(EMAIL_SET, false);
+        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
+        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
+        assertEquals(accessToken, result.getAccessToken());
+        assertEquals(PROFILE_EMAIL_SET, result.getRecentlyGrantedPermissions());
+        assertEquals(0, result.getRecentlyDeniedPermissions().size());
+    }
+
+    @Test
+    public void testReAuth() {
+        LoginClient.Request request = createRequest(EMAIL_SET, true);
+        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
+        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
+        assertEquals(accessToken, result.getAccessToken());
+        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
+        assertEquals(0, result.getRecentlyDeniedPermissions().size());
+    }
+
+    @Test
+    public void testDeniedPermissions() {
+        LoginClient.Request request = createRequest(LIKES_EMAIL_SET, true);
+        AccessToken accessToken = createAccessToken(EMAIL_SET, new HashSet<String>());
+        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
+        assertEquals(accessToken, result.getAccessToken());
+        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
+        assertEquals(
+                new HashSet<String>(){{ add("user_likes"); }},
+                result.getRecentlyDeniedPermissions());
+    }
+
+
+    private AccessToken createAccessToken(Set<String> permissions,
+                                          Set<String> declinedPermissions) {
+        return new AccessToken(
+            "token",
+            "123",
+            "234",
+            permissions,
+            declinedPermissions,
+            null,
+            null,
+            null
+        );
+    }
+
+    private LoginClient.Request createRequest(Set<String> permissions, boolean isRerequest) {
+        LoginClient.Request request = new LoginClient.Request(
+                LoginBehavior.SSO_WITH_FALLBACK,
+                permissions,
+                DefaultAudience.EVERYONE,
+                "123",
+                "authid"
+        );
+        request.setRerequest(isRerequest);
+        return request;
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/WebViewLoginMethodHandlerTest.java b/facebook/junitTests/src/test/java/com/facebook/login/WebViewLoginMethodHandlerTest.java
new file mode 100644
index 000000000..b37f6cc23
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/WebViewLoginMethodHandlerTest.java
@@ -0,0 +1,186 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Intent;
+import android.os.Bundle;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.FacebookException;
+import com.facebook.FacebookOperationCanceledException;
+import com.facebook.TestUtils;
+import com.facebook.internal.Utility;
+
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+
+import java.util.Date;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@PrepareForTest( { LoginClient.class })
+public class WebViewLoginMethodHandlerTest extends LoginHandlerTestCase {
+    private final static String SIGNED_REQUEST_STR = "ggarbage.eyJhbGdvcml0aG0iOiJITUFDSEEyNTYiLCJ"
+            + "jb2RlIjoid2h5bm90IiwiaXNzdWVkX2F0IjoxNDIyNTAyMDkyLCJ1c2VyX2lkIjoiMTIzIn0";
+
+    @Test
+    public void testWebViewHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", ACCESS_TOKEN);
+        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
+        bundle.putString("code", "Something else");
+        bundle.putString("signed_request", SIGNED_REQUEST_STR);
+
+        WebViewLoginMethodHandler handler = new WebViewLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.onWebDialogComplete(request, bundle, null);
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);
+
+        AccessToken token = result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
+    }
+
+    @Test
+    public void testWebViewHandlesCancel() {
+        WebViewLoginMethodHandler handler = new WebViewLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.onWebDialogComplete(request, null, new FacebookOperationCanceledException());
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.CANCEL, result.code);
+        assertNull(result.token);
+        assertNotNull(result.errorMessage);
+    }
+
+    @Test
+    public void testWebViewHandlesError() {
+        WebViewLoginMethodHandler handler = new WebViewLoginMethodHandler(mockLoginClient);
+
+        LoginClient.Request request = createRequest();
+        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+        LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.ERROR, result.code);
+        assertNull(result.token);
+        assertNotNull(result.errorMessage);
+        assertEquals(ERROR_MESSAGE, result.errorMessage);
+    }
+
+
+    @Test
+    public void testFromDialog() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        String userId = "1000";
+
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", token);
+        bundle.putString("expires_in", "60");
+        bundle.putString("signed_request", SIGNED_REQUEST_STR);
+
+        AccessToken accessToken = LoginMethodHandler.createAccessTokenFromWebBundle(
+                permissions,
+                bundle,
+                AccessTokenSource.WEB_VIEW,
+                "1234");
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.WEB_VIEW, accessToken.getSource());
+        assertTrue(!accessToken.isExpired());
+    }
+
+    @Test
+    public void testFromSSOWithExpiresString() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", "60");
+        intent.putExtra("extra_extra", "Something unrelated");
+        intent.putExtra("signed_request", SIGNED_REQUEST_STR);
+
+        AccessToken accessToken = LoginMethodHandler.createAccessTokenFromWebBundle(
+                permissions,
+                intent.getExtras(),
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                "1234");
+
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isExpired());
+    }
+
+    @Test
+    public void testFromSSOWithExpiresLong() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", 60L);
+        intent.putExtra("extra_extra", "Something unrelated");
+        intent.putExtra("signed_request", SIGNED_REQUEST_STR);
+
+        AccessToken accessToken = LoginMethodHandler.createAccessTokenFromWebBundle(
+                permissions,
+                intent.getExtras(),
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                "1234");
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isExpired());
+    }
+
+
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/login/widget/LoginButtonTest.java b/facebook/junitTests/src/test/java/com/facebook/login/widget/LoginButtonTest.java
new file mode 100644
index 000000000..9cf532c7f
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/login/widget/LoginButtonTest.java
@@ -0,0 +1,109 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login.widget;
+
+import android.app.Activity;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.junittests.MainActivity;
+import com.facebook.junittests.R;
+import com.facebook.login.DefaultAudience;
+import com.facebook.login.LoginManager;
+
+import org.junit.Test;
+import org.robolectric.Robolectric;
+
+import java.util.ArrayList;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyCollection;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.mock;
+
+public class LoginButtonTest extends FacebookTestCase {
+
+    @Test
+    public void testLoginButtonWithReadPermissions() throws Exception {
+        LoginManager loginManager = mock(LoginManager.class);
+        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
+
+        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
+        ArrayList<String> permissions = new ArrayList<>();
+        permissions.add("user_location");
+        loginButton.setReadPermissions(permissions);
+        loginButton.setDefaultAudience(DefaultAudience.EVERYONE);
+        loginButton.setLoginManager(loginManager);
+        loginButton.performClick();
+
+        verify(loginManager).logInWithReadPermissions(activity, permissions);
+        verify(loginManager, never())
+                .logInWithPublishPermissions(isA(Activity.class), anyCollection());
+        // Verify default audience is channeled
+        verify(loginManager).setDefaultAudience(DefaultAudience.EVERYONE);
+    }
+
+    @Test
+    public void testLoginButtonWithPublishPermissions() throws Exception {
+        LoginManager loginManager = mock(LoginManager.class);
+        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
+
+        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
+        ArrayList<String> permissions = new ArrayList<>();
+        permissions.add("publish_actions");
+        loginButton.setPublishPermissions(permissions);
+        loginButton.setLoginManager(loginManager);
+        loginButton.performClick();
+
+        verify(loginManager, never())
+                .logInWithReadPermissions(isA(Activity.class), anyCollection());
+        verify(loginManager).logInWithPublishPermissions(activity, permissions);
+    }
+
+    @Test
+    public void testCantSetReadThenPublishPermissions() throws Exception {
+        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
+
+        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
+        loginButton.setReadPermissions("user_location");
+        try {
+            loginButton.setPublishPermissions("publish_actions");
+        } catch (UnsupportedOperationException e) {
+            return;
+        }
+        fail();
+    }
+
+    @Test
+    public void testCantSetPublishThenReadPermissions() throws Exception {
+        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
+
+        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
+        loginButton.setPublishPermissions("publish_actions");
+        try {
+            loginButton.setReadPermissions("user_location");
+        } catch (UnsupportedOperationException e) {
+            return;
+        }
+        fail();
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/messenger/MessengerUtilsTest.java b/facebook/junitTests/src/test/java/com/facebook/messenger/MessengerUtilsTest.java
new file mode 100644
index 000000000..5012a5f37
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/messenger/MessengerUtilsTest.java
@@ -0,0 +1,273 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.messenger;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.facebook.FacebookSdk;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
+
+/**
+ * Tests for {@link com.facebook.messenger.MessengerUtils}
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(emulateSdk = 18, manifest = Config.NONE)
+public class MessengerUtilsTest {
+
+  private Activity mMockActivity;
+  private PackageManager mMockPackageManager;
+  private ContentResolver mMockContentResolver;
+
+  @Before
+  public void setup() {
+    mMockActivity = mock(Activity.class);
+    mMockPackageManager = mock(PackageManager.class);
+    mMockContentResolver = mock(ContentResolver.class);
+    when(mMockActivity.getPackageManager()).thenReturn(mMockPackageManager);
+    when(mMockActivity.getContentResolver()).thenReturn(mMockContentResolver);
+    FacebookSdk.sdkInitialize(Robolectric.application);
+    FacebookSdk.setApplicationId("200");
+  }
+
+  @Test
+  public void testMessengerIsInstalled() throws Exception {
+    setupPackageManagerForMessenger(true);
+    assertTrue(MessengerUtils.hasMessengerInstalled(mMockActivity));
+  }
+
+  @Test
+  public void testMessengerNotInstalled() throws Exception {
+    setupPackageManagerForMessenger(false);
+    assertFalse(MessengerUtils.hasMessengerInstalled(mMockActivity));
+  }
+
+  @Test
+  public void testShareToMessengerWith20150314Protocol() throws Exception {
+    setupPackageManagerForMessenger(true);
+    setupContentResolverForProtocolVersions(20150314);
+
+
+    Uri uri = Uri.parse("file:///foo.jpeg");
+    Uri externalUri = Uri.parse("http://example.com/foo.jpeg");
+    ShareToMessengerParams params = ShareToMessengerParams
+        .newBuilder(uri, "image/jpeg")
+        .setMetaData("{}")
+        .setExternalUri(externalUri)
+        .build();
+    MessengerUtils.shareToMessenger(mMockActivity, 1, params);
+
+    // Expect it to have launched messenger with the right intent.
+    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+    verify(mMockActivity).startActivityForResult(
+        intentArgumentCaptor.capture(),
+        eq(1));
+    Intent intent = intentArgumentCaptor.getValue();
+    assertEquals(Intent.ACTION_SEND, intent.getAction());
+    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
+    assertEquals("com.facebook.orca", intent.getPackage());
+    assertEquals(uri, intent.getParcelableExtra(Intent.EXTRA_STREAM));
+    assertEquals("image/jpeg", intent.getType());
+    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
+    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
+    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
+    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
+  }
+
+  @Test
+  public void testShareToMessengerWithNoProtocol() throws Exception {
+    setupPackageManagerForMessenger(true);
+    setupContentResolverForProtocolVersions(/* empty */);
+
+    Uri uri = Uri.parse("file:///foo.jpeg");
+    Uri externalUri = Uri.parse("http://example.com/foo.jpeg");
+    ShareToMessengerParams params = ShareToMessengerParams
+        .newBuilder(uri, "image/jpeg")
+        .setMetaData("{}")
+        .setExternalUri(externalUri)
+        .build();
+    MessengerUtils.shareToMessenger(mMockActivity, 1, params);
+
+
+    // Expect it to have gone to the play store.
+    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+    verify(mMockActivity).startActivity(intentArgumentCaptor.capture());
+    Intent intent = intentArgumentCaptor.getValue();
+    assertEquals(Intent.ACTION_VIEW, intent.getAction());
+    assertEquals(Uri.parse("market://details?id=com.facebook.orca"), intent.getData());
+  }
+
+  @Test
+  public void testGetMessengerThreadParamsForIntentWith20150314Protocol() throws Exception {
+    // Simulate an intent that Messenger would send.
+    Intent intent = new Intent();
+    intent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
+    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(intent);
+    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
+    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
+    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
+    extrasBundle.putBoolean("com.facebook.orca.extra.IS_REPLY", true);
+
+    // Check the parsing logic.
+    MessengerThreadParams params = MessengerUtils.getMessengerThreadParamsForIntent(intent);
+    assertEquals(MessengerThreadParams.Origin.REPLY_FLOW, params.origin);
+    assertEquals("thread_token", params.threadToken);
+    assertEquals("{}", params.metadata);
+    assertEquals(Arrays.asList("100", "400", "500"), params.participants);
+  }
+
+  @Test
+  public void testGetMessengerThreadParamsForIntentWithUnrecognizedIntent() throws Exception {
+    // Simulate an intent that Messenger would send.
+    Intent intent = new Intent();
+    assertNull(MessengerUtils.getMessengerThreadParamsForIntent(intent));
+  }
+
+  @Test
+  public void testFinishShareToMessengerWith20150314Protocol() throws Exception {
+    // Simulate an intent that Messenger would send.
+    Intent originalIntent = new Intent();
+    originalIntent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
+    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(originalIntent);
+    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
+    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
+    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
+    when(mMockActivity.getIntent()).thenReturn(originalIntent);
+
+    // Setup the data the app will send back to messenger.
+    Uri uri = Uri.parse("file:///foo.jpeg");
+    Uri externalUri = Uri.parse("http://example.com/foo.jpeg");
+    ShareToMessengerParams params = ShareToMessengerParams
+        .newBuilder(uri, "image/jpeg")
+        .setMetaData("{}")
+        .setExternalUri(externalUri)
+        .build();
+
+    // Call finishShareToMessenger and verify the results.
+    MessengerUtils.finishShareToMessenger(mMockActivity, params);
+    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+    verify(mMockActivity).setResult(eq(Activity.RESULT_OK), intentArgumentCaptor.capture());
+    verify(mMockActivity).finish();
+
+    Intent intent = intentArgumentCaptor.getValue();
+    assertNotNull(intent);
+    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
+    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
+    assertEquals("thread_token", intent.getStringExtra("com.facebook.orca.extra.THREAD_TOKEN"));
+    assertEquals(uri, intent.getData());
+    assertEquals("image/jpeg", intent.getType());
+    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
+    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
+    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
+  }
+
+  @Test
+  public void testFinishShareToMessengerWithUnexpectedIntent() throws Exception {
+    // Simulate an intent that Messenger would send.
+    Intent originalIntent = new Intent();
+    when(mMockActivity.getIntent()).thenReturn(originalIntent);
+
+    // Setup the data the app will send back to messenger.
+    Uri uri = Uri.parse("file:///foo.jpeg");
+    Uri externalUri = Uri.parse("http://example.com/foo.jpeg");
+    ShareToMessengerParams params = ShareToMessengerParams
+        .newBuilder(uri, "image/jpeg")
+        .setMetaData("{}")
+        .setExternalUri(externalUri)
+        .build();
+
+    // Call finishShareToMessenger and verify the results.
+    MessengerUtils.finishShareToMessenger(mMockActivity, params);
+    verify(mMockActivity).setResult(Activity.RESULT_CANCELED, null);
+    verify(mMockActivity).finish();
+  }
+
+  /**
+   * Sets up the PackageManager to return what we expect depending on whether messenger is
+   * installed.
+   *
+   * @param isInstalled true to simulate that messenger is installed
+   */
+  private void setupPackageManagerForMessenger(boolean isInstalled) throws Exception {
+    if (isInstalled) {
+      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
+          .thenReturn(new PackageInfo());
+    } else {
+      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
+          .thenThrow(new PackageManager.NameNotFoundException());
+    }
+  }
+
+  /**
+   * Sets up the Messenger content resolver to reply that it supports the specified versions.
+   *
+   * @param versions the versions that it should support
+   */
+  private void setupContentResolverForProtocolVersions(int... versions) {
+    MatrixCursor matrixCursor = new MatrixCursor(new String[]{"version"});
+    for (int version : versions) {
+      matrixCursor.addRow(new Object[]{version});
+    }
+
+    when(mMockContentResolver.query(
+        Uri.parse("content://com.facebook.orca.provider.MessengerPlatformProvider/versions"),
+        new String[]{"version"},
+        null,
+        null,
+        null))
+        .thenReturn(matrixCursor);
+  }
+
+  /**
+   * Adds the structure to the Intent to look like an app link and returns the Extras section
+   * which is where the messenger parameters go.
+   *
+   * @param intent the intent to add to
+   * @return the extras Bundle
+   */
+  private Bundle setupIntentWithAppLinkExtrasBundle(Intent intent) {
+    Bundle appLinksDataBundle = new Bundle();
+    intent.putExtra("al_applink_data", appLinksDataBundle);
+    Bundle extrasBundle = new Bundle();
+    appLinksDataBundle.putBundle("extras", extrasBundle);
+    return extrasBundle;
+  }
+
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/internal/ShareOpenGraphUtilityTest.java b/facebook/junitTests/src/test/java/com/facebook/share/internal/ShareOpenGraphUtilityTest.java
new file mode 100644
index 000000000..0654be83e
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/internal/ShareOpenGraphUtilityTest.java
@@ -0,0 +1,94 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphObject;
+
+import org.apache.maven.artifact.ant.shaded.IOUtil;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Test;
+import org.robolectric.Robolectric;
+import org.robolectric.util.RobolectricBackgroundExecutorService;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+
+import static junit.framework.Assert.assertNotNull;
+
+public class ShareOpenGraphUtilityTest extends FacebookTestCase {
+    private static final String TYPE_KEY = "type";
+
+    @Test
+    public void testToJSONObject() throws IOException, JSONException {
+        final JSONObject actual = OpenGraphJSONUtility.toJSONObject(this.getAction(), null);
+        final JSONObject expected = this.getActionJSONObject();
+        TestUtils.assertEquals(expected, actual);
+    }
+
+    private static <E> ArrayList<E> createArrayList(E... params) {
+        final ArrayList<E> list = new ArrayList<E>();
+        for (E item : params) {
+            list.add(item);
+        }
+        return list;
+    }
+
+    private ShareOpenGraphAction getAction() {
+        return new ShareOpenGraphAction.Builder()
+                .putString(TYPE_KEY, "myActionType")
+                .putObject(
+                        "myObject",
+                        new ShareOpenGraphObject.Builder()
+                                .putString("myString", "value")
+                                .putInt("myInt", 42)
+                                .putBoolean("myBoolean", true)
+                                .putStringArrayList(
+                                        "myStringArray",
+                                        createArrayList(
+                                                "string1",
+                                                "string2",
+                                                "string3")
+                                )
+                                .putObject(
+                                        "myObject",
+                                        new ShareOpenGraphObject.Builder()
+                                                .putDouble("myPi", 3.14)
+                                                .build()
+                                )
+                                .build()).build();
+    }
+
+    private JSONObject getActionJSONObject() throws IOException, JSONException {
+        return new JSONObject(this.getActionJSONString());
+    }
+
+    private String getActionJSONString() throws IOException {
+        return TestUtils.getAssetFileStringContents(
+                Robolectric.getShadowApplication().getApplicationContext(),
+                "ShareOpenGraphUtilityTests_actionJSON.json"
+        );
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareLinkContentBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareLinkContentBuilderTest.java
new file mode 100644
index 000000000..23bfd895f
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareLinkContentBuilderTest.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ShareLinkContentBuilderTest extends FacebookTestCase {
+    @Test
+    public void testVideoBuilder() {
+        final ShareLinkContent content = ShareModelTestUtility.getLinkContentBuilder().build();
+        assertEquals(
+                ShareModelTestUtility.STATUS_CONTENT_DESCRIPTION,
+                content.getContentDescription());
+        assertEquals(
+                ShareModelTestUtility.STATUS_CONTENT_IMAGE_URL,
+                content.getImageUrl());
+        assertEquals(
+                ShareModelTestUtility.STATUS_CONTENT_TITLE,
+                content.getContentTitle());
+        ShareModelTestUtility.assertEquals(content, TestUtils.parcelAndUnparcel(content));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareModelTestUtility.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareModelTestUtility.java
new file mode 100644
index 000000000..4fd059002
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareModelTestUtility.java
@@ -0,0 +1,299 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Environment;
+
+import junit.framework.Assert;
+
+import java.util.*;
+
+public class ShareModelTestUtility {
+    public static final String OPEN_GRAPH_ACTION_TYPE = "myActionType";
+    public static final boolean OPEN_GRAPH_BOOLEAN_VALUE = true;
+    public static final String OPEN_GRAPH_BOOLEAN_VALUE_KEY = "OPEN_GRAPH_BOOLEAN_VALUE";
+    public static final boolean[] OPEN_GRAPH_BOOLEAN_ARRAY = { true, false };
+    public static final String OPEN_GRAPH_BOOLEAN_ARRAY_KEY = "OPEN_GRAPH_BOOLEAN_ARRAY";
+    public static final ShareOpenGraphAction OPEN_GRAPH_CONTENT_ACTION =
+            getOpenGraphActionBuilder().build();
+    public static final String OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_NAME = "myActionProperty";
+    public static final String OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_VALUE = "myActionPropertyValue";
+    public static final double OPEN_GRAPH_DOUBLE_VALUE = Double.MAX_VALUE;
+    public static final String OPEN_GRAPH_DOUBLE_VALUE_KEY = "OPEN_GRAPH_DOUBLE_VALUE";
+    public static final double[] OPEN_GRAPH_DOUBLE_ARRAY =
+            { Double.MIN_VALUE, -7, 0, 42, Double.MAX_VALUE };
+    public static final String OPEN_GRAPH_DOUBLE_ARRAY_KEY = "OPEN_GRAPH_DOUBLE_ARRAY";
+    public static final int OPEN_GRAPH_INT_VALUE = 42;
+    public static final String OPEN_GRAPH_INT_VALUE_KEY = "OPEN_GRAPH_INT_VALUE";
+    public static final int[] OPEN_GRAPH_INT_ARRAY =
+            { Integer.MIN_VALUE, -7, 0, 42, Integer.MAX_VALUE };
+    public static final String OPEN_GRAPH_INT_ARRAY_KEY = "OPEN_GRAPH_INT_ARRAY";
+    public static final long OPEN_GRAPH_LONG_VALUE = Long.MAX_VALUE;
+    public static final String OPEN_GRAPH_LONG_VALUE_KEY = "OPEN_GRAPH_LONG_VALUE";
+    public static final long[] OPEN_GRAPH_LONG_ARRAY =
+            { Long.MIN_VALUE, -7, 0, 42, Long.MAX_VALUE };
+    public static final String OPEN_GRAPH_LONG_ARRAY_KEY = "OPEN_GRAPH_LONG_ARRAY";
+    public static final String OPEN_GRAPH_STRING = "this is a string";
+    public static final String OPEN_GRAPH_STRING_KEY = "OPEN_GRAPH_STRING";
+    public static final ArrayList<String> OPEN_GRAPH_STRING_ARRAY_LIST = new ArrayList<String>() {{
+        add("string1");
+        add("string2");
+        add("string3");
+    }};
+    public static final String OPEN_GRAPH_STRING_ARRAY_LIST_KEY = "OPEN_GRAPH_STRING_ARRAY_LIST";
+    public static final String OPEN_GRAPH_UNUSED_KEY = "unused";
+    public static final Bitmap PHOTO_BITMAP = Bitmap.createBitmap(10, 10, Bitmap.Config.ALPHA_8);
+    public static final ArrayList<SharePhoto> PHOTO_CONTENT_PHOTOS = new ArrayList<SharePhoto>() {{
+        add(getPhotoBuilder(PhotoBuilderType.LOCAL_URL).build());
+    }};
+    public static final boolean PHOTO_USER_GENERATED = true;
+    public static final String STATUS_CONTENT_DESCRIPTION = "this is a description";
+    public static final Uri STATUS_CONTENT_IMAGE_URL = Uri.parse(
+            "http://www.facebook.com/image/url");
+    public static final String STATUS_CONTENT_TITLE = "this is a title";
+    public static final SharePhoto VIDEO_CONTENT_PREVIEW_PHOTO = getPhotoBuilder(
+            PhotoBuilderType.LOCAL_URL).build();
+    public static final ShareVideo VIDEO_CONTENT_VIDEO = getVideoBuilder().build();
+
+    public enum PhotoBuilderType {
+        BITMAP,
+        LOCAL_URL,
+    }
+
+    public static Uri getTestPhotoImageUrl() {
+        return Uri.parse("file://" +
+                        Environment.getExternalStorageDirectory().getPath() +
+                        "crazy-cat-photo.jpg");
+    }
+
+    public static Uri getTestVideoLocalUrl() {
+        return Uri.parse("file://" +
+                Environment.getExternalStorageDirectory().getPath() +
+                "crazy-cat-video.mp4");
+    }
+
+    public static ShareOpenGraphAction.Builder getOpenGraphActionBuilder() {
+        return prepareOpenGraphValueContainerBuilder(
+                new ShareOpenGraphAction.Builder())
+                .setActionType(OPEN_GRAPH_ACTION_TYPE)
+                .putString(
+                        OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_NAME,
+                        OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_VALUE);
+    }
+
+    public static ShareOpenGraphContent.Builder getOpenGraphContentBuilder() {
+        return new ShareOpenGraphContent.Builder()
+                .setAction(OPEN_GRAPH_CONTENT_ACTION)
+                .setPreviewPropertyName(OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_NAME)
+                ;
+    }
+
+    public static ShareOpenGraphObject.Builder getOpenGraphObjectBuilder() {
+        return prepareOpenGraphValueContainerBuilder(new ShareOpenGraphObject.Builder());
+    }
+
+    public static SharePhoto.Builder getPhotoBuilder(final PhotoBuilderType type) {
+        final SharePhoto.Builder builder = new SharePhoto.Builder().setUserGenerated(
+                PHOTO_USER_GENERATED);
+        switch (type) {
+            case BITMAP:
+                builder.setBitmap(PHOTO_BITMAP);
+                break;
+            case LOCAL_URL:
+                builder.setImageUrl(getTestPhotoImageUrl());
+                break;
+        }
+        return builder;
+    }
+
+    public static SharePhotoContent.Builder getPhotoContentBuilder() {
+        return new SharePhotoContent.Builder().addPhotos(PHOTO_CONTENT_PHOTOS);
+    }
+
+    public static ShareLinkContent.Builder getLinkContentBuilder() {
+        return new ShareLinkContent.Builder()
+                .setContentDescription(STATUS_CONTENT_DESCRIPTION)
+                .setImageUrl(STATUS_CONTENT_IMAGE_URL)
+                .setContentTitle(STATUS_CONTENT_TITLE)
+                ;
+    }
+
+    public static ShareVideo.Builder getVideoBuilder() {
+        return new ShareVideo.Builder().setLocalUrl(getTestVideoLocalUrl());
+    }
+
+    public static ShareVideoContent.Builder getVideoContentBuilder() {
+        return new ShareVideoContent.Builder()
+                .setPreviewPhoto(VIDEO_CONTENT_PREVIEW_PHOTO)
+                .setVideo(VIDEO_CONTENT_VIDEO)
+                ;
+    }
+
+    private static <E extends ShareOpenGraphValueContainer.Builder> E
+    prepareOpenGraphValueContainerBuilder(
+            final E builder
+    ) {
+        return (E)builder
+                .putBoolean(OPEN_GRAPH_BOOLEAN_VALUE_KEY, OPEN_GRAPH_BOOLEAN_VALUE)
+                .putBooleanArray(OPEN_GRAPH_BOOLEAN_ARRAY_KEY, OPEN_GRAPH_BOOLEAN_ARRAY)
+                .putDouble(OPEN_GRAPH_DOUBLE_VALUE_KEY, OPEN_GRAPH_DOUBLE_VALUE)
+                .putDoubleArray(OPEN_GRAPH_DOUBLE_ARRAY_KEY, OPEN_GRAPH_DOUBLE_ARRAY)
+                .putInt(OPEN_GRAPH_INT_VALUE_KEY, OPEN_GRAPH_INT_VALUE)
+                .putIntArray(OPEN_GRAPH_INT_ARRAY_KEY, OPEN_GRAPH_INT_ARRAY)
+                .putLong(OPEN_GRAPH_LONG_VALUE_KEY, OPEN_GRAPH_LONG_VALUE)
+                .putLongArray(OPEN_GRAPH_LONG_ARRAY_KEY, OPEN_GRAPH_LONG_ARRAY)
+                .putString(OPEN_GRAPH_STRING_KEY, OPEN_GRAPH_STRING)
+                .putStringArrayList(OPEN_GRAPH_STRING_ARRAY_LIST_KEY, OPEN_GRAPH_STRING_ARRAY_LIST)
+                ;
+    }
+
+    public static <E> void assertEquals(final E a, final E b) {
+        if (a == null) {
+            // if a is null, b should be null
+            Assert.assertNull(b);
+        } else if ((a instanceof boolean[]) && (b instanceof boolean[])) {
+            // check for arrays of all of the primitive types, then arrays of Object, and route
+            // those through Arrays equals
+            Assert.assertTrue(Arrays.equals((boolean[]) a, (boolean[]) b));
+        } else if ((a instanceof byte[]) && (b instanceof byte[])) {
+            Assert.assertTrue(Arrays.equals((byte[])a, (byte[])b));
+        } else if ((a instanceof char[]) && (b instanceof char[])) {
+            Assert.assertTrue(Arrays.equals((char[])a, (char[])b));
+        } else if ((a instanceof double[]) && (b instanceof double[])) {
+            Assert.assertTrue(Arrays.equals((double[])a, (double[])b));
+        } else if ((a instanceof float[]) && (b instanceof float[])) {
+            Assert.assertTrue(Arrays.equals((float[])a, (float[])b));
+        } else if ((a instanceof int[]) && (b instanceof int[])) {
+            Assert.assertTrue(Arrays.equals((int[])a, (int[])b));
+        } else if ((a instanceof long[]) && (b instanceof long[])) {
+            Assert.assertTrue(Arrays.equals((long[])a, (long[])b));
+        } else if ((a instanceof short[]) && (b instanceof short[])) {
+            Assert.assertTrue(Arrays.equals((short[])a, (short[])b));
+        } else if ((a instanceof Object[]) && (b instanceof Object[])) {
+            Assert.assertTrue(Arrays.deepEquals((Object[])a, (Object[])b));
+        } else if ((a instanceof List) && (b instanceof List)) {
+            // check for Lists
+            assertEquals((List)a, (List)b);
+        } else if ((a instanceof ShareModel) && (b instanceof ShareModel)) {
+            // check for ShareModels
+            assertEquals((ShareModel)a, (ShareModel)b);
+        } else {
+            // now use Object.equals
+            Assert.assertTrue(a.equals(b));
+        }
+    }
+
+    public static void assertEquals(final List a, final List b) {
+        final int size = a.size();
+        Assert.assertEquals(size, b.size());
+        for (int i = 0; i < size; ++i) {
+            assertEquals(a.get(i), b.get(i));
+        }
+    }
+
+    public static <E extends ShareModel> void assertEquals(final E a, final E b) {
+        if ((a instanceof ShareOpenGraphAction) && (b instanceof ShareOpenGraphAction)) {
+            assertEquals((ShareOpenGraphAction)a, (ShareOpenGraphAction)b);
+        } else if ((a instanceof ShareOpenGraphObject) && (b instanceof ShareOpenGraphObject)) {
+            assertEquals((ShareOpenGraphObject) a, (ShareOpenGraphObject) b);
+        } else if ((a instanceof ShareOpenGraphContent) && (b instanceof ShareOpenGraphContent)) {
+            assertEquals((ShareOpenGraphContent)a, (ShareOpenGraphContent)b);
+        } else if ((a instanceof SharePhoto) && (b instanceof SharePhoto)) {
+            assertEquals((SharePhoto)a, (SharePhoto)b);
+        } else if ((a instanceof SharePhotoContent) && (b instanceof SharePhotoContent)) {
+            assertEquals((SharePhotoContent)a, (SharePhotoContent)b);
+        } else if ((a instanceof ShareLinkContent) && (b instanceof ShareLinkContent)) {
+            assertEquals((ShareLinkContent)a, (ShareLinkContent)b);
+        } else if ((a instanceof ShareVideo) && (b instanceof ShareVideo)) {
+            assertEquals((ShareVideo)a, (ShareVideo)b);
+        } else if ((a instanceof ShareVideoContent) && (b instanceof ShareVideoContent)) {
+            assertEquals((ShareVideoContent)a, (ShareVideoContent)b);
+        } else {
+            Assert.fail(a.getClass().toString() + " models do not have an equality test");
+        }
+    }
+
+    public static void assertEquals(final ShareOpenGraphAction a, final ShareOpenGraphAction b) {
+        Assert.assertEquals(a.getActionType(), b.getActionType());
+        assertOpenGraphValueContainerEquals(a, b);
+    }
+
+    public static void assertEquals(final ShareOpenGraphContent a, final ShareOpenGraphContent b) {
+        assertEquals(a.getAction(), b.getAction());
+        Assert.assertEquals(a.getPreviewPropertyName(), b.getPreviewPropertyName());
+        assertContentEquals(a, b);
+    }
+
+    public static void assertEquals(final ShareOpenGraphObject a, final ShareOpenGraphObject b) {
+        assertOpenGraphValueContainerEquals(a, b);
+    }
+
+    public static void assertEquals(final SharePhoto a, final SharePhoto b) {
+        Assert.assertEquals(a.getBitmap(), b.getBitmap());
+        Assert.assertEquals(a.getImageUrl(), b.getImageUrl());
+        Assert.assertEquals(a.getUserGenerated(), b.getUserGenerated());
+    }
+
+    public static void assertEquals(final SharePhotoContent a, final SharePhotoContent b) {
+        assertEquals(a.getPhotos(), b.getPhotos());
+        assertContentEquals(a, b);
+    }
+
+    public static void assertEquals(final ShareLinkContent a, final ShareLinkContent b) {
+        Assert.assertEquals(a.getContentDescription(), b.getContentDescription());
+        Assert.assertEquals(a.getImageUrl(), b.getImageUrl());
+        Assert.assertEquals(a.getContentTitle(), b.getContentTitle());
+        assertContentEquals(a, b);
+    }
+
+    public static void assertEquals(final ShareVideo a, final ShareVideo b) {
+        Assert.assertEquals(a.getLocalUrl(), b.getLocalUrl());
+    }
+
+    public static void assertEquals(final ShareVideoContent a, final ShareVideoContent b) {
+        assertEquals(a.getPreviewPhoto(), b.getPreviewPhoto());
+        assertEquals(a.getVideo(), b.getVideo());
+        assertContentEquals(a, b);
+    }
+
+    private static void assertContentEquals(final ShareContent a, final ShareContent b) {
+        Assert.assertEquals(a.getContentUrl(), b.getContentUrl());
+        Assert.assertEquals(a.getPeopleIds(), b.getPeopleIds());
+        Assert.assertEquals(a.getPlaceId(), b.getPlaceId());
+        Assert.assertEquals(a.getRef(), b.getRef());
+    }
+
+    private static void assertOpenGraphValueContainerEquals(
+            final ShareOpenGraphValueContainer a,
+            final ShareOpenGraphValueContainer b
+    ) {
+        final HashSet<String> keySet = new HashSet<String>();
+        keySet.addAll(a.keySet());
+        keySet.addAll(b.keySet());
+        for (String key : keySet) {
+            assertEquals(a.get(key), b.get(key));
+        }
+    }
+
+    private ShareModelTestUtility() {}
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphActionBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphActionBuilderTest.java
new file mode 100644
index 000000000..cfba6e541
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphActionBuilderTest.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class ShareOpenGraphActionBuilderTest extends FacebookTestCase {
+    @Test
+    public void testVideoBuilder() {
+        final ShareOpenGraphAction action =
+                ShareModelTestUtility.getOpenGraphActionBuilder().build();
+        assertEquals(ShareModelTestUtility.OPEN_GRAPH_ACTION_TYPE, action.getActionType());
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE,
+                action.getBoolean(
+                        ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE_KEY,
+                        !ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE,
+                action.getBoolean(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_ARRAY,
+                action.getBooleanArray(ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_ARRAY_KEY));
+        assertNull(action.getBooleanArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE,
+                action.getDouble(ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE_KEY, 0),
+                TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE,
+                action.getDouble(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE),
+                TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_ARRAY,
+                action.getDoubleArray(ShareModelTestUtility.OPEN_GRAPH_DOUBLE_ARRAY_KEY));
+        assertNull(action.getDoubleArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_VALUE,
+                action.getInt(ShareModelTestUtility.OPEN_GRAPH_INT_VALUE_KEY, 0));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_VALUE,
+                action.getInt(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_INT_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_ARRAY,
+                action.getIntArray(ShareModelTestUtility.OPEN_GRAPH_INT_ARRAY_KEY));
+        assertNull(action.getIntArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE,
+                action.getLong(ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE_KEY, 0));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE,
+                action.getLong(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_ARRAY,
+                action.getLongArray(ShareModelTestUtility.OPEN_GRAPH_LONG_ARRAY_KEY));
+        assertNull(action.getLongArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_STRING,
+                action.getString(ShareModelTestUtility.OPEN_GRAPH_STRING_KEY));
+        assertNull(action.getString(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_STRING_ARRAY_LIST,
+                action.getStringArrayList(ShareModelTestUtility.OPEN_GRAPH_STRING_ARRAY_LIST_KEY));
+        assertNull(action.getStringArrayList(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        ShareModelTestUtility.assertEquals(action, TestUtils.parcelAndUnparcel(action));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphContentBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphContentBuilderTest.java
new file mode 100644
index 000000000..a1a0bd163
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphContentBuilderTest.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ShareOpenGraphContentBuilderTest extends FacebookTestCase {
+    @Test
+    public void testOpenGraphBuilder() {
+        final ShareOpenGraphContent content =
+                ShareModelTestUtility.getOpenGraphContentBuilder().build();
+        ShareModelTestUtility.assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_CONTENT_ACTION,
+                content.getAction());
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_CONTENT_PREVIEW_PROPERTY_NAME,
+                content.getPreviewPropertyName());
+        ShareModelTestUtility.assertEquals(content, TestUtils.parcelAndUnparcel(content));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphObjectBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphObjectBuilderTest.java
new file mode 100644
index 000000000..0643ddf51
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareOpenGraphObjectBuilderTest.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class ShareOpenGraphObjectBuilderTest extends FacebookTestCase {
+    @Test
+    public void testVideoBuilder() {
+        final ShareOpenGraphObject object =
+                ShareModelTestUtility.getOpenGraphObjectBuilder().build();
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE,
+                object.getBoolean(
+                        ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE_KEY,
+                        !ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE,
+                object.getBoolean(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_ARRAY,
+                object.getBooleanArray(ShareModelTestUtility.OPEN_GRAPH_BOOLEAN_ARRAY_KEY));
+        assertNull(object.getBooleanArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE,
+                object.getDouble(ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE_KEY, 0),
+                TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE,
+                object.getDouble(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_DOUBLE_VALUE),
+                TestUtils.DOUBLE_EQUALS_DELTA);
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_DOUBLE_ARRAY,
+                object.getDoubleArray(ShareModelTestUtility.OPEN_GRAPH_DOUBLE_ARRAY_KEY));
+        assertNull(object.getDoubleArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_VALUE,
+                object.getInt(ShareModelTestUtility.OPEN_GRAPH_INT_VALUE_KEY, 0));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_VALUE,
+                object.getInt(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_INT_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_INT_ARRAY,
+                object.getIntArray(ShareModelTestUtility.OPEN_GRAPH_INT_ARRAY_KEY));
+        assertNull(object.getIntArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE,
+                object.getLong(ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE_KEY, 0));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE,
+                object.getLong(
+                        ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY,
+                        ShareModelTestUtility.OPEN_GRAPH_LONG_VALUE));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_LONG_ARRAY,
+                object.getLongArray(ShareModelTestUtility.OPEN_GRAPH_LONG_ARRAY_KEY));
+        assertNull(object.getLongArray(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_STRING,
+                object.getString(ShareModelTestUtility.OPEN_GRAPH_STRING_KEY));
+        assertNull(object.getString(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        assertEquals(
+                ShareModelTestUtility.OPEN_GRAPH_STRING_ARRAY_LIST,
+                object.getStringArrayList(ShareModelTestUtility.OPEN_GRAPH_STRING_ARRAY_LIST_KEY));
+        assertNull(object.getStringArrayList(ShareModelTestUtility.OPEN_GRAPH_UNUSED_KEY));
+        ShareModelTestUtility.assertEquals(object, TestUtils.parcelAndUnparcel(object));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoBuilderTest.java
new file mode 100644
index 000000000..c6b9e53c5
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoBuilderTest.java
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class SharePhotoBuilderTest extends FacebookTestCase {
+    @Test
+    public void testPhotoBuilder() {
+        final SharePhoto photo = ShareModelTestUtility
+                .getPhotoBuilder(ShareModelTestUtility.PhotoBuilderType.LOCAL_URL)
+                .build();
+        assertEquals(ShareModelTestUtility.getTestPhotoImageUrl(), photo.getImageUrl());
+        assertEquals(ShareModelTestUtility.PHOTO_USER_GENERATED, photo.getUserGenerated());
+        ShareModelTestUtility.assertEquals(photo, TestUtils.parcelAndUnparcel(photo));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoContentBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoContentBuilderTest.java
new file mode 100644
index 000000000..6d327c2a6
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/SharePhotoContentBuilderTest.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+public class SharePhotoContentBuilderTest extends FacebookTestCase {
+    @Test
+    public void testPhotoBuilder() {
+        final SharePhotoContent content = ShareModelTestUtility.getPhotoContentBuilder().build();
+        ShareModelTestUtility.assertEquals(
+                ShareModelTestUtility.PHOTO_CONTENT_PHOTOS,
+                content.getPhotos());
+        ShareModelTestUtility.assertEquals(content, TestUtils.parcelAndUnparcel(content));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoBuilderTest.java
new file mode 100644
index 000000000..38ede93a4
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoBuilderTest.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ShareVideoBuilderTest extends FacebookTestCase {
+    @Test
+    public void testVideoBuilder() {
+        final ShareVideo video = ShareModelTestUtility.getVideoBuilder().build();
+        assertEquals(ShareModelTestUtility.getTestVideoLocalUrl(), video.getLocalUrl());
+        ShareModelTestUtility.assertEquals(video, TestUtils.parcelAndUnparcel(video));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoContentBuilderTest.java b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoContentBuilderTest.java
new file mode 100644
index 000000000..0d859b153
--- /dev/null
+++ b/facebook/junitTests/src/test/java/com/facebook/share/model/ShareVideoContentBuilderTest.java
@@ -0,0 +1,42 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import com.facebook.FacebookTestCase;
+import com.facebook.TestUtils;
+
+import org.junit.Test;
+
+public class ShareVideoContentBuilderTest extends FacebookTestCase {
+    @Test
+    public void testVideoBuilder() {
+        final ShareVideoContent content = ShareModelTestUtility.getVideoContentBuilder().build();
+        ShareModelTestUtility.assertEquals(
+                ShareModelTestUtility.VIDEO_CONTENT_PREVIEW_PHOTO,
+                content.getPreviewPhoto());
+        ShareModelTestUtility.assertEquals(
+                ShareModelTestUtility.VIDEO_CONTENT_VIDEO,
+                content.getVideo());
+        ShareModelTestUtility.assertEquals(
+                content,
+                TestUtils.parcelAndUnparcel(content));
+    }
+}
diff --git a/facebook/junitTests/src/test/java/org/mockito/configuration/MockitoConfiguration.java b/facebook/junitTests/src/test/java/org/mockito/configuration/MockitoConfiguration.java
new file mode 100644
index 000000000..0b3b0efef
--- /dev/null
+++ b/facebook/junitTests/src/test/java/org/mockito/configuration/MockitoConfiguration.java
@@ -0,0 +1,9 @@
+package org.mockito.configuration;
+
+public class MockitoConfiguration extends DefaultMockitoConfiguration {
+
+    @Override
+    public boolean enableClassCache() {
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/facebook/lint.xml b/facebook/lint.xml
new file mode 100644
index 000000000..57ebc724e
--- /dev/null
+++ b/facebook/lint.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="MissingTranslation" severity="ignore" />
+</lint>
diff --git a/facebook/project.properties b/facebook/project.properties
deleted file mode 100644
index 4a46b9d1c..000000000
--- a/facebook/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-android.library=true
-# Project target.
-target=android-17
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_blue_focused.9.png b/facebook/res/drawable-hdpi/com_facebook_button_blue_focused.9.png
deleted file mode 100644
index cf60eb0ac..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_blue_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_blue_normal.9.png b/facebook/res/drawable-hdpi/com_facebook_button_blue_normal.9.png
deleted file mode 100644
index ece0c4c94..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_blue_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_blue_pressed.9.png b/facebook/res/drawable-hdpi/com_facebook_button_blue_pressed.9.png
deleted file mode 100644
index a123c2555..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_blue_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png
deleted file mode 100644
index 2e6f66dbc..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png
deleted file mode 100644
index 6098f0b0e..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png
deleted file mode 100644
index 23b9757d1..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_icon.png b/facebook/res/drawable-hdpi/com_facebook_button_icon.png
new file mode 100644
index 000000000..c0d4688e5
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_icon.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..5e8ac3c99
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_send_icon.png b/facebook/res/drawable-hdpi/com_facebook_button_send_icon.png
new file mode 100644
index 000000000..dbc69dccc
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_send_icon.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_close.png b/facebook/res/drawable-hdpi/com_facebook_close.png
index d925cb7b2..d81f040d7 100644
Binary files a/facebook/res/drawable-hdpi/com_facebook_close.png and b/facebook/res/drawable-hdpi/com_facebook_close.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_inverse_icon.png b/facebook/res/drawable-hdpi/com_facebook_inverse_icon.png
deleted file mode 100644
index a7289c112..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_inverse_icon.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_logo.png b/facebook/res/drawable-hdpi/com_facebook_logo.png
deleted file mode 100644
index 26ab7945f..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_logo.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_picker_magnifier.png b/facebook/res/drawable-hdpi/com_facebook_picker_magnifier.png
deleted file mode 100644
index d6ec37d04..000000000
Binary files a/facebook/res/drawable-hdpi/com_facebook_picker_magnifier.png and /dev/null differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_black_background.9.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_background.9.png
new file mode 100644
index 000000000..2c5b1bbad
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_background.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_black_bottomnub.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_bottomnub.png
new file mode 100644
index 000000000..972010ec2
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_bottomnub.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_black_topnub.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_topnub.png
new file mode 100644
index 000000000..5d595c5a3
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_topnub.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_black_xout.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_xout.png
new file mode 100644
index 000000000..e2903b6de
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_black_xout.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_background.9.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_background.9.png
new file mode 100644
index 000000000..a42b3cd92
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_background.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_bottomnub.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_bottomnub.png
new file mode 100644
index 000000000..2d292f2ca
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_bottomnub.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_topnub.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_topnub.png
new file mode 100644
index 000000000..b2dcc4089
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_topnub.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_xout.png b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_xout.png
new file mode 100644
index 000000000..1285a1665
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_tooltip_blue_xout.png differ
diff --git a/facebook/res/drawable-hdpi/messenger_bubble_large_blue.png b/facebook/res/drawable-hdpi/messenger_bubble_large_blue.png
new file mode 100644
index 000000000..a58670371
Binary files /dev/null and b/facebook/res/drawable-hdpi/messenger_bubble_large_blue.png differ
diff --git a/facebook/res/drawable-hdpi/messenger_bubble_large_white.png b/facebook/res/drawable-hdpi/messenger_bubble_large_white.png
new file mode 100644
index 000000000..80be8f6de
Binary files /dev/null and b/facebook/res/drawable-hdpi/messenger_bubble_large_white.png differ
diff --git a/facebook/res/drawable-hdpi/messenger_bubble_small_blue.png b/facebook/res/drawable-hdpi/messenger_bubble_small_blue.png
new file mode 100644
index 000000000..d7a6fcd42
Binary files /dev/null and b/facebook/res/drawable-hdpi/messenger_bubble_small_blue.png differ
diff --git a/facebook/res/drawable-hdpi/messenger_bubble_small_white.png b/facebook/res/drawable-hdpi/messenger_bubble_small_white.png
new file mode 100644
index 000000000..b368abbaa
Binary files /dev/null and b/facebook/res/drawable-hdpi/messenger_bubble_small_white.png differ
diff --git a/facebook/res/drawable-hdpi/messenger_button_send_round_shadow.png b/facebook/res/drawable-hdpi/messenger_button_send_round_shadow.png
new file mode 100644
index 000000000..f369b4128
Binary files /dev/null and b/facebook/res/drawable-hdpi/messenger_button_send_round_shadow.png differ
diff --git a/facebook/res/drawable-ldpi/com_facebook_close.png b/facebook/res/drawable-ldpi/com_facebook_close.png
deleted file mode 100644
index fe4be250e..000000000
Binary files a/facebook/res/drawable-ldpi/com_facebook_close.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_blue_focused.9.png b/facebook/res/drawable-mdpi/com_facebook_button_blue_focused.9.png
deleted file mode 100644
index cfb7a015c..000000000
Binary files a/facebook/res/drawable-mdpi/com_facebook_button_blue_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_blue_normal.9.png b/facebook/res/drawable-mdpi/com_facebook_button_blue_normal.9.png
deleted file mode 100644
index 1e9390133..000000000
Binary files a/facebook/res/drawable-mdpi/com_facebook_button_blue_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_blue_pressed.9.png b/facebook/res/drawable-mdpi/com_facebook_button_blue_pressed.9.png
deleted file mode 100644
index d8427fdef..000000000
Binary files a/facebook/res/drawable-mdpi/com_facebook_button_blue_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_icon.png b/facebook/res/drawable-mdpi/com_facebook_button_icon.png
new file mode 100644
index 000000000..51d72dd32
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_button_icon.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-mdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..9834a4c14
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_button_send_icon.png b/facebook/res/drawable-mdpi/com_facebook_button_send_icon.png
new file mode 100644
index 000000000..5964bc945
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_button_send_icon.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_close.png b/facebook/res/drawable-mdpi/com_facebook_close.png
new file mode 100755
index 000000000..4ffc94cdc
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_close.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_inverse_icon.png b/facebook/res/drawable-mdpi/com_facebook_inverse_icon.png
deleted file mode 100644
index a806a2f5d..000000000
Binary files a/facebook/res/drawable-mdpi/com_facebook_inverse_icon.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_picker_magnifier.png b/facebook/res/drawable-mdpi/com_facebook_picker_magnifier.png
deleted file mode 100644
index c5170c18b..000000000
Binary files a/facebook/res/drawable-mdpi/com_facebook_picker_magnifier.png and /dev/null differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_portrait.png b/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_portrait.png
new file mode 100644
index 000000000..27a6f7a74
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_portrait.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_square.png b/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_square.png
new file mode 100644
index 000000000..77554e01f
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_profile_picture_blank_square.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_black_background.9.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_background.9.png
new file mode 100644
index 000000000..d10e30391
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_background.9.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_black_bottomnub.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_bottomnub.png
new file mode 100644
index 000000000..9378512ce
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_bottomnub.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_black_topnub.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_topnub.png
new file mode 100644
index 000000000..d94fa9688
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_topnub.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_black_xout.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_xout.png
new file mode 100644
index 000000000..51454e5a3
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_black_xout.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_background.9.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_background.9.png
new file mode 100644
index 000000000..bf60245bb
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_background.9.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_bottomnub.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_bottomnub.png
new file mode 100644
index 000000000..e0ac8fea8
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_bottomnub.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_topnub.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_topnub.png
new file mode 100644
index 000000000..e09406081
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_topnub.png differ
diff --git a/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_xout.png b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_xout.png
new file mode 100644
index 000000000..85699f8ec
Binary files /dev/null and b/facebook/res/drawable-mdpi/com_facebook_tooltip_blue_xout.png differ
diff --git a/facebook/res/drawable-mdpi/messenger_bubble_large_blue.png b/facebook/res/drawable-mdpi/messenger_bubble_large_blue.png
new file mode 100644
index 000000000..89ec1d6a1
Binary files /dev/null and b/facebook/res/drawable-mdpi/messenger_bubble_large_blue.png differ
diff --git a/facebook/res/drawable-mdpi/messenger_bubble_large_white.png b/facebook/res/drawable-mdpi/messenger_bubble_large_white.png
new file mode 100644
index 000000000..b62f660e1
Binary files /dev/null and b/facebook/res/drawable-mdpi/messenger_bubble_large_white.png differ
diff --git a/facebook/res/drawable-mdpi/messenger_bubble_small_blue.png b/facebook/res/drawable-mdpi/messenger_bubble_small_blue.png
new file mode 100644
index 000000000..cf4417797
Binary files /dev/null and b/facebook/res/drawable-mdpi/messenger_bubble_small_blue.png differ
diff --git a/facebook/res/drawable-mdpi/messenger_bubble_small_white.png b/facebook/res/drawable-mdpi/messenger_bubble_small_white.png
new file mode 100644
index 000000000..2f3a364ce
Binary files /dev/null and b/facebook/res/drawable-mdpi/messenger_bubble_small_white.png differ
diff --git a/facebook/res/drawable-mdpi/messenger_button_send_round_shadow.png b/facebook/res/drawable-mdpi/messenger_button_send_round_shadow.png
new file mode 100644
index 000000000..d5ebd1854
Binary files /dev/null and b/facebook/res/drawable-mdpi/messenger_button_send_round_shadow.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_blue_focused.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_blue_focused.9.png
deleted file mode 100644
index 5a47068d7..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_blue_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_blue_normal.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_blue_normal.9.png
deleted file mode 100644
index 1449c8a13..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_blue_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_blue_pressed.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_blue_pressed.9.png
deleted file mode 100644
index 28bd184ed..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_blue_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png
deleted file mode 100644
index bfd883f92..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png
deleted file mode 100644
index aa9895432..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png
deleted file mode 100644
index 92f2ad12a..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_icon.png b/facebook/res/drawable-xhdpi/com_facebook_button_icon.png
new file mode 100644
index 000000000..c4d7016b4
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_icon.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..ccb98d5e3
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_send_icon.png b/facebook/res/drawable-xhdpi/com_facebook_button_send_icon.png
new file mode 100644
index 000000000..a751b5fe8
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_send_icon.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_close.png b/facebook/res/drawable-xhdpi/com_facebook_close.png
index e3aff5ae5..b603ef892 100755
Binary files a/facebook/res/drawable-xhdpi/com_facebook_close.png and b/facebook/res/drawable-xhdpi/com_facebook_close.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_inverse_icon.png b/facebook/res/drawable-xhdpi/com_facebook_inverse_icon.png
deleted file mode 100644
index 4192c4887..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_inverse_icon.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_logo.png b/facebook/res/drawable-xhdpi/com_facebook_logo.png
deleted file mode 100644
index 24d7fc56b..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_logo.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_picker_magnifier.png b/facebook/res/drawable-xhdpi/com_facebook_picker_magnifier.png
deleted file mode 100644
index a5b372468..000000000
Binary files a/facebook/res/drawable-xhdpi/com_facebook_picker_magnifier.png and /dev/null differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_background.9.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_background.9.png
new file mode 100644
index 000000000..43b14c999
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_background.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_bottomnub.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_bottomnub.png
new file mode 100644
index 000000000..87f9795bc
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_bottomnub.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_topnub.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_topnub.png
new file mode 100644
index 000000000..4d3f58f6e
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_topnub.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_xout.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_xout.png
new file mode 100644
index 000000000..6cd7bc8d9
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_black_xout.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_background.9.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_background.9.png
new file mode 100644
index 000000000..7614b95c3
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_background.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_bottomnub.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_bottomnub.png
new file mode 100644
index 000000000..d29b95242
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_bottomnub.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_topnub.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_topnub.png
new file mode 100644
index 000000000..d2dc678ee
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_topnub.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_xout.png b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_xout.png
new file mode 100644
index 000000000..e9bc616f1
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_tooltip_blue_xout.png differ
diff --git a/facebook/res/drawable-xhdpi/messenger_bubble_large_blue.png b/facebook/res/drawable-xhdpi/messenger_bubble_large_blue.png
new file mode 100644
index 000000000..7bf06cc29
Binary files /dev/null and b/facebook/res/drawable-xhdpi/messenger_bubble_large_blue.png differ
diff --git a/facebook/res/drawable-xhdpi/messenger_bubble_large_white.png b/facebook/res/drawable-xhdpi/messenger_bubble_large_white.png
new file mode 100644
index 000000000..0743811ac
Binary files /dev/null and b/facebook/res/drawable-xhdpi/messenger_bubble_large_white.png differ
diff --git a/facebook/res/drawable-xhdpi/messenger_bubble_small_blue.png b/facebook/res/drawable-xhdpi/messenger_bubble_small_blue.png
new file mode 100644
index 000000000..8de9b46a8
Binary files /dev/null and b/facebook/res/drawable-xhdpi/messenger_bubble_small_blue.png differ
diff --git a/facebook/res/drawable-xhdpi/messenger_bubble_small_white.png b/facebook/res/drawable-xhdpi/messenger_bubble_small_white.png
new file mode 100644
index 000000000..9ed2cb28b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/messenger_bubble_small_white.png differ
diff --git a/facebook/res/drawable-xhdpi/messenger_button_send_round_shadow.png b/facebook/res/drawable-xhdpi/messenger_button_send_round_shadow.png
new file mode 100644
index 000000000..3f9382064
Binary files /dev/null and b/facebook/res/drawable-xhdpi/messenger_button_send_round_shadow.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_icon.png b/facebook/res/drawable-xxhdpi/com_facebook_button_icon.png
new file mode 100644
index 000000000..88d2169da
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_icon.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..41137fc92
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_send_icon.png b/facebook/res/drawable-xxhdpi/com_facebook_button_send_icon.png
new file mode 100644
index 000000000..a30068b98
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_send_icon.png differ
diff --git a/facebook/res/drawable-xxhdpi/messenger_bubble_large_blue.png b/facebook/res/drawable-xxhdpi/messenger_bubble_large_blue.png
new file mode 100644
index 000000000..7f18441ff
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/messenger_bubble_large_blue.png differ
diff --git a/facebook/res/drawable-xxhdpi/messenger_bubble_large_white.png b/facebook/res/drawable-xxhdpi/messenger_bubble_large_white.png
new file mode 100644
index 000000000..39e8f4d7b
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/messenger_bubble_large_white.png differ
diff --git a/facebook/res/drawable-xxhdpi/messenger_bubble_small_blue.png b/facebook/res/drawable-xxhdpi/messenger_bubble_small_blue.png
new file mode 100644
index 000000000..b5ad769bd
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/messenger_bubble_small_blue.png differ
diff --git a/facebook/res/drawable-xxhdpi/messenger_bubble_small_white.png b/facebook/res/drawable-xxhdpi/messenger_bubble_small_white.png
new file mode 100644
index 000000000..3134ed126
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/messenger_bubble_small_white.png differ
diff --git a/facebook/res/drawable-xxhdpi/messenger_button_send_round_shadow.png b/facebook/res/drawable-xxhdpi/messenger_button_send_round_shadow.png
new file mode 100644
index 000000000..5b88c0947
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/messenger_button_send_round_shadow.png differ
diff --git a/facebook/res/drawable/com_facebook_button_background.xml b/facebook/res/drawable/com_facebook_button_background.xml
new file mode 100644
index 000000000..cd814039c
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_background.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_enabled="false">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_disabled" />
+        </shape>
+    </item>
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_pressed" />
+        </shape>
+    </item>
+    <item>
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color" />
+        </shape>
+    </item>
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_blue.xml b/facebook/res/drawable/com_facebook_button_blue.xml
deleted file mode 100644
index 91aebe685..000000000
--- a/facebook/res/drawable/com_facebook_button_blue.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-
-  <item
-      android:drawable="@drawable/com_facebook_button_blue_pressed"
-      android:state_focused="true"
-      android:state_pressed="true"
-      />
-  <item
-      android:drawable="@drawable/com_facebook_button_blue_pressed"
-      android:state_focused="false"
-      android:state_pressed="true"
-      />
-  <item
-      android:drawable="@drawable/com_facebook_button_blue_focused"
-      android:state_focused="true"
-      />
-  <item
-      android:drawable="@drawable/com_facebook_button_blue_normal"
-      android:state_focused="false"
-      android:state_pressed="false"
-      />
-
-</selector>
diff --git a/facebook/res/drawable/com_facebook_button_blue_focused.9.png b/facebook/res/drawable/com_facebook_button_blue_focused.9.png
deleted file mode 100644
index cfb7a015c..000000000
Binary files a/facebook/res/drawable/com_facebook_button_blue_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_blue_normal.9.png b/facebook/res/drawable/com_facebook_button_blue_normal.9.png
deleted file mode 100644
index 1e9390133..000000000
Binary files a/facebook/res/drawable/com_facebook_button_blue_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_blue_pressed.9.png b/facebook/res/drawable/com_facebook_button_blue_pressed.9.png
deleted file mode 100644
index d8427fdef..000000000
Binary files a/facebook/res/drawable/com_facebook_button_blue_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_check.xml b/facebook/res/drawable/com_facebook_button_check.xml
deleted file mode 100644
index dfa510607..000000000
--- a/facebook/res/drawable/com_facebook_button_check.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-  <item android:state_checked="true" android:drawable="@drawable/com_facebook_button_check_on" />
-  <item android:drawable="@drawable/com_facebook_button_check_off" />
-</selector>
diff --git a/facebook/res/drawable/com_facebook_button_check_off.png b/facebook/res/drawable/com_facebook_button_check_off.png
deleted file mode 100644
index e9737df5c..000000000
Binary files a/facebook/res/drawable/com_facebook_button_check_off.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_focused.9.png b/facebook/res/drawable/com_facebook_button_grey_focused.9.png
deleted file mode 100644
index 56f603571..000000000
Binary files a/facebook/res/drawable/com_facebook_button_grey_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_normal.9.png b/facebook/res/drawable/com_facebook_button_grey_normal.9.png
deleted file mode 100644
index dff3b7d73..000000000
Binary files a/facebook/res/drawable/com_facebook_button_grey_normal.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable/com_facebook_button_grey_pressed.9.png
deleted file mode 100644
index 46648efcd..000000000
Binary files a/facebook/res/drawable/com_facebook_button_grey_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_button_like_background.xml b/facebook/res/drawable/com_facebook_button_like_background.xml
new file mode 100644
index 000000000..0aa75000f
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_like_background.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_enabled="false">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_disabled" />
+        </shape>
+    </item>
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_pressed" />
+        </shape>
+    </item>
+    <item android:state_selected="true">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_like_background_color_selected" />
+        </shape>
+    </item>
+    <item>
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color" />
+        </shape>
+    </item>
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_login_silver_background.xml b/facebook/res/drawable/com_facebook_button_login_silver_background.xml
new file mode 100644
index 000000000..b9cff4a61
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_login_silver_background.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_enabled="false">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_disabled" />
+        </shape>
+    </item>
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_login_silver_background_color_pressed" />
+        </shape>
+    </item>
+    <item>
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_login_silver_background_color" />
+        </shape>
+    </item>
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_send_background.xml b/facebook/res/drawable/com_facebook_button_send_background.xml
new file mode 100644
index 000000000..26d12d09e
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_send_background.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_enabled="false">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_background_color_disabled" />
+        </shape>
+    </item>
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_send_background_color_pressed" />
+        </shape>
+    </item>
+    <item>
+        <shape android:shape="rectangle">
+            <corners android:radius="2dp" />
+            <solid android:color="@color/com_facebook_button_send_background_color" />
+        </shape>
+    </item>
+</selector>
diff --git a/facebook/res/drawable/com_facebook_close.png b/facebook/res/drawable/com_facebook_close.png
deleted file mode 100755
index ad0147460..000000000
Binary files a/facebook/res/drawable/com_facebook_close.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_inverse_icon.png b/facebook/res/drawable/com_facebook_inverse_icon.png
deleted file mode 100644
index a806a2f5d..000000000
Binary files a/facebook/res/drawable/com_facebook_inverse_icon.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_list_divider.9.png b/facebook/res/drawable/com_facebook_list_divider.9.png
deleted file mode 100644
index 7d4c46c47..000000000
Binary files a/facebook/res/drawable/com_facebook_list_divider.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_list_section_header_background.9.png b/facebook/res/drawable/com_facebook_list_section_header_background.9.png
deleted file mode 100644
index 1763c4a64..000000000
Binary files a/facebook/res/drawable/com_facebook_list_section_header_background.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_silver.xml b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
deleted file mode 100644
index adf9885d7..000000000
--- a/facebook/res/drawable/com_facebook_loginbutton_silver.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<selector xmlns:android="http://schemas.android.com/apk/res/android" >
-    <item android:state_pressed="true" 
-          android:drawable="@drawable/com_facebook_button_grey_pressed" />
-    <item android:state_focused="true" 
-          android:drawable="@drawable/com_facebook_button_grey_focused" />
-    <item android:drawable="@drawable/com_facebook_button_grey_normal" />
-</selector>
diff --git a/facebook/res/drawable/com_facebook_logo.png b/facebook/res/drawable/com_facebook_logo.png
deleted file mode 100644
index 785acf9ea..000000000
Binary files a/facebook/res/drawable/com_facebook_logo.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_picker_item_background.xml b/facebook/res/drawable/com_facebook_picker_item_background.xml
deleted file mode 100644
index e43eb6cf5..000000000
--- a/facebook/res/drawable/com_facebook_picker_item_background.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-
-    <!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. -->
-    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
-    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
-    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
-    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
-    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
-    <item                                                                                          android:drawable="@android:color/transparent" />
-</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_focused.9.png b/facebook/res/drawable/com_facebook_picker_list_focused.9.png
deleted file mode 100644
index 7c0599e3a..000000000
Binary files a/facebook/res/drawable/com_facebook_picker_list_focused.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png b/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png
deleted file mode 100644
index 3bf8e0362..000000000
Binary files a/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_pressed.9.png b/facebook/res/drawable/com_facebook_picker_list_pressed.9.png
deleted file mode 100644
index 6e77525d2..000000000
Binary files a/facebook/res/drawable/com_facebook_picker_list_pressed.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector.xml b/facebook/res/drawable/com_facebook_picker_list_selector.xml
deleted file mode 100644
index b35deba5e..000000000
--- a/facebook/res/drawable/com_facebook_picker_list_selector.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-
-    <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
-
-    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
-    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
-    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
-    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
-    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
-
-</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml b/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
deleted file mode 100644
index 0e4aa8eb8..000000000
--- a/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2010 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<transition xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:drawable="@drawable/com_facebook_picker_list_pressed"  />
-    <item android:drawable="@drawable/com_facebook_picker_list_longpressed"  />
-</transition>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png b/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png
deleted file mode 100644
index 42cb6463e..000000000
Binary files a/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_picker_top_button.xml b/facebook/res/drawable/com_facebook_picker_top_button.xml
deleted file mode 100644
index d282105b0..000000000
--- a/facebook/res/drawable/com_facebook_picker_top_button.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<shape xmlns:android="http://schemas.android.com/apk/res/android">
-    <gradient
-            android:startColor="#3f5b96"
-            android:endColor="#2d4984"
-            android:angle="270"/>
-</shape>
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png
deleted file mode 100644
index 107d7f89e..000000000
Binary files a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png
deleted file mode 100644
index 8b4a76a0e..000000000
Binary files a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png and /dev/null differ
diff --git a/facebook/res/drawable/com_facebook_top_background.xml b/facebook/res/drawable/com_facebook_top_background.xml
deleted file mode 100644
index 9b2989709..000000000
--- a/facebook/res/drawable/com_facebook_top_background.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<shape xmlns:android="http://schemas.android.com/apk/res/android">
-  <gradient
-      android:startColor="#FF5975b0"
-      android:endColor="#FF47639e"
-      android:angle="270"/>
-</shape>
diff --git a/facebook/res/drawable/com_facebook_top_button.xml b/facebook/res/drawable/com_facebook_top_button.xml
deleted file mode 100644
index 7a60e4844..000000000
--- a/facebook/res/drawable/com_facebook_top_button.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:state_pressed="true"
-          android:drawable="@drawable/com_facebook_picker_top_button" />
-    <item android:state_focused="true"
-          android:drawable="@drawable/com_facebook_picker_top_button" />
-    <item android:state_selected="true"
-          android:drawable="@drawable/com_facebook_picker_top_button" />
-    <item
-            android:drawable="@drawable/com_facebook_top_background" />
-</selector>
diff --git a/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml b/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
deleted file mode 100644
index b28dab56c..000000000
--- a/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
-    <gradient
-      android:startColor="#5774B5"
-      android:endColor="#2C4988"
-      android:gradientRadius="495"
-      android:type="radial"/>
-</shape>    
diff --git a/facebook/res/drawable/messenger_button_blue_bg_round.xml b/facebook/res/drawable/messenger_button_blue_bg_round.xml
new file mode 100644
index 000000000..971aba7e7
--- /dev/null
+++ b/facebook/res/drawable/messenger_button_blue_bg_round.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<layer-list xmlns:android="http://schemas.android.com/apk/res/android" >
+  <item android:drawable="@drawable/messenger_button_send_round_shadow" />
+  <item
+    android:top="1dp"
+    android:bottom="2dp"
+    android:left="1dp"
+    android:right="1dp"
+    >
+    <selector>
+      <item android:state_pressed="true">
+        <shape android:shape="oval">
+          <solid android:color="#1f8eff" />
+        </shape>
+      </item>
+
+      <item>
+        <shape android:shape="oval">
+          <solid android:color="#0084ff" />
+        </shape>
+      </item>
+    </selector>
+  </item>
+
+  <item
+    android:top="1dp"
+    android:bottom="2dp"
+    android:left="1dp"
+    android:right="1dp"
+    >
+    <bitmap
+      android:src="@drawable/messenger_bubble_large_white"
+      android:gravity="center"
+      />
+  </item>
+</layer-list>
diff --git a/facebook/res/drawable/messenger_button_blue_bg_selector.xml b/facebook/res/drawable/messenger_button_blue_bg_selector.xml
new file mode 100644
index 000000000..248041038
--- /dev/null
+++ b/facebook/res/drawable/messenger_button_blue_bg_selector.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_pressed="true">
+    <shape android:shape="rectangle">
+      <corners android:radius="2dp" />
+      <solid android:color="#1f8eff" />
+    </shape>
+  </item>
+
+  <item>
+    <shape android:shape="rectangle">
+      <corners android:radius="2dp" />
+      <solid android:color="#0084ff" />
+    </shape>
+  </item>
+</selector>
diff --git a/facebook/res/drawable/messenger_button_white_bg_round.xml b/facebook/res/drawable/messenger_button_white_bg_round.xml
new file mode 100644
index 000000000..c6bccabc4
--- /dev/null
+++ b/facebook/res/drawable/messenger_button_white_bg_round.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<layer-list xmlns:android="http://schemas.android.com/apk/res/android" >
+  <item android:drawable="@drawable/messenger_button_send_round_shadow" />
+  <item
+    android:top="1dp"
+    android:bottom="2dp"
+    android:left="1dp"
+    android:right="1dp"
+    >
+    <selector>
+      <item android:state_pressed="true">
+        <shape android:shape="oval">
+          <solid android:color="#ebebeb" />
+        </shape>
+      </item>
+
+      <item>
+        <shape android:shape="oval">
+          <solid android:color="#ffffff" />
+        </shape>
+      </item>
+    </selector>
+  </item>
+
+  <item
+    android:top="1dp"
+    android:bottom="2dp"
+    android:left="1dp"
+    android:right="1dp"
+    >
+    <bitmap
+      android:src="@drawable/messenger_bubble_large_blue"
+      android:gravity="center"
+      />
+  </item>
+</layer-list>
diff --git a/facebook/res/drawable/messenger_button_white_bg_selector.xml b/facebook/res/drawable/messenger_button_white_bg_selector.xml
new file mode 100644
index 000000000..9035e21e7
--- /dev/null
+++ b/facebook/res/drawable/messenger_button_white_bg_selector.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_pressed="true">
+    <shape android:shape="rectangle">
+      <corners android:radius="2dp" />
+      <solid android:color="#ebebeb" />
+    </shape>
+  </item>
+
+  <item>
+    <shape android:shape="rectangle">
+      <corners android:radius="2dp" />
+      <solid android:color="#ffffff" />
+    </shape>
+  </item>
+</selector>
diff --git a/facebook/res/layout/com_facebook_activity_layout.xml b/facebook/res/layout/com_facebook_activity_layout.xml
new file mode 100644
index 000000000..db7f79cd3
--- /dev/null
+++ b/facebook/res/layout/com_facebook_activity_layout.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+             android:id="@+id/com_facebook_fragment_container"
+             android:layout_width="match_parent"
+             android:layout_height="match_parent"
+    />
diff --git a/facebook/res/layout/com_facebook_friendpickerfragment.xml b/facebook/res/layout/com_facebook_friendpickerfragment.xml
deleted file mode 100644
index b42f15e7d..000000000
--- a/facebook/res/layout/com_facebook_friendpickerfragment.xml
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-              android:background="#FFFFFF">
-
-    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
-
-    <ListView
-            android:id="@+id/com_facebook_picker_list_view"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            android:divider="@drawable/com_facebook_list_divider"
-            android:fastScrollEnabled="true"
-            android:scrollbars="vertical"
-            android:listSelector="@drawable/com_facebook_picker_list_selector"
-            android:cacheColorHint="#FFFFFF"
-            />
-
-    <ProgressBar android:indeterminate="true"
-                 android:layout_width="wrap_content"
-                 android:layout_height="wrap_content"
-                 android:id="@+id/com_facebook_picker_activity_circle"
-                 style="@android:style/Widget.ProgressBar"
-                 android:layout_centerInParent="true"
-                 android:visibility="invisible"
-            />
-</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_login_activity_layout.xml b/facebook/res/layout/com_facebook_login_activity_layout.xml
deleted file mode 100644
index 09b28999f..000000000
--- a/facebook/res/layout/com_facebook_login_activity_layout.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <ProgressBar android:indeterminate="true"
-                 android:layout_width="wrap_content"
-                 android:layout_height="50dip"
-                 android:id="@+id/com_facebook_login_activity_progress_bar"
-                 android:layout_centerInParent="true"
-                 android:visibility="gone"
-                 android:indeterminateOnly="true"
-            />
-</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_login_fragment.xml b/facebook/res/layout/com_facebook_login_fragment.xml
new file mode 100644
index 000000000..ef301ae85
--- /dev/null
+++ b/facebook/res/layout/com_facebook_login_fragment.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent">
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_login_activity_progress_bar"
+                 android:layout_centerInParent="true"
+                 android:visibility="gone"
+                 android:indeterminateOnly="true"
+        />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
deleted file mode 100644
index de3e7e323..000000000
--- a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<RelativeLayout
-        xmlns:android="http://schemas.android.com/apk/res/android"
-        android:layout_height="50dip"
-        android:layout_width="fill_parent"
-        >
-    <ProgressBar android:indeterminate="true"
-                 android:layout_width="wrap_content"
-                 android:layout_height="50dip"
-                 android:id="@+id/com_facebook_picker_row_activity_circle"
-                 style="@android:style/Widget.ProgressBar.Small"
-                 android:layout_centerInParent="true"
-                 android:visibility="visible"
-                 android:indeterminateOnly="true"
-            />
-</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_checkbox.xml b/facebook/res/layout/com_facebook_picker_checkbox.xml
deleted file mode 100644
index ecc4aa88e..000000000
--- a/facebook/res/layout/com_facebook_picker_checkbox.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<CheckBox
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/com_facebook_picker_checkbox"
-    android:layout_width="23dip"
-    android:layout_height="23dip"
-    android:focusable="false"
-    android:clickable="false"
-    android:button="@drawable/com_facebook_button_check" />
diff --git a/facebook/res/layout/com_facebook_picker_image.xml b/facebook/res/layout/com_facebook_picker_image.xml
deleted file mode 100644
index dd02cfe9c..000000000
--- a/facebook/res/layout/com_facebook_picker_image.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<ImageView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/com_facebook_picker_image"
-    android:layout_width="50dip"
-    android:layout_height="50dip"
-    android:layout_gravity="center_vertical"
-    android:src="@drawable/com_facebook_profile_default_icon" />
diff --git a/facebook/res/layout/com_facebook_picker_list_row.xml b/facebook/res/layout/com_facebook_picker_list_row.xml
deleted file mode 100644
index 8f6725b11..000000000
--- a/facebook/res/layout/com_facebook_picker_list_row.xml
+++ /dev/null
@@ -1,48 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout
-        xmlns:android="http://schemas.android.com/apk/res/android"
-        android:layout_height="wrap_content"
-        android:layout_width="fill_parent"
-        >
-    <ViewStub
-            android:id="@+id/com_facebook_picker_profile_pic_stub"
-            android:inflatedId="@+id/com_facebook_picker_image"
-            android:layout="@layout/com_facebook_picker_image"
-            android:layout_width="50dip"
-            android:layout_height="50dip" />
-    <TextView
-            android:id="@+id/com_facebook_picker_title"
-            android:layout_width="100dip"
-            android:layout_height="50dip"
-            android:layout_weight="1.0"
-            android:paddingLeft="5dip"
-            android:textStyle="bold"
-            android:textColor="#000000"
-            android:singleLine="true"
-            android:ellipsize="end"
-            android:textSize="18sp"
-            android:gravity="left|center_vertical"/>
-    <ViewStub
-            android:id="@+id/com_facebook_picker_checkbox_stub"
-            android:inflatedId="@+id/com_facebook_picker_checkbox"
-            android:layout="@layout/com_facebook_picker_checkbox"
-            android:layout_width="23dip"
-            android:layout_height="23dip"
-            android:layout_marginRight="10dip"/>
-</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_picker_list_section_header.xml b/facebook/res/layout/com_facebook_picker_list_section_header.xml
deleted file mode 100644
index ef04e3bc9..000000000
--- a/facebook/res/layout/com_facebook_picker_list_section_header.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<TextView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/com_facebook_picker_list_section_header"
-    android:layout_width="fill_parent"
-    android:layout_height="wrap_content"
-    android:textStyle="bold"
-    android:background="@drawable/com_facebook_list_section_header_background"
-    android:orientation="horizontal"
-    android:gravity="left|center_vertical"
-    android:textColor="#68768a"
-    android:textSize="17sp"
-    android:paddingLeft="8dip"
-    android:paddingBottom="0px"
-    android:shadowDx="1"
-    android:shadowDy="1"
-    android:shadowRadius="1"
-    android:shadowColor="#BFFFFFFF" />
diff --git a/facebook/res/layout/com_facebook_picker_search_box.xml b/facebook/res/layout/com_facebook_picker_search_box.xml
deleted file mode 100644
index 616bba4e0..000000000
--- a/facebook/res/layout/com_facebook_picker_search_box.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="match_parent"
-              android:layout_height="wrap_content"
-              android:orientation="vertical"
-        >
-    <include layout="@layout/com_facebook_search_bar_layout" />
-    <View
-            android:layout_width="match_parent"
-            android:layout_height="@dimen/com_facebook_picker_divider_width"
-            android:background="@drawable/com_facebook_picker_default_separator_color"
-            />
-</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
deleted file mode 100644
index ebbffd883..000000000
--- a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<merge xmlns:android="http://schemas.android.com/apk/res/android">
-    <ViewStub android:id="@+id/com_facebook_picker_title_bar_stub"
-              android:inflatedId="@+id/com_facebook_picker_title_bar"
-              android:layout="@layout/com_facebook_picker_title_bar"
-              android:layout_height="48dip"
-              android:layout_width="fill_parent"/>
-
-</merge>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment.xml b/facebook/res/layout/com_facebook_placepickerfragment.xml
deleted file mode 100644
index 56c5cc8ee..000000000
--- a/facebook/res/layout/com_facebook_placepickerfragment.xml
+++ /dev/null
@@ -1,47 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-              android:background="#FFFFFF"
-              android:descendantFocusability="beforeDescendants"
-              android:focusableInTouchMode="true">
-
-    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
-
-    <ListView
-            android:id="@+id/com_facebook_picker_list_view"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            android:layout_alignParentTop="true"
-            android:divider="@null"
-            android:fastScrollEnabled="true"
-            android:scrollbars="vertical"
-            android:listSelector="@drawable/com_facebook_picker_list_selector"
-            android:cacheColorHint="#FFFFFF"
-            />
-
-    <ProgressBar android:indeterminate="true"
-                 android:layout_width="wrap_content"
-                 android:layout_height="wrap_content"
-                 android:id="@+id/com_facebook_picker_activity_circle"
-                 style="@android:style/Widget.ProgressBar"
-                 android:layout_centerInParent="true"
-                 android:visibility="invisible"
-            />
-</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_search_bar_layout.xml b/facebook/res/layout/com_facebook_search_bar_layout.xml
deleted file mode 100644
index 79dbabbf0..000000000
--- a/facebook/res/layout/com_facebook_search_bar_layout.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout
-        xmlns:android="http://schemas.android.com/apk/res/android"
-        android:id="@+id/com_facebook_search_bar_view"
-        android:orientation="horizontal"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:paddingTop="0dp"
-        android:paddingBottom="0dp"
-        android:paddingLeft="5dp"
-        android:paddingRight="5dp"
-        android:background="@color/com_facebook_picker_search_bar_background"
-        >
-    <EditText
-            android:id="@+id/com_facebook_picker_search_text"
-            android:layout_width="match_parent"
-            android:layout_height="48dp"
-            android:layout_marginLeft="5dp"
-            android:singleLine="true"
-            android:layout_gravity="center"
-            android:gravity="center_vertical"
-            android:textSize="16dp"
-            android:textColor="@android:color/black"
-            android:textColorHint="@color/com_facebook_picker_search_bar_text"
-            android:background="@color/com_facebook_picker_search_bar_background"
-            android:drawableLeft="@drawable/com_facebook_picker_magnifier"
-            android:drawablePadding="5dp"
-            android:imeOptions="actionDone"
-            />
-</LinearLayout>
\ No newline at end of file
diff --git a/facebook/res/layout/com_facebook_tooltip_bubble.xml b/facebook/res/layout/com_facebook_tooltip_bubble.xml
new file mode 100644
index 000000000..d1aff5920
--- /dev/null
+++ b/facebook/res/layout/com_facebook_tooltip_bubble.xml
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:paddingLeft="20dp"
+    android:paddingRight="20dp">
+  <RelativeLayout
+  	android:id="@+id/com_facebook_body_frame"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_below="@+id/com_facebook_tooltip_bubble_view_top_pointer"
+    android:layout_centerHorizontal="true"
+    android:background="@drawable/com_facebook_tooltip_blue_background">
+      <ImageView 
+        android:id="@+id/com_facebook_button_xout"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_alignParentRight="true"
+        android:padding="10dp"
+        android:src="@drawable/com_facebook_tooltip_blue_xout"
+        />
+      <TextView
+          android:id="@+id/com_facebook_tooltip_bubble_view_text_body"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_alignParentTop="true"
+          android:layout_toLeftOf="@id/com_facebook_button_xout"
+          android:layout_alignParentLeft="true"
+          android:padding="10dp"
+          style="@style/tooltip_bubble_text"
+          />
+  </RelativeLayout>
+  <ImageView
+      android:id="@+id/com_facebook_tooltip_bubble_view_top_pointer"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_alignParentTop="true"
+      android:layout_centerHorizontal="true"
+      android:layout_marginBottom="-10dp"
+      android:src="@drawable/com_facebook_tooltip_blue_topnub"
+      />
+  <ImageView
+      android:id="@+id/com_facebook_tooltip_bubble_view_bottom_pointer"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal|bottom"
+      android:layout_centerHorizontal="true"
+      android:layout_below="@id/com_facebook_body_frame"
+      android:layout_marginTop="-13dp"
+      android:src="@drawable/com_facebook_tooltip_blue_bottomnub"
+      />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_usersettingsfragment.xml b/facebook/res/layout/com_facebook_usersettingsfragment.xml
deleted file mode 100644
index 04a9a1ded..000000000
--- a/facebook/res/layout/com_facebook_usersettingsfragment.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<ScrollView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:loginView="http://schemas.android.com/apk/res-auto"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@drawable/com_facebook_usersettingsfragment_background_gradient" >
-    <LinearLayout
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
-        android:orientation="vertical">
-
-        <ImageView
-            android:id="@+id/com_facebook_usersettingsfragment_logo_image"
-            android:layout_width="193dp"
-            android:layout_height="44dp"
-            android:layout_gravity="center_horizontal"
-            android:src="@drawable/com_facebook_logo"
-            android:layout_marginTop="35dp"
-            android:contentDescription="@string/com_facebook_logo_content_description"/>
-
-        <TextView
-            android:id="@+id/com_facebook_usersettingsfragment_profile_name"
-            android:layout_width="fill_parent"
-            android:layout_height="100dp"
-            android:lines="1"
-            android:textSize="16sp"
-            android:textStyle="bold"
-            android:layout_marginTop="35dp"
-            android:gravity="center"/>
-    
-        <com.facebook.widget.LoginButton
-            android:id="@+id/com_facebook_usersettingsfragment_login_button"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:layout_marginTop="35dp"
-            android:layout_marginBottom="35dp"
-            loginView:login_text="@string/com_facebook_usersettingsfragment_log_in_button"
-            style="@style/com_facebook_loginview_silver_style" />
-    
-    </LinearLayout>
-</ScrollView>
diff --git a/facebook/res/layout/messenger_button_send_blue_large.xml b/facebook/res/layout/messenger_button_send_blue_large.xml
new file mode 100644
index 000000000..5583b3e28
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_blue_large.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  style="@style/MessengerButton.Blue.Large"
+  >
+  <TextView
+    android:text="@string/messenger_send_button_text"
+    style="@style/MessengerButtonText.Blue.Large"
+    />
+</FrameLayout>
diff --git a/facebook/res/layout/messenger_button_send_blue_round.xml b/facebook/res/layout/messenger_button_send_blue_round.xml
new file mode 100644
index 000000000..805efba90
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_blue_round.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<Button
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  android:layout_width="58dp"
+  android:layout_height="59dp"
+  android:background="@drawable/messenger_button_blue_bg_round"
+  />
diff --git a/facebook/res/layout/messenger_button_send_blue_small.xml b/facebook/res/layout/messenger_button_send_blue_small.xml
new file mode 100644
index 000000000..107a56bc5
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_blue_small.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  style="@style/MessengerButton.Blue.Small"
+  >
+  <TextView
+    android:text="@string/messenger_send_button_text"
+    style="@style/MessengerButtonText.Blue.Small"
+    />
+</FrameLayout>
diff --git a/facebook/res/layout/messenger_button_send_white_large.xml b/facebook/res/layout/messenger_button_send_white_large.xml
new file mode 100644
index 000000000..2f0e0923a
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_white_large.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  style="@style/MessengerButton.White.Large"
+  >
+  <TextView
+    android:text="@string/messenger_send_button_text"
+    style="@style/MessengerButtonText.White.Large"
+    />
+</FrameLayout>
diff --git a/facebook/res/layout/messenger_button_send_white_round.xml b/facebook/res/layout/messenger_button_send_white_round.xml
new file mode 100644
index 000000000..796ca687e
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_white_round.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<Button
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  android:layout_width="58dp"
+  android:layout_height="59dp"
+  android:background="@drawable/messenger_button_white_bg_round"
+  />
diff --git a/facebook/res/layout/messenger_button_send_white_small.xml b/facebook/res/layout/messenger_button_send_white_small.xml
new file mode 100644
index 000000000..876f5d666
--- /dev/null
+++ b/facebook/res/layout/messenger_button_send_white_small.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/messenger_send_button"
+  style="@style/MessengerButton.White.Small"
+  >
+  <TextView
+    android:text="@string/messenger_send_button_text"
+    style="@style/MessengerButtonText.White.Small"
+    />
+</FrameLayout>
diff --git a/facebook/res/values-af/messenger_button_strings.xml b/facebook/res/values-af/messenger_button_strings.xml
new file mode 100644
index 000000000..17be2a914
--- /dev/null
+++ b/facebook/res/values-af/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Stuur</string>
+</resources>
diff --git a/facebook/res/values-ar/messenger_button_strings.xml b/facebook/res/values-ar/messenger_button_strings.xml
new file mode 100644
index 000000000..5051f3908
--- /dev/null
+++ b/facebook/res/values-ar/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Ø¥Ø±Ø³Ø§Ù„</string>
+</resources>
diff --git a/facebook/res/values-bn/messenger_button_strings.xml b/facebook/res/values-bn/messenger_button_strings.xml
new file mode 100644
index 000000000..633acf2b0
--- /dev/null
+++ b/facebook/res/values-bn/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à¦ªà§à¦°à§‡à¦°à¦£ à¦•à¦°à§à¦¨</string>
+</resources>
diff --git a/facebook/res/values-cs/messenger_button_strings.xml b/facebook/res/values-cs/messenger_button_strings.xml
new file mode 100644
index 000000000..381bf74f6
--- /dev/null
+++ b/facebook/res/values-cs/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Odeslat</string>
+</resources>
diff --git a/facebook/res/values-da/messenger_button_strings.xml b/facebook/res/values-da/messenger_button_strings.xml
new file mode 100644
index 000000000..d4d20fbd9
--- /dev/null
+++ b/facebook/res/values-da/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Send</string>
+</resources>
diff --git a/facebook/res/values-de/messenger_button_strings.xml b/facebook/res/values-de/messenger_button_strings.xml
new file mode 100644
index 000000000..8b125cf1a
--- /dev/null
+++ b/facebook/res/values-de/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Senden</string>
+</resources>
diff --git a/facebook/res/values-el/messenger_button_strings.xml b/facebook/res/values-el/messenger_button_strings.xml
new file mode 100644
index 000000000..4acca25b4
--- /dev/null
+++ b/facebook/res/values-el/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®</string>
+</resources>
diff --git a/facebook/res/values-es-rES/messenger_button_strings.xml b/facebook/res/values-es-rES/messenger_button_strings.xml
new file mode 100644
index 000000000..c7b157fb2
--- /dev/null
+++ b/facebook/res/values-es-rES/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Enviar</string>
+</resources>
diff --git a/facebook/res/values-es/messenger_button_strings.xml b/facebook/res/values-es/messenger_button_strings.xml
new file mode 100644
index 000000000..c7b157fb2
--- /dev/null
+++ b/facebook/res/values-es/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Enviar</string>
+</resources>
diff --git a/facebook/res/values-es/strings.xml b/facebook/res/values-es/strings.xml
index 556a7a4f9..78af85e6c 100644
--- a/facebook/res/values-es/strings.xml
+++ b/facebook/res/values-es/strings.xml
@@ -1,44 +1,33 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
-    <string name="com_facebook_dialogloginactivity_ok_button">Aceptar</string>
     <string name="com_facebook_loginview_log_out_button">Cerrar sesiÃ³n</string>
     <string name="com_facebook_loginview_log_in_button">Iniciar sesiÃ³n con Facebook</string>
     <string name="com_facebook_loginview_logged_in_as">SesiÃ³n iniciada como: %1$s</string>
     <string name="com_facebook_loginview_logged_in_using_facebook">SesiÃ³n iniciada con Facebook</string>
     <string name="com_facebook_loginview_log_out_action">Cerrar sesiÃ³n</string>
     <string name="com_facebook_loginview_cancel_action">Cancelar</string>
-    <string name="com_facebook_logo_content_description">Logo de Facebook</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">Iniciar sesiÃ³n&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">SesiÃ³n iniciada</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">No has iniciado sesiÃ³n</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s â€¢ %2$,d estuvieron aquÃ­</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">es:%1$,d estuvieron aquÃ­</string>
-    <string name="com_facebook_picker_done_button_text">Aceptar</string>
-    <string name="com_facebook_choose_friends">Elige Amigos</string>
-    <string name="com_facebook_nearby">Cercano</string>
     <string name="com_facebook_loading">Cargando</string>
     <string name="com_facebook_internet_permission_error_title">Error de AndroidManifest</string>
     <string name="com_facebook_internet_permission_error_message">WebView inicio de sesiÃ³n requiere permiso INTERNET</string>
-    <string name="com_facebook_requesterror_web_login">Por favor, iniciar sesiÃ³n a travÃ©s https://www.facebook.com o https://m.facebook.com para volver a activar la aplicaciÃ³n para conectar con Facebook.</string>
-    <string name="com_facebook_requesterror_relogin">La aplicaciÃ³n no se conecta con Facebook, inicie sesiÃ³n y volver a conectar esta aplicaciÃ³n.</string>
-    <string name="com_facebook_requesterror_password_changed">Su contraseÃ±a de Facebook ha cambiado, por favor vuelva a conectar la aplicaciÃ³n con Facebook.</string>
-    <string name="com_facebook_requesterror_reconnect">Se produjo un error al conectar con Facebook, por favor vuelva a conectar la aplicaciÃ³n con Facebook.</string>
-    <string name="com_facebook_requesterror_permissions">Una conexiÃ³n de aplicaciÃ³n con Facebook fallÃ³ debido a permisos insuficientes, por favor, conceda los permisos de aplicaciones para realizar la operaciÃ³n.</string>
+    <string name="com_facebook_image_download_unknown_error">Error al descargar la imagen.</string>
 </resources>
diff --git a/facebook/res/values-fi/messenger_button_strings.xml b/facebook/res/values-fi/messenger_button_strings.xml
new file mode 100644
index 000000000..f9864d98d
--- /dev/null
+++ b/facebook/res/values-fi/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">LÃ¤hetÃ¤</string>
+</resources>
diff --git a/facebook/res/values-fr/messenger_button_strings.xml b/facebook/res/values-fr/messenger_button_strings.xml
new file mode 100644
index 000000000..18721c291
--- /dev/null
+++ b/facebook/res/values-fr/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Envoyer</string>
+</resources>
diff --git a/facebook/res/values-gu/messenger_button_strings.xml b/facebook/res/values-gu/messenger_button_strings.xml
new file mode 100644
index 000000000..012084c1b
--- /dev/null
+++ b/facebook/res/values-gu/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">àª®à«‹àª•àª²à«‹</string>
+</resources>
diff --git a/facebook/res/values-hdpi/dimens.xml b/facebook/res/values-hdpi/dimens.xml
deleted file mode 100644
index 638b2b318..000000000
--- a/facebook/res/values-hdpi/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <dimen name="com_facebook_picker_divider_width">1px</dimen>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values-he/strings.xml b/facebook/res/values-he/strings.xml
index 4ab34a3e2..e5c22ea91 100644
--- a/facebook/res/values-he/strings.xml
+++ b/facebook/res/values-he/strings.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
@@ -22,23 +26,8 @@
     <string name="com_facebook_loginview_logged_in_using_facebook">×ž×—×•×‘×¨ ×‘××ž×¦×¢×•×ª ×¤×™×™×¡×‘×•×§</string>
     <string name="com_facebook_loginview_log_out_action">×”×ª× ×ª×§</string>
     <string name="com_facebook_loginview_cancel_action">×‘×˜×œ</string>
-    <string name="com_facebook_logo_content_description">×¤×™×™×¡×‘×•×§ ×œ×•×’×•</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">×”×ª×—×‘×¨&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">×ž×—×•×‘×¨</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">×œ× ×ž×—×•×‘×¨</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s â€¢ %2$,d ×”×™×• ×¤×”</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d ×”×™×• ×¤×”</string>
-    <string name="com_facebook_picker_done_button_text">×‘×¦×¢</string>
-    <string name="com_facebook_choose_friends">×‘×—×¨ ×—×‘×¨×™×</string>
-    <string name="com_facebook_nearby">×§×¨×•×‘ ××œ×™×™</string>
     <string name="com_facebook_loading">..×ž×¢×œ×”</string>
     <string name="com_facebook_internet_permission_error_title">AndroidManifest ×©×’×™××ª</string>
     <string name="com_facebook_internet_permission_error_message">×”×”×ª×—×‘×¨×•×ª ×œ×ª×¦×•×’×ª ××ª×¨ ×“×•×¨×©×ª ××™×©×•×¨ ××™× ×˜×¨× ×˜</string>
-    <string name="com_facebook_requesterror_web_login">.×›×“×™ ×œ××¤×©×¨ ×ž×—×“×© ×œ××¤×œ×™×§×¦×™×” ×œ×”×ª×—×‘×¨ ×¢× ×¤×™×™×¡×‘×•×§ https://www.facebook.com ××• https://m.facebook.com ×× × ×”×™×›× ×¡ ×“×¨×š</string>
-    <string name="com_facebook_requesterror_relogin">.×”××¤×œ×™×§×¦×™×” ××™× ×” ×ž×—×•×‘×¨×ª ×œ×¤×™×™×¡×‘×•×§, ×× × ×”×™×›× ×¡ ×•×—×‘×¨ ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×”</string>
-    <string name="com_facebook_requesterror_password_changed">.×”×¡×™×¡×ž×” ×©×œ×š ×‘×¤×™×™×¡×‘×•×§ ×”×©×ª× ×ª×”, ×× × ×—×‘×¨ ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§</string>
-    <string name="com_facebook_requesterror_reconnect">.××¨×¢×” ×©×’×™××” ×‘×¢×ª ×”×—×™×‘×•×¨ ×¢× ×¤×™×™×¡×‘×•×§, ×—×‘×¨ ×‘×‘×§×©×” ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§</string>
-    <string name="com_facebook_requesterror_permissions">.×—×™×‘×•×¨ ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§ × ×›×©×œ ×‘×©×œ ×”×¨×©××•×ª ×œ× ×ž×¡×¤×§×•×ª, ×× × ×”×¢× ×§ ×”×¨×©××•×ª ×œ××¤×œ×™×§×¦×™×” ×‘×›×“×™ ×©×”×¤×¢×•×œ×” ×ª×•×›×œ ×œ×”×ª×‘×¦×¢</string>
-    <string name="com_facebook_dialogloginactivity_ok_button">××™×©×•×¨</string>
+    <string name="com_facebook_image_download_unknown_error">×©×’×™××” ×‘×¢×ª ×”×•×¨×“×ª ×ª×ž×•× ×”</string>
 </resources>
diff --git a/facebook/res/values-hi/messenger_button_strings.xml b/facebook/res/values-hi/messenger_button_strings.xml
new file mode 100644
index 000000000..ad8aeabd3
--- /dev/null
+++ b/facebook/res/values-hi/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à¤­à¥‡à¤œà¥‡à¤‚</string>
+</resources>
diff --git a/facebook/res/values-in/messenger_button_strings.xml b/facebook/res/values-in/messenger_button_strings.xml
new file mode 100644
index 000000000..31bb1a62e
--- /dev/null
+++ b/facebook/res/values-in/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Kirim</string>
+</resources>
diff --git a/facebook/res/values-it/messenger_button_strings.xml b/facebook/res/values-it/messenger_button_strings.xml
new file mode 100644
index 000000000..55473fbdc
--- /dev/null
+++ b/facebook/res/values-it/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Invia</string>
+</resources>
diff --git a/facebook/res/values-iw/strings.xml b/facebook/res/values-iw/strings.xml
index 4ab34a3e2..e5c22ea91 100644
--- a/facebook/res/values-iw/strings.xml
+++ b/facebook/res/values-iw/strings.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
@@ -22,23 +26,8 @@
     <string name="com_facebook_loginview_logged_in_using_facebook">×ž×—×•×‘×¨ ×‘××ž×¦×¢×•×ª ×¤×™×™×¡×‘×•×§</string>
     <string name="com_facebook_loginview_log_out_action">×”×ª× ×ª×§</string>
     <string name="com_facebook_loginview_cancel_action">×‘×˜×œ</string>
-    <string name="com_facebook_logo_content_description">×¤×™×™×¡×‘×•×§ ×œ×•×’×•</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">×”×ª×—×‘×¨&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">×ž×—×•×‘×¨</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">×œ× ×ž×—×•×‘×¨</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s â€¢ %2$,d ×”×™×• ×¤×”</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d ×”×™×• ×¤×”</string>
-    <string name="com_facebook_picker_done_button_text">×‘×¦×¢</string>
-    <string name="com_facebook_choose_friends">×‘×—×¨ ×—×‘×¨×™×</string>
-    <string name="com_facebook_nearby">×§×¨×•×‘ ××œ×™×™</string>
     <string name="com_facebook_loading">..×ž×¢×œ×”</string>
     <string name="com_facebook_internet_permission_error_title">AndroidManifest ×©×’×™××ª</string>
     <string name="com_facebook_internet_permission_error_message">×”×”×ª×—×‘×¨×•×ª ×œ×ª×¦×•×’×ª ××ª×¨ ×“×•×¨×©×ª ××™×©×•×¨ ××™× ×˜×¨× ×˜</string>
-    <string name="com_facebook_requesterror_web_login">.×›×“×™ ×œ××¤×©×¨ ×ž×—×“×© ×œ××¤×œ×™×§×¦×™×” ×œ×”×ª×—×‘×¨ ×¢× ×¤×™×™×¡×‘×•×§ https://www.facebook.com ××• https://m.facebook.com ×× × ×”×™×›× ×¡ ×“×¨×š</string>
-    <string name="com_facebook_requesterror_relogin">.×”××¤×œ×™×§×¦×™×” ××™× ×” ×ž×—×•×‘×¨×ª ×œ×¤×™×™×¡×‘×•×§, ×× × ×”×™×›× ×¡ ×•×—×‘×¨ ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×”</string>
-    <string name="com_facebook_requesterror_password_changed">.×”×¡×™×¡×ž×” ×©×œ×š ×‘×¤×™×™×¡×‘×•×§ ×”×©×ª× ×ª×”, ×× × ×—×‘×¨ ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§</string>
-    <string name="com_facebook_requesterror_reconnect">.××¨×¢×” ×©×’×™××” ×‘×¢×ª ×”×—×™×‘×•×¨ ×¢× ×¤×™×™×¡×‘×•×§, ×—×‘×¨ ×‘×‘×§×©×” ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§</string>
-    <string name="com_facebook_requesterror_permissions">.×—×™×‘×•×¨ ×”××¤×œ×™×§×¦×™×” ×¢× ×¤×™×™×¡×‘×•×§ × ×›×©×œ ×‘×©×œ ×”×¨×©××•×ª ×œ× ×ž×¡×¤×§×•×ª, ×× × ×”×¢× ×§ ×”×¨×©××•×ª ×œ××¤×œ×™×§×¦×™×” ×‘×›×“×™ ×©×”×¤×¢×•×œ×” ×ª×•×›×œ ×œ×”×ª×‘×¦×¢</string>
-    <string name="com_facebook_dialogloginactivity_ok_button">××™×©×•×¨</string>
+    <string name="com_facebook_image_download_unknown_error">×©×’×™××” ×‘×¢×ª ×”×•×¨×“×ª ×ª×ž×•× ×”</string>
 </resources>
diff --git a/facebook/res/values-ja/messenger_button_strings.xml b/facebook/res/values-ja/messenger_button_strings.xml
new file mode 100644
index 000000000..029d66e5f
--- /dev/null
+++ b/facebook/res/values-ja/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">é€ä¿¡</string>
+</resources>
diff --git a/facebook/res/values-kn/messenger_button_strings.xml b/facebook/res/values-kn/messenger_button_strings.xml
new file mode 100644
index 000000000..1b8db435c
--- /dev/null
+++ b/facebook/res/values-kn/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à²•à²³à³à²¹à²¿à²¸à³</string>
+</resources>
diff --git a/facebook/res/values-ko/messenger_button_strings.xml b/facebook/res/values-ko/messenger_button_strings.xml
new file mode 100644
index 000000000..0f492315b
--- /dev/null
+++ b/facebook/res/values-ko/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">ë³´ë‚´ê¸°</string>
+</resources>
diff --git a/facebook/res/values-ldpi/dimens.xml b/facebook/res/values-ldpi/dimens.xml
deleted file mode 100644
index 638b2b318..000000000
--- a/facebook/res/values-ldpi/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <dimen name="com_facebook_picker_divider_width">1px</dimen>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values-mdpi/dimens.xml b/facebook/res/values-mdpi/dimens.xml
deleted file mode 100644
index 638b2b318..000000000
--- a/facebook/res/values-mdpi/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <dimen name="com_facebook_picker_divider_width">1px</dimen>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values-ml/messenger_button_strings.xml b/facebook/res/values-ml/messenger_button_strings.xml
new file mode 100644
index 000000000..4709f1178
--- /dev/null
+++ b/facebook/res/values-ml/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à´…à´¯à´¯àµà´•àµà´•àµà´•</string>
+</resources>
diff --git a/facebook/res/values-mr/messenger_button_strings.xml b/facebook/res/values-mr/messenger_button_strings.xml
new file mode 100644
index 000000000..15fd59880
--- /dev/null
+++ b/facebook/res/values-mr/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à¤ªà¤¾à¤ à¤µà¤¾</string>
+</resources>
diff --git a/facebook/res/values-ms/messenger_button_strings.xml b/facebook/res/values-ms/messenger_button_strings.xml
new file mode 100644
index 000000000..567fbbe2a
--- /dev/null
+++ b/facebook/res/values-ms/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Hantar</string>
+</resources>
diff --git a/facebook/res/values-nb/messenger_button_strings.xml b/facebook/res/values-nb/messenger_button_strings.xml
new file mode 100644
index 000000000..d4d20fbd9
--- /dev/null
+++ b/facebook/res/values-nb/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Send</string>
+</resources>
diff --git a/facebook/res/values-nl/messenger_button_strings.xml b/facebook/res/values-nl/messenger_button_strings.xml
new file mode 100644
index 000000000..293e33aa3
--- /dev/null
+++ b/facebook/res/values-nl/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Verzenden</string>
+</resources>
diff --git a/facebook/res/values-pa/messenger_button_strings.xml b/facebook/res/values-pa/messenger_button_strings.xml
new file mode 100644
index 000000000..12057e2f7
--- /dev/null
+++ b/facebook/res/values-pa/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à¨­à©‡à¨œà©‹</string>
+</resources>
diff --git a/facebook/res/values-pl/messenger_button_strings.xml b/facebook/res/values-pl/messenger_button_strings.xml
new file mode 100644
index 000000000..4e0d1732a
--- /dev/null
+++ b/facebook/res/values-pl/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">WyÅ›lij</string>
+</resources>
diff --git a/facebook/res/values-pt-rPT/messenger_button_strings.xml b/facebook/res/values-pt-rPT/messenger_button_strings.xml
new file mode 100644
index 000000000..c7b157fb2
--- /dev/null
+++ b/facebook/res/values-pt-rPT/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Enviar</string>
+</resources>
diff --git a/facebook/res/values-pt/messenger_button_strings.xml b/facebook/res/values-pt/messenger_button_strings.xml
new file mode 100644
index 000000000..c7b157fb2
--- /dev/null
+++ b/facebook/res/values-pt/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Enviar</string>
+</resources>
diff --git a/facebook/res/values-ru/messenger_button_strings.xml b/facebook/res/values-ru/messenger_button_strings.xml
new file mode 100644
index 000000000..da0987b7e
--- /dev/null
+++ b/facebook/res/values-ru/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">ÐžÑ‚Ð¿Ñ€</string>
+</resources>
diff --git a/facebook/res/values-sv/messenger_button_strings.xml b/facebook/res/values-sv/messenger_button_strings.xml
new file mode 100644
index 000000000..0cff34af8
--- /dev/null
+++ b/facebook/res/values-sv/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Skicka</string>
+</resources>
diff --git a/facebook/res/values-ta/messenger_button_strings.xml b/facebook/res/values-ta/messenger_button_strings.xml
new file mode 100644
index 000000000..cae24ff92
--- /dev/null
+++ b/facebook/res/values-ta/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à®…à®©à¯à®ªà¯à®ªà¯</string>
+</resources>
diff --git a/facebook/res/values-te/messenger_button_strings.xml b/facebook/res/values-te/messenger_button_strings.xml
new file mode 100644
index 000000000..d709da3d1
--- /dev/null
+++ b/facebook/res/values-te/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à°ªà°‚à°ªà±</string>
+</resources>
diff --git a/facebook/res/values-th/messenger_button_strings.xml b/facebook/res/values-th/messenger_button_strings.xml
new file mode 100644
index 000000000..32f559c08
--- /dev/null
+++ b/facebook/res/values-th/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">à¸ªà¹ˆà¸‡</string>
+</resources>
diff --git a/facebook/res/values-tl/messenger_button_strings.xml b/facebook/res/values-tl/messenger_button_strings.xml
new file mode 100644
index 000000000..38c161156
--- /dev/null
+++ b/facebook/res/values-tl/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Ipadala</string>
+</resources>
diff --git a/facebook/res/values-tr/messenger_button_strings.xml b/facebook/res/values-tr/messenger_button_strings.xml
new file mode 100644
index 000000000..e0f9539b2
--- /dev/null
+++ b/facebook/res/values-tr/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">GÃ¶nder</string>
+</resources>
diff --git a/facebook/res/values-vi/messenger_button_strings.xml b/facebook/res/values-vi/messenger_button_strings.xml
new file mode 100644
index 000000000..54840acde
--- /dev/null
+++ b/facebook/res/values-vi/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Gá»­i</string>
+</resources>
diff --git a/facebook/res/values-xhdpi/dimens.xml b/facebook/res/values-xhdpi/dimens.xml
deleted file mode 100644
index 17ff433c2..000000000
--- a/facebook/res/values-xhdpi/dimens.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <dimen name="com_facebook_picker_divider_width">2px</dimen>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values-zh-rCN/messenger_button_strings.xml b/facebook/res/values-zh-rCN/messenger_button_strings.xml
new file mode 100644
index 000000000..3bc0640da
--- /dev/null
+++ b/facebook/res/values-zh-rCN/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">å‘é€</string>
+</resources>
diff --git a/facebook/res/values-zh-rHK/messenger_button_strings.xml b/facebook/res/values-zh-rHK/messenger_button_strings.xml
new file mode 100644
index 000000000..457aeeb9f
--- /dev/null
+++ b/facebook/res/values-zh-rHK/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">å‚³é€</string>
+</resources>
diff --git a/facebook/res/values-zh-rTW/messenger_button_strings.xml b/facebook/res/values-zh-rTW/messenger_button_strings.xml
new file mode 100644
index 000000000..457aeeb9f
--- /dev/null
+++ b/facebook/res/values-zh-rTW/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">å‚³é€</string>
+</resources>
diff --git a/facebook/res/values/attrs.xml b/facebook/res/values/attrs.xml
index 21c3bacef..ecd88b321 100644
--- a/facebook/res/values/attrs.xml
+++ b/facebook/res/values/attrs.xml
@@ -1,52 +1,71 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
-    <declare-styleable name="com_facebook_picker_fragment">
-        <attr name="show_pictures" format="boolean"/>
-        <attr name="extra_fields" format="string"/>
-        <attr name="show_title_bar" format="boolean" />
-        <attr name="title_text" format="string" />
-        <attr name="done_button_text" format="string" />
-        <attr name="title_bar_background" format="reference" />
-        <attr name="done_button_background" format="reference" />
-    </declare-styleable>
-    <declare-styleable name="com_facebook_friend_picker_fragment">
-        <attr name="multi_select" format="boolean"/>
-    </declare-styleable>
-    <declare-styleable name="com_facebook_place_picker_fragment">
-        <attr name="radius_in_meters" format="integer"/>
-        <attr name="results_limit" format="integer"/>
-        <attr name="search_text" format="string"/>
-        <attr name="show_search_box" format="boolean" />
-    </declare-styleable>
     <declare-styleable name="com_facebook_login_view">
-        <attr name="confirm_logout" format="boolean"/>
-        <attr name="fetch_user_info" format="boolean"/>
-        <attr name="login_text" format="string"/>
-        <attr name="logout_text" format="string"/>
+        <attr name="com_facebook_confirm_logout" format="boolean"/>
+        <attr name="com_facebook_login_text" format="string"/>
+        <attr name="com_facebook_logout_text" format="string"/>
+        <attr name="com_facebook_tooltip_mode">
+            <!-- Keep in sync with Enums in LoginButton -->
+            <enum name="automatic" value="0" />
+            <enum name="display_always" value="1" />
+            <enum name="never_display" value="2" />
+        </attr>
     </declare-styleable>
     <declare-styleable name="com_facebook_profile_picture_view">
-        <attr name="preset_size">
+        <attr name="com_facebook_preset_size">
             <!-- Keep in sync with constants in ProfilePictureView -->
             <enum name="small" value="-2" />
             <enum name="normal" value="-3" />
             <enum name="large" value="-4" />
         </attr>
-        <attr name="is_cropped" format="boolean" />
+        <attr name="com_facebook_is_cropped" format="boolean" />
+    </declare-styleable>
+    <declare-styleable name="com_facebook_like_view">
+        <attr name="com_facebook_foreground_color" format="color" />
+        <attr name="com_facebook_object_id" format="string" />
+        <attr name="com_facebook_object_type">
+            <!-- Keep in sync with Enums in Likeview -->
+            <enum name="unknown" value="0" />
+            <enum name="open_graph" value="1" />
+            <enum name="page" value="2" />
+        </attr>
+        <attr name="com_facebook_style">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="standard" value="0" />
+            <enum name="button" value="1" />
+            <enum name="box_count" value="2" />
+        </attr>
+        <attr name="com_facebook_auxiliary_view_position">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="bottom" value="0" />
+            <enum name="inline" value="1" />
+            <enum name="top" value="2" />
+        </attr>
+        <attr name="com_facebook_horizontal_alignment">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="center" value="0" />
+            <enum name="left" value="1" />
+            <enum name="right" value="2" />
+        </attr>
     </declare-styleable>
 </resources>
diff --git a/facebook/res/values/colors.xml b/facebook/res/values/colors.xml
deleted file mode 100644
index 3bf48f417..000000000
--- a/facebook/res/values/colors.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <dimen name="com_facebook_picker_place_image_size">64dp</dimen>
-    <color name="com_facebook_picker_search_bar_background">#f5f5f7</color>
-    <color name="com_facebook_picker_search_bar_text">#bcbdc2</color>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values/drawables.xml b/facebook/res/values/drawables.xml
deleted file mode 100644
index a8f6af01e..000000000
--- a/facebook/res/values/drawables.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <drawable name="com_facebook_picker_default_separator_color">#33464c59</drawable>
-</resources>
\ No newline at end of file
diff --git a/facebook/res/values/messenger_button_strings.xml b/facebook/res/values/messenger_button_strings.xml
new file mode 100644
index 000000000..d4d20fbd9
--- /dev/null
+++ b/facebook/res/values/messenger_button_strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name="messenger_send_button_text">Send</string>
+</resources>
diff --git a/facebook/res/values/messenger_button_styles.xml b/facebook/res/values/messenger_button_styles.xml
new file mode 100644
index 000000000..998e4bd4b
--- /dev/null
+++ b/facebook/res/values/messenger_button_styles.xml
@@ -0,0 +1,94 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <style name="MessengerButton">
+    <item name="android:clickable">true</item>
+  </style>
+
+  <style name="MessengerButton.Blue">
+    <item name="android:background">@drawable/messenger_button_blue_bg_selector</item>
+  </style>
+
+  <style name="MessengerButton.Blue.Large">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">44dp</item>
+    <item name="android:layout_marginLeft">16dp</item>
+    <item name="android:layout_marginRight">16dp</item>
+  </style>
+
+  <style name="MessengerButton.Blue.Small">
+    <item name="android:layout_width">158dp</item>
+    <item name="android:layout_height">36dp</item>
+  </style>
+
+
+  <style name="MessengerButton.White">
+    <item name="android:background">@drawable/messenger_button_white_bg_selector</item>
+  </style>
+
+  <style name="MessengerButton.White.Large">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">44dp</item>
+    <item name="android:layout_marginLeft">16dp</item>
+    <item name="android:layout_marginRight">16dp</item>
+  </style>
+
+  <style name="MessengerButton.White.Small">
+    <item name="android:layout_width">158dp</item>
+    <item name="android:layout_height">36dp</item>
+  </style>
+
+  <style name="MessengerButtonText">
+    <item name="android:layout_width">wrap_content</item>
+    <item name="android:layout_height">wrap_content</item>
+    <item name="android:layout_gravity">center</item>
+    <item name="android:drawablePadding">4dp</item>
+    <item name="android:gravity">center</item>
+    <!--suppress NewApi -->
+    <item name="android:textAllCaps">true</item>
+    <item name="android:textSize">14sp</item>
+    <item name="android:textStyle">bold</item>
+  </style>
+
+  <style name="MessengerButtonText.Blue">
+    <item name="android:textColor">#ffffff</item>
+  </style>
+
+  <style name="MessengerButtonText.Blue.Large">
+    <item name="android:drawableLeft">@drawable/messenger_bubble_large_white</item>
+  </style>
+
+  <style name="MessengerButtonText.Blue.Small">
+    <item name="android:drawableLeft">@drawable/messenger_bubble_small_white</item>
+  </style>
+
+  <style name="MessengerButtonText.White">
+    <item name="android:textColor">#0084ff</item>
+  </style>
+
+  <style name="MessengerButtonText.White.Large">
+    <item name="android:drawableLeft">@drawable/messenger_bubble_large_blue</item>
+  </style>
+
+  <style name="MessengerButtonText.White.Small">
+    <item name="android:drawableLeft">@drawable/messenger_bubble_small_blue</item>
+  </style>
+</resources>
diff --git a/facebook/res/values/strings.xml b/facebook/res/values/strings.xml
index 022d85c80..918adbd3c 100644
--- a/facebook/res/values/strings.xml
+++ b/facebook/res/values/strings.xml
@@ -1,44 +1,39 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
-    <string name="com_facebook_dialogloginactivity_ok_button">OK</string>
+    <string name="com_facebook_like_button_not_liked">Like</string>
+    <string name="com_facebook_like_button_liked">Liked</string>
     <string name="com_facebook_loginview_log_out_button">Log out</string>
-    <string name="com_facebook_loginview_log_in_button">Log in with Facebook</string>
+    <string name="com_facebook_loginview_log_in_button">Log in</string>
+    <string name="com_facebook_loginview_log_in_button_long">Log in with Facebook</string>
     <string name="com_facebook_loginview_logged_in_as">Logged in as: %1$s</string>
     <string name="com_facebook_loginview_logged_in_using_facebook">Logged in using Facebook</string>
     <string name="com_facebook_loginview_log_out_action">Log out</string>
     <string name="com_facebook_loginview_cancel_action">Cancel</string>
-    <string name="com_facebook_logo_content_description">Facebook Logo</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">Log in&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">Logged in</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">Not logged in</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s â€¢ %2$,d were here</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d were here</string>
-    <string name="com_facebook_picker_done_button_text">Done</string>
-    <string name="com_facebook_choose_friends">Choose Friends</string>
-    <string name="com_facebook_nearby">Nearby</string>
     <string name="com_facebook_loading">Loading...</string>
     <string name="com_facebook_internet_permission_error_title">AndroidManifest Error</string>
     <string name="com_facebook_internet_permission_error_message">WebView login requires INTERNET permission</string>
-    <string name="com_facebook_requesterror_web_login">Your Facebook account is locked. Please log into www.facebook.com to continue.</string>
-    <string name="com_facebook_requesterror_relogin">Please log into this app again to reconnect your Facebook account.</string>
-    <string name="com_facebook_requesterror_password_changed">Your Facebook password has changed. Please log into this app again to reconnect your Facebook account.</string>
-    <string name="com_facebook_requesterror_reconnect">Please log into this app again to reconnect your Facebook account.</string>
-    <string name="com_facebook_requesterror_permissions">This app doesnâ€™t have permission to do this. To change permissions, try logging into the app again.</string>
+    <string name="com_facebook_tooltip_default">New! You\'re in control - choose what info you want to share with apps.</string>
+    <string name="com_facebook_image_download_unknown_error">Unexpected error while downloading an image.</string>
+    <string name="com_facebook_share_button_text">Share</string>
+    <string name="com_facebook_send_button_text">Send</string>
 </resources>
diff --git a/facebook/res/values/styles.xml b/facebook/res/values/styles.xml
index aafc79431..77cbc1ee0 100644
--- a/facebook/res/values/styles.xml
+++ b/facebook/res/values/styles.xml
@@ -1,59 +1,108 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android">
     <color name="com_facebook_blue">#3B5998</color>
-    
-    <color name="com_facebook_usersettingsfragment_connected_text_color">#FFFFFF</color>
-    <color name="com_facebook_usersettingsfragment_connected_shadow_color">#000000</color>
-    <color name="com_facebook_usersettingsfragment_not_connected_text_color">#A6AED7</color>
-    <dimen name="com_facebook_usersettingsfragment_profile_picture_width">64dp</dimen>
-    <dimen name="com_facebook_usersettingsfragment_profile_picture_height">64dp</dimen>
-
-    <dimen name="com_facebook_loginview_padding_left">12dip</dimen>
-    <dimen name="com_facebook_loginview_padding_right">16dp</dimen>
-    <dimen name="com_facebook_loginview_padding_top">12dp</dimen>
-    <dimen name="com_facebook_loginview_padding_bottom">12dp</dimen>
-    <dimen name="com_facebook_loginview_compound_drawable_padding">12dp</dimen>
-    <color name="com_facebook_loginview_text_color">#FFFFFF</color>
-    <dimen name="com_facebook_loginview_text_size">16.0sp</dimen>
+
+    <dimen name="com_facebook_likeview_text_size">11.0sp</dimen>
+    <color name="com_facebook_likeview_text_color">#6a7180</color>
+    <dimen name="com_facebook_likeview_edge_padding">2dp</dimen>
+    <dimen name="com_facebook_likeview_internal_padding">6dp</dimen>
+
+    <dimen name="com_facebook_likeboxcountview_caret_width">6dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_caret_height">3dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_border_radius">3dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_border_width">1dp</dimen>
+    <color name="com_facebook_likeboxcountview_border_color">#6a7180</color>
+    <color name="com_facebook_likeboxcountview_text_color">#6a7180</color>
+    <dimen name="com_facebook_likeboxcountview_text_size">11.0sp</dimen>
+    <dimen name="com_facebook_likeboxcountview_text_padding">6dp</dimen>
 
     <dimen name="com_facebook_profilepictureview_preset_size_small">50dp</dimen>
     <dimen name="com_facebook_profilepictureview_preset_size_normal">100dp</dimen>
     <dimen name="com_facebook_profilepictureview_preset_size_large">180dp</dimen>
 
-    <style name="com_facebook_loginview_default_style" parent="@android:style/Widget.Button">
-        <item name="android:layout_width">wrap_content</item>
-        <item name="android:layout_height">wrap_content</item>
-        <item name="android:background">@drawable/com_facebook_button_blue</item>
-        <item name="android:textColor">@color/com_facebook_loginview_text_color</item>
-        <item name="android:textSize">@dimen/com_facebook_loginview_text_size</item>
-        <item name="android:textStyle">bold</item>
-        <item name="android:paddingLeft">@dimen/com_facebook_loginview_padding_left</item>
-        <item name="android:gravity">center</item>
+    <dimen name="com_facebook_share_button_compound_drawable_padding">12dp</dimen>
+    <dimen name="com_facebook_share_button_padding_bottom">12dp</dimen>
+    <dimen name="com_facebook_share_button_padding_left">12dp</dimen>
+    <dimen name="com_facebook_share_button_padding_right">16dp</dimen>
+    <dimen name="com_facebook_share_button_padding_top">12dp</dimen>
+    <color name="com_facebook_share_button_text_color">#FFFFFF</color>
+    <dimen name="com_facebook_share_button_text_size">16.0sp</dimen>
+
+    <dimen name="com_facebook_tooltip_horizontal_padding">10dp</dimen>
+
+    <style name="tooltip_bubble_text">
+	    <item name="android:textColor">@android:color/white</item>
+	    <item name="android:gravity">left</item>
+	    <item name="android:textSize">12sp</item>
+	    <item name="android:shadowDy">-1</item>
+	    <item name="android:shadowRadius">0.25</item>
+	    <item name="android:shadowColor">#40000000</item>
     </style>
-    
-    <style name="com_facebook_loginview_silver_style" parent="@android:style/Widget.Button">
-        <item name="android:width">205dp</item>
-        <item name="android:height">44dp</item>
-        <item name="android:background">@drawable/com_facebook_loginbutton_silver</item>
-        <item name="android:textSize">18sp</item>
-        <item name="android:textStyle">bold</item>
-        <item name="android:textColor">#4B5164</item>
+
+    <color name="com_facebook_button_background_color">#415dae</color>
+    <color name="com_facebook_button_background_color_disabled">#bdc1c9</color>
+    <color name="com_facebook_button_background_color_pressed">#2f477a</color>
+    <color name="com_facebook_button_like_background_color_selected">#7c8fc8</color>
+    <color name="com_facebook_button_login_silver_background_color">#f4f6f8</color>
+    <color name="com_facebook_button_login_silver_background_color_pressed">#e9eaf0</color>
+    <color name="com_facebook_button_send_background_color">#0084ff</color>
+    <color name="com_facebook_button_send_background_color_pressed">#006fff</color>
+
+    <style name="com_facebook_button" parent="@android:style/Widget.Button">
+        <item name="android:background">@drawable/com_facebook_button_background</item>
+        <item name="android:drawablePadding">6dp</item>
         <item name="android:gravity">center</item>
+        <item name="android:paddingBottom">5dp</item>
+        <item name="android:paddingLeft">8dp</item>
+        <item name="android:paddingRight">8dp</item>
+        <item name="android:paddingTop">5dp</item>
+        <item name="android:textColor">#ffffff</item>
+        <item name="android:textSize">14.0dp</item>
+    </style>
+
+    <style name="com_facebook_button_like" parent="com_facebook_button">
+        <item name="android:background">@drawable/com_facebook_button_like_background</item>
     </style>
+
+    <style name="com_facebook_loginview_default_style" parent="com_facebook_button">
+        <item name="android:drawableLeft">@drawable/com_facebook_button_icon</item>
+    </style>
+
+    <style name="com_facebook_loginview_silver_style" parent="com_facebook_loginview_default_style">
+        <item name="android:background">@drawable/com_facebook_button_login_silver_background</item>
+        <item name="android:drawableLeft">@null</item>
+        <item name="android:textColor">#4b5164</item>
+    </style>
+
+    <style name="com_facebook_button_send" parent="com_facebook_button">
+        <item name="android:background">@drawable/com_facebook_button_send_background</item>
+        <item name="android:drawableLeft">@drawable/com_facebook_button_send_icon</item>
+        <item name="android:text">@string/com_facebook_send_button_text</item>
+    </style>
+
+    <style name="com_facebook_button_share" parent="com_facebook_button">
+        <item name="android:drawableLeft">@drawable/com_facebook_button_icon</item>
+        <item name="android:text">@string/com_facebook_share_button_text</item>
+    </style>
+
 </resources>
diff --git a/facebook/src/com/facebook/AccessToken.java b/facebook/src/com/facebook/AccessToken.java
index 374a2b498..668be1a04 100644
--- a/facebook/src/com/facebook/AccessToken.java
+++ b/facebook/src/com/facebook/AccessToken.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -19,56 +23,144 @@
 import android.annotation.SuppressLint;
 import android.content.Intent;
 import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-import com.facebook.internal.NativeProtocol;
+
 import com.facebook.internal.Utility;
 import com.facebook.internal.Validate;
 
-import java.io.InvalidObjectException;
-import java.io.ObjectInputStream;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
 
 /**
- * This class represents an access token returned by the Facebook Login service, along with associated
- * metadata such as its expiration date and permissions. In general, the {@link Session} class will
- * abstract away the need to worry about the details of an access token, but there are situations
- * (such as handling native links, importing previously-obtained access tokens, etc.) where it is
- * useful to deal with access tokens directly. Factory methods are provided to construct access tokens.
+ * This class represents an immutable access token for using Facebook APIs. It also includes
+ * associated metadata such as expiration date and permissions.
  * <p/>
  * For more information on access tokens, see
  * <a href="https://developers.facebook.com/docs/facebook-login/access-tokens/">Access Tokens</a>.
  */
-public final class AccessToken implements Serializable {
-    private static final long serialVersionUID = 1L;
-    static final String ACCESS_TOKEN_KEY = "access_token";
-    static final String EXPIRES_IN_KEY = "expires_in";
-    private static final Date MIN_DATE = new Date(Long.MIN_VALUE);
+public final class AccessToken implements Parcelable {
+    public static final String ACCESS_TOKEN_KEY = "access_token";
+    public static final String EXPIRES_IN_KEY = "expires_in";
+    public static final String USER_ID_KEY = "user_id";
+
     private static final Date MAX_DATE = new Date(Long.MAX_VALUE);
     private static final Date DEFAULT_EXPIRATION_TIME = MAX_DATE;
     private static final Date DEFAULT_LAST_REFRESH_TIME = new Date();
-    private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource.FACEBOOK_APPLICATION_WEB;
-    private static final Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE;
+    private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE =
+            AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+
+    // Constants related to JSON serialization.
+    private static final int CURRENT_JSON_FORMAT = 1;
+    private static final String VERSION_KEY = "version";
+    private static final String EXPIRES_AT_KEY = "expires_at";
+    private static final String PERMISSIONS_KEY = "permissions";
+    private static final String DECLINED_PERMISSIONS_KEY = "declined_permissions";
+    private static final String TOKEN_KEY = "token";
+    private static final String SOURCE_KEY = "source";
+    private static final String LAST_REFRESH_KEY = "last_refresh";
+    private static final String APPLICATION_ID_KEY = "application_id";
 
     private final Date expires;
-    private final List<String> permissions;
+    private final Set<String> permissions;
+    private final Set<String> declinedPermissions;
     private final String token;
     private final AccessTokenSource source;
     private final Date lastRefresh;
+    private final String applicationId;
+    private final String userId;
 
-    AccessToken(String token, Date expires, List<String> permissions, AccessTokenSource source, Date lastRefresh) {
-        if (permissions == null) {
-            permissions = Collections.emptyList();
-        }
+    /**
+     * Creates a new AccessToken using the supplied information from a previously-obtained access
+     * token (for instance, from an already-cached access token obtained prior to integration with
+     * the Facebook SDK). Note that the caller is asserting that all parameters provided are correct
+     * with respect to the access token string; no validation is done to verify they are correct.
+     *
+     * @param accessToken         the access token string obtained from Facebook
+     * @param applicationId       the ID of the Facebook Application associated with this access
+     *                            token
+     * @param userId              the id of the user
+     * @param permissions         the permissions that were requested when the token was obtained
+     *                            (or when it was last reauthorized); may be null if permission set
+     *                            is unknown
+     * @param declinedPermissions the permissions that were declined when the token was obtained;
+     *                            may be null if permission set is unknown
+     * @param accessTokenSource   an enum indicating how the token was originally obtained (in most
+     *                            cases, this will be either AccessTokenSource.FACEBOOK_APPLICATION
+     *                            or AccessTokenSource.WEB_VIEW); if null, FACEBOOK_APPLICATION is
+     *                            assumed.
+     * @param expirationTime      the expiration date associated with the token; if null, an
+     *                            infinite expiration time is assumed (but will become correct when
+     *                            the token is refreshed)
+     * @param lastRefreshTime     the last time the token was refreshed (or when it was first
+     *                            obtained); if null, the current time is used.
+     */
+    public AccessToken(
+            final String accessToken,
+            final String applicationId,
+            final String userId,
+            @Nullable
+            final Collection<String> permissions,
+            @Nullable
+            final Collection<String> declinedPermissions,
+            @Nullable
+            final AccessTokenSource accessTokenSource,
+            @Nullable
+            final Date expirationTime,
+            @Nullable
+            final Date lastRefreshTime
+    ) {
+        Validate.notNullOrEmpty(accessToken, "accessToken");
+        Validate.notNullOrEmpty(applicationId, "applicationId");
+        Validate.notNullOrEmpty(userId, "userId");
+
+        this.expires = expirationTime != null ? expirationTime : DEFAULT_EXPIRATION_TIME;
+        this.permissions = Collections.unmodifiableSet(
+                permissions != null ? new HashSet<String>(permissions) : new HashSet<String>());
+        this.declinedPermissions = Collections.unmodifiableSet(
+                declinedPermissions != null
+                        ? new HashSet<String>(declinedPermissions)
+                        : new HashSet<String>());
+        this.token = accessToken;
+        this.source = accessTokenSource != null ? accessTokenSource : DEFAULT_ACCESS_TOKEN_SOURCE;
+        this.lastRefresh = lastRefreshTime != null ? lastRefreshTime : DEFAULT_LAST_REFRESH_TIME;
+        this.applicationId = applicationId;
+        this.userId = userId;
+    }
 
-        this.expires = expires;
-        this.permissions = Collections.unmodifiableList(permissions);
-        this.token = token;
-        this.source = source;
-        this.lastRefresh = lastRefresh;
+    /**
+     * Getter for the access token that is current for the application.
+     *
+     * @return The access token that is current for the application.
+     */
+    public static AccessToken getCurrentAccessToken() {
+        return AccessTokenManager.getInstance().getCurrentAccessToken();
+    }
+
+    /**
+     * Setter for the access token that is current for the application.
+     *
+     * @param accessToken The access token to set.
+     */
+    public static void setCurrentAccessToken(AccessToken accessToken) {
+        AccessTokenManager.getInstance().setCurrentAccessToken(accessToken);
+    }
+
+    /**
+     * Updates the current access token with up to date permissions,
+     * and extends the expiration date, if extension is possible.
+     *
+     * This function must be run from the UI thread.
+     */
+    public static void refreshCurrentAccessTokenAsync() {
+        AccessTokenManager.getInstance().refreshCurrentAccessToken();
     }
 
     /**
@@ -91,16 +183,31 @@ public Date getExpires() {
 
     /**
      * Gets the list of permissions associated with this access token. Note that the most up-to-date
-     * list of permissions is maintained by the Facebook service, so this list may be outdated if
+     * list of permissions is maintained by Facebook, so this list may be outdated if
      * permissions have been added or removed since the time the AccessToken object was created. For
-     * more information on permissions, see https://developers.facebook.com/docs/reference/login/#permissions.
+     * more information on permissions, see
+     * https://developers.facebook.com/docs/reference/login/#permissions.
      *
-     * @return a read-only list of strings representing the permissions granted via this access token
+     * @return a read-only list of strings representing the permissions granted via this access
+     * token
      */
-    public List<String> getPermissions() {
+    public Set<String> getPermissions() {
         return this.permissions;
     }
 
+    /**
+     * Gets the list of permissions declined by the user with this access token.  It represents the
+     * entire set of permissions that have been requested and declined.  Note that the most
+     * up-to-date list of permissions is maintained by Facebook, so this list may be
+     * outdated if permissions have been granted or declined since the last time an AccessToken
+     * object was created.
+     *
+     * @return a read-only list of strings representing the permissions declined by the user
+     */
+    public Set<String> getDeclinedPermissions() {
+        return this.declinedPermissions;
+    }
+
     /**
      * Gets the {@link AccessTokenSource} indicating how this access token was obtained.
      *
@@ -121,53 +228,100 @@ public Date getLastRefresh() {
     }
 
     /**
-     * Creates a new AccessToken using the supplied information from a previously-obtained access
-     * token (for instance, from an already-cached access token obtained prior to integration with the
-     * Facebook SDK).
+     * Gets the ID of the Facebook Application associated with this access token.
      *
-     * @param accessToken       the access token string obtained from Facebook
-     * @param expirationTime    the expiration date associated with the token; if null, an infinite expiration time is
-     *                          assumed (but will become correct when the token is refreshed)
-     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained); if null,
-     *                          the current time is used.
-     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
-     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
-     *                          AccessTokenSource.WEB_VIEW); if null, FACEBOOK_APPLICATION is assumed.
-     * @param permissions       the permissions that were requested when the token was obtained (or when
-     *                          it was last reauthorized); may be null if permission set is unknown
-     * @return a new AccessToken
+     * @return the application ID
      */
-    public static AccessToken createFromExistingAccessToken(String accessToken, Date expirationTime,
-            Date lastRefreshTime, AccessTokenSource accessTokenSource, List<String> permissions) {
-        if (expirationTime == null) {
-            expirationTime = DEFAULT_EXPIRATION_TIME;
-        }
-        if (lastRefreshTime == null) {
-            lastRefreshTime = DEFAULT_LAST_REFRESH_TIME;
-        }
-        if (accessTokenSource == null) {
-            accessTokenSource = DEFAULT_ACCESS_TOKEN_SOURCE;
-        }
+    public String getApplicationId() {
+        return applicationId;
+    }
+
+    /**
+     * Returns the user id for this access token.
+     *
+     * @return The user id for this access token.
+     */
+    public String getUserId() {
+        return userId;
+    }
 
-        return new AccessToken(accessToken, expirationTime, permissions, accessTokenSource, lastRefreshTime);
+    /**
+     * A callback for creating an access token from a NativeLinkingIntent
+     */
+    public interface AccessTokenCreationCallback {
+        /**
+         * The method called on a successful creation of an AccessToken.
+         *
+         * @param token the access token created from the native link intent.
+         */
+        public void onSuccess(AccessToken token);
+
+        public void onError(FacebookException error);
     }
 
     /**
-     * Creates a new AccessToken using the information contained in an Intent populated by the Facebook
-     * application in order to launch a native link. For more information on native linking, please see
-     * https://developers.facebook.com/docs/mobile/android/deep_linking/.
+     * Creates a new AccessToken using the information contained in an Intent populated by the
+     * Facebook application in order to launch a native link. For more information on native
+     * linking, please see https://developers.facebook.com/docs/mobile/android/deep_linking/.
      *
-     * @param intent the Intent that was used to start an Activity; must not be null
-     * @return a new AccessToken, or null if the Intent did not contain enough data to create one
+     * @param intent        the Intent that was used to start an Activity; must not be null
+     * @param applicationId the ID of the Facebook Application associated with this access token
      */
-    public static AccessToken createFromNativeLinkingIntent(Intent intent) {
+    public static void createFromNativeLinkingIntent(
+            Intent intent,
+            final String applicationId,
+            final AccessTokenCreationCallback accessTokenCallback) {
         Validate.notNull(intent, "intent");
-
         if (intent.getExtras() == null) {
-            return null;
+            accessTokenCallback.onError(
+                    new FacebookException("No extras found on intent"));
+            return;
         }
+        final Bundle extras = new Bundle(intent.getExtras());
 
-        return createFromBundle(null, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
+        String accessToken = extras.getString(ACCESS_TOKEN_KEY);
+        if (accessToken == null || accessToken.isEmpty()) {
+            accessTokenCallback.onError(new FacebookException("No access token found on intent"));
+            return;
+        }
+
+        String userId = extras.getString(USER_ID_KEY);
+        // Old versions of facebook for android don't provide the UserId. Obtain the id if missing
+        if (userId == null || userId.isEmpty()) {
+            Utility.getGraphMeRequestWithCacheAsync(accessToken,
+                new Utility.GraphMeRequestWithCacheCallback() {
+                    @Override
+                    public void onSuccess(JSONObject userInfo) {
+                        try {
+                            String userId = userInfo.getString("id");
+                            extras.putString(USER_ID_KEY, userId);
+                            accessTokenCallback.onSuccess(createFromBundle(
+                                    null,
+                                    extras,
+                                    AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                                    new Date(),
+                                    applicationId));
+                        } catch (JSONException ex) {
+                            accessTokenCallback.onError(
+                                    new FacebookException(
+                                        "Unable to generate access token due to missing user id"));
+                        }
+
+                    }
+
+                    @Override
+                    public void onFailure(FacebookException error) {
+                        accessTokenCallback.onError(error);
+                    }
+                });
+        } else {
+            accessTokenCallback.onSuccess(createFromBundle(
+                    null,
+                    extras,
+                    AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                    new Date(),
+                    applicationId));
+        }
     }
 
     @Override
@@ -182,106 +336,207 @@ public String toString() {
         return builder.toString();
     }
 
-    static AccessToken createEmptyToken(List<String> permissions) {
-        return new AccessToken("", ALREADY_EXPIRED_EXPIRATION_TIME, permissions, AccessTokenSource.NONE,
-                DEFAULT_LAST_REFRESH_TIME);
-    }
-
-    static AccessToken createFromString(String token, List<String> permissions, AccessTokenSource source) {
-        return new AccessToken(token, DEFAULT_EXPIRATION_TIME, permissions, source, DEFAULT_LAST_REFRESH_TIME);
-    }
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
 
-    static AccessToken createFromNativeLogin(Bundle bundle, AccessTokenSource source) {
-        Date expires = getBundleLongAsDate(
-                bundle, NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date(0));
-        ArrayList<String> permissions = bundle.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
-        String token = bundle.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+        if (!(other instanceof AccessToken)) {
+            return false;
+        }
 
-        return createNew(permissions, token, expires, source);
+        AccessToken o = (AccessToken) other;
+
+        return expires.equals(o.expires) &&
+                permissions.equals(o.permissions) &&
+                declinedPermissions.equals(o.declinedPermissions) &&
+                token.equals(o.token) &&
+                source == o.source &&
+                lastRefresh.equals(o.lastRefresh) &&
+                (applicationId == null ?
+                        o.applicationId == null :
+                        applicationId.equals(o.applicationId)) &&
+                userId.equals(o.userId);
     }
 
-    static AccessToken createFromWebBundle(List<String> requestedPermissions, Bundle bundle, AccessTokenSource source) {
-        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date());
-        String token = bundle.getString(ACCESS_TOKEN_KEY);
-
-        return createNew(requestedPermissions, token, expires, source);
+    @Override
+    public int hashCode() {
+        int result = 17;
+
+        result = result * 31 + expires.hashCode();
+        result = result * 31 + permissions.hashCode();
+        result = result * 31 + declinedPermissions.hashCode();
+        result = result * 31 + token.hashCode();
+        result = result * 31 + source.hashCode();
+        result = result * 31 + lastRefresh.hashCode();
+        result = result * 31 + (applicationId == null ? 0 : applicationId.hashCode());
+        result = result * 31 + userId.hashCode();
+
+        return result;
     }
 
     @SuppressLint("FieldGetter")
     static AccessToken createFromRefresh(AccessToken current, Bundle bundle) {
-        // Only tokens obtained via SSO support refresh. Token refresh returns the expiration date in
-        // seconds from the epoch rather than seconds from now.
-        assert (current.source == AccessTokenSource.FACEBOOK_APPLICATION_WEB ||
-                current.source == AccessTokenSource.FACEBOOK_APPLICATION_NATIVE ||
-                current.source == AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+        // Only tokens obtained via SSO support refresh. Token refresh returns the expiration date
+        // in seconds from the epoch rather than seconds from now.
+        if (current.source != AccessTokenSource.FACEBOOK_APPLICATION_WEB &&
+                current.source != AccessTokenSource.FACEBOOK_APPLICATION_NATIVE &&
+                current.source != AccessTokenSource.FACEBOOK_APPLICATION_SERVICE) {
+            throw new FacebookException("Invalid token source: " + current.source);
+        }
 
-        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date(0));
+        Date expires = Utility.getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date(0));
         String token = bundle.getString(ACCESS_TOKEN_KEY);
 
-        return createNew(current.getPermissions(), token, expires, current.source);
+        if (Utility.isNullOrEmpty(token)) {
+            return null;
+        }
+        return new AccessToken(
+                token,
+                current.applicationId,
+                current.getUserId(),
+                current.getPermissions(),
+                current.getDeclinedPermissions(),
+                current.source,
+                expires,
+                new Date());
     }
 
-    static AccessToken createFromTokenWithRefreshedPermissions(AccessToken token, List<String> permissions) {
-        return new AccessToken(token.token, token.expires, permissions, token.source, token.lastRefresh);
-    }
+    static AccessToken createFromLegacyCache(Bundle bundle) {
+        List<String> permissions = getPermissionsFromBundle(
+                bundle,
+                LegacyTokenHelper.PERMISSIONS_KEY);
+        List<String> declinedPermissions = getPermissionsFromBundle(
+                bundle,
+                LegacyTokenHelper.DECLINED_PERMISSIONS_KEY);
+
+        String applicationId = LegacyTokenHelper.getApplicationId(bundle);
+        if (Utility.isNullOrEmpty(applicationId)) {
+            applicationId = FacebookSdk.getApplicationId();
+        }
 
-    private static AccessToken createNew(
-            List<String> requestedPermissions, String accessToken, Date expires, AccessTokenSource source) {
-        if (Utility.isNullOrEmpty(accessToken) || (expires == null)) {
-            return createEmptyToken(requestedPermissions);
-        } else {
-            return new AccessToken(accessToken, expires, requestedPermissions, source, new Date());
+        String tokenString = LegacyTokenHelper.getToken(bundle);
+        String userId;
+        JSONObject userInfo = Utility.awaitGetGraphMeRequestWithCache(tokenString);
+        try {
+            userId = userInfo.getString("id");
+        } catch (JSONException ex) {
+            // This code is only used by AccessTokenCache. If we for any reason fail to get the
+            // user id just return null.
+            return null;
         }
+
+        return new AccessToken(
+                tokenString,
+                applicationId,
+                userId,
+                permissions,
+                declinedPermissions,
+                LegacyTokenHelper.getSource(bundle),
+                LegacyTokenHelper.getDate(
+                        bundle,
+                        LegacyTokenHelper.EXPIRATION_DATE_KEY),
+                LegacyTokenHelper.getDate(
+                        bundle,
+                        LegacyTokenHelper.LAST_REFRESH_DATE_KEY)
+        );
     }
 
-    static AccessToken createFromCache(Bundle bundle) {
+    static List<String> getPermissionsFromBundle(Bundle bundle, String key) {
         // Copy the list so we can guarantee immutable
-        List<String> originalPermissions = bundle.getStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY);
+        List<String> originalPermissions = bundle.getStringArrayList(key);
         List<String> permissions;
         if (originalPermissions == null) {
             permissions = Collections.emptyList();
         } else {
             permissions = Collections.unmodifiableList(new ArrayList<String>(originalPermissions));
         }
-
-        return new AccessToken(bundle.getString(TokenCachingStrategy.TOKEN_KEY), TokenCachingStrategy.getDate(bundle,
-                TokenCachingStrategy.EXPIRATION_DATE_KEY), permissions, TokenCachingStrategy.getSource(bundle),
-                TokenCachingStrategy.getDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY));
+        return permissions;
     }
 
-    Bundle toCacheBundle() {
-        Bundle bundle = new Bundle();
-
-        bundle.putString(TokenCachingStrategy.TOKEN_KEY, this.token);
-        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.EXPIRATION_DATE_KEY, expires);
-        bundle.putStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY, new ArrayList<String>(permissions));
-        bundle.putSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY, source);
-        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY, lastRefresh);
+    /**
+     * Shows if the token is expired.
+     *
+     * @return true if the token is expired.
+     */
+    public boolean isExpired() {
+        return new Date().after(this.expires);
+    }
 
-        return bundle;
+    JSONObject toJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put(VERSION_KEY, CURRENT_JSON_FORMAT);
+        jsonObject.put(TOKEN_KEY, token);
+        jsonObject.put(EXPIRES_AT_KEY, expires.getTime());
+        JSONArray permissionsArray = new JSONArray(permissions);
+        jsonObject.put(PERMISSIONS_KEY, permissionsArray);
+        JSONArray declinedPermissionsArray = new JSONArray(declinedPermissions);
+        jsonObject.put(DECLINED_PERMISSIONS_KEY, declinedPermissionsArray);
+        jsonObject.put(LAST_REFRESH_KEY, lastRefresh.getTime());
+        jsonObject.put(SOURCE_KEY, source.name());
+        jsonObject.put(APPLICATION_ID_KEY, applicationId);
+        jsonObject.put(USER_ID_KEY, userId);
+
+        return jsonObject;
     }
 
-    boolean isInvalid() {
-        return Utility.isNullOrEmpty(this.token) || new Date().after(this.expires);
+    static AccessToken createFromJSONObject(JSONObject jsonObject) throws JSONException {
+        int version = jsonObject.getInt(VERSION_KEY);
+        if (version > CURRENT_JSON_FORMAT) {
+            throw new FacebookException("Unknown AccessToken serialization format.");
+        }
+
+        String token = jsonObject.getString(TOKEN_KEY);
+        Date expiresAt = new Date(jsonObject.getLong(EXPIRES_AT_KEY));
+        JSONArray permissionsArray = jsonObject.getJSONArray(PERMISSIONS_KEY);
+        JSONArray declinedPermissionsArray = jsonObject.getJSONArray(DECLINED_PERMISSIONS_KEY);
+        Date lastRefresh = new Date(jsonObject.getLong(LAST_REFRESH_KEY));
+        AccessTokenSource source = AccessTokenSource.valueOf(jsonObject.getString(SOURCE_KEY));
+        String applicationId = jsonObject.getString(APPLICATION_ID_KEY);
+        String userId = jsonObject.getString(USER_ID_KEY);
+
+        return new AccessToken(
+                token,
+                applicationId,
+                userId,
+                Utility.jsonArrayToStringList(permissionsArray),
+                Utility.jsonArrayToStringList(declinedPermissionsArray),
+                source,
+                expiresAt,
+                lastRefresh);
     }
 
-    private static AccessToken createFromBundle(List<String> requestedPermissions, Bundle bundle,
+    private static AccessToken createFromBundle(
+            List<String> requestedPermissions,
+            Bundle bundle,
             AccessTokenSource source,
-            Date expirationBase) {
+            Date expirationBase,
+            String applicationId) {
         String token = bundle.getString(ACCESS_TOKEN_KEY);
-        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, expirationBase);
+        Date expires = Utility.getBundleLongAsDate(bundle, EXPIRES_IN_KEY, expirationBase);
+        String userId = bundle.getString(USER_ID_KEY);
 
         if (Utility.isNullOrEmpty(token) || (expires == null)) {
             return null;
         }
 
-        return new AccessToken(token, expires, requestedPermissions, source, new Date());
+        return new AccessToken(
+                token,
+                applicationId,
+                userId,
+                requestedPermissions,
+                null,
+                source,
+                expires,
+                new Date());
     }
 
     private String tokenToString() {
         if (this.token == null) {
             return "null";
-        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS)) {
+        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS)) {
             return this.token;
         } else {
             return "ACCESS_TOKEN_REMOVED";
@@ -299,62 +554,49 @@ private void appendPermissions(StringBuilder builder) {
         }
     }
 
-    private static class SerializationProxyV1 implements Serializable {
-        private static final long serialVersionUID = -2488473066578201069L;
-        private final Date expires;
-        private final List<String> permissions;
-        private final String token;
-        private final AccessTokenSource source;
-        private final Date lastRefresh;
-
-        private SerializationProxyV1(String token, Date expires,
-                List<String> permissions, AccessTokenSource source, Date lastRefresh) {
-            this.expires = expires;
-            this.permissions = permissions;
-            this.token = token;
-            this.source = source;
-            this.lastRefresh = lastRefresh;
-        }
-
-        private Object readResolve() {
-            return new AccessToken(token, expires, permissions, source, lastRefresh);
-        }
+    AccessToken(Parcel parcel) {
+        this.expires = new Date(parcel.readLong());
+        ArrayList<String> permissionsList = new ArrayList<>();
+        parcel.readStringList(permissionsList);
+        this.permissions = Collections.unmodifiableSet(new HashSet<String>(permissionsList));
+        permissionsList.clear();
+        parcel.readStringList(permissionsList);
+        this.declinedPermissions = Collections.unmodifiableSet(
+                new HashSet<String>(permissionsList));
+        this.token = parcel.readString();
+        this.source = AccessTokenSource.valueOf(parcel.readString());
+        this.lastRefresh = new Date(parcel.readLong());
+        this.applicationId = parcel.readString();
+        this.userId = parcel.readString();
     }
 
-    private Object writeReplace() {
-        return new SerializationProxyV1(token, expires, permissions, source, lastRefresh);
+    @Override
+    public int describeContents() {
+        return 0;
     }
 
-    // have a readObject that throws to prevent spoofing
-    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
-        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(expires.getTime());
+        dest.writeStringList(new ArrayList<String>(permissions));
+        dest.writeStringList(new ArrayList<String>(declinedPermissions));
+        dest.writeString(token);
+        dest.writeString(source.name());
+        dest.writeLong(lastRefresh.getTime());
+        dest.writeString(applicationId);
+        dest.writeString(userId);
     }
 
+    public static final Parcelable.Creator<AccessToken> CREATOR = new Parcelable.Creator() {
 
-    private static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
-        if (bundle == null) {
-            return null;
-        }
-
-        long secondsFromBase = Long.MIN_VALUE;
-
-        Object secondsObject = bundle.get(key);
-        if (secondsObject instanceof Long) {
-            secondsFromBase = (Long) secondsObject;
-        } else if (secondsObject instanceof String) {
-            try {
-                secondsFromBase = Long.parseLong((String) secondsObject);
-            } catch (NumberFormatException e) {
-                return null;
-            }
-        } else {
-            return null;
+        @Override
+        public AccessToken createFromParcel(Parcel source) {
+            return new AccessToken(source);
         }
 
-        if (secondsFromBase == 0) {
-            return new Date(Long.MAX_VALUE);
-        } else {
-            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
+        @Override
+        public AccessToken[] newArray(int size) {
+            return new AccessToken[size];
         }
-    }
+    };
 }
diff --git a/facebook/src/com/facebook/AccessTokenCache.java b/facebook/src/com/facebook/AccessTokenCache.java
new file mode 100644
index 000000000..2b3ccf49c
--- /dev/null
+++ b/facebook/src/com/facebook/AccessTokenCache.java
@@ -0,0 +1,140 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+
+import com.facebook.internal.Validate;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+class AccessTokenCache {
+    static final String CACHED_ACCESS_TOKEN_KEY
+            = "com.facebook.AccessTokenManager.CachedAccessToken";
+
+    private final SharedPreferences sharedPreferences;
+    private final SharedPreferencesTokenCachingStrategyFactory tokenCachingStrategyFactory;
+    private LegacyTokenHelper tokenCachingStrategy;
+
+    AccessTokenCache(SharedPreferences sharedPreferences,
+                     SharedPreferencesTokenCachingStrategyFactory tokenCachingStrategyFactory) {
+        this.sharedPreferences = sharedPreferences;
+        this.tokenCachingStrategyFactory = tokenCachingStrategyFactory;
+    }
+
+    public AccessTokenCache() {
+        this(
+                FacebookSdk.getApplicationContext().getSharedPreferences(
+                        AccessTokenManager.SHARED_PREFERENCES_NAME,
+                        Context.MODE_PRIVATE),
+                new SharedPreferencesTokenCachingStrategyFactory()
+        );
+    }
+
+    public AccessToken load() {
+        AccessToken accessToken = null;
+        if (hasCachedAccessToken()) {
+            // If we have something cached, we try to use it; even if it is invalid, do not fall
+            // back to a legacy caching strategy.
+            accessToken = getCachedAccessToken();
+        } else if (shouldCheckLegacyToken()) {
+            accessToken = getLegacyAccessToken();
+
+            if (accessToken != null) {
+                save(accessToken);
+                getTokenCachingStrategy().clear();
+            }
+        }
+
+        return accessToken;
+    }
+
+    public void save(AccessToken accessToken) {
+        Validate.notNull(accessToken, "accessToken");
+
+        JSONObject jsonObject = null;
+        try {
+            jsonObject = accessToken.toJSONObject();
+            sharedPreferences.edit().putString(CACHED_ACCESS_TOKEN_KEY, jsonObject.toString())
+                    .apply();
+        } catch (JSONException e) {
+            // Can't recover
+        }
+    }
+
+    public void clear() {
+        sharedPreferences.edit().remove(CACHED_ACCESS_TOKEN_KEY).apply();
+        if (shouldCheckLegacyToken()) {
+            getTokenCachingStrategy().clear();
+        }
+    }
+
+    private boolean hasCachedAccessToken() {
+        return sharedPreferences.contains(CACHED_ACCESS_TOKEN_KEY);
+    }
+
+    private AccessToken getCachedAccessToken() {
+        String jsonString = sharedPreferences.getString(CACHED_ACCESS_TOKEN_KEY, null);
+        if (jsonString != null) {
+            try {
+                JSONObject jsonObject = new JSONObject(jsonString);
+                return AccessToken.createFromJSONObject(jsonObject);
+            } catch (JSONException e) {
+                return null;
+            }
+        }
+        return null;
+    }
+
+    private boolean shouldCheckLegacyToken() {
+        return FacebookSdk.isLegacyTokenUpgradeSupported();
+    }
+
+    private AccessToken getLegacyAccessToken() {
+        AccessToken accessToken = null;
+        Bundle bundle = getTokenCachingStrategy().load();
+
+        if (bundle != null && LegacyTokenHelper.hasTokenInformation(bundle)) {
+            accessToken = AccessToken.createFromLegacyCache(bundle);
+        }
+        return accessToken;
+    }
+
+    private LegacyTokenHelper getTokenCachingStrategy() {
+        if (tokenCachingStrategy == null) {
+            synchronized (this) {
+                if (tokenCachingStrategy == null) {
+                    tokenCachingStrategy = tokenCachingStrategyFactory.create();
+                }
+            }
+        }
+        return tokenCachingStrategy;
+    }
+
+    static class SharedPreferencesTokenCachingStrategyFactory {
+        public LegacyTokenHelper create() {
+            return new LegacyTokenHelper(FacebookSdk.getApplicationContext());
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/AccessTokenManager.java b/facebook/src/com/facebook/AccessTokenManager.java
new file mode 100644
index 000000000..82ee6014f
--- /dev/null
+++ b/facebook/src/com/facebook/AccessTokenManager.java
@@ -0,0 +1,313 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+final class AccessTokenManager {
+    static final String TAG = "AccessTokenManager";
+
+    static final String ACTION_CURRENT_ACCESS_TOKEN_CHANGED =
+            "com.facebook.sdk.ACTION_CURRENT_ACCESS_TOKEN_CHANGED";
+    static final String EXTRA_OLD_ACCESS_TOKEN =
+            "com.facebook.sdk.EXTRA_OLD_ACCESS_TOKEN";
+    static final String EXTRA_NEW_ACCESS_TOKEN =
+            "com.facebook.sdk.EXTRA_NEW_ACCESS_TOKEN";
+    static final String SHARED_PREFERENCES_NAME =
+            "com.facebook.AccessTokenManager.SharedPreferences";
+
+    // Token extension constants
+    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1 day
+    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
+
+    private static final String TOKEN_EXTEND_GRAPH_PATH = "oauth/access_token";
+    private static final String ME_PERMISSIONS_GRAPH_PATH = "me/permissions";
+
+    private static volatile AccessTokenManager instance;
+
+    private final LocalBroadcastManager localBroadcastManager;
+    private final AccessTokenCache accessTokenCache;
+    private AccessToken currentAccessToken;
+    private AtomicBoolean tokenRefreshInProgress = new AtomicBoolean(false);
+    private Date lastAttemptedTokenExtendDate = new Date(0);
+
+    AccessTokenManager(LocalBroadcastManager localBroadcastManager,
+                       AccessTokenCache accessTokenCache) {
+
+        Validate.notNull(localBroadcastManager, "localBroadcastManager");
+        Validate.notNull(accessTokenCache, "accessTokenCache");
+
+        this.localBroadcastManager = localBroadcastManager;
+        this.accessTokenCache = accessTokenCache;
+    }
+
+    static AccessTokenManager getInstance() {
+        if (instance == null) {
+            synchronized (AccessTokenManager.class) {
+                if (instance == null) {
+                    Context applicationContext = FacebookSdk.getApplicationContext();
+                    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(
+                            applicationContext);
+                    AccessTokenCache accessTokenCache = new AccessTokenCache();
+
+                    instance = new AccessTokenManager(localBroadcastManager, accessTokenCache);
+                }
+            }
+        }
+
+        return instance;
+    }
+
+    AccessToken getCurrentAccessToken() {
+        return currentAccessToken;
+    }
+
+    boolean loadCurrentAccessToken() {
+        AccessToken accessToken = accessTokenCache.load();
+
+        if (accessToken != null) {
+            setCurrentAccessToken(accessToken, false);
+            return true;
+        }
+
+        return false;
+    }
+
+    void setCurrentAccessToken(AccessToken currentAccessToken) {
+        setCurrentAccessToken(currentAccessToken, true);
+    }
+
+    private void setCurrentAccessToken(AccessToken currentAccessToken, boolean saveToCache) {
+        AccessToken oldAccessToken = this.currentAccessToken;
+        this.currentAccessToken = currentAccessToken;
+        tokenRefreshInProgress.set(false);
+        this.lastAttemptedTokenExtendDate = new Date(0);
+
+        if (saveToCache) {
+            if (currentAccessToken != null) {
+                accessTokenCache.save(currentAccessToken);
+            } else {
+                accessTokenCache.clear();
+                Utility.clearFacebookCookies(FacebookSdk.getApplicationContext());
+            }
+        }
+
+        if (!Utility.areObjectsEqual(oldAccessToken, currentAccessToken)) {
+            sendCurrentAccessTokenChangedBroadcast(oldAccessToken, currentAccessToken);
+        }
+    }
+
+    private void sendCurrentAccessTokenChangedBroadcast(AccessToken oldAccessToken,
+        AccessToken currentAccessToken) {
+        Intent intent = new Intent(ACTION_CURRENT_ACCESS_TOKEN_CHANGED);
+
+        intent.putExtra(EXTRA_OLD_ACCESS_TOKEN, oldAccessToken);
+        intent.putExtra(EXTRA_NEW_ACCESS_TOKEN, currentAccessToken);
+
+        localBroadcastManager.sendBroadcast(intent);
+    }
+
+    void extendAccessTokenIfNeeded() {
+        if (!shouldExtendAccessToken()) {
+            return;
+        }
+        refreshCurrentAccessToken();
+    }
+
+    private boolean shouldExtendAccessToken() {
+        if (currentAccessToken == null) {
+            return false;
+        }
+        Long now = new Date().getTime();
+
+        return currentAccessToken.getSource().canExtendToken()
+                && now - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
+                && now - currentAccessToken.getLastRefresh().getTime() >
+                    TOKEN_EXTEND_THRESHOLD_SECONDS * 1000;
+    }
+
+    private static GraphRequest createGrantedPermissionsRequest(
+            AccessToken accessToken,
+            GraphRequest.Callback callback
+    ) {
+        Bundle parameters = new Bundle();
+        return new GraphRequest(
+                accessToken,
+                ME_PERMISSIONS_GRAPH_PATH,
+                parameters,
+                HttpMethod.GET,
+                callback);
+    }
+
+    private static GraphRequest createExtendAccessTokenRequest(
+            AccessToken accessToken,
+            GraphRequest.Callback callback
+    ) {
+        Bundle parameters = new Bundle();
+        parameters.putString("grant_type", "fb_extend_sso_token");
+        return new GraphRequest(
+                accessToken,
+                TOKEN_EXTEND_GRAPH_PATH,
+                parameters,
+                HttpMethod.GET,
+                callback);
+    }
+
+    private static class RefreshResult {
+        public String accessToken;
+        public int expiresAt;
+    }
+
+    void refreshCurrentAccessToken() {
+        if (Looper.getMainLooper().equals(Looper.myLooper())) {
+            refreshCurrentAccessTokenImpl();
+        } else {
+            Handler mainHandler = new Handler(Looper.getMainLooper());
+            mainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    refreshCurrentAccessTokenImpl();
+                }
+            });
+        }
+    }
+
+    private void refreshCurrentAccessTokenImpl() {
+        final AccessToken accessToken = currentAccessToken;
+        if (accessToken == null) {
+            return;
+        }
+        if (!tokenRefreshInProgress.compareAndSet(false, true)) {
+            return;
+        }
+
+        Validate.runningOnUiThread();
+
+        lastAttemptedTokenExtendDate = new Date();
+
+        final Set<String> permissions = new HashSet<>();
+        final Set<String> declinedPermissions = new HashSet<>();
+        final AtomicBoolean permissionsCallSucceeded = new AtomicBoolean(false);
+        final RefreshResult refreshResult = new RefreshResult();
+
+        GraphRequestBatch batch = new GraphRequestBatch(
+                createGrantedPermissionsRequest(accessToken, new GraphRequest.Callback() {
+                    @Override
+                    public void onCompleted(GraphResponse response) {
+                        JSONObject result = response.getJSONObject();
+                        if (result == null) {
+                            return;
+                        }
+                        JSONArray permissionsArray = result.optJSONArray("data");
+                        if (permissionsArray == null) {
+                            return;
+                        }
+                        permissionsCallSucceeded.set(true);
+                        for (int i = 0; i < permissionsArray.length(); i++) {
+                            JSONObject permissionEntry = permissionsArray.optJSONObject(i);
+                            if (permissionEntry == null) {
+                                continue;
+                            }
+                            String permission = permissionEntry.optString("permission");
+                            String status = permissionEntry.optString("status");
+                            if (!Utility.isNullOrEmpty(permission) &&
+                                    !Utility.isNullOrEmpty(status)) {
+                                status = status.toLowerCase(Locale.US);
+                                if (status.equals("granted")) {
+                                    permissions.add(permission);
+                                } else if (status.equals("declined")) {
+                                    declinedPermissions.add(permission);
+                                } else {
+                                    Log.w(TAG, "Unexpected status: " + status);
+                                }
+                            }
+                        }
+                    }
+                }),
+                createExtendAccessTokenRequest(accessToken, new GraphRequest.Callback() {
+                    @Override
+                    public void onCompleted(GraphResponse response) {
+                        JSONObject data = response.getJSONObject();
+                        if (data == null) {
+                            return;
+                        }
+                        refreshResult.accessToken = data.optString("access_token");
+                        refreshResult.expiresAt = data.optInt("expires_at");
+                    }
+                })
+        );
+
+        batch.addCallback(new GraphRequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(GraphRequestBatch batch) {
+                if (getInstance().getCurrentAccessToken() == null ||
+                        getInstance().getCurrentAccessToken().getUserId()
+                                != accessToken.getUserId()) {
+                    return;
+                }
+                try {
+                    if (permissionsCallSucceeded.get() == false &&
+                            refreshResult.accessToken == null &&
+                            refreshResult.expiresAt == 0) {
+                        return;
+                    }
+                    AccessToken newAccessToken = new AccessToken(
+                            refreshResult.accessToken != null ? refreshResult.accessToken :
+                                    accessToken.getToken(),
+                            accessToken.getApplicationId(),
+                            accessToken.getUserId(),
+                            permissionsCallSucceeded.get()
+                                    ? permissions : accessToken.getPermissions(),
+                            permissionsCallSucceeded.get()
+                                    ? declinedPermissions : accessToken.getDeclinedPermissions(),
+                            accessToken.getSource(),
+                            refreshResult.expiresAt != 0
+                                    ? new Date(refreshResult.expiresAt * 1000l)
+                                    : accessToken.getExpires(),
+                            new Date()
+                    );
+                    getInstance().setCurrentAccessToken(newAccessToken);
+                } finally {
+                    tokenRefreshInProgress.set(false);
+                }
+            }
+        });
+        batch.executeAsync();
+    }
+}
diff --git a/facebook/src/com/facebook/AccessTokenSource.java b/facebook/src/com/facebook/AccessTokenSource.java
index 263111285..76dbbdebf 100644
--- a/facebook/src/com/facebook/AccessTokenSource.java
+++ b/facebook/src/com/facebook/AccessTokenSource.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
diff --git a/facebook/src/com/facebook/AccessTokenTracker.java b/facebook/src/com/facebook/AccessTokenTracker.java
new file mode 100644
index 000000000..b25b6e4f6
--- /dev/null
+++ b/facebook/src/com/facebook/AccessTokenTracker.java
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.internal.Validate;
+
+
+/**
+ * This class can be extended to receive notifications of access token changes. The {@link
+ * #stopTracking()} method should be called in the onDestroy() method of the receiving Activity or
+ * Fragment.
+ */
+public abstract class AccessTokenTracker {
+
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+    private boolean isTracking = false;
+
+    /**
+     * The method that will be called with the access token changes.
+     * @param oldAccessToken The access token before the change.
+     * @param currentAccessToken The new access token.
+     */
+    protected abstract void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                        AccessToken currentAccessToken);
+
+    /**
+     * The constructor.
+     */
+    public AccessTokenTracker() {
+        Validate.sdkInitialized();
+
+        this.receiver = new CurrentAccessTokenBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(
+                FacebookSdk.getApplicationContext());
+
+        startTracking();
+    }
+
+    /**
+     * Starts tracking the current access token
+     */
+    public void startTracking() {
+        if (isTracking) {
+            return;
+        }
+
+        addBroadcastReceiver();
+
+        isTracking = true;
+    }
+
+    /**
+     * Stops tracking the current access token.
+     */
+    public void stopTracking() {
+        if (!isTracking) {
+            return;
+        }
+
+        broadcastManager.unregisterReceiver(receiver);
+        isTracking = false;
+    }
+
+    /**
+     * Gets whether the tracker is tracking the current access token.
+     * @return true if the tracker is tracking the current access token, false if not
+     */
+    public boolean isTracking() {
+        return isTracking;
+    }
+
+    private class CurrentAccessTokenBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED.equals(intent.getAction())) {
+
+                AccessToken oldAccessToken = (AccessToken) intent
+                        .getParcelableExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN);
+                AccessToken newAccessToken = (AccessToken) intent
+                        .getParcelableExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN);
+
+                onCurrentAccessTokenChanged(oldAccessToken, newAccessToken);
+            }
+        }
+    }
+
+    private void addBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED);
+
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+}
diff --git a/facebook/src/com/facebook/AppEventsLogger.java b/facebook/src/com/facebook/AppEventsLogger.java
deleted file mode 100644
index 0081ec8a8..000000000
--- a/facebook/src/com/facebook/AppEventsLogger.java
+++ /dev/null
@@ -1,1302 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.content.LocalBroadcastManager;
-import android.util.Log;
-import com.facebook.internal.*;
-import com.facebook.model.GraphObject;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.*;
-import java.math.BigDecimal;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-
-
-/**
- * <p>
- * The AppEventsLogger class allows the developer to log various types of events back to Facebook.  In order to log
- * events, the app must create an instance of this class via a {@link #newLogger newLogger} method, and then call
- * the various "log" methods off of that.
- * </p>
- * <p>
- * This client-side event logging is then available through Facebook App Insights
- * and for use with Facebook Ads conversion tracking and optimization.
- * </p>
- * <p>
- * The AppEventsLogger class has a few related roles:
- * <ul>
- * <li>
- * Logging predefined and application-defined events to Facebook App Insights with a
- * numeric value to sum across a large number of events, and an optional set of key/value
- * parameters that define "segments" for this event (e.g., 'purchaserStatus' : 'frequent', or
- * 'gamerLevel' : 'intermediate').  These events may also be used for ads conversion tracking,
- * optimization, and other ads related targeting in the future.
- * </li>
- * <li>
- * Methods that control the way in which events are flushed out to the Facebook servers.
- * </li>
- * </ul>
- * Here are some important characteristics of the logging mechanism provided by AppEventsLogger:
- * <ul>
- * <li>
- * Events are not sent immediately when logged.  They're cached and flushed out to the Facebook servers
- * in a number of situations:
- * <ul>
- * <li>when an event count threshold is passed (currently 100 logged events).</li>
- * <li>when a time threshold is passed (currently 60 seconds).</li>
- * <li>when an app has gone to background and is then brought back to the foreground.</li>
- * </ul>
- * <li>
- * Events will be accumulated when the app is in a disconnected state, and sent when the connection is
- * restored and one of the above 'flush' conditions are met.
- * </li>
- * <li>
- * The AppEventsLogger class is intended to be used from the thread it was created on.  Multiple AppEventsLoggers
- * may be created on other threads if desired.
- * </li>
- * <li>
- * The developer can call the setFlushBehavior method to force the flushing of events to only
- * occur on an explicit call to the `flush` method.
- * </li>
- * <li>
- * The developer can turn on console debug output for event logging and flushing to the server
- * Settings.addLoggingBehavior(LoggingBehavior.APP_EVENTS);
- * </li>
- * </ul>
- * Some things to note when logging events:
- * <ul>
- * <li>
- * There is a limit on the number of unique event names an app can use, on the order of 300.
- * </li>
- * <li>
- * There is a limit to the number of unique parameter names in the provided parameters that can
- * be used per event, on the order of 10.  This is not just for an individual call, but for all
- * invocations for that eventName.
- * </li>
- * <li>
- * Event names and parameter names (the keys in the NSDictionary) must be between 2 and 40 characters, and
- * must consist of alphanumeric characters, _, -, or spaces.
- * </li>
- * <li>
- * The length of each parameter value can be no more than on the order of 100 characters.
- * </li>
- * </ul>
- */
-public class AppEventsLogger {
-    // Enums
-
-    /**
-     * Controls when an AppEventsLogger sends log events to the server
-     */
-    public enum FlushBehavior {
-        /**
-         * Flush automatically: periodically (once a minute or after every 100 events), and always at app reactivation.
-         * This is the default value.
-         */
-        AUTO,
-
-        /**
-         * Only flush when AppEventsLogger.flush() is explicitly invoked.
-         */
-        EXPLICIT_ONLY,
-    }
-
-    private enum SuppressionTimeoutBehavior {
-        // Successfully logging an event will reset the timeout period (i.e., events will log no more than every N
-        // seconds).
-        RESET_TIMEOUT_WHEN_LOG_SUCCESSFUL,
-        // Attempting to log an event, even if it is suppressed, will reset the timeout period (i.e., events will not
-        // be logged until they have been "silent" for at least N seconds).
-        RESET_TIMEOUT_WHEN_LOG_ATTEMPTED,
-    }
-
-    private static class EventSuppression {
-        // Timeout period in seconds
-        private int timeoutPeriod;
-        private SuppressionTimeoutBehavior behavior;
-
-        EventSuppression(int timeoutPeriod, SuppressionTimeoutBehavior behavior) {
-            this.timeoutPeriod = timeoutPeriod;
-            this.behavior = behavior;
-        }
-
-        int getTimeoutPeriod() {
-            return timeoutPeriod;
-        }
-
-        SuppressionTimeoutBehavior getBehavior() {
-            return behavior;
-        }
-    }
-
-    // Constants
-    private static final String TAG = AppEventsLogger.class.getCanonicalName();
-
-    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER                  = 100;
-    private static final int FLUSH_PERIOD_IN_SECONDS                               = 60;
-    private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
-    private static final int APP_ACTIVATE_SUPPRESSION_PERIOD_IN_SECONDS            = 5 * 60;
-
-    // Instance member variables
-    private final Context context;
-    private final AccessTokenAppIdPair accessTokenAppId;
-
-    private static Map<AccessTokenAppIdPair, SessionEventsState> stateMap =
-            new ConcurrentHashMap<AccessTokenAppIdPair, SessionEventsState>();
-    private static Timer flushTimer;
-    private static Timer supportsAttributionRecheckTimer;
-    private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
-    private static boolean requestInFlight;
-    private static Context applicationContext;
-    private static Object staticLock = new Object();
-    private static String hashedDeviceAndAppId;
-    private static Map<String, Date> mapEventsToSuppressionTime = new HashMap<String, Date>();
-    @SuppressWarnings("serial")
-    private static Map<String, EventSuppression> mapEventNameToSuppress = new HashMap<String, EventSuppression>() {
-        {
-            put(AppEventsConstants.EVENT_NAME_ACTIVATED_APP,
-                    new EventSuppression(APP_ACTIVATE_SUPPRESSION_PERIOD_IN_SECONDS,
-                            SuppressionTimeoutBehavior.RESET_TIMEOUT_WHEN_LOG_ATTEMPTED));
-        }
-    };
-
-    // Rather than retaining Sessions, we extract the information we need and track app events by
-    // application ID and access token (which may be null for Session-less calls). This avoids needing to
-    // worry about Session lifecycle and also allows us to coalesce app events from different Sessions
-    // that have the same access token/app ID.
-    private static class AccessTokenAppIdPair implements Serializable {
-        private static final long serialVersionUID = 1L;
-        private final String accessToken;
-        private final String applicationId;
-
-        AccessTokenAppIdPair(Session session) {
-            this(session.getAccessToken(), session.getApplicationId());
-        }
-
-        AccessTokenAppIdPair(String accessToken, String applicationId) {
-            this.accessToken = Utility.isNullOrEmpty(accessToken) ? null : accessToken;
-            this.applicationId = applicationId;
-        }
-
-        String getAccessToken() {
-            return accessToken;
-        }
-
-        String getApplicationId() {
-            return applicationId;
-        }
-
-        @Override
-        public int hashCode() {
-            return (accessToken == null ? 0 : accessToken.hashCode()) ^
-                    (applicationId == null ? 0 : applicationId.hashCode());
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (!(o instanceof AccessTokenAppIdPair)) {
-                return false;
-            }
-            AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
-            return Utility.areObjectsEqual(p.accessToken, accessToken) &&
-                    Utility.areObjectsEqual(p.applicationId, applicationId);
-        }
-
-        private static class SerializationProxyV1 implements Serializable {
-            private static final long serialVersionUID = -2488473066578201069L;
-            private final String accessToken;
-            private final String appId;
-
-            private SerializationProxyV1(String accessToken, String appId) {
-                this.accessToken = accessToken;
-                this.appId = appId;
-            }
-
-            private Object readResolve() {
-                return new AccessTokenAppIdPair(accessToken, appId);
-            }
-        }
-
-        private Object writeReplace() {
-            return new SerializationProxyV1(accessToken, applicationId);
-        }
-    }
-
-    /**
-     * This method is deprecated.  Use {@link Settings#getLimitEventAndDataUsage(Context)} instead.
-     */
-    @Deprecated
-    public static boolean getLimitEventUsage(Context context) {
-        return Settings.getLimitEventAndDataUsage(context);
-    }
-
-    /**
-     * This method is deprecated.  Use {@link Settings#setLimitEventAndDataUsage(Context, boolean)} instead.
-     */
-    @Deprecated
-    public static void setLimitEventUsage(Context context, boolean limitEventUsage) {
-        Settings.setLimitEventAndDataUsage(context, limitEventUsage);
-    }
-
-    /**
-     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be called whenever
-     * your app becomes active, typically in the onResume() method of each long-running Activity of your app.
-     *
-     * Use this method if your application ID is stored in application metadata, otherwise see
-     * {@link AppEventsLogger#activateApp(android.content.Context, String)}.
-     *
-     * @param context   Used to access the applicationId and the attributionId for non-authenticated users.
-     */
-    public static void activateApp(Context context) {
-        activateApp(context, Utility.getMetadataApplicationId(context));
-    }
-
-    /**
-     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be called whenever
-     * your app becomes active, typically in the onResume() method of each long-running Activity of your app.
-     *
-     * @param context   Used to access the attributionId for non-authenticated users.
-     *
-     * @param applicationId  The specific applicationId to report the activation for.
-     */
-    @SuppressWarnings("deprecation")
-    public static void activateApp(Context context, String applicationId) {
-        if (context == null || applicationId == null) {
-            throw new IllegalArgumentException("Both context and applicationId must be non-null");
-        }
-
-        // activateApp supercedes publishInstall in the public API, so we need to explicitly invoke it, since the server
-        // can't reliably infer install state for all conditions of an app activate.
-        Settings.publishInstallAsync(context, applicationId);
-
-        AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
-        logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP);
-    }
-
-    /**
-     * Build an AppEventsLogger instance to log events through.  The Facebook app that these events are targeted at
-     * comes from this application's metadata. The application ID used to log events will be determined from
-     * the app ID specified in the package metadata.
-     *
-     * @param context   Used to access the applicationId and the attributionId for non-authenticated users.
-     *
-     * @return          AppEventsLogger instance to invoke log* methods on.
-     */
-    public static AppEventsLogger newLogger(Context context) {
-        return new AppEventsLogger(context, null, null);
-    }
-
-    /**
-     * Build an AppEventsLogger instance to log events through.
-     *
-     * @param context        Used to access the attributionId for non-authenticated users.
-     * @param session        Explicitly specified Session to log events against.  If null, the activeSession
-     *                       will be used if it's open, otherwise the logging will happen against the default
-     *                       app ID specified via the app ID specified in the package metadata.
-     *
-     * @return          AppEventsLogger instance to invoke log* methods on.
-     */
-    public static AppEventsLogger newLogger(Context context, Session session) {
-        return new AppEventsLogger(context, null, session);
-    }
-
-    /**
-     * Build an AppEventsLogger instance to log events through.
-     *
-     * @param context        Used to access the attributionId for non-authenticated users.
-     * @param applicationId  Explicitly specified Facebook applicationId to log events against.  If null, the default
-     *                       app ID specified in the package metadata will be used.
-     * @param session        Explicitly specified Session to log events against.  If null, the activeSession
-     *                       will be used if it's open, otherwise the logging will happen against the specified
-     *                       app ID.
-     *
-     * @return          AppEventsLogger instance to invoke log* methods on.
-     */
-    public static AppEventsLogger newLogger(Context context, String applicationId, Session session) {
-        return new AppEventsLogger(context, applicationId, session);
-    }
-
-    /**
-     * Build an AppEventsLogger instance to log events that are attributed to the application but not to
-     * any particular Session.
-     *
-     * @param context        Used to access the attributionId for non-authenticated users.
-     * @param applicationId  Explicitly specified Facebook applicationId to log events against.  If null, the default
-     *                       app ID specified
-     *                       in the package metadata will be used.
-     *
-     * @return          AppEventsLogger instance to invoke log* methods on.
-     */
-    public static AppEventsLogger newLogger(Context context, String applicationId) {
-        return new AppEventsLogger(context, applicationId, null);
-    }
-
-    /**
-     * The action used to indicate that a flush of app events has occurred. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
-     */
-    public static final String ACTION_APP_EVENTS_FLUSHED = "com.facebook.sdk.APP_EVENTS_FLUSHED";
-
-    public static final String APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED = "com.facebook.sdk.APP_EVENTS_NUM_EVENTS_FLUSHED";
-    public static final String APP_EVENTS_EXTRA_FLUSH_RESULT = "com.facebook.sdk.APP_EVENTS_FLUSH_RESULT";
-
-    /**
-     * Access the behavior that AppEventsLogger uses to determine when to flush logged events to the server. This
-     * setting applies to all instances of AppEventsLogger.
-     * @return specified flush behavior.
-     */
-    public static FlushBehavior getFlushBehavior() {
-        synchronized (staticLock) {
-            return flushBehavior;
-        }
-    }
-
-    /**
-     * Set the behavior that this AppEventsLogger uses to determine when to flush logged events to the server. This
-     * setting applies to all instances of AppEventsLogger.
-     * @param flushBehavior the desired behavior.
-     */
-    public static void setFlushBehavior(FlushBehavior flushBehavior) {
-        synchronized (staticLock) {
-            AppEventsLogger.flushBehavior = flushBehavior;
-        }
-    }
-
-    /**
-     * Log an app event with the specified name.
-     * @param eventName eventName used to denote the event.  Choose amongst the EVENT_NAME_* constants in
-     *                  {@link AppEventsConstants} when possible.  Or create your own if none of the EVENT_NAME_*
-     *                  constants are applicable.
-     *                  Event names should be 40 characters or less, alphanumeric, and can include spaces, underscores
-     *                  or hyphens, but mustn't have a space or hyphen as the first character.  Any given app should
-     *                  have no more than ~300 distinct event names.
-      */
-    public void logEvent(String eventName) {
-        logEvent(eventName, null);
-    }
-
-    /**
-     * Log an app event with the specified name and the supplied value.
-     * @param eventName eventName used to denote the event.  Choose amongst the EVENT_NAME_* constants in
-     *                  {@link AppEventsConstants} when possible.  Or create your own if none of the EVENT_NAME_*
-     *                  constants are applicable.
-     *                  Event names should be 40 characters or less, alphanumeric, and can include spaces, underscores
-     *                  or hyphens, but mustn't have a space or hyphen as the first character.  Any given app should
-     *                  have no more than ~300 distinct event names.
-     *                  * @param eventName
-     * @param valueToSum a value to associate with the event which will be summed up in Insights for across all
-     *                   instances of the event, so that average values can be determined, etc.
-     */
-    public void logEvent(String eventName, double valueToSum) {
-        logEvent(eventName, valueToSum, null);
-    }
-
-    /**
-     * Log an app event with the specified name and set of parameters.
-     * @param eventName eventName used to denote the event.  Choose amongst the EVENT_NAME_* constants in
-     *                  {@link AppEventsConstants} when possible.  Or create your own if none of the EVENT_NAME_*
-     *                  constants are applicable.
-     *                  Event names should be 40 characters or less, alphanumeric, and can include spaces, underscores
-     *                  or hyphens, but mustn't have a space or hyphen as the first character.  Any given app should
-     *                  have no more than ~300 distinct event names.
-     * @param parameters A Bundle of parameters to log with the event.  Insights will allow looking at the logs of these
-     *                   events via different parameter values.  You can log on the order of 10 parameters with each
-     *                   distinct eventName.  It's advisable to keep the number of unique values provided for each
-     *                   parameter in the, at most, thousands.  As an example, don't attempt to provide a unique
-     *                   parameter value for each unique user in your app.  You won't get meaningful aggregate reporting
-     *                   on so many parameter values.  The values in the bundles should be Strings or numeric values.
-     */
-    public void logEvent(String eventName, Bundle parameters) {
-        logEvent(eventName, null, parameters, false);
-    }
-
-    /**
-     * Log an app event with the specified name, supplied value, and set of parameters.
-     * @param eventName eventName used to denote the event.  Choose amongst the EVENT_NAME_* constants in
-     *                  {@link AppEventsConstants} when possible.  Or create your own if none of the EVENT_NAME_*
-     *                  constants are applicable.
-     *                  Event names should be 40 characters or less, alphanumeric, and can include spaces, underscores
-     *                  or hyphens, but mustn't have a space or hyphen as the first character.  Any given app should
-     *                  have no more than ~300 distinct event names.
-     * @param valueToSum a value to associate with the event which will be summed up in Insights for across all
-     *                   instances of the event, so that average values can be determined, etc.
-     * @param parameters A Bundle of parameters to log with the event.  Insights will allow looking at the logs of these
-     *                   events via different parameter values.  You can log on the order of 10 parameters with each
-     *                   distinct eventName.  It's advisable to keep the number of unique values provided for each
-     *                   parameter in the, at most, thousands.  As an example, don't attempt to provide a unique
-     *                   parameter value for each unique user in your app.  You won't get meaningful aggregate reporting
-     *                   on so many parameter values.  The values in the bundles should be Strings or numeric values.
-     */
-    public void logEvent(String eventName, double valueToSum, Bundle parameters) {
-        logEvent(eventName, valueToSum, parameters, false);
-    }
-
-    /**
-     * Logs a purchase event with Facebook, in the specified amount and with the specified currency.
-     *
-     * @param purchaseAmount  Amount of purchase, in the currency specified by the 'currency' parameter. This value
-     *                        will be rounded to the thousandths place (e.g., 12.34567 becomes 12.346).
-     * @param currency        Currency used to specify the amount.
-     */
-    public void logPurchase(BigDecimal purchaseAmount, Currency currency) {
-        logPurchase(purchaseAmount, currency, null);
-    }
-
-    /**
-     * Logs a purchase event with Facebook, in the specified amount and with the specified currency.  Additional
-     * detail about the purchase can be passed in through the parameters bundle.
-     *
-     * @param purchaseAmount  Amount of purchase, in the currency specified by the 'currency' parameter. This value
-     *                        will be rounded to the thousandths place (e.g., 12.34567 becomes 12.346).
-     * @param currency        Currency used to specify the amount.
-     * @param parameters      Arbitrary additional information for describing this event.  Should have no more than
-     *                        10 entries, and keys should be mostly consistent from one purchase event to the next.
-     */
-    public void logPurchase(BigDecimal purchaseAmount, Currency currency, Bundle parameters) {
-
-        if (purchaseAmount == null) {
-            notifyDeveloperError("purchaseAmount cannot be null");
-            return;
-        } else if (currency == null) {
-            notifyDeveloperError("currency cannot be null");
-            return;
-        }
-
-        if (parameters == null) {
-            parameters = new Bundle();
-        }
-        parameters.putString(AppEventsConstants.EVENT_PARAM_CURRENCY, currency.getCurrencyCode());
-
-        logEvent(AppEventsConstants.EVENT_NAME_PURCHASED, purchaseAmount.doubleValue(), parameters);
-        eagerFlush();
-    }
-
-    /**
-     * Explicitly flush any stored events to the server.  Implicit flushes may happen depending on the value
-     * of getFlushBehavior.  This method allows for explicit, app invoked flushing.
-     */
-    public void flush() {
-        flush(FlushReason.EXPLICIT);
-    }
-
-    /**
-     * Call this when the consuming Activity/Fragment receives an onStop() callback in order to persist any
-     * outstanding events to disk, so they may be flushed at a later time. The next flush (explicit or not)
-     * will check for any outstanding events and, if present, include them in that flush. Note that this call
-     * may trigger an I/O operation on the calling thread. Explicit use of this method is not necessary
-     * if the consumer is making use of {@link UiLifecycleHelper}, which will take care of making the call
-     * in its own onStop() callback.
-     */
-    public static void onContextStop() {
-        PersistedEvents.persistEvents(applicationContext, stateMap);
-    }
-
-    boolean isValidForSession(Session session) {
-        AccessTokenAppIdPair other = new AccessTokenAppIdPair(session);
-        return accessTokenAppId.equals(other);
-    }
-
-    /**
-     * This method is intended only for internal use by the Facebook SDK and other use is unsupported.
-     */
-    public void logSdkEvent(String eventName, Double valueToSum, Bundle parameters) {
-        logEvent(eventName, valueToSum, parameters, true);
-    }
-
-    /**
-     * Returns the app ID this logger was configured to log to.
-     * @return the Facebook app ID
-     */
-    public String getApplicationId() {
-        return accessTokenAppId.getApplicationId();
-    }
-
-    //
-    // Private implementation
-    //
-
-    private enum FlushReason {
-        EXPLICIT,
-        TIMER,
-        SESSION_CHANGE,
-        PERSISTED_EVENTS,
-        EVENT_THRESHOLD,
-        EAGER_FLUSHING_EVENT,
-    }
-
-    private enum FlushResult {
-        SUCCESS,
-        SERVER_ERROR,
-        NO_CONNECTIVITY,
-        UNKNOWN_ERROR
-    }
-
-    /**
-     * Constructor is private, newLogger() methods should be used to build an instance.
-     */
-    private AppEventsLogger(Context context, String applicationId, Session session) {
-
-        Validate.notNull(context, "context");
-        this.context = context;
-
-        if (session == null) {
-            session = Session.getActiveSession();
-        }
-
-        if (session != null) {
-            accessTokenAppId = new AccessTokenAppIdPair(session);
-        } else {
-            if (applicationId == null) {
-                applicationId = Utility.getMetadataApplicationId(context);
-            }
-            accessTokenAppId = new AccessTokenAppIdPair(null, applicationId);
-        }
-
-        synchronized (staticLock) {
-
-            if (hashedDeviceAndAppId == null) {
-                hashedDeviceAndAppId = Utility.getHashedDeviceAndAppID(context, applicationId);
-            }
-
-            if (applicationContext == null) {
-                applicationContext = context.getApplicationContext();
-            }
-        }
-
-        initializeTimersIfNeeded();
-    }
-
-    private static void initializeTimersIfNeeded() {
-        synchronized (staticLock) {
-            if (flushTimer != null) {
-                return;
-            }
-            flushTimer = new Timer();
-            supportsAttributionRecheckTimer = new Timer();
-        }
-
-        flushTimer.schedule(
-                new TimerTask() {
-                    @Override
-                    public void run() {
-                        if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-                            flushAndWait(FlushReason.TIMER);
-                        }
-                    }
-                },
-                0,  // start immediately
-                FLUSH_PERIOD_IN_SECONDS * 1000);
-
-        supportsAttributionRecheckTimer.schedule(
-                new TimerTask() {
-                    @Override
-                    public void run() {
-                        Set<String> applicationIds = new HashSet<String>();
-                        synchronized (staticLock) {
-                            for (AccessTokenAppIdPair accessTokenAppId  : stateMap.keySet()) {
-                                applicationIds.add(accessTokenAppId.getApplicationId());
-                            }
-                        }
-                        for (String applicationId : applicationIds) {
-                            Utility.queryAppSettings(applicationId, true);
-                        }
-                    }
-                },
-                0,   // start immediately
-                APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS * 1000);
-    }
-
-    private void logEvent(String eventName, Double valueToSum, Bundle parameters, boolean isImplicitlyLogged) {
-
-        AppEvent event = new AppEvent(eventName, valueToSum, parameters, isImplicitlyLogged);
-        logEvent(context, event, accessTokenAppId);
-    }
-
-    private static void logEvent(Context context, AppEvent event, AccessTokenAppIdPair accessTokenAppId) {
-        if(shouldSuppressEvent(event)) {
-            return;
-        }
-
-        SessionEventsState state = getSessionEventsState(context, accessTokenAppId);
-        state.addEvent(event);
-
-        flushIfNecessary();
-    }
-
-    // This will also update the timestamp based on specified behavior.
-    private static boolean shouldSuppressEvent(AppEvent event) {
-        EventSuppression suppressionInfo = mapEventNameToSuppress.get(event.getName());
-        if (suppressionInfo == null) {
-            return false;
-        }
-
-        Date timestamp = mapEventsToSuppressionTime.get(event.getName());
-        boolean suppressed;
-        if (timestamp == null) {
-            suppressed = false;
-        } else {
-            long delta = new Date().getTime() - timestamp.getTime();
-            suppressed = delta < (suppressionInfo.getTimeoutPeriod() * 1000);
-        }
-
-        // Update the time if we're not suppressed, OR if we are suppressed but the behavior is to reset even on
-        // suppressed events.
-        if (!suppressed ||
-                suppressionInfo.getBehavior() == SuppressionTimeoutBehavior.RESET_TIMEOUT_WHEN_LOG_ATTEMPTED) {
-            mapEventsToSuppressionTime.put(event.getName(), new Date());
-        }
-
-        return suppressed;
-    }
-
-    static void eagerFlush() {
-        if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-            flush(FlushReason.EAGER_FLUSHING_EVENT);
-        }
-    }
-
-    private static void flushIfNecessary() {
-        synchronized (staticLock) {
-            if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-                if (getAccumulatedEventCount() > NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
-                    flush(FlushReason.EVENT_THRESHOLD);
-                }
-            }
-        }
-    }
-
-    private static int getAccumulatedEventCount() {
-        synchronized (staticLock) {
-
-            int result = 0;
-            for (SessionEventsState state : stateMap.values()) {
-                result += state.getAccumulatedEventCount();
-            }
-            return result;
-        }
-    }
-
-    // Creates a new SessionEventsState if not already in the map.
-    private static SessionEventsState getSessionEventsState(Context context, AccessTokenAppIdPair accessTokenAppId) {
-        synchronized (staticLock) {
-            SessionEventsState state = stateMap.get(accessTokenAppId);
-            if (state == null) {
-                // Retrieve attributionId, but we will only send it if attribution is supported for the app.
-                String attributionId = Settings.getAttributionId(context.getContentResolver());
-
-                state = new SessionEventsState(attributionId, context.getPackageName(), hashedDeviceAndAppId);
-                stateMap.put(accessTokenAppId, state);
-            }
-            return state;
-        }
-    }
-
-    private static SessionEventsState getSessionEventsState(AccessTokenAppIdPair accessTokenAppId) {
-        synchronized (staticLock) {
-            return stateMap.get(accessTokenAppId);
-        }
-    }
-
-    private static void flush(final FlushReason reason) {
-
-        Settings.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                flushAndWait(reason);
-            }
-        });
-    }
-
-    private static void flushAndWait(final FlushReason reason) {
-
-        Set<AccessTokenAppIdPair> keysToFlush;
-        synchronized (staticLock) {
-            if (requestInFlight) {
-                return;
-            }
-            requestInFlight = true;
-            keysToFlush = new HashSet<AccessTokenAppIdPair>(stateMap.keySet());
-        }
-
-        accumulatePersistedEvents();
-
-        FlushStatistics flushResults = null;
-        try {
-            flushResults = buildAndExecuteRequests(reason, keysToFlush);
-        } catch (Exception e) {
-            Log.d(TAG, "Caught unexpected exception while flushing: " + e.toString());
-        }
-
-        synchronized (staticLock) {
-            requestInFlight = false;
-        }
-
-        if (flushResults != null) {
-            final Intent intent = new Intent(ACTION_APP_EVENTS_FLUSHED);
-            intent.putExtra(APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, flushResults.numEvents);
-            intent.putExtra(APP_EVENTS_EXTRA_FLUSH_RESULT, flushResults.result);
-            LocalBroadcastManager.getInstance(applicationContext).sendBroadcast(intent);
-        }
-    }
-
-    private static FlushStatistics buildAndExecuteRequests(FlushReason reason, Set<AccessTokenAppIdPair> keysToFlush) {
-        FlushStatistics flushResults = new FlushStatistics();
-
-        boolean limitEventUsage = Settings.getLimitEventAndDataUsage(applicationContext);
-
-        List<Request> requestsToExecute = new ArrayList<Request>();
-        for (AccessTokenAppIdPair accessTokenAppId : keysToFlush) {
-            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppId);
-            if (sessionEventsState == null) {
-                continue;
-            }
-
-            Request request = buildRequestForSession(accessTokenAppId, sessionEventsState, limitEventUsage,
-                    flushResults);
-            if (request != null) {
-                requestsToExecute.add(request);
-            }
-        }
-
-        if (requestsToExecute.size() > 0) {
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
-                    flushResults.numEvents,
-                    reason.toString());
-
-            for (Request request : requestsToExecute) {
-                // Execute the request synchronously. Callbacks will take care of handling errors and updating
-                // our final overall result.
-                request.executeAndWait();
-            }
-            return flushResults;
-        }
-
-        return null;
-    }
-
-    private static class FlushStatistics {
-        public int numEvents = 0;
-        public FlushResult result = FlushResult.SUCCESS;
-    }
-
-    private static Request buildRequestForSession(final AccessTokenAppIdPair accessTokenAppId,
-            final SessionEventsState sessionEventsState, final boolean limitEventUsage,
-            final FlushStatistics flushState) {
-        String applicationId = accessTokenAppId.getApplicationId();
-
-        Utility.FetchedAppSettings fetchedAppSettings = Utility.queryAppSettings(applicationId, false);
-
-        final Request postRequest = Request.newPostRequest(
-                null,
-                String.format("%s/activities", applicationId),
-                null,
-                null);
-
-        Bundle requestParameters = postRequest.getParameters();
-        if (requestParameters == null) {
-            requestParameters = new Bundle();
-        }
-        requestParameters.putString("access_token", accessTokenAppId.getAccessToken());
-        postRequest.setParameters(requestParameters);
-
-        int numEvents = sessionEventsState.populateRequest(postRequest, fetchedAppSettings.supportsImplicitLogging(),
-                fetchedAppSettings.supportsAttribution(), limitEventUsage);
-        if (numEvents == 0) {
-            return null;
-        }
-
-        flushState.numEvents += numEvents;
-
-        postRequest.setCallback(new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                handleResponse(accessTokenAppId, postRequest, response, sessionEventsState, flushState);
-            }
-        });
-
-        return postRequest;
-    }
-
-    private static void handleResponse(AccessTokenAppIdPair accessTokenAppId, Request request, Response response,
-            SessionEventsState sessionEventsState, FlushStatistics flushState) {
-        FacebookRequestError error = response.getError();
-        String resultDescription = "Success";
-
-        FlushResult flushResult = FlushResult.SUCCESS;
-
-        if (error != null) {
-            final int NO_CONNECTIVITY_ERROR_CODE = -1;
-            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
-                resultDescription = "Failed: No Connectivity";
-                flushResult = FlushResult.NO_CONNECTIVITY;
-            } else {
-                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
-                        response.toString(),
-                        error.toString());
-                flushResult = FlushResult.SERVER_ERROR;
-            }
-        }
-
-        if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
-            String eventsJsonString = (String) request.getTag();
-            String prettyPrintedEvents;
-
-            try {
-                JSONArray jsonArray = new JSONArray(eventsJsonString);
-                prettyPrintedEvents = jsonArray.toString(2);
-            } catch (JSONException exc) {
-                prettyPrintedEvents = "<Can't encode events for debug logging>";
-            }
-
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
-                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
-                    request.getGraphObject().toString(),
-                    resultDescription,
-                    prettyPrintedEvents);
-        }
-
-        sessionEventsState.clearInFlightAndStats(error != null);
-
-        if (flushResult == FlushResult.NO_CONNECTIVITY) {
-            // We may call this for multiple requests in a batch, which is slightly inefficient since in principle
-            // we could call it once for all failed requests, but the impact is likely to be minimal.
-            // We don't call this for other server errors, because if an event failed because it was malformed, etc.,
-            // continually retrying it will cause subsequent events to not be logged either.
-            PersistedEvents.persistEvents(applicationContext, accessTokenAppId, sessionEventsState);
-        }
-
-        if (flushResult != FlushResult.SUCCESS) {
-            // We assume that connectivity issues are more significant to report than server issues.
-            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
-                flushState.result = flushResult;
-            }
-        }
-    }
-
-    private static int accumulatePersistedEvents() {
-        PersistedEvents persistedEvents = PersistedEvents.readAndClearStore(applicationContext);
-
-        int result = 0;
-        for(AccessTokenAppIdPair accessTokenAppId : persistedEvents.keySet()) {
-            SessionEventsState sessionEventsState = getSessionEventsState(applicationContext, accessTokenAppId);
-
-            List<AppEvent> events = persistedEvents.getEvents(accessTokenAppId);
-            sessionEventsState.accumulatePersistedEvents(events);
-            result += events.size();
-        }
-
-        return result;
-    }
-
-    /**
-     * Invoke this method, rather than throwing an Exception, for situations where user/server input might reasonably
-     * cause this to occur, and thus don't want an exception thrown at production time, but do want logging
-     * notification.
-     */
-    private static void notifyDeveloperError(String message) {
-        Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "AppEvents", message);
-    }
-
-
-    //
-    // Deprecated Stuff
-    //
-
-
-    static class SessionEventsState {
-        private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
-        private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
-        private int numSkippedEventsDueToFullBuffer;
-        private String attributionId;
-        private String packageName;
-        private String hashedDeviceAndAppId;
-
-        public static final String EVENT_COUNT_KEY = "event_count";
-        public static final String ENCODED_EVENTS_KEY = "encoded_events";
-        public static final String NUM_SKIPPED_KEY = "num_skipped";
-
-        private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;
-
-        public SessionEventsState(String attributionId, String packageName, String hashedDeviceAndAppId) {
-            this.attributionId = attributionId;
-            this.packageName = packageName;
-            this.hashedDeviceAndAppId = hashedDeviceAndAppId;
-        }
-
-        // Synchronize here and in other methods on this class, because could be coming in from different
-        // AppEventsLoggers on different threads pointing at the same session.
-        public synchronized void addEvent(AppEvent event) {
-            if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
-                numSkippedEventsDueToFullBuffer++;
-            } else {
-                accumulatedEvents.add(event);
-            }
-        }
-
-        public synchronized int getAccumulatedEventCount() {
-            return accumulatedEvents.size();
-        }
-
-        public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
-            if (moveToAccumulated) {
-                accumulatedEvents.addAll(inFlightEvents);
-            }
-            inFlightEvents.clear();
-            numSkippedEventsDueToFullBuffer = 0;
-        }
-
-        public int populateRequest(Request request, boolean includeImplicitEvents,
-                boolean includeAttribution, boolean limitEventUsage) {
-
-            int numSkipped;
-            JSONArray jsonArray;
-            synchronized (this) {
-                numSkipped = numSkippedEventsDueToFullBuffer;
-
-                // move all accumulated events to inFlight.
-                inFlightEvents.addAll(accumulatedEvents);
-                accumulatedEvents.clear();
-
-                jsonArray = new JSONArray();
-                for (AppEvent event : inFlightEvents) {
-                    if (includeImplicitEvents || !event.getIsImplicit()) {
-                        jsonArray.put(event.getJSONObject());
-                    }
-                }
-
-                if (jsonArray.length() == 0) {
-                    return 0;
-                }
-            }
-
-            populateRequest(request, numSkipped, jsonArray, includeAttribution, limitEventUsage);
-            return jsonArray.length();
-        }
-
-        public synchronized List<AppEvent> getEventsToPersist() {
-            // We will only persist accumulated events, not ones currently in-flight. This means if an in-flight
-            // request fails, those requests will not be persisted and thus might be lost if the process terminates
-            // while the flush is in progress.
-            List<AppEvent> result = accumulatedEvents;
-            accumulatedEvents = new ArrayList<AppEvent>();
-            return result;
-        }
-
-        public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
-            // We won't skip events due to a full buffer, since we already accumulated them once and persisted
-            // them. But they will count against the buffer size when further events are accumulated.
-            accumulatedEvents.addAll(events);
-        }
-
-        private void populateRequest(Request request, int numSkipped, JSONArray events, boolean includeAttribution,
-                boolean limitEventUsage) {
-            GraphObject publishParams = GraphObject.Factory.create();
-            publishParams.setProperty("event", "CUSTOM_APP_EVENTS");
-
-            if (numSkippedEventsDueToFullBuffer > 0) {
-                publishParams.setProperty("num_skipped_events", numSkipped);
-            }
-
-            if (includeAttribution) {
-                Utility.setAppEventAttributionParameters(publishParams, attributionId,
-                        hashedDeviceAndAppId, limitEventUsage);
-            }
-
-            publishParams.setProperty("application_package_name", packageName);
-
-            request.setGraphObject(publishParams);
-
-            Bundle requestParameters = request.getParameters();
-            if (requestParameters == null) {
-                requestParameters = new Bundle();
-            }
-
-            String jsonString = events.toString();
-            if (jsonString != null) {
-                requestParameters.putByteArray("custom_events_file", getStringAsByteArray(jsonString));
-                request.setTag(jsonString);
-            }
-            request.setParameters(requestParameters);
-        }
-
-        private byte[] getStringAsByteArray(String jsonString) {
-            byte[] jsonUtf8 = null;
-            try {
-                jsonUtf8 = jsonString.getBytes("UTF-8");
-            } catch (UnsupportedEncodingException e) {
-                // shouldn't happen, but just in case:
-                Utility.logd("Encoding exception: ", e);
-            }
-            return jsonUtf8;
-        }
-    }
-
-    static class AppEvent implements Serializable {
-        private static final long serialVersionUID = 1L;
-
-        private JSONObject jsonObject;
-        private boolean isImplicit;
-        private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
-        private String name;
-
-        public AppEvent(String eventName, Double valueToSum, Bundle parameters, boolean isImplicitlyLogged) {
-
-            validateIdentifier(eventName);
-
-            this.name = eventName;
-
-            isImplicit = isImplicitlyLogged;
-            jsonObject = new JSONObject();
-
-            try {
-
-                jsonObject.put("_eventName", eventName);
-                jsonObject.put("_logTime", System.currentTimeMillis() / 1000);
-
-                if (valueToSum != null) {
-                    jsonObject.put("_valueToSum", valueToSum.doubleValue());
-                }
-
-                if (isImplicit) {
-                    jsonObject.put("_implicitlyLogged", "1");
-                }
-
-                String appVersion = Settings.getAppVersion();
-                if (appVersion != null) {
-                    jsonObject.put("_appVersion", appVersion);
-                }
-
-                if (parameters != null) {
-                    for (String key : parameters.keySet()) {
-
-                        validateIdentifier(key);
-
-                        Object value = parameters.get(key);
-                        if (!(value instanceof String) && !(value instanceof Number)) {
-                            throw new FacebookException(
-                                    String.format("Parameter value '%s' for key '%s' should be a string or a numeric type.",
-                                            value, key));
-                        }
-
-                        jsonObject.put(key, value.toString());
-                    }
-                }
-
-                if (!isImplicit) {
-                    Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
-                            "Created app event '%s'", jsonObject.toString());
-                }
-            } catch (JSONException jsonException) {
-
-                // If any of the above failed, just consider this an illegal event.
-                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
-                        "JSON encoding for app event failed: '%s'", jsonException.toString());
-                jsonObject = null;
-
-            }
-        }
-
-        public String getName() {
-            return name;
-        }
-
-        private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
-            jsonObject = new JSONObject(jsonString);
-            this.isImplicit = isImplicit;
-        }
-
-        public boolean getIsImplicit() { return isImplicit; }
-
-        public JSONObject getJSONObject() {
-            return jsonObject;
-        }
-
-        // throw exception if not valid.
-        private void validateIdentifier(String identifier) {
-
-            // Identifier should be 40 chars or less, and only have 0-9A-Za-z, underscore, hyphen, and space (but no
-            // hyphen or space in the first position).
-            final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";
-
-            final int MAX_IDENTIFIER_LENGTH = 40;
-            if (identifier == null || identifier.length() == 0 || identifier.length() > MAX_IDENTIFIER_LENGTH) {
-                if (identifier == null) {
-                    identifier = "<None Provided>";
-                }
-                throw new FacebookException(
-                    String.format("Identifier '%s' must be less than %d characters", identifier, MAX_IDENTIFIER_LENGTH));
-            }
-
-            boolean alreadyValidated = false;
-            synchronized (validatedIdentifiers) {
-                alreadyValidated = validatedIdentifiers.contains(identifier);
-            }
-
-            if (!alreadyValidated) {
-                if (identifier.matches(regex)) {
-                    synchronized (validatedIdentifiers) {
-                        validatedIdentifiers.add(identifier);
-                    }
-                } else {
-                    throw new FacebookException(
-                            String.format("Skipping event named '%s' due to illegal name - must be under 40 chars " +
-                                          "and alphanumeric, _, - or space, and not start with a space or hyphen.",
-                                          identifier));
-                }
-            }
-
-        }
-
-        private static class SerializationProxyV1 implements Serializable {
-            private static final long serialVersionUID = -2488473066578201069L;
-            private final String jsonString;
-            private final boolean isImplicit;
-
-            private SerializationProxyV1(String jsonString, boolean isImplicit) {
-                this.jsonString = jsonString;
-                this.isImplicit = isImplicit;
-            }
-
-            private Object readResolve() throws JSONException {
-                return new AppEvent(jsonString, isImplicit);
-            }
-        }
-
-        private Object writeReplace() {
-            return new SerializationProxyV1(jsonObject.toString(), isImplicit);
-        }
-
-        @Override
-        public String toString() {
-            return String.format("\"%s\", implicit: %b, json: %s", jsonObject.optString("_eventName"),
-                    isImplicit, jsonObject.toString());
-        }
-    }
-
-    // Read/write operations are thread-safe/atomic across all instances of PersistedEvents, but modifications
-    // to any individual instance are not thread-safe.
-    static class PersistedEvents {
-        static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";
-
-        private static Object staticLock = new Object();
-
-        private Context context;
-        private HashMap<AccessTokenAppIdPair, List<AppEvent>> persistedEvents =
-                new HashMap<AccessTokenAppIdPair, List<AppEvent>>();
-
-        private PersistedEvents(Context context) {
-            this.context = context;
-        }
-
-        public static PersistedEvents readAndClearStore(Context context) {
-            synchronized (staticLock) {
-                PersistedEvents persistedEvents = new PersistedEvents(context);
-
-                persistedEvents.readAndClearStore();
-
-                return persistedEvents;
-            }
-        }
-        public static void persistEvents(Context context, AccessTokenAppIdPair accessTokenAppId,
-                SessionEventsState eventsToPersist) {
-            Map<AccessTokenAppIdPair, SessionEventsState> map = new HashMap<AccessTokenAppIdPair, SessionEventsState>();
-            map.put(accessTokenAppId, eventsToPersist);
-            persistEvents(context, map);
-        }
-
-        public static void persistEvents(Context context,
-                Map<AccessTokenAppIdPair, SessionEventsState> eventsToPersist) {
-            synchronized (staticLock) {
-                // Note that we don't track which instance of AppEventsLogger added a particular event to
-                // SessionEventsState; when a particular Context is being destroyed, we'll persist all accumulated
-                // events. More sophisticated tracking could be done to try to reduce unnecessary persisting of events,
-                // but the overall number of events is not expected to be large.
-                PersistedEvents persistedEvents = readAndClearStore(context);
-
-                for (Map.Entry<AccessTokenAppIdPair, SessionEventsState> entry : eventsToPersist.entrySet()) {
-                    List<AppEvent> events = entry.getValue().getEventsToPersist();
-                    if (events.size() == 0) {
-                        continue;
-                    }
-
-                    persistedEvents.addEvents(entry.getKey(), events);
-                }
-
-                persistedEvents.write();
-            }
-        }
-
-        public Set<AccessTokenAppIdPair> keySet() {
-            return persistedEvents.keySet();
-        }
-
-        public List<AppEvent> getEvents(AccessTokenAppIdPair accessTokenAppId) {
-            return persistedEvents.get(accessTokenAppId);
-        }
-
-        private void write() {
-            ObjectOutputStream oos = null;
-            try {
-                oos = new ObjectOutputStream(
-                        new BufferedOutputStream(context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
-                oos.writeObject(persistedEvents);
-            } catch (Exception e) {
-                Log.d(TAG, "Got unexpected exception: " + e.toString());
-            } finally {
-                Utility.closeQuietly(oos);
-            }
-        }
-
-        private void readAndClearStore() {
-            ObjectInputStream ois = null;
-            try {
-                ois = new ObjectInputStream(
-                        new BufferedInputStream(context.openFileInput(PERSISTED_EVENTS_FILENAME)));
-
-                @SuppressWarnings("unchecked")
-                HashMap<AccessTokenAppIdPair, List<AppEvent>> obj =
-                        (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();
-
-                // Note: We delete the store before we store the events; this means we'd prefer to lose some
-                // events in the case of exception rather than potentially log them twice.
-                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
-                persistedEvents = obj;
-            } catch (FileNotFoundException e) {
-                // Expected if we never persisted any events.
-            } catch (Exception e) {
-                Log.d(TAG, "Got unexpected exception: " + e.toString());
-            } finally {
-                Utility.closeQuietly(ois);
-            }
-        }
-
-        public void addEvents(AccessTokenAppIdPair accessTokenAppId, List<AppEvent> eventsToPersist) {
-            if (!persistedEvents.containsKey(accessTokenAppId)) {
-                persistedEvents.put(accessTokenAppId, new ArrayList<AppEvent>());
-            }
-            persistedEvents.get(accessTokenAppId).addAll(eventsToPersist);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
deleted file mode 100644
index cbd308add..000000000
--- a/facebook/src/com/facebook/AuthorizationClient.java
+++ /dev/null
@@ -1,1173 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.webkit.CookieSyncManager;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.ServerProtocol;
-import com.facebook.internal.Utility;
-import com.facebook.model.GraphMultiResult;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.model.GraphUser;
-import com.facebook.widget.WebDialog;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.Serializable;
-import java.util.*;
-
-class AuthorizationClient implements Serializable {
-    private static final long serialVersionUID = 1L;
-    private static final String TAG = "Facebook-AuthorizationClient";
-    private static final String WEB_VIEW_AUTH_HANDLER_STORE =
-            "com.facebook.AuthorizationClient.WebViewAuthHandler.TOKEN_STORE_KEY";
-    private static final String WEB_VIEW_AUTH_HANDLER_TOKEN_KEY = "TOKEN";
-
-    // Constants for logging login-related data. Some of these are only used by Session, but grouped here for
-    // maintainability.
-    private static final String EVENT_NAME_LOGIN_METHOD_START = "fb_mobile_login_method_start";
-    private static final String EVENT_NAME_LOGIN_METHOD_COMPLETE = "fb_mobile_login_method_complete";
-    private static final String EVENT_PARAM_METHOD_RESULT_SKIPPED = "skipped";
-    static final String EVENT_NAME_LOGIN_START = "fb_mobile_login_start";
-    static final String EVENT_NAME_LOGIN_COMPLETE = "fb_mobile_login_complete";
-    // Note: to ensure stability of column mappings across the four different event types, we prepend a column
-    // index to each name, and we log all columns with all events, even if they are empty.
-    static final String EVENT_PARAM_AUTH_LOGGER_ID = "0_auth_logger_id";
-    static final String EVENT_PARAM_TIMESTAMP = "1_timestamp_ms";
-    static final String EVENT_PARAM_LOGIN_RESULT = "2_result";
-    static final String EVENT_PARAM_METHOD = "3_method";
-    static final String EVENT_PARAM_ERROR_CODE = "4_error_code";
-    static final String EVENT_PARAM_ERROR_MESSAGE = "5_error_message";
-    static final String EVENT_PARAM_EXTRAS = "6_extras";
-    static final String EVENT_EXTRAS_TRY_LOGIN_ACTIVITY = "try_login_activity";
-    static final String EVENT_EXTRAS_TRY_LEGACY = "try_legacy";
-    static final String EVENT_EXTRAS_LOGIN_BEHAVIOR = "login_behavior";
-    static final String EVENT_EXTRAS_REQUEST_CODE = "request_code";
-    static final String EVENT_EXTRAS_IS_LEGACY = "is_legacy";
-    static final String EVENT_EXTRAS_PERMISSIONS = "permissions";
-    static final String EVENT_EXTRAS_DEFAULT_AUDIENCE = "default_audience";
-    static final String EVENT_EXTRAS_MISSING_INTERNET_PERMISSION = "no_internet_permission";
-    static final String EVENT_EXTRAS_NOT_TRIED = "not_tried";
-    static final String EVENT_EXTRAS_NEW_PERMISSIONS = "new_permissions";
-    static final String EVENT_EXTRAS_SERVICE_DISABLED = "service_disabled";
-    static final String EVENT_EXTRAS_APP_CALL_ID = "call_id";
-    static final String EVENT_EXTRAS_PROTOCOL_VERSION = "protocol_version";
-    static final String EVENT_EXTRAS_WRITE_PRIVACY = "write_privacy";
-
-    List<AuthHandler> handlersToTry;
-    AuthHandler currentHandler;
-    transient Context context;
-    transient StartActivityDelegate startActivityDelegate;
-    transient OnCompletedListener onCompletedListener;
-    transient BackgroundProcessingListener backgroundProcessingListener;
-    transient boolean checkedInternetPermission;
-    AuthorizationRequest pendingRequest;
-    Map<String, String> loggingExtras;
-    private transient AppEventsLogger appEventsLogger;
-
-    interface OnCompletedListener {
-        void onCompleted(Result result);
-    }
-
-    interface BackgroundProcessingListener {
-        void onBackgroundProcessingStarted();
-
-        void onBackgroundProcessingStopped();
-    }
-
-    interface StartActivityDelegate {
-        public void startActivityForResult(Intent intent, int requestCode);
-
-        public Activity getActivityContext();
-    }
-
-    void setContext(final Context context) {
-        this.context = context;
-        // We rely on individual requests to tell us how to start an activity.
-        startActivityDelegate = null;
-    }
-
-    void setContext(final Activity activity) {
-        this.context = activity;
-
-        // If we are used in the context of an activity, we will always use that activity to
-        // call startActivityForResult.
-        startActivityDelegate = new StartActivityDelegate() {
-            @Override
-            public void startActivityForResult(Intent intent, int requestCode) {
-                activity.startActivityForResult(intent, requestCode);
-            }
-
-            @Override
-            public Activity getActivityContext() {
-                return activity;
-            }
-        };
-    }
-
-    void startOrContinueAuth(AuthorizationRequest request) {
-        if (getInProgress()) {
-            continueAuth();
-        } else {
-            authorize(request);
-        }
-    }
-
-    void authorize(AuthorizationRequest request) {
-        if (request == null) {
-            return;
-        }
-
-        if (pendingRequest != null) {
-            throw new FacebookException("Attempted to authorize while a request is pending.");
-        }
-
-        if (request.needsNewTokenValidation() && !checkInternetPermission()) {
-            // We're going to need INTERNET permission later and don't have it, so fail early.
-            return;
-        }
-        pendingRequest = request;
-        handlersToTry = getHandlerTypes(request);
-        tryNextHandler();
-    }
-
-    void continueAuth() {
-        if (pendingRequest == null || currentHandler == null) {
-            throw new FacebookException("Attempted to continue authorization without a pending request.");
-        }
-
-        if (currentHandler.needsRestart()) {
-            currentHandler.cancel();
-            tryCurrentHandler();
-        }
-    }
-
-    boolean getInProgress() {
-        return pendingRequest != null && currentHandler != null;
-    }
-
-    void cancelCurrentHandler() {
-        if (currentHandler != null) {
-            currentHandler.cancel();
-        }
-    }
-
-    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == pendingRequest.getRequestCode()) {
-            return currentHandler.onActivityResult(requestCode, resultCode, data);
-        }
-        return false;
-    }
-
-    private List<AuthHandler> getHandlerTypes(AuthorizationRequest request) {
-        ArrayList<AuthHandler> handlers = new ArrayList<AuthHandler>();
-
-        final SessionLoginBehavior behavior = request.getLoginBehavior();
-        if (behavior.allowsKatanaAuth()) {
-            if (!request.isLegacy()) {
-                handlers.add(new GetTokenAuthHandler());
-                handlers.add(new KatanaLoginDialogAuthHandler());
-            }
-            handlers.add(new KatanaProxyAuthHandler());
-        }
-
-        if (behavior.allowsWebViewAuth()) {
-            handlers.add(new WebViewAuthHandler());
-        }
-
-        return handlers;
-    }
-
-    boolean checkInternetPermission() {
-        if (checkedInternetPermission) {
-            return true;
-        }
-
-        int permissionCheck = checkPermission(Manifest.permission.INTERNET);
-        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
-            String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
-            String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
-            complete(Result.createErrorResult(pendingRequest, errorType, errorDescription));
-
-            return false;
-        }
-
-        checkedInternetPermission = true;
-        return true;
-    }
-
-    void tryNextHandler() {
-        if (currentHandler != null) {
-            logAuthorizationMethodComplete(currentHandler.getNameForLogging(), EVENT_PARAM_METHOD_RESULT_SKIPPED,
-                    null, null, currentHandler.methodLoggingExtras);
-        }
-
-        while (handlersToTry != null && !handlersToTry.isEmpty()) {
-            currentHandler = handlersToTry.remove(0);
-
-            boolean started = tryCurrentHandler();
-
-            if (started) {
-                return;
-            }
-        }
-
-        if (pendingRequest != null) {
-            // We went through all handlers without successfully attempting an auth.
-            completeWithFailure();
-        }
-    }
-
-    private void completeWithFailure() {
-        complete(Result.createErrorResult(pendingRequest, "Login attempt failed.", null));
-    }
-
-    private void addLoggingExtra(String key, String value, boolean accumulate) {
-        if (loggingExtras == null) {
-            loggingExtras = new HashMap<String, String>();
-        }
-        if (loggingExtras.containsKey(key) && accumulate) {
-            value = loggingExtras.get(key) + "," + value;
-        }
-        loggingExtras.put(key, value);
-    }
-
-    boolean tryCurrentHandler() {
-        if (currentHandler.needsInternetPermission() && !checkInternetPermission()) {
-            addLoggingExtra(EVENT_EXTRAS_MISSING_INTERNET_PERMISSION, AppEventsConstants.EVENT_PARAM_VALUE_YES,
-                    false);
-            return false;
-        }
-
-        boolean tried = currentHandler.tryAuthorize(pendingRequest);
-        if (tried) {
-            logAuthorizationMethodStart(currentHandler.getNameForLogging());
-        } else {
-            // We didn't try it, so we don't get any other completion notification -- log that we skipped it.
-            addLoggingExtra(EVENT_EXTRAS_NOT_TRIED, currentHandler.getNameForLogging(), true);
-        }
-
-        return tried;
-    }
-
-    void completeAndValidate(Result outcome) {
-        // Do we need to validate a successful result (as in the case of a reauth)?
-        if (outcome.token != null && pendingRequest.needsNewTokenValidation()) {
-            validateSameFbidAndFinish(outcome);
-        } else {
-            // We're done, just notify the listener.
-            complete(outcome);
-        }
-    }
-
-    void complete(Result outcome) {
-        // This might be null if, for some reason, none of the handlers were successfully tried (in which case
-        // we already logged that).
-        if (currentHandler != null) {
-            logAuthorizationMethodComplete(currentHandler.getNameForLogging(), outcome,
-                    currentHandler.methodLoggingExtras);
-        }
-
-        if (loggingExtras != null) {
-            // Pass this back to the caller for logging at the aggregate level.
-            outcome.loggingExtras = loggingExtras;
-        }
-
-        handlersToTry = null;
-        currentHandler = null;
-        pendingRequest = null;
-        loggingExtras = null;
-
-        notifyOnCompleteListener(outcome);
-    }
-
-    OnCompletedListener getOnCompletedListener() {
-        return onCompletedListener;
-    }
-
-    void setOnCompletedListener(OnCompletedListener onCompletedListener) {
-        this.onCompletedListener = onCompletedListener;
-    }
-
-    BackgroundProcessingListener getBackgroundProcessingListener() {
-        return backgroundProcessingListener;
-    }
-
-    void setBackgroundProcessingListener(BackgroundProcessingListener backgroundProcessingListener) {
-        this.backgroundProcessingListener = backgroundProcessingListener;
-    }
-
-    StartActivityDelegate getStartActivityDelegate() {
-        if (startActivityDelegate != null) {
-            return startActivityDelegate;
-        } else if (pendingRequest != null) {
-            // Wrap the request's delegate in our own.
-            return new StartActivityDelegate() {
-                @Override
-                public void startActivityForResult(Intent intent, int requestCode) {
-                    pendingRequest.getStartActivityDelegate().startActivityForResult(intent, requestCode);
-                }
-
-                @Override
-                public Activity getActivityContext() {
-                    return pendingRequest.getStartActivityDelegate().getActivityContext();
-                }
-            };
-        }
-        return null;
-    }
-
-    int checkPermission(String permission) {
-        return context.checkCallingOrSelfPermission(permission);
-    }
-
-    void validateSameFbidAndFinish(Result pendingResult) {
-        if (pendingResult.token == null) {
-            throw new FacebookException("Can't validate without a token");
-        }
-
-        RequestBatch batch = createReauthValidationBatch(pendingResult);
-
-        notifyBackgroundProcessingStart();
-
-        batch.executeAsync();
-    }
-
-    RequestBatch createReauthValidationBatch(final Result pendingResult) {
-        // We need to ensure that the token we got represents the same fbid as the old one. We issue
-        // a "me" request using the current token, a "me" request using the new token, and a "me/permissions"
-        // request using the current token to get the permissions of the user.
-
-        final ArrayList<String> fbids = new ArrayList<String>();
-        final ArrayList<String> tokenPermissions = new ArrayList<String>();
-        final String newToken = pendingResult.token.getToken();
-
-        Request.Callback meCallback = new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                try {
-                    GraphUser user = response.getGraphObjectAs(GraphUser.class);
-                    if (user != null) {
-                        fbids.add(user.getId());
-                    }
-                } catch (Exception ex) {
-                }
-            }
-        };
-
-        String validateSameFbidAsToken = pendingRequest.getPreviousAccessToken();
-        Request requestCurrentTokenMe = createGetProfileIdRequest(validateSameFbidAsToken);
-        requestCurrentTokenMe.setCallback(meCallback);
-
-        Request requestNewTokenMe = createGetProfileIdRequest(newToken);
-        requestNewTokenMe.setCallback(meCallback);
-
-        Request requestCurrentTokenPermissions = createGetPermissionsRequest(validateSameFbidAsToken);
-        requestCurrentTokenPermissions.setCallback(new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                try {
-                    GraphMultiResult result = response.getGraphObjectAs(GraphMultiResult.class);
-                    if (result != null) {
-                        GraphObjectList<GraphObject> data = result.getData();
-                        if (data != null && data.size() == 1) {
-                            GraphObject permissions = data.get(0);
-
-                            // The keys are the permission names.
-                            tokenPermissions.addAll(permissions.asMap().keySet());
-                        }
-                    }
-                } catch (Exception ex) {
-                }
-            }
-        });
-
-        RequestBatch batch = new RequestBatch(requestCurrentTokenMe, requestNewTokenMe,
-                requestCurrentTokenPermissions);
-        batch.setBatchApplicationId(pendingRequest.getApplicationId());
-        batch.addCallback(new RequestBatch.Callback() {
-            @Override
-            public void onBatchCompleted(RequestBatch batch) {
-                try {
-                    Result result = null;
-                    if (fbids.size() == 2 && fbids.get(0) != null && fbids.get(1) != null &&
-                            fbids.get(0).equals(fbids.get(1))) {
-                        // Modify the token to have the right permission set.
-                        AccessToken tokenWithPermissions = AccessToken
-                                .createFromTokenWithRefreshedPermissions(pendingResult.token,
-                                        tokenPermissions);
-                        result = Result.createTokenResult(pendingRequest, tokenWithPermissions);
-                    } else {
-                        result = Result
-                                .createErrorResult(pendingRequest, "User logged in as different Facebook user.", null);
-                    }
-                    complete(result);
-                } catch (Exception ex) {
-                    complete(Result.createErrorResult(pendingRequest, "Caught exception", ex.getMessage()));
-                } finally {
-                    notifyBackgroundProcessingStop();
-                }
-            }
-        });
-
-        return batch;
-    }
-
-    Request createGetPermissionsRequest(String accessToken) {
-        Bundle parameters = new Bundle();
-        parameters.putString("fields", "id");
-        parameters.putString("access_token", accessToken);
-        return new Request(null, "me/permissions", parameters, HttpMethod.GET, null);
-    }
-
-    Request createGetProfileIdRequest(String accessToken) {
-        Bundle parameters = new Bundle();
-        parameters.putString("fields", "id");
-        parameters.putString("access_token", accessToken);
-        return new Request(null, "me", parameters, HttpMethod.GET, null);
-    }
-
-    private AppEventsLogger getAppEventsLogger() {
-        if (appEventsLogger == null || appEventsLogger.getApplicationId() != pendingRequest.getApplicationId()) {
-            appEventsLogger = AppEventsLogger.newLogger(context, pendingRequest.getApplicationId());
-        }
-        return appEventsLogger;
-    }
-
-    private void notifyOnCompleteListener(Result outcome) {
-        if (onCompletedListener != null) {
-            onCompletedListener.onCompleted(outcome);
-        }
-    }
-
-    private void notifyBackgroundProcessingStart() {
-        if (backgroundProcessingListener != null) {
-            backgroundProcessingListener.onBackgroundProcessingStarted();
-        }
-    }
-
-    private void notifyBackgroundProcessingStop() {
-        if (backgroundProcessingListener != null) {
-            backgroundProcessingListener.onBackgroundProcessingStopped();
-        }
-    }
-
-    private void logAuthorizationMethodStart(String method) {
-        Bundle bundle = newAuthorizationLoggingBundle(pendingRequest.getAuthId());
-        bundle.putLong(EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
-        bundle.putString(EVENT_PARAM_METHOD, method);
-
-        getAppEventsLogger().logSdkEvent(EVENT_NAME_LOGIN_METHOD_START, null, bundle);
-    }
-
-    private void logAuthorizationMethodComplete(String method, Result result, Map<String, String> loggingExtras) {
-        logAuthorizationMethodComplete(method, result.code.getLoggingValue(), result.errorMessage, result.errorCode,
-                loggingExtras);
-    }
-
-    private void logAuthorizationMethodComplete(String method, String result, String errorMessage, String errorCode,
-            Map<String, String> loggingExtras) {
-        Bundle bundle = null;
-        if (pendingRequest == null) {
-            // We don't expect this to happen, but if it does, log an event for diagnostic purposes.
-            bundle = newAuthorizationLoggingBundle("");
-            bundle.putString(EVENT_PARAM_LOGIN_RESULT, Result.Code.ERROR.getLoggingValue());
-            bundle.putString(EVENT_PARAM_ERROR_MESSAGE,
-                    "Unexpected call to logAuthorizationMethodComplete with null pendingRequest.");
-        } else {
-            bundle = newAuthorizationLoggingBundle(pendingRequest.getAuthId());
-            if (result != null) {
-                bundle.putString(EVENT_PARAM_LOGIN_RESULT, result);
-            }
-            if (errorMessage != null) {
-                bundle.putString(EVENT_PARAM_ERROR_MESSAGE, errorMessage);
-            }
-            if (errorCode != null) {
-                bundle.putString(EVENT_PARAM_ERROR_CODE, errorCode);
-            }
-            if (loggingExtras != null && !loggingExtras.isEmpty()) {
-                JSONObject jsonObject = new JSONObject(loggingExtras);
-                bundle.putString(EVENT_PARAM_EXTRAS, jsonObject.toString());
-            }
-        }
-        bundle.putString(EVENT_PARAM_METHOD, method);
-        bundle.putLong(EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
-
-        getAppEventsLogger().logSdkEvent(EVENT_NAME_LOGIN_METHOD_COMPLETE, null, bundle);
-    }
-
-    static Bundle newAuthorizationLoggingBundle(String authLoggerId) {
-        // We want to log all parameters for all events, to ensure stability of columns across different event types.
-        Bundle bundle = new Bundle();
-        bundle.putLong(EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
-        bundle.putString(EVENT_PARAM_AUTH_LOGGER_ID, authLoggerId);
-        bundle.putString(EVENT_PARAM_METHOD, "");
-        bundle.putString(EVENT_PARAM_LOGIN_RESULT, "");
-        bundle.putString(EVENT_PARAM_ERROR_MESSAGE, "");
-        bundle.putString(EVENT_PARAM_ERROR_CODE, "");
-        bundle.putString(EVENT_PARAM_EXTRAS, "");
-        return bundle;
-    }
-
-    abstract class AuthHandler implements Serializable {
-        private static final long serialVersionUID = 1L;
-
-        Map<String, String> methodLoggingExtras;
-
-        abstract boolean tryAuthorize(AuthorizationRequest request);
-        abstract String getNameForLogging();
-
-        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-            return false;
-        }
-
-        boolean needsRestart() {
-            return false;
-        }
-
-        boolean needsInternetPermission() {
-            return false;
-        }
-
-        void cancel() {
-        }
-
-        protected void addLoggingExtra(String key, Object value) {
-            if (methodLoggingExtras == null) {
-                methodLoggingExtras = new HashMap<String, String>();
-            }
-            methodLoggingExtras.put(key, value == null ? null : value.toString());
-        }
-    }
-
-    class WebViewAuthHandler extends AuthHandler {
-        private static final long serialVersionUID = 1L;
-        private transient WebDialog loginDialog;
-        private String applicationId;
-        private String e2e;
-
-        @Override
-        String getNameForLogging() {
-            return "web_view";
-        }
-
-        @Override
-        boolean needsRestart() {
-            // Because we are presenting WebView UI within the current context, we need to explicitly
-            // restart the process if the context goes away and is recreated.
-            return true;
-        }
-
-        @Override
-        boolean needsInternetPermission() {
-            return true;
-        }
-
-        @Override
-        void cancel() {
-            if (loginDialog != null) {
-                loginDialog.dismiss();
-                loginDialog = null;
-            }
-        }
-
-        @Override
-        boolean tryAuthorize(final AuthorizationRequest request) {
-            applicationId = request.getApplicationId();
-            Bundle parameters = new Bundle();
-            if (!Utility.isNullOrEmpty(request.getPermissions())) {
-                String scope = TextUtils.join(",", request.getPermissions());
-                parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
-                addLoggingExtra(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
-            }
-
-            String previousToken = request.getPreviousAccessToken();
-            if (!Utility.isNullOrEmpty(previousToken) && (previousToken.equals(loadCookieToken()))) {
-                parameters.putString(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, previousToken);
-                // Don't log the actual access token, just its presence or absence.
-                addLoggingExtra(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, AppEventsConstants.EVENT_PARAM_VALUE_YES);
-            } else {
-                // The call to clear cookies will create the first instance of CookieSyncManager if necessary
-                Utility.clearFacebookCookies(context);
-                addLoggingExtra(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, AppEventsConstants.EVENT_PARAM_VALUE_NO);
-            }
-
-            WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
-                @Override
-                public void onComplete(Bundle values, FacebookException error) {
-                    onWebDialogComplete(request, values, error);
-                }
-            };
-
-            e2e = getE2E();
-            addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);
-
-            WebDialog.Builder builder =
-                    new AuthDialogBuilder(getStartActivityDelegate().getActivityContext(), applicationId, parameters)
-                            .setE2E(e2e)
-                            .setOnCompleteListener(listener);
-            loginDialog = builder.build();
-            loginDialog.show();
-
-            return true;
-        }
-
-        void onWebDialogComplete(AuthorizationRequest request, Bundle values,
-                FacebookException error) {
-            Result outcome;
-            if (values != null) {
-                // Actual e2e we got from the dialog should be used for logging.
-                if (values.containsKey(ServerProtocol.DIALOG_PARAM_E2E)) {
-                    e2e = values.getString(ServerProtocol.DIALOG_PARAM_E2E);
-                }
-
-                AccessToken token = AccessToken
-                        .createFromWebBundle(request.getPermissions(), values, AccessTokenSource.WEB_VIEW);
-                outcome = Result.createTokenResult(pendingRequest, token);
-
-                // Ensure any cookies set by the dialog are saved
-                // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
-                // has never been created.
-                CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
-                syncManager.sync();
-                saveCookieToken(token.getToken());
-            } else {
-                if (error instanceof FacebookOperationCanceledException) {
-                    outcome = Result.createCancelResult(pendingRequest, "User canceled log in.");
-                } else {
-                    // Something went wrong, don't log a completion event since it will skew timing results.
-                    e2e = null;
-
-                    String errorCode = null;
-                    String errorMessage = error.getMessage();
-                    if (error instanceof FacebookServiceException) {
-                        FacebookRequestError requestError = ((FacebookServiceException)error).getRequestError();
-                        errorCode = String.format("%d", requestError.getErrorCode());
-                        errorMessage = requestError.toString();
-                    }
-                    outcome = Result.createErrorResult(pendingRequest, null, errorMessage, errorCode);
-                }
-            }
-
-            if (!Utility.isNullOrEmpty(e2e)) {
-                logWebLoginCompleted(applicationId, e2e);
-            }
-
-            completeAndValidate(outcome);
-        }
-
-        private void saveCookieToken(String token) {
-            Context context = getStartActivityDelegate().getActivityContext();
-            SharedPreferences sharedPreferences = context.getSharedPreferences(
-                    WEB_VIEW_AUTH_HANDLER_STORE,
-                    Context.MODE_PRIVATE);
-            SharedPreferences.Editor editor = sharedPreferences.edit();
-            editor.putString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, token);
-            if (!editor.commit()) {
-                Utility.logd(TAG, "Could not update saved web view auth handler token.");
-            }
-        }
-
-        private String loadCookieToken() {
-            Context context = getStartActivityDelegate().getActivityContext();
-            SharedPreferences sharedPreferences = context.getSharedPreferences(
-                    WEB_VIEW_AUTH_HANDLER_STORE,
-                    Context.MODE_PRIVATE);
-            return sharedPreferences.getString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, "");
-        }
-    }
-
-    class GetTokenAuthHandler extends AuthHandler {
-        private static final long serialVersionUID = 1L;
-        private transient GetTokenClient getTokenClient;
-
-        @Override
-        String getNameForLogging() {
-            return "get_token";
-        }
-
-        @Override
-        void cancel() {
-            if (getTokenClient != null) {
-                getTokenClient.cancel();
-                getTokenClient = null;
-            }
-        }
-
-        @Override
-        boolean needsRestart() {
-            // if the getTokenClient is null, that means an orientation change has occurred, and we need
-            // to recreate the GetTokenClient, so return true to indicate we need a restart
-            return getTokenClient == null;
-        }
-
-        boolean tryAuthorize(final AuthorizationRequest request) {
-            getTokenClient = new GetTokenClient(context, request.getApplicationId());
-            if (!getTokenClient.start()) {
-                return false;
-            }
-
-            notifyBackgroundProcessingStart();
-
-            GetTokenClient.CompletedListener callback = new GetTokenClient.CompletedListener() {
-                @Override
-                public void completed(Bundle result) {
-                    getTokenCompleted(request, result);
-                }
-            };
-
-            getTokenClient.setCompletedListener(callback);
-            return true;
-        }
-
-        void getTokenCompleted(AuthorizationRequest request, Bundle result) {
-            getTokenClient = null;
-
-            notifyBackgroundProcessingStop();
-
-            if (result != null) {
-                ArrayList<String> currentPermissions = result.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
-                List<String> permissions = request.getPermissions();
-                if ((currentPermissions != null) &&
-                        ((permissions == null) || currentPermissions.containsAll(permissions))) {
-                    // We got all the permissions we needed, so we can complete the auth now.
-                    AccessToken token = AccessToken
-                            .createFromNativeLogin(result, AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
-                    Result outcome = Result.createTokenResult(pendingRequest, token);
-                    completeAndValidate(outcome);
-                    return;
-                }
-
-                // We didn't get all the permissions we wanted, so update the request with just the permissions
-                // we still need.
-                List<String> newPermissions = new ArrayList<String>();
-                for (String permission : permissions) {
-                    if (!currentPermissions.contains(permission)) {
-                        newPermissions.add(permission);
-                    }
-                }
-                if (!newPermissions.isEmpty()) {
-                    addLoggingExtra(EVENT_EXTRAS_NEW_PERMISSIONS, TextUtils.join(",", newPermissions));
-                }
-
-                request.setPermissions(newPermissions);
-            }
-
-            tryNextHandler();
-        }
-    }
-
-    abstract class KatanaAuthHandler extends AuthHandler {
-        private static final long serialVersionUID = 1L;
-
-        protected boolean tryIntent(Intent intent, int requestCode) {
-            if (intent == null) {
-                return false;
-            }
-
-            try {
-                getStartActivityDelegate().startActivityForResult(intent, requestCode);
-            } catch (ActivityNotFoundException e) {
-                // We don't expect this to happen, since we've already validated the intent and bailed out before
-                // now if it couldn't be resolved.
-                return false;
-            }
-
-            return true;
-        }
-    }
-
-    class KatanaLoginDialogAuthHandler extends KatanaAuthHandler {
-        private static final long serialVersionUID = 1L;
-        private String applicationId;
-        private String callId;
-
-        @Override
-        String getNameForLogging() {
-            return "katana_login_dialog";
-        }
-
-        @Override
-        boolean tryAuthorize(AuthorizationRequest request) {
-            applicationId = request.getApplicationId();
-
-            Intent intent = NativeProtocol.createLoginDialog20121101Intent(context, request.getApplicationId(),
-                    new ArrayList<String>(request.getPermissions()),
-                    request.getDefaultAudience().getNativeProtocolAudience());
-            if (intent == null) {
-                return false;
-            }
-
-            callId = intent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID);
-
-            addLoggingExtra(EVENT_EXTRAS_APP_CALL_ID, callId);
-            addLoggingExtra(EVENT_EXTRAS_PROTOCOL_VERSION,
-                    intent.getIntExtra(NativeProtocol.EXTRA_PROTOCOL_VERSION, 0));
-            addLoggingExtra(EVENT_EXTRAS_PERMISSIONS,
-                    TextUtils.join(",", intent.getStringArrayListExtra(NativeProtocol.EXTRA_PERMISSIONS)));
-            addLoggingExtra(EVENT_EXTRAS_WRITE_PRIVACY, intent.getStringExtra(NativeProtocol.EXTRA_WRITE_PRIVACY));
-            logEvent(AnalyticsEvents.EVENT_NATIVE_LOGIN_DIALOG_START,
-                    AnalyticsEvents.PARAMETER_NATIVE_LOGIN_DIALOG_START_TIME, callId);
-
-            return tryIntent(intent, request.getRequestCode());
-        }
-
-        @Override
-        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-            Result outcome;
-
-            logEvent(AnalyticsEvents.EVENT_NATIVE_LOGIN_DIALOG_COMPLETE,
-                    AnalyticsEvents.PARAMETER_NATIVE_LOGIN_DIALOG_COMPLETE_TIME, callId);
-
-            if (data == null) {
-                // This happens if the user presses 'Back'.
-                outcome = Result.createCancelResult(pendingRequest, "Operation canceled");
-            } else if (NativeProtocol.isServiceDisabledResult20121101(data)) {
-                outcome = null;
-            } else if (resultCode == Activity.RESULT_CANCELED) {
-                outcome = createCancelOrErrorResult(pendingRequest, data);
-            } else if (resultCode != Activity.RESULT_OK) {
-                outcome = Result.createErrorResult(pendingRequest, "Unexpected resultCode from authorization.", null);
-            } else {
-                outcome = handleResultOk(data);
-            }
-
-            if (outcome != null) {
-                completeAndValidate(outcome);
-            } else {
-                tryNextHandler();
-            }
-
-            return true;
-        }
-
-        private Result handleResultOk(Intent data) {
-            Bundle extras = data.getExtras();
-            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
-            if (errorType == null) {
-                return Result.createTokenResult(pendingRequest,
-                        AccessToken.createFromNativeLogin(extras, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE));
-            } else if (NativeProtocol.ERROR_SERVICE_DISABLED.equals(errorType)) {
-                addLoggingExtra(EVENT_EXTRAS_SERVICE_DISABLED, AppEventsConstants.EVENT_PARAM_VALUE_YES);
-                return null;
-            } else {
-                return createCancelOrErrorResult(pendingRequest, data);
-            }
-        }
-
-        private Result createCancelOrErrorResult(AuthorizationRequest request, Intent data) {
-            Bundle extras = data.getExtras();
-            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
-
-            if (NativeProtocol.ERROR_USER_CANCELED.equals(errorType) ||
-                    NativeProtocol.ERROR_PERMISSION_DENIED.equals(errorType)) {
-                return Result.createCancelResult(request, data.getStringExtra(NativeProtocol.STATUS_ERROR_DESCRIPTION));
-            } else {
-                // See if we can get an error code out of the JSON.
-                String errorJson = extras.getString(NativeProtocol.STATUS_ERROR_JSON);
-                String errorCode = null;
-                if (errorJson != null) {
-                    try {
-                        JSONObject jsonObject = new JSONObject(errorJson);
-                        errorCode = jsonObject.getString("error_code");
-                    } catch (JSONException e) {
-                    }
-                }
-                return Result.createErrorResult(request, errorType,
-                        data.getStringExtra(NativeProtocol.STATUS_ERROR_DESCRIPTION), errorCode);
-            }
-        }
-
-        private void logEvent(String eventName, String timeParameter, String callId) {
-            if (callId != null) {
-                AppEventsLogger appEventsLogger = AppEventsLogger.newLogger(context, applicationId);
-                Bundle parameters = new Bundle();
-                parameters.putString(AnalyticsEvents.PARAMETER_APP_ID, applicationId);
-                parameters.putString(AnalyticsEvents.PARAMETER_ACTION_ID, callId);
-                parameters.putLong(timeParameter, System.currentTimeMillis());
-                appEventsLogger.logSdkEvent(eventName, null, parameters);
-            }
-        }
-    }
-
-    class KatanaProxyAuthHandler extends KatanaAuthHandler {
-        private static final long serialVersionUID = 1L;
-        private String applicationId;
-
-        @Override
-        String getNameForLogging() {
-            return "katana_proxy_auth";
-        }
-
-        @Override
-        boolean tryAuthorize(AuthorizationRequest request) {
-            applicationId = request.getApplicationId();
-
-            String e2e = getE2E();
-            Intent intent = NativeProtocol.createProxyAuthIntent(context, request.getApplicationId(),
-                    request.getPermissions(), e2e);
-
-            addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);
-
-            return tryIntent(intent, request.getRequestCode());
-        }
-
-        @Override
-        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-            // Handle stuff
-            Result outcome;
-
-            if (data == null) {
-                // This happens if the user presses 'Back'.
-                outcome = Result.createCancelResult(pendingRequest, "Operation canceled");
-            } else if (resultCode == Activity.RESULT_CANCELED) {
-                outcome = Result.createCancelResult(pendingRequest, data.getStringExtra("error"));
-            } else if (resultCode != Activity.RESULT_OK) {
-                outcome = Result.createErrorResult(pendingRequest, "Unexpected resultCode from authorization.", null);
-            } else {
-                outcome = handleResultOk(data);
-            }
-
-            if (outcome != null) {
-                completeAndValidate(outcome);
-            } else {
-                tryNextHandler();
-            }
-            return true;
-        }
-
-        private Result handleResultOk(Intent data) {
-            Bundle extras = data.getExtras();
-            String error = extras.getString("error");
-            if (error == null) {
-                error = extras.getString("error_type");
-            }
-            String errorCode = extras.getString("error_code");
-            String errorMessage = extras.getString("error_message");
-            if (errorMessage == null) {
-                errorMessage = extras.getString("error_description");
-            }
-
-            String e2e = extras.getString(NativeProtocol.FACEBOOK_PROXY_AUTH_E2E_KEY);
-            if (!Utility.isNullOrEmpty(e2e)) {
-                logWebLoginCompleted(applicationId, e2e);
-            }
-
-            if (error == null && errorCode == null && errorMessage == null) {
-                AccessToken token = AccessToken.createFromWebBundle(pendingRequest.getPermissions(), extras,
-                        AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-                return Result.createTokenResult(pendingRequest, token);
-            } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
-                return null;
-            } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
-                return Result.createCancelResult(pendingRequest, null);
-            } else {
-                return Result.createErrorResult(pendingRequest, error, errorMessage, errorCode);
-            }
-        }
-    }
-
-    private static String getE2E() {
-        JSONObject e2e = new JSONObject();
-        try {
-            e2e.put("init", System.currentTimeMillis());
-        } catch (JSONException e) {
-        }
-        return e2e.toString();
-    }
-
-    private void logWebLoginCompleted(String applicationId, String e2e) {
-        AppEventsLogger appEventsLogger = AppEventsLogger.newLogger(context, applicationId);
-
-        Bundle parameters = new Bundle();
-        parameters.putString(AnalyticsEvents.PARAMETER_WEB_LOGIN_E2E, e2e);
-        parameters.putLong(AnalyticsEvents.PARAMETER_WEB_LOGIN_SWITCHBACK_TIME, System.currentTimeMillis());
-        parameters.putString(AnalyticsEvents.PARAMETER_APP_ID, applicationId);
-
-        appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_WEB_LOGIN_COMPLETE, null, parameters);
-    }
-
-    static class AuthDialogBuilder extends WebDialog.Builder {
-        private static final String OAUTH_DIALOG = "oauth";
-        static final String REDIRECT_URI = "fbconnect://success";
-        private String e2e;
-
-        public AuthDialogBuilder(Context context, String applicationId, Bundle parameters) {
-            super(context, applicationId, OAUTH_DIALOG, parameters);
-        }
-
-        public AuthDialogBuilder setE2E(String e2e) {
-            this.e2e = e2e;
-            return this;
-        }
-
-        @Override
-        public WebDialog build() {
-            Bundle parameters = getParameters();
-            parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
-            parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getApplicationId());
-            parameters.putString(ServerProtocol.DIALOG_PARAM_E2E, e2e);
-
-            return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
-        }
-    }
-
-    static class AuthorizationRequest implements Serializable {
-        private static final long serialVersionUID = 1L;
-
-        private transient final StartActivityDelegate startActivityDelegate;
-        private final SessionLoginBehavior loginBehavior;
-        private final int requestCode;
-        private boolean isLegacy = false;
-        private List<String> permissions;
-        private final SessionDefaultAudience defaultAudience;
-        private final String applicationId;
-        private final String previousAccessToken;
-        private final String authId;
-
-        AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode, boolean isLegacy,
-                List<String> permissions, SessionDefaultAudience defaultAudience, String applicationId,
-                String validateSameFbidAsToken, StartActivityDelegate startActivityDelegate, String authId) {
-            this.loginBehavior = loginBehavior;
-            this.requestCode = requestCode;
-            this.isLegacy = isLegacy;
-            this.permissions = permissions;
-            this.defaultAudience = defaultAudience;
-            this.applicationId = applicationId;
-            this.previousAccessToken = validateSameFbidAsToken;
-            this.startActivityDelegate = startActivityDelegate;
-            this.authId = authId;
-
-        }
-
-        StartActivityDelegate getStartActivityDelegate() {
-            return startActivityDelegate;
-        }
-
-        List<String> getPermissions() {
-            return permissions;
-        }
-
-        void setPermissions(List<String> permissions) {
-            this.permissions = permissions;
-        }
-
-        SessionLoginBehavior getLoginBehavior() {
-            return loginBehavior;
-        }
-
-        int getRequestCode() {
-            return requestCode;
-        }
-
-        SessionDefaultAudience getDefaultAudience() {
-            return defaultAudience;
-        }
-
-        String getApplicationId() {
-            return applicationId;
-        }
-
-        boolean isLegacy() {
-            return isLegacy;
-        }
-
-        void setIsLegacy(boolean isLegacy) {
-            this.isLegacy = isLegacy;
-        }
-
-        String getPreviousAccessToken() {
-            return previousAccessToken;
-        }
-
-        boolean needsNewTokenValidation() {
-            return previousAccessToken != null && !isLegacy;
-        }
-
-        String getAuthId() {
-            return authId;
-        }
-    }
-
-
-    static class Result implements Serializable {
-        private static final long serialVersionUID = 1L;
-
-        enum Code {
-            SUCCESS("success"),
-            CANCEL("cancel"),
-            ERROR("error");
-
-            private final String loggingValue;
-
-            Code(String loggingValue) {
-                this.loggingValue = loggingValue;
-            }
-
-            // For consistency across platforms, we want to use specific string values when logging these results.
-            String getLoggingValue() {
-                return loggingValue;
-            }
-        }
-
-        final Code code;
-        final AccessToken token;
-        final String errorMessage;
-        final String errorCode;
-        final AuthorizationRequest request;
-        Map<String, String> loggingExtras;
-
-        private Result(AuthorizationRequest request, Code code, AccessToken token, String errorMessage,
-                String errorCode) {
-            this.request = request;
-            this.token = token;
-            this.errorMessage = errorMessage;
-            this.code = code;
-            this.errorCode = errorCode;
-        }
-
-        static Result createTokenResult(AuthorizationRequest request, AccessToken token) {
-            return new Result(request, Code.SUCCESS, token, null, null);
-        }
-
-        static Result createCancelResult(AuthorizationRequest request, String message) {
-            return new Result(request, Code.CANCEL, null, message, null);
-        }
-
-        static Result createErrorResult(AuthorizationRequest request, String errorType, String errorDescription) {
-            return createErrorResult(request, errorType, errorDescription, null);
-        }
-
-        static Result createErrorResult(AuthorizationRequest request, String errorType, String errorDescription,
-                String errorCode) {
-            String message = TextUtils.join(": ", Utility.asListNoNulls(errorType, errorDescription));
-            return new Result(request, Code.ERROR, null, message, errorCode);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/CallbackManager.java b/facebook/src/com/facebook/CallbackManager.java
new file mode 100644
index 000000000..12c02c8f4
--- /dev/null
+++ b/facebook/src/com/facebook/CallbackManager.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+
+import com.facebook.internal.CallbackManagerImpl;
+
+/**
+ * The CallbackManager manages the callbacks into the FacebookSdk from an Activity's or
+ * Fragment's onActivityResult() method.
+ */
+public interface CallbackManager {
+
+    /**
+     * The method that should be called from the Activity's or Fragment's onActivityResult method.
+     * @param requestCode The request code that's received by the Activity or Fragment.
+     * @param resultCode  The result code that's received by the Activity or Fragment.
+     * @param data        The result data that's received by the Activity or Fragment.
+     * @return true If the result could be handled.
+     */
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data);
+
+    /**
+     * The factory class for the {@link com.facebook.CallbackManager}.
+     */
+    public static class Factory {
+        /**
+         * Creates an instance of {@link com.facebook.CallbackManager}.
+         * @return an instance of {@link com.facebook.CallbackManager}.
+         */
+        public static CallbackManager create() {
+            return new CallbackManagerImpl();
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookActivity.java b/facebook/src/com/facebook/FacebookActivity.java
new file mode 100644
index 000000000..825ac86b0
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookActivity.java
@@ -0,0 +1,113 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+
+import com.facebook.internal.FacebookDialogFragment;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.login.LoginFragment;
+
+/**
+ * This Activity is a necessary part of the overall Facebook SDK,
+ * but is not meant to be used directly. Add this Activity to your
+ * AndroidManifest.xml to ensure proper handling of Facebook SDK features.
+ * <pre>
+ * {@code
+ * <activity android:name="com.facebook.FacebookActivity"
+ *           android:theme="@android:style/Theme.Translucent.NoTitleBar"
+ *           android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
+ *           android:label="@string/app_name" />
+ * }
+ * </pre>
+ * Do not start this activity directly.
+ */
+public class FacebookActivity extends FragmentActivity {
+
+    public static String PASS_THROUGH_CANCEL_ACTION = "PassThrough";
+    private static String FRAGMENT_TAG = "SingleFragment";
+
+    private Fragment singleFragment;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.com_facebook_activity_layout);
+
+        Intent intent = getIntent();
+        if (PASS_THROUGH_CANCEL_ACTION.equals(intent.getAction())) {
+            handlePassThroughError();
+            return;
+        }
+
+        FragmentManager manager = getSupportFragmentManager();
+        Fragment fragment = manager.findFragmentByTag(FRAGMENT_TAG);
+
+        if (fragment == null) {
+            if (FacebookDialogFragment.TAG.equals(intent.getAction())) {
+                FacebookDialogFragment dialogFragment = new FacebookDialogFragment();
+                dialogFragment.setRetainInstance(true);
+                dialogFragment.show(manager, FRAGMENT_TAG);
+
+                fragment = dialogFragment;
+            } else {
+                fragment = new LoginFragment();
+                fragment.setRetainInstance(true);
+                manager.beginTransaction()
+                        .add(R.id.com_facebook_fragment_container, fragment, FRAGMENT_TAG)
+                        .commit();
+            }
+        }
+
+        singleFragment = fragment;
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+
+        if (singleFragment != null) {
+            singleFragment.onConfigurationChanged(newConfig);
+        }
+    }
+
+    private void handlePassThroughError() {
+        Intent requestIntent = getIntent();
+
+        // The error we need to respond with is passed to us as method arguments.
+        Bundle errorResults = NativeProtocol.getMethodArgumentsFromIntent(requestIntent);
+        FacebookException exception = NativeProtocol.getExceptionFromErrorData(errorResults);
+
+        // Create a result intent that is formed based on the request intent
+        Intent resultIntent = NativeProtocol.createProtocolResultIntent(
+                requestIntent,
+                null,
+                exception);
+
+        setResult(RESULT_CANCELED, resultIntent);
+        finish();
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookAuthorizationException.java b/facebook/src/com/facebook/FacebookAuthorizationException.java
index 59ef9742a..1997e8057 100644
--- a/facebook/src/com/facebook/FacebookAuthorizationException.java
+++ b/facebook/src/com/facebook/FacebookAuthorizationException.java
@@ -1,23 +1,27 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 /**
- * An Exception indicating that a Session failed to open or obtain new permissions.
+ * An Exception indicating that Login failed.
  */
 public class FacebookAuthorizationException extends FacebookException {
     static final long serialVersionUID = 1;
diff --git a/facebook/src/com/facebook/FacebookBroadcastReceiver.java b/facebook/src/com/facebook/FacebookBroadcastReceiver.java
new file mode 100644
index 000000000..31ecb67d6
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookBroadcastReceiver.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * This class implements a simple BroadcastReceiver designed to listen for broadcast notifications
+ * from the Facebook app. At present, these notifications consistent of success/failure
+ * notifications for photo upload operations that happen in the background.
+ * <p/>
+ * Applications may subclass this class and register it in their AndroidManifest.xml. The receiver
+ * is listening the com.facebook.platform.AppCallResultBroadcast action.
+ */
+public class FacebookBroadcastReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String appCallId = intent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID);
+        String action = intent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_ACTION);
+        if (appCallId != null && action != null) {
+            Bundle extras = intent.getExtras();
+
+            if (NativeProtocol.isErrorResult(intent)) {
+                onFailedAppCall(appCallId, action, extras);
+            } else {
+                onSuccessfulAppCall(appCallId, action, extras);
+            }
+        }
+    }
+
+    /**
+     * Invoked when the operation was completed successfully.
+     *
+     * @param appCallId The App Call ID.
+     * @param action The action performed.
+     * @param extras Any extra information.
+     */
+    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
+        // Default does nothing.
+    }
+
+    /**
+     * Invoked when the operation failed to complete.
+     *
+     * @param appCallId The App Call ID.
+     * @param action The action performed.
+     * @param extras Any extra information.
+     */
+    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
+        // Default does nothing.
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookButtonBase.java b/facebook/src/com/facebook/FacebookButtonBase.java
new file mode 100644
index 000000000..73cc044d5
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookButtonBase.java
@@ -0,0 +1,368 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.support.v4.app.Fragment;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.Button;
+
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.R;
+import com.facebook.appevents.AppEventsLogger;
+
+/**
+ * A base class for a facebook button.
+ */
+public abstract class FacebookButtonBase extends Button {
+    private String analyticsButtonCreatedEventName;
+    private OnClickListener externalOnClickListener;
+    private OnClickListener internalOnClickListener;
+    private boolean overrideCompoundPadding;
+    private int overrideCompoundPaddingLeft;
+    private int overrideCompoundPaddingRight;
+    private Fragment parentFragment;
+    private int requestCode;
+
+    protected FacebookButtonBase(
+            final Context context,
+            final AttributeSet attrs,
+            int defStyleAttr,
+            int defStyleRes,
+            final String analyticsButtonCreatedEventName,
+            final int requestCode) {
+        super(context, attrs, 0);
+        defStyleRes = (defStyleRes == 0 ? this.getDefaultStyleResource() : defStyleRes);
+        defStyleRes = (defStyleRes == 0 ? R.style.com_facebook_button : defStyleRes);
+        configureButton(context, attrs, defStyleAttr, defStyleRes);
+        this.analyticsButtonCreatedEventName = analyticsButtonCreatedEventName;
+        this.requestCode = requestCode;
+    }
+
+    /**
+     * Sets the fragment that contains this control. This allows the button to be embedded inside a
+     * Fragment, and will allow the fragment to receive the
+     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
+     * call rather than the Activity.
+     *
+     * @param fragment the fragment that contains this control
+     */
+    public void setFragment(final Fragment fragment) {
+        parentFragment = fragment;
+    }
+
+    /**
+     * Gets the fragment that contains this control.
+     * @return The fragment that contains this control.
+     */
+    public Fragment getFragment() {
+        return parentFragment;
+    }
+
+    @Override
+    public void setOnClickListener(final OnClickListener l) {
+        this.externalOnClickListener = l;
+    }
+
+    /**
+     * Set the request code for the startActivityForResult call. The requestCode should be
+     * outside of the range of those reserved for the Facebook SDK
+     * {@link com.facebook.FacebookSdk#isFacebookRequestCode(int)}. This method should also be
+     * called prior to registering any callbacks.
+     *
+     * @param requestCode the request code to use.
+     */
+    protected void setRequestCode(final int requestCode) {
+        if (FacebookSdk.isFacebookRequestCode(requestCode)) {
+            throw new IllegalArgumentException("Request code " + requestCode +
+                    " cannot be within the range reserved by the Facebook SDK.");
+        }
+        this.requestCode = requestCode;
+    }
+
+    /**
+     * Returns the request code used for this Button.
+     *
+     * @return the request code.
+     */
+    public int getRequestCode() {
+        return requestCode;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        logButtonCreated(getContext());
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        boolean centered = (this.getGravity() & Gravity.CENTER_HORIZONTAL) != 0;
+        if (centered) {
+            // if the text is centered, we need to adjust the frame for the titleLabel based on the
+            // size of the text in order to keep the text centered in the button without adding
+            // extra blank space to the right when unnecessary
+            // 1. the text fits centered within the button without colliding with the image
+            //    (imagePaddingWidth)
+            // 2. the text would run into the image, so adjust the insets to effectively left align
+            //    it (textPaddingWidth)
+            final int compoundPaddingLeft = getCompoundPaddingLeft();
+            final int compoundPaddingRight = getCompoundPaddingRight();
+            final int compoundDrawablePadding = getCompoundDrawablePadding();
+            final int textX = compoundPaddingLeft + compoundDrawablePadding;
+            final int textContentWidth = getWidth() - textX - compoundPaddingRight;
+            final int textWidth = measureTextWidth(getText().toString());
+            final int textPaddingWidth = (textContentWidth - textWidth) / 2;
+            final int imagePaddingWidth = (compoundPaddingLeft - getPaddingLeft()) / 2;
+            final int inset = Math.min(textPaddingWidth, imagePaddingWidth);
+            this.overrideCompoundPaddingLeft = compoundPaddingLeft - inset;
+            this.overrideCompoundPaddingRight = compoundPaddingRight + inset;
+            this.overrideCompoundPadding = true;
+        }
+        super.onDraw(canvas);
+        this.overrideCompoundPadding = false;
+    }
+
+    @Override
+    public int getCompoundPaddingLeft() {
+        return (this.overrideCompoundPadding ?
+                this.overrideCompoundPaddingLeft :
+                super.getCompoundPaddingLeft());
+    }
+
+    @Override
+    public int getCompoundPaddingRight() {
+        return (this.overrideCompoundPadding ?
+                this.overrideCompoundPaddingRight :
+                super.getCompoundPaddingRight());
+    }
+
+    protected Activity getActivity() {
+        final Context context = getContext();
+        if (context instanceof Activity) {
+            return (Activity) context;
+        } else if (context instanceof ContextWrapper) {
+            Context baseContext = ((ContextWrapper) context).getBaseContext();
+            if (baseContext instanceof Activity) {
+                return (Activity) baseContext;
+            }
+        }
+        throw new FacebookException("Unable to get Activity.");
+    }
+
+    protected int getDefaultStyleResource() {
+        return 0;
+    }
+
+    protected int measureTextWidth(final String text) {
+        return (int)Math.ceil(getPaint().measureText(text));
+    }
+
+    protected void configureButton(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        parseBackgroundAttributes(context, attrs, defStyleAttr, defStyleRes);
+        parseCompoundDrawableAttributes(context, attrs, defStyleAttr, defStyleRes);
+        parseContentAttributes(context, attrs, defStyleAttr, defStyleRes);
+        parseTextAttributes(context, attrs, defStyleAttr, defStyleRes);
+        setupOnClickListener();
+    }
+
+    protected void callExternalOnClickListener(final View v) {
+        if (externalOnClickListener != null) {
+            externalOnClickListener.onClick(v);
+        }
+    }
+
+    protected void setInternalOnClickListener(final OnClickListener l) {
+        internalOnClickListener = l;
+    }
+
+    private void logButtonCreated(final Context context) {
+        AppEventsLogger logger = AppEventsLogger.newLogger(context);
+        logger.logSdkEvent(analyticsButtonCreatedEventName, null, null);
+    }
+
+    private void parseBackgroundAttributes(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        final int attrsResources[] = {
+                android.R.attr.background,
+        };
+        final TypedArray a = context.getTheme().obtainStyledAttributes(
+                attrs,
+                attrsResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            if (a.hasValue(0)) {
+                int backgroundResource = a.getResourceId(0, 0);
+                if (backgroundResource != 0) {
+                    setBackgroundResource(backgroundResource);
+                } else {
+                    setBackgroundColor(a.getColor(0, 0));
+                }
+            } else {
+                // fallback, if no background specified, fill with Facebook blue
+                setBackgroundColor(a.getColor(0, R.color.com_facebook_blue));
+            }
+        } finally {
+            a.recycle();
+        }
+    }
+
+    private void parseCompoundDrawableAttributes(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        final int attrsResources[] = {
+                android.R.attr.drawableLeft,
+                android.R.attr.drawableTop,
+                android.R.attr.drawableRight,
+                android.R.attr.drawableBottom,
+                android.R.attr.drawablePadding,
+        };
+        final TypedArray a = context.getTheme().obtainStyledAttributes(
+                attrs,
+                attrsResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            setCompoundDrawablesWithIntrinsicBounds(
+                    a.getResourceId(0, 0),
+                    a.getResourceId(1, 0),
+                    a.getResourceId(2, 0),
+                    a.getResourceId(3, 0));
+            setCompoundDrawablePadding(a.getDimensionPixelSize(4, 0));
+
+        } finally {
+            a.recycle();
+        }
+    }
+
+    private void parseContentAttributes(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        final int attrsResources[] = {
+                android.R.attr.paddingLeft,
+                android.R.attr.paddingTop,
+                android.R.attr.paddingRight,
+                android.R.attr.paddingBottom,
+        };
+        final TypedArray a = context.getTheme().obtainStyledAttributes(
+                attrs,
+                attrsResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            setPadding(
+                    a.getDimensionPixelSize(0, 0),
+                    a.getDimensionPixelSize(1, 0),
+                    a.getDimensionPixelSize(2, 0),
+                    a.getDimensionPixelSize(3, 0));
+        } finally {
+            a.recycle();
+        }
+    }
+
+    private void parseTextAttributes(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        final int colorResources[] = {
+                android.R.attr.textColor,
+        };
+        final TypedArray colorAttrs = context.getTheme().obtainStyledAttributes(
+                attrs,
+                colorResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            setTextColor(colorAttrs.getColor(0, Color.WHITE));
+        } finally {
+            colorAttrs.recycle();
+        }
+        final int gravityResources[] = {
+                android.R.attr.gravity,
+        };
+        final TypedArray gravityAttrs = context.getTheme().obtainStyledAttributes(
+                attrs,
+                gravityResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            setGravity(gravityAttrs.getInt(0, Gravity.CENTER));
+        } finally {
+            gravityAttrs.recycle();
+        }
+        final int attrsResources[] = {
+                android.R.attr.textSize,
+                android.R.attr.textStyle,
+                android.R.attr.text,
+        };
+        final TypedArray a = context.getTheme().obtainStyledAttributes(
+                attrs,
+                attrsResources,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            setTextSize(TypedValue.COMPLEX_UNIT_PX, a.getDimensionPixelSize(0, 0));
+            setTypeface(Typeface.defaultFromStyle(a.getInt(1, Typeface.BOLD)));
+            setText(a.getString(2));
+        } finally {
+            a.recycle();
+        }
+    }
+
+    private void setupOnClickListener() {
+        // set the listener on super so that consumers can set another listener that this will
+        // forward to
+        super.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(final View v) {
+                if (FacebookButtonBase.this.internalOnClickListener != null) {
+                    FacebookButtonBase.this.internalOnClickListener.onClick(v);
+                } else if (FacebookButtonBase.this.externalOnClickListener != null) {
+                    FacebookButtonBase.this.externalOnClickListener.onClick(v);
+                }
+            }
+        });
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookCallback.java b/facebook/src/com/facebook/FacebookCallback.java
new file mode 100644
index 000000000..6a7133eb8
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookCallback.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+/**
+ * A callback class for the Facebook SDK.
+ */
+public interface FacebookCallback<RESULT> {
+    /**
+     * Called when the dialog completes without error.
+     * <p/>
+     * Note: This will be called instead of {@link #onCancel()} if any of the following conditions
+     * are true.
+     * <ul>
+     * <li>
+     * {@link com.facebook.share.widget.MessageDialog} is used.
+     * </li>
+     * <li>
+     * The logged in Facebook user has not authorized the app that has initiated the dialog.
+     * </li>
+     * </ul>
+     *
+     * @param result Result from the dialog
+     */
+    public void onSuccess(RESULT result);
+
+    /**
+     * Called when the dialog is canceled.
+     * <p/>
+     * Note: {@link #onSuccess(RESULT)} will be called instead if any of the following conditions
+     * are true.
+     * <ul>
+     * <li>
+     * {@link com.facebook.share.widget.MessageDialog} is used.
+     * </li>
+     * <li>
+     * The logged in Facebook user has not authorized the app that has initiated the dialog.
+     * </li>
+     * </ul>
+     */
+    public void onCancel();
+
+    /**
+     * Called when the dialog finishes with an error.
+     *
+     * @param error The error that occurred
+     */
+    public void onError(FacebookException error);
+}
diff --git a/facebook/src/com/facebook/FacebookContentProvider.java b/facebook/src/com/facebook/FacebookContentProvider.java
new file mode 100644
index 000000000..9b061d3e2
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookContentProvider.java
@@ -0,0 +1,148 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+import android.util.Pair;
+
+import com.facebook.internal.NativeAppCallAttachmentStore;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.UUID;
+
+/**
+ * <p>Implements a
+ * <a href="http://developer.android.com/reference/android/content/ContentProvider.html">
+ * ContentProvider</a> that can be used to provide binary attachments (e.g., images) to calls made
+ * via {@link com.facebook.FacebookDialog}.
+ * <p/>
+ * <p>Note that this ContentProvider is only necessary if an application wishes to attach images,
+ * etc., that are stored in memory and do not have another way to be referenced by a content URI.
+ * For images obtained from, e.g., the Camera or Gallery, that already have a content URI associated
+ * with them, use of this class is not necessary.
+ * </p>
+ * <p>If an application wishes to attach images that are stored in-memory within the application,
+ * this content provider must be listed in the application's AndroidManifest.xml, and it should be
+ * named according to the pattern
+ * <code>"com.facebook.app.FacebookContentProvider{FACEBOOK_APP_ID}"</code>.
+ * See the {@link FacebookContentProvider#getAttachmentUrl getContentProviderName} method.
+ * </p>
+ */
+public class FacebookContentProvider extends ContentProvider {
+    private static final String TAG = FacebookContentProvider.class.getName();
+    private static final String ATTACHMENT_URL_BASE =
+            "content://com.facebook.app.FacebookContentProvider";
+
+    public FacebookContentProvider() {
+    }
+
+    /**
+     * Returns the name of the content provider formatted correctly for constructing URLs.
+     * @param applicationId the Facebook application ID of the application
+     * @return the String to use as the authority portion of a content URI.
+     */
+    public static String getAttachmentUrl(
+            String applicationId,
+            UUID callId,
+            String attachmentName) {
+        return String.format(
+                "%s%s/%s/%s",
+                ATTACHMENT_URL_BASE,
+                applicationId,
+                callId.toString(),
+                attachmentName);
+    }
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] strings, String s, String[] strings2, String s2) {
+        return null;
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        return null;
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues contentValues) {
+        return null;
+    }
+
+    @Override
+    public int delete(Uri uri, String s, String[] strings) {
+        return 0;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
+        return 0;
+    }
+
+    @Override
+    public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode)
+            throws java.io.FileNotFoundException {
+
+        Pair<UUID, String> callIdAndAttachmentName = parseCallIdAndAttachmentName(uri);
+        if (callIdAndAttachmentName == null) {
+            throw new FileNotFoundException();
+        }
+
+        try {
+            File file = NativeAppCallAttachmentStore.openAttachment(
+                    callIdAndAttachmentName.first,
+                    callIdAndAttachmentName.second);
+
+            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        } catch (FileNotFoundException exception) {
+            Log.e(TAG, "Got unexpected exception:" + exception);
+            throw exception;
+        }
+    }
+
+    Pair<UUID, String> parseCallIdAndAttachmentName(Uri uri) {
+        try {
+            // We don't do explicit format checking here. Malformed URIs may generate
+            // NullPointerExceptions or array bounds exceptions, which we'll catch and return null.
+            // All of these will result in a FileNotFoundException being thrown in openFile.
+            String callIdAndAttachmentName = uri.getPath().substring(1);
+            String [] parts = callIdAndAttachmentName.split("/");
+
+            String callIdString = parts[0];
+            String attachmentName = parts[1];
+            UUID callId = UUID.fromString(callIdString);
+
+            return new Pair<UUID, String>(callId, attachmentName);
+        } catch (Exception exception) {
+            return null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookDialog.java b/facebook/src/com/facebook/FacebookDialog.java
new file mode 100644
index 000000000..5af094bc6
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookDialog.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+/**
+ * Represents dialogs provided by Facebook
+ */
+public interface FacebookDialog<CONTENT, RESULT> {
+
+    /**
+     * Indicates whether the dialog can be shown for the content passed in.
+     * @param content the content to check
+     *
+     * @return true if the dialog can be shown
+     */
+    public boolean canShow(CONTENT content);
+
+    /**
+     * Shows the dialog for the content passed in.
+     * @param content the content to show
+     */
+    public void show(CONTENT content);
+
+    /**
+     * Allows the registration of a callback that will be executed once the dialog is closed, with
+     * success, cancel or error details. This should be called in the
+     * {@link android.app.Activity#onCreate(android.os.Bundle)} or
+     * {@link android.support.v4.app.Fragment#onCreate(android.os.Bundle)} methods.
+     *
+     * @param callbackManager CallbackManager instance that will handle the onActivityResult
+     * @param callback Callback to be called upon dialog completion
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<RESULT> callback);
+
+    /**
+     * Allows the registration of a callback that will be executed once the dialog is closed, with
+     * success, cancel or error details. This should be called in the
+     * {@link android.app.Activity#onCreate(android.os.Bundle)} or
+     * {@link android.support.v4.app.Fragment#onCreate(android.os.Bundle)} methods.
+     *
+     * @param callbackManager CallbackManager instance that will handle the Activity Result
+     * @param callback Callback to be called upon dialog completion
+     * @param requestCode  The request code to use, this should be outside of the range of those
+     *                     reserved for the Facebook SDK
+     *                     {@link com.facebook.FacebookSdk#isFacebookRequestCode(int)}.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<RESULT> callback,
+            final int requestCode);
+}
diff --git a/facebook/src/com/facebook/FacebookDialogException.java b/facebook/src/com/facebook/FacebookDialogException.java
index f59b99c8f..4a336fa28 100644
--- a/facebook/src/com/facebook/FacebookDialogException.java
+++ b/facebook/src/com/facebook/FacebookDialogException.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -50,4 +54,18 @@ public int getErrorCode() {
     public String getFailingUrl() {
         return failingUrl;
     }
+
+    @Override
+    public final String toString() {
+        return new StringBuilder()
+                .append("{FacebookDialogException: ")
+                .append("errorCode: ")
+                .append(getErrorCode())
+                .append(", message: ")
+                .append(getMessage())
+                .append(", url: ")
+                .append(getFailingUrl())
+                .append("}")
+                .toString();
+    }
 }
diff --git a/facebook/src/com/facebook/FacebookException.java b/facebook/src/com/facebook/FacebookException.java
index 4caeda7f7..adbf1c8f4 100644
--- a/facebook/src/com/facebook/FacebookException.java
+++ b/facebook/src/com/facebook/FacebookException.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -31,9 +35,8 @@ public FacebookException() {
 
     /**
      * Constructs a new FacebookException.
-     * 
-     * @param message
-     *            the detail message of this exception
+     *
+     * @param message the detail message of this exception
      */
     public FacebookException(String message) {
         super(message);
@@ -41,11 +44,19 @@ public FacebookException(String message) {
 
     /**
      * Constructs a new FacebookException.
-     * 
-     * @param message
-     *            the detail message of this exception
-     * @param throwable
-     *            the cause of this exception
+     *
+     * @param format the format string (see {@link java.util.Formatter#format})
+     * @param args   the list of arguments passed to the formatter.
+     */
+    public FacebookException(String format, Object... args) {
+        this(String.format(format, args));
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     *
+     * @param message   the detail message of this exception
+     * @param throwable the cause of this exception
      */
     public FacebookException(String message, Throwable throwable) {
         super(message, throwable);
@@ -53,11 +64,17 @@ public FacebookException(String message, Throwable throwable) {
 
     /**
      * Constructs a new FacebookException.
-     * 
-     * @param throwable
-     *            the cause of this exception
+     *
+     * @param throwable the cause of this exception
      */
     public FacebookException(Throwable throwable) {
         super(throwable);
     }
+
+    @Override
+    public String toString() {
+        // Throwable.toString() returns "FacebookException:{message}". Returning just "{message}"
+        // should be fine here.
+        return getMessage();
+    }
 }
diff --git a/facebook/src/com/facebook/FacebookGraphObjectException.java b/facebook/src/com/facebook/FacebookGraphObjectException.java
deleted file mode 100644
index b513706de..000000000
--- a/facebook/src/com/facebook/FacebookGraphObjectException.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-/**
- * Represents an error specific to the {@link com.facebook.model.GraphObject GraphObject} class.
- */
-public class FacebookGraphObjectException extends FacebookException {
-    static final long serialVersionUID = 1;
-
-    /**
-     * Constructs a new FacebookGraphObjectException.
-     */
-    public FacebookGraphObjectException() {
-        super();
-    }
-
-    /**
-     * Constructs a new FacebookGraphObjectException.
-     * 
-     * @param message
-     *            the detail message of this exception
-     */
-    public FacebookGraphObjectException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs a new FacebookGraphObjectException.
-     * 
-     * @param message
-     *            the detail message of this exception
-     * @param throwable
-     *            the cause of this exception
-     */
-    public FacebookGraphObjectException(String message, Throwable throwable) {
-        super(message, throwable);
-    }
-
-    /**
-     * Constructs a new FacebookGraphObjectException.
-     * 
-     * @param throwable
-     *            the cause of this exception
-     */
-    public FacebookGraphObjectException(Throwable throwable) {
-        super(throwable);
-    }
-}
diff --git a/facebook/src/com/facebook/FacebookGraphResponseException.java b/facebook/src/com/facebook/FacebookGraphResponseException.java
new file mode 100644
index 000000000..354b62bda
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookGraphResponseException.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an issue that's returned by the Graph API.
+ */
+public class FacebookGraphResponseException extends FacebookException {
+
+    private final GraphResponse graphResponse;
+
+    /**
+     * Constructs a new FacebookGraphResponseException.
+     *
+     * @param graphResponse The graph response with issue.
+     * @param errorMessage The error message.
+     */
+    public FacebookGraphResponseException(GraphResponse graphResponse, String errorMessage) {
+        super(errorMessage);
+        this.graphResponse = graphResponse;
+    }
+
+    /**
+     * Getter for the graph response with the issue.
+     * @return the graph response with the issue.
+     */
+    public final GraphResponse getGraphResponse() {
+        return graphResponse;
+    }
+
+    @Override
+    public final String toString() {
+        FacebookRequestError requestError = graphResponse != null ? graphResponse.getError() : null;
+        StringBuilder errorStringBuilder = new StringBuilder()
+                .append("{FacebookGraphResponseException: ");
+        String message = getMessage();
+        if (message != null) {
+            errorStringBuilder.append(message);
+            errorStringBuilder.append(" ");
+        }
+        if (requestError != null) {
+            errorStringBuilder.append("httpResponseCode: ")
+                    .append(requestError.getRequestStatusCode())
+                    .append(", facebookErrorCode: ")
+                    .append(requestError.getErrorCode())
+                    .append(", facebookErrorType: ")
+                    .append(requestError.getErrorType())
+                    .append(", message: ")
+                    .append(requestError.getErrorMessage())
+                    .append("}");
+        }
+
+        return errorStringBuilder.toString();
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookOperationCanceledException.java b/facebook/src/com/facebook/FacebookOperationCanceledException.java
index 9fcf11dd4..09e08889e 100644
--- a/facebook/src/com/facebook/FacebookOperationCanceledException.java
+++ b/facebook/src/com/facebook/FacebookOperationCanceledException.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
diff --git a/facebook/src/com/facebook/FacebookRequestError.java b/facebook/src/com/facebook/FacebookRequestError.java
index 937e2b580..f9c82d26b 100644
--- a/facebook/src/com/facebook/FacebookRequestError.java
+++ b/facebook/src/com/facebook/FacebookRequestError.java
@@ -1,35 +1,41 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
-import com.facebook.android.R;
+import com.facebook.internal.FacebookRequestErrorClassification;
 import com.facebook.internal.Utility;
 import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.net.HttpURLConnection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * This class represents an error that occurred during a Facebook request.
  * <p/>
  * In general, one would call {@link #getCategory()} to determine the type
- * of error that occurred, and act accordingly. The app can also call
- * {@link #getUserActionMessageId()} in order to get the resource id for a
- * string that can be displayed to the user. For more information on error
+ * of error that occurred, and act accordingly. For more information on error
  * handling, see <a href="https://developers.facebook.com/docs/reference/api/errors/">
  * https://developers.facebook.com/docs/reference/api/errors/</a>
  */
@@ -46,8 +52,6 @@
      */
     public static final int INVALID_HTTP_STATUS_CODE = -1;
 
-    private static final int INVALID_MESSAGE_ID = 0;
-
     private static final String CODE_KEY = "code";
     private static final String BODY_KEY = "body";
     private static final String ERROR_KEY = "error";
@@ -58,6 +62,9 @@
     private static final String ERROR_SUB_CODE_KEY = "error_subcode";
     private static final String ERROR_MSG_KEY = "error_msg";
     private static final String ERROR_REASON_KEY = "error_reason";
+    private static final String ERROR_USER_TITLE_KEY = "error_user_title";
+    private static final String ERROR_USER_MSG_KEY = "error_user_msg";
+    private static final String ERROR_IS_TRANSIENT_KEY = "is_transient";
 
     private static class Range {
         private final int start, end;
@@ -72,41 +79,36 @@ boolean contains(int value) {
         }
     }
 
-    private static final int EC_UNKNOWN_ERROR = 1;
-    private static final int EC_SERVICE_UNAVAILABLE = 2;
-    private static final int EC_APP_TOO_MANY_CALLS = 4;
-    private static final int EC_USER_TOO_MANY_CALLS = 17;
-    private static final int EC_PERMISSION_DENIED = 10;
-    private static final int EC_INVALID_SESSION = 102;
-    private static final int EC_INVALID_TOKEN = 190;
-    private static final Range EC_RANGE_PERMISSION = new Range(200, 299);
-    private static final int EC_APP_NOT_INSTALLED = 458;
-    private static final int EC_USER_CHECKPOINTED = 459;
-    private static final int EC_PASSWORD_CHANGED = 460;
-    private static final int EC_EXPIRED = 463;
-    private static final int EC_UNCONFIRMED_USER = 464;
-
-    private static final Range HTTP_RANGE_SUCCESS = new Range(200, 299);
-    private static final Range HTTP_RANGE_CLIENT_ERROR = new Range(400, 499);
-    private static final Range HTTP_RANGE_SERVER_ERROR = new Range(500, 599);
-
-    private final int userActionMessageId;
-    private final boolean shouldNotifyUser;
+    static final Range HTTP_RANGE_SUCCESS = new Range(200, 299);
+
     private final Category category;
     private final int requestStatusCode;
     private final int errorCode;
     private final int subErrorCode;
     private final String errorType;
     private final String errorMessage;
+    private final String errorUserTitle;
+    private final String errorUserMessage;
+    private final String errorRecoveryMessage;
     private final JSONObject requestResult;
     private final JSONObject requestResultBody;
     private final Object batchRequestResult;
     private final HttpURLConnection connection;
     private final FacebookException exception;
 
-    private FacebookRequestError(int requestStatusCode, int errorCode,
-            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
-            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection,
+    private FacebookRequestError(
+            int requestStatusCode,
+            int errorCode,
+            int subErrorCode,
+            String errorType,
+            String errorMessage,
+            String errorUserTitle,
+            String errorUserMessage,
+            boolean errorIsTransient,
+            JSONObject requestResultBody,
+            JSONObject requestResult,
+            Object batchRequestResult,
+            HttpURLConnection connection,
             FacebookException exception) {
         this.requestStatusCode = requestStatusCode;
         this.errorCode = errorCode;
@@ -117,6 +119,8 @@ private FacebookRequestError(int requestStatusCode, int errorCode,
         this.requestResult = requestResult;
         this.batchRequestResult = batchRequestResult;
         this.connection = connection;
+        this.errorUserTitle = errorUserTitle;
+        this.errorUserMessage = errorUserMessage;
 
         boolean isLocalException = false;
         if (exception != null) {
@@ -126,95 +130,46 @@ private FacebookRequestError(int requestStatusCode, int errorCode,
             this.exception = new FacebookServiceException(this, errorMessage);
         }
 
-        // Initializes the error categories based on the documented error codes as outlined here
-        // https://developers.facebook.com/docs/reference/api/errors/
-        Category errorCategory = null;
-        int messageId = INVALID_MESSAGE_ID;
-        boolean shouldNotify = false;
-        if (isLocalException) {
-            errorCategory = Category.CLIENT;
-            messageId = INVALID_MESSAGE_ID;
-        } else {
-            if (errorCode == EC_UNKNOWN_ERROR || errorCode == EC_SERVICE_UNAVAILABLE) {
-                errorCategory = Category.SERVER;
-            } else if (errorCode == EC_APP_TOO_MANY_CALLS || errorCode == EC_USER_TOO_MANY_CALLS) {
-                errorCategory = Category.THROTTLING;
-            } else if (errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION.contains(errorCode)) {
-                errorCategory = Category.PERMISSION;
-                messageId = R.string.com_facebook_requesterror_permissions;
-            } else if (errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN) {
-                if (subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER) {
-                    errorCategory = Category.AUTHENTICATION_RETRY;
-                    messageId = R.string.com_facebook_requesterror_web_login;
-                    shouldNotify = true;
-                } else {
-                    errorCategory = Category.AUTHENTICATION_REOPEN_SESSION;
-
-                    if ((subErrorCode == EC_APP_NOT_INSTALLED) || (subErrorCode == EC_EXPIRED)) {
-                        messageId = R.string.com_facebook_requesterror_relogin;
-                    } else if (subErrorCode == EC_PASSWORD_CHANGED) {
-                        messageId = R.string.com_facebook_requesterror_password_changed;
-                    } else {
-                        messageId = R.string.com_facebook_requesterror_reconnect;
-                        shouldNotify = true;
-                    }
-                }
-            }
-
-            if (errorCategory == null) {
-                if (HTTP_RANGE_CLIENT_ERROR.contains(requestStatusCode)) {
-                    errorCategory = Category.BAD_REQUEST;
-                } else if (HTTP_RANGE_SERVER_ERROR.contains(requestStatusCode)) {
-                    errorCategory = Category.SERVER;
-                } else {
-                    errorCategory = Category.OTHER;
-                }
-            }
-        }
-
-        this.category = errorCategory;
-        this.userActionMessageId = messageId;
-        this.shouldNotifyUser = shouldNotify;
-    }
-
-    private FacebookRequestError(int requestStatusCode, int errorCode,
-            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
-            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection) {
-        this(requestStatusCode, errorCode, subErrorCode, errorType, errorMessage,
-                requestResultBody, requestResult, batchRequestResult, connection, null);
+        FacebookRequestErrorClassification errorClassification = getErrorClassification();
+        this.category = isLocalException
+                ? Category.OTHER
+                : errorClassification.classify(errorCode, subErrorCode, errorIsTransient);
+        this.errorRecoveryMessage = errorClassification.getRecoveryMessage(this.category);
     }
 
     FacebookRequestError(HttpURLConnection connection, Exception exception) {
-        this(INVALID_HTTP_STATUS_CODE, INVALID_ERROR_CODE, INVALID_ERROR_CODE,
-                null, null, null, null, null, connection,
+        this(
+                INVALID_HTTP_STATUS_CODE,
+                INVALID_ERROR_CODE,
+                INVALID_ERROR_CODE,
+                null,
+                null,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+                connection,
                 (exception instanceof FacebookException) ?
                         (FacebookException) exception : new FacebookException(exception));
     }
 
     public FacebookRequestError(int errorCode, String errorType, String errorMessage) {
-        this(INVALID_HTTP_STATUS_CODE, errorCode, INVALID_ERROR_CODE, errorType, errorMessage,
-                null, null, null, null, null);
-    }
-
-    /**
-     * Returns the resource id for a user-friendly message for the application to
-     * present to the user.
-     *
-     * @return a user-friendly message to present to the user
-     */
-    public int getUserActionMessageId() {
-        return userActionMessageId;
-    }
-
-    /**
-     * Returns whether direct user action is required to successfully continue with the Facebook
-     * operation. If user action is required, apps can also call {@link #getUserActionMessageId()}
-     * in order to get a resource id for a message to show the user.
-     *
-     * @return whether direct user action is required
-     */
-    public boolean shouldNotifyUser() {
-        return shouldNotifyUser;
+        this(
+                INVALID_HTTP_STATUS_CODE,
+                errorCode,
+                INVALID_ERROR_CODE,
+                errorType,
+                errorMessage,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+                null,
+                null);
     }
 
     /**
@@ -279,6 +234,37 @@ public String getErrorMessage() {
         }
     }
 
+    /**
+     * Returns the message that can be displayed to the user before attempting error recovery.
+     * @return the message that can be displayed to the user before attempting error recovery
+     */
+    public String getErrorRecoveryMessage() {
+        return this.errorRecoveryMessage;
+    }
+
+    /**
+     * Returns a message suitable for display to the user, describing a user action necessary to
+     * enable Facebook functionality. Not all Facebook errors yield a message suitable for user
+     * display; however in all cases where shouldNotifyUser() returns true, this method returns a
+     * non-null message suitable for display.
+     *
+     * @return the error message returned from Facebook
+     */
+    public String getErrorUserMessage() {
+        return errorUserMessage;
+    }
+
+    /**
+     * Returns a short summary of the error suitable for display to the user. Not all Facebook
+     * errors yield a title/message suitable for user display; however in all cases where
+     * getErrorUserTitle() returns valid String - user should be notified.
+     *
+     * @return the error message returned from Facebook
+     */
+    public String getErrorUserTitle() {
+        return errorUserTitle;
+    }
+
     /**
      * Returns the body portion of the response corresponding to the request from Facebook.
      *
@@ -345,32 +331,42 @@ public String toString() {
                 .toString();
     }
 
-    static FacebookRequestError checkResponseAndCreateError(JSONObject singleResult,
-            Object batchResult, HttpURLConnection connection) {
+    static FacebookRequestError checkResponseAndCreateError(
+            JSONObject singleResult,
+            Object batchResult,
+            HttpURLConnection connection) {
         try {
             if (singleResult.has(CODE_KEY)) {
                 int responseCode = singleResult.getInt(CODE_KEY);
                 Object body = Utility.getStringPropertyAsJSON(singleResult, BODY_KEY,
-                        Response.NON_JSON_RESPONSE_PROPERTY);
+                        GraphResponse.NON_JSON_RESPONSE_PROPERTY);
 
                 if (body != null && body instanceof JSONObject) {
                     JSONObject jsonBody = (JSONObject) body;
-                    // Does this response represent an error from the service? We might get either an "error"
-                    // with several sub-properties, or else one or more top-level fields containing error info.
+                    // Does this response represent an error from the service? We might get either
+                    // an "error" with several sub-properties, or else one or more top-level fields
+                    // containing error info.
                     String errorType = null;
                     String errorMessage = null;
+                    String errorUserMessage = null;
+                    String errorUserTitle = null;
+                    boolean errorIsTransient = false;
                     int errorCode = INVALID_ERROR_CODE;
                     int errorSubCode = INVALID_ERROR_CODE;
 
                     boolean hasError = false;
                     if (jsonBody.has(ERROR_KEY)) {
                         // We assume the error object is correctly formatted.
-                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
+                        JSONObject error = (JSONObject)
+                                Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
 
                         errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
                         errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
                         errorCode = error.optInt(ERROR_CODE_FIELD_KEY, INVALID_ERROR_CODE);
                         errorSubCode = error.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        errorUserMessage =  error.optString(ERROR_USER_MSG_KEY, null);
+                        errorUserTitle =  error.optString(ERROR_USER_TITLE_KEY, null);
+                        errorIsTransient = error.optBoolean(ERROR_IS_TRANSIENT_KEY, false);
                         hasError = true;
                     } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
                             || jsonBody.has(ERROR_REASON_KEY)) {
@@ -382,72 +378,82 @@ static FacebookRequestError checkResponseAndCreateError(JSONObject singleResult,
                     }
 
                     if (hasError) {
-                        return new FacebookRequestError(responseCode, errorCode, errorSubCode,
-                                errorType, errorMessage, jsonBody, singleResult, batchResult, connection);
+                        return new FacebookRequestError(
+                                responseCode,
+                                errorCode,
+                                errorSubCode,
+                                errorType,
+                                errorMessage,
+                                errorUserTitle,
+                                errorUserMessage,
+                                errorIsTransient,
+                                jsonBody,
+                                singleResult,
+                                batchResult,
+                                connection,
+                                null);
                     }
                 }
 
-                // If we didn't get error details, but we did get a failure response code, report it.
+                // If we didn't get error details, but we did get a failure response code, report
+                // it.
                 if (!HTTP_RANGE_SUCCESS.contains(responseCode)) {
-                    return new FacebookRequestError(responseCode, INVALID_ERROR_CODE,
-                            INVALID_ERROR_CODE, null, null,
+                    return new FacebookRequestError(
+                            responseCode,
+                            INVALID_ERROR_CODE,
+                            INVALID_ERROR_CODE,
+                            null,
+                            null,
+                            null,
+                            null,
+                            false,
                             singleResult.has(BODY_KEY) ?
                                     (JSONObject) Utility.getStringPropertyAsJSON(
-                                            singleResult, BODY_KEY, Response.NON_JSON_RESPONSE_PROPERTY) : null,
-                            singleResult, batchResult, connection);
+                                            singleResult,
+                                            BODY_KEY,
+                                            GraphResponse.NON_JSON_RESPONSE_PROPERTY
+                                    ) : null,
+                            singleResult,
+                            batchResult,
+                            connection,
+                            null);
                 }
             }
         } catch (JSONException e) {
-            // defer the throwing of a JSONException to the graph object proxy
         }
         return null;
     }
 
+    static synchronized FacebookRequestErrorClassification getErrorClassification() {
+        FacebookRequestErrorClassification errorClassification;
+        Utility.FetchedAppSettings appSettings =
+                Utility.getAppSettingsWithoutQuery(FacebookSdk.getApplicationId());
+        if (appSettings == null) {
+            return FacebookRequestErrorClassification.getDefaultErrorClassification();
+        }
+        return appSettings.getErrorClassification();
+    }
+
     /**
      * An enum that represents the Facebook SDK classification for the error that occurred.
      */
     public enum Category {
         /**
-         * Indicates that the error is authentication related, and that the app should retry
-         * the request after some user action.
+         * Indicates that the error is authentication related. The {@link
+         * com.facebook.login.LoginManager#resolveError(android.app.Activity, GraphResponse)} method
+         * or {@link com.facebook.login.LoginManager#resolveError(android.support.v4.app.Fragment,
+         * GraphResponse)} method can be called to recover from this error.
          */
-        AUTHENTICATION_RETRY,
+        LOGIN_RECOVERABLE,
 
         /**
-         * Indicates that the error is authentication related, and that the app should close
-         * the session and reopen it.
-         */
-        AUTHENTICATION_REOPEN_SESSION,
-
-        /** Indicates that the error is permission related. */
-        PERMISSION,
-
-        /**
-         * Indicates that the error implies the server had an unexpected failure or may be
-         * temporarily unavailable.
-         */
-        SERVER,
-
-        /** Indicates that the error results from the server throttling the client. */
-        THROTTLING,
-
-        /**
-         * Indicates that the error is Facebook-related but cannot be categorized at this time,
-         * and is likely newer than the current version of the SDK.
+         * Indicates that the error is not transient or recoverable by the Facebook SDK.
          */
         OTHER,
 
         /**
-         * Indicates that the error is an application error resulting in a bad or malformed
-         * request to the server.
-         */
-        BAD_REQUEST,
-
-        /**
-         * Indicates that this is a client-side error. Examples of this can include, but are
-         * not limited to, JSON parsing errors or {@link java.io.IOException}s.
+         * Indicates that the error is transient, the request can be attempted again.
          */
-        CLIENT
+        TRANSIENT,
     };
-
 }
diff --git a/facebook/src/com/facebook/FacebookSdk.java b/facebook/src/com/facebook/FacebookSdk.java
new file mode 100644
index 000000000..12928d4f2
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookSdk.java
@@ -0,0 +1,735 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.Signature;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.util.Base64;
+import android.util.Log;
+
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AppEventsLoggerUtility;
+import com.facebook.internal.BoltsMeasurementEventListener;
+import com.facebook.internal.AttributionIdentifiers;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.lang.reflect.Field;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * This class allows some customization of Facebook SDK behavior.
+ */
+public final class FacebookSdk {
+    private static final String TAG = FacebookSdk.class.getCanonicalName();
+    private static final HashSet<LoggingBehavior> loggingBehaviors =
+            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
+    private static volatile Executor executor;
+    private static volatile String applicationId;
+    private static volatile String applicationName;
+    private static volatile String appClientToken;
+    private static final String FACEBOOK_COM = "facebook.com";
+    private static volatile String facebookDomain = FACEBOOK_COM;
+    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
+    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
+    private static boolean isLegacyTokenUpgradeSupported = false;
+    private static File cacheDir;
+    private static Context applicationContext;
+    private static final int DEFAULT_CORE_POOL_SIZE = 5;
+    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
+    private static final int DEFAULT_KEEP_ALIVE = 1;
+    private static int callbackRequestCodeOffset = 0xface;
+    private static final Object LOCK = new Object();
+
+    private static final int MAX_REQUEST_CODE_RANGE = 100;
+
+    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
+    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
+
+    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
+            new LinkedBlockingQueue<Runnable>(10);
+
+    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
+        private final AtomicInteger counter = new AtomicInteger(0);
+
+        public Thread newThread(Runnable runnable) {
+            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
+        }
+    };
+
+    static final String CALLBACK_OFFSET_CHANGED_AFTER_INIT =
+            "The callback request code offset can't be updated once the SDK is initialized.";
+
+    static final String CALLBACK_OFFSET_NEGATIVE =
+            "The callback request code offset can't be negative.";
+
+
+    /**
+     * The key for the application ID in the Android manifest.
+     */
+    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";
+
+    /**
+     * The key for the application name in the Android manifest.
+     */
+    public static final String APPLICATION_NAME_PROPERTY = "com.facebook.sdk.ApplicationName";
+
+    /**
+     * The key for the client token in the Android manifest.
+     */
+    public static final String CLIENT_TOKEN_PROPERTY = "com.facebook.sdk.ClientToken";
+
+    private static Boolean sdkInitialized = false;
+
+    /**
+     * This function initializes the Facebook SDK, the behavior of Facebook SDK functions are
+     * undetermined if this function is not called. It should be called as early as possible.
+     * @param applicationContext The application context
+     * @param callbackRequestCodeOffset The request code offset that Facebook activities will be
+     *                                  called with. Please do not use the range between the
+     *                                  value you set and another 100 entries after it in your
+     *                                  other requests.
+     */
+    public static synchronized void sdkInitialize(
+            Context applicationContext,
+            int callbackRequestCodeOffset) {
+        if (sdkInitialized && callbackRequestCodeOffset != FacebookSdk.callbackRequestCodeOffset) {
+            throw new FacebookException(CALLBACK_OFFSET_CHANGED_AFTER_INIT);
+        }
+        if (callbackRequestCodeOffset < 0) {
+            throw new FacebookException(CALLBACK_OFFSET_NEGATIVE);
+        }
+        FacebookSdk.callbackRequestCodeOffset = callbackRequestCodeOffset;
+        sdkInitialize(applicationContext);
+    }
+
+
+    /**
+     * This function initializes the Facebook SDK, the behavior of Facebook SDK functions are
+     * undetermined if this function is not called. It should be called as early as possible.
+     * @param applicationContext The application context
+     */
+    public static synchronized void sdkInitialize(Context applicationContext) {
+        if (sdkInitialized == true) {
+          return;
+        }
+
+        Validate.notNull(applicationContext, "applicationContext");
+
+        // Don't throw for these validations here, just log an error. We'll throw when we actually
+        // need them
+        Validate.hasFacebookActivity(applicationContext, false);
+        Validate.hasInternetPermissions(applicationContext, false);
+
+        FacebookSdk.applicationContext = applicationContext.getApplicationContext();
+
+        // Make sure we've loaded default settings if we haven't already.
+        FacebookSdk.loadDefaultsFromMetadata(FacebookSdk.applicationContext);
+        // Load app settings from network so that dialog configs are available
+        Utility.loadAppSettingsAsync(FacebookSdk.applicationContext, applicationId);
+        // Fetch available protocol versions from the apps on the device
+        NativeProtocol.updateAllAvailableProtocolVersionsAsync();
+
+        BoltsMeasurementEventListener.getInstance(FacebookSdk.applicationContext);
+
+        cacheDir = FacebookSdk.applicationContext.getCacheDir();
+
+        FutureTask<Void> accessTokenLoadFutureTask =
+                new FutureTask<Void>(new Callable<Void>() {
+                    @Override
+                    public Void call() throws Exception {
+                        AccessTokenManager.getInstance().loadCurrentAccessToken();
+                        ProfileManager.getInstance().loadCurrentProfile();
+                        if (AccessToken.getCurrentAccessToken() != null &&
+                                Profile.getCurrentProfile() == null) {
+                            // Access token and profile went out of sync due to a network or caching
+                            // issue, retry
+                            Profile.fetchProfileForCurrentAccessToken();
+                        }
+                        return null;
+                    }
+                });
+        getExecutor().execute(accessTokenLoadFutureTask);
+
+        sdkInitialized = true;
+    }
+
+    /**
+     * Indicates whether the Facebook SDK has been initialized.
+     * @return true if initialized, false if not
+     */
+    public static synchronized boolean isInitialized() {
+        return sdkInitialized;
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Returns the types of extended logging that are currently enabled.
+     *
+     * @return a set containing enabled logging behaviors
+     */
+    public static Set<LoggingBehavior> getLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Enables a particular extended logging in the SDK.
+     *
+     * @param behavior
+     *          The LoggingBehavior to enable
+     */
+    public static void addLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.add(behavior);
+            updateGraphDebugBehavior();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables a particular extended logging behavior in the SDK.
+     *
+     * @param behavior
+     *          The LoggingBehavior to disable
+     */
+    public static void removeLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.remove(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables all extended logging behaviors.
+     */
+    public static void clearLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.clear();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Checks if a particular extended logging behavior is enabled.
+     *
+     * @param behavior
+     *          The LoggingBehavior to check
+     * @return whether behavior is enabled
+     */
+    public static boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            return FacebookSdk.isDebugEnabled() && loggingBehaviors.contains(behavior);
+        }
+    }
+
+    /**
+     * Indicates if we are in debug mode.
+     */
+    public static boolean isDebugEnabled() {
+        return isDebugEnabled;
+    }
+
+    /**
+     * Used to enable or disable logging, and other debug features. Defaults to BuildConfig.DEBUG.
+     * @param enabled Debug features (like logging) are enabled if true, disabled if false.
+     */
+    public static void setIsDebugEnabled(boolean enabled) {
+        isDebugEnabled = enabled;
+    }
+
+    /**
+     * Indicates if the SDK should fallback and read the legacy token. This is turned off by default
+     * for performance.
+     * @return if the legacy token upgrade is supported.
+     */
+    public static boolean isLegacyTokenUpgradeSupported() {
+        return isLegacyTokenUpgradeSupported;
+    }
+
+    private static void updateGraphDebugBehavior() {
+        if (loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_INFO)
+           && !loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
+            loggingBehaviors.add(LoggingBehavior.GRAPH_API_DEBUG_WARNING);
+        }
+    }
+
+    /**
+     * Setter for legacy token upgrade.
+     * @param supported True if upgrade should be supported.
+     */
+    public static void setLegacyTokenUpgradeSupported(boolean supported) {
+        isLegacyTokenUpgradeSupported = supported;
+    }
+
+    /**
+     * Returns the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
+     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
+     *
+     * @return an Executor used by the SDK.  This will never be null.
+     */
+    public static Executor getExecutor() {
+        synchronized (LOCK) {
+            if (FacebookSdk.executor == null) {
+                Executor executor = getAsyncTaskExecutor();
+                if (executor == null) {
+                    executor = new ThreadPoolExecutor(
+                            DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE, DEFAULT_KEEP_ALIVE,
+                            TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
+                }
+                FacebookSdk.executor = executor;
+            }
+        }
+        return FacebookSdk.executor;
+    }
+
+    /**
+     * Sets the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * @param executor
+     *          the Executor to use; must not be null.
+     */
+    public static void setExecutor(Executor executor) {
+        Validate.notNull(executor, "executor");
+        synchronized (LOCK) {
+            FacebookSdk.executor = executor;
+        }
+    }
+
+    /**
+     * Gets the base Facebook domain to use when making Web requests; in production code this will
+     * always be "facebook.com".
+     *
+     * @return the Facebook domain
+     */
+    public static String getFacebookDomain() {
+        return facebookDomain;
+    }
+
+    /**
+     * Sets the base Facebook domain to use when making Web requests. This defaults to
+     * "facebook.com", but may be overridden to, e.g., "beta.facebook.com" to direct requests at a
+     * different domain. This method should never be called from production code.
+     *
+     * @param facebookDomain the base domain to use instead of "facebook.com"
+     */
+    public static void setFacebookDomain(String facebookDomain) {
+        if (!BuildConfig.DEBUG) {
+            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
+        }
+
+        FacebookSdk.facebookDomain = facebookDomain;
+    }
+
+    /**
+     * The getter for the context of the current application.
+     * @return The context of the current application.
+     */
+    public static Context getApplicationContext() {
+        Validate.sdkInitialized();
+        return applicationContext;
+    }
+
+    private static Executor getAsyncTaskExecutor() {
+        Field executorField = null;
+        try {
+            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+
+        Object executorObject = null;
+        try {
+            executorObject = executorField.get(null);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
+
+        if (executorObject == null) {
+            return null;
+        }
+
+        if (!(executorObject instanceof Executor)) {
+            return null;
+        }
+
+        return (Executor) executorObject;
+    }
+
+    /**
+     * This method is public in order to be used by app events, please don't use directly.
+     * @param context       The application context.
+     * @param applicationId The application id.
+     */
+    public static void publishInstallAsync(final Context context, final String applicationId) {
+        // grab the application context ahead of time, since we will return to the caller
+        // immediately.
+        final Context applicationContext = context.getApplicationContext();
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                FacebookSdk.publishInstallAndWaitForResponse(applicationContext, applicationId);
+            }
+        });
+    }
+
+    static GraphResponse publishInstallAndWaitForResponse(
+            final Context context,
+            final String applicationId) {
+        try {
+            if (context == null || applicationId == null) {
+                throw new IllegalArgumentException("Both context and applicationId must be non-null");
+            }
+            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
+            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
+            String pingKey = applicationId+"ping";
+            String jsonKey = applicationId+"json";
+            long lastPing = preferences.getLong(pingKey, 0);
+            String lastResponseJSON = preferences.getString(jsonKey, null);
+
+            JSONObject publishParams;
+            try {
+                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
+                        AppEventsLoggerUtility.GraphAPIActivityType.MOBILE_INSTALL_EVENT,
+                        identifiers,
+                        AppEventsLogger.getAnonymousAppDeviceGUID(context),
+                        getLimitEventAndDataUsage(context),
+                        context);
+            } catch (JSONException e) {
+                throw new FacebookException("An error occurred while publishing install.", e);
+            }
+
+            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
+            GraphRequest publishRequest = GraphRequest.newPostRequest(null, publishUrl, publishParams, null);
+
+            if (lastPing != 0) {
+                JSONObject graphObject = null;
+                try {
+                    if (lastResponseJSON != null) {
+                        graphObject = new JSONObject(lastResponseJSON);
+                    }
+                }
+                catch (JSONException je) {
+                    // return the default graph object if there is any problem reading the data.
+                }
+                if (graphObject == null) {
+                    return GraphResponse.createResponsesFromString(
+                            "true",
+                            null,
+                            new GraphRequestBatch(publishRequest)
+                    ).get(0);
+                } else {
+                    return new GraphResponse(null, null, null, graphObject);
+                }
+
+            } else {
+
+                GraphResponse publishResponse = publishRequest.executeAndWait();
+
+                // denote success since no error threw from the post.
+                SharedPreferences.Editor editor = preferences.edit();
+                lastPing = System.currentTimeMillis();
+                editor.putLong(pingKey, lastPing);
+
+                // if we got an object response back, cache the string of the JSON.
+                if (publishResponse.getJSONObject() != null) {
+                    editor.putString(jsonKey, publishResponse.getJSONObject().toString());
+                }
+                editor.apply();
+
+                return publishResponse;
+            }
+        } catch (Exception e) {
+            // if there was an error, fall through to the failure case.
+            Utility.logd("Facebook-publish", e);
+            return new GraphResponse(null, null, new FacebookRequestError(null, e));
+        }
+    }
+
+    /**
+     * Returns the current version of the Facebook SDK for Android as a string.
+     *
+     * @return the current version of the SDK
+     */
+    public static String getSdkVersion() {
+        Validate.sdkInitialized();
+        return FacebookSdkVersion.BUILD;
+    }
+
+    /**
+     * Returns whether data such as those generated through AppEventsLogger and sent to Facebook
+     * should be restricted from being used for purposes other than analytics and conversions, such
+     * as targeting ads to this user.  Defaults to false.  This value is stored on the device and
+     * persists across app launches.
+     *
+     * @param context  Used to read the value.
+     */
+    public static boolean getLimitEventAndDataUsage(Context context) {
+        Validate.sdkInitialized();
+        SharedPreferences preferences = context.getSharedPreferences(
+                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
+        return preferences.getBoolean("limitEventUsage", false);
+    }
+
+    /**
+     * Sets whether data such as those generated through AppEventsLogger and sent to Facebook should
+     * be restricted from being used for purposes other than analytics and conversions, such as
+     * targeting ads to this user.  Defaults to false.  This value is stored on the device and
+     * persists across app launches.  Changes to this setting will apply to app events currently
+     * queued to be flushed.
+     *
+     * @param context Used to persist this value across app runs.
+     */
+    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
+        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
+            .edit()
+            .putBoolean("limitEventUsage", limitEventUsage)
+            .apply();
+    }
+
+    /**
+     * Gets the threshold used to report progress on requests.
+     */
+    public static long getOnProgressThreshold() {
+        Validate.sdkInitialized();
+        return onProgressThreshold.get();
+    }
+
+    /**
+     * Sets the threshold used to report progress on requests. Note that the value will be read when
+     * the request is started and cannot be changed during a request (or batch) execution.
+     *
+     * @param threshold The number of bytes progressed to force a callback.
+     */
+    public static void setOnProgressThreshold(long threshold) {
+        onProgressThreshold.set(threshold);
+    }
+
+    // Package private for testing only
+    static void loadDefaultsFromMetadata(Context context) {
+        if (context == null) {
+            return;
+        }
+
+        ApplicationInfo ai = null;
+        try {
+            ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) {
+            return;
+        }
+
+        if (ai == null || ai.metaData == null) {
+            return;
+        }
+
+        if (applicationId == null) {
+            Object appId = ai.metaData.get(APPLICATION_ID_PROPERTY);
+            if (appId instanceof String) {
+                applicationId = (String) appId;
+            } else if (appId instanceof Integer) {
+                applicationId = appId.toString();
+            }
+        }
+
+        if (applicationName == null) {
+            applicationName = ai.metaData.getString(APPLICATION_NAME_PROPERTY);
+        }
+
+        if (appClientToken == null) {
+            appClientToken = ai.metaData.getString(CLIENT_TOKEN_PROPERTY);
+        }
+    }
+
+    /**
+     * Internal call please don't use directly.
+     * @param context The application context.
+     * @return The application signature.
+     */
+    public static String getApplicationSignature(Context context) {
+        Validate.sdkInitialized();
+        if (context == null) {
+            return null;
+        }
+        PackageManager packageManager = context.getPackageManager();
+        if (packageManager == null) {
+            return null;
+        }
+
+        String packageName = context.getPackageName();
+        PackageInfo pInfo;
+        try {
+            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
+        } catch (PackageManager.NameNotFoundException e) {
+            return null;
+        }
+
+        Signature[] signatures = pInfo.signatures;
+        if (signatures == null || signatures.length == 0) {
+            return null;
+        }
+
+        MessageDigest md;
+        try {
+            md = MessageDigest.getInstance("SHA-1");
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        md.update(pInfo.signatures[0].toByteArray());
+        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
+    }
+
+    /**
+     * Gets the Facebook application ID for the current app. This should only be called after the
+     * SDK has been initialized by calling FacebookSdk.sdkInitialize().
+     *
+     * @return the application ID
+     */
+    public static String getApplicationId() {
+        Validate.sdkInitialized();
+        return applicationId;
+    }
+
+    /**
+     * Sets the Facebook application ID for the current app.
+     * @param applicationId the application ID
+     */
+    public static void setApplicationId(String applicationId) {
+        FacebookSdk.applicationId = applicationId;
+    }
+
+    /**
+     * Gets the Facebook application name of the current app. This should only be called after the
+     * SDK has been initialized by calling FacebookSdk.sdkInitialize().
+     *
+     * @return the application name
+     */
+    public static String getApplicationName() {
+        Validate.sdkInitialized();
+        return applicationName;
+    }
+
+    /**
+     * Sets the Facebook application name for the current app.
+     * @param applicationName the application name
+     */
+    public static void setApplicationName(String applicationName) {
+        FacebookSdk.applicationName = applicationName;
+    }
+
+    /**
+     * Gets the client token for the current app. This will be null unless explicitly set or unless
+     * loadDefaultsFromMetadata has been called.
+     * @return the client token
+     */
+    public static String getClientToken() {
+        Validate.sdkInitialized();
+        return appClientToken;
+    }
+
+    /**
+     * Sets the Facebook client token for the current app.
+     * @param clientToken the client token
+     */
+    public static void setClientToken(String clientToken) {
+        appClientToken = clientToken;
+    }
+
+    /**
+     * Gets the cache directory to use for caching responses, etc. The default will be the value
+     * returned by Context.getCacheDir() when the SDK was initialized, but it can be overridden.
+     *
+     * @return the cache directory
+     */
+    public static File getCacheDir() {
+        Validate.sdkInitialized();
+        return cacheDir;
+    }
+
+    /**
+     * Sets the cache directory to use for caching responses, etc.
+     * @param cacheDir the cache directory
+     */
+    public static void setCacheDir(File cacheDir) {
+        FacebookSdk.cacheDir = cacheDir;
+    }
+
+    /**
+     * Getter for the callback request code offset. The request codes starting at this offset and
+     * the next 100 values are used by the Facebook SDK.
+     *
+     * @return The callback request code offset.
+     */
+    public static int getCallbackRequestCodeOffset() {
+        Validate.sdkInitialized();
+        return callbackRequestCodeOffset;
+    }
+
+    /**
+     * Returns true if the request code is within the range used by Facebook SDK requests. This does
+     * not include request codes that you explicitly set on the dialogs, buttons or LoginManager.
+     * The range of request codes that the SDK uses starts at the callbackRequestCodeOffset and
+     * continues for the next 100 values.
+     *
+     * @param requestCode the request code to check.
+     * @return true if the request code is within the range used by the Facebook SDK.
+     */
+    public static boolean isFacebookRequestCode(int requestCode) {
+        return requestCode >= callbackRequestCodeOffset
+                && requestCode < callbackRequestCodeOffset + MAX_REQUEST_CODE_RANGE;
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookSdkNotInitializedException.java b/facebook/src/com/facebook/FacebookSdkNotInitializedException.java
new file mode 100644
index 000000000..14e0c9176
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookSdkNotInitializedException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+/**
+ * An Exception indicating that the Facebook SDK has not been correctly initialized.
+ */
+public class FacebookSdkNotInitializedException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookSdkNotInitializedException with no additional information.
+     */
+    public FacebookSdkNotInitializedException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookSdkNotInitializedException with a message.
+     *
+     * @param message A String to be returned from getMessage.
+     */
+    public FacebookSdkNotInitializedException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookSdkNotInitializedException with a message and inner error.
+     *
+     * @param message   A String to be returned from getMessage.
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookSdkNotInitializedException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookSdkNotInitializedException with an inner error.
+     *
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookSdkNotInitializedException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
index 8973962d3..a31e363f6 100644
--- a/facebook/src/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -1,22 +1,25 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 final class FacebookSdkVersion {
-    public static final String BUILD = "3.7.0";
-    public static final String MIGRATION_BUNDLE = "fbsdk:20131203";
+    public static final String BUILD = "4.1.0";
 }
diff --git a/facebook/src/com/facebook/FacebookServiceException.java b/facebook/src/com/facebook/FacebookServiceException.java
index 0ff4f84f8..709b15fe2 100644
--- a/facebook/src/com/facebook/FacebookServiceException.java
+++ b/facebook/src/com/facebook/FacebookServiceException.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
diff --git a/facebook/src/com/facebook/GetTokenClient.java b/facebook/src/com/facebook/GetTokenClient.java
deleted file mode 100644
index 23cb31bf8..000000000
--- a/facebook/src/com/facebook/GetTokenClient.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-
-import android.content.Context;
-import android.os.*;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.PlatformServiceClient;
-
-final class GetTokenClient extends PlatformServiceClient {
-
-    GetTokenClient(Context context, String applicationId) {
-        super(context, NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REQUEST, NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REPLY,
-                NativeProtocol.PROTOCOL_VERSION_20121101, applicationId);
-    }
-
-    @Override
-    protected void populateRequestBundle(Bundle data) {
-    }
-}
-
diff --git a/facebook/src/com/facebook/GraphRequest.java b/facebook/src/com/facebook/GraphRequest.java
new file mode 100644
index 000000000..302018b3c
--- /dev/null
+++ b/facebook/src/com/facebook/GraphRequest.java
@@ -0,0 +1,2158 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.*;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.Pair;
+
+import com.facebook.internal.*;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * <p>
+ * A single request to be sent to the Facebook Platform through the <a
+ * href="https://developers.facebook.com/docs/reference/api/">Graph API</a>. The Request class
+ * provides functionality relating to serializing and deserializing requests and responses, making
+ * calls in batches (with a single round-trip to the service) and making calls asynchronously.
+ * </p>
+ * <p>
+ * The particular service endpoint that a request targets is determined by a graph path (see the
+ * {@link #setGraphPath(String) setGraphPath} method).
+ * </p>
+ * <p>
+ * A Request can be executed either anonymously or representing an authenticated user. In the former
+ * case, no AccessToken needs to be specified, while in the latter, an AccessToken must be provided.
+ * If requests are executed in a batch, a Facebook application ID must be associated with the batch,
+ * either by setting the application ID in the AndroidManifest.xml or via FacebookSdk or by calling
+ * the {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
+ * </p>
+ * <p>
+ * After completion of a request, the AccessToken, if not null and taken from AccessTokenManager,
+ * will be checked to determine if its Facebook access token needs to be extended; if so, a request
+ * to extend it will be issued in the background.
+ * </p>
+ */
+public class GraphRequest {
+    /**
+     * The maximum number of requests that can be submitted in a single batch. This limit is
+     * enforced on the service side by the Facebook platform, not by the Request class.
+     */
+    public static final int MAXIMUM_BATCH_SIZE = 50;
+
+    public static final String TAG = GraphRequest.class.getSimpleName();
+
+    private static final String VIDEOS_SUFFIX = "/videos";
+    private static final String ME = "me";
+    private static final String MY_FRIENDS = "me/friends";
+    private static final String SEARCH = "search";
+    private static final String USER_AGENT_BASE = "FBAndroidSDK";
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String CONTENT_TYPE_HEADER = "Content-Type";
+    private static final String ACCEPT_LANGUAGE_HEADER = "Accept-Language";
+    private static final String CONTENT_ENCODING_HEADER = "Content-Encoding";
+
+    // Parameter names/values
+    private static final String FORMAT_PARAM = "format";
+    private static final String FORMAT_JSON = "json";
+    private static final String SDK_PARAM = "sdk";
+    private static final String SDK_ANDROID = "android";
+    private static final String ACCESS_TOKEN_PARAM = "access_token";
+    private static final String BATCH_ENTRY_NAME_PARAM = "name";
+    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM =
+            "omit_response_on_success";
+    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
+    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
+    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
+    private static final String BATCH_BODY_PARAM = "body";
+    private static final String BATCH_METHOD_PARAM = "method";
+    private static final String BATCH_PARAM = "batch";
+    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
+    private static final String ATTACHED_FILES_PARAM = "attached_files";
+    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
+    private static final String DEBUG_PARAM = "debug";
+    private static final String DEBUG_SEVERITY_INFO = "info";
+    private static final String DEBUG_SEVERITY_WARNING = "warning";
+    private static final String DEBUG_KEY = "__debug__";
+    private static final String DEBUG_MESSAGES_KEY = "messages";
+    private static final String DEBUG_MESSAGE_KEY = "message";
+    private static final String DEBUG_MESSAGE_TYPE_KEY = "type";
+    private static final String DEBUG_MESSAGE_LINK_KEY = "link";
+
+    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
+
+    private static String defaultBatchApplicationId;
+
+    // Group 1 in the pattern is the path without the version info
+    private static Pattern versionPattern = Pattern.compile("^/?v\\d+\\.\\d+/(.*)");
+
+    private AccessToken accessToken;
+    private HttpMethod httpMethod;
+    private String graphPath;
+    private JSONObject graphObject;
+    private String batchEntryName;
+    private String batchEntryDependsOn;
+    private boolean batchEntryOmitResultOnSuccess = true;
+    private Bundle parameters;
+    private Callback callback;
+    private String overriddenURL;
+    private Object tag;
+    private String version;
+    private boolean skipClientToken = false;
+
+    /**
+     * Constructs a request without an access token, graph path, or any other parameters.
+     */
+    public GraphRequest() {
+        this(null, null, null, null, null);
+    }
+
+    /**
+     * Constructs a request with an access token to retrieve a particular graph path.
+     * An access token need not be provided, in which case the request is sent without an access
+     * token and thus is not executed in the context of any particular user. Only certain graph
+     * requests can be expected to succeed in this case.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve
+     */
+    public GraphRequest(AccessToken accessToken, String graphPath) {
+        this(accessToken, graphPath, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a specific AccessToken, graph path, parameters, and HTTP method. An
+     * access token need not be provided, in which case the request is sent without an access token
+     * and thus is not executed in the context of any particular user. Only certain graph requests
+     * can be expected to succeed in this case.
+     * <p/>
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved,
+     * created, or deleted.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve, create, or delete
+     * @param parameters  additional parameters to pass along with the Graph API request; parameters
+     *                    must be Strings, Numbers, Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod  the {@link HttpMethod} to use for the request, or null for default
+     *                    (HttpMethod.GET)
+     */
+    public GraphRequest(
+            AccessToken accessToken,
+            String graphPath,
+            Bundle parameters,
+            HttpMethod httpMethod) {
+        this(accessToken, graphPath, parameters, httpMethod, null);
+    }
+
+    /**
+     * Constructs a request with a specific access token, graph path, parameters, and HTTP method.
+     * An access token need not be provided, in which case the request is sent without an access
+     * token and thus is not executed in the context of any particular user. Only certain graph\
+     * requests can be expected to succeed in this case.
+     * <p/>
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved,
+     * created, or deleted.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve, create, or delete
+     * @param parameters  additional parameters to pass along with the Graph API request; parameters
+     *                    must be Strings, Numbers, Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod  the {@link HttpMethod} to use for the request, or null for default
+     *                    (HttpMethod.GET)
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     */
+    public GraphRequest(
+            AccessToken accessToken,
+            String graphPath,
+            Bundle parameters,
+            HttpMethod httpMethod,
+            Callback callback) {
+        this(accessToken, graphPath, parameters, httpMethod, callback, null);
+    }
+
+    /**
+     * Constructs a request with a specific access token, graph path, parameters, and HTTP method.
+     * An access token need not be provided, in which case the request is sent without an access
+     * token and thus is not executed in the context of any particular user. Only certain graph
+     * requests can be expected to succeed in this case.
+     * <p/>
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved,
+     * created, or deleted.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve, create, or delete
+     * @param parameters  additional parameters to pass along with the Graph API request; parameters
+     *                    must be Strings, Numbers, Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod  the {@link HttpMethod} to use for the request, or null for default
+     *                    (HttpMethod.GET)
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @param version     the version of the Graph API
+     */
+    public GraphRequest(
+            AccessToken accessToken,
+            String graphPath,
+            Bundle parameters,
+            HttpMethod httpMethod,
+            Callback callback,
+            String version) {
+        this.accessToken = accessToken;
+        this.graphPath = graphPath;
+        this.version = version;
+
+        setCallback(callback);
+        setHttpMethod(httpMethod);
+
+        if (parameters != null) {
+            this.parameters = new Bundle(parameters);
+        } else {
+            this.parameters = new Bundle();
+        }
+
+        if (this.version == null) {
+            this.version = ServerProtocol.getAPIVersion();
+        }
+    }
+
+    GraphRequest(AccessToken accessToken, URL overriddenURL) {
+        this.accessToken = accessToken;
+        this.overriddenURL = overriddenURL.toString();
+
+        setHttpMethod(HttpMethod.GET);
+
+        this.parameters = new Bundle();
+    }
+
+    /**
+     * Creates a new Request configured to delete a resource through the Graph API.
+     *
+     * @param accessToken the access token to use, or null
+     * @param id          the id of the object to delete
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newDeleteObjectRequest(
+            AccessToken accessToken,
+            String id,
+            Callback callback) {
+        return new GraphRequest(accessToken, id, null, HttpMethod.DELETE, callback);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     *
+     * @param accessToken the access token to use, or null
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newMeRequest(
+            AccessToken accessToken,
+            final GraphJSONObjectCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                if (callback != null) {
+                    callback.onCompleted(response.getJSONObject(), response);
+                }
+            }
+        };
+        return new GraphRequest(accessToken, ME, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to post a GraphObject to a particular graph path, to either
+     * create or update the object at that path.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve, create, or delete
+     * @param graphObject the graph object to create or update
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newPostRequest(
+            AccessToken accessToken,
+            String graphPath,
+            JSONObject graphObject,
+            Callback callback) {
+        GraphRequest request = new GraphRequest(
+                accessToken,
+                graphPath,
+                null,
+                HttpMethod.POST,
+                callback);
+        request.setGraphObject(graphObject);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     *
+     * @param accessToken the access token to use, or null
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newMyFriendsRequest(
+            AccessToken accessToken,
+            final GraphJSONArrayCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                if (callback != null) {
+                    JSONObject result = response.getJSONObject();
+                    JSONArray data = result != null ? result.optJSONArray("data") : null;
+                    callback.onCompleted(data, response);
+                }
+            }
+        };
+        return new GraphRequest(accessToken, MY_FRIENDS, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     *
+     * @param accessToken the access token to use, or null
+     * @param graphPath   the graph path to retrieve
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newGraphPathRequest(
+            AccessToken accessToken,
+            String graphPath,
+            Callback callback) {
+        return new GraphRequest(accessToken, graphPath, null, null, callback);
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified
+     * location via the Graph API. At least one of location or searchText must be specified.
+     *
+     * @param accessToken    the access token to use, or null
+     * @param location       the location around which to search; only the latitude and longitude
+     *                       components of the location are meaningful
+     * @param radiusInMeters the radius around the location to search, specified in meters; this is
+     *                       ignored if no location is specified
+     * @param resultsLimit   the maximum number of results to return
+     * @param searchText     optional text to search for as part of the name or type of an object
+     * @param callback       a callback that will be called when the request is completed to handle
+     *                       success or error conditions
+     * @return a Request that is ready to execute
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static GraphRequest newPlacesSearchRequest(
+            AccessToken accessToken,
+            Location location,
+            int radiusInMeters,
+            int resultsLimit,
+            String searchText,
+            final GraphJSONArrayCallback callback) {
+        if (location == null && Utility.isNullOrEmpty(searchText)) {
+            throw new FacebookException("Either location or searchText must be specified.");
+        }
+
+        Bundle parameters = new Bundle(5);
+        parameters.putString("type", "place");
+        parameters.putInt("limit", resultsLimit);
+        if (location != null) {
+            parameters.putString("center",
+                    String.format(
+                            Locale.US,
+                            "%f,%f",
+                            location.getLatitude(),
+                            location.getLongitude()));
+            parameters.putInt("distance", radiusInMeters);
+        }
+        if (!Utility.isNullOrEmpty(searchText)) {
+            parameters.putString("q", searchText);
+        }
+
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                if (callback != null) {
+                    JSONObject result = response.getJSONObject();
+                    JSONArray data = result != null ? result.optJSONArray("data") : null;
+                    callback.onCompleted(data, response);
+                }
+            }
+        };
+
+        return new GraphRequest(accessToken, SEARCH, parameters, HttpMethod.GET, wrapper);
+    }
+
+
+    /**
+     * Creates a new Request configured to retrieve an App User ID for the app's Facebook user.
+     * Callers will send this ID back to their own servers, collect up a set to create a Facebook
+     * Custom Audience with, and then use the resultant Custom Audience to target ads.
+     * <p/>
+     * The GraphObject in the response will include a "custom_audience_third_party_id" property,
+     * with the value being the ID retrieved.  This ID is an encrypted encoding of the Facebook
+     * user's ID and the invoking Facebook app ID.  Multiple calls with the same user will return
+     * different IDs, thus these IDs cannot be used to correlate behavior across devices or
+     * applications, and are only meaningful when sent back to Facebook for creating Custom
+     * Audiences.
+     * <p/>
+     * The ID retrieved represents the Facebook user identified in the following way: if the
+     * specified access token (or active access token if `null`) is valid, the ID will represent the
+     * user associated with the active access token; otherwise the ID will represent the user logged
+     * into the native Facebook app on the device. A `null` ID will be provided into the callback if
+     * a) there is no native Facebook app, b) no one is logged into it, or c) the app has previously
+     * called {@link FacebookSdk#setLimitEventAndDataUsage(android.content.Context, boolean)} ;}
+     * with `true` for this user. <b>You must call this method from a background thread for it to
+     * work properly.</b>
+     *
+     * @param accessToken   the access token to issue the Request on, or null If there is no
+     *                      logged-in Facebook user, null is the expected choice.
+     * @param context       the Application context from which the app ID will be pulled, and from
+     *                      which the 'attribution ID' for the Facebook user is determined.  If
+     *                      there has been no app ID set, an exception will be thrown.
+     * @param applicationId explicitly specified Facebook App ID.  If null, the application ID from
+     *                      the access token will be used, if any; if not, the application ID from
+     *                      metadata will be used.
+     * @param callback      a callback that will be called when the request is completed to handle
+     *                      success or error conditions. The GraphObject in the Response will
+     *                      contain a "custom_audience_third_party_id" property that represents the
+     *                      user as described above.
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newCustomAudienceThirdPartyIdRequest(AccessToken accessToken,
+                                                                    Context context,
+                                                                    String applicationId,
+                                                                    Callback callback) {
+
+        if (applicationId == null && accessToken != null) {
+            applicationId = accessToken.getApplicationId();
+        }
+
+        if (applicationId == null) {
+            applicationId = Utility.getMetadataApplicationId(context);
+        }
+
+        if (applicationId == null) {
+            throw new FacebookException("Facebook App ID cannot be determined");
+        }
+
+        String endpoint = applicationId + "/custom_audience_third_party_id";
+        AttributionIdentifiers attributionIdentifiers =
+                AttributionIdentifiers.getAttributionIdentifiers(context);
+        Bundle parameters = new Bundle();
+
+        if (accessToken == null) {
+            // Only use the attributionID if we don't have an access token.  If we do, then the user
+            // token will be used to identify the user, and is more reliable than the attributionID.
+            String udid = attributionIdentifiers.getAttributionId() != null
+                    ? attributionIdentifiers.getAttributionId()
+                    : attributionIdentifiers.getAndroidAdvertiserId();
+            if (attributionIdentifiers.getAttributionId() != null) {
+                parameters.putString("udid", udid);
+            }
+        }
+
+        // Server will choose to not provide the App User ID in the event that event usage has been
+        // limited for this user for this app.
+        if (FacebookSdk.getLimitEventAndDataUsage(context)
+                || attributionIdentifiers.isTrackingLimited()) {
+            parameters.putString("limit_event_usage", "1");
+        }
+
+        return new GraphRequest(accessToken, endpoint, parameters, HttpMethod.GET, callback);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve an App User ID for the app's Facebook user.
+     * Callers will send this ID back to their own servers, collect up a set to create a Facebook
+     * Custom Audience with, and then use the resultant Custom Audience to target ads.
+     * <p/>
+     * The GraphObject in the response will include a "custom_audience_third_party_id" property,
+     * with the value being the ID retrieved.  This ID is an encrypted encoding of the Facebook
+     * user's ID and the invoking Facebook app ID.  Multiple calls with the same user will return
+     * different IDs, thus these IDs cannot be used to correlate behavior across devices or
+     * applications, and are only meaningful when sent back to Facebook for creating Custom
+     * Audiences.
+     * <p/>
+     * The ID retrieved represents the Facebook user identified in the following way: if the
+     * specified access token (or active access token if `null`) is valid, the ID will represent the
+     * user associated with the active access token; otherwise the ID will represent the user logged
+     * into the native Facebook app on the device. A `null` ID will be provided into the callback if
+     * a) there is no native Facebook app, b) no one is logged into it, or c) the app has previously
+     * called {@link FacebookSdk#setLimitEventAndDataUsage(android.content.Context, boolean)} with
+     * `true` for this user. <b>You must call this method from a background thread for it to work
+     * properly.</b>
+     *
+     * @param accessToken the access token to issue the Request on, or null If there is no logged-in
+     *                    Facebook user, null is the expected choice.
+     * @param context     the Application context from which the app ID will be pulled, and from
+     *                    which the 'attribution ID' for the Facebook user is determined.  If there
+     *                    has been no app ID set, an exception will be thrown.
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions. The GraphObject in the Response will contain
+     *                    a "custom_audience_third_party_id" property that represents the user as
+     *                    described above.
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newCustomAudienceThirdPartyIdRequest(
+            AccessToken accessToken,
+            Context context,
+            Callback callback) {
+        return newCustomAudienceThirdPartyIdRequest(accessToken, context, null, callback);
+    }
+
+    /**
+     * Returns the GraphObject, if any, associated with this request.
+     *
+     * @return the GraphObject associated with this request, or null if there is none
+     */
+    public final JSONObject getGraphObject() {
+        return this.graphObject;
+    }
+
+    /**
+     * Sets the GraphObject associated with this request. This is meaningful only for POST
+     * requests.
+     *
+     * @param graphObject the GraphObject to upload along with this request
+     */
+    public final void setGraphObject(JSONObject graphObject) {
+        this.graphObject = graphObject;
+    }
+
+    /**
+     * Returns the graph path of this request, if any.
+     *
+     * @return the graph path of this request, or null if there is none
+     */
+    public final String getGraphPath() {
+        return this.graphPath;
+    }
+
+    /**
+     * Sets the graph path of this request.
+     *
+     * @param graphPath the graph path for this request
+     */
+    public final void setGraphPath(String graphPath) {
+        this.graphPath = graphPath;
+    }
+
+    /**
+     * Returns the {@link HttpMethod} to use for this request.
+     *
+     * @return the HttpMethod
+     */
+    public final HttpMethod getHttpMethod() {
+        return this.httpMethod;
+    }
+
+    /**
+     * Sets the {@link HttpMethod} to use for this request.
+     *
+     * @param httpMethod the HttpMethod, or null for the default (HttpMethod.GET).
+     */
+    public final void setHttpMethod(HttpMethod httpMethod) {
+        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
+            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
+        }
+        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
+    }
+
+    /**
+     * Returns the version of the API that this request will use.  By default this is the current
+     * API at the time the SDK is released.
+     *
+     * @return the version that this request will use
+     */
+    public final String getVersion() {
+        return this.version;
+    }
+
+    /**
+     * Set the version to use for this request.  By default the version will be the current API at
+     * the time the SDK is released.  Only use this if you need to explicitly override.
+     *
+     * @param version The version to use.  Should look like "v2.0"
+     */
+    public final void setVersion(String version) {
+        this.version = version;
+    }
+
+    /**
+     * This is an internal function that is not meant to be used by developers.
+     */
+    public final void setSkipClientToken(boolean skipClientToken) {
+        this.skipClientToken = skipClientToken;
+    }
+
+    /**
+     * Returns the parameters for this request.
+     *
+     * @return the parameters
+     */
+    public final Bundle getParameters() {
+        return this.parameters;
+    }
+
+    /**
+     * Sets the parameters for this request.
+     *
+     * @param parameters the parameters
+     */
+    public final void setParameters(Bundle parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Returns the access token associated with this request.
+     *
+     * @return the access token associated with this request, or null if none has been specified
+     */
+    public final AccessToken getAccessToken() {
+        return this.accessToken;
+    }
+
+    /**
+     * Sets the access token to use for this request.
+     *
+     * @param accessToken the access token to use for this request
+     */
+    public final void setAccessToken(AccessToken accessToken) {
+        this.accessToken = accessToken;
+    }
+
+    /**
+     * Returns the name of this requests entry in a batched request.
+     *
+     * @return the name of this requests batch entry, or null if none has been specified
+     */
+    public final String getBatchEntryName() {
+        return this.batchEntryName;
+    }
+
+    /**
+     * Sets the name of this request's entry in a batched request. This value is only used if this
+     * request is submitted as part of a batched request. It can be used to specified dependencies
+     * between requests.
+     * See <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in
+     * the Graph API documentation for more details.
+     *
+     * @param batchEntryName the name of this requests entry in a batched request, which must be
+     *                       unique within a particular batch of requests
+     */
+    public final void setBatchEntryName(String batchEntryName) {
+        this.batchEntryName = batchEntryName;
+    }
+
+    /**
+     * Returns the name of the request that this request entry explicitly depends on in a batched
+     * request.
+     *
+     * @return the name of this requests dependency, or null if none has been specified
+     */
+    public final String getBatchEntryDependsOn() {
+        return this.batchEntryDependsOn;
+    }
+
+    /**
+     * Sets the name of the request entry that this request explicitly depends on in a batched
+     * request. This value is only used if this request is submitted as part of a batched request.
+     * It can be used to specified dependencies between requests. See <a
+     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the
+     * Graph API documentation for more details.
+     *
+     * @param batchEntryDependsOn the name of the request entry that this entry depends on in a
+     *                            batched request
+     */
+    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
+        this.batchEntryDependsOn = batchEntryDependsOn;
+    }
+
+
+    /**
+     * Returns whether or not this batch entry will return a response if it is successful. Only
+     * applies if another request entry in the batch specifies this entry as a dependency.
+     *
+     * @return the name of this requests dependency, or null if none has been specified
+     */
+    public final boolean getBatchEntryOmitResultOnSuccess() {
+        return this.batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Sets whether or not this batch entry will return a response if it is successful. Only applies
+     * if another request entry in the batch specifies this entry as a dependency. See <a
+     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the
+     * Graph API documentation for more details.
+     *
+     * @param batchEntryOmitResultOnSuccess the name of the request entry that this entry depends on
+     *                                      in a batched request
+     */
+    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
+        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Gets the default Facebook application ID that will be used to submit batched requests.
+     * Batched requests require an application ID, so either at least one request in a batch must
+     * provide an access token or the application ID must be specified explicitly.
+     *
+     * @return the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final String getDefaultBatchApplicationId() {
+        return GraphRequest.defaultBatchApplicationId;
+    }
+
+    /**
+     * Sets the default application ID that will be used to submit batched requests if none of those
+     * requests specifies an access token. Batched requests require an application ID, so either at
+     * least one request in a batch must specify an access token or the application ID must be
+     * specified explicitly.
+     *
+     * @param applicationId the Facebook application ID to use for batched requests if none can
+     *                      be determined
+     */
+    public static final void setDefaultBatchApplicationId(String applicationId) {
+        defaultBatchApplicationId = applicationId;
+    }
+
+    /**
+     * Returns the callback which will be called when the request finishes.
+     *
+     * @return the callback
+     */
+    public final Callback getCallback() {
+        return callback;
+    }
+
+    /**
+     * Sets the callback which will be called when the request finishes.
+     *
+     * @param callback the callback
+     */
+    public final void setCallback(final Callback callback) {
+        // Wrap callback to parse debug response if Graph Debug Mode is Enabled.
+        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)
+                || FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
+            Callback wrapper = new Callback() {
+                @Override
+                public void onCompleted(GraphResponse response) {
+                    JSONObject responseObject = response.getJSONObject();
+                    JSONObject debug =
+                            responseObject != null ? responseObject.optJSONObject(DEBUG_KEY) : null;
+                    JSONArray debugMessages =
+                            debug != null ? debug.optJSONArray(DEBUG_MESSAGES_KEY) : null;
+                    if (debugMessages != null) {
+                        for (int i = 0; i < debugMessages.length(); ++i) {
+                            JSONObject debugMessageObject = debugMessages.optJSONObject(i);
+                            String debugMessage = debugMessageObject != null
+                                    ? debugMessageObject.optString(DEBUG_MESSAGE_KEY)
+                                    : null;
+                            String debugMessageType = debugMessageObject != null
+                                    ? debugMessageObject.optString(DEBUG_MESSAGE_TYPE_KEY)
+                                    : null;
+                            String debugMessageLink = debugMessageObject != null
+                                    ? debugMessageObject.optString(DEBUG_MESSAGE_LINK_KEY)
+                                    : null;
+                            if (debugMessage != null && debugMessageType != null) {
+                                LoggingBehavior behavior = LoggingBehavior.GRAPH_API_DEBUG_INFO;
+                                if (debugMessageType.equals("warning")) {
+                                    behavior = LoggingBehavior.GRAPH_API_DEBUG_WARNING;
+                                }
+                                if (!Utility.isNullOrEmpty(debugMessageLink)) {
+                                    debugMessage += " Link: " + debugMessageLink;
+                                }
+                                Logger.log(behavior, TAG, debugMessage);
+                            }
+                        }
+                    }
+                    if (callback != null) {
+                        callback.onCompleted(response);
+                    }
+                }
+            };
+            this.callback = wrapper;
+        } else {
+            this.callback = callback;
+        }
+
+    }
+
+    /**
+     * Sets the tag on the request; this is an application-defined object that can be used to
+     * distinguish between different requests. Its value has no effect on the execution of the
+     * request.
+     *
+     * @param tag an object to serve as a tag, or null
+     */
+    public final void setTag(Object tag) {
+        this.tag = tag;
+    }
+
+    /**
+     * Gets the tag on the request; this is an application-defined object that can be used to
+     * distinguish between different requests. Its value has no effect on the execution of the
+     * request.
+     *
+     * @return an object that serves as a tag, or null
+     */
+    public final Object getTag() {
+        return tag;
+    }
+
+    /**
+     * Executes this request on the current thread and blocks while waiting for the response.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @return the Response object representing the results of the request
+     * @throws FacebookException        If there was an error in the protocol used to communicate
+     * with the service
+     * @throws IllegalArgumentException
+     */
+    public final GraphResponse executeAndWait() {
+        return GraphRequest.executeAndWait(this);
+    }
+
+    /**
+     * Executes the request asynchronously. This function will return immediately,
+     * and the request will be processed on a separate thread. In order to process result of a
+     * request, or determine whether a request succeeded or failed, a callback must be specified
+     * (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     * @throws IllegalArgumentException
+     */
+    public final GraphRequestAsyncTask executeAsync() {
+        return GraphRequest.executeBatchAsync(this);
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection
+     * can be executed explicitly by the caller.
+     *
+     * @param requests one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     * @throws FacebookException        If any of the requests in the batch are badly constructed or
+     *                                  if there are problems contacting the service
+     * @throws IllegalArgumentException if the passed in array is zero-length
+     * @throws NullPointerException     if the passed in array or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(GraphRequest... requests) {
+        return toHttpConnection(Arrays.asList(requests));
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection
+     * can be executed explicitly by the caller.
+     *
+     * @param requests one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     * @throws FacebookException        If any of the requests in the batch are badly constructed or
+     *                                  if there are problems contacting the service
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException     if the passed in collection or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Collection<GraphRequest> requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        return toHttpConnection(new GraphRequestBatch(requests));
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection
+     * can be executed explicitly by the caller.
+     *
+     * @param requests a RequestBatch to serialize
+     * @return an HttpURLConnection which is ready to execute
+     * @throws FacebookException        If any of the requests in the batch are badly constructed or
+     *                                  if there are problems contacting the service
+     * @throws IllegalArgumentException
+     */
+    public static HttpURLConnection toHttpConnection(GraphRequestBatch requests) {
+
+        URL url;
+        try {
+            if (requests.size() == 1) {
+                // Single request case.
+                GraphRequest request = requests.get(0);
+                // In the non-batch case, the URL we use really is the same one returned by
+                // getUrlForSingleRequest.
+                url = new URL(request.getUrlForSingleRequest());
+            } else {
+                // Batch case -- URL is just the graph API base, individual request URLs are
+                // serialized as relative_url parameters within each batch entry.
+                url = new URL(ServerProtocol.getGraphUrlBase());
+            }
+        } catch (MalformedURLException e) {
+            throw new FacebookException("could not construct URL for request", e);
+        }
+
+        HttpURLConnection connection;
+        try {
+            connection = createConnection(url);
+
+            serializeToUrlConnection(requests, connection);
+        } catch (IOException e) {
+            throw new FacebookException("could not construct request body", e);
+        } catch (JSONException e) {
+            throw new FacebookException("could not construct request body", e);
+        }
+
+        return connection;
+    }
+
+    /**
+     * Executes a single request on the current thread and blocks while waiting for the response.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param request the Request to execute
+     * @return the Response object representing the results of the request
+     * @throws FacebookException If there was an error in the protocol used to communicate with the
+     *                           service
+     */
+    public static GraphResponse executeAndWait(GraphRequest request) {
+        List<GraphResponse> responses = executeBatchAndWait(request);
+
+        if (responses == null || responses.size() != 1) {
+            throw new FacebookException("invalid state: expected a single response");
+        }
+
+        return responses.get(0);
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and blocks while waiting for the
+     * response.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests the Requests to execute
+     * @return a list of Response objects representing the results of the requests; responses are
+     * returned in the same order as the requests were specified.
+     * @throws NullPointerException In case of a null request
+     * @throws FacebookException    If there was an error in the protocol used to communicate with
+     *                              the service
+     */
+    public static List<GraphResponse> executeBatchAndWait(GraphRequest... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAndWait(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch on the current thread and blocks while waiting for the
+     * responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests the Requests to execute
+     * @return a list of Response objects representing the results of the requests; responses are
+     * returned in the same order as the requests were specified.
+     * @throws FacebookException If there was an error in the protocol used to communicate with the
+     *                           service
+     */
+    public static List<GraphResponse> executeBatchAndWait(Collection<GraphRequest> requests) {
+        return executeBatchAndWait(new GraphRequestBatch(requests));
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and blocks while waiting for the
+     * responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests the batch of Requests to execute
+     * @return a list of Response objects representing the results of the requests; responses are
+     * returned in the same order as the requests were specified.
+     * @throws FacebookException        If there was an error in the protocol used to communicate
+     *                                  with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException     if the passed in RequestBatch or any of its contents are
+     *                                  null
+     */
+    public static List<GraphResponse> executeBatchAndWait(GraphRequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        HttpURLConnection connection = null;
+        try {
+            connection = toHttpConnection(requests);
+        } catch (Exception ex) {
+            List<GraphResponse> responses = GraphResponse.constructErrorResponses(
+                    requests.getRequests(),
+                    null,
+                    new FacebookException(ex));
+            runCallbacks(requests, responses);
+            return responses;
+        }
+
+        List<GraphResponse> responses = executeConnectionAndWait(connection, requests);
+        return responses;
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately,
+     * and the requests will be processed on a separate thread. In order to process results of a
+     * request, or determine whether a request succeeded or failed, a callback must be specified
+     * (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     * @throws NullPointerException If a null request is passed in
+     */
+    public static GraphRequestAsyncTask executeBatchAsync(GraphRequest... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAsync(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately,
+     * and the requests will be processed on a separate thread. In order to process results of a
+     * request, or determine whether a request succeeded or failed, a callback must be specified
+     * (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException     if the passed in collection or any of its contents are null
+     */
+    public static GraphRequestAsyncTask executeBatchAsync(Collection<GraphRequest> requests) {
+        return executeBatchAsync(new GraphRequestBatch(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately,
+     * and the requests will be processed on a separate thread. In order to process results of a
+     * request, or determine whether a request succeeded or failed, a callback must be specified
+     * (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests the RequestBatch to execute
+     * @return a RequestAsyncTask that is executing the request
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException     if the passed in RequestBatch or any of its contents are
+     *                                  null
+     */
+    public static GraphRequestAsyncTask executeBatchAsync(GraphRequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(requests);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation
+     * is done that the contents of the connection actually reflect the serialized requests, so it
+     * is the caller's responsibility to ensure that it will correctly generate the desired
+     * responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection the HttpURLConnection that the requests were serialized into
+     * @param requests   the requests represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     * @throws FacebookException If there was an error in the protocol used to communicate with the
+     *                           service
+     */
+    public static List<GraphResponse> executeConnectionAndWait(
+            HttpURLConnection connection,
+            Collection<GraphRequest> requests) {
+        return executeConnectionAndWait(connection, new GraphRequestBatch(requests));
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation
+     * is done that the contents of the connection actually reflect the serialized requests, so it
+     * is the caller's responsibility to ensure that it will correctly generate the desired
+     * responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection the HttpURLConnection that the requests were serialized into
+     * @param requests   the RequestBatch represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     * @throws FacebookException If there was an error in the protocol used to communicate with the
+     *                           service
+     */
+    public static List<GraphResponse> executeConnectionAndWait(
+            HttpURLConnection connection,
+            GraphRequestBatch requests) {
+        List<GraphResponse> responses = GraphResponse.fromHttpConnection(connection, requests);
+
+        Utility.disconnectQuietly(connection);
+
+        int numRequests = requests.size();
+        if (numRequests != responses.size()) {
+            throw new FacebookException(
+                    String.format(Locale.US,
+                            "Received %d responses while expecting %d",
+                            responses.size(),
+                            numRequests));
+        }
+
+        runCallbacks(requests, responses);
+
+        // Try extending the current access token in case it's needed.
+        AccessTokenManager.getInstance().extendAccessTokenIfNeeded();
+
+        return responses;
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection.
+     * No validation is done that the contents of the connection actually reflect the serialized
+     * requests, so it is the caller's responsibility to ensure that it will correctly generate the
+     * desired responses. This function will return immediately, and the requests will be processed
+     * on a separate thread. In order to process results of a request, or determine whether a
+     * request succeeded or failed, a callback must be specified (see the {@link
+     * #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param connection the HttpURLConnection that the requests were serialized into
+     * @param requests   the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static GraphRequestAsyncTask executeConnectionAsync(
+            HttpURLConnection connection,
+            GraphRequestBatch requests) {
+        return executeConnectionAsync(null, connection, requests);
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection.
+     * No validation is done that the contents of the connection actually reflect the serialized
+     * requests, so it is the caller's responsibility to ensure that it will correctly generate the
+     * desired responses. This function will return immediately, and the requests will be processed
+     * on a separate thread. In order to process results of a request, or determine whether a
+     * request succeeded or failed, a callback must be specified (see the {@link
+     * #setCallback(Callback) setCallback} method)
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param callbackHandler a Handler that will be used to post calls to the callback for each
+     *                        request; if null, a Handler will be instantiated on the calling
+     *                        thread
+     * @param connection      the HttpURLConnection that the requests were serialized into
+     * @param requests        the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static GraphRequestAsyncTask executeConnectionAsync(
+            Handler callbackHandler,
+            HttpURLConnection connection,
+            GraphRequestBatch requests) {
+        Validate.notNull(connection, "connection");
+
+        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(connection, requests);
+        requests.setCallbackHandler(callbackHandler);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Returns a string representation of this Request, useful for debugging.
+     *
+     * @return the debugging information
+     */
+    @Override
+    public String toString() {
+        return new StringBuilder()
+                .append("{Request: ")
+                .append(" accessToken: ")
+                .append(accessToken == null ? "null" : accessToken)
+                .append(", graphPath: ")
+                .append(graphPath)
+                .append(", graphObject: ")
+                .append(graphObject)
+                .append(", httpMethod: ")
+                .append(httpMethod)
+                .append(", parameters: ")
+                .append(parameters)
+                .append("}")
+                .toString();
+    }
+
+    static void runCallbacks(final GraphRequestBatch requests, List<GraphResponse> responses) {
+        int numRequests = requests.size();
+
+        // Compile the list of callbacks to call and then run them either on this thread or via the
+        // Handler we received
+        final ArrayList<Pair<Callback, GraphResponse>> callbacks = new ArrayList<Pair<Callback, GraphResponse>>();
+        for (int i = 0; i < numRequests; ++i) {
+            GraphRequest request = requests.get(i);
+            if (request.callback != null) {
+                callbacks.add(
+                        new Pair<Callback, GraphResponse>(request.callback, responses.get(i)));
+            }
+        }
+
+        if (callbacks.size() > 0) {
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    for (Pair<Callback, GraphResponse> pair : callbacks) {
+                        pair.first.onCompleted(pair.second);
+                    }
+
+                    List<GraphRequestBatch.Callback> batchCallbacks = requests.getCallbacks();
+                    for (GraphRequestBatch.Callback batchCallback : batchCallbacks) {
+                        batchCallback.onBatchCompleted(requests);
+                    }
+                }
+            };
+
+            Handler callbackHandler = requests.getCallbackHandler();
+            if (callbackHandler == null) {
+                // Run on this thread.
+                runnable.run();
+            } else {
+                // Post to the handler.
+                callbackHandler.post(runnable);
+            }
+        }
+    }
+
+    private static HttpURLConnection createConnection(URL url) throws IOException {
+        HttpURLConnection connection;
+        connection = (HttpURLConnection) url.openConnection();
+
+        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
+        connection.setRequestProperty(ACCEPT_LANGUAGE_HEADER, Locale.getDefault().toString());
+
+        connection.setChunkedStreamingMode(0);
+        return connection;
+    }
+
+
+    private void addCommonParameters() {
+        if (this.accessToken != null) {
+            if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+                String token = accessToken.getToken();
+                Logger.registerAccessToken(token);
+                this.parameters.putString(ACCESS_TOKEN_PARAM, token);
+            }
+        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+            String appID = FacebookSdk.getApplicationId();
+            String clientToken = FacebookSdk.getClientToken();
+            if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
+                String accessToken = appID + "|" + clientToken;
+                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+            } else {
+                Log.d(TAG, "Warning: Request without access token missing application ID or" +
+                        " client token.");
+            }
+        }
+        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
+        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
+
+        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)) {
+            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_INFO);
+        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
+            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_WARNING);
+        }
+    }
+
+    private String appendParametersToBaseUrl(String baseUrl) {
+        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);
+
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+
+            if (value == null) {
+                value = "";
+            }
+
+            if (isSupportedParameterType(value)) {
+                value = parameterToString(value);
+            } else {
+                if (httpMethod == HttpMethod.GET) {
+                    throw new IllegalArgumentException(
+                            String.format(
+                                    Locale.US,
+                                    "Unsupported parameter type for GET request: %s",
+                                    value.getClass().getSimpleName()));
+                }
+                continue;
+            }
+
+            uriBuilder.appendQueryParameter(key, value.toString());
+        }
+
+        return uriBuilder.toString();
+    }
+
+    final String getUrlForBatchedRequest() {
+        if (overriddenURL != null) {
+            throw new FacebookException("Can't override URL for a batch request");
+        }
+
+        String baseUrl = getGraphPathWithVersion();
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+    final String getUrlForSingleRequest() {
+        if (overriddenURL != null) {
+            return overriddenURL.toString();
+        }
+
+        String graphBaseUrlBase;
+        if (this.getHttpMethod() == HttpMethod.POST
+                && graphPath != null
+                && graphPath.endsWith(VIDEOS_SUFFIX)) {
+            graphBaseUrlBase = ServerProtocol.getGraphVideoUrlBase();
+        } else {
+            graphBaseUrlBase = ServerProtocol.getGraphUrlBase();
+        }
+        String baseUrl = String.format("%s/%s", graphBaseUrlBase, getGraphPathWithVersion());
+
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+    private String getGraphPathWithVersion() {
+        Matcher matcher = versionPattern.matcher(this.graphPath);
+        if (matcher.matches()) {
+            return this.graphPath;
+        }
+        return String.format("%s/%s", this.version, this.graphPath);
+    }
+
+    private static class Attachment {
+        private final GraphRequest request;
+        private final Object value;
+
+        public Attachment(GraphRequest request, Object value) {
+            this.request = request;
+            this.value = value;
+        }
+
+        public GraphRequest getRequest() {
+            return request;
+        }
+
+        public Object getValue() {
+            return value;
+        }
+    }
+
+    private void serializeToBatch(
+            JSONArray batch,
+            Map<String, Attachment> attachments
+    ) throws JSONException, IOException {
+        JSONObject batchEntry = new JSONObject();
+
+        if (this.batchEntryName != null) {
+            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
+            batchEntry.put(
+                    BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM,
+                    this.batchEntryOmitResultOnSuccess);
+        }
+        if (this.batchEntryDependsOn != null) {
+            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
+        }
+
+        String relativeURL = getUrlForBatchedRequest();
+        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
+        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
+        if (this.accessToken != null) {
+            String token = this.accessToken.getToken();
+            Logger.registerAccessToken(token);
+        }
+
+        // Find all of our attachments. Remember their names and put them in the attachment map.
+        ArrayList<String> attachmentNames = new ArrayList<String>();
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+            if (isSupportedAttachmentType(value)) {
+                // Make the name unique across this entire batch.
+                String name = String.format(
+                        Locale.ROOT,
+                        "%s%d",
+                        ATTACHMENT_FILENAME_PREFIX,
+                        attachments.size());
+                attachmentNames.add(name);
+                attachments.put(name, new Attachment(this, value));
+            }
+        }
+
+        if (!attachmentNames.isEmpty()) {
+            String attachmentNamesString = TextUtils.join(",", attachmentNames);
+            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
+        }
+
+        if (this.graphObject != null) {
+            // Serialize the graph object into the "body" parameter.
+            final ArrayList<String> keysAndValues = new ArrayList<String>();
+            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
+                @Override
+                public void writeString(String key, String value) throws IOException {
+                    keysAndValues.add(String.format(
+                            Locale.US,
+                            "%s=%s",
+                            key,
+                            URLEncoder.encode(value, "UTF-8")));
+                }
+            });
+            String bodyValue = TextUtils.join("&", keysAndValues);
+            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
+        }
+
+        batch.put(batchEntry);
+    }
+
+    private static boolean hasOnProgressCallbacks(GraphRequestBatch requests) {
+        for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
+            if (callback instanceof GraphRequestBatch.OnProgressCallback) {
+                return true;
+            }
+        }
+
+        for (GraphRequest request : requests) {
+            if (request.getCallback() instanceof OnProgressCallback) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static void setConnectionContentType(
+            HttpURLConnection connection,
+            boolean shouldUseGzip) {
+        if (shouldUseGzip) {
+            connection.setRequestProperty(CONTENT_TYPE_HEADER, "application/x-www-form-urlencoded");
+            connection.setRequestProperty(CONTENT_ENCODING_HEADER, "gzip");
+        } else {
+            connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
+        }
+    }
+
+    private static boolean isGzipCompressible(GraphRequestBatch requests) {
+        for (GraphRequest request : requests) {
+            for (String key : request.parameters.keySet()) {
+                Object value = request.parameters.get(key);
+                if (isSupportedAttachmentType(value)) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    final static void serializeToUrlConnection(
+            GraphRequestBatch requests,
+            HttpURLConnection connection
+    ) throws IOException, JSONException {
+        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");
+
+        int numRequests = requests.size();
+        boolean shouldUseGzip = isGzipCompressible(requests);
+
+        HttpMethod connectionHttpMethod =
+                (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
+        connection.setRequestMethod(connectionHttpMethod.name());
+        setConnectionContentType(connection, shouldUseGzip);
+
+        URL url = connection.getURL();
+        logger.append("Request:\n");
+        logger.appendKeyValue("Id", requests.getId());
+        logger.appendKeyValue("URL", url);
+        logger.appendKeyValue("Method", connection.getRequestMethod());
+        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
+        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));
+
+        connection.setConnectTimeout(requests.getTimeout());
+        connection.setReadTimeout(requests.getTimeout());
+
+        // If we have a single non-POST request, don't try to serialize anything or
+        // HttpURLConnection will turn it into a POST.
+        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
+        if (!isPost) {
+            logger.log();
+            return;
+        }
+
+        connection.setDoOutput(true);
+
+        OutputStream outputStream = null;
+        try {
+            outputStream = new BufferedOutputStream(connection.getOutputStream());
+            if (shouldUseGzip) {
+                outputStream = new GZIPOutputStream(outputStream);
+            }
+
+            if (hasOnProgressCallbacks(requests)) {
+                ProgressNoopOutputStream countingStream = null;
+                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
+                processRequest(requests, null, numRequests, url, countingStream, shouldUseGzip);
+
+                int max = countingStream.getMaxProgress();
+                Map<GraphRequest, RequestProgress> progressMap = countingStream.getProgressMap();
+
+                outputStream = new ProgressOutputStream(outputStream, requests, progressMap, max);
+            }
+
+            processRequest(requests, logger, numRequests, url, outputStream, shouldUseGzip);
+        } finally {
+            if (outputStream != null) {
+                outputStream.close();
+            }
+        }
+
+        logger.log();
+    }
+
+    private static void processRequest(GraphRequestBatch requests, Logger logger, int numRequests,
+                                       URL url, OutputStream outputStream, boolean shouldUseGzip)
+            throws IOException, JSONException {
+        Serializer serializer = new Serializer(outputStream, logger, shouldUseGzip);
+
+        if (numRequests == 1) {
+            GraphRequest request = requests.get(0);
+
+            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
+            for (String key : request.parameters.keySet()) {
+                Object value = request.parameters.get(key);
+                if (isSupportedAttachmentType(value)) {
+                    attachments.put(key, new Attachment(request, value));
+                }
+            }
+
+            if (logger != null) {
+                logger.append("  Parameters:\n");
+            }
+            serializeParameters(request.parameters, serializer, request);
+
+            if (logger != null) {
+                logger.append("  Attachments:\n");
+            }
+            serializeAttachments(attachments, serializer);
+
+            if (request.graphObject != null) {
+                processGraphObject(request.graphObject, url.getPath(), serializer);
+            }
+        } else {
+            String batchAppID = getBatchAppId(requests);
+            if (Utility.isNullOrEmpty(batchAppID)) {
+                throw new FacebookException(
+                        "App ID was not specified at the request or Settings.");
+            }
+
+            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);
+
+            // We write out all the requests as JSON, remembering which file attachments they have,
+            // then write out the attachments.
+            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
+            serializeRequestsAsJSON(serializer, requests, attachments);
+
+            if (logger != null) {
+                logger.append("  Attachments:\n");
+            }
+            serializeAttachments(attachments, serializer);
+        }
+    }
+
+    private static boolean isMeRequest(String path) {
+        Matcher matcher = versionPattern.matcher(path);
+        if (matcher.matches()) {
+            // Group 1 contains the path aside from version
+            path = matcher.group(1);
+        }
+        if (path.startsWith("me/") || path.startsWith("/me/")) {
+            return true;
+        }
+        return false;
+    }
+
+    private static void processGraphObject(
+            JSONObject graphObject,
+            String path,
+            KeyValueSerializer serializer
+    ) throws IOException {
+        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
+        // we need to pass the entire values of the contents of the 'image' property, as they
+        // contain important metadata beyond just a URL. We don't have a 100% foolproof way of
+        // knowing if we are posting an OG Action, given that batched requests can have parameter
+        // substitution, but passing the OG Action type as a substituted parameter is unlikely.
+        // It looks like an OG Action if it's posted to me/namespace:action[?other=stuff].
+        boolean isOGAction = false;
+        if (isMeRequest(path)) {
+            int colonLocation = path.indexOf(":");
+            int questionMarkLocation = path.indexOf("?");
+            isOGAction = colonLocation > 3
+                    && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
+        }
+
+        Iterator<String> keyIterator = graphObject.keys();
+        while (keyIterator.hasNext()) {
+            String key = keyIterator.next();
+            Object value = graphObject.opt(key);
+            boolean passByValue = isOGAction && key.equalsIgnoreCase("image");
+            processGraphObjectProperty(key, value, serializer, passByValue);
+        }
+    }
+
+    private static void processGraphObjectProperty(
+            String key,
+            Object value,
+            KeyValueSerializer serializer,
+            boolean passByValue
+    ) throws IOException {
+        Class<?> valueClass = value.getClass();
+
+        if (JSONObject.class.isAssignableFrom(valueClass)) {
+            JSONObject jsonObject = (JSONObject) value;
+            if (passByValue) {
+                // We need to pass all properties of this object in key[propertyName] format.
+                @SuppressWarnings("unchecked")
+                Iterator<String> keys = jsonObject.keys();
+                while (keys.hasNext()) {
+                    String propertyName = keys.next();
+                    String subKey = String.format("%s[%s]", key, propertyName);
+                    processGraphObjectProperty(
+                            subKey,
+                            jsonObject.opt(propertyName),
+                            serializer,
+                            passByValue);
+                }
+            } else {
+                // Normal case is passing objects by reference, so just pass the ID or URL, if any,
+                // as the value for "key"
+                if (jsonObject.has("id")) {
+                    processGraphObjectProperty(
+                            key,
+                            jsonObject.optString("id"),
+                            serializer,
+                            passByValue);
+                } else if (jsonObject.has("url")) {
+                    processGraphObjectProperty(
+                            key,
+                            jsonObject.optString("url"),
+                            serializer,
+                            passByValue);
+                } else if (jsonObject.has(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
+                    processGraphObjectProperty(key, jsonObject.toString(), serializer, passByValue);
+                }
+            }
+        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
+            JSONArray jsonArray = (JSONArray) value;
+            int length = jsonArray.length();
+            for (int i = 0; i < length; ++i) {
+                String subKey = String.format(Locale.ROOT, "%s[%d]", key, i);
+                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
+            }
+        } else if (String.class.isAssignableFrom(valueClass) ||
+                Number.class.isAssignableFrom(valueClass) ||
+                Boolean.class.isAssignableFrom(valueClass)) {
+            serializer.writeString(key, value.toString());
+        } else if (Date.class.isAssignableFrom(valueClass)) {
+            Date date = (Date) value;
+            // The "Events Timezone" platform migration affects what date/time formats Facebook
+            // accepts and returns. Apps created after 8/1/12 (or apps that have explicitly enabled
+            // the migration) should send/receive dates in ISO-8601 format. Pre-migration apps can
+            // send as Unix timestamps. Since the future is ISO-8601, that is what we support here.
+            // Apps that need pre-migration behavior can explicitly send these as integer timestamps
+            // rather than Dates.
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
+                    ISO_8601_FORMAT_STRING,
+                    Locale.US);
+            serializer.writeString(key, iso8601DateFormat.format(date));
+        }
+    }
+
+    private static void serializeParameters(
+            Bundle bundle,
+            Serializer serializer,
+            GraphRequest request
+    ) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (isSupportedParameterType(value)) {
+                serializer.writeObject(key, value, request);
+            }
+        }
+    }
+
+    private static void serializeAttachments(
+            Map<String, Attachment> attachments,
+            Serializer serializer
+    ) throws IOException {
+        Set<String> keys = attachments.keySet();
+
+        for (String key : keys) {
+            Attachment attachment = attachments.get(key);
+            if (isSupportedAttachmentType(attachment.getValue())) {
+                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
+            }
+        }
+    }
+
+    private static void serializeRequestsAsJSON(
+            Serializer serializer,
+            Collection<GraphRequest> requests,
+            Map<String, Attachment> attachments
+    ) throws JSONException, IOException {
+        JSONArray batch = new JSONArray();
+        for (GraphRequest request : requests) {
+            request.serializeToBatch(batch, attachments);
+        }
+
+        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
+    }
+
+    private static String getMimeContentType() {
+        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
+    }
+
+    private static volatile String userAgent;
+
+    private static String getUserAgent() {
+        if (userAgent == null) {
+            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);
+        }
+
+        return userAgent;
+    }
+
+    private static String getBatchAppId(GraphRequestBatch batch) {
+        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
+            return batch.getBatchApplicationId();
+        }
+
+        for (GraphRequest request : batch) {
+            AccessToken accessToken = request.accessToken;
+            if (accessToken != null) {
+                String applicationId = accessToken.getApplicationId();
+                if (applicationId != null) {
+                    return applicationId;
+                }
+            }
+        }
+        if (!Utility.isNullOrEmpty(GraphRequest.defaultBatchApplicationId)) {
+            return GraphRequest.defaultBatchApplicationId;
+        }
+        return FacebookSdk.getApplicationId();
+    }
+
+    private static boolean isSupportedAttachmentType(Object value) {
+        return value instanceof Bitmap ||
+                value instanceof byte[] ||
+                value instanceof Uri ||
+                value instanceof ParcelFileDescriptor ||
+                value instanceof ParcelableResourceWithMimeType;
+    }
+
+    private static boolean isSupportedParameterType(Object value) {
+        return value instanceof String || value instanceof Boolean || value instanceof Number ||
+                value instanceof Date;
+    }
+
+    private static String parameterToString(Object value) {
+        if (value instanceof String) {
+            return (String) value;
+        } else if (value instanceof Boolean || value instanceof Number) {
+            return value.toString();
+        } else if (value instanceof Date) {
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
+                    ISO_8601_FORMAT_STRING, Locale.US);
+            return iso8601DateFormat.format(value);
+        }
+        throw new IllegalArgumentException("Unsupported parameter type.");
+    }
+
+    private interface KeyValueSerializer {
+        void writeString(String key, String value) throws IOException;
+    }
+
+    private static class Serializer implements KeyValueSerializer {
+        private final OutputStream outputStream;
+        private final Logger logger;
+        private boolean firstWrite = true;
+        private boolean useUrlEncode = false;
+
+        public Serializer(OutputStream outputStream, Logger logger, boolean useUrlEncode) {
+            this.outputStream = outputStream;
+            this.logger = logger;
+            this.useUrlEncode = useUrlEncode;
+        }
+
+        public void writeObject(String key, Object value, GraphRequest request) throws IOException {
+            if (outputStream instanceof RequestOutputStream) {
+                ((RequestOutputStream) outputStream).setCurrentRequest(request);
+            }
+
+            if (isSupportedParameterType(value)) {
+                writeString(key, parameterToString(value));
+            } else if (value instanceof Bitmap) {
+                writeBitmap(key, (Bitmap) value);
+            } else if (value instanceof byte[]) {
+                writeBytes(key, (byte[]) value);
+            } else if (value instanceof Uri) {
+                writeContentUri(key, (Uri) value, null);
+            } else if (value instanceof ParcelFileDescriptor) {
+                writeFile(key, (ParcelFileDescriptor) value, null);
+            } else if (value instanceof ParcelableResourceWithMimeType) {
+                ParcelableResourceWithMimeType resourceWithMimeType =
+                        (ParcelableResourceWithMimeType) value;
+                Parcelable resource = resourceWithMimeType.getResource();
+                String mimeType = resourceWithMimeType.getMimeType();
+                if (resource instanceof ParcelFileDescriptor) {
+                    writeFile(key, (ParcelFileDescriptor) resource, mimeType);
+                } else if (resource instanceof Uri) {
+                    writeContentUri(key, (Uri) resource, mimeType);
+                } else {
+                    throw getInvalidTypeError();
+                }
+            } else {
+                throw getInvalidTypeError();
+            }
+        }
+
+        private RuntimeException getInvalidTypeError() {
+            return new IllegalArgumentException("value is not a supported type.");
+        }
+
+        public void writeRequestsAsJson(
+                String key,
+                JSONArray requestJsonArray,
+                Collection<GraphRequest> requests
+        ) throws IOException, JSONException {
+            if (!(outputStream instanceof RequestOutputStream)) {
+                writeString(key, requestJsonArray.toString());
+                return;
+            }
+
+            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
+            writeContentDisposition(key, null, null);
+            write("[");
+            int i = 0;
+            for (GraphRequest request : requests) {
+                JSONObject requestJson = requestJsonArray.getJSONObject(i);
+                requestOutputStream.setCurrentRequest(request);
+                if (i > 0) {
+                    write(",%s", requestJson.toString());
+                } else {
+                    write("%s", requestJson.toString());
+                }
+                i++;
+            }
+            write("]");
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, requestJsonArray.toString());
+            }
+        }
+
+        public void writeString(String key, String value) throws IOException {
+            writeContentDisposition(key, null, null);
+            writeLine("%s", value);
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, value);
+            }
+        }
+
+        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
+            writeContentDisposition(key, key, "image/png");
+            // Note: quality parameter is ignored for PNG
+            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
+            writeLine("");
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, "<Image>");
+            }
+        }
+
+        public void writeBytes(String key, byte[] bytes) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+            this.outputStream.write(bytes);
+            writeLine("");
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue(
+                        "    " + key,
+                        String.format(Locale.ROOT, "<Data: %d>", bytes.length));
+            }
+        }
+
+        public void writeContentUri(String key, Uri contentUri, String mimeType)
+                throws IOException {
+            if (mimeType == null) {
+                mimeType = "content/unknown";
+            }
+            writeContentDisposition(key, key, mimeType);
+
+            InputStream inputStream = FacebookSdk
+                    .getApplicationContext()
+                    .getContentResolver()
+                    .openInputStream(contentUri);
+
+            int totalBytes = 0;
+            if (outputStream instanceof ProgressNoopOutputStream) {
+                // If we are only counting bytes then skip reading the file
+                long contentSize = Utility.getContentSize(contentUri);
+
+                ((ProgressNoopOutputStream) outputStream).addProgress(contentSize);
+            } else {
+                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
+            }
+
+            writeLine("");
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue(
+                        "    " + key,
+                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
+            }
+        }
+
+        public void writeFile(
+                String key,
+                ParcelFileDescriptor descriptor,
+                String mimeType
+        ) throws IOException {
+            if (mimeType == null) {
+                mimeType = "content/unknown";
+            }
+            writeContentDisposition(key, key, mimeType);
+
+            int totalBytes = 0;
+
+            if (outputStream instanceof ProgressNoopOutputStream) {
+                // If we are only counting bytes then skip reading the file
+                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
+            } else {
+                ParcelFileDescriptor.AutoCloseInputStream inputStream =
+                        new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
+                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
+            }
+            writeLine("");
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue(
+                        "    " + key,
+                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
+            }
+        }
+
+        public void writeRecordBoundary() throws IOException {
+            if (!useUrlEncode) {
+                writeLine("--%s", MIME_BOUNDARY);
+            } else {
+                this.outputStream.write("&".getBytes());
+            }
+        }
+
+        public void writeContentDisposition(
+                String name,
+                String filename,
+                String contentType
+        ) throws IOException {
+            if (!useUrlEncode) {
+                write("Content-Disposition: form-data; name=\"%s\"", name);
+                if (filename != null) {
+                    write("; filename=\"%s\"", filename);
+                }
+                writeLine(""); // newline after Content-Disposition
+                if (contentType != null) {
+                    writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
+                }
+                writeLine(""); // blank line before content
+            } else {
+                this.outputStream.write(String.format("%s=", name).getBytes());
+            }
+        }
+
+        public void write(String format, Object... args) throws IOException {
+            if (!useUrlEncode) {
+                if (firstWrite) {
+                    // Prepend all of our output with a boundary string.
+                    this.outputStream.write("--".getBytes());
+                    this.outputStream.write(MIME_BOUNDARY.getBytes());
+                    this.outputStream.write("\r\n".getBytes());
+                    firstWrite = false;
+                }
+                this.outputStream.write(String.format(format, args).getBytes());
+            } else {
+                this.outputStream.write(
+                        URLEncoder.encode(
+                                String.format(Locale.US, format, args), "UTF-8").getBytes());
+            }
+        }
+
+        public void writeLine(String format, Object... args) throws IOException {
+            write(format, args);
+            if (!useUrlEncode) {
+                write("\r\n");
+            }
+        }
+
+    }
+
+    /**
+     * Specifies the interface that consumers of the Request class can implement in order to be
+     * notified when a particular request completes, either successfully or with an error.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a request completes.
+         *
+         * @param response the Response of this request, which may include error information if the
+         *                 request was unsuccessful
+         */
+        void onCompleted(GraphResponse response);
+    }
+
+    /**
+     * Specifies the interface that consumers of the Request class can implement in order to be
+     * notified when a progress is made on a particular request. The frequency of the callbacks can
+     * be controlled using {@link FacebookSdk#setOnProgressThreshold(long)}
+     */
+    public interface OnProgressCallback extends Callback {
+        /**
+         * The method that will be called when progress is made.
+         *
+         * @param current the current value of the progress of the request.
+         * @param max     the maximum value (target) value that the progress will have.
+         */
+        void onProgress(long current, long max);
+    }
+
+    /**
+     * Callback for requests that result in an array of JSONObjects.
+     */
+    public interface GraphJSONArrayCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param objects  the list of GraphObjects representing the returned objects, or null
+         * @param response the Response of this request, which may include error information if the
+         *                 request was unsuccessful
+         */
+        void onCompleted(JSONArray objects, GraphResponse response);
+    }
+
+    /**
+     * Callback for requests that result in a JSONObject.
+     */
+    public interface GraphJSONObjectCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param object   the GraphObject representing the returned object, or null
+         * @param response the Response of this request, which may include error information if the
+         *                 request was unsuccessful
+         */
+        void onCompleted(JSONObject object, GraphResponse response);
+    }
+
+    /**
+     * Used during serialization for the graph request.
+     * @param <RESOURCE> The Parcelable type parameter.
+     */
+    public static class ParcelableResourceWithMimeType<RESOURCE extends Parcelable>
+            implements Parcelable {
+        private final String mimeType;
+        private final RESOURCE resource;
+
+        public String getMimeType() {
+            return mimeType;
+        }
+
+        public RESOURCE getResource() {
+            return resource;
+        }
+
+        public int describeContents() {
+            return CONTENTS_FILE_DESCRIPTOR;
+        }
+
+        public void writeToParcel(Parcel out, int flags) {
+            out.writeString(mimeType);
+            out.writeParcelable(resource, flags);
+        }
+
+        @SuppressWarnings("unused")
+        public static final Parcelable.Creator<ParcelableResourceWithMimeType> CREATOR
+                = new Parcelable.Creator<ParcelableResourceWithMimeType>() {
+            public ParcelableResourceWithMimeType createFromParcel(Parcel in) {
+                return new ParcelableResourceWithMimeType(in);
+            }
+
+            public ParcelableResourceWithMimeType[] newArray(int size) {
+                return new ParcelableResourceWithMimeType[size];
+            }
+        };
+
+        /**
+         * The constructor.
+         * @param resource The resource to parcel.
+         * @param mimeType The mime type.
+         */
+        public ParcelableResourceWithMimeType(
+                RESOURCE resource,
+                String mimeType
+        ) {
+            this.mimeType = mimeType;
+            this.resource = resource;
+        }
+
+        private ParcelableResourceWithMimeType(Parcel in) {
+            mimeType = in.readString();
+            resource = in.readParcelable(FacebookSdk.getApplicationContext().getClassLoader());
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/RequestAsyncTask.java b/facebook/src/com/facebook/GraphRequestAsyncTask.java
similarity index 50%
rename from facebook/src/com/facebook/RequestAsyncTask.java
rename to facebook/src/com/facebook/GraphRequestAsyncTask.java
index db60a18f9..6b27bc8af 100644
--- a/facebook/src/com/facebook/RequestAsyncTask.java
+++ b/facebook/src/com/facebook/GraphRequestAsyncTask.java
@@ -1,22 +1,25 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
-import android.annotation.TargetApi;
 import android.os.AsyncTask;
 import android.os.Handler;
 import android.util.Log;
@@ -32,13 +35,12 @@
  * Defines an AsyncTask suitable for executing a Request in the background. May be subclassed
  * by applications having unique threading model needs.
  */
-@TargetApi(3)
-public class RequestAsyncTask extends AsyncTask<Void, Void, List<Response>> {
-    private static final String TAG = RequestAsyncTask.class.getCanonicalName();
+public class GraphRequestAsyncTask extends AsyncTask<Void, Void, List<GraphResponse>> {
+    private static final String TAG = GraphRequestAsyncTask.class.getCanonicalName();
     private static Method executeOnExecutorMethod;
 
     private final HttpURLConnection connection;
-    private final RequestBatch requests;
+    private final GraphRequestBatch requests;
 
     private Exception exception;
 
@@ -46,7 +48,8 @@
         for (Method method : AsyncTask.class.getMethods()) {
             if ("executeOnExecutor".equals(method.getName())) {
                 Class<?>[] parameters = method.getParameterTypes();
-                if ((parameters.length == 2) && (parameters[0] == Executor.class) && parameters[1].isArray()) {
+                if ((parameters.length == 2) &&
+                        (parameters[0] == Executor.class) && parameters[1].isArray()) {
                     executeOnExecutorMethod = method;
                     break;
                 }
@@ -55,32 +58,32 @@
     }
 
     /**
-     * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getException() method.
+     * Constructor. Serialization of the requests will be done in the background, so any
+     * serialization- related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
-    public RequestAsyncTask(Request... requests) {
-        this(null, new RequestBatch(requests));
+    public GraphRequestAsyncTask(GraphRequest... requests) {
+        this(null, new GraphRequestBatch(requests));
     }
 
     /**
-     * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getException() method.
+     * Constructor. Serialization of the requests will be done in the background, so any
+     * serialization- related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
-    public RequestAsyncTask(Collection<Request> requests) {
-        this(null, new RequestBatch(requests));
+    public GraphRequestAsyncTask(Collection<GraphRequest> requests) {
+        this(null, new GraphRequestBatch(requests));
     }
 
     /**
-     * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getException() method.
+     * Constructor. Serialization of the requests will be done in the background, so any
+     * serialization- related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
-    public RequestAsyncTask(RequestBatch requests) {
+    public GraphRequestAsyncTask(GraphRequestBatch requests) {
         this(null, requests);
     }
 
@@ -93,8 +96,8 @@ public RequestAsyncTask(RequestBatch requests) {
      * @param connection the HTTP connection to use to execute the requests
      * @param requests   the requests to execute
      */
-    public RequestAsyncTask(HttpURLConnection connection, Request... requests) {
-        this(connection, new RequestBatch(requests));
+    public GraphRequestAsyncTask(HttpURLConnection connection, GraphRequest... requests) {
+        this(connection, new GraphRequestBatch(requests));
     }
 
     /**
@@ -106,8 +109,8 @@ public RequestAsyncTask(HttpURLConnection connection, Request... requests) {
      * @param connection the HTTP connection to use to execute the requests
      * @param requests   the requests to execute
      */
-    public RequestAsyncTask(HttpURLConnection connection, Collection<Request> requests) {
-        this(connection, new RequestBatch(requests));
+    public GraphRequestAsyncTask(HttpURLConnection connection, Collection<GraphRequest> requests) {
+        this(connection, new GraphRequestBatch(requests));
     }
 
     /**
@@ -119,7 +122,7 @@ public RequestAsyncTask(HttpURLConnection connection, Collection<Request> reques
      * @param connection the HTTP connection to use to execute the requests
      * @param requests   the requests to execute
      */
-    public RequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+    public GraphRequestAsyncTask(HttpURLConnection connection, GraphRequestBatch requests) {
         this.requests = requests;
         this.connection = connection;
     }
@@ -128,14 +131,20 @@ protected final Exception getException() {
         return exception;
     }
 
-    protected final RequestBatch getRequests() {
+    protected final GraphRequestBatch getRequests() {
         return requests;
     }
 
     @Override
     public String toString() {
-        return new StringBuilder().append("{RequestAsyncTask: ").append(" connection: ").append(connection)
-                .append(", requests: ").append(requests).append("}").toString();
+        return new StringBuilder()
+                .append("{RequestAsyncTask: ")
+                .append(" connection: ")
+                .append(connection)
+                .append(", requests: ")
+                .append(requests)
+                .append("}")
+                .toString();
     }
 
     @Override
@@ -143,27 +152,30 @@ protected void onPreExecute() {
         super.onPreExecute();
 
         if (requests.getCallbackHandler() == null) {
-            // We want any callbacks to go to a handler on this thread unless a handler has already been specified.
+            // We want any callbacks to go to a handler on this thread unless a handler has already
+            // been specified.
             requests.setCallbackHandler(new Handler());
         }
     }
 
     @Override
-    protected void onPostExecute(List<Response> result) {
+    protected void onPostExecute(List<GraphResponse> result) {
         super.onPostExecute(result);
 
         if (exception != null) {
-            Log.d(TAG, String.format("onPostExecute: exception encountered during request: %s", exception.getMessage()));
+            Log.d(TAG, String.format(
+                    "onPostExecute: exception encountered during request: %s",
+                    exception.getMessage()));
         }
     }
 
     @Override
-    protected List<Response> doInBackground(Void... params) {
+    protected List<GraphResponse> doInBackground(Void... params) {
         try {
             if (connection == null) {
                 return requests.executeAndWait();
             } else {
-                return Request.executeConnectionAndWait(connection, requests);
+                return GraphRequest.executeConnectionAndWait(connection, requests);
             }
         } catch (Exception e) {
             exception = e;
@@ -171,19 +183,19 @@ protected void onPostExecute(List<Response> result) {
         }
     }
 
-    RequestAsyncTask executeOnSettingsExecutor() {
-        try {
-            if (executeOnExecutorMethod != null) {
-                executeOnExecutorMethod.invoke(this, Settings.getExecutor(), null);
-                return this;
+    GraphRequestAsyncTask executeOnSettingsExecutor() {
+        if (executeOnExecutorMethod != null) {
+            try {
+                executeOnExecutorMethod.invoke(this, FacebookSdk.getExecutor(), null);
+            } catch (InvocationTargetException e) {
+                // fall-through
+            } catch (IllegalAccessException e) {
+                // fall-through
             }
-        } catch (InvocationTargetException e) {
-            // fall-through
-        } catch (IllegalAccessException e) {
-            // fall-through
+        } else {
+          this.execute();
         }
 
-        this.execute();
         return this;
     }
 }
diff --git a/facebook/src/com/facebook/RequestBatch.java b/facebook/src/com/facebook/GraphRequestBatch.java
similarity index 58%
rename from facebook/src/com/facebook/RequestBatch.java
rename to facebook/src/com/facebook/GraphRequestBatch.java
index 9ecd7be18..ff4d7a05e 100644
--- a/facebook/src/com/facebook/RequestBatch.java
+++ b/facebook/src/com/facebook/GraphRequestBatch.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -22,13 +26,14 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * RequestBatch contains a list of Request objects that can be sent to Facebook in a single round-trip.
+ * RequestBatch contains a list of Request objects that can be sent to Facebook in a single
+ * round-trip.
  */
-public class RequestBatch extends AbstractList<Request> {
+public class GraphRequestBatch extends AbstractList<GraphRequest> {
     private static AtomicInteger idGenerator = new AtomicInteger();
 
     private Handler callbackHandler;
-    private List<Request> requests = new ArrayList<Request>();
+    private List<GraphRequest> requests = new ArrayList<GraphRequest>();
     private int timeoutInMilliseconds = 0;
     private final String id = Integer.valueOf(idGenerator.incrementAndGet()).toString();
     private List<Callback> callbacks = new ArrayList<Callback>();
@@ -37,23 +42,23 @@
     /**
      * Constructor. Creates an empty batch.
      */
-    public RequestBatch() {
-        this.requests = new ArrayList<Request>();
+    public GraphRequestBatch() {
+        this.requests = new ArrayList<GraphRequest>();
     }
 
     /**
      * Constructor.
      * @param requests the requests to add to the batch
      */
-    public RequestBatch(Collection<Request> requests) {
-        this.requests = new ArrayList<Request>(requests);
+    public GraphRequestBatch(Collection<GraphRequest> requests) {
+        this.requests = new ArrayList<GraphRequest>(requests);
     }
 
     /**
      * Constructor.
      * @param requests the requests to add to the batch
      */
-    public RequestBatch(Request... requests) {
+    public GraphRequestBatch(GraphRequest... requests) {
         this.requests = Arrays.asList(requests);
     }
 
@@ -61,8 +66,8 @@ public RequestBatch(Request... requests) {
      * Constructor.
      * @param requests the requests to add to the batch
      */
-    public RequestBatch(RequestBatch requests) {
-        this.requests = new ArrayList<Request>(requests);
+    public GraphRequestBatch(GraphRequestBatch requests) {
+        this.requests = new ArrayList<GraphRequest>(requests);
         this.callbackHandler = requests.callbackHandler;
         this.timeoutInMilliseconds = requests.timeoutInMilliseconds;
         this.callbacks = new ArrayList<Callback>(requests.callbacks);
@@ -88,7 +93,8 @@ public void setTimeout(int timeoutInMilliseconds) {
     }
 
     /**
-     * Adds a batch-level callback which will be called when the entire batch has finished executing.
+     * Adds a batch-level callback which will be called when the entire batch has finished
+     * executing.
      *
      * @param callback the callback
      */
@@ -108,12 +114,12 @@ public void removeCallback(Callback callback) {
     }
 
     @Override
-    public final boolean add(Request request) {
+    public final boolean add(GraphRequest request) {
         return requests.add(request);
     }
 
     @Override
-    public final void add(int location, Request request) {
+    public final void add(int location, GraphRequest request) {
         requests.add(location, request);
     }
 
@@ -123,17 +129,17 @@ public final void clear() {
     }
 
     @Override
-    public final Request get(int i) {
+    public final GraphRequest get(int i) {
         return requests.get(i);
     }
 
     @Override
-    public final Request remove(int location) {
+    public final GraphRequest remove(int location) {
         return requests.remove(location);
     }
 
     @Override
-    public final Request set(int location, Request request) {
+    public final GraphRequest set(int location, GraphRequest request) {
         return requests.set(location, request);
     }
 
@@ -154,7 +160,7 @@ final void setCallbackHandler(Handler callbackHandler) {
         this.callbackHandler = callbackHandler;
     }
 
-    final List<Request> getRequests() {
+    final List<GraphRequest> getRequests() {
         return requests;
     }
 
@@ -162,11 +168,19 @@ final void setCallbackHandler(Handler callbackHandler) {
         return callbacks;
     }
 
-    final String getBatchApplicationId() {
+    /**
+     * Getter for the batch application id.
+     * @return the batch application id.
+     */
+    final public String getBatchApplicationId() {
         return batchApplicationId;
     }
 
-    final void setBatchApplicationId(String batchApplicationId) {
+    /**
+     * Setter for the batch application id.
+     * @param batchApplicationId The batch application id.
+     */
+    final public void setBatchApplicationId(String batchApplicationId) {
         this.batchApplicationId = batchApplicationId;
     }
 
@@ -175,15 +189,15 @@ final void setBatchApplicationId(String batchApplicationId) {
      * <p/>
      * This should only be used if you have transitioned off the UI thread.
      *
-     * @return a list of Response objects representing the results of the requests; responses are returned in the same
-     *         order as the requests were specified.
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
+     * @return a list of Response objects representing the results of the requests; responses are
+     * returned in the same order as the requests were specified.
+     * @throws FacebookException        If there was an error in the protocol used to communicate
+     *                                  with the service
      * @throws IllegalArgumentException if the passed in RequestBatch is empty
-     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     * @throws NullPointerException     if the passed in RequestBatch or any of its contents are
+     *                                  null
      */
-    public final List<Response> executeAndWait() {
+    public final List<GraphResponse> executeAndWait() {
         return executeAndWaitImpl();
     }
 
@@ -191,7 +205,7 @@ final void setBatchApplicationId(String batchApplicationId) {
      * Executes this batch asynchronously. This function will return immediately, and the batch will
      * be processed on a separate thread. In order to process results of a request, or determine
      * whether a request succeeded or failed, a callback must be specified (see
-     * {@link Request#setCallback(com.facebook.Request.Callback)})
+     * {@link GraphRequest#setCallback(GraphRequest.Callback)})
      * <p/>
      * This should only be called from the UI thread.
      *
@@ -200,13 +214,14 @@ final void setBatchApplicationId(String batchApplicationId) {
      * @throws IllegalArgumentException if this batch is empty
      * @throws NullPointerException if any of the contents of this batch are null
      */
-    public final RequestAsyncTask executeAsync() {
+    public final GraphRequestAsyncTask executeAsync() {
         return executeAsyncImpl();
     }
 
     /**
-     * Specifies the interface that consumers of the RequestBatch class can implement in order to be notified when the
-     * entire batch completes execution. It will be called after all per-Request callbacks are called.
+     * Specifies the interface that consumers of the RequestBatch class can implement in order to be
+     * notified when the entire batch completes execution. It will be called after all per-Request
+     * callbacks are called.
      */
     public interface Callback {
         /**
@@ -214,13 +229,13 @@ public final RequestAsyncTask executeAsync() {
          *
          * @param batch     the RequestBatch containing the Requests which were executed
          */
-        void onBatchCompleted(RequestBatch batch);
+        void onBatchCompleted(GraphRequestBatch batch);
     }
 
     /**
-     * Specifies the interface that consumers of the RequestBatch class can implement in order to be notified when the
-     * batch makes progress. The frequency of the callbacks can be controlled using
-     * {@link com.facebook.Settings#setOnProgressThreshold(long)}.
+     * Specifies the interface that consumers of the RequestBatch class can implement in order to be
+     * notified when the batch makes progress. The frequency of the callbacks can be controlled
+     * using {@link FacebookSdk#setOnProgressThreshold(long)}.
      */
     public interface OnProgressCallback extends Callback {
         /**
@@ -230,14 +245,14 @@ public final RequestAsyncTask executeAsync() {
          * @param current   the current value of the progress
          * @param max       the max (target) value of the progress
          */
-        void onBatchProgress(RequestBatch batch, long current, long max);
+        void onBatchProgress(GraphRequestBatch batch, long current, long max);
     }
 
-    List<Response> executeAndWaitImpl() {
-        return Request.executeBatchAndWait(this);
+    List<GraphResponse> executeAndWaitImpl() {
+        return GraphRequest.executeBatchAndWait(this);
     }
 
-    RequestAsyncTask executeAsyncImpl() {
-        return Request.executeBatchAsync(this);
+    GraphRequestAsyncTask executeAsyncImpl() {
+        return GraphRequest.executeBatchAsync(this);
     }
 }
diff --git a/facebook/src/com/facebook/GraphResponse.java b/facebook/src/com/facebook/GraphResponse.java
new file mode 100644
index 000000000..9793e03b5
--- /dev/null
+++ b/facebook/src/com/facebook/GraphResponse.java
@@ -0,0 +1,465 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import com.facebook.internal.FacebookRequestErrorClassification;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Encapsulates the response, successful or otherwise, of a call to the Facebook platform.
+ */
+public class GraphResponse {
+    private final HttpURLConnection connection;
+    private final JSONObject graphObject;
+    private final JSONArray graphObjectArray;
+    private final FacebookRequestError error;
+    private final String rawResponse;
+    private final GraphRequest request;
+
+    /**
+     * Property name of non-JSON results in the GraphObject. Certain calls to Facebook result in a
+     * non-JSON response (e.g., the string literal "true" or "false"). To present a consistent way
+     * of accessing results, these are represented as a GraphObject with a single string property
+     * with this name.
+     */
+    public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT";
+
+    // From v2.1 of the Graph API, write endpoints will now return valid JSON with the result as the
+    // value for the "success" key
+    public static final String SUCCESS_KEY = "success";
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+
+    private static final String RESPONSE_LOG_TAG = "Response";
+
+    GraphResponse(
+            GraphRequest request,
+            HttpURLConnection connection,
+            String rawResponse,
+            JSONObject graphObject) {
+        this(request, connection, rawResponse, graphObject, null, null);
+    }
+
+    GraphResponse(
+            GraphRequest request,
+            HttpURLConnection connection,
+            String rawResponse,
+            JSONArray graphObjects) {
+        this(request, connection, rawResponse, null, graphObjects, null);
+    }
+
+    GraphResponse(
+            GraphRequest request,
+            HttpURLConnection connection,
+            FacebookRequestError error) {
+        this(request, connection, null, null, null, error);
+    }
+
+    GraphResponse(
+            GraphRequest request,
+            HttpURLConnection connection,
+            String rawResponse,
+            JSONObject graphObject,
+            JSONArray graphObjects,
+            FacebookRequestError error) {
+        this.request = request;
+        this.connection = connection;
+        this.rawResponse = rawResponse;
+        this.graphObject = graphObject;
+        this.graphObjectArray = graphObjects;
+        this.error = error;
+    }
+
+    /**
+     * Returns information about any errors that may have occurred during the request.
+     *
+     * @return the error from the server, or null if there was no server error
+     */
+    public final FacebookRequestError getError() {
+        return error;
+    }
+
+    /**
+     * The response returned for this request, if it's in object form.
+     *
+     * @return the returned JSON object, or null if none was returned (or if the result was a JSON
+     * array)
+     */
+    public final JSONObject getJSONObject() {
+        return graphObject;
+    }
+
+
+    /**
+     * The response returned for this request, if it's in array form.
+     *
+     * @return the returned JSON array, or null if none was returned (or if the result was a JSON
+     * object)
+     */
+    public final JSONArray getJSONArray() {
+        return graphObjectArray;
+    }
+
+    /**
+     * Returns the HttpURLConnection that this response was generated from. If the response was
+     * retrieved from the cache, this will be null.
+     *
+     * @return the connection, or null
+     */
+    public final HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the request that this response is for.
+     *
+     * @return the request that this response is for
+     */
+    public GraphRequest getRequest() {
+        return request;
+    }
+
+    /**
+     * Returns the server response as a String that this response is for.
+     *
+     * @return A String representation of the actual response from the server
+     */
+    public String getRawResponse() {
+        return rawResponse;
+    }
+
+    /**
+     * Indicates whether paging is being done forward or backward.
+     */
+    public enum PagingDirection {
+        /**
+         * Indicates that paging is being performed in the forward direction.
+         */
+        NEXT,
+        /**
+         * Indicates that paging is being performed in the backward direction.
+         */
+        PREVIOUS
+    }
+
+    /**
+     * If a Response contains results that contain paging information, returns a new
+     * Request that will retrieve the next page of results, in whichever direction
+     * is desired. If no paging information is available, returns null.
+     *
+     * @param direction enum indicating whether to page forward or backward
+     * @return a Request that will retrieve the next page of results in the desired
+     *         direction, or null if no paging information is available
+     */
+    public GraphRequest getRequestForPagedResults(PagingDirection direction) {
+        String link = null;
+        if (graphObject != null) {
+            JSONObject pagingInfo = graphObject.optJSONObject("paging");
+            if (pagingInfo != null) {
+                if (direction == PagingDirection.NEXT) {
+                    link = pagingInfo.optString("next");
+                } else {
+                    link = pagingInfo.optString("previous");
+                }
+            }
+        }
+        if (Utility.isNullOrEmpty(link)) {
+            return null;
+        }
+
+        if (link != null && link.equals(request.getUrlForSingleRequest())) {
+            // We got the same "next" link as we just tried to retrieve. This could happen if cached
+            // data is invalid. All we can do in this case is pretend we have finished.
+            return null;
+        }
+
+        GraphRequest pagingRequest;
+        try {
+            pagingRequest = new GraphRequest(request.getAccessToken(), new URL(link));
+        } catch (MalformedURLException e) {
+            return null;
+        }
+
+        return pagingRequest;
+    }
+
+    /**
+     * Provides a debugging string for this response.
+     */
+    @Override
+    public String toString() {
+        String responseCode;
+        try {
+            responseCode = String.format(
+                    Locale.US,
+                    "%d",
+                    (connection != null) ? connection.getResponseCode() : 200);
+        } catch (IOException e) {
+            responseCode = "unknown";
+        }
+
+        return new StringBuilder()
+                .append("{Response: ")
+                .append(" responseCode: ")
+                .append(responseCode)
+                .append(", graphObject: ")
+                .append(graphObject)
+                .append(", error: ")
+                .append(error)
+                .append("}")
+                .toString();
+    }
+
+    @SuppressWarnings("resource")
+    static List<GraphResponse> fromHttpConnection(
+            HttpURLConnection connection,
+            GraphRequestBatch requests) {
+        InputStream stream = null;
+
+        try {
+            if (connection.getResponseCode() >= 400) {
+                stream = connection.getErrorStream();
+            } else {
+                stream = connection.getInputStream();
+            }
+
+            return createResponsesFromStream(stream, connection, requests);
+        } catch (FacebookException facebookException) {
+            Logger.log(
+                    LoggingBehavior.REQUESTS,
+                    RESPONSE_LOG_TAG,
+                    "Response <Error>: %s",
+                    facebookException);
+            return constructErrorResponses(requests, connection, facebookException);
+        } catch (JSONException exception) {
+            Logger.log(
+                    LoggingBehavior.REQUESTS,
+                    RESPONSE_LOG_TAG,
+                    "Response <Error>: %s",
+                    exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } catch (IOException exception) {
+            Logger.log(
+                    LoggingBehavior.REQUESTS,
+                    RESPONSE_LOG_TAG,
+                    "Response <Error>: %s",
+                    exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } catch (SecurityException exception) {
+            Logger.log(
+                    LoggingBehavior.REQUESTS,
+                    RESPONSE_LOG_TAG,
+                    "Response <Error>: %s",
+                    exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } finally {
+            Utility.closeQuietly(stream);
+        }
+    }
+
+    static List<GraphResponse> createResponsesFromStream(
+            InputStream stream,
+            HttpURLConnection connection,
+            GraphRequestBatch requests
+    ) throws FacebookException, JSONException, IOException {
+
+        String responseString = Utility.readStreamToString(stream);
+        Logger.log(LoggingBehavior.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
+                "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
+                responseString);
+
+        return createResponsesFromString(responseString, connection, requests);
+    }
+
+    static List<GraphResponse> createResponsesFromString(
+            String responseString,
+            HttpURLConnection connection,
+            GraphRequestBatch requests
+    ) throws FacebookException, JSONException, IOException {
+        JSONTokener tokener = new JSONTokener(responseString);
+        Object resultObject = tokener.nextValue();
+
+        List<GraphResponse> responses = createResponsesFromObject(
+                connection,
+                requests,
+                resultObject);
+        Logger.log(
+                LoggingBehavior.REQUESTS,
+                RESPONSE_LOG_TAG,
+                "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
+                requests.getId(),
+                responseString.length(),
+                responses);
+
+        return responses;
+    }
+
+    private static List<GraphResponse> createResponsesFromObject(
+            HttpURLConnection connection,
+            List<GraphRequest> requests,
+            Object object
+    ) throws FacebookException, JSONException {
+        int numRequests = requests.size();
+        List<GraphResponse> responses = new ArrayList<GraphResponse>(numRequests);
+        Object originalResult = object;
+
+        if (numRequests == 1) {
+            GraphRequest request = requests.get(0);
+            try {
+                // Single request case -- the entire response is the result, wrap it as "body" so we
+                // can handle it the same as we do in the batched case. We get the response code
+                // from the actual HTTP response, as opposed to the batched case where it is
+                // returned as a "code" element.
+                JSONObject jsonObject = new JSONObject();
+                jsonObject.put(BODY_KEY, object);
+                int responseCode = (connection != null) ? connection.getResponseCode() : 200;
+                jsonObject.put(CODE_KEY, responseCode);
+
+                JSONArray jsonArray = new JSONArray();
+                jsonArray.put(jsonObject);
+
+                // Pretend we got an array of 1 back.
+                object = jsonArray;
+            } catch (JSONException e) {
+                responses.add(
+                        new GraphResponse(
+                                request,
+                                connection,
+                                new FacebookRequestError(connection, e)));
+            } catch (IOException e) {
+                responses.add(
+                        new GraphResponse(
+                                request,
+                                connection,
+                                new FacebookRequestError(connection, e)));
+            }
+        }
+
+        if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
+            FacebookException exception = new FacebookException("Unexpected number of results");
+            throw exception;
+        }
+
+        JSONArray jsonArray = (JSONArray) object;
+
+        for (int i = 0; i < jsonArray.length(); ++i) {
+            GraphRequest request = requests.get(i);
+            try {
+                Object obj = jsonArray.get(i);
+                responses.add(
+                        createResponseFromObject(
+                                request,
+                                connection,
+                                obj,
+                                originalResult));
+            } catch (JSONException e) {
+                responses.add(
+                        new GraphResponse(
+                                request,
+                                connection,
+                                new FacebookRequestError(connection, e)));
+            } catch (FacebookException e) {
+                responses.add(
+                        new GraphResponse(
+                                request,
+                                connection,
+                                new FacebookRequestError(connection, e)));
+            }
+        }
+
+        return responses;
+    }
+
+    private static GraphResponse createResponseFromObject(
+            GraphRequest request,
+            HttpURLConnection connection,
+            Object object,
+            Object originalResult
+    ) throws JSONException {
+        if (object instanceof JSONObject) {
+            JSONObject jsonObject = (JSONObject) object;
+
+            FacebookRequestError error =
+                    FacebookRequestError.checkResponseAndCreateError(
+                            jsonObject,
+                            originalResult,
+                            connection);
+            if (error != null) {
+                if (error.getErrorCode() == FacebookRequestErrorClassification.EC_INVALID_TOKEN
+                        && Utility.isCurrentAccessToken(request.getAccessToken())) {
+                    AccessToken.setCurrentAccessToken(null);
+                }
+                return new GraphResponse(request, connection, error);
+            }
+
+            Object body = Utility.getStringPropertyAsJSON(
+                    jsonObject,
+                    BODY_KEY,
+                    NON_JSON_RESPONSE_PROPERTY);
+
+            if (body instanceof JSONObject) {
+                return new GraphResponse(request, connection, body.toString(), (JSONObject)body);
+            } else if (body instanceof JSONArray) {
+                return new GraphResponse(request, connection, body.toString(), (JSONArray)body);
+            }
+            // We didn't get a body we understand how to handle, so pretend we got nothing.
+            object = JSONObject.NULL;
+        }
+
+        if (object == JSONObject.NULL) {
+            return new GraphResponse(request, connection, object.toString(), (JSONObject)null);
+        } else {
+            throw new FacebookException("Got unexpected object type in response, class: "
+                    + object.getClass().getSimpleName());
+        }
+    }
+
+    static List<GraphResponse> constructErrorResponses(
+            List<GraphRequest> requests,
+            HttpURLConnection connection,
+            FacebookException error) {
+        int count = requests.size();
+        List<GraphResponse> responses = new ArrayList<GraphResponse>(count);
+        for (int i = 0; i < count; ++i) {
+            GraphResponse response = new GraphResponse(
+                    requests.get(i),
+                    connection,
+                    new FacebookRequestError(connection, error));
+            responses.add(response);
+        }
+        return responses;
+    }
+}
diff --git a/facebook/src/com/facebook/HttpMethod.java b/facebook/src/com/facebook/HttpMethod.java
index bf355bd9d..63b287106 100644
--- a/facebook/src/com/facebook/HttpMethod.java
+++ b/facebook/src/com/facebook/HttpMethod.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
diff --git a/facebook/src/com/facebook/InsightsLogger.java b/facebook/src/com/facebook/InsightsLogger.java
deleted file mode 100644
index 168125f73..000000000
--- a/facebook/src/com/facebook/InsightsLogger.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.os.Bundle;
-import com.facebook.internal.Logger;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-/**
- * This class is deprecated. Please use {@link AppEventsLogger} instead.
- */
-@Deprecated
-public class InsightsLogger {
-    private static final String EVENT_PARAMETER_PIXEL_ID         = "fb_offsite_pixel_id";
-    private static final String EVENT_PARAMETER_PIXEL_VALUE      = "fb_offsite_pixel_value";
-
-    private static final String EVENT_NAME_LOG_CONVERSION_PIXEL  = "fb_log_offsite_pixel";
-
-    private AppEventsLogger appEventsLogger;
-
-    private InsightsLogger(Context context, String applicationId, Session session) {
-        appEventsLogger = AppEventsLogger.newLogger(context, applicationId, session);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public static InsightsLogger newLogger(Context context, String clientToken) {
-        return new InsightsLogger(context, null, null);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public static InsightsLogger newLogger(Context context, String clientToken, String applicationId) {
-        return new InsightsLogger(context, applicationId, null);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public static InsightsLogger newLogger(Context context, String clientToken, String applicationId, Session session) {
-        return new InsightsLogger(context, applicationId, session);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public void logPurchase(BigDecimal purchaseAmount, Currency currency) {
-        logPurchase(purchaseAmount, currency, null);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public void logPurchase(BigDecimal purchaseAmount, Currency currency, Bundle parameters) {
-        appEventsLogger.logPurchase(purchaseAmount, currency, parameters);
-    }
-
-    /**
-     * Deprecated. Please use {@link AppEventsLogger} instead.
-     */
-    public void logConversionPixel(String pixelId, double valueOfPixel) {
-
-        if (pixelId == null) {
-            Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "Insights", "pixelID cannot be null");
-            return;
-        }
-
-        Bundle parameters = new Bundle();
-        parameters.putString(EVENT_PARAMETER_PIXEL_ID, pixelId);
-        parameters.putDouble(EVENT_PARAMETER_PIXEL_VALUE, valueOfPixel);
-
-        appEventsLogger.logEvent(EVENT_NAME_LOG_CONVERSION_PIXEL, valueOfPixel, parameters);
-        AppEventsLogger.eagerFlush();
-    }
-}
diff --git a/facebook/src/com/facebook/LegacyHelper.java b/facebook/src/com/facebook/LegacyHelper.java
deleted file mode 100644
index dcdfd8561..000000000
--- a/facebook/src/com/facebook/LegacyHelper.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-
-/**
- * LegacyHelper is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the methods in this class is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-public class LegacyHelper {
-    @Deprecated
-    public static void extendTokenCompleted(Session session, Bundle bundle) {
-        session.extendTokenCompleted(bundle);
-    }
-}
diff --git a/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java b/facebook/src/com/facebook/LegacyTokenHelper.java
similarity index 62%
rename from facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
rename to facebook/src/com/facebook/LegacyTokenHelper.java
index 0286d3c1f..723955891 100644
--- a/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
+++ b/facebook/src/com/facebook/LegacyTokenHelper.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -28,25 +32,63 @@
 import org.json.JSONObject;
 
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
-/*
- * <p>
- * An implementation of {@link TokenCachingStrategy TokenCachingStrategy} that uses Android SharedPreferences
- * to persist information.
- * </p>
- * <p>
- * The data to be cached is passed in via a Bundle. Only non-null key-value-pairs where
- * the value is one of the following types (or an array of the same) are persisted:
- * boolean, byte, int, long, float, double, char. In addition, String and List<String>
- * are also supported.
- * </p>
- */
-public class SharedPreferencesTokenCachingStrategy extends TokenCachingStrategy {
+final class LegacyTokenHelper {
+    /**
+     * The key used by AccessTokenCache to store the token value in the Bundle during
+     * load and save.
+     */
+    public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token";
+
+    /**
+     * The key used by AccessTokenCache to store the expiration date value in the Bundle
+     * during load and save.
+     */
+    public static final String EXPIRATION_DATE_KEY =
+            "com.facebook.TokenCachingStrategy.ExpirationDate";
+
+    /**
+     * The key used by AccessTokenCache to store the last refresh date value in the
+     * Bundle during load and save.
+     */
+    public static final String LAST_REFRESH_DATE_KEY =
+            "com.facebook.TokenCachingStrategy.LastRefreshDate";
+
+    /**
+     * The key used by AccessTokenCache to store an enum indicating the source of the token
+     * in the Bundle during load and save.
+     */
+    public static final String TOKEN_SOURCE_KEY =
+            "com.facebook.TokenCachingStrategy.AccessTokenSource";
+
+    /**
+     * The key used by AccessTokenCache to store the list of permissions granted by the
+     * token in the Bundle during load and save.
+     */
+    public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions";
+
+    /**
+     * The key used by AccessTokenCache to store the list of permissions declined by the user in the token in
+     * the Bundle during load and save.
+     */
+    public static final String DECLINED_PERMISSIONS_KEY =
+            "com.facebook.TokenCachingStrategy.DeclinedPermissions";
+
+    public static final String APPLICATION_ID_KEY =
+            "com.facebook.TokenCachingStrategy.ApplicationId";
+
+    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
+    private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO";
 
-    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY";
-    private static final String TAG = SharedPreferencesTokenCachingStrategy.class.getSimpleName();
+    public static final String DEFAULT_CACHE_KEY =
+            "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY";
+    private static final String TAG = LegacyTokenHelper.class.getSimpleName();
 
     private static final String JSON_VALUE_TYPE = "valueType";
     private static final String JSON_VALUE = "value";
@@ -75,32 +117,11 @@
     private String cacheKey;
     private SharedPreferences cache;
 
-    /**
-     * Creates a default {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy}
-     * instance that provides access to a single set of token information.
-     *
-     * @param context
-     *              The Context object to use to get the SharedPreferences object.
-     *
-     * @throws NullPointerException if the passed in Context is null
-     */
-    public SharedPreferencesTokenCachingStrategy(Context context) {
+    public LegacyTokenHelper(Context context) {
         this(context, null);
     }
 
-    /**
-     * Creates a {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy} instance
-     * that is distinct for the passed in cacheKey.
-     *
-     * @param context
-     *              The Context object to use to get the SharedPreferences object.
-     *
-     * @param cacheKey
-     *              Identifies a distinct set of token information.
-     *
-     * @throws NullPointerException if the passed in Context is null
-     */
-    public SharedPreferencesTokenCachingStrategy(Context context, String cacheKey) {
+    public LegacyTokenHelper(Context context, String cacheKey) {
         Validate.notNull(context, "context");
 
         this.cacheKey = Utility.isNullOrEmpty(cacheKey) ? DEFAULT_CACHE_KEY : cacheKey;
@@ -116,11 +137,6 @@ public SharedPreferencesTokenCachingStrategy(Context context, String cacheKey) {
                 Context.MODE_PRIVATE);
     }
 
-    /**
-     * Returns a Bundle that contains the information stored in this cache
-     *
-     * @return A Bundle with the information contained in this cache
-     */
     public Bundle load() {
         Bundle settings = new Bundle();
 
@@ -140,13 +156,6 @@ public Bundle load() {
         return settings;
     }
 
-    /**
-     * Persists all supported data types present in the passed in Bundle, to the
-     * cache
-     *
-     * @param bundle
-     *          The Bundle containing information to be cached
-     */
     public void save(Bundle bundle) {
         Validate.notNull(bundle, "bundle");
 
@@ -157,24 +166,160 @@ public void save(Bundle bundle) {
                 serializeKey(key, bundle, editor);
             } catch (JSONException e) {
                 // Error in the bundle. Don't store a partial cache.
-                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
+                Logger.log(
+                        LoggingBehavior.CACHE,
+                        Log.WARN,
+                        TAG,
+                        "Error processing value for key: '" + key + "' -- " + e);
 
                 // Bypass the commit and just return. This cancels the entire edit transaction
                 return;
             }
         }
-
-        boolean successfulCommit = editor.commit();
-        if (!successfulCommit) {
-            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
-        }
+        editor.apply();
     }
 
     /**
      * Clears out all token information stored in this cache.
      */
     public void clear() {
-        cache.edit().clear().commit();
+        cache.edit().clear().apply();
+    }
+
+    public static boolean hasTokenInformation(Bundle bundle) {
+        if (bundle == null) {
+            return false;
+        }
+
+        String token = bundle.getString(TOKEN_KEY);
+        if ((token == null) || (token.length() == 0)) {
+            return false;
+        }
+
+        long expiresMilliseconds = bundle.getLong(EXPIRATION_DATE_KEY, 0L);
+        if (expiresMilliseconds == 0L) {
+            return false;
+        }
+
+        return true;
+    }
+
+    public static String getToken(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getString(TOKEN_KEY);
+    }
+
+    public static void putToken(Bundle bundle, String value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        bundle.putString(TOKEN_KEY, value);
+    }
+
+    public static Date getExpirationDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, EXPIRATION_DATE_KEY);
+    }
+
+    public static void putExpirationDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, EXPIRATION_DATE_KEY, value);
+    }
+
+    public static long getExpirationMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(EXPIRATION_DATE_KEY);
+    }
+
+    public static void putExpirationMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(EXPIRATION_DATE_KEY, value);
+    }
+
+    public static Set<String> getPermissions(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        ArrayList<String> arrayList = bundle.getStringArrayList(PERMISSIONS_KEY);
+        if (arrayList == null) {
+            return null;
+        }
+        return new HashSet<String>(arrayList);
+    }
+
+    public static void putPermissions(Bundle bundle, Collection<String> value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+
+        bundle.putStringArrayList(PERMISSIONS_KEY, new ArrayList<String>(value));
+    }
+
+    public static void putDeclinedPermissions(Bundle bundle, Collection<String> value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+
+        bundle.putStringArrayList(DECLINED_PERMISSIONS_KEY, new ArrayList<String>(value));
+    }
+
+    public static AccessTokenSource getSource(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        if (bundle.containsKey(TOKEN_SOURCE_KEY)) {
+            return (AccessTokenSource) bundle.getSerializable(TOKEN_SOURCE_KEY);
+        } else {
+            boolean isSSO = bundle.getBoolean(IS_SSO_KEY);
+            return isSSO ? AccessTokenSource.FACEBOOK_APPLICATION_WEB : AccessTokenSource.WEB_VIEW;
+        }
+    }
+
+    public static void putSource(Bundle bundle, AccessTokenSource value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putSerializable(TOKEN_SOURCE_KEY, value);
+    }
+
+    public static Date getLastRefreshDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, LAST_REFRESH_DATE_KEY);
+    }
+
+    public static void putLastRefreshDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, LAST_REFRESH_DATE_KEY, value);
+    }
+
+    public static long getLastRefreshMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(LAST_REFRESH_DATE_KEY);
+    }
+
+    public static void putLastRefreshMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(LAST_REFRESH_DATE_KEY, value);
+    }
+
+    public static String getApplicationId(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getString(APPLICATION_ID_KEY);
+    }
+
+    public static void putApplicationId(Bundle bundle, String value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putString(APPLICATION_ID_KEY, value);
+    }
+
+    static Date getDate(Bundle bundle, String key) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);
+        if (n == INVALID_BUNDLE_MILLISECONDS) {
+            return null;
+        }
+
+        return new Date(n);
+    }
+
+    static void putDate(Bundle bundle, String key, Date date) {
+        bundle.putLong(key, date.getTime());
     }
 
     private void serializeKey(String key, Bundle bundle, SharedPreferences.Editor editor)
@@ -384,7 +529,9 @@ private void deserializeKey(String key, Bundle bundle)
             ArrayList<String> stringList = new ArrayList<String>(numStrings);
             for (int i = 0; i < numStrings; i++) {
                 Object jsonStringValue = jsonArray.get(i);
-                stringList.add(i, jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
+                stringList.add(
+                        i,
+                        jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
             }
             bundle.putStringArrayList(key, stringList);
         } else if (valueType.equals(TYPE_ENUM)) {
diff --git a/facebook/src/com/facebook/LoggingBehavior.java b/facebook/src/com/facebook/LoggingBehavior.java
index 5fb198e9c..768a8b944 100644
--- a/facebook/src/com/facebook/LoggingBehavior.java
+++ b/facebook/src/com/facebook/LoggingBehavior.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -19,7 +23,7 @@
 /**
  * Specifies different categories of logging messages that can be generated.
  *
- * @see Settings#addLoggingBehavior(LoggingBehavior)
+ * @see FacebookSdk#addLoggingBehavior(LoggingBehavior)
  */
 public enum LoggingBehavior {
     /**
@@ -27,7 +31,8 @@
      */
     REQUESTS,
     /**
-     * Indicates that access tokens should be logged as part of the request logging; normally they are not.
+     * Indicates that access tokens should be logged as part of the request logging; normally they
+     * are not.
      */
     INCLUDE_ACCESS_TOKENS,
     /**
@@ -43,11 +48,22 @@
      */
     APP_EVENTS,
     /**
-     * Indicates that likely developer errors should be logged.  (This is set by default in LoggingBehavior.)
+     * Indicates that likely developer errors should be logged.  (This is set by default in
+     * LoggingBehavior.)
      */
-    DEVELOPER_ERRORS
-    ;
+    DEVELOPER_ERRORS,
+
+    /**
+     * Log debug warnings from API response, e.g. when friends fields requested, but user_friends
+     * permission isn't granted.
+     */
+    GRAPH_API_DEBUG_WARNING,
 
-    @Deprecated
-    public static final LoggingBehavior INSIGHTS = APP_EVENTS;
+    /**
+     * Log warnings from API response, e.g. when requested feature will be deprecated in next
+     * version of API. Info is the lowest level of severity, using it will result in logging all
+     * GRAPH_API_DEBUG levels.
+     */
+    GRAPH_API_DEBUG_INFO
+    ;
 }
diff --git a/facebook/src/com/facebook/LoginActivity.java b/facebook/src/com/facebook/LoginActivity.java
deleted file mode 100644
index 096f00eae..000000000
--- a/facebook/src/com/facebook/LoginActivity.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import com.facebook.android.R;
-
-/**
- * This Activity is a necessary part of the overall Facebook login process
- * but is not meant to be used directly. Add this activity to your
- * AndroidManifest.xml to ensure proper handling of Facebook login.
- * <pre>
- * {@code
- * <activity android:name="com.facebook.LoginActivity"
- *           android:theme="@android:style/Theme.Translucent.NoTitleBar"
- *           android:label="@string/app_name" />
- * }
- * </pre>
- * Do not start this activity directly.
- */
-public class LoginActivity extends Activity {
-    static final String RESULT_KEY = "com.facebook.LoginActivity:Result";
-
-    private static final String TAG = LoginActivity.class.getName();
-    private static final String NULL_CALLING_PKG_ERROR_MSG =
-            "Cannot call LoginActivity with a null calling package. " +
-                    "This can occur if the launchMode of the caller is singleInstance.";
-    private static final String SAVED_CALLING_PKG_KEY = "callingPackage";
-    private static final String SAVED_AUTH_CLIENT = "authorizationClient";
-    private static final String EXTRA_REQUEST = "request";
-
-    private String callingPackage;
-    private AuthorizationClient authorizationClient;
-    private AuthorizationClient.AuthorizationRequest request;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.com_facebook_login_activity_layout);
-
-        if (savedInstanceState != null) {
-            callingPackage = savedInstanceState.getString(SAVED_CALLING_PKG_KEY);
-            authorizationClient = (AuthorizationClient) savedInstanceState.getSerializable(SAVED_AUTH_CLIENT);
-        } else {
-            callingPackage = getCallingPackage();
-            authorizationClient = new AuthorizationClient();
-            request = (AuthorizationClient.AuthorizationRequest) getIntent().getSerializableExtra(EXTRA_REQUEST);
-        }
-
-        authorizationClient.setContext(this);
-        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
-            @Override
-            public void onCompleted(AuthorizationClient.Result outcome) {
-                onAuthClientCompleted(outcome);
-            }
-        });
-        authorizationClient.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
-            @Override
-            public void onBackgroundProcessingStarted() {
-                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
-            }
-
-            @Override
-            public void onBackgroundProcessingStopped() {
-                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
-            }
-        });
-    }
-
-    private void onAuthClientCompleted(AuthorizationClient.Result outcome) {
-        request = null;
-
-        int resultCode = (outcome.code == AuthorizationClient.Result.Code.CANCEL) ?
-                RESULT_CANCELED : RESULT_OK;
-
-        Bundle bundle = new Bundle();
-        bundle.putSerializable(RESULT_KEY, outcome);
-
-        Intent resultIntent = new Intent();
-        resultIntent.putExtras(bundle);
-        setResult(resultCode, resultIntent);
-
-        finish();
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        // If the calling package is null, this generally means that the callee was started
-        // with a launchMode of singleInstance. Unfortunately, Android does not allow a result
-        // to be set when the callee is a singleInstance, so we log an error and return.
-        if (callingPackage == null) {
-            Log.e(TAG, NULL_CALLING_PKG_ERROR_MSG);
-            finish();
-            return;
-        }
-
-        authorizationClient.startOrContinueAuth(request);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-
-        authorizationClient.cancelCurrentHandler();
-        findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        outState.putString(SAVED_CALLING_PKG_KEY, callingPackage);
-        outState.putSerializable(SAVED_AUTH_CLIENT, authorizationClient);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        authorizationClient.onActivityResult(requestCode, resultCode, data);
-    }
-
-    static Bundle populateIntentExtras(AuthorizationClient.AuthorizationRequest request) {
-        Bundle extras = new Bundle();
-        extras.putSerializable(EXTRA_REQUEST, request);
-        return extras;
-    }
-}
diff --git a/facebook/src/com/facebook/NativeAppCallAttachmentStore.java b/facebook/src/com/facebook/NativeAppCallAttachmentStore.java
deleted file mode 100644
index dc4108656..000000000
--- a/facebook/src/com/facebook/NativeAppCallAttachmentStore.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.util.Log;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-
-import java.io.*;
-import java.net.URLEncoder;
-import java.util.*;
-
-/**
- * <p>This class works in conjunction with {@link NativeAppCallContentProvider} to allow apps to attach binary
- * attachments (e.g., images) to native dialogs launched via the {@link com.facebook.widget.FacebookDialog}
- * class. It stores attachments in temporary files and allows the Facebook application to retrieve them via
- * the content provider.</p>
- *
- * <p>Callers are generally not expected to need to use this class directly;
- * see {@link com.facebook.widget.FacebookDialog.OpenGraphActionDialogBuilder#setImageAttachmentsForObject(String,
- * java.util.List) OpenGraphActionDialogBuilder.setImageAttachmentsForObject} for an example of a function
- * that will accept attachments, attach them to the native dialog call, and add them to the content provider
- * automatically.</p>
- **/
-public final class NativeAppCallAttachmentStore implements NativeAppCallContentProvider.AttachmentDataSource {
-    private static final String TAG = NativeAppCallAttachmentStore.class.getName();
-    static final String ATTACHMENTS_DIR_NAME = "com.facebook.NativeAppCallAttachmentStore.files";
-    private static File attachmentsDirectory;
-
-    /**
-     * Adds a number of bitmap attachments associated with a native app call. The attachments will be
-     * served via {@link NativeAppCallContentProvider#openFile(android.net.Uri, String) openFile}.
-     *
-     * @param context the Context the call is being made from
-     * @param callId the unique ID of the call
-     * @param imageAttachments a Map of attachment names to Bitmaps; the attachment names will be part of
-     *                         the URI processed by openFile
-     * @throws java.io.IOException
-     */
-    public void addAttachmentsForCall(Context context, UUID callId, Map<String, Bitmap> imageAttachments) {
-        Validate.notNull(context, "context");
-        Validate.notNull(callId, "callId");
-        Validate.containsNoNulls(imageAttachments.values(), "imageAttachments");
-        Validate.containsNoNullOrEmpty(imageAttachments.keySet(), "imageAttachments");
-
-        addAttachments(context, callId, imageAttachments, new ProcessAttachment<Bitmap>() {
-            @Override
-            public void processAttachment(Bitmap attachment, File outputFile) throws IOException {
-                FileOutputStream outputStream = new FileOutputStream(outputFile);
-                try {
-                    attachment.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);
-                } finally {
-                    Utility.closeQuietly(outputStream);
-                }
-            }
-        });
-    }
-
-    /**
-     * Adds a number of bitmap attachment files associated with a native app call. The attachments will be
-     * served via {@link NativeAppCallContentProvider#openFile(android.net.Uri, String) openFile}.
-     *
-     * @param context the Context the call is being made from
-     * @param callId the unique ID of the call
-     * @param imageAttachments a Map of attachment names to Files containing the bitmaps; the attachment names will be
-     *                         part of the URI processed by openFile
-     * @throws java.io.IOException
-     */
-    public void addAttachmentFilesForCall(Context context, UUID callId, Map<String, File> imageAttachmentFiles) {
-        Validate.notNull(context, "context");
-        Validate.notNull(callId, "callId");
-        Validate.containsNoNulls(imageAttachmentFiles.values(), "imageAttachmentFiles");
-        Validate.containsNoNullOrEmpty(imageAttachmentFiles.keySet(), "imageAttachmentFiles");
-
-        addAttachments(context, callId, imageAttachmentFiles, new ProcessAttachment<File>() {
-            @Override
-            public void processAttachment(File attachment, File outputFile) throws IOException {
-                FileOutputStream outputStream = new FileOutputStream(outputFile);
-                FileInputStream inputStream = null;
-                try {
-                    inputStream = new FileInputStream(attachment);
-
-                    byte[] buffer = new byte[1024];
-                    int len;
-                    while ((len = inputStream.read(buffer)) > 0) {
-                        outputStream.write(buffer, 0, len);
-                    }
-                } finally {
-                    Utility.closeQuietly(outputStream);
-                    Utility.closeQuietly(inputStream);
-                }
-            }
-        });
-    }
-
-    private <T> void addAttachments(Context context, UUID callId, Map<String, T> attachments,
-            ProcessAttachment<T> processor) {
-        if (attachments.size() == 0) {
-            return;
-        }
-
-        // If this is the first time we've been instantiated, clean up any existing attachments.
-        if (attachmentsDirectory == null) {
-            cleanupAllAttachments(context);
-        }
-
-        ensureAttachmentsDirectoryExists(context);
-
-        List<File> filesToCleanup = new ArrayList<File>();
-
-        try {
-            for (Map.Entry<String, T> entry : attachments.entrySet()) {
-                String attachmentName = entry.getKey();
-                T attachment = entry.getValue();
-
-                File file = getAttachmentFile(callId, attachmentName, true);
-                filesToCleanup.add(file);
-
-                processor.processAttachment(attachment, file);
-            }
-        } catch (IOException exception) {
-            Log.e(TAG, "Got unexpected exception:" + exception);
-            for (File file : filesToCleanup) {
-                try {
-                    file.delete();
-                } catch (Exception e) {
-                    // Always try to delete other files.
-                }
-            }
-            throw new FacebookException(exception);
-        }
-
-    }
-
-    interface ProcessAttachment<T> {
-        void processAttachment(T attachment, File outputFile) throws IOException;
-    }
-
-    /**
-     * Removes any temporary files associated with a particular native app call.
-     *
-     * @param context the Context the call is being made from
-     * @param callId the unique ID of the call
-     */
-    public void cleanupAttachmentsForCall(Context context, UUID callId) {
-        File dir = getAttachmentsDirectoryForCall(callId, false);
-        Utility.deleteDirectory(dir);
-    }
-
-    @Override
-    public File openAttachment(UUID callId, String attachmentName) throws FileNotFoundException {
-        if (Utility.isNullOrEmpty(attachmentName) ||
-                callId == null) {
-            throw new FileNotFoundException();
-        }
-
-        try {
-            return getAttachmentFile(callId, attachmentName, false);
-        } catch (IOException e) {
-            // We don't try to create the file, so we shouldn't get any IOExceptions. But if we do, just
-            // act like the file wasn't found.
-            throw new FileNotFoundException();
-        }
-    }
-
-    synchronized static File getAttachmentsDirectory(Context context) {
-        if (attachmentsDirectory == null) {
-            attachmentsDirectory = new File(context.getCacheDir(), ATTACHMENTS_DIR_NAME);
-        }
-        return attachmentsDirectory;
-    }
-
-    File ensureAttachmentsDirectoryExists(Context context) {
-        File dir = getAttachmentsDirectory(context);
-        dir.mkdirs();
-        return dir;
-    }
-
-    File getAttachmentsDirectoryForCall(UUID callId, boolean create) {
-        if (attachmentsDirectory == null) {
-            return null;
-        }
-
-        File dir = new File(attachmentsDirectory, callId.toString());
-        if (create && !dir.exists()) {
-            dir.mkdirs();
-        }
-        return dir;
-    }
-
-    File getAttachmentFile(UUID callId, String attachmentName, boolean createDirs) throws IOException {
-        File dir = getAttachmentsDirectoryForCall(callId, createDirs);
-        if (dir == null) {
-            return null;
-        }
-
-        try {
-            return new File(dir, URLEncoder.encode(attachmentName, "UTF-8"));
-        } catch (UnsupportedEncodingException e) {
-            return null;
-        }
-    }
-
-    void cleanupAllAttachments(Context context) {
-        // Attachments directory may or may not exist; we won't create it if not, since we are just going to delete it.
-        File dir = getAttachmentsDirectory(context);
-        Utility.deleteDirectory(dir);
-    }
-}
diff --git a/facebook/src/com/facebook/NativeAppCallContentProvider.java b/facebook/src/com/facebook/NativeAppCallContentProvider.java
deleted file mode 100644
index bde165f58..000000000
--- a/facebook/src/com/facebook/NativeAppCallContentProvider.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-import android.util.Log;
-import android.util.Pair;
-
-import java.io.*;
-import java.util.*;
-
-/**
- * <p>Implements a <a href="http://developer.android.com/reference/android/content/ContentProvider.html">
- * ContentProvider</a> that can be used to provide binary attachments (e.g., images) to calls made
- * via @link FacebookDialog}. The {@link NativeAppCallAttachmentStore} class provides methods to attach
- * and clean up the attachments.
- *
- * <p>Note that this ContentProvider is only necessary if an application wishes to attach images, etc., that are
- * stored in memory and do not have another way to be referenced by a content URI. For images obtained from,
- * e.g., the Camera or Gallery, that already have a content URI associated with them, use of this class is not
- * necessary.</p>
- *
- * <p>If an application wishes to attach images that are stored in-memory within the application, this content
- * provider must be listed in the application's AndroidManifest.xml, and it should be named according to the
- * pattern <code>"com.facebook.app.NativeAppCallContentProvider{FACEBOOK_APP_ID}"</code>. See the
- * {@link NativeAppCallContentProvider#getAttachmentUrl(String) getContentProviderName} method.</p>
- */
-public class NativeAppCallContentProvider extends ContentProvider {
-    private static final String TAG = NativeAppCallContentProvider.class.getName();
-    private static final String ATTACHMENT_URL_BASE = "content://com.facebook.app.NativeAppCallContentProvider";
-
-    private final AttachmentDataSource dataSource;
-
-    public NativeAppCallContentProvider() {
-        this(new NativeAppCallAttachmentStore());
-    }
-
-    NativeAppCallContentProvider(AttachmentDataSource dataSource) {
-        this.dataSource = dataSource;
-    }
-
-    interface AttachmentDataSource {
-        File openAttachment(UUID callId, String attachmentName) throws FileNotFoundException;
-    }
-
-    /**
-     * Returns the name of the content provider formatted correctly for constructing URLs.
-     * @param applicationId the Facebook application ID of the application
-     * @return the String to use as the authority portion of a content URI.
-     */
-    public static String getAttachmentUrl(String applicationId, UUID callId, String attachmentName) {
-        return String.format("%s%s/%s/%s", ATTACHMENT_URL_BASE, applicationId, callId.toString(), attachmentName);
-    }
-
-    @Override
-    public boolean onCreate() {
-        return true;
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] strings, String s, String[] strings2, String s2) {
-        return null;
-    }
-
-    @Override
-    public String getType(Uri uri) {
-        return null;
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues contentValues) {
-        return null;
-    }
-
-    @Override
-    public int delete(Uri uri, String s, String[] strings) {
-        return 0;
-    }
-
-    @Override
-    public int update(Uri uri, ContentValues contentValues, String s, String[] strings) {
-        return 0;
-    }
-
-    @Override
-    public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode)
-            throws java.io.FileNotFoundException {
-
-        Pair<UUID, String> callIdAndAttachmentName = parseCallIdAndAttachmentName(uri);
-        if (callIdAndAttachmentName == null) {
-            throw new FileNotFoundException();
-        }
-
-        try {
-            File file = dataSource.openAttachment(callIdAndAttachmentName.first, callIdAndAttachmentName.second);
-
-            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        } catch (FileNotFoundException exception) {
-            Log.e(TAG, "Got unexpected exception:" + exception);
-            throw exception;
-        }
-    }
-
-    Pair<UUID, String> parseCallIdAndAttachmentName(Uri uri) {
-        try {
-            // We don't do explicit format checking here. Malformed URIs may generate NullPointerExceptions or
-            // array bounds exceptions, which we'll catch and return null. All of these will result in a
-            // FileNotFoundException being thrown in openFile.
-            String callIdAndAttachmentName = uri.getPath().substring(1);
-            String [] parts = callIdAndAttachmentName.split("/");
-
-            String callIdString = parts[0];
-            String attachmentName = parts[1];
-            UUID callId = UUID.fromString(callIdString);
-
-            return new Pair<UUID, String>(callId, attachmentName);
-        } catch (Exception exception) {
-            return null;
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java b/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
deleted file mode 100644
index 1f4c56216..000000000
--- a/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-
-/**
- * Implements a trivial {@link TokenCachingStrategy} that does not actually cache any tokens.
- * It is intended for use when an access token may be used on a temporary basis but should not be
- * cached for future use (for instance, when handling a deep link).
- */
-public class NonCachingTokenCachingStrategy extends TokenCachingStrategy {
-    @Override
-    public Bundle load() {
-        return null;
-    }
-
-    @Override
-    public void save(Bundle bundle) {
-    }
-
-    @Override
-    public void clear() {
-    }
-}
diff --git a/facebook/src/com/facebook/Profile.java b/facebook/src/com/facebook/Profile.java
new file mode 100644
index 000000000..919ba1686
--- /dev/null
+++ b/facebook/src/com/facebook/Profile.java
@@ -0,0 +1,313 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
+
+import com.facebook.internal.ImageRequest;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * This class represents a basic Facebook profile.
+ */
+public final class Profile implements Parcelable {
+    private static final String ID_KEY = "id";
+    private static final String FIRST_NAME_KEY = "first_name";
+    private static final String MIDDLE_NAME_KEY = "middle_name";
+    private static final String LAST_NAME_KEY = "last_name";
+    private static final String NAME_KEY = "name";
+    private static final String LINK_URI_KEY = "link_uri";
+
+    private final String id;
+    private final String firstName;
+    private final String middleName;
+    private final String lastName;
+    private final String name;
+    private final Uri linkUri;
+
+    /**
+     * Getter for the profile that is currently logged in to the application.
+     * @return The profile that is currently logged in to the application.
+     */
+    public static Profile getCurrentProfile()
+    {
+        return ProfileManager.getInstance().getCurrentProfile();
+    }
+
+    /**
+     * Setter for the profile that is currently logged in to the application. If the access token is
+     * invalidated, the current profile will not be updated. It's only updated when there is an
+     * explicit logout, login or when permissions change via the
+     * {@link com.facebook.login.LoginManager}.
+     * @param profile The profile that is currently logged in to the application.
+     */
+    public static void setCurrentProfile(Profile profile) {
+        ProfileManager.getInstance().setCurrentProfile(profile);
+    }
+
+    /**
+     * Fetches and sets the current profile from the current access token.
+     * <p/>
+     * This should only be called from the UI thread.
+     */
+    public static void fetchProfileForCurrentAccessToken() {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken == null) {
+            Profile.setCurrentProfile(null);
+            return;
+        }
+
+        Utility.getGraphMeRequestWithCacheAsync(accessToken.getToken(),
+                new Utility.GraphMeRequestWithCacheCallback() {
+                    @Override
+                    public void onSuccess(JSONObject userInfo) {
+                        String id = userInfo.optString("id");
+                        if (id == null) {
+                            return;
+                        }
+                        String link = userInfo.optString("link");
+                        Profile profile = new Profile(
+                                id,
+                                userInfo.optString("first_name"),
+                                userInfo.optString("middle_name"),
+                                userInfo.optString("last_name"),
+                                userInfo.optString("name"),
+                                link != null ? Uri.parse(link) : null
+                        );
+                        Profile.setCurrentProfile(profile);
+                    }
+
+                    @Override
+                    public void onFailure(FacebookException error) {
+                        return;
+                    }
+                });
+    }
+
+    /**
+     * Contructor.
+     * @param id         The id of the profile.
+     * @param firstName  The first name of the profile. Can be null.
+     * @param middleName The middle name of the profile. Can be null.
+     * @param lastName   The last name of the profile. Can be null.
+     * @param name       The name of the profile. Can be null.
+     * @param linkUri    The link for this profile. Can be null.
+     */
+    public Profile(
+            final String id,
+            @Nullable
+            final String firstName,
+            @Nullable
+            final String middleName,
+            @Nullable
+            final String lastName,
+            @Nullable
+            final String name,
+            @Nullable
+            final Uri linkUri) {
+        Validate.notNullOrEmpty(id, "id");
+
+        this.id = id;
+        this.firstName = firstName;
+        this.middleName = middleName;
+        this.lastName = lastName;
+        this.name = name;
+        this.linkUri = linkUri;
+    }
+
+    /**
+     * Getter for the Uri of the profile picture.
+     *
+     * @param width  The desired width for the profile picture.
+     * @param height The desired height for the profile picture.
+     * @return The Uri of the profile picture.
+     */
+    public Uri getProfilePictureUri(
+            int width,
+            int height) {
+        return ImageRequest.getProfilePictureUri(this.id, width, height);
+    }
+
+    /**
+     * Getter for the id of the profile.
+     * @return id of the profile.
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Getter for the first name of the profile.
+     * @return the first name of the profile.
+     */
+    public String getFirstName() {
+        return firstName;
+    }
+
+    /**
+     * Getter for the middle name of the profile.
+     * @return the middle name of the profile.
+     */
+    public String getMiddleName() {
+        return middleName;
+    }
+
+    /**
+     * Getter for the last name of the profile.
+     * @return the last name of the profile.
+     */
+    public String getLastName() {
+        return lastName;
+    }
+
+    /**
+     * Getter for the name of the profile.
+     * @return the name of the profile.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Getter for the link of the profile.
+     * @return the link of the profile.
+     */
+    public Uri getLinkUri() {
+        return linkUri;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+
+        if (!(other instanceof Profile)) {
+            return false;
+        }
+
+        Profile o = (Profile) other;
+
+        return id.equals(o.id) &&
+                firstName == null ? o.firstName == null : firstName.equals(o.firstName) &&
+                middleName == null ? o.middleName == null : middleName.equals(o.middleName) &&
+                lastName == null ? o.lastName == null : lastName.equals(o.lastName) &&
+                name == null ? o.name == null : name.equals(o.name) &&
+                linkUri == null ? o.linkUri == null : linkUri.equals(o.linkUri);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+
+        result = result * 31 + id.hashCode();
+        if (firstName != null) {
+            result = result * 31 + firstName.hashCode();
+        }
+        if (middleName != null) {
+            result = result * 31 + middleName.hashCode();
+        }
+        if (lastName != null) {
+            result = result * 31 + lastName.hashCode();
+        }
+        if (name != null) {
+            result = result * 31 + name.hashCode();
+        }
+        if (linkUri != null) {
+            result = result * 31 + linkUri.hashCode();
+        }
+
+        return result;
+    }
+
+    JSONObject toJSONObject() {
+        JSONObject jsonObject = new JSONObject();
+        try {
+            jsonObject.put(ID_KEY, id);
+            jsonObject.put(FIRST_NAME_KEY, firstName);
+            jsonObject.put(MIDDLE_NAME_KEY, middleName);
+            jsonObject.put(LAST_NAME_KEY, lastName);
+            jsonObject.put(NAME_KEY, name);
+            if (linkUri != null) {
+                jsonObject.put(LINK_URI_KEY, linkUri.toString());
+            }
+        } catch (JSONException object) {
+            jsonObject = null;
+        }
+        return jsonObject;
+    }
+
+    Profile(JSONObject jsonObject) {
+        id = jsonObject.optString(ID_KEY, null);
+        firstName = jsonObject.optString(FIRST_NAME_KEY, null);
+        middleName = jsonObject.optString(MIDDLE_NAME_KEY, null);
+        lastName = jsonObject.optString(LAST_NAME_KEY, null);
+        name = jsonObject.optString(NAME_KEY, null);
+        String linkUriString = jsonObject.optString(LINK_URI_KEY, null);
+        linkUri = linkUriString == null ? null : Uri.parse(linkUriString);
+    }
+
+    private Profile(Parcel source) {
+        id = source.readString();
+        firstName = source.readString();
+        middleName = source.readString();
+        lastName = source.readString();
+        name = source.readString();
+        String linkUriString = source.readString();
+        linkUri = linkUriString == null ? null : Uri.parse(linkUriString);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(id);
+        dest.writeString(firstName);
+        dest.writeString(middleName);
+        dest.writeString(lastName);
+        dest.writeString(name);
+        dest.writeString(linkUri == null ? null : linkUri.toString());
+    }
+
+    public static final Parcelable.Creator<Profile> CREATOR = new Parcelable.Creator() {
+
+        @Override
+        public Profile createFromParcel(Parcel source) {
+            return new Profile(source);
+        }
+
+        @Override
+        public Profile[] newArray(int size) {
+            return new Profile[size];
+        }
+    };
+}
diff --git a/facebook/src/com/facebook/ProfileCache.java b/facebook/src/com/facebook/ProfileCache.java
new file mode 100644
index 000000000..3569bab37
--- /dev/null
+++ b/facebook/src/com/facebook/ProfileCache.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.facebook.internal.Validate;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+final class ProfileCache {
+    static final String CACHED_PROFILE_KEY = "com.facebook.ProfileManager.CachedProfile";
+    static final String SHARED_PREFERENCES_NAME =
+            "com.facebook.AccessTokenManager.SharedPreferences";
+
+    private final SharedPreferences sharedPreferences;
+
+    ProfileCache() {
+        sharedPreferences = FacebookSdk.getApplicationContext().getSharedPreferences(
+                SHARED_PREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+    }
+
+    Profile load() {
+        String jsonString = sharedPreferences.getString(CACHED_PROFILE_KEY, null);
+        if (jsonString != null) {
+            try {
+                JSONObject jsonObject = new JSONObject(jsonString);
+                return new Profile(jsonObject);
+            } catch (JSONException e) {
+                // Can't recover
+            }
+        }
+        return null;
+    }
+
+    void save(Profile profile) {
+        Validate.notNull(profile, "profile");
+        JSONObject jsonObject = profile.toJSONObject();
+        if (jsonObject != null) {
+            sharedPreferences
+                    .edit()
+                    .putString(CACHED_PROFILE_KEY, jsonObject.toString())
+                    .apply();
+        }
+    }
+
+    void clear() {
+        sharedPreferences
+                .edit()
+                .remove(CACHED_PROFILE_KEY)
+                .apply();
+    }
+}
diff --git a/facebook/src/com/facebook/ProfileManager.java b/facebook/src/com/facebook/ProfileManager.java
new file mode 100644
index 000000000..1f14b2554
--- /dev/null
+++ b/facebook/src/com/facebook/ProfileManager.java
@@ -0,0 +1,115 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+final class ProfileManager {
+    static final String ACTION_CURRENT_PROFILE_CHANGED =
+            "com.facebook.sdk.ACTION_CURRENT_PROFILE_CHANGED";
+    static final String EXTRA_OLD_PROFILE =
+            "com.facebook.sdk.EXTRA_OLD_PROFILE";
+    static final String EXTRA_NEW_PROFILE =
+            "com.facebook.sdk.EXTRA_NEW_PROFILE";
+
+    private static volatile ProfileManager instance;
+
+    private final LocalBroadcastManager localBroadcastManager;
+    private final ProfileCache profileCache;
+    private Profile currentProfile;
+
+
+    ProfileManager(
+            LocalBroadcastManager localBroadcastManager,
+            ProfileCache profileCache) {
+        Validate.notNull(localBroadcastManager, "localBroadcastManager");
+        Validate.notNull(profileCache, "profileCache");
+        this.localBroadcastManager = localBroadcastManager;
+        this.profileCache = profileCache;
+    }
+
+    static ProfileManager getInstance() {
+        if (instance == null) {
+            synchronized (ProfileManager.class) {
+                if (instance == null) {
+                    Context applicationContext = FacebookSdk.getApplicationContext();
+                    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(
+                            applicationContext);
+
+                    instance = new ProfileManager(localBroadcastManager, new ProfileCache());
+                }
+            }
+        }
+        return instance;
+    }
+
+    Profile getCurrentProfile() {
+        return currentProfile;
+    }
+
+    boolean loadCurrentProfile() {
+        Profile profile = profileCache.load();
+
+        if (profile != null) {
+            setCurrentProfile(profile, false);
+            return true;
+        }
+
+        return false;
+    }
+
+    void setCurrentProfile(Profile currentProfile) {
+        setCurrentProfile(currentProfile, true);
+    }
+
+    private void setCurrentProfile(Profile currentProfile, boolean writeToCache) {
+        Profile oldProfile = this.currentProfile;
+        this.currentProfile = currentProfile;
+
+        if (writeToCache) {
+            if (currentProfile != null) {
+                profileCache.save(currentProfile);
+            } else {
+                profileCache.clear();
+            }
+        }
+
+        if (!Utility.areObjectsEqual(oldProfile, currentProfile)) {
+            sendCurrentProfileChangedBroadcast(oldProfile, currentProfile);
+        }
+    }
+
+    private void sendCurrentProfileChangedBroadcast(
+            Profile oldProfile,
+            Profile currentProfile) {
+        Intent intent = new Intent(ACTION_CURRENT_PROFILE_CHANGED);
+
+        intent.putExtra(EXTRA_OLD_PROFILE, oldProfile);
+        intent.putExtra(EXTRA_NEW_PROFILE, currentProfile);
+
+        localBroadcastManager.sendBroadcast(intent);
+    }
+}
diff --git a/facebook/src/com/facebook/ProfileTracker.java b/facebook/src/com/facebook/ProfileTracker.java
new file mode 100644
index 000000000..8ee010c8e
--- /dev/null
+++ b/facebook/src/com/facebook/ProfileTracker.java
@@ -0,0 +1,116 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.internal.Validate;
+
+/**
+ * This class can be extended to receive notifications of profile changes. The {@link
+ * #stopTracking()} method should be called in the onDestroy() method of the receiving Activity or
+ * Fragment.
+ */
+abstract public class ProfileTracker {
+
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+    private boolean isTracking = false;
+
+    /**
+     * The method that will be called when the profile changes.
+     * @param oldProfile The profile before the change.
+     * @param currentProfile The new profile.
+     */
+    protected abstract void onCurrentProfileChanged(
+            Profile oldProfile,
+            Profile currentProfile);
+
+    /**
+     * Constructor.
+     */
+    public ProfileTracker() {
+        Validate.sdkInitialized();
+        this.receiver = new ProfileBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(
+                FacebookSdk.getApplicationContext());
+        startTracking();
+    }
+
+    /**
+     * Starts tracking the current profile.
+     */
+    public void startTracking() {
+        if (isTracking) {
+            return;
+        }
+
+        addBroadcastReceiver();
+
+        isTracking = true;
+    }
+
+    /**
+     * Stops tracking the current profile.
+     */
+    public void stopTracking() {
+        if (!isTracking) {
+            return;
+        }
+
+        broadcastManager.unregisterReceiver(receiver);
+        isTracking = false;
+    }
+
+    /**
+     * Gets whether the tracker is tracking the current access token.
+     * @return true if the tracker is the tracking the current access token, false if not
+     */
+    public boolean isTracking() {
+        return isTracking;
+    }
+
+    private class ProfileBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (ProfileManager.ACTION_CURRENT_PROFILE_CHANGED.equals(intent.getAction())) {
+
+                Profile oldProfile = (Profile) intent
+                        .getParcelableExtra(ProfileManager.EXTRA_OLD_PROFILE);
+                Profile newProfile = (Profile) intent
+                        .getParcelableExtra(ProfileManager.EXTRA_NEW_PROFILE);
+
+                onCurrentProfileChanged(oldProfile, newProfile);
+            }
+        }
+    }
+
+    private void addBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(ProfileManager.ACTION_CURRENT_PROFILE_CHANGED);
+
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+}
diff --git a/facebook/src/com/facebook/ProgressNoopOutputStream.java b/facebook/src/com/facebook/ProgressNoopOutputStream.java
index e0e3770df..71f7bb45d 100644
--- a/facebook/src/com/facebook/ProgressNoopOutputStream.java
+++ b/facebook/src/com/facebook/ProgressNoopOutputStream.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -23,10 +27,10 @@
 import java.util.Map;
 
 class ProgressNoopOutputStream extends OutputStream implements RequestOutputStream {
-    private final Map<Request, RequestProgress> progressMap = new HashMap<Request, RequestProgress>();
+    private final Map<GraphRequest, RequestProgress> progressMap = new HashMap<GraphRequest, RequestProgress>();
     private final Handler callbackHandler;
 
-    private Request currentRequest;
+    private GraphRequest currentRequest;
     private RequestProgress currentRequestProgress;
     private int batchMax;
 
@@ -34,16 +38,17 @@
         this.callbackHandler = callbackHandler;
     }
 
-    public void setCurrentRequest(Request currentRequest) {
+    public void setCurrentRequest(GraphRequest currentRequest) {
         this.currentRequest = currentRequest;
-        this.currentRequestProgress = currentRequest != null? progressMap.get(currentRequest) : null;
+        this.currentRequestProgress =
+                currentRequest != null? progressMap.get(currentRequest) : null;
     }
 
     int getMaxProgress() {
         return batchMax;
     }
 
-    Map<Request,RequestProgress> getProgressMap() {
+    Map<GraphRequest,RequestProgress> getProgressMap() {
         return progressMap;
     }
 
diff --git a/facebook/src/com/facebook/ProgressOutputStream.java b/facebook/src/com/facebook/ProgressOutputStream.java
index 780baffd6..8a650e678 100644
--- a/facebook/src/com/facebook/ProgressOutputStream.java
+++ b/facebook/src/com/facebook/ProgressOutputStream.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -24,20 +28,24 @@
 import java.util.Map;
 
 class ProgressOutputStream extends FilterOutputStream implements RequestOutputStream {
-    private final Map<Request, RequestProgress> progressMap;
-    private final RequestBatch requests;
+    private final Map<GraphRequest, RequestProgress> progressMap;
+    private final GraphRequestBatch requests;
     private final long threshold;
 
     private long batchProgress, lastReportedProgress, maxProgress;
     private RequestProgress currentRequestProgress;
 
-    ProgressOutputStream(OutputStream out, RequestBatch requests, Map<Request, RequestProgress> progressMap, long maxProgress) {
+    ProgressOutputStream(
+            OutputStream out,
+            GraphRequestBatch requests,
+            Map<GraphRequest, RequestProgress> progressMap,
+            long maxProgress) {
         super(out);
         this.requests = requests;
         this.progressMap = progressMap;
         this.maxProgress = maxProgress;
 
-        this.threshold = Settings.getOnProgressThreshold();
+        this.threshold = FacebookSdk.getOnProgressThreshold();
     }
 
     private void addProgress(long size) {
@@ -54,12 +62,13 @@ private void addProgress(long size) {
 
     private void reportBatchProgress() {
         if (batchProgress > lastReportedProgress) {
-            for (RequestBatch.Callback callback : requests.getCallbacks()) {
-                if (callback instanceof RequestBatch.OnProgressCallback) {
+            for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
+                if (callback instanceof GraphRequestBatch.OnProgressCallback) {
                     final Handler callbackHandler = requests.getCallbackHandler();
 
                     // Keep copies to avoid threading issues
-                    final RequestBatch.OnProgressCallback progressCallback = (RequestBatch.OnProgressCallback) callback;
+                    final GraphRequestBatch.OnProgressCallback progressCallback =
+                            (GraphRequestBatch.OnProgressCallback) callback;
                     if (callbackHandler == null) {
                         progressCallback.onBatchProgress(requests, batchProgress, maxProgress);
                     }
@@ -67,7 +76,10 @@ private void reportBatchProgress() {
                         callbackHandler.post(new Runnable() {
                             @Override
                             public void run() {
-                                progressCallback.onBatchProgress(requests, batchProgress, maxProgress);
+                                progressCallback.onBatchProgress(
+                                        requests,
+                                        batchProgress,
+                                        maxProgress);
                             }
                         });
                     }
@@ -78,7 +90,7 @@ public void run() {
         }
     }
 
-    public void setCurrentRequest(Request request) {
+    public void setCurrentRequest(GraphRequest request) {
         currentRequestProgress = request != null? progressMap.get(request) : null;
     }
 
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
deleted file mode 100644
index e7660f6c0..000000000
--- a/facebook/src/com/facebook/Request.java
+++ /dev/null
@@ -1,2440 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.location.Location;
-import android.net.Uri;
-import android.os.*;
-import android.text.TextUtils;
-import android.util.Pair;
-import com.facebook.internal.ServerProtocol;
-import com.facebook.model.*;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.*;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLEncoder;
-import java.text.SimpleDateFormat;
-import java.util.*;
-import java.util.Map.Entry;
-
-/**
- * A single request to be sent to the Facebook Platform through either the <a
- * href="https://developers.facebook.com/docs/reference/api/">Graph API</a> or <a
- * href="https://developers.facebook.com/docs/reference/rest/">REST API</a>. The Request class provides functionality
- * relating to serializing and deserializing requests and responses, making calls in batches (with a single round-trip
- * to the service) and making calls asynchronously.
- *
- * The particular service endpoint that a request targets is determined by either a graph path (see the
- * {@link #setGraphPath(String) setGraphPath} method) or a REST method name (see the {@link #setRestMethod(String)
- * setRestMethod} method); a single request may not target both.
- *
- * A Request can be executed either anonymously or representing an authenticated user. In the former case, no Session
- * needs to be specified, while in the latter, a Session that is in an opened state must be provided. If requests are
- * executed in a batch, a Facebook application ID must be associated with the batch, either by supplying a Session for
- * at least one of the requests in the batch (the first one found in the batch will be used) or by calling the
- * {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
- *
- * After completion of a request, its Session, if any, will be checked to determine if its Facebook access token needs
- * to be extended; if so, a request to extend it will be issued in the background.
- */
-public class Request {
-    /**
-     * The maximum number of requests that can be submitted in a single batch. This limit is enforced on the service
-     * side by the Facebook platform, not by the Request class.
-     */
-    public static final int MAXIMUM_BATCH_SIZE = 50;
-
-    private static final String ME = "me";
-    private static final String MY_FRIENDS = "me/friends";
-    private static final String MY_PHOTOS = "me/photos";
-    private static final String MY_VIDEOS = "me/videos";
-    private static final String VIDEOS_SUFFIX = "/videos";
-    private static final String SEARCH = "search";
-    private static final String MY_FEED = "me/feed";
-    private static final String MY_STAGING_RESOURCES = "me/staging_resources";
-    private static final String MY_OBJECTS_FORMAT = "me/objects/%s";
-    private static final String MY_ACTION_FORMAT = "me/%s";
-
-    private static final String USER_AGENT_BASE = "FBAndroidSDK";
-    private static final String USER_AGENT_HEADER = "User-Agent";
-    private static final String CONTENT_TYPE_HEADER = "Content-Type";
-
-    // Parameter names/values
-    private static final String PICTURE_PARAM = "picture";
-    private static final String FORMAT_PARAM = "format";
-    private static final String FORMAT_JSON = "json";
-    private static final String SDK_PARAM = "sdk";
-    private static final String SDK_ANDROID = "android";
-    private static final String ACCESS_TOKEN_PARAM = "access_token";
-    private static final String BATCH_ENTRY_NAME_PARAM = "name";
-    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM = "omit_response_on_success";
-    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
-    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
-    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
-    private static final String BATCH_BODY_PARAM = "body";
-    private static final String BATCH_METHOD_PARAM = "method";
-    private static final String BATCH_PARAM = "batch";
-    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
-    private static final String ATTACHED_FILES_PARAM = "attached_files";
-    private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle";
-    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
-    private static final String STAGING_PARAM = "file";
-    private static final String OBJECT_PARAM = "object";
-
-    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
-
-    private static String defaultBatchApplicationId;
-
-    private Session session;
-    private HttpMethod httpMethod;
-    private String graphPath;
-    private GraphObject graphObject;
-    private String restMethod;
-    private String batchEntryName;
-    private String batchEntryDependsOn;
-    private boolean batchEntryOmitResultOnSuccess = true;
-    private Bundle parameters;
-    private Callback callback;
-    private String overriddenURL;
-    private Object tag;
-
-    /**
-     * Constructs a request without a session, graph path, or any other parameters.
-     */
-    public Request() {
-        this(null, null, null, null, null);
-    }
-
-    /**
-     * Constructs a request with a Session to retrieve a particular graph path. A Session need not be provided, in which
-     * case the request is sent without an access token and thus is not executed in the context of any particular user.
-     * Only certain graph requests can be expected to succeed in this case. If a Session is provided, it must be in an
-     * opened state or the request will fail.
-     *
-     * @param session
-     *            the Session to use, or null
-     * @param graphPath
-     *            the graph path to retrieve
-     */
-    public Request(Session session, String graphPath) {
-        this(session, graphPath, null, null, null);
-    }
-
-    /**
-     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
-     * provided, in which case the request is sent without an access token and thus is not executed in the context of
-     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
-     * provided, it must be in an opened state or the request will fail.
-     *
-     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
-     *
-     * @param session
-     *            the Session to use, or null
-     * @param graphPath
-     *            the graph path to retrieve, create, or delete
-     * @param parameters
-     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
-     *            Bitmaps, Dates, or Byte arrays.
-     * @param httpMethod
-     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
-     */
-    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod) {
-        this(session, graphPath, parameters, httpMethod, null);
-    }
-
-    /**
-     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
-     * provided, in which case the request is sent without an access token and thus is not executed in the context of
-     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
-     * provided, it must be in an opened state or the request will fail.
-     *
-     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
-     *
-     * @param session
-     *            the Session to use, or null
-     * @param graphPath
-     *            the graph path to retrieve, create, or delete
-     * @param parameters
-     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
-     *            Bitmaps, Dates, or Byte arrays.
-     * @param httpMethod
-     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     */
-    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod, Callback callback) {
-        this.session = session;
-        this.graphPath = graphPath;
-        this.callback = callback;
-
-        setHttpMethod(httpMethod);
-
-        if (parameters != null) {
-            this.parameters = new Bundle(parameters);
-        } else {
-            this.parameters = new Bundle();
-        }
-
-        if (!this.parameters.containsKey(MIGRATION_BUNDLE_PARAM)) {
-            this.parameters.putString(MIGRATION_BUNDLE_PARAM, FacebookSdkVersion.MIGRATION_BUNDLE);
-        }
-    }
-
-    Request(Session session, URL overriddenURL) {
-        this.session = session;
-        this.overriddenURL = overriddenURL.toString();
-
-        setHttpMethod(HttpMethod.GET);
-
-        this.parameters = new Bundle();
-    }
-
-    /**
-     * Creates a new Request configured to post a GraphObject to a particular graph path, to either create or update the
-     * object at that path.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param graphPath
-     *            the graph path to retrieve, create, or delete
-     * @param graphObject
-     *            the GraphObject to create or update
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newPostRequest(Session session, String graphPath, GraphObject graphObject, Callback callback) {
-        Request request = new Request(session, graphPath, null, HttpMethod.POST , callback);
-        request.setGraphObject(graphObject);
-        return request;
-    }
-
-    /**
-     * Creates a new Request configured to make a call to the Facebook REST API.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param restMethod
-     *            the method in the Facebook REST API to execute
-     * @param parameters
-     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
-     *            Bitmaps, Dates, or Byte arrays.
-     * @param httpMethod
-     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
-     * @return a Request that is ready to execute
-     */
-    public static Request newRestRequest(Session session, String restMethod, Bundle parameters, HttpMethod httpMethod) {
-        Request request = new Request(session, null, parameters, httpMethod);
-        request.setRestMethod(restMethod);
-        return request;
-    }
-
-    /**
-     * Creates a new Request configured to retrieve a user's own profile.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newMeRequest(Session session, final GraphUserCallback callback) {
-        Callback wrapper = new Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                if (callback != null) {
-                    callback.onCompleted(response.getGraphObjectAs(GraphUser.class), response);
-                }
-            }
-        };
-        return new Request(session, ME, null, null, wrapper);
-    }
-
-    /**
-     * Creates a new Request configured to retrieve a user's friend list.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newMyFriendsRequest(Session session, final GraphUserListCallback callback) {
-        Callback wrapper = new Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                if (callback != null) {
-                    callback.onCompleted(typedListFromResponse(response, GraphUser.class), response);
-                }
-            }
-        };
-        return new Request(session, MY_FRIENDS, null, null, wrapper);
-    }
-
-    /**
-     * Creates a new Request configured to upload a photo to the user's default photo album.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param image
-     *            the image to upload
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUploadPhotoRequest(Session session, Bitmap image, Callback callback) {
-        Bundle parameters = new Bundle(1);
-        parameters.putParcelable(PICTURE_PARAM, image);
-
-        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
-     * will be read from the specified stream.
-     *
-     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
-     * @param file     the file containing the photo to upload
-     * @param callback a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUploadPhotoRequest(Session session, File file,
-            Callback callback) throws FileNotFoundException {
-        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        Bundle parameters = new Bundle(1);
-        parameters.putParcelable(PICTURE_PARAM, descriptor);
-
-        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
-     * will be read from the specified file descriptor.
-     *
-     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
-     * @param file     the file to upload
-     * @param callback a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUploadVideoRequest(Session session, File file,
-            Callback callback) throws FileNotFoundException {
-        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        Bundle parameters = new Bundle(1);
-        parameters.putParcelable(file.getName(), descriptor);
-
-        return new Request(session, MY_VIDEOS, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to retrieve a particular graph path.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param graphPath
-     *            the graph path to retrieve
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newGraphPathRequest(Session session, String graphPath, Callback callback) {
-        return new Request(session, graphPath, null, null, callback);
-    }
-
-    /**
-     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
-     * API. At least one of location or searchText must be specified.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param location
-     *            the location around which to search; only the latitude and longitude components of the location are
-     *            meaningful
-     * @param radiusInMeters
-     *            the radius around the location to search, specified in meters; this is ignored if
-     *            no location is specified
-     * @param resultsLimit
-     *            the maximum number of results to return
-     * @param searchText
-     *            optional text to search for as part of the name or type of an object
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     *
-     * @throws FacebookException If neither location nor searchText is specified
-     */
-    public static Request newPlacesSearchRequest(Session session, Location location, int radiusInMeters,
-            int resultsLimit, String searchText, final GraphPlaceListCallback callback) {
-        if (location == null && Utility.isNullOrEmpty(searchText)) {
-            throw new FacebookException("Either location or searchText must be specified.");
-        }
-
-        Bundle parameters = new Bundle(5);
-        parameters.putString("type", "place");
-        parameters.putInt("limit", resultsLimit);
-        if (location != null) {
-            parameters.putString("center",
-                    String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
-            parameters.putInt("distance", radiusInMeters);
-        }
-        if (!Utility.isNullOrEmpty(searchText)) {
-            parameters.putString("q", searchText);
-        }
-
-        Callback wrapper = new Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                if (callback != null) {
-                    callback.onCompleted(typedListFromResponse(response, GraphPlace.class), response);
-                }
-            }
-        };
-
-        return new Request(session, SEARCH, parameters, HttpMethod.GET, wrapper);
-    }
-
-    /**
-     * Creates a new Request configured to post a status update to a user's feed.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param message
-     *            the text of the status update
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newStatusUpdateRequest(Session session, String message, Callback callback) {
-        return newStatusUpdateRequest(session, message, (String)null, null, callback);
-    }
-
-    /**
-     * Creates a new Request configured to post a status update to a user's feed.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param message
-     *            the text of the status update
-     * @param placeId
-     *            an optional place id to associate with the post
-     * @param tagIds
-     *            an optional list of user ids to tag in the post
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    private static Request newStatusUpdateRequest(Session session, String message, String placeId, List<String> tagIds,
-            Callback callback) {
-
-        Bundle parameters = new Bundle();
-        parameters.putString("message", message);
-
-        if (placeId != null) {
-            parameters.putString("place", placeId);
-        }
-
-        if (tagIds != null && tagIds.size() > 0) {
-            String tags = TextUtils.join(",", tagIds);
-            parameters.putString("tags", tags);
-        }
-
-        return new Request(session, MY_FEED, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to post a status update to a user's feed.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param message
-     *            the text of the status update
-     * @param place
-     *            an optional place to associate with the post
-     * @param tags
-     *            an optional list of users to tag in the post
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newStatusUpdateRequest(Session session, String message, GraphPlace place,
-            List<GraphUser> tags, Callback callback) {
-
-        List<String> tagIds = null;
-        if (tags != null) {
-            tagIds = new ArrayList<String>(tags.size());
-            for (GraphUser tag: tags) {
-                tagIds.add(tag.getId());
-            }
-        }
-        String placeId = place == null ? null : place.getId();
-        return newStatusUpdateRequest(session, message, placeId, tagIds, callback);
-    }
-
-    /**
-     * Creates a new Request configured to retrieve an App User ID for the app's Facebook user.  Callers
-     * will send this ID back to their own servers, collect up a set to create a Facebook Custom Audience with,
-     * and then use the resultant Custom Audience to target ads.
-     * <p/>
-     * The GraphObject in the response will include an "custom_audience_third_party_id" property, with the value
-     * being the ID retrieved.  This ID is an encrypted encoding of the Facebook user's ID and the
-     * invoking Facebook app ID.  Multiple calls with the same user will return different IDs, thus these IDs cannot be
-     * used to correlate behavior across devices or applications, and are only meaningful when sent back to Facebook
-     * for creating Custom Audiences.
-     * <p/>
-     * The ID retrieved represents the Facebook user identified in the following way: if the specified session
-     * (or activeSession if the specified session is `null`) is open, the ID will represent the user associated with
-     * the activeSession; otherwise the ID will represent the user logged into the native Facebook app on the device.
-     * A `null` ID will be provided into the callback if a) there is no native Facebook app, b) no one is logged into
-     * it, or c) the app has previously called
-     * {@link Settings#setLimitEventAndDataUsage(android.content.Context, boolean)} with `true` for this user.
-     *
-     * @param session
-     *            the Session to issue the Request on, or null; if non-null, the session must be in an opened state.
-     *            If there is no logged-in Facebook user, null is the expected choice.
-     * @param context
-     *            the Application context from which the app ID will be pulled, and from which the 'attribution ID'
-     *            for the Facebook user is determined.  If there has been no app ID set, an exception will be thrown.
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions.
-     *            The GraphObject in the Response will contain a "custom_audience_third_party_id" property that
-     *            represents the user as described above.
-     * @return a Request that is ready to execute
-     */
-    public static Request newCustomAudienceThirdPartyIdRequest(Session session, Context context, Callback callback) {
-        return newCustomAudienceThirdPartyIdRequest(session, context, null, callback);
-    }
-
-    /**
-     * Creates a new Request configured to retrieve an App User ID for the app's Facebook user.  Callers
-     * will send this ID back to their own servers, collect up a set to create a Facebook Custom Audience with,
-     * and then use the resultant Custom Audience to target ads.
-     * <p/>
-     * The GraphObject in the response will include an "custom_audience_third_party_id" property, with the value
-     * being the ID retrieved.  This ID is an encrypted encoding of the Facebook user's ID and the
-     * invoking Facebook app ID.  Multiple calls with the same user will return different IDs, thus these IDs cannot be
-     * used to correlate behavior across devices or applications, and are only meaningful when sent back to Facebook
-     * for creating Custom Audiences.
-     * <p/>
-     * The ID retrieved represents the Facebook user identified in the following way: if the specified session
-     * (or activeSession if the specified session is `null`) is open, the ID will represent the user associated with
-     * the activeSession; otherwise the ID will represent the user logged into the native Facebook app on the device.
-     * A `null` ID will be provided into the callback if a) there is no native Facebook app, b) no one is logged into
-     * it, or c) the app has previously called
-     * {@link Settings#setLimitEventAndDataUsage(android.content.Context, boolean)} ;} with `true` for this user.
-     *
-     * @param session
-     *            the Session to issue the Request on, or null; if non-null, the session must be in an opened state.
-     *            If there is no logged-in Facebook user, null is the expected choice.
-     * @param context
-     *            the Application context from which the app ID will be pulled, and from which the 'attribution ID'
-     *            for the Facebook user is determined.  If there has been no app ID set, an exception will be thrown.
-     * @param applicationId
-     *            explicitly specified Facebook App ID.  If null, and there's a valid session, then the application ID
-     *            from the session will be used, otherwise the application ID from metadata will be used.
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions.
-     *            The GraphObject in the Response will contain a "custom_audience_third_party_id" property that
-     *            represents the user as described above.
-     * @return a Request that is ready to execute
-     */
-    public static Request newCustomAudienceThirdPartyIdRequest(Session session,
-            Context context, String applicationId, Callback callback) {
-
-        // if provided session or activeSession is opened, use it.
-        if (session == null) {
-            session = Session.getActiveSession();
-        }
-
-        if (session != null && !session.isOpened()) {
-            session = null;
-        }
-
-        if (applicationId == null) {
-            if (session != null) {
-                applicationId = session.getApplicationId();
-            } else {
-                applicationId = Utility.getMetadataApplicationId(context);
-            }
-        }
-
-        if (applicationId == null) {
-            throw new FacebookException("Facebook App ID cannot be determined");
-        }
-
-        String endpoint = applicationId + "/custom_audience_third_party_id";
-
-        Bundle parameters = new Bundle();
-        if (session == null) {
-            // Only use the attributionID if we don't have an open session.  If we do have an open session, then
-            // the user token will be used to identify the user, and is more reliable than the attributionID.
-            String attributionId = Settings.getAttributionId(context.getContentResolver());
-            if (attributionId != null) {
-                parameters.putString("udid", attributionId);
-            }
-        }
-
-        // Server will choose to not provide the App User ID in the event that event usage has been limited for
-        // this user for this app.
-        if (Settings.getLimitEventAndDataUsage(context)) {
-            parameters.putString("limit_event_usage", "1");
-        }
-
-        return new Request(session, endpoint, parameters, HttpMethod.GET, callback);
-    }
-
-    /**
-     * Creates a new Request configured to upload an image to create a staging resource. Staging resources
-     * allow you to post binary data such as images, in preparation for a post of an Open Graph object or action
-     * which references the image. The URI returned when uploading a staging resource may be passed as the image
-     * property for an Open Graph object or action.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param image
-     *            the image to upload
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUploadStagingResourceWithImageRequest(Session session,
-            Bitmap image, Callback callback) {
-        Bundle parameters = new Bundle(1);
-        parameters.putParcelable(STAGING_PARAM, image);
-
-        return new Request(session, MY_STAGING_RESOURCES, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to upload an image to create a staging resource. Staging resources
-     * allow you to post binary data such as images, in preparation for a post of an Open Graph object or action
-     * which references the image. The URI returned when uploading a staging resource may be passed as the image
-     * property for an Open Graph object or action.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param file
-     *            the file containing the image to upload
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUploadStagingResourceWithImageRequest(Session session,
-            File file, Callback callback) throws FileNotFoundException {
-        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        ParcelFileDescriptorWithMimeType descriptorWithMimeType = new ParcelFileDescriptorWithMimeType(descriptor, "image/png");
-        Bundle parameters = new Bundle(1);
-        parameters.putParcelable(STAGING_PARAM, descriptorWithMimeType);
-
-        return new Request(session, MY_STAGING_RESOURCES, parameters, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to create a user owned Open Graph object.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param openGraphObject
-     *            the Open Graph object to create; must not be null, and must have a non-empty type and title
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newPostOpenGraphObjectRequest(Session session,
-            OpenGraphObject openGraphObject, Callback callback) {
-        if (openGraphObject == null) {
-            throw new FacebookException("openGraphObject cannot be null");
-        }
-        if (Utility.isNullOrEmpty(openGraphObject.getType())) {
-            throw new FacebookException("openGraphObject must have non-null 'type' property");
-        }
-        if (Utility.isNullOrEmpty(openGraphObject.getTitle())) {
-            throw new FacebookException("openGraphObject must have non-null 'title' property");
-        }
-
-        String path = String.format(MY_OBJECTS_FORMAT, openGraphObject.getType());
-        Bundle bundle = new Bundle();
-        bundle.putString(OBJECT_PARAM, openGraphObject.getInnerJSONObject().toString());
-        return new Request(session, path, bundle, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to create a user owned Open Graph object.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param type
-     *            the fully-specified Open Graph object type (e.g., my_app_namespace:my_object_name); must not be null
-     * @param title
-     *            the title of the Open Graph object; must not be null
-     * @param imageUrl
-     *            the link to an image to be associated with the Open Graph object; may be null
-     * @param url
-     *            the url to be associated with the Open Graph object; may be null
-     * @param description
-     *            the description to be associated with the object; may be null
-     * @param objectProperties
-     *            any additional type-specific properties for the Open Graph object; may be null
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions;
-     *            may be null
-     * @return a Request that is ready to execute
-     */
-    public static Request newPostOpenGraphObjectRequest(Session session, String type, String title, String imageUrl,
-            String url, String description, GraphObject objectProperties, Callback callback) {
-        OpenGraphObject openGraphObject = OpenGraphObject.Factory.createForPost(OpenGraphObject.class, type, title,
-                imageUrl, url, description);
-        if (objectProperties != null) {
-            openGraphObject.setData(objectProperties);
-        }
-
-        return newPostOpenGraphObjectRequest(session, openGraphObject, callback);
-    }
-
-    /**
-     * Creates a new Request configured to publish an Open Graph action.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param openGraphAction
-     *            the Open Graph object to create; must not be null, and must have a non-empty 'type'
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newPostOpenGraphActionRequest(Session session, OpenGraphAction openGraphAction,
-            Callback callback) {
-        if (openGraphAction == null) {
-            throw new FacebookException("openGraphAction cannot be null");
-        }
-        if (Utility.isNullOrEmpty(openGraphAction.getType())) {
-            throw new FacebookException("openGraphAction must have non-null 'type' property");
-        }
-
-        String path = String.format(MY_ACTION_FORMAT, openGraphAction.getType());
-        return newPostRequest(session, path, openGraphAction, callback);
-    }
-
-    /**
-     * Creates a new Request configured to delete a resource through the Graph API.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param id
-     *            the id of the object to delete
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newDeleteObjectRequest(Session session, String id, Callback callback) {
-        return new Request(session, id, null, HttpMethod.DELETE, callback);
-    }
-
-    /**
-     * Creates a new Request configured to update a user owned Open Graph object.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param openGraphObject
-     *            the Open Graph object to update, which must have a valid 'id' property
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUpdateOpenGraphObjectRequest(Session session, OpenGraphObject openGraphObject,
-            Callback callback) {
-        if (openGraphObject == null) {
-            throw new FacebookException("openGraphObject cannot be null");
-        }
-
-        String path = openGraphObject.getId();
-        if (path == null) {
-            throw new FacebookException("openGraphObject must have an id");
-        }
-
-        Bundle bundle = new Bundle();
-        bundle.putString(OBJECT_PARAM, openGraphObject.getInnerJSONObject().toString());
-        return new Request(session, path, bundle, HttpMethod.POST, callback);
-    }
-
-    /**
-     * Creates a new Request configured to update a user owned Open Graph object.
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param id
-     *            the id of the Open Graph object
-     * @param title
-     *            the title of the Open Graph object
-     * @param imageUrl
-     *            the link to an image to be associated with the Open Graph object
-     * @param url
-     *            the url to be associated with the Open Graph object
-     * @param description
-     *            the description to be associated with the object
-     * @param objectProperties
-     *            any additional type-specific properties for the Open Graph object
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a Request that is ready to execute
-     */
-    public static Request newUpdateOpenGraphObjectRequest(Session session, String id, String title, String imageUrl,
-            String url, String description, GraphObject objectProperties, Callback callback) {
-        OpenGraphObject openGraphObject = OpenGraphObject.Factory.createForPost(OpenGraphObject.class, null, title,
-                imageUrl, url, description);
-        openGraphObject.setId(id);
-        openGraphObject.setData(objectProperties);
-
-        return newUpdateOpenGraphObjectRequest(session, openGraphObject, callback);
-    }
-
-    /**
-     * Returns the GraphObject, if any, associated with this request.
-     *
-     * @return the GraphObject associated with this requeset, or null if there is none
-     */
-    public final GraphObject getGraphObject() {
-        return this.graphObject;
-    }
-
-    /**
-     * Sets the GraphObject associated with this request. This is meaningful only for POST requests.
-     *
-     * @param graphObject
-     *            the GraphObject to upload along with this request
-     */
-    public final void setGraphObject(GraphObject graphObject) {
-        this.graphObject = graphObject;
-    }
-
-    /**
-     * Returns the graph path of this request, if any.
-     *
-     * @return the graph path of this request, or null if there is none
-     */
-    public final String getGraphPath() {
-        return this.graphPath;
-    }
-
-    /**
-     * Sets the graph path of this request. A graph path may not be set if a REST method has been specified.
-     *
-     * @param graphPath
-     *            the graph path for this request
-     */
-    public final void setGraphPath(String graphPath) {
-        this.graphPath = graphPath;
-    }
-
-    /**
-     * Returns the {@link HttpMethod} to use for this request.
-     *
-     * @return the HttpMethod
-     */
-    public final HttpMethod getHttpMethod() {
-        return this.httpMethod;
-    }
-
-    /**
-     * Sets the {@link HttpMethod} to use for this request.
-     *
-     * @param httpMethod
-     *            the HttpMethod, or null for the default (HttpMethod.GET).
-     */
-    public final void setHttpMethod(HttpMethod httpMethod) {
-        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
-            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
-            }
-        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
-    }
-
-    /**
-     * Returns the parameters for this request.
-     *
-     * @return the parameters
-     */
-    public final Bundle getParameters() {
-        return this.parameters;
-    }
-
-    /**
-     * Sets the parameters for this request.
-     *
-     * @param parameters
-     *            the parameters
-     */
-    public final void setParameters(Bundle parameters) {
-        this.parameters = parameters;
-    }
-
-    /**
-     * Returns the REST method to call for this request.
-     *
-     * @return the REST method
-     */
-    public final String getRestMethod() {
-        return this.restMethod;
-    }
-
-    /**
-     * Sets the REST method to call for this request. A REST method may not be set if a graph path has been specified.
-     *
-     * @param restMethod
-     *            the REST method to call
-     */
-    public final void setRestMethod(String restMethod) {
-        this.restMethod = restMethod;
-    }
-
-    /**
-     * Returns the Session associated with this request.
-     *
-     * @return the Session associated with this request, or null if none has been specified
-     */
-    public final Session getSession() {
-        return this.session;
-    }
-
-    /**
-     * Sets the Session to use for this request. The Session does not need to be opened at the time it is specified, but
-     * it must be opened by the time the request is executed.
-     *
-     * @param session
-     *            the Session to use for this request
-     */
-    public final void setSession(Session session) {
-        this.session = session;
-    }
-
-    /**
-     * Returns the name of this request's entry in a batched request.
-     *
-     * @return the name of this request's batch entry, or null if none has been specified
-     */
-    public final String getBatchEntryName() {
-        return this.batchEntryName;
-    }
-
-    /**
-     * Sets the name of this request's entry in a batched request. This value is only used if this request is submitted
-     * as part of a batched request. It can be used to specified dependencies between requests. See <a
-     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
-     * documentation for more details.
-     *
-     * @param batchEntryName
-     *            the name of this request's entry in a batched request, which must be unique within a particular batch
-     *            of requests
-     */
-    public final void setBatchEntryName(String batchEntryName) {
-        this.batchEntryName = batchEntryName;
-    }
-
-    /**
-     * Returns the name of the request that this request entry explicitly depends on in a batched request.
-     *
-     * @return the name of this request's dependency, or null if none has been specified
-     */
-    public final String getBatchEntryDependsOn() {
-        return this.batchEntryDependsOn;
-    }
-
-    /**
-     * Sets the name of the request entry that this request explicitly depends on in a batched request. This value is
-     * only used if this request is submitted as part of a batched request. It can be used to specified dependencies
-     * between requests. See <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in
-     * the Graph API documentation for more details.
-     *
-     * @param batchEntryDependsOn
-     *            the name of the request entry that this entry depends on in a batched request
-     */
-    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
-        this.batchEntryDependsOn = batchEntryDependsOn;
-    }
-
-
-    /**
-     * Returns whether or not this batch entry will return a response if it is successful. Only applies if another
-     * request entry in the batch specifies this entry as a dependency.
-     *
-     * @return the name of this request's dependency, or null if none has been specified
-     */
-    public final boolean getBatchEntryOmitResultOnSuccess() {
-        return this.batchEntryOmitResultOnSuccess;
-    }
-
-    /**
-     * Sets whether or not this batch entry will return a response if it is successful. Only applies if another
-     * request entry in the batch specifies this entry as a dependency. See
-     * <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
-     * documentation for more details.
-     *
-     * @param batchEntryOmitResultOnSuccess
-     *            the name of the request entry that this entry depends on in a batched request
-     */
-    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
-        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
-    }
-
-    /**
-     * Gets the default Facebook application ID that will be used to submit batched requests if none of those requests
-     * specifies a Session. Batched requests require an application ID, so either at least one request in a batch must
-     * specify a Session or the application ID must be specified explicitly.
-     *
-     * @return the Facebook application ID to use for batched requests if none can be determined
-     */
-    public static final String getDefaultBatchApplicationId() {
-        return Request.defaultBatchApplicationId;
-    }
-
-    /**
-     * Sets the default application ID that will be used to submit batched requests if none of those requests specifies
-     * a Session. Batched requests require an application ID, so either at least one request in a batch must specify a
-     * Session or the application ID must be specified explicitly.
-     *
-     * @param applicationId
-     *            the Facebook application ID to use for batched requests if none can be determined
-     */
-    public static final void setDefaultBatchApplicationId(String applicationId) {
-        defaultBatchApplicationId = applicationId;
-    }
-
-    /**
-     * Returns the callback which will be called when the request finishes.
-     *
-     * @return the callback
-     */
-    public final Callback getCallback() {
-        return callback;
-    }
-
-    /**
-     * Sets the callback which will be called when the request finishes.
-     *
-     * @param callback
-     *            the callback
-     */
-    public final void setCallback(Callback callback) {
-        this.callback = callback;
-    }
-
-    /**
-     * Sets the tag on the request; this is an application-defined object that can be used to distinguish
-     * between different requests. Its value has no effect on the execution of the request.
-     *
-     * @param tag an object to serve as a tag, or null
-     */
-    public final void setTag(Object tag) {
-        this.tag = tag;
-    }
-
-    /**
-     * Gets the tag on the request; this is an application-defined object that can be used to distinguish
-     * between different requests. Its value has no effect on the execution of the request.
-     *
-     * @return an object that serves as a tag, or null
-     */
-    public final Object getTag() {
-        return tag;
-    }
-
-    /**
-     * Starts a new Request configured to post a GraphObject to a particular graph path, to either create or update the
-     * object at that path.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newPostRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param graphPath
-     *            the graph path to retrieve, create, or delete
-     * @param graphObject
-     *            the GraphObject to create or update
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executePostRequestAsync(Session session, String graphPath, GraphObject graphObject,
-            Callback callback) {
-        return newPostRequest(session, graphPath, graphObject, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to make a call to the Facebook REST API.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newRestRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param restMethod
-     *            the method in the Facebook REST API to execute
-     * @param parameters
-     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
-     *            Bitmaps, Dates, or Byte arrays.
-     * @param httpMethod
-     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeRestRequestAsync(Session session, String restMethod, Bundle parameters,
-            HttpMethod httpMethod) {
-        return newRestRequest(session, restMethod, parameters, httpMethod).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to retrieve a user's own profile.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newMeRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeMeRequestAsync(Session session, GraphUserCallback callback) {
-        return newMeRequest(session, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to retrieve a user's friend list.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newMyFriendsRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeMyFriendsRequestAsync(Session session, GraphUserListCallback callback) {
-        return newMyFriendsRequest(session, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to upload a photo to the user's default photo album.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newUploadPhotoRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param image
-     *            the image to upload
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, Bitmap image, Callback callback) {
-        return newUploadPhotoRequest(session, image, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to upload a photo to the user's default photo album. The photo
-     * will be read from the specified stream.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newUploadPhotoRequest(...).executeAsync();
-     *
-     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
-     * @param file     the file containing the photo to upload
-     * @param callback a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, File file,
-            Callback callback) throws FileNotFoundException {
-        return newUploadPhotoRequest(session, file, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to retrieve a particular graph path.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newGraphPathRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param graphPath
-     *            the graph path to retrieve
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeGraphPathRequestAsync(Session session, String graphPath, Callback callback) {
-        return newGraphPathRequest(session, graphPath, callback).executeAsync();
-    }
-
-    /**
-     * Starts a new Request that is configured to perform a search for places near a specified location via the Graph
-     * API.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newPlacesSearchRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param location
-     *            the location around which to search; only the latitude and longitude components of the location are
-     *            meaningful
-     * @param radiusInMeters
-     *            the radius around the location to search, specified in meters
-     * @param resultsLimit
-     *            the maximum number of results to return
-     * @param searchText
-     *            optional text to search for as part of the name or type of an object
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     *
-     * @throws FacebookException If neither location nor searchText is specified
-     */
-    @Deprecated
-    public static RequestAsyncTask executePlacesSearchRequestAsync(Session session, Location location,
-            int radiusInMeters, int resultsLimit, String searchText, GraphPlaceListCallback callback) {
-        return newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText, callback)
-                .executeAsync();
-    }
-
-    /**
-     * Starts a new Request configured to post a status update to a user's feed.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * This method is deprecated. Prefer to call Request.newStatusUpdateRequest(...).executeAsync();
-     *
-     * @param session
-     *            the Session to use, or null; if non-null, the session must be in an opened state
-     * @param message
-     *            the text of the status update
-     * @param callback
-     *            a callback that will be called when the request is completed to handle success or error conditions
-     * @return a RequestAsyncTask that is executing the request
-     */
-    @Deprecated
-    public static RequestAsyncTask executeStatusUpdateRequestAsync(Session session, String message, Callback callback) {
-        return newStatusUpdateRequest(session, message, callback).executeAsync();
-    }
-
-    /**
-     * Executes this request and returns the response.
-     * <p/>
-     * This should only be called if you have transitioned off the UI thread.
-     *
-     * @return the Response object representing the results of the request
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     * @throws IllegalArgumentException
-     */
-    public final Response executeAndWait() {
-        return Request.executeAndWait(this);
-    }
-
-    /**
-     * Executes this request and returns the response.
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @return a RequestAsyncTask that is executing the request
-     *
-     * @throws IllegalArgumentException
-     */
-    public final RequestAsyncTask executeAsync() {
-        return Request.executeBatchAsync(this);
-    }
-
-    /**
-     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
-     * explicitly by the caller.
-     *
-     * @param requests
-     *            one or more Requests to serialize
-     * @return an HttpURLConnection which is ready to execute
-     *
-     * @throws FacebookException
-     *            If any of the requests in the batch are badly constructed or if there are problems
-     *            contacting the service
-     * @throws IllegalArgumentException if the passed in array is zero-length
-     * @throws NullPointerException if the passed in array or any of its contents are null
-     */
-    public static HttpURLConnection toHttpConnection(Request... requests) {
-        return toHttpConnection(Arrays.asList(requests));
-    }
-
-    /**
-     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
-     * explicitly by the caller.
-     *
-     * @param requests
-     *            one or more Requests to serialize
-     * @return an HttpURLConnection which is ready to execute
-     *
-     * @throws FacebookException
-     *            If any of the requests in the batch are badly constructed or if there are problems
-     *            contacting the service
-     * @throws IllegalArgumentException if the passed in collection is empty
-     * @throws NullPointerException if the passed in collection or any of its contents are null
-     */
-    public static HttpURLConnection toHttpConnection(Collection<Request> requests) {
-        Validate.notEmptyAndContainsNoNulls(requests, "requests");
-
-        return toHttpConnection(new RequestBatch(requests));
-    }
-
-
-    /**
-     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
-     * explicitly by the caller.
-     *
-     * @param requests
-     *            a RequestBatch to serialize
-     * @return an HttpURLConnection which is ready to execute
-     *
-     * @throws FacebookException
-     *            If any of the requests in the batch are badly constructed or if there are problems
-     *            contacting the service
-     * @throws IllegalArgumentException
-     */
-    public static HttpURLConnection toHttpConnection(RequestBatch requests) {
-
-        for (Request request : requests) {
-            request.validate();
-        }
-
-        URL url = null;
-        try {
-            if (requests.size() == 1) {
-                // Single request case.
-                Request request = requests.get(0);
-                // In the non-batch case, the URL we use really is the same one returned by getUrlForSingleRequest.
-                url = new URL(request.getUrlForSingleRequest());
-            } else {
-                // Batch case -- URL is just the graph API base, individual request URLs are serialized
-                // as relative_url parameters within each batch entry.
-                url = new URL(ServerProtocol.getGraphUrlBase());
-            }
-        } catch (MalformedURLException e) {
-            throw new FacebookException("could not construct URL for request", e);
-        }
-
-        HttpURLConnection connection;
-        try {
-            connection = createConnection(url);
-
-            serializeToUrlConnection(requests, connection);
-        } catch (IOException e) {
-            throw new FacebookException("could not construct request body", e);
-        } catch (JSONException e) {
-            throw new FacebookException("could not construct request body", e);
-        }
-
-        return connection;
-    }
-
-    /**
-     * Executes a single request on the current thread and returns the response.
-     * <p/>
-     * This should only be used if you have transitioned off the UI thread.
-     *
-     * @param request
-     *            the Request to execute
-     *
-     * @return the Response object representing the results of the request
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     */
-    public static Response executeAndWait(Request request) {
-        List<Response> responses = executeBatchAndWait(request);
-
-        if (responses == null || responses.size() != 1) {
-            throw new FacebookException("invalid state: expected a single response");
-        }
-
-        return responses.get(0);
-    }
-
-    /**
-     * Executes requests on the current thread as a single batch and returns the responses.
-     * <p/>
-     * This should only be used if you have transitioned off the UI thread.
-     *
-     * @param requests
-     *            the Requests to execute
-     *
-     * @return a list of Response objects representing the results of the requests; responses are returned in the same
-     *         order as the requests were specified.
-     *
-     * @throws NullPointerException
-     *            In case of a null request
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     */
-    public static List<Response> executeBatchAndWait(Request... requests) {
-        Validate.notNull(requests, "requests");
-
-        return executeBatchAndWait(Arrays.asList(requests));
-    }
-
-    /**
-     * Executes requests as a single batch on the current thread and returns the responses.
-     * <p/>
-     * This should only be used if you have transitioned off the UI thread.
-     *
-     * @param requests
-     *            the Requests to execute
-     *
-     * @return a list of Response objects representing the results of the requests; responses are returned in the same
-     *         order as the requests were specified.
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     */
-    public static List<Response> executeBatchAndWait(Collection<Request> requests) {
-        return executeBatchAndWait(new RequestBatch(requests));
-    }
-
-    /**
-     * Executes requests on the current thread as a single batch and returns the responses.
-     * <p/>
-     * This should only be used if you have transitioned off the UI thread.
-     *
-     * @param requests
-     *            the batch of Requests to execute
-     *
-     * @return a list of Response objects representing the results of the requests; responses are returned in the same
-     *         order as the requests were specified.
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     * @throws IllegalArgumentException if the passed in RequestBatch is empty
-     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
-     */
-    public static List<Response> executeBatchAndWait(RequestBatch requests) {
-        Validate.notEmptyAndContainsNoNulls(requests, "requests");
-
-        HttpURLConnection connection = null;
-        try {
-            connection = toHttpConnection(requests);
-        } catch (Exception ex) {
-            List<Response> responses = Response.constructErrorResponses(requests.getRequests(), null, new FacebookException(ex));
-            runCallbacks(requests, responses);
-            return responses;
-        }
-
-        List<Response> responses = executeConnectionAndWait(connection, requests);
-        return responses;
-    }
-
-    /**
-     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
-     * be processed on a separate thread. In order to process results of a request, or determine whether a request
-     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @param requests
-     *            the Requests to execute
-     * @return a RequestAsyncTask that is executing the request
-     *
-     * @throws NullPointerException
-     *            If a null request is passed in
-     */
-    public static RequestAsyncTask executeBatchAsync(Request... requests) {
-        Validate.notNull(requests, "requests");
-
-        return executeBatchAsync(Arrays.asList(requests));
-    }
-
-    /**
-     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
-     * be processed on a separate thread. In order to process results of a request, or determine whether a request
-     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @param requests
-     *            the Requests to execute
-     * @return a RequestAsyncTask that is executing the request
-     *
-     * @throws IllegalArgumentException if the passed in collection is empty
-     * @throws NullPointerException if the passed in collection or any of its contents are null
-     */
-    public static RequestAsyncTask executeBatchAsync(Collection<Request> requests) {
-        return executeBatchAsync(new RequestBatch(requests));
-    }
-
-    /**
-     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
-     * be processed on a separate thread. In order to process results of a request, or determine whether a request
-     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @param requests
-     *            the RequestBatch to execute
-     * @return a RequestAsyncTask that is executing the request
-     *
-     * @throws IllegalArgumentException if the passed in RequestBatch is empty
-     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
-     */
-    public static RequestAsyncTask executeBatchAsync(RequestBatch requests) {
-        Validate.notEmptyAndContainsNoNulls(requests, "requests");
-
-        RequestAsyncTask asyncTask = new RequestAsyncTask(requests);
-        asyncTask.executeOnSettingsExecutor();
-        return asyncTask;
-    }
-
-    /**
-     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
-     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
-     * ensure that it will correctly generate the desired responses.
-     * <p/>
-     * This should only be called if you have transitioned off the UI thread.
-     *
-     * @param connection
-     *            the HttpURLConnection that the requests were serialized into
-     * @param requests
-     *            the requests represented by the HttpURLConnection
-     * @return a list of Responses corresponding to the requests
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     */
-    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, Collection<Request> requests) {
-        return executeConnectionAndWait(connection, new RequestBatch(requests));
-    }
-
-    /**
-     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
-     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
-     * ensure that it will correctly generate the desired responses.
-     * <p/>
-     * This should only be called if you have transitioned off the UI thread.
-     *
-     * @param connection
-     *            the HttpURLConnection that the requests were serialized into
-     * @param requests
-     *            the RequestBatch represented by the HttpURLConnection
-     * @return a list of Responses corresponding to the requests
-     *
-     * @throws FacebookException
-     *            If there was an error in the protocol used to communicate with the service
-     */
-    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, RequestBatch requests) {
-        List<Response> responses = Response.fromHttpConnection(connection, requests);
-
-        Utility.disconnectQuietly(connection);
-
-        int numRequests = requests.size();
-        if (numRequests != responses.size()) {
-            throw new FacebookException(String.format("Received %d responses while expecting %d", responses.size(),
-                    numRequests));
-        }
-
-        runCallbacks(requests, responses);
-
-        // See if any of these sessions needs its token to be extended. We do this after issuing the request so as to
-        // reduce network contention.
-        HashSet<Session> sessions = new HashSet<Session>();
-        for (Request request : requests) {
-            if (request.session != null) {
-                sessions.add(request.session);
-            }
-        }
-        for (Session session : sessions) {
-            session.extendAccessTokenIfNeeded();
-        }
-
-        return responses;
-    }
-
-    /**
-     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
-     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
-     * responsibility to ensure that it will correctly generate the desired responses. This function will return
-     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
-     * or determine whether a request succeeded or failed, a callback must be specified (see the
-     * {@link #setCallback(Callback) setCallback} method).
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @param connection
-     *            the HttpURLConnection that the requests were serialized into
-     * @param requests
-     *            the requests represented by the HttpURLConnection
-     * @return a RequestAsyncTask that is executing the request
-     */
-    public static RequestAsyncTask executeConnectionAsync(HttpURLConnection connection, RequestBatch requests) {
-        return executeConnectionAsync(null, connection, requests);
-    }
-
-    /**
-     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
-     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
-     * responsibility to ensure that it will correctly generate the desired responses. This function will return
-     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
-     * or determine whether a request succeeded or failed, a callback must be specified (see the
-     * {@link #setCallback(Callback) setCallback} method)
-     * <p/>
-     * This should only be called from the UI thread.
-     *
-     * @param callbackHandler
-     *            a Handler that will be used to post calls to the callback for each request; if null, a Handler will be
-     *            instantiated on the calling thread
-     * @param connection
-     *            the HttpURLConnection that the requests were serialized into
-     * @param requests
-     *            the requests represented by the HttpURLConnection
-     * @return a RequestAsyncTask that is executing the request
-     */
-    public static RequestAsyncTask executeConnectionAsync(Handler callbackHandler, HttpURLConnection connection,
-            RequestBatch requests) {
-        Validate.notNull(connection, "connection");
-
-        RequestAsyncTask asyncTask = new RequestAsyncTask(connection, requests);
-        requests.setCallbackHandler(callbackHandler);
-        asyncTask.executeOnSettingsExecutor();
-        return asyncTask;
-    }
-
-    /**
-     * Returns a string representation of this Request, useful for debugging.
-     *
-     * @return the debugging information
-     */
-    @Override
-    public String toString() {
-        return new StringBuilder().append("{Request: ").append(" session: ").append(session).append(", graphPath: ")
-                .append(graphPath).append(", graphObject: ").append(graphObject).append(", restMethod: ")
-                .append(restMethod).append(", httpMethod: ").append(httpMethod).append(", parameters: ")
-                .append(parameters).append("}").toString();
-    }
-
-    static void runCallbacks(final RequestBatch requests, List<Response> responses) {
-        int numRequests = requests.size();
-
-        // Compile the list of callbacks to call and then run them either on this thread or via the Handler we received
-        final ArrayList<Pair<Callback, Response>> callbacks = new ArrayList<Pair<Callback, Response>>();
-        for (int i = 0; i < numRequests; ++i) {
-            Request request = requests.get(i);
-            if (request.callback != null) {
-                callbacks.add(new Pair<Callback, Response>(request.callback, responses.get(i)));
-            }
-        }
-
-        if (callbacks.size() > 0) {
-            Runnable runnable = new Runnable() {
-                public void run() {
-                    for (Pair<Callback, Response> pair : callbacks) {
-                        pair.first.onCompleted(pair.second);
-                    }
-
-                    List<RequestBatch.Callback> batchCallbacks = requests.getCallbacks();
-                    for (RequestBatch.Callback batchCallback : batchCallbacks) {
-                        batchCallback.onBatchCompleted(requests);
-                    }
-                }
-            };
-
-            Handler callbackHandler = requests.getCallbackHandler();
-            if (callbackHandler == null) {
-                // Run on this thread.
-                runnable.run();
-            } else {
-                // Post to the handler.
-                callbackHandler.post(runnable);
-            }
-        }
-    }
-
-    static HttpURLConnection createConnection(URL url) throws IOException {
-        HttpURLConnection connection;
-        connection = (HttpURLConnection) url.openConnection();
-
-        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
-        connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
-
-        connection.setChunkedStreamingMode(0);
-        return connection;
-    }
-
-
-    private void addCommonParameters() {
-        if (this.session != null) {
-            if (!this.session.isOpened()) {
-                throw new FacebookException("Session provided to a Request in un-opened state.");
-            } else if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
-                String accessToken = this.session.getAccessToken();
-                Logger.registerAccessToken(accessToken);
-                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
-            }
-        }
-        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
-        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
-    }
-
-    private String appendParametersToBaseUrl(String baseUrl) {
-        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);
-
-        Set<String> keys = this.parameters.keySet();
-        for (String key : keys) {
-            Object value = this.parameters.get(key);
-
-            if (value == null) {
-                value = "";
-            }
-
-            if (isSupportedParameterType(value)) {
-                value = parameterToString(value);
-            } else {
-                if (httpMethod == HttpMethod.GET) {
-                    throw new IllegalArgumentException(String.format("Unsupported parameter type for GET request: %s",
-                                    value.getClass().getSimpleName()));
-                }
-                continue;
-            }
-
-            uriBuilder.appendQueryParameter(key, value.toString());
-        }
-
-        return uriBuilder.toString();
-    }
-
-    final String getUrlForBatchedRequest() {
-        if (overriddenURL != null) {
-            throw new FacebookException("Can't override URL for a batch request");
-        }
-
-        String baseUrl;
-        if (this.restMethod != null) {
-            baseUrl = ServerProtocol.BATCHED_REST_METHOD_URL_BASE + this.restMethod;
-        } else {
-            baseUrl = this.graphPath;
-        }
-
-        addCommonParameters();
-        return appendParametersToBaseUrl(baseUrl);
-    }
-
-    final String getUrlForSingleRequest() {
-        if (overriddenURL != null) {
-            return overriddenURL.toString();
-        }
-
-        String baseUrl;
-        if (this.restMethod != null) {
-            baseUrl = String.format("%s/%s", ServerProtocol.getRestUrlBase(), restMethod);
-        } else {
-            if (this.getHttpMethod() == HttpMethod.POST && graphPath != null && graphPath.endsWith(VIDEOS_SUFFIX)) {
-                baseUrl = String.format("%s/%s", ServerProtocol.getGraphVideoUrlBase(), graphPath);
-            } else {
-                baseUrl = String.format("%s/%s", ServerProtocol.getGraphUrlBase(), graphPath);
-            }
-        }
-
-        addCommonParameters();
-        return appendParametersToBaseUrl(baseUrl);
-    }
-
-    private static class Attachment {
-        private final Request request;
-        private final Object value;
-
-        public Attachment(Request request, Object value) {
-            this.request = request;
-            this.value = value;
-        }
-
-        public Request getRequest() {
-            return request;
-        }
-
-        public Object getValue() {
-            return value;
-        }
-    }
-
-    private void serializeToBatch(JSONArray batch, Map<String, Attachment> attachments) throws JSONException, IOException {
-        JSONObject batchEntry = new JSONObject();
-
-        if (this.batchEntryName != null) {
-            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
-            batchEntry.put(BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM, this.batchEntryOmitResultOnSuccess);
-        }
-        if (this.batchEntryDependsOn != null) {
-            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
-        }
-
-        String relativeURL = getUrlForBatchedRequest();
-        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
-        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
-        if (this.session != null) {
-            String accessToken = this.session.getAccessToken();
-            Logger.registerAccessToken(accessToken);
-        }
-
-        // Find all of our attachments. Remember their names and put them in the attachment map.
-        ArrayList<String> attachmentNames = new ArrayList<String>();
-        Set<String> keys = this.parameters.keySet();
-        for (String key : keys) {
-            Object value = this.parameters.get(key);
-            if (isSupportedAttachmentType(value)) {
-                // Make the name unique across this entire batch.
-                String name = String.format("%s%d", ATTACHMENT_FILENAME_PREFIX, attachments.size());
-                attachmentNames.add(name);
-                attachments.put(name, new Attachment(this, value));
-            }
-        }
-
-        if (!attachmentNames.isEmpty()) {
-            String attachmentNamesString = TextUtils.join(",", attachmentNames);
-            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
-        }
-
-        if (this.graphObject != null) {
-            // Serialize the graph object into the "body" parameter.
-            final ArrayList<String> keysAndValues = new ArrayList<String>();
-            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
-                @Override
-                public void writeString(String key, String value) throws IOException {
-                    keysAndValues.add(String.format("%s=%s", key, URLEncoder.encode(value, "UTF-8")));
-                }
-            });
-            String bodyValue = TextUtils.join("&", keysAndValues);
-            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
-        }
-
-        batch.put(batchEntry);
-    }
-
-    private void validate() {
-        if (graphPath != null && restMethod != null) {
-            throw new IllegalArgumentException("Only one of a graph path or REST method may be specified per request.");
-        }
-    }
-
-    private static boolean hasOnProgressCallbacks(RequestBatch requests) {
-        for (RequestBatch.Callback callback : requests.getCallbacks()) {
-            if (callback instanceof RequestBatch.OnProgressCallback) {
-                return true;
-            }
-        }
-
-        for (Request request : requests) {
-            if (request.getCallback() instanceof OnProgressCallback) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnection connection)
-    throws IOException, JSONException {
-        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");
-
-        int numRequests = requests.size();
-
-        HttpMethod connectionHttpMethod = (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
-        connection.setRequestMethod(connectionHttpMethod.name());
-
-        URL url = connection.getURL();
-        logger.append("Request:\n");
-        logger.appendKeyValue("Id", requests.getId());
-        logger.appendKeyValue("URL", url);
-        logger.appendKeyValue("Method", connection.getRequestMethod());
-        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
-        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));
-
-        connection.setConnectTimeout(requests.getTimeout());
-        connection.setReadTimeout(requests.getTimeout());
-
-        // If we have a single non-POST request, don't try to serialize anything or HttpURLConnection will
-        // turn it into a POST.
-        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
-        if (!isPost) {
-            logger.log();
-            return;
-        }
-
-        connection.setDoOutput(true);
-
-        OutputStream outputStream = null;
-        try {
-            if (hasOnProgressCallbacks(requests)) {
-                ProgressNoopOutputStream countingStream = null;
-                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
-                processRequest(requests, null, numRequests, url, countingStream);
-
-                int max = countingStream.getMaxProgress();
-                Map<Request, RequestProgress> progressMap = countingStream.getProgressMap();
-
-                BufferedOutputStream buffered = new BufferedOutputStream(connection.getOutputStream());
-                outputStream = new ProgressOutputStream(buffered, requests, progressMap, max);
-            }
-            else {
-                outputStream = new BufferedOutputStream(connection.getOutputStream());
-            }
-
-            processRequest(requests, logger, numRequests, url, outputStream);
-        }
-        finally {
-            outputStream.close();
-        }
-
-        logger.log();
-    }
-
-    private static void processRequest(RequestBatch requests, Logger logger, int numRequests, URL url, OutputStream outputStream)
-            throws IOException, JSONException
-    {
-        Serializer serializer = new Serializer(outputStream, logger);
-
-        if (numRequests == 1) {
-            Request request = requests.get(0);
-
-            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
-            for(String key : request.parameters.keySet()) {
-                Object value = request.parameters.get(key);
-                if (isSupportedAttachmentType(value)) {
-                    attachments.put(key, new Attachment(request, value));
-                }
-            }
-
-            if (logger != null) {
-                logger.append("  Parameters:\n");
-            }
-            serializeParameters(request.parameters, serializer, request);
-
-            if (logger != null) {
-                logger.append("  Attachments:\n");
-            }
-            serializeAttachments(attachments, serializer);
-
-            if (request.graphObject != null) {
-                processGraphObject(request.graphObject, url.getPath(), serializer);
-            }
-        } else {
-            String batchAppID = getBatchAppId(requests);
-            if (Utility.isNullOrEmpty(batchAppID)) {
-                throw new FacebookException("At least one request in a batch must have an open Session, or a "
-                        + "default app ID must be specified.");
-            }
-
-            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);
-
-            // We write out all the requests as JSON, remembering which file attachments they have, then
-            // write out the attachments.
-            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
-            serializeRequestsAsJSON(serializer, requests, attachments);
-
-            if (logger != null) {
-                logger.append("  Attachments:\n");
-            }
-            serializeAttachments(attachments, serializer);
-        }
-    }
-
-    private static void processGraphObject(GraphObject graphObject, String path, KeyValueSerializer serializer)
-            throws IOException {
-        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
-        // we need to pass the entire values of the contents of the 'image' property, as they
-        // contain important metadata beyond just a URL. We don't have a 100% foolproof way of knowing
-        // if we are posting an OG Action, given that batched requests can have parameter substitution,
-        // but passing the OG Action type as a substituted parameter is unlikely.
-        // It looks like an OG Action if it's posted to me/namespace:action[?other=stuff].
-        boolean isOGAction = false;
-        if (path.startsWith("me/") || path.startsWith("/me/")) {
-            int colonLocation = path.indexOf(":");
-            int questionMarkLocation = path.indexOf("?");
-            isOGAction = colonLocation > 3 && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
-        }
-
-        Set<Entry<String, Object>> entries = graphObject.asMap().entrySet();
-        for (Entry<String, Object> entry : entries) {
-            boolean passByValue = isOGAction && entry.getKey().equalsIgnoreCase("image");
-            processGraphObjectProperty(entry.getKey(), entry.getValue(), serializer, passByValue);
-        }
-    }
-
-    private static void processGraphObjectProperty(String key, Object value, KeyValueSerializer serializer,
-            boolean passByValue) throws IOException {
-        Class<?> valueClass = value.getClass();
-        if (GraphObject.class.isAssignableFrom(valueClass)) {
-            value = ((GraphObject) value).getInnerJSONObject();
-            valueClass = value.getClass();
-        } else if (GraphObjectList.class.isAssignableFrom(valueClass)) {
-            value = ((GraphObjectList<?>) value).getInnerJSONArray();
-            valueClass = value.getClass();
-        }
-
-        if (JSONObject.class.isAssignableFrom(valueClass)) {
-            JSONObject jsonObject = (JSONObject) value;
-            if (passByValue) {
-                // We need to pass all properties of this object in key[propertyName] format.
-                @SuppressWarnings("unchecked")
-                Iterator<String> keys = jsonObject.keys();
-                while (keys.hasNext()) {
-                    String propertyName = keys.next();
-                    String subKey = String.format("%s[%s]", key, propertyName);
-                    processGraphObjectProperty(subKey, jsonObject.opt(propertyName), serializer, passByValue);
-                }
-            } else {
-                // Normal case is passing objects by reference, so just pass the ID or URL, if any, as the value
-                // for "key"
-                if (jsonObject.has("id")) {
-                    processGraphObjectProperty(key, jsonObject.optString("id"), serializer, passByValue);
-                } else if (jsonObject.has("url")) {
-                    processGraphObjectProperty(key, jsonObject.optString("url"), serializer, passByValue);
-                }
-            }
-        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
-            JSONArray jsonArray = (JSONArray) value;
-            int length = jsonArray.length();
-            for (int i = 0; i < length; ++i) {
-                String subKey = String.format("%s[%d]", key, i);
-                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
-            }
-        } else if (String.class.isAssignableFrom(valueClass) ||
-                Number.class.isAssignableFrom(valueClass) ||
-                Boolean.class.isAssignableFrom(valueClass)) {
-            serializer.writeString(key, value.toString());
-        } else if (Date.class.isAssignableFrom(valueClass)) {
-            Date date = (Date) value;
-            // The "Events Timezone" platform migration affects what date/time formats Facebook accepts and returns.
-            // Apps created after 8/1/12 (or apps that have explicitly enabled the migration) should send/receive
-            // dates in ISO-8601 format. Pre-migration apps can send as Unix timestamps. Since the future is ISO-8601,
-            // that is what we support here. Apps that need pre-migration behavior can explicitly send these as
-            // integer timestamps rather than Dates.
-            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
-            serializer.writeString(key, iso8601DateFormat.format(date));
-        }
-    }
-
-    private static void serializeParameters(Bundle bundle, Serializer serializer, Request request) throws IOException {
-        Set<String> keys = bundle.keySet();
-
-        for (String key : keys) {
-            Object value = bundle.get(key);
-            if (isSupportedParameterType(value)) {
-                serializer.writeObject(key, value, request);
-            }
-        }
-    }
-
-    private static void serializeAttachments(Map<String, Attachment> attachments, Serializer serializer) throws IOException {
-        Set<String> keys = attachments.keySet();
-
-        for (String key : keys) {
-            Attachment attachment = attachments.get(key);
-            if (isSupportedAttachmentType(attachment.getValue())) {
-                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
-            }
-        }
-    }
-
-    private static void serializeRequestsAsJSON(Serializer serializer, Collection<Request> requests, Map<String, Attachment> attachments)
-            throws JSONException, IOException {
-        JSONArray batch = new JSONArray();
-        for (Request request : requests) {
-            request.serializeToBatch(batch, attachments);
-        }
-
-        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
-    }
-
-    private static String getMimeContentType() {
-        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
-    }
-
-    private static volatile String userAgent;
-
-    private static String getUserAgent() {
-        if (userAgent == null) {
-            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);
-        }
-
-        return userAgent;
-    }
-
-    private static String getBatchAppId(RequestBatch batch) {
-        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
-            return batch.getBatchApplicationId();
-        }
-
-        for (Request request : batch) {
-            Session session = request.session;
-            if (session != null) {
-                return session.getApplicationId();
-            }
-        }
-        return Request.defaultBatchApplicationId;
-    }
-
-    private static <T extends GraphObject> List<T> typedListFromResponse(Response response, Class<T> clazz) {
-        GraphMultiResult multiResult = response.getGraphObjectAs(GraphMultiResult.class);
-        if (multiResult == null) {
-            return null;
-        }
-
-        GraphObjectList<GraphObject> data = multiResult.getData();
-        if (data == null) {
-            return null;
-        }
-
-        return data.castToListOf(clazz);
-    }
-
-    private static boolean isSupportedAttachmentType(Object value) {
-        return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor ||
-                value instanceof ParcelFileDescriptorWithMimeType;
-    }
-
-    private static boolean isSupportedParameterType(Object value) {
-        return value instanceof String || value instanceof Boolean || value instanceof Number ||
-                value instanceof Date;
-    }
-
-    private static String parameterToString(Object value) {
-        if (value instanceof String) {
-            return (String) value;
-        } else if (value instanceof Boolean || value instanceof Number) {
-            return value.toString();
-        } else if (value instanceof Date) {
-            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
-            return iso8601DateFormat.format(value);
-        }
-        throw new IllegalArgumentException("Unsupported parameter type.");
-    }
-
-    private interface KeyValueSerializer {
-        void writeString(String key, String value) throws IOException;
-    }
-
-    private static class Serializer implements KeyValueSerializer {
-        private final OutputStream outputStream;
-        private final Logger logger;
-        private boolean firstWrite = true;
-
-        public Serializer(OutputStream outputStream, Logger logger) {
-            this.outputStream = outputStream;
-            this.logger = logger;
-        }
-
-        public void writeObject(String key, Object value, Request request) throws IOException {
-            if (outputStream instanceof RequestOutputStream) {
-                ((RequestOutputStream) outputStream).setCurrentRequest(request);
-            }
-
-            if (isSupportedParameterType(value)) {
-                writeString(key, parameterToString(value));
-            } else if (value instanceof Bitmap) {
-                writeBitmap(key, (Bitmap) value);
-            } else if (value instanceof byte[]) {
-                writeBytes(key, (byte[]) value);
-            } else if (value instanceof ParcelFileDescriptor) {
-                writeFile(key, (ParcelFileDescriptor) value, null);
-            } else if (value instanceof ParcelFileDescriptorWithMimeType) {
-                writeFile(key, (ParcelFileDescriptorWithMimeType) value);
-            } else {
-                throw new IllegalArgumentException("value is not a supported type: String, Bitmap, byte[]");
-            }
-        }
-
-        public void writeRequestsAsJson(String key, JSONArray requestJsonArray, Collection<Request> requests)
-                throws IOException, JSONException {
-            if (! (outputStream instanceof RequestOutputStream)) {
-                writeString(key, requestJsonArray.toString());
-                return;
-            }
-
-            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
-            writeContentDisposition(key, null, null);
-            write("[");
-            int i = 0;
-            for (Request request : requests) {
-                JSONObject requestJson = requestJsonArray.getJSONObject(i);
-                requestOutputStream.setCurrentRequest(request);
-                if (i > 0) {
-                    write(",%s", requestJson.toString());
-                } else {
-                    write("%s", requestJson.toString());
-                }
-                i++;
-            }
-            write("]");
-            if (logger != null) {
-                logger.appendKeyValue("    " + key, requestJsonArray.toString());
-            }
-        }
-
-        public void writeString(String key, String value) throws IOException {
-            writeContentDisposition(key, null, null);
-            writeLine("%s", value);
-            writeRecordBoundary();
-            if (logger != null) {
-                logger.appendKeyValue("    " + key, value);
-            }
-        }
-
-        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
-            writeContentDisposition(key, key, "image/png");
-            // Note: quality parameter is ignored for PNG
-            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
-            writeLine("");
-            writeRecordBoundary();
-            if (logger != null) {
-                logger.appendKeyValue("    " + key, "<Image>");
-            }
-        }
-
-        public void writeBytes(String key, byte[] bytes) throws IOException {
-            writeContentDisposition(key, key, "content/unknown");
-            this.outputStream.write(bytes);
-            writeLine("");
-            writeRecordBoundary();
-            if (logger != null) {
-                logger.appendKeyValue("    " + key, String.format("<Data: %d>", bytes.length));
-            }
-        }
-
-        public void writeFile(String key, ParcelFileDescriptorWithMimeType descriptorWithMimeType) throws IOException {
-            writeFile(key, descriptorWithMimeType.getFileDescriptor(), descriptorWithMimeType.getMimeType());
-        }
-
-        public void writeFile(String key, ParcelFileDescriptor descriptor, String mimeType) throws IOException {
-            if (mimeType == null) {
-                mimeType = "content/unknown";
-            }
-            writeContentDisposition(key, key, mimeType);
-
-            int totalBytes = 0;
-
-            if (outputStream instanceof ProgressNoopOutputStream) {
-                // If we are only counting bytes then skip reading the file
-                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
-            }
-            else {
-                ParcelFileDescriptor.AutoCloseInputStream inputStream = null;
-                BufferedInputStream bufferedInputStream = null;
-                try {
-                    inputStream = new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
-                    bufferedInputStream = new BufferedInputStream(inputStream);
-
-                    byte[] buffer = new byte[8192];
-                    int bytesRead;
-                    while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
-                        this.outputStream.write(buffer, 0, bytesRead);
-                        totalBytes += bytesRead;
-                    }
-                } finally {
-                    if (bufferedInputStream != null) {
-                        bufferedInputStream.close();
-                    }
-                    if (inputStream != null) {
-                        inputStream.close();
-                    }
-                }
-            }
-            writeLine("");
-            writeRecordBoundary();
-            if (logger != null) {
-                logger.appendKeyValue("    " + key, String.format("<Data: %d>", totalBytes));
-            }
-        }
-
-        public void writeRecordBoundary() throws IOException {
-            writeLine("--%s", MIME_BOUNDARY);
-        }
-
-        public void writeContentDisposition(String name, String filename, String contentType) throws IOException {
-            write("Content-Disposition: form-data; name=\"%s\"", name);
-            if (filename != null) {
-                write("; filename=\"%s\"", filename);
-            }
-            writeLine(""); // newline after Content-Disposition
-            if (contentType != null) {
-                writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
-            }
-            writeLine(""); // blank line before content
-        }
-
-        public void write(String format, Object... args) throws IOException {
-            if (firstWrite) {
-                // Prepend all of our output with a boundary string.
-                this.outputStream.write("--".getBytes());
-                this.outputStream.write(MIME_BOUNDARY.getBytes());
-                this.outputStream.write("\r\n".getBytes());
-                firstWrite = false;
-            }
-            this.outputStream.write(String.format(format, args).getBytes());
-        }
-
-        public void writeLine(String format, Object... args) throws IOException {
-            write(format, args);
-            write("\r\n");
-        }
-
-    }
-
-    /**
-     * Specifies the interface that consumers of the Request class can implement in order to be notified when a
-     * particular request completes, either successfully or with an error.
-     */
-    public interface Callback {
-        /**
-         * The method that will be called when a request completes.
-         *
-         * @param response
-         *            the Response of this request, which may include error information if the request was unsuccessful
-         */
-        void onCompleted(Response response);
-    }
-
-    /**
-     * Specifies the interface that consumers of the Request class can implement in order to be notified when a
-     * progress is made on a particular request. The frequency of the callbacks can be controlled using
-     * {@link com.facebook.Settings#setOnProgressThreshold(long)}
-     */
-    public interface OnProgressCallback extends Callback {
-        /**
-         * The method that will be called when progress is made.
-         *
-         * @param current
-         *            the current value of the progress of the request.
-         * @param max
-         *            the maximum value (target) value that the progress will have.
-         */
-        void onProgress(long current, long max);
-    }
-
-    /**
-     * Specifies the interface that consumers of
-     * {@link Request#executeMeRequestAsync(Session, com.facebook.Request.GraphUserCallback)}
-     * can use to be notified when the request completes, either successfully or with an error.
-     */
-    public interface GraphUserCallback {
-        /**
-         * The method that will be called when the request completes.
-         *
-         * @param user     the GraphObject representing the returned user, or null
-         * @param response the Response of this request, which may include error information if the request was unsuccessful
-         */
-        void onCompleted(GraphUser user, Response response);
-    }
-
-    /**
-     * Specifies the interface that consumers of
-     * {@link Request#executeMyFriendsRequestAsync(Session, com.facebook.Request.GraphUserListCallback)}
-     * can use to be notified when the request completes, either successfully or with an error.
-     */
-    public interface GraphUserListCallback {
-        /**
-         * The method that will be called when the request completes.
-         *
-         * @param users    the list of GraphObjects representing the returned friends, or null
-         * @param response the Response of this request, which may include error information if the request was unsuccessful
-         */
-        void onCompleted(List<GraphUser> users, Response response);
-    }
-
-    /**
-     * Specifies the interface that consumers of
-     * {@link Request#executePlacesSearchRequestAsync(Session, android.location.Location, int, int, String, com.facebook.Request.GraphPlaceListCallback)}
-     * can use to be notified when the request completes, either successfully or with an error.
-     */
-    public interface GraphPlaceListCallback {
-        /**
-         * The method that will be called when the request completes.
-         *
-         * @param places   the list of GraphObjects representing the returned places, or null
-         * @param response the Response of this request, which may include error information if the request was unsuccessful
-         */
-        void onCompleted(List<GraphPlace> places, Response response);
-    }
-
-    private static class ParcelFileDescriptorWithMimeType implements Parcelable {
-        private final String mimeType;
-        private final ParcelFileDescriptor fileDescriptor;
-
-        public String getMimeType() {
-            return mimeType;
-        }
-
-        public ParcelFileDescriptor getFileDescriptor() {
-            return fileDescriptor;
-        }
-
-        public int describeContents() {
-            return CONTENTS_FILE_DESCRIPTOR;
-        }
-
-        public void writeToParcel(Parcel out, int flags) {
-            out.writeString(mimeType);
-            out.writeFileDescriptor(fileDescriptor.getFileDescriptor());
-        }
-
-        @SuppressWarnings("unused")
-        public static final Parcelable.Creator<ParcelFileDescriptorWithMimeType> CREATOR
-                = new Parcelable.Creator<ParcelFileDescriptorWithMimeType>() {
-            public ParcelFileDescriptorWithMimeType createFromParcel(Parcel in) {
-                return new ParcelFileDescriptorWithMimeType(in);
-            }
-
-            public ParcelFileDescriptorWithMimeType[] newArray(int size) {
-                return new ParcelFileDescriptorWithMimeType[size];
-            }
-        };
-
-        public ParcelFileDescriptorWithMimeType(ParcelFileDescriptor fileDescriptor, String mimeType) {
-            this.mimeType = mimeType;
-            this.fileDescriptor = fileDescriptor;
-        }
-
-        private ParcelFileDescriptorWithMimeType(Parcel in) {
-            mimeType = in.readString();
-            fileDescriptor = in.readFileDescriptor();
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/RequestOutputStream.java b/facebook/src/com/facebook/RequestOutputStream.java
index 323b7c73d..71383b9c3 100644
--- a/facebook/src/com/facebook/RequestOutputStream.java
+++ b/facebook/src/com/facebook/RequestOutputStream.java
@@ -1,21 +1,25 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 interface RequestOutputStream {
-    void setCurrentRequest(Request r);
+    void setCurrentRequest(GraphRequest r);
 }
diff --git a/facebook/src/com/facebook/RequestProgress.java b/facebook/src/com/facebook/RequestProgress.java
index ef10361cf..b167abd9f 100644
--- a/facebook/src/com/facebook/RequestProgress.java
+++ b/facebook/src/com/facebook/RequestProgress.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -19,17 +23,17 @@
 import android.os.Handler;
 
 class RequestProgress {
-    private final Request request;
+    private final GraphRequest request;
     private final Handler callbackHandler;
     private final long threshold;
 
     private long progress, lastReportedProgress, maxProgress;
 
-    RequestProgress(Handler callbackHandler, Request request) {
+    RequestProgress(Handler callbackHandler, GraphRequest request) {
         this.request = request;
         this.callbackHandler = callbackHandler;
 
-        this.threshold = Settings.getOnProgressThreshold();
+        this.threshold = FacebookSdk.getOnProgressThreshold();
     }
 
     long getProgress() {
@@ -54,12 +58,13 @@ void addToMax(long size) {
 
     void reportProgress() {
         if (progress > lastReportedProgress) {
-            Request.Callback callback = request.getCallback();
-            if (maxProgress > 0 && callback instanceof Request.OnProgressCallback) {
+            GraphRequest.Callback callback = request.getCallback();
+            if (maxProgress > 0 && callback instanceof GraphRequest.OnProgressCallback) {
                 // Keep copies to avoid threading issues
                 final long currentCopy = progress;
                 final long maxProgressCopy = maxProgress;
-                final Request.OnProgressCallback callbackCopy = (Request.OnProgressCallback) callback;
+                final GraphRequest.OnProgressCallback callbackCopy =
+                        (GraphRequest.OnProgressCallback) callback;
                 if (callbackHandler == null) {
                     callbackCopy.onProgress(currentCopy, maxProgressCopy);
                 }
diff --git a/facebook/src/com/facebook/Response.java b/facebook/src/com/facebook/Response.java
deleted file mode 100644
index 4697aaf12..000000000
--- a/facebook/src/com/facebook/Response.java
+++ /dev/null
@@ -1,469 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import com.facebook.internal.*;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Encapsulates the response, successful or otherwise, of a call to the Facebook platform.
- */
-public class Response {
-    private final HttpURLConnection connection;
-    private final GraphObject graphObject;
-    private final GraphObjectList<GraphObject> graphObjectList;
-    private final boolean isFromCache;
-    private final FacebookRequestError error;
-    private final Request request;
-
-    /**
-     * Property name of non-JSON results in the GraphObject. Certain calls to Facebook result in a non-JSON response
-     * (e.g., the string literal "true" or "false"). To present a consistent way of accessing results, these are
-     * represented as a GraphObject with a single string property with this name.
-     */
-    public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT";
-
-    private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190;
-
-    private static final String CODE_KEY = "code";
-    private static final String BODY_KEY = "body";
-
-    private static final String RESPONSE_LOG_TAG = "Response";
-
-    private static final String RESPONSE_CACHE_TAG = "ResponseCache";
-    private static FileLruCache responseCache;
-
-    Response(Request request, HttpURLConnection connection, GraphObject graphObject, boolean isFromCache) {
-        this.request = request;
-        this.connection = connection;
-        this.graphObject = graphObject;
-        this.graphObjectList = null;
-        this.isFromCache = isFromCache;
-        this.error = null;
-    }
-
-    Response(Request request, HttpURLConnection connection, GraphObjectList<GraphObject> graphObjects,
-            boolean isFromCache) {
-        this.request = request;
-        this.connection = connection;
-        this.graphObject = null;
-        this.graphObjectList = graphObjects;
-        this.isFromCache = isFromCache;
-        this.error = null;
-    }
-
-    Response(Request request, HttpURLConnection connection, FacebookRequestError error) {
-        this.request = request;
-        this.connection = connection;
-        this.graphObject = null;
-        this.graphObjectList = null;
-        this.isFromCache = false;
-        this.error = error;
-    }
-
-    /**
-     * Returns information about any errors that may have occurred during the request.
-     *
-     * @return the error from the server, or null if there was no server error
-     */
-    public final FacebookRequestError getError() {
-        return error;
-    }
-
-    /**
-     * The single graph object returned for this request, if any.
-     *
-     * @return the graph object returned, or null if none was returned (or if the result was a list)
-     */
-    public final GraphObject getGraphObject() {
-        return graphObject;
-    }
-
-    /**
-     * The single graph object returned for this request, if any, cast into a particular type of GraphObject.
-     *
-     * @param graphObjectClass the GraphObject-derived interface to cast the graph object into
-     * @return the graph object returned, or null if none was returned (or if the result was a list)
-     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
-     */
-    public final <T extends GraphObject> T getGraphObjectAs(Class<T> graphObjectClass) {
-        if (graphObject == null) {
-            return null;
-        }
-        if (graphObjectClass == null) {
-            throw new NullPointerException("Must pass in a valid interface that extends GraphObject");
-        }
-        return graphObject.cast(graphObjectClass);
-    }
-
-    /**
-     * The list of graph objects returned for this request, if any.
-     *
-     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
-     */
-    public final GraphObjectList<GraphObject> getGraphObjectList() {
-        return graphObjectList;
-    }
-
-    /**
-     * The list of graph objects returned for this request, if any, cast into a particular type of GraphObject.
-     *
-     * @param graphObjectClass the GraphObject-derived interface to cast the graph objects into
-     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
-     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
-     */
-    public final <T extends GraphObject> GraphObjectList<T> getGraphObjectListAs(Class<T> graphObjectClass) {
-        if (graphObjectList == null) {
-            return null;
-        }
-        return graphObjectList.castToListOf(graphObjectClass);
-    }
-
-    /**
-     * Returns the HttpURLConnection that this response was generated from. If the response was retrieved
-     * from the cache, this will be null.
-     *
-     * @return the connection, or null
-     */
-    public final HttpURLConnection getConnection() {
-        return connection;
-    }
-
-    /**
-     * Returns the request that this response is for.
-     *
-     * @return the request that this response is for
-     */
-    public Request getRequest() {
-        return request;
-    }
-
-    /**
-     * Indicates whether paging is being done forward or backward.
-     */
-    public enum PagingDirection {
-        /**
-         * Indicates that paging is being performed in the forward direction.
-         */
-        NEXT,
-        /**
-         * Indicates that paging is being performed in the backward direction.
-         */
-        PREVIOUS
-    }
-
-    /**
-     * If a Response contains results that contain paging information, returns a new
-     * Request that will retrieve the next page of results, in whichever direction
-     * is desired. If no paging information is available, returns null.
-     *
-     * @param direction enum indicating whether to page forward or backward
-     * @return a Request that will retrieve the next page of results in the desired
-     *         direction, or null if no paging information is available
-     */
-    public Request getRequestForPagedResults(PagingDirection direction) {
-        String link = null;
-        if (graphObject != null) {
-            PagedResults pagedResults = graphObject.cast(PagedResults.class);
-            PagingInfo pagingInfo = pagedResults.getPaging();
-            if (pagingInfo != null) {
-                if (direction == PagingDirection.NEXT) {
-                    link = pagingInfo.getNext();
-                } else {
-                    link = pagingInfo.getPrevious();
-                }
-            }
-        }
-        if (Utility.isNullOrEmpty(link)) {
-            return null;
-        }
-
-        if (link != null && link.equals(request.getUrlForSingleRequest())) {
-            // We got the same "next" link as we just tried to retrieve. This could happen if cached
-            // data is invalid. All we can do in this case is pretend we have finished.
-            return null;
-        }
-
-        Request pagingRequest;
-        try {
-            pagingRequest = new Request(request.getSession(), new URL(link));
-        } catch (MalformedURLException e) {
-            return null;
-        }
-
-        return pagingRequest;
-    }
-
-    /**
-     * Provides a debugging string for this response.
-     */
-    @Override
-    public String toString() {
-        String responseCode;
-        try {
-            responseCode = String.format("%d", (connection != null) ? connection.getResponseCode() : 200);
-        } catch (IOException e) {
-            responseCode = "unknown";
-        }
-
-        return new StringBuilder().append("{Response: ").append(" responseCode: ").append(responseCode)
-                .append(", graphObject: ").append(graphObject).append(", error: ").append(error)
-                .append(", isFromCache:").append(isFromCache).append("}")
-                .toString();
-    }
-
-    /**
-     * Indicates whether the response was retrieved from a local cache or from the server.
-     *
-     * @return true if the response was cached locally, false if it was retrieved from the server
-     */
-    public final boolean getIsFromCache() {
-        return isFromCache;
-    }
-
-    static FileLruCache getResponseCache() {
-        if (responseCache == null) {
-            Context applicationContext = Session.getStaticContext();
-            if (applicationContext != null) {
-                responseCache = new FileLruCache(applicationContext, RESPONSE_CACHE_TAG, new FileLruCache.Limits());
-            }
-        }
-
-        return responseCache;
-    }
-
-    @SuppressWarnings("resource")
-    static List<Response> fromHttpConnection(HttpURLConnection connection, RequestBatch requests) {
-        InputStream stream = null;
-
-        FileLruCache cache = null;
-        String cacheKey = null;
-        if (requests instanceof CacheableRequestBatch) {
-            CacheableRequestBatch cacheableRequestBatch = (CacheableRequestBatch) requests;
-            cache = getResponseCache();
-            cacheKey = cacheableRequestBatch.getCacheKeyOverride();
-            if (Utility.isNullOrEmpty(cacheKey)) {
-                if (requests.size() == 1) {
-                    // Default for single requests is to use the URL.
-                    cacheKey = requests.get(0).getUrlForSingleRequest();
-                } else {
-                    Logger.log(LoggingBehavior.REQUESTS, RESPONSE_CACHE_TAG,
-                            "Not using cache for cacheable request because no key was specified");
-                }
-            }
-
-            // Try loading from cache.  If that fails, load from the network.
-            if (!cacheableRequestBatch.getForceRoundTrip() && cache != null && !Utility.isNullOrEmpty(cacheKey)) {
-                try {
-                    stream = cache.get(cacheKey);
-                    if (stream != null) {
-                        return createResponsesFromStream(stream, null, requests, true);
-                    }
-                } catch (FacebookException exception) { // retry via roundtrip below
-                } catch (JSONException exception) {
-                } catch (IOException exception) {
-                } finally {
-                    Utility.closeQuietly(stream);
-                }
-            }
-        }
-
-        // Load from the network, and cache the result if not an error.
-        try {
-            if (connection.getResponseCode() >= 400) {
-                stream = connection.getErrorStream();
-            } else {
-                stream = connection.getInputStream();
-                if ((cache != null) && (cacheKey != null) && (stream != null)) {
-                    InputStream interceptStream = cache.interceptAndPut(cacheKey, stream);
-                    if (interceptStream != null) {
-                        stream = interceptStream;
-                    }
-                }
-            }
-
-            return createResponsesFromStream(stream, connection, requests, false);
-        } catch (FacebookException facebookException) {
-            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
-            return constructErrorResponses(requests, connection, facebookException);
-        } catch (JSONException exception) {
-            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
-            return constructErrorResponses(requests, connection, new FacebookException(exception));
-        } catch (IOException exception) {
-            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
-            return constructErrorResponses(requests, connection, new FacebookException(exception));
-        } catch (SecurityException exception) {
-            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
-            return constructErrorResponses(requests, connection, new FacebookException(exception));
-        } finally {
-            Utility.closeQuietly(stream);
-        }
-    }
-
-    static List<Response> createResponsesFromStream(InputStream stream, HttpURLConnection connection,
-            RequestBatch requests, boolean isFromCache) throws FacebookException, JSONException, IOException {
-
-        String responseString = Utility.readStreamToString(stream);
-        Logger.log(LoggingBehavior.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
-                "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
-                responseString);
-
-        return createResponsesFromString(responseString, connection, requests, isFromCache);
-    }
-
-    static List<Response> createResponsesFromString(String responseString, HttpURLConnection connection,
-            RequestBatch requests, boolean isFromCache) throws FacebookException, JSONException, IOException {
-        JSONTokener tokener = new JSONTokener(responseString);
-        Object resultObject = tokener.nextValue();
-
-        List<Response> responses = createResponsesFromObject(connection, requests, resultObject, isFromCache);
-        Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
-                requests.getId(), responseString.length(), responses);
-
-        return responses;
-    }
-
-    private static List<Response> createResponsesFromObject(HttpURLConnection connection, List<Request> requests,
-            Object object, boolean isFromCache) throws FacebookException, JSONException {
-        assert (connection != null) || isFromCache;
-
-        int numRequests = requests.size();
-        List<Response> responses = new ArrayList<Response>(numRequests);
-        Object originalResult = object;
-
-        if (numRequests == 1) {
-            Request request = requests.get(0);
-            try {
-                // Single request case -- the entire response is the result, wrap it as "body" so we can handle it
-                // the same as we do in the batched case. We get the response code from the actual HTTP response,
-                // as opposed to the batched case where it is returned as a "code" element.
-                JSONObject jsonObject = new JSONObject();
-                jsonObject.put(BODY_KEY, object);
-                int responseCode = (connection != null) ? connection.getResponseCode() : 200;
-                jsonObject.put(CODE_KEY, responseCode);
-
-                JSONArray jsonArray = new JSONArray();
-                jsonArray.put(jsonObject);
-
-                // Pretend we got an array of 1 back.
-                object = jsonArray;
-            } catch (JSONException e) {
-                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
-            } catch (IOException e) {
-                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
-            }
-        }
-
-        if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
-            FacebookException exception = new FacebookException("Unexpected number of results");
-            throw exception;
-        }
-
-        JSONArray jsonArray = (JSONArray) object;
-
-        for (int i = 0; i < jsonArray.length(); ++i) {
-            Request request = requests.get(i);
-            try {
-                Object obj = jsonArray.get(i);
-                responses.add(createResponseFromObject(request, connection, obj, isFromCache, originalResult));
-            } catch (JSONException e) {
-                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
-            } catch (FacebookException e) {
-                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
-            }
-        }
-
-        return responses;
-    }
-
-    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object,
-            boolean isFromCache, Object originalResult) throws JSONException {
-        if (object instanceof JSONObject) {
-            JSONObject jsonObject = (JSONObject) object;
-
-            FacebookRequestError error =
-                    FacebookRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);
-            if (error != null) {
-                if (error.getErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
-                    Session session = request.getSession();
-                    if (session != null) {
-                        session.closeAndClearTokenInformation();
-                    }
-                }
-                return new Response(request, connection, error);
-            }
-
-            Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
-
-            if (body instanceof JSONObject) {
-                GraphObject graphObject = GraphObject.Factory.create((JSONObject) body);
-                return new Response(request, connection, graphObject, isFromCache);
-            } else if (body instanceof JSONArray) {
-                GraphObjectList<GraphObject> graphObjectList = GraphObject.Factory.createList(
-                        (JSONArray) body, GraphObject.class);
-                return new Response(request, connection, graphObjectList, isFromCache);
-            }
-            // We didn't get a body we understand how to handle, so pretend we got nothing.
-            object = JSONObject.NULL;
-        }
-
-        if (object == JSONObject.NULL) {
-            return new Response(request, connection, (GraphObject)null, isFromCache);
-        } else {
-            throw new FacebookException("Got unexpected object type in response, class: "
-                    + object.getClass().getSimpleName());
-        }
-    }
-
-    static List<Response> constructErrorResponses(List<Request> requests, HttpURLConnection connection,
-            FacebookException error) {
-        int count = requests.size();
-        List<Response> responses = new ArrayList<Response>(count);
-        for (int i = 0; i < count; ++i) {
-            Response response = new Response(requests.get(i), connection, new FacebookRequestError(connection, error));
-            responses.add(response);
-        }
-        return responses;
-    }
-
-    interface PagingInfo extends GraphObject {
-        String getNext();
-
-        String getPrevious();
-    }
-
-    interface PagedResults extends GraphObject {
-        GraphObjectList<GraphObject> getData();
-
-        PagingInfo getPaging();
-    }
-
-}
diff --git a/facebook/src/com/facebook/Session.java b/facebook/src/com/facebook/Session.java
deleted file mode 100644
index e5b106af4..000000000
--- a/facebook/src/com/facebook/Session.java
+++ /dev/null
@@ -1,2065 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.*;
-import android.content.pm.ResolveInfo;
-import android.os.*;
-import android.support.v4.app.Fragment;
-import android.support.v4.content.LocalBroadcastManager;
-import android.text.TextUtils;
-import android.util.Log;
-import com.facebook.internal.*;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.*;
-import java.lang.ref.WeakReference;
-import java.util.*;
-
-/**
- * <p>
- * Session is used to authenticate a user and manage the user's session with
- * Facebook.
- * </p>
- * <p>
- * Sessions must be opened before they can be used to make a Request. When a
- * Session is created, it attempts to initialize itself from a TokenCachingStrategy.
- * Closing the session can optionally clear this cache.  The Session lifecycle
- * uses {@link SessionState SessionState} to indicate its state. Once a Session has
- * been closed, it can't be re-opened; a new Session must be created.
- * </p>
- * <p>
- * Instances of Session provide state change notification via a callback
- * interface, {@link Session.StatusCallback StatusCallback}.
- * </p>
- */
-public class Session implements Serializable {
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * The logging tag used by Session.
-     */
-    public static final String TAG = Session.class.getCanonicalName();
-
-    /**
-     * The default activity code used for authorization.
-     *
-     * @see #openForRead(OpenRequest)
-     *      open
-     */
-    public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface;
-
-    /**
-     * If Session authorization fails and provides a web view error code, the
-     * web view error code is stored in the Bundle returned from
-     * {@link #getAuthorizationBundle getAuthorizationBundle} under this key.
-     */
-    public static final String WEB_VIEW_ERROR_CODE_KEY = "com.facebook.sdk.WebViewErrorCode";
-
-    /**
-     * If Session authorization fails and provides a failing url, the failing
-     * url is stored in the Bundle returned from {@link #getAuthorizationBundle
-     * getAuthorizationBundle} under this key.
-     */
-    public static final String WEB_VIEW_FAILING_URL_KEY = "com.facebook.sdk.FailingUrl";
-
-    /**
-     * The action used to indicate that the active session has been set. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
-     */
-    public static final String ACTION_ACTIVE_SESSION_SET = "com.facebook.sdk.ACTIVE_SESSION_SET";
-
-    /**
-     * The action used to indicate that the active session has been set to null. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
-     */
-    public static final String ACTION_ACTIVE_SESSION_UNSET = "com.facebook.sdk.ACTIVE_SESSION_UNSET";
-
-    /**
-     * The action used to indicate that the active session has been opened. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
-     */
-    public static final String ACTION_ACTIVE_SESSION_OPENED = "com.facebook.sdk.ACTIVE_SESSION_OPENED";
-
-    /**
-     * The action used to indicate that the active session has been closed. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
-     */
-    public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED";
-
-    /**
-     * Session takes application id as a constructor parameter. If this is null,
-     * Session will attempt to load the application id from
-     * application/meta-data using this String as the key.
-     */
-    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";
-
-    private static final Object STATIC_LOCK = new Object();
-    private static Session activeSession;
-    private static volatile Context staticContext;
-
-    // Token extension constants
-    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1
-    // day
-    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
-
-    private static final String SESSION_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.saveSessionKey";
-    private static final String AUTH_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.authBundleKey";
-    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
-    private static final String MANAGE_PERMISSION_PREFIX = "manage";
-
-    @SuppressWarnings("serial")
-    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
-        add("ads_management");
-        add("create_event");
-        add("rsvp_event");
-    }};
-
-    private String applicationId;
-    private SessionState state;
-    private AccessToken tokenInfo;
-    private Date lastAttemptedTokenExtendDate = new Date(0);
-
-    private AuthorizationRequest pendingAuthorizationRequest;
-    private AuthorizationClient authorizationClient;
-
-    // The following are not serialized with the Session object
-    private volatile Bundle authorizationBundle;
-    private final List<StatusCallback> callbacks;
-    private Handler handler;
-    private AutoPublishAsyncTask autoPublishAsyncTask;
-    // This is the object that synchronizes access to state and tokenInfo
-    private final Object lock = new Object();
-    private TokenCachingStrategy tokenCachingStrategy;
-    private volatile TokenRefreshRequest currentTokenRefreshRequest;
-    private AppEventsLogger appEventsLogger;
-
-    /**
-     * Serialization proxy for the Session class. This is version 1 of
-     * serialization. Future serializations may differ in format. This
-     * class should not be modified. If serializations formats change,
-     * create a new class SerializationProxyVx.
-     */
-    private static class SerializationProxyV1 implements Serializable {
-        private static final long serialVersionUID = 7663436173185080063L;
-        private final String applicationId;
-        private final SessionState state;
-        private final AccessToken tokenInfo;
-        private final Date lastAttemptedTokenExtendDate;
-        private final boolean shouldAutoPublish;
-        private final AuthorizationRequest pendingAuthorizationRequest;
-
-        SerializationProxyV1(String applicationId, SessionState state,
-                AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
-                boolean shouldAutoPublish, AuthorizationRequest pendingAuthorizationRequest) {
-            this.applicationId = applicationId;
-            this.state = state;
-            this.tokenInfo = tokenInfo;
-            this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
-            this.shouldAutoPublish = shouldAutoPublish;
-            this.pendingAuthorizationRequest = pendingAuthorizationRequest;
-        }
-
-        private Object readResolve() {
-            return new Session(applicationId, state, tokenInfo,
-                    lastAttemptedTokenExtendDate, shouldAutoPublish, pendingAuthorizationRequest);
-        }
-    }
-
-    /**
-     * Used by version 1 of the serialization proxy, do not modify.
-     */
-    private Session(String applicationId, SessionState state,
-            AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
-            boolean shouldAutoPublish, AuthorizationRequest pendingAuthorizationRequest) {
-        this.applicationId = applicationId;
-        this.state = state;
-        this.tokenInfo = tokenInfo;
-        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
-        this.pendingAuthorizationRequest = pendingAuthorizationRequest;
-        handler = new Handler(Looper.getMainLooper());
-        currentTokenRefreshRequest = null;
-        tokenCachingStrategy = null;
-        callbacks = new ArrayList<StatusCallback>();
-    }
-
-    /**
-     * Initializes a new Session with the specified context.
-     *
-     * @param currentContext The Activity or Service creating this Session.
-     */
-    public Session(Context currentContext) {
-        this(currentContext, null, null, true);
-    }
-
-    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
-        this(context, applicationId, tokenCachingStrategy, true);
-    }
-
-    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy,
-            boolean loadTokenFromCache) {
-        // if the application ID passed in is null, try to get it from the
-        // meta-data in the manifest.
-        if ((context != null) && (applicationId == null)) {
-            applicationId = Utility.getMetadataApplicationId(context);
-        }
-
-        Validate.notNull(applicationId, "applicationId");
-
-        initializeStaticContext(context);
-
-        if (tokenCachingStrategy == null) {
-            tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(staticContext);
-        }
-
-        this.applicationId = applicationId;
-        this.tokenCachingStrategy = tokenCachingStrategy;
-        this.state = SessionState.CREATED;
-        this.pendingAuthorizationRequest = null;
-        this.callbacks = new ArrayList<StatusCallback>();
-        this.handler = new Handler(Looper.getMainLooper());
-
-        Bundle tokenState = loadTokenFromCache ? tokenCachingStrategy.load() : null;
-        if (TokenCachingStrategy.hasTokenInformation(tokenState)) {
-            Date cachedExpirationDate = TokenCachingStrategy
-                    .getDate(tokenState, TokenCachingStrategy.EXPIRATION_DATE_KEY);
-            Date now = new Date();
-
-            if ((cachedExpirationDate == null) || cachedExpirationDate.before(now)) {
-                // If expired or we require new permissions, clear out the
-                // current token cache.
-                tokenCachingStrategy.clear();
-                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
-            } else {
-                // Otherwise we have a valid token, so use it.
-                this.tokenInfo = AccessToken.createFromCache(tokenState);
-                this.state = SessionState.CREATED_TOKEN_LOADED;
-            }
-        } else {
-            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
-        }
-    }
-
-    /**
-     * Returns a Bundle containing data that was returned from Facebook during
-     * authorization.
-     *
-     * @return a Bundle containing data that was returned from Facebook during
-     *         authorization.
-     */
-    public final Bundle getAuthorizationBundle() {
-        synchronized (this.lock) {
-            return this.authorizationBundle;
-        }
-    }
-
-    /**
-     * Returns a boolean indicating whether the session is opened.
-     *
-     * @return a boolean indicating whether the session is opened.
-     */
-    public final boolean isOpened() {
-        synchronized (this.lock) {
-            return this.state.isOpened();
-        }
-    }
-
-    public final boolean isClosed() {
-        synchronized (this.lock) {
-            return this.state.isClosed();
-        }
-    }
-
-    /**
-     * Returns the current state of the Session.
-     * See {@link SessionState} for details.
-     *
-     * @return the current state of the Session.
-     */
-    public final SessionState getState() {
-        synchronized (this.lock) {
-            return this.state;
-        }
-    }
-
-    /**
-     * Returns the application id associated with this Session.
-     *
-     * @return the application id associated with this Session.
-     */
-    public final String getApplicationId() {
-        return this.applicationId;
-    }
-
-    /**
-     * Returns the access token String.
-     *
-     * @return the access token String, or null if there is no access token
-     */
-    public final String getAccessToken() {
-        synchronized (this.lock) {
-            return (this.tokenInfo == null) ? null : this.tokenInfo.getToken();
-        }
-    }
-
-    /**
-     * <p>
-     * Returns the Date at which the current token will expire.
-     * </p>
-     * <p>
-     * Note that Session automatically attempts to extend the lifetime of Tokens
-     * as needed when Facebook requests are made.
-     * </p>
-     *
-     * @return the Date at which the current token will expire, or null if there is no access token
-     */
-    public final Date getExpirationDate() {
-        synchronized (this.lock) {
-            return (this.tokenInfo == null) ? null : this.tokenInfo.getExpires();
-        }
-    }
-
-    /**
-     * <p>
-     * Returns the list of permissions associated with the session.
-     * </p>
-     * <p>
-     * If there is a valid token, this represents the permissions granted by
-     * that token. This can change during calls to
-     * {@link #requestNewReadPermissions}
-     * or {@link #requestNewPublishPermissions}.
-     * </p>
-     *
-     * @return the list of permissions associated with the session, or null if there is no access token
-     */
-    public final List<String> getPermissions() {
-        synchronized (this.lock) {
-            return (this.tokenInfo == null) ? null : this.tokenInfo.getPermissions();
-        }
-    }
-
-    /**
-     * <p>
-     * Logs a user in to Facebook.
-     * </p>
-     * <p>
-     * A session may not be used with {@link Request Request} and other classes
-     * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, and the requested permissions are a subset of the previously authorized
-     * permissions, then the Session becomes usable immediately with no user interaction.
-     * </p>
-     * <p>
-     * The permissions associated with the openRequest passed to this method must
-     * be read permissions only (or null/empty). It is not allowed to pass publish
-     * permissions to this method and will result in an exception being thrown.
-     * </p>
-     * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
-     * </p>
-     *
-     * @param openRequest the open request, can be null only if the Session is in the
-     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     * @throws FacebookException if any publish or manage permissions are requested
-     */
-    public final void openForRead(OpenRequest openRequest) {
-        open(openRequest, SessionAuthorizationType.READ);
-    }
-
-    /**
-     * <p>
-     * Logs a user in to Facebook.
-     * </p>
-     * <p>
-     * A session may not be used with {@link Request Request} and other classes
-     * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, and the requested permissions are a subset of the previously authorized
-     * permissions, then the Session becomes usable immediately with no user interaction.
-     * </p>
-     * <p>
-     * The permissions associated with the openRequest passed to this method must
-     * be publish or manage permissions only and must be non-empty. Any read permissions
-     * will result in a warning, and may fail during server-side authorization. Also, an application
-     * must have at least basic read permissions prior to requesting publish permissions, so
-     * this method should only be used if the application knows that the user has already granted
-     * read permissions to the application; otherwise, openForRead should be used, followed by a
-     * call to requestNewPublishPermissions. For more information on this flow, see
-     * https://developers.facebook.com/docs/facebook-login/permissions/.
-     * </p>
-     * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
-     * </p>
-     *
-     * @param openRequest the open request, can be null only if the Session is in the
-     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     * @throws FacebookException if the passed in request is null or has no permissions set.
-     */
-    public final void openForPublish(OpenRequest openRequest) {
-        open(openRequest, SessionAuthorizationType.PUBLISH);
-    }
-
-    /**
-     * Opens a session based on an existing Facebook access token. This method should be used
-     * only in instances where an application has previously obtained an access token and wishes
-     * to import it into the Session/TokenCachingStrategy-based session-management system. An
-     * example would be an application which previously did not use the Facebook SDK for Android
-     * and implemented its own session-management scheme, but wishes to implement an upgrade path
-     * for existing users so they do not need to log in again when upgrading to a version of
-     * the app that uses the SDK.
-     * <p/>
-     * No validation is done that the token, token source, or permissions are actually valid.
-     * It is the caller's responsibility to ensure that these accurately reflect the state of
-     * the token that has been passed in, or calls to the Facebook API may fail.
-     *
-     * @param accessToken the access token obtained from Facebook
-     * @param callback    a callback that will be called when the session status changes; may be null
-     */
-    public final void open(AccessToken accessToken, StatusCallback callback) {
-        synchronized (this.lock) {
-            if (pendingAuthorizationRequest != null) {
-                throw new UnsupportedOperationException(
-                        "Session: an attempt was made to open a session that has a pending request.");
-            }
-
-            if (state.isClosed()) {
-                throw new UnsupportedOperationException(
-                        "Session: an attempt was made to open a previously-closed session.");
-            } else if (state != SessionState.CREATED && state != SessionState.CREATED_TOKEN_LOADED) {
-                throw new UnsupportedOperationException(
-                        "Session: an attempt was made to open an already opened session.");
-            }
-
-            if (callback != null) {
-                addCallback(callback);
-            }
-
-            this.tokenInfo = accessToken;
-
-            if (this.tokenCachingStrategy != null) {
-                this.tokenCachingStrategy.save(accessToken.toCacheBundle());
-            }
-
-            final SessionState oldState = state;
-            state = SessionState.OPENED;
-            this.postStateChange(oldState, state, null);
-        }
-
-        autoPublishAsync();
-    }
-
-    /**
-     * <p>
-     * Issues a request to add new read permissions to the Session.
-     * </p>
-     * <p>
-     * If successful, this will update the set of permissions on this session to
-     * match the newPermissions. If this fails, the Session remains unchanged.
-     * </p>
-     * <p>
-     * The permissions associated with the newPermissionsRequest passed to this method must
-     * be read permissions only (or null/empty). It is not allowed to pass publish
-     * permissions to this method and will result in an exception being thrown.
-     * </p>
-     *
-     * @param newPermissionsRequest the new permissions request
-     */
-    public final void requestNewReadPermissions(NewPermissionsRequest newPermissionsRequest) {
-        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.READ);
-    }
-
-    /**
-     * <p>
-     * Issues a request to add new publish or manage permissions to the Session.
-     * </p>
-     * <p>
-     * If successful, this will update the set of permissions on this session to
-     * match the newPermissions. If this fails, the Session remains unchanged.
-     * </p>
-     * <p>
-     * The permissions associated with the newPermissionsRequest passed to this method must
-     * be publish or manage permissions only and must be non-empty. Any read permissions
-     * will result in a warning, and may fail during server-side authorization.
-     * </p>
-     *
-     * @param newPermissionsRequest the new permissions request
-     */
-    public final void requestNewPublishPermissions(NewPermissionsRequest newPermissionsRequest) {
-        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.PUBLISH);
-    }
-
-    /**
-     * Provides an implementation for {@link Activity#onActivityResult
-     * onActivityResult} that updates the Session based on information returned
-     * during the authorization flow. The Activity that calls open or
-     * requestNewPermissions should forward the resulting onActivityResult call here to
-     * update the Session state based on the contents of the resultCode and
-     * data.
-     *
-     * @param currentActivity The Activity that is forwarding the onActivityResult call.
-     * @param requestCode     The requestCode parameter from the forwarded call. When this
-     *                        onActivityResult occurs as part of Facebook authorization
-     *                        flow, this value is the activityCode passed to open or
-     *                        authorize.
-     * @param resultCode      An int containing the resultCode parameter from the forwarded
-     *                        call.
-     * @param data            The Intent passed as the data parameter from the forwarded
-     *                        call.
-     * @return A boolean indicating whether the requestCode matched a pending
-     *         authorization request for this Session.
-     */
-    public final boolean onActivityResult(Activity currentActivity, int requestCode, int resultCode, Intent data) {
-        Validate.notNull(currentActivity, "currentActivity");
-
-        initializeStaticContext(currentActivity);
-
-        synchronized (lock) {
-            if (pendingAuthorizationRequest == null || (requestCode != pendingAuthorizationRequest.getRequestCode())) {
-                return false;
-            }
-        }
-
-        Exception exception = null;
-        AuthorizationClient.Result.Code code = AuthorizationClient.Result.Code.ERROR;
-
-        if (data != null) {
-            AuthorizationClient.Result result = (AuthorizationClient.Result) data.getSerializableExtra(
-                    LoginActivity.RESULT_KEY);
-            if (result != null) {
-                // This came from LoginActivity.
-                handleAuthorizationResult(resultCode, result);
-                return true;
-            } else if (authorizationClient != null) {
-                // Delegate to the auth client.
-                authorizationClient.onActivityResult(requestCode, resultCode, data);
-                return true;
-            }
-        } else if (resultCode == Activity.RESULT_CANCELED) {
-            exception = new FacebookOperationCanceledException("User canceled operation.");
-            code = AuthorizationClient.Result.Code.CANCEL;
-        }
-
-        if (exception == null) {
-            exception = new FacebookException("Unexpected call to Session.onActivityResult");
-        }
-
-        logAuthorizationComplete(code, null, exception);
-        finishAuthOrReauth(null, exception);
-
-        return true;
-    }
-
-    /**
-     * Closes the local in-memory Session object, but does not clear the
-     * persisted token cache.
-     */
-    public final void close() {
-        synchronized (this.lock) {
-            final SessionState oldState = this.state;
-
-            switch (this.state) {
-                case CREATED:
-                case OPENING:
-                    this.state = SessionState.CLOSED_LOGIN_FAILED;
-                    postStateChange(oldState, this.state, new FacebookException(
-                            "Log in attempt aborted."));
-                    break;
-
-                case CREATED_TOKEN_LOADED:
-                case OPENED:
-                case OPENED_TOKEN_UPDATED:
-                    this.state = SessionState.CLOSED;
-                    postStateChange(oldState, this.state, null);
-                    break;
-
-                case CLOSED:
-                case CLOSED_LOGIN_FAILED:
-                    break;
-            }
-        }
-    }
-
-    /**
-     * Closes the local in-memory Session object and clears any persisted token
-     * cache related to the Session.
-     */
-    public final void closeAndClearTokenInformation() {
-        if (this.tokenCachingStrategy != null) {
-            this.tokenCachingStrategy.clear();
-        }
-        Utility.clearFacebookCookies(staticContext);
-        Utility.clearCaches(staticContext);
-        close();
-    }
-
-    /**
-     * Adds a callback that will be called when the state of this Session changes.
-     *
-     * @param callback the callback
-     */
-    public final void addCallback(StatusCallback callback) {
-        synchronized (callbacks) {
-            if (callback != null && !callbacks.contains(callback)) {
-                callbacks.add(callback);
-            }
-        }
-    }
-
-    /**
-     * Removes a StatusCallback from this Session.
-     *
-     * @param callback the callback
-     */
-    public final void removeCallback(StatusCallback callback) {
-        synchronized (callbacks) {
-            callbacks.remove(callback);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return new StringBuilder().append("{Session").append(" state:").append(this.state).append(", token:")
-                .append((this.tokenInfo == null) ? "null" : this.tokenInfo).append(", appId:")
-                .append((this.applicationId == null) ? "null" : this.applicationId).append("}").toString();
-    }
-
-    void extendTokenCompleted(Bundle bundle) {
-        synchronized (this.lock) {
-            final SessionState oldState = this.state;
-
-            switch (this.state) {
-                case OPENED:
-                    this.state = SessionState.OPENED_TOKEN_UPDATED;
-                    postStateChange(oldState, this.state, null);
-                    break;
-                case OPENED_TOKEN_UPDATED:
-                    break;
-                default:
-                    // Silently ignore attempts to refresh token if we are not open
-                    Log.d(TAG, "refreshToken ignored in state " + this.state);
-                    return;
-            }
-            this.tokenInfo = AccessToken.createFromRefresh(this.tokenInfo, bundle);
-            if (this.tokenCachingStrategy != null) {
-                this.tokenCachingStrategy.save(this.tokenInfo.toCacheBundle());
-            }
-        }
-    }
-
-    private Object writeReplace() {
-        return new SerializationProxyV1(applicationId, state, tokenInfo,
-                lastAttemptedTokenExtendDate, false, pendingAuthorizationRequest);
-    }
-
-    // have a readObject that throws to prevent spoofing
-    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
-        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
-    }
-
-    /**
-     * Save the Session object into the supplied Bundle. This method is intended to be called from an
-     * Activity or Fragment's onSaveInstanceState method in order to preserve Sessions across Activity lifecycle events.
-     *
-     * @param session the Session to save
-     * @param bundle  the Bundle to save the Session to
-     */
-    public static final void saveSession(Session session, Bundle bundle) {
-        if (bundle != null && session != null && !bundle.containsKey(SESSION_BUNDLE_SAVE_KEY)) {
-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-            try {
-                new ObjectOutputStream(outputStream).writeObject(session);
-            } catch (IOException e) {
-                throw new FacebookException("Unable to save session.", e);
-            }
-            bundle.putByteArray(SESSION_BUNDLE_SAVE_KEY, outputStream.toByteArray());
-            bundle.putBundle(AUTH_BUNDLE_SAVE_KEY, session.authorizationBundle);
-        }
-    }
-
-    /**
-     * Restores the saved session from a Bundle, if any. Returns the restored Session or
-     * null if it could not be restored. This method is intended to be called from an Activity or Fragment's
-     * onCreate method when a Session has previously been saved into a Bundle via saveState to preserve a Session
-     * across Activity lifecycle events.
-     *
-     * @param context         the Activity or Service creating the Session, must not be null
-     * @param cachingStrategy the TokenCachingStrategy to use to load and store the token. If this is
-     *                        null, a default token cachingStrategy that stores data in
-     *                        SharedPreferences will be used
-     * @param callback        the callback to notify for Session state changes, can be null
-     * @param bundle          the bundle to restore the Session from
-     * @return the restored Session, or null
-     */
-    public static final Session restoreSession(
-            Context context, TokenCachingStrategy cachingStrategy, StatusCallback callback, Bundle bundle) {
-        if (bundle == null) {
-            return null;
-        }
-        byte[] data = bundle.getByteArray(SESSION_BUNDLE_SAVE_KEY);
-        if (data != null) {
-            ByteArrayInputStream is = new ByteArrayInputStream(data);
-            try {
-                Session session = (Session) (new ObjectInputStream(is)).readObject();
-                initializeStaticContext(context);
-                if (cachingStrategy != null) {
-                    session.tokenCachingStrategy = cachingStrategy;
-                } else {
-                    session.tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(context);
-                }
-                if (callback != null) {
-                    session.addCallback(callback);
-                }
-                session.authorizationBundle = bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
-                return session;
-            } catch (ClassNotFoundException e) {
-                Log.w(TAG, "Unable to restore session", e);
-            } catch (IOException e) {
-                Log.w(TAG, "Unable to restore session.", e);
-            }
-        }
-        return null;
-    }
-
-
-    /**
-     * Returns the current active Session, or null if there is none.
-     *
-     * @return the current active Session, or null if there is none.
-     */
-    public static final Session getActiveSession() {
-        synchronized (Session.STATIC_LOCK) {
-            return Session.activeSession;
-        }
-    }
-
-    /**
-     * <p>
-     * Sets the current active Session.
-     * </p>
-     * <p>
-     * The active Session is used implicitly by predefined Request factory
-     * methods as well as optionally by UI controls in the sdk.
-     * </p>
-     * <p>
-     * It is legal to set this to null, or to a Session that is not yet open.
-     * </p>
-     *
-     * @param session A Session to use as the active Session, or null to indicate
-     *                that there is no active Session.
-     */
-    public static final void setActiveSession(Session session) {
-        synchronized (Session.STATIC_LOCK) {
-            if (session != Session.activeSession) {
-                Session oldSession = Session.activeSession;
-
-                if (oldSession != null) {
-                    oldSession.close();
-                }
-
-                Session.activeSession = session;
-
-                if (oldSession != null) {
-                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-                }
-
-                if (session != null) {
-                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-
-                    if (session.isOpened()) {
-                        postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * If a cached token is available, creates and opens the session and makes it active without any user interaction,
-     * otherwise this does nothing.
-     *
-     * @param context The Context creating this session
-     * @return The new session or null if one could not be created
-     */
-    public static Session openActiveSessionFromCache(Context context) {
-        return openActiveSession(context, false, null);
-    }
-
-    /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
-     * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param activity     The Activity that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
-     * @param callback     The {@link StatusCallback SessionStatusCallback} to
-     *                     notify regarding Session state changes. May be null.
-     * @return The new Session or null if one could not be created
-     */
-    public static Session openActiveSession(Activity activity, boolean allowLoginUI,
-            StatusCallback callback) {
-        return openActiveSession(activity, allowLoginUI, new OpenRequest(activity).setCallback(callback));
-    }
-
-    /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
-     * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param context      The Activity or Service creating this Session
-     * @param fragment     The Fragment that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
-     * @param callback     The {@link StatusCallback SessionStatusCallback} to
-     *                     notify regarding Session state changes.
-     * @return The new Session or null if one could not be created
-     */
-    public static Session openActiveSession(Context context, Fragment fragment,
-            boolean allowLoginUI, StatusCallback callback) {
-        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
-    }
-
-    /**
-     * Opens a session based on an existing Facebook access token, and also makes this session
-     * the currently active session. This method should be used
-     * only in instances where an application has previously obtained an access token and wishes
-     * to import it into the Session/TokenCachingStrategy-based session-management system. A primary
-     * example would be an application which previously did not use the Facebook SDK for Android
-     * and implemented its own session-management scheme, but wishes to implement an upgrade path
-     * for existing users so they do not need to log in again when upgrading to a version of
-     * the app that uses the SDK. In general, this method will be called only once, when the app
-     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
-     * should be used to manage the session and its associated token.
-     * <p/>
-     * No validation is done that the token, token source, or permissions are actually valid.
-     * It is the caller's responsibility to ensure that these accurately reflect the state of
-     * the token that has been passed in, or calls to the Facebook API may fail.
-     *
-     * @param context     the Context to use for creation the session
-     * @param accessToken the access token obtained from Facebook
-     * @param callback    a callback that will be called when the session status changes; may be null
-     * @return The new Session or null if one could not be created
-     */
-    public static Session openActiveSessionWithAccessToken(Context context, AccessToken accessToken,
-            StatusCallback callback) {
-        Session session = new Session(context, null, null, false);
-
-        setActiveSession(session);
-        session.open(accessToken, callback);
-
-        return session;
-    }
-
-    private static Session openActiveSession(Context context, boolean allowLoginUI, OpenRequest openRequest) {
-        Session session = new Builder(context).build();
-        if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState()) || allowLoginUI) {
-            setActiveSession(session);
-            session.openForRead(openRequest);
-            return session;
-        }
-        return null;
-    }
-
-    static Context getStaticContext() {
-        return staticContext;
-    }
-
-    static void initializeStaticContext(Context currentContext) {
-        if ((currentContext != null) && (staticContext == null)) {
-            Context applicationContext = currentContext.getApplicationContext();
-            staticContext = (applicationContext != null) ? applicationContext : currentContext;
-        }
-    }
-
-    void authorize(AuthorizationRequest request) {
-        boolean started = false;
-
-        request.setApplicationId(applicationId);
-
-        autoPublishAsync();
-
-        logAuthorizationStart();
-
-        started = tryLoginActivity(request);
-
-        pendingAuthorizationRequest.loggingExtras.put(AuthorizationClient.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
-                started ? AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO);
-
-        if (!started && request.isLegacy) {
-            pendingAuthorizationRequest.loggingExtras.put(AuthorizationClient.EVENT_EXTRAS_TRY_LEGACY,
-                    AppEventsConstants.EVENT_PARAM_VALUE_YES);
-
-            tryLegacyAuth(request);
-            started = true;
-        }
-
-        if (!started) {
-            synchronized (this.lock) {
-                final SessionState oldState = this.state;
-
-                switch (this.state) {
-                    case CLOSED:
-                    case CLOSED_LOGIN_FAILED:
-                        return;
-
-                    default:
-                        this.state = SessionState.CLOSED_LOGIN_FAILED;
-
-                        Exception exception = new FacebookException(
-                                "Log in attempt failed: LoginActivity could not be started, and not legacy request");
-                        logAuthorizationComplete(AuthorizationClient.Result.Code.ERROR, null, exception);
-                        postStateChange(oldState, this.state, exception);
-                }
-            }
-        }
-    }
-
-    private void open(OpenRequest openRequest, SessionAuthorizationType authType) {
-        validatePermissions(openRequest, authType);
-        validateLoginBehavior(openRequest);
-
-        SessionState newState;
-        synchronized (this.lock) {
-            if (pendingAuthorizationRequest != null) {
-                postStateChange(state, state, new UnsupportedOperationException(
-                        "Session: an attempt was made to open a session that has a pending request."));
-                return;
-            }
-            final SessionState oldState = this.state;
-
-            switch (this.state) {
-                case CREATED:
-                    this.state = newState = SessionState.OPENING;
-                    if (openRequest == null) {
-                        throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
-                    }
-                    pendingAuthorizationRequest = openRequest;
-                    break;
-                case CREATED_TOKEN_LOADED:
-                    if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
-                        if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
-                            pendingAuthorizationRequest = openRequest;
-                        }
-                    }
-                    if (pendingAuthorizationRequest == null) {
-                        this.state = newState = SessionState.OPENED;
-                    } else {
-                        this.state = newState = SessionState.OPENING;
-                    }
-                    break;
-                default:
-                    throw new UnsupportedOperationException(
-                            "Session: an attempt was made to open an already opened session.");
-            }
-            if (openRequest != null) {
-                addCallback(openRequest.getCallback());
-            }
-            this.postStateChange(oldState, newState, null);
-        }
-
-        if (newState == SessionState.OPENING) {
-            authorize(openRequest);
-        }
-    }
-
-    private void requestNewPermissions(NewPermissionsRequest newPermissionsRequest, SessionAuthorizationType authType) {
-        validatePermissions(newPermissionsRequest, authType);
-        validateLoginBehavior(newPermissionsRequest);
-
-        if (newPermissionsRequest != null) {
-            synchronized (this.lock) {
-                if (pendingAuthorizationRequest != null) {
-                    throw new UnsupportedOperationException(
-                            "Session: an attempt was made to request new permissions for a session that has a pending request.");
-                }
-                if (state.isOpened()) {
-                    pendingAuthorizationRequest = newPermissionsRequest;
-                } else if (state.isClosed()) {
-                    throw new UnsupportedOperationException(
-                            "Session: an attempt was made to request new permissions for a session that has been closed.");
-                } else {
-                    throw new UnsupportedOperationException(
-                            "Session: an attempt was made to request new permissions for a session that is not currently open.");
-                }
-            }
-
-            newPermissionsRequest.setValidateSameFbidAsToken(getAccessToken());
-            addCallback(newPermissionsRequest.getCallback());
-            authorize(newPermissionsRequest);
-        }
-    }
-
-    private void validateLoginBehavior(AuthorizationRequest request) {
-        if (request != null && !request.isLegacy) {
-            Intent intent = new Intent();
-            intent.setClass(getStaticContext(), LoginActivity.class);
-            if (!resolveIntent(intent)) {
-                throw new FacebookException(String.format(
-                        "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
-                        request.getLoginBehavior(), LoginActivity.class.getName()));
-            }
-        }
-    }
-
-    private void validatePermissions(AuthorizationRequest request, SessionAuthorizationType authType) {
-        if (request == null || Utility.isNullOrEmpty(request.getPermissions())) {
-            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                throw new FacebookException("Cannot request publish or manage authorization with no permissions.");
-            }
-            return; // nothing to check
-        }
-        for (String permission : request.getPermissions()) {
-            if (isPublishPermission(permission)) {
-                if (SessionAuthorizationType.READ.equals(authType)) {
-                    throw new FacebookException(
-                            String.format(
-                                    "Cannot pass a publish or manage permission (%s) to a request for read authorization",
-                                    permission));
-                }
-            } else {
-                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                    Log.w(TAG,
-                            String.format(
-                                    "Should not pass a read permission (%s) to a request for publish or manage authorization",
-                                    permission));
-                }
-            }
-        }
-    }
-
-    public static boolean isPublishPermission(String permission) {
-        return permission != null &&
-                (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
-                        permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
-                        OTHER_PUBLISH_PERMISSIONS.contains(permission));
-
-    }
-
-    private void handleAuthorizationResult(int resultCode, AuthorizationClient.Result result) {
-        AccessToken newToken = null;
-        Exception exception = null;
-        if (resultCode == Activity.RESULT_OK) {
-            if (result.code == AuthorizationClient.Result.Code.SUCCESS) {
-                newToken = result.token;
-            } else {
-                exception = new FacebookAuthorizationException(result.errorMessage);
-            }
-        } else if (resultCode == Activity.RESULT_CANCELED) {
-            exception = new FacebookOperationCanceledException(result.errorMessage);
-        }
-
-        logAuthorizationComplete(result.code, result.loggingExtras, exception);
-
-        authorizationClient = null;
-        finishAuthOrReauth(newToken, exception);
-    }
-
-    private void logAuthorizationStart() {
-        Bundle bundle = AuthorizationClient.newAuthorizationLoggingBundle(pendingAuthorizationRequest.getAuthId());
-        bundle.putLong(AuthorizationClient.EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
-
-        // Log what we already know about the call in start event
-        try {
-            JSONObject extras = new JSONObject();
-            extras.put(AuthorizationClient.EVENT_EXTRAS_LOGIN_BEHAVIOR,
-                    pendingAuthorizationRequest.loginBehavior.toString());
-            extras.put(AuthorizationClient.EVENT_EXTRAS_REQUEST_CODE, pendingAuthorizationRequest.requestCode);
-            extras.put(AuthorizationClient.EVENT_EXTRAS_IS_LEGACY, pendingAuthorizationRequest.isLegacy);
-            extras.put(AuthorizationClient.EVENT_EXTRAS_PERMISSIONS,
-                    TextUtils.join(",", pendingAuthorizationRequest.permissions));
-            extras.put(AuthorizationClient.EVENT_EXTRAS_DEFAULT_AUDIENCE,
-                    pendingAuthorizationRequest.defaultAudience.toString());
-            bundle.putString(AuthorizationClient.EVENT_PARAM_EXTRAS, extras.toString());
-        } catch (JSONException e) {
-        }
-
-        AppEventsLogger logger = getAppEventsLogger();
-        logger.logSdkEvent(AuthorizationClient.EVENT_NAME_LOGIN_START, null, bundle);
-    }
-
-    private void logAuthorizationComplete(AuthorizationClient.Result.Code result, Map<String, String> resultExtras,
-            Exception exception) {
-        Bundle bundle = null;
-        if (pendingAuthorizationRequest == null) {
-            // We don't expect this to happen, but if it does, log an event for diagnostic purposes.
-            bundle = AuthorizationClient.newAuthorizationLoggingBundle("");
-            bundle.putString(AuthorizationClient.EVENT_PARAM_LOGIN_RESULT,
-                    AuthorizationClient.Result.Code.ERROR.getLoggingValue());
-            bundle.putString(AuthorizationClient.EVENT_PARAM_ERROR_MESSAGE,
-                    "Unexpected call to logAuthorizationComplete with null pendingAuthorizationRequest.");
-        } else {
-            bundle = AuthorizationClient.newAuthorizationLoggingBundle(pendingAuthorizationRequest.getAuthId());
-            if (result != null) {
-                bundle.putString(AuthorizationClient.EVENT_PARAM_LOGIN_RESULT, result.getLoggingValue());
-            }
-            if (exception != null && exception.getMessage() != null) {
-                bundle.putString(AuthorizationClient.EVENT_PARAM_ERROR_MESSAGE, exception.getMessage());
-            }
-
-            // Combine extras from the request and from the result.
-            JSONObject jsonObject = null;
-            if (pendingAuthorizationRequest.loggingExtras.isEmpty() == false) {
-                jsonObject = new JSONObject(pendingAuthorizationRequest.loggingExtras);
-            }
-            if (resultExtras != null) {
-                if (jsonObject == null) {
-                    jsonObject = new JSONObject();
-                }
-                try {
-                    for (Map.Entry<String, String> entry : resultExtras.entrySet()) {
-                        jsonObject.put(entry.getKey(), entry.getValue());
-                    }
-                } catch (JSONException e) {
-                }
-            }
-            if (jsonObject != null) {
-                bundle.putString(AuthorizationClient.EVENT_PARAM_EXTRAS, jsonObject.toString());
-            }
-        }
-        bundle.putLong(AuthorizationClient.EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
-
-        AppEventsLogger logger = getAppEventsLogger();
-        logger.logSdkEvent(AuthorizationClient.EVENT_NAME_LOGIN_COMPLETE, null, bundle);
-    }
-
-    private boolean tryLoginActivity(AuthorizationRequest request) {
-        Intent intent = getLoginActivityIntent(request);
-
-        if (!resolveIntent(intent)) {
-            return false;
-        }
-
-        try {
-            request.getStartActivityDelegate().startActivityForResult(intent, request.getRequestCode());
-        } catch (ActivityNotFoundException e) {
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean resolveIntent(Intent intent) {
-        ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
-        if (resolveInfo == null) {
-            return false;
-        }
-        return true;
-    }
-
-    private Intent getLoginActivityIntent(AuthorizationRequest request) {
-        Intent intent = new Intent();
-        intent.setClass(getStaticContext(), LoginActivity.class);
-        intent.setAction(request.getLoginBehavior().toString());
-
-        // Let LoginActivity populate extras appropriately
-        AuthorizationClient.AuthorizationRequest authClientRequest = request.getAuthorizationClientRequest();
-        Bundle extras = LoginActivity.populateIntentExtras(authClientRequest);
-        intent.putExtras(extras);
-
-        return intent;
-    }
-
-    private void tryLegacyAuth(final AuthorizationRequest request) {
-        authorizationClient = new AuthorizationClient();
-        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
-            @Override
-            public void onCompleted(AuthorizationClient.Result result) {
-                int activityResult;
-                if (result.code == AuthorizationClient.Result.Code.CANCEL) {
-                    activityResult = Activity.RESULT_CANCELED;
-                } else {
-                    activityResult = Activity.RESULT_OK;
-                }
-                handleAuthorizationResult(activityResult, result);
-            }
-        });
-        authorizationClient.setContext(getStaticContext());
-        authorizationClient.startOrContinueAuth(request.getAuthorizationClientRequest());
-    }
-
-    void finishAuthOrReauth(AccessToken newToken, Exception exception) {
-        // If the token we came up with is expired/invalid, then auth failed.
-        if ((newToken != null) && newToken.isInvalid()) {
-            newToken = null;
-            exception = new FacebookException("Invalid access token.");
-        }
-
-
-        synchronized (this.lock) {
-            switch (this.state) {
-                case OPENING:
-                    // This means we are authorizing for the first time in this Session.
-                    finishAuthorization(newToken, exception);
-                    break;
-
-                case OPENED:
-                case OPENED_TOKEN_UPDATED:
-                    // This means we are reauthorizing.
-                    finishReauthorization(newToken, exception);
-                    break;
-
-                case CREATED:
-                case CREATED_TOKEN_LOADED:
-                case CLOSED:
-                case CLOSED_LOGIN_FAILED:
-                    Log.d(TAG, "Unexpected call to finishAuthOrReauth in state " + this.state);
-                    break;
-            }
-        }
-    }
-
-    private void finishAuthorization(AccessToken newToken, Exception exception) {
-        final SessionState oldState = state;
-        if (newToken != null) {
-            tokenInfo = newToken;
-            saveTokenToCache(newToken);
-
-            state = SessionState.OPENED;
-        } else if (exception != null) {
-            state = SessionState.CLOSED_LOGIN_FAILED;
-        }
-        pendingAuthorizationRequest = null;
-        postStateChange(oldState, state, exception);
-    }
-
-    private void finishReauthorization(final AccessToken newToken, Exception exception) {
-        final SessionState oldState = state;
-
-        if (newToken != null) {
-            tokenInfo = newToken;
-            saveTokenToCache(newToken);
-
-            state = SessionState.OPENED_TOKEN_UPDATED;
-        }
-
-        pendingAuthorizationRequest = null;
-        postStateChange(oldState, state, exception);
-    }
-
-    private void saveTokenToCache(AccessToken newToken) {
-        if (newToken != null && tokenCachingStrategy != null) {
-            tokenCachingStrategy.save(newToken.toCacheBundle());
-        }
-    }
-
-    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
-        // When we request new permissions, we stay in SessionState.OPENED_TOKEN_UPDATED,
-        // but we still want notifications of the state change since permissions are
-        // different now.
-        if ((oldState == newState) &&
-                (oldState != SessionState.OPENED_TOKEN_UPDATED) &&
-                (exception == null)) {
-            return;
-        }
-
-        if (newState.isClosed()) {
-            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
-        }
-
-        // Need to schedule the callbacks inside the same queue to preserve ordering.
-        // Otherwise these callbacks could have been added to the queue before the SessionTracker
-        // gets the ACTIVE_SESSION_SET action.
-        Runnable runCallbacks = new Runnable() {
-            public void run() {
-                synchronized (callbacks) {
-                    for (final StatusCallback callback : callbacks) {
-                        Runnable closure = new Runnable() {
-                            public void run() {
-                                // This can be called inside a synchronized block.
-                                callback.call(Session.this, newState, exception);
-                            }
-                        };
-
-                        runWithHandlerOrExecutor(handler, closure);
-                    }
-                }
-            }
-        };
-        runWithHandlerOrExecutor(handler, runCallbacks);
-
-        if (this == Session.activeSession) {
-            if (oldState.isOpened() != newState.isOpened()) {
-                if (newState.isOpened()) {
-                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-                } else {
-                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-                }
-            }
-        }
-    }
-
-    static void postActiveSessionAction(String action) {
-        final Intent intent = new Intent(action);
-
-        LocalBroadcastManager.getInstance(getStaticContext()).sendBroadcast(intent);
-    }
-
-    private static void runWithHandlerOrExecutor(Handler handler, Runnable runnable) {
-        if (handler != null) {
-            handler.post(runnable);
-        } else {
-            Settings.getExecutor().execute(runnable);
-        }
-    }
-
-    void extendAccessTokenIfNeeded() {
-        if (shouldExtendAccessToken()) {
-            extendAccessToken();
-        }
-    }
-
-    void extendAccessToken() {
-        TokenRefreshRequest newTokenRefreshRequest = null;
-        synchronized (this.lock) {
-            if (currentTokenRefreshRequest == null) {
-                newTokenRefreshRequest = new TokenRefreshRequest();
-                currentTokenRefreshRequest = newTokenRefreshRequest;
-            }
-        }
-
-        if (newTokenRefreshRequest != null) {
-            newTokenRefreshRequest.bind();
-        }
-    }
-
-    boolean shouldExtendAccessToken() {
-        if (currentTokenRefreshRequest != null) {
-            return false;
-        }
-
-        boolean result = false;
-
-        Date now = new Date();
-
-        if (state.isOpened() && tokenInfo.getSource().canExtendToken()
-                && now.getTime() - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
-                && now.getTime() - tokenInfo.getLastRefresh().getTime() > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000) {
-            result = true;
-        }
-
-        return result;
-    }
-
-    private AppEventsLogger getAppEventsLogger() {
-        synchronized (lock) {
-            if (appEventsLogger == null) {
-                appEventsLogger = AppEventsLogger.newLogger(staticContext, applicationId);
-            }
-            return appEventsLogger;
-        }
-    }
-
-    AccessToken getTokenInfo() {
-        return tokenInfo;
-    }
-
-    void setTokenInfo(AccessToken tokenInfo) {
-        this.tokenInfo = tokenInfo;
-    }
-
-    Date getLastAttemptedTokenExtendDate() {
-        return lastAttemptedTokenExtendDate;
-    }
-
-    void setLastAttemptedTokenExtendDate(Date lastAttemptedTokenExtendDate) {
-        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
-    }
-
-    void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
-        this.currentTokenRefreshRequest = request;
-    }
-
-    class TokenRefreshRequest implements ServiceConnection {
-
-        final Messenger messageReceiver = new Messenger(
-                new TokenRefreshRequestHandler(Session.this, this));
-
-        Messenger messageSender = null;
-
-        public void bind() {
-            Intent intent = NativeProtocol.createTokenRefreshIntent(getStaticContext());
-            if (intent != null
-                    && staticContext.bindService(intent, this, Context.BIND_AUTO_CREATE)) {
-                setLastAttemptedTokenExtendDate(new Date());
-            } else {
-                cleanup();
-            }
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            messageSender = new Messenger(service);
-            refreshToken();
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName arg) {
-            cleanup();
-
-            // We returned an error so there's no point in
-            // keeping the binding open.
-            staticContext.unbindService(TokenRefreshRequest.this);
-        }
-
-        private void cleanup() {
-            if (currentTokenRefreshRequest == this) {
-                currentTokenRefreshRequest = null;
-            }
-        }
-
-        private void refreshToken() {
-            Bundle requestData = new Bundle();
-            requestData.putString(AccessToken.ACCESS_TOKEN_KEY, getTokenInfo().getToken());
-
-            Message request = Message.obtain();
-            request.setData(requestData);
-            request.replyTo = messageReceiver;
-
-            try {
-                messageSender.send(request);
-            } catch (RemoteException e) {
-                cleanup();
-            }
-        }
-
-    }
-
-    // Creating a static Handler class to reduce the possibility of a memory leak.
-    // Handler objects for the same thread all share a common Looper object, which they post messages
-    // to and read from. As messages contain target Handler, as long as there are messages with target
-    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
-    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
-    static class TokenRefreshRequestHandler extends Handler {
-
-        private WeakReference<Session> sessionWeakReference;
-        private WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
-
-        TokenRefreshRequestHandler(Session session, TokenRefreshRequest refreshRequest) {
-            super(Looper.getMainLooper());
-            sessionWeakReference = new WeakReference<Session>(session);
-            refreshRequestWeakReference = new WeakReference<TokenRefreshRequest>(refreshRequest);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            String token = msg.getData().getString(AccessToken.ACCESS_TOKEN_KEY);
-            Session session = sessionWeakReference.get();
-
-            if (session != null && token != null) {
-                session.extendTokenCompleted(msg.getData());
-            }
-
-            TokenRefreshRequest request = refreshRequestWeakReference.get();
-            if (request != null) {
-                // The refreshToken function should be called rarely,
-                // so there is no point in keeping the binding open.
-                staticContext.unbindService(request);
-                request.cleanup();
-            }
-        }
-    }
-
-    /**
-     * Provides asynchronous notification of Session state changes.
-     *
-     * @see Session#open open
-     */
-    public interface StatusCallback {
-        public void call(Session session, SessionState state, Exception exception);
-    }
-
-    @Override
-    public int hashCode() {
-        return 0;
-    }
-
-    @Override
-    public boolean equals(Object otherObj) {
-        if (!(otherObj instanceof Session)) {
-            return false;
-        }
-        Session other = (Session) otherObj;
-
-        return areEqual(other.applicationId, applicationId) &&
-                areEqual(other.authorizationBundle, authorizationBundle) &&
-                areEqual(other.state, state) &&
-                areEqual(other.getExpirationDate(), getExpirationDate());
-    }
-
-    private static boolean areEqual(Object a, Object b) {
-        if (a == null) {
-            return b == null;
-        } else {
-            return a.equals(b);
-        }
-    }
-
-    /**
-     * Builder class used to create a Session.
-     */
-    public static final class Builder {
-        private final Context context;
-        private String applicationId;
-        private TokenCachingStrategy tokenCachingStrategy;
-
-        /**
-         * Constructs a new Builder associated with the context.
-         *
-         * @param context the Activity or Service starting the Session
-         */
-        public Builder(Context context) {
-            this.context = context;
-        }
-
-        /**
-         * Sets the application id for the Session.
-         *
-         * @param applicationId the application id
-         * @return the Builder instance
-         */
-        public Builder setApplicationId(final String applicationId) {
-            this.applicationId = applicationId;
-            return this;
-        }
-
-        /**
-         * Sets the TokenCachingStrategy for the Session.
-         *
-         * @param tokenCachingStrategy the token cache to use
-         * @return the Builder instance
-         */
-        public Builder setTokenCachingStrategy(final TokenCachingStrategy tokenCachingStrategy) {
-            this.tokenCachingStrategy = tokenCachingStrategy;
-            return this;
-        }
-
-        /**
-         * Build the Session.
-         *
-         * @return a new Session
-         */
-        public Session build() {
-            return new Session(context, applicationId, tokenCachingStrategy);
-        }
-    }
-
-    interface StartActivityDelegate {
-        public void startActivityForResult(Intent intent, int requestCode);
-
-        public Activity getActivityContext();
-    }
-
-    @SuppressWarnings("deprecation")
-    private void autoPublishAsync() {
-        AutoPublishAsyncTask asyncTask = null;
-        synchronized (this) {
-            if (autoPublishAsyncTask == null && Settings.getShouldAutoPublishInstall()) {
-                // copy the application id to guarantee thread safety against our container.
-                String applicationId = Session.this.applicationId;
-
-                // skip publish if we don't have an application id.
-                if (applicationId != null) {
-                    asyncTask = autoPublishAsyncTask = new AutoPublishAsyncTask(applicationId, staticContext);
-                }
-            }
-        }
-
-        if (asyncTask != null) {
-            asyncTask.execute();
-        }
-    }
-
-    /**
-     * Async implementation to allow auto publishing to not block the ui thread.
-     */
-    private class AutoPublishAsyncTask extends AsyncTask<Void, Void, Void> {
-        private final String mApplicationId;
-        private final Context mApplicationContext;
-
-        public AutoPublishAsyncTask(String applicationId, Context context) {
-            mApplicationId = applicationId;
-            mApplicationContext = context.getApplicationContext();
-        }
-
-        @Override
-        protected Void doInBackground(Void... voids) {
-            try {
-                Settings.publishInstallAndWaitForResponse(mApplicationContext, mApplicationId, true);
-            } catch (Exception e) {
-                Utility.logd("Facebook-publish", e);
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-            // always clear out the publisher to allow other invocations.
-            synchronized (Session.this) {
-                autoPublishAsyncTask = null;
-            }
-        }
-    }
-
-    /**
-     * Base class for authorization requests {@link OpenRequest} and {@link NewPermissionsRequest}.
-     */
-    public static class AuthorizationRequest implements Serializable {
-
-        private static final long serialVersionUID = 1L;
-
-        private final StartActivityDelegate startActivityDelegate;
-        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
-        private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE;
-        private StatusCallback statusCallback;
-        private boolean isLegacy = false;
-        private List<String> permissions = Collections.emptyList();
-        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
-        private String applicationId;
-        private String validateSameFbidAsToken;
-        private final String authId = UUID.randomUUID().toString();
-        private final Map<String, String> loggingExtras = new HashMap<String, String>();
-
-        AuthorizationRequest(final Activity activity) {
-            startActivityDelegate = new StartActivityDelegate() {
-                @Override
-                public void startActivityForResult(Intent intent, int requestCode) {
-                    activity.startActivityForResult(intent, requestCode);
-                }
-
-                @Override
-                public Activity getActivityContext() {
-                    return activity;
-                }
-            };
-        }
-
-        AuthorizationRequest(final Fragment fragment) {
-            startActivityDelegate = new StartActivityDelegate() {
-                @Override
-                public void startActivityForResult(Intent intent, int requestCode) {
-                    fragment.startActivityForResult(intent, requestCode);
-                }
-
-                @Override
-                public Activity getActivityContext() {
-                    return fragment.getActivity();
-                }
-            };
-        }
-
-        /**
-         * Constructor to be used for V1 serialization only, DO NOT CHANGE.
-         */
-        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
-                List<String> permissions, String defaultAudience, boolean isLegacy, String applicationId,
-                String validateSameFbidAsToken) {
-            startActivityDelegate = new StartActivityDelegate() {
-                @Override
-                public void startActivityForResult(Intent intent, int requestCode) {
-                    throw new UnsupportedOperationException(
-                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
-                }
-
-                @Override
-                public Activity getActivityContext() {
-                    throw new UnsupportedOperationException(
-                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
-                }
-            };
-            this.loginBehavior = loginBehavior;
-            this.requestCode = requestCode;
-            this.permissions = permissions;
-            this.defaultAudience = SessionDefaultAudience.valueOf(defaultAudience);
-            this.isLegacy = isLegacy;
-            this.applicationId = applicationId;
-            this.validateSameFbidAsToken = validateSameFbidAsToken;
-        }
-
-        /**
-         * Used for backwards compatibility with Facebook.java only, DO NOT USE.
-         *
-         * @param isLegacy
-         */
-        public void setIsLegacy(boolean isLegacy) {
-            this.isLegacy = isLegacy;
-        }
-
-        boolean isLegacy() {
-            return isLegacy;
-        }
-
-        AuthorizationRequest setCallback(StatusCallback statusCallback) {
-            this.statusCallback = statusCallback;
-            return this;
-        }
-
-        StatusCallback getCallback() {
-            return statusCallback;
-        }
-
-        AuthorizationRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            if (loginBehavior != null) {
-                this.loginBehavior = loginBehavior;
-            }
-            return this;
-        }
-
-        SessionLoginBehavior getLoginBehavior() {
-            return loginBehavior;
-        }
-
-        AuthorizationRequest setRequestCode(int requestCode) {
-            if (requestCode >= 0) {
-                this.requestCode = requestCode;
-            }
-            return this;
-        }
-
-        int getRequestCode() {
-            return requestCode;
-        }
-
-        AuthorizationRequest setPermissions(List<String> permissions) {
-            if (permissions != null) {
-                this.permissions = permissions;
-            }
-            return this;
-        }
-
-        AuthorizationRequest setPermissions(String... permissions) {
-            return setPermissions(Arrays.asList(permissions));
-        }
-
-        List<String> getPermissions() {
-            return permissions;
-        }
-
-        AuthorizationRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            if (defaultAudience != null) {
-                this.defaultAudience = defaultAudience;
-            }
-            return this;
-        }
-
-        SessionDefaultAudience getDefaultAudience() {
-            return defaultAudience;
-        }
-
-        StartActivityDelegate getStartActivityDelegate() {
-            return startActivityDelegate;
-        }
-
-        String getApplicationId() {
-            return applicationId;
-        }
-
-        void setApplicationId(String applicationId) {
-            this.applicationId = applicationId;
-        }
-
-        String getValidateSameFbidAsToken() {
-            return validateSameFbidAsToken;
-        }
-
-        void setValidateSameFbidAsToken(String validateSameFbidAsToken) {
-            this.validateSameFbidAsToken = validateSameFbidAsToken;
-        }
-
-        String getAuthId() {
-            return authId;
-        }
-
-        AuthorizationClient.AuthorizationRequest getAuthorizationClientRequest() {
-            AuthorizationClient.StartActivityDelegate delegate = new AuthorizationClient.StartActivityDelegate() {
-                @Override
-                public void startActivityForResult(Intent intent, int requestCode) {
-                    startActivityDelegate.startActivityForResult(intent, requestCode);
-                }
-
-                @Override
-                public Activity getActivityContext() {
-                    return startActivityDelegate.getActivityContext();
-                }
-            };
-            return new AuthorizationClient.AuthorizationRequest(loginBehavior, requestCode, isLegacy,
-                    permissions, defaultAudience, applicationId, validateSameFbidAsToken, delegate, authId);
-        }
-
-        // package private so subclasses can use it
-        Object writeReplace() {
-            return new AuthRequestSerializationProxyV1(
-                    loginBehavior, requestCode, permissions, defaultAudience.name(), isLegacy, applicationId, validateSameFbidAsToken);
-        }
-
-        // have a readObject that throws to prevent spoofing; must be private so serializer will call it (will be
-        // called automatically prior to any base class)
-        private void readObject(ObjectInputStream stream) throws InvalidObjectException {
-            throw new InvalidObjectException("Cannot readObject, serialization proxy required");
-        }
-
-        private static class AuthRequestSerializationProxyV1 implements Serializable {
-            private static final long serialVersionUID = -8748347685113614927L;
-            private final SessionLoginBehavior loginBehavior;
-            private final int requestCode;
-            private boolean isLegacy;
-            private final List<String> permissions;
-            private final String defaultAudience;
-            private final String applicationId;
-            private final String validateSameFbidAsToken;
-
-            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
-                    int requestCode, List<String> permissions, String defaultAudience, boolean isLegacy,
-                    String applicationId, String validateSameFbidAsToken) {
-                this.loginBehavior = loginBehavior;
-                this.requestCode = requestCode;
-                this.permissions = permissions;
-                this.defaultAudience = defaultAudience;
-                this.isLegacy = isLegacy;
-                this.applicationId = applicationId;
-                this.validateSameFbidAsToken = validateSameFbidAsToken;
-            }
-
-            private Object readResolve() {
-                return new AuthorizationRequest(loginBehavior, requestCode, permissions, defaultAudience, isLegacy,
-                        applicationId, validateSameFbidAsToken);
-            }
-        }
-    }
-
-    /**
-     * A request used to open a Session.
-     */
-    public static final class OpenRequest extends AuthorizationRequest {
-        private static final long serialVersionUID = 1L;
-
-        /**
-         * Constructs an OpenRequest.
-         *
-         * @param activity the Activity to use to open the Session
-         */
-        public OpenRequest(Activity activity) {
-            super(activity);
-        }
-
-        /**
-         * Constructs an OpenRequest.
-         *
-         * @param fragment the Fragment to use to open the Session
-         */
-        public OpenRequest(Fragment fragment) {
-            super(fragment);
-        }
-
-        /**
-         * Sets the StatusCallback for the OpenRequest.
-         *
-         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
-         *                       notify regarding Session state changes.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setCallback(StatusCallback statusCallback) {
-            super.setCallback(statusCallback);
-            return this;
-        }
-
-        /**
-         * Sets the login behavior for the OpenRequest.
-         *
-         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *                      specifies what behaviors should be attempted during
-         *                      authorization.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            super.setLoginBehavior(loginBehavior);
-            return this;
-        }
-
-        /**
-         * Sets the request code for the OpenRequest.
-         *
-         * @param requestCode An integer that identifies this request. This integer will be used
-         *                    as the request code in {@link Activity#onActivityResult
-         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *                    passed in, then a default value will be used.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setRequestCode(int requestCode) {
-            super.setRequestCode(requestCode);
-            return this;
-        }
-
-        /**
-         * Sets the permissions for the OpenRequest.
-         *
-         * @param permissions A List&lt;String&gt; representing the permissions to request
-         *                    during the authentication flow. A null or empty List
-         *                    represents basic permissions.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setPermissions(List<String> permissions) {
-            super.setPermissions(permissions);
-            return this;
-        }
-
-        /**
-         * Sets the permissions for the OpenRequest.
-         *
-         * @param permissions the permissions to request during the authentication flow.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setPermissions(String... permissions) {
-            super.setPermissions(permissions);
-            return this;
-        }
-
-        /**
-         * Sets the defaultAudience for the OpenRequest.
-         * <p/>
-         * This is only used during Native login using a sufficiently recent facebook app.
-         *
-         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
-         * @return the OpenRequest object to allow for chaining
-         */
-        public final OpenRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            super.setDefaultAudience(defaultAudience);
-            return this;
-        }
-    }
-
-    /**
-     * A request to be used to request new permissions for a Session.
-     */
-    public static final class NewPermissionsRequest extends AuthorizationRequest {
-        private static final long serialVersionUID = 1L;
-
-        /**
-         * Constructs a NewPermissionsRequest.
-         *
-         * @param activity    the Activity used to issue the request
-         * @param permissions additional permissions to request
-         */
-        public NewPermissionsRequest(Activity activity, List<String> permissions) {
-            super(activity);
-            setPermissions(permissions);
-        }
-
-        /**
-         * Constructs a NewPermissionsRequest.
-         *
-         * @param fragment    the Fragment used to issue the request
-         * @param permissions additional permissions to request
-         */
-        public NewPermissionsRequest(Fragment fragment, List<String> permissions) {
-            super(fragment);
-            setPermissions(permissions);
-        }
-
-        /**
-         * Constructs a NewPermissionsRequest.
-         *
-         * @param activity    the Activity used to issue the request
-         * @param permissions additional permissions to request
-         */
-        public NewPermissionsRequest(Activity activity, String... permissions) {
-            super(activity);
-            setPermissions(permissions);
-        }
-
-        /**
-         * Constructs a NewPermissionsRequest.
-         *
-         * @param fragment    the Fragment used to issue the request
-         * @param permissions additional permissions to request
-         */
-        public NewPermissionsRequest(Fragment fragment, String... permissions) {
-            super(fragment);
-            setPermissions(permissions);
-        }
-
-        /**
-         * Sets the StatusCallback for the NewPermissionsRequest. Note that once the request is made, this callback
-         * will be added to the session, and will receive all future state changes on the session.
-         *
-         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
-         *                       notify regarding Session state changes.
-         * @return the NewPermissionsRequest object to allow for chaining
-         */
-        public final NewPermissionsRequest setCallback(StatusCallback statusCallback) {
-            super.setCallback(statusCallback);
-            return this;
-        }
-
-        /**
-         * Sets the login behavior for the NewPermissionsRequest.
-         *
-         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *                      specifies what behaviors should be attempted during
-         *                      authorization.
-         * @return the NewPermissionsRequest object to allow for chaining
-         */
-        public final NewPermissionsRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            super.setLoginBehavior(loginBehavior);
-            return this;
-        }
-
-        /**
-         * Sets the request code for the NewPermissionsRequest.
-         *
-         * @param requestCode An integer that identifies this request. This integer will be used
-         *                    as the request code in {@link Activity#onActivityResult
-         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *                    passed in, then a default value will be used.
-         * @return the NewPermissionsRequest object to allow for chaining
-         */
-        public final NewPermissionsRequest setRequestCode(int requestCode) {
-            super.setRequestCode(requestCode);
-            return this;
-        }
-
-        /**
-         * Sets the defaultAudience for the OpenRequest.
-         *
-         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
-         * @return the NewPermissionsRequest object to allow for chaining
-         */
-        public final NewPermissionsRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            super.setDefaultAudience(defaultAudience);
-            return this;
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/SessionDefaultAudience.java b/facebook/src/com/facebook/SessionDefaultAudience.java
deleted file mode 100644
index 2fdac3d01..000000000
--- a/facebook/src/com/facebook/SessionDefaultAudience.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import com.facebook.internal.NativeProtocol;
-
-/**
- * Certain operations such as publishing a status or publishing a photo require an audience. When the user
- * grants an application permission to perform a publish operation, a default audience is selected as the
- * publication ceiling for the application. This enumerated value allows the application to select which
- * audience to ask the user to grant publish permission for.
- */
-public enum SessionDefaultAudience {
-    /**
-     * Represents an invalid default audience value, can be used when only reading.
-     */
-    NONE(null),
-
-    /**
-     * Indicates only the user is able to see posts made by the application.
-     */
-    ONLY_ME(NativeProtocol.AUDIENCE_ME),
-
-    /**
-     * Indicates that the user's friends are able to see posts made by the application.
-     */
-    FRIENDS(NativeProtocol.AUDIENCE_FRIENDS),
-
-    /**
-     * Indicates that all Facebook users are able to see posts made by the application.
-     */
-    EVERYONE(NativeProtocol.AUDIENCE_EVERYONE);
-
-    private final String nativeProtocolAudience;
-
-    private SessionDefaultAudience(String protocol) {
-        nativeProtocolAudience = protocol;
-    }
-
-    String getNativeProtocolAudience() {
-        return nativeProtocolAudience;
-    }
-}
diff --git a/facebook/src/com/facebook/SessionLoginBehavior.java b/facebook/src/com/facebook/SessionLoginBehavior.java
deleted file mode 100644
index 17dd09658..000000000
--- a/facebook/src/com/facebook/SessionLoginBehavior.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-/**
- * Specifies the behaviors to try during
- * {@link Session#openForRead(com.facebook.Session.OpenRequest) openForRead},
- * {@link Session#openForPublish(com.facebook.Session.OpenRequest) openForPublish},
- * {@link Session#requestNewReadPermissions(com.facebook.Session.NewPermissionsRequest) requestNewReadPermissions}, or
- * {@link Session#requestNewPublishPermissions(com.facebook.Session.NewPermissionsRequest) requestNewPublishPermissions}.
- */
-public enum SessionLoginBehavior {
-    /**
-     * Specifies that Session should attempt Single Sign On (SSO), and if that
-     * does not work fall back to dialog auth. This is the default behavior.
-     */
-    SSO_WITH_FALLBACK(true, true),
-
-    /**
-     * Specifies that Session should only attempt SSO. If SSO fails, then the
-     * open or new permissions call fails.
-     */
-    SSO_ONLY(true, false),
-
-    /**
-     * Specifies that SSO should not be attempted, and to only use dialog auth.
-     */
-    SUPPRESS_SSO(false, true);
-
-    private final boolean allowsKatanaAuth;
-    private final boolean allowsWebViewAuth;
-
-    private SessionLoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
-        this.allowsKatanaAuth = allowsKatanaAuth;
-        this.allowsWebViewAuth = allowsWebViewAuth;
-    }
-
-    boolean allowsKatanaAuth() {
-        return allowsKatanaAuth;
-    }
-
-    boolean allowsWebViewAuth() {
-        return allowsWebViewAuth;
-    }
-}
diff --git a/facebook/src/com/facebook/SessionState.java b/facebook/src/com/facebook/SessionState.java
deleted file mode 100644
index 99ac70187..000000000
--- a/facebook/src/com/facebook/SessionState.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-/**
- * <p>
- * Identifies the state of a Session.
- * </p>
- * <p>
- * Session objects implement a state machine that controls their lifecycle. This
- * enum represents the states of the state machine.
- * </p>
- */
-public enum SessionState {
-    /**
-     * Indicates that the Session has not yet been opened and has no cached
-     * token. Opening a Session in this state will involve user interaction.
-     */
-    CREATED(Category.CREATED_CATEGORY),
-
-    /**
-     * <p>
-     * Indicates that the Session has not yet been opened and has a cached
-     * token. Opening a Session in this state will not involve user interaction.
-     * </p>
-     * <p>
-     * If you are using Session from an Android Service, you must provide a
-     * TokenCachingStrategy implementation that contains a valid token to the Session
-     * constructor. The resulting Session will be created in this state, and you
-     * can then safely call open, passing null for the Activity.
-     * </p>
-     */
-    CREATED_TOKEN_LOADED(Category.CREATED_CATEGORY),
-
-    /**
-     * Indicates that the Session is in the process of opening.
-     */
-    OPENING(Category.CREATED_CATEGORY),
-
-    /**
-     * Indicates that the Session is opened. In this state, the Session may be
-     * used with a {@link Request}.
-     */
-    OPENED(Category.OPENED_CATEGORY),
-
-    /**
-     * <p>
-     * Indicates that the Session is opened and that the token has changed. In
-     * this state, the Session may be used with {@link Request}.
-     * </p>
-     * <p>
-     * Every time the token is updated, {@link Session.StatusCallback
-     * StatusCallback} is called with this value.
-     * </p>
-     */
-    OPENED_TOKEN_UPDATED(Category.OPENED_CATEGORY),
-
-    /**
-     * Indicates that the Session is closed, and that it was not closed
-     * normally. Typically this means that the open call failed, and the
-     * Exception parameter to {@link Session.StatusCallback StatusCallback} will
-     * be non-null.
-     */
-    CLOSED_LOGIN_FAILED(Category.CLOSED_CATEGORY),
-
-    /**
-     * Indicates that the Session was closed normally.
-     */
-    CLOSED(Category.CLOSED_CATEGORY);
-
-    private final Category category;
-
-    SessionState(Category category) {
-        this.category = category;
-    }
-
-    /**
-     * Returns a boolean indicating whether the state represents a successfully
-     * opened state in which the Session can be used with a {@link Request}.
-     * 
-     * @return a boolean indicating whether the state represents a successfully
-     *         opened state in which the Session can be used with a
-     *         {@link Request}.
-     */
-    public boolean isOpened() {
-        return this.category == Category.OPENED_CATEGORY;
-    }
-
-    /**
-     * Returns a boolean indicating whether the state represents a closed
-     * Session that can no longer be used with a {@link Request}.
-     * 
-     * @return a boolean indicating whether the state represents a closed
-     * Session that can no longer be used with a {@link Request}.
-     */
-    public boolean isClosed() {
-        return this.category == Category.CLOSED_CATEGORY;
-    }
-
-    private enum Category {
-        CREATED_CATEGORY, OPENED_CATEGORY, CLOSED_CATEGORY
-    }
-}
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
deleted file mode 100644
index fe1ee6558..000000000
--- a/facebook/src/com/facebook/Settings.java
+++ /dev/null
@@ -1,520 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Handler;
-import android.os.Looper;
-import android.util.Log;
-import com.facebook.android.BuildConfig;
-import com.facebook.internal.Utility;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.Validate;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.lang.reflect.Field;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-/**
- * Allows some customization of sdk behavior.
- */
-public final class Settings {
-    private static final String TAG = Settings.class.getCanonicalName();
-    private static final HashSet<LoggingBehavior> loggingBehaviors =
-            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
-    private static volatile Executor executor;
-    private static volatile boolean shouldAutoPublishInstall;
-    private static volatile String appVersion;
-    private static final String FACEBOOK_COM = "facebook.com";
-    private static volatile String facebookDomain = FACEBOOK_COM;
-    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
-
-    private static final int DEFAULT_CORE_POOL_SIZE = 5;
-    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
-    private static final int DEFAULT_KEEP_ALIVE = 1;
-    private static final Object LOCK = new Object();
-
-    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
-            Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
-    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
-
-    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
-    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
-    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
-    private static final String ANALYTICS_EVENT = "event";
-    private static final String AUTO_PUBLISH = "auto_publish";
-
-    private static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";
-
-    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE = new LinkedBlockingQueue<Runnable>(10);
-
-    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
-        private final AtomicInteger counter = new AtomicInteger(0);
-
-        public Thread newThread(Runnable runnable) {
-            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
-        }
-    };
-
-    /**
-     * Certain logging behaviors are available for debugging beyond those that should be
-     * enabled in production.
-     *
-     * Returns the types of extended logging that are currently enabled.
-     *
-     * @return a set containing enabled logging behaviors
-     */
-    public static final Set<LoggingBehavior> getLoggingBehaviors() {
-        synchronized (loggingBehaviors) {
-            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
-        }
-    }
-
-    /**
-     * Certain logging behaviors are available for debugging beyond those that should be
-     * enabled in production.
-     *
-     * Enables a particular extended logging in the sdk.
-     *
-     * @param behavior
-     *          The LoggingBehavior to enable
-     */
-    public static final void addLoggingBehavior(LoggingBehavior behavior) {
-        synchronized (loggingBehaviors) {
-            loggingBehaviors.add(behavior);
-        }
-    }
-
-    /**
-     * Certain logging behaviors are available for debugging beyond those that should be
-     * enabled in production.
-     *
-     * Disables a particular extended logging behavior in the sdk.
-     *
-     * @param behavior
-     *          The LoggingBehavior to disable
-     */
-    public static final void removeLoggingBehavior(LoggingBehavior behavior) {
-        synchronized (loggingBehaviors) {
-            loggingBehaviors.remove(behavior);
-        }
-    }
-
-    /**
-     * Certain logging behaviors are available for debugging beyond those that should be
-     * enabled in production.
-     *
-     * Disables all extended logging behaviors.
-     */
-    public static final void clearLoggingBehaviors() {
-        synchronized (loggingBehaviors) {
-            loggingBehaviors.clear();
-        }
-    }
-
-    /**
-     * Certain logging behaviors are available for debugging beyond those that should be
-     * enabled in production.
-     *
-     * Checks if a particular extended logging behavior is enabled.
-     *
-     * @param behavior
-     *          The LoggingBehavior to check
-     * @return whether behavior is enabled
-     */
-    public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
-        synchronized (loggingBehaviors) {
-            return BuildConfig.DEBUG && loggingBehaviors.contains(behavior);
-        }
-    }
-
-    /**
-     * Returns the Executor used by the SDK for non-AsyncTask background work.
-     *
-     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
-     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
-     *
-     * @return an Executor used by the SDK.  This will never be null.
-     */
-    public static Executor getExecutor() {
-        synchronized (LOCK) {
-            if (Settings.executor == null) {
-                Executor executor = getAsyncTaskExecutor();
-                if (executor == null) {
-                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,
-                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
-                }
-                Settings.executor = executor;
-            }
-        }
-        return Settings.executor;
-    }
-
-    /**
-     * Sets the Executor used by the SDK for non-AsyncTask background work.
-     *
-     * @param executor
-     *          the Executor to use; must not be null.
-     */
-    public static void setExecutor(Executor executor) {
-        Validate.notNull(executor, "executor");
-        synchronized (LOCK) {
-            Settings.executor = executor;
-        }
-    }
-
-    /**
-     * Gets the base Facebook domain to use when making Web requests; in production code this will always be
-     * "facebook.com".
-     *
-     * @return the Facebook domain
-     */
-    public static String getFacebookDomain() {
-        return facebookDomain;
-    }
-
-    /**
-     * Sets the base Facebook domain to use when making Web requests. This defaults to "facebook.com", but may
-     * be overridden to, e.g., "beta.facebook.com" to direct requests at a different domain. This method should
-     * never be called from production code.
-     *
-     * @param facebookDomain the base domain to use instead of "facebook.com"
-     */
-    public static void setFacebookDomain(String facebookDomain) {
-        if (!BuildConfig.DEBUG) {
-            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
-        }
-
-        Settings.facebookDomain = facebookDomain;
-    }
-
-    private static Executor getAsyncTaskExecutor() {
-        Field executorField = null;
-        try {
-            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
-        } catch (NoSuchFieldException e) {
-            return null;
-        }
-
-        Object executorObject = null;
-        try {
-            executorObject = executorField.get(null);
-        } catch (IllegalAccessException e) {
-            return null;
-        }
-
-        if (executorObject == null) {
-            return null;
-        }
-
-        if (!(executorObject instanceof Executor)) {
-            return null;
-        }
-
-        return (Executor) executorObject;
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
-     * multiple installs being published to the graph.
-     * @param context the current Context
-     * @param applicationId the fb application being published.
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static void publishInstallAsync(final Context context, final String applicationId) {
-       publishInstallAsync(context, applicationId, null);
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
-     * multiple installs being published to the graph.
-     * @param context the current Context
-     * @param applicationId the fb application being published.
-     * @param callback a callback to invoke with a Response object, carrying the server response, or an error.
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static void publishInstallAsync(final Context context, final String applicationId,
-        final Request.Callback callback) {
-        // grab the application context ahead of time, since we will return to the caller immediately.
-        final Context applicationContext = context.getApplicationContext();
-        Settings.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                final Response response = Settings.publishInstallAndWaitForResponse(applicationContext, applicationId);
-                if (callback != null) {
-                    // invoke the callback on the main thread.
-                    Handler handler = new Handler(Looper.getMainLooper());
-                    handler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            callback.onCompleted(response);
-                        }
-                    });
-                }
-            }
-        });
-    }
-
-    /**
-     * Sets whether opening a Session should automatically publish install attribution to the Facebook graph.
-     *
-     * @param shouldAutoPublishInstall true to automatically publish, false to not
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static void setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
-        Settings.shouldAutoPublishInstall = shouldAutoPublishInstall;
-    }
-
-    /**
-     * Gets whether opening a Session should automatically publish install attribution to the Facebook graph.
-     *
-     * @return true to automatically publish, false to not
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static boolean getShouldAutoPublishInstall() {
-        return shouldAutoPublishInstall;
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
-     * multiple installs being published to the graph.
-     * @param context the current Context
-     * @param applicationId the fb application being published.
-     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
-     * true is returned.
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static boolean publishInstallAndWait(final Context context, final String applicationId) {
-        Response response = publishInstallAndWaitForResponse(context, applicationId);
-        return response != null && response.getError() == null;
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles caching repeat calls to prevent
-     * multiple installs being published to the graph.
-     * @param context the current Context
-     * @param applicationId the fb application being published.
-     * @return returns a Response object, carrying the server response, or an error.
-     *
-     * This method is deprecated.  See {@link AppEventsLogger#activateApp(Context, String)} for more info.
-     */
-    @Deprecated
-    public static Response publishInstallAndWaitForResponse(final Context context, final String applicationId) {
-        return publishInstallAndWaitForResponse(context, applicationId, false);
-    }
-
-    static Response publishInstallAndWaitForResponse(
-            final Context context,
-            final String applicationId,
-            final boolean isAutoPublish) {
-        try {
-            if (context == null || applicationId == null) {
-                throw new IllegalArgumentException("Both context and applicationId must be non-null");
-            }
-            String attributionId = Settings.getAttributionId(context.getContentResolver());
-            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
-            String pingKey = applicationId+"ping";
-            String jsonKey = applicationId+"json";
-            long lastPing = preferences.getLong(pingKey, 0);
-            String lastResponseJSON = preferences.getString(jsonKey, null);
-
-            // prevent auto publish from occurring if we have an explicit call.
-            if (!isAutoPublish) {
-                setShouldAutoPublishInstall(false);
-            }
-
-            GraphObject publishParams = GraphObject.Factory.create();
-            publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
-
-            Utility.setAppEventAttributionParameters(publishParams,
-                    attributionId,
-                    Utility.getHashedDeviceAndAppID(context, applicationId),
-                    !getLimitEventAndDataUsage(context));
-            publishParams.setProperty(AUTO_PUBLISH, isAutoPublish);
-            publishParams.setProperty("application_package_name", context.getPackageName());
-
-            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
-            Request publishRequest = Request.newPostRequest(null, publishUrl, publishParams, null);
-
-            if (lastPing != 0) {
-                GraphObject graphObject = null;
-                try {
-                    if (lastResponseJSON != null) {
-                        graphObject = GraphObject.Factory.create(new JSONObject(lastResponseJSON));
-                    }
-                }
-                catch (JSONException je) {
-                    // return the default graph object if there is any problem reading the data.
-                }
-                if (graphObject == null) {
-                    return Response.createResponsesFromString("true", null, new RequestBatch(publishRequest), true).get(0);
-                } else {
-                    return new Response(null, null, graphObject, true);
-                }
-            } else if (attributionId == null) {
-                throw new FacebookException("No attribution id returned from the Facebook application");
-            } else {
-
-                if (!Utility.queryAppSettings(applicationId, false).supportsAttribution()) {
-                    throw new FacebookException("Install attribution has been disabled on the server.");
-                }
-
-                Response publishResponse = publishRequest.executeAndWait();
-
-                // denote success since no error threw from the post.
-                SharedPreferences.Editor editor = preferences.edit();
-                lastPing = System.currentTimeMillis();
-                editor.putLong(pingKey, lastPing);
-
-                // if we got an object response back, cache the string of the JSON.
-                if (publishResponse.getGraphObject() != null &&
-                    publishResponse.getGraphObject().getInnerJSONObject() != null) {
-                    editor.putString(jsonKey, publishResponse.getGraphObject().getInnerJSONObject().toString());
-                }
-                editor.commit();
-
-                return publishResponse;
-            }
-        } catch (Exception e) {
-            // if there was an error, fall through to the failure case.
-            Utility.logd("Facebook-publish", e);
-            return new Response(null, null, new FacebookRequestError(null, e));
-        }
-    }
-
-    /**
-     * Acquire the current attribution id from the facebook app.
-     * @return returns null if the facebook app is not present on the phone.
-     */
-    public static String getAttributionId(ContentResolver contentResolver) {
-        try {
-            String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
-            Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
-            if (c == null || !c.moveToFirst()) {
-                return null;
-            }
-            String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
-            c.close();
-            return attributionId;
-        } catch (Exception e) {
-            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
-            return null;
-        }
-    }
-
-    /**
-     * Gets the application version to the provided string.
-     * @return application version set via setAppVersion.
-     */
-    public static String getAppVersion() {
-        return appVersion;
-    }
-
-    /**
-     * Sets the application version to the provided string.  AppEventsLogger.logEvent calls logs its event with the
-     * current app version, and App Insights allows breakdown of events by app version.
-     *
-     * @param appVersion  The version identifier of the Android app that events are being logged through.
-     *                    Enables analysis and breakdown of logged events by app version.
-     */
-    public static void setAppVersion(String appVersion) {
-        Settings.appVersion = appVersion;
-    }
-
-    /**
-     * Gets the current version of the Facebook SDK for Android as a string.
-     *
-     * @return the current version of the SDK
-     */
-    public static String getSdkVersion() {
-        return FacebookSdkVersion.BUILD;
-    }
-
-    /**
-     * Gets the current Facebook migration bundle string; this string can be passed to Graph API
-     * endpoints to specify a set of platform migrations that are explicitly turned on or off for
-     * that call, in order to ensure compatibility between a given version of the SDK and the
-     * Graph API.
-     * @return the migration bundle supported by this version of the SDK
-     */
-    public static String getMigrationBundle() {
-        return FacebookSdkVersion.MIGRATION_BUNDLE;
-    }
-
-    /**
-     * Gets whether data such as that generated through AppEventsLogger and sent to Facebook should be restricted from
-     * being used for purposes other than analytics and conversions, such as for targeting ads to this user.  Defaults
-     * to false.  This value is stored on the device and persists across app launches.
-     *
-     * @param context   Used to read the value.
-     */
-    public static boolean getLimitEventAndDataUsage(Context context) {
-        SharedPreferences preferences = context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
-        return preferences.getBoolean("limitEventUsage", false);
-    }
-
-    /**
-     * Sets whether data such as that generated through AppEventsLogger and sent to Facebook should be restricted from
-     * being used for purposes other than analytics and conversions, such as for targeting ads to this user.  Defaults
-     * to false.  This value is stored on the device and persists across app launches.  Changes to this setting will
-     * apply to app events currently queued to be flushed.
-     *
-     * @param context   Used to persist this value across app runs.
-     */
-    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
-        SharedPreferences preferences = context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
-        SharedPreferences.Editor editor = preferences.edit();
-        editor.putBoolean("limitEventUsage", limitEventUsage);
-        editor.commit();
-    }
-
-    /**
-     * Gets the threshold used to report progress on requests.
-     */
-    public static long getOnProgressThreshold() {
-        return onProgressThreshold.get();
-    }
-
-    /**
-     * Sets the threshold used to report progress on requests. Note that the value will be read when the
-     * request is started and can not be changed during a request (or batch) execution.
-     *
-     * @param threshold The number of bytes progressed to force a callback.
-     */
-    public static void setOnProgressThreshold(long threshold) {
-        onProgressThreshold.set(threshold);
-    }
-}
diff --git a/facebook/src/com/facebook/TestSession.java b/facebook/src/com/facebook/TestSession.java
deleted file mode 100644
index 9133cb91f..000000000
--- a/facebook/src/com/facebook/TestSession.java
+++ /dev/null
@@ -1,516 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.util.Log;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.*;
-
-/**
- * Implements an subclass of Session that knows about test users for a particular
- * application. This should never be used from a real application, but may be useful
- * for writing unit tests, etc.
- * <p/>
- * Facebook allows developers to create test accounts for testing their applications'
- * Facebook integration (see https://developers.facebook.com/docs/test_users/). This class
- * simplifies use of these accounts for writing unit tests. It is not designed for use in
- * production application code.
- * <p/>
- * The main use case for this class is using {@link #createSessionWithPrivateUser(android.app.Activity, java.util.List)}
- * or {@link #createSessionWithSharedUser(android.app.Activity, java.util.List)}
- * to create a session for a test user. Two modes are supported. In "shared" mode, an attempt
- * is made to find an existing test user that has the required permissions. If no such user is available,
- * a new one is created with the required permissions. In "private" mode, designed for
- * scenarios which require a new user in a known clean state, a new test user will always be
- * created, and it will be automatically deleted when the TestSession is closed. The session
- * obeys the same lifecycle as a regular Session, meaning it must be opened after creation before
- * it can be used to make calls to the Facebook API.
- * <p/>
- * Prior to creating a TestSession, two static methods must be called to initialize the
- * application ID and application Secret to be used for managing test users. These methods are
- * {@link #setTestApplicationId(String)} and {@link #setTestApplicationSecret(String)}.
- * <p/>
- * Note that the shared test user functionality depends on a naming convention for the test users.
- * It is important that any testing of functionality which will mutate the permissions for a
- * test user NOT use a shared test user, or this scheme will break down. If a shared test user
- * seems to be in an invalid state, it can be deleted manually via the Web interface at
- * https://developers.facebook.com/apps/APP_ID/permissions?role=test+users.
- */
-public class TestSession extends Session {
-    private static final long serialVersionUID = 1L;
-
-    private enum Mode {
-        PRIVATE, SHARED
-    }
-
-    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "TestSession";
-
-    private static Map<String, TestAccount> appTestAccounts;
-    private static String testApplicationSecret;
-    private static String testApplicationId;
-
-    private final String sessionUniqueUserTag;
-    private final List<String> requestedPermissions;
-    private final Mode mode;
-    private String testAccountId;
-
-    private boolean wasAskedToExtendAccessToken;
-
-    TestSession(Activity activity, List<String> permissions, TokenCachingStrategy tokenCachingStrategy,
-            String sessionUniqueUserTag, Mode mode) {
-        super(activity, TestSession.testApplicationId, tokenCachingStrategy);
-
-        Validate.notNull(permissions, "permissions");
-
-        // Validate these as if they were arguments even though they are statics.
-        Validate.notNullOrEmpty(testApplicationId, "testApplicationId");
-        Validate.notNullOrEmpty(testApplicationSecret, "testApplicationSecret");
-
-        this.sessionUniqueUserTag = sessionUniqueUserTag;
-        this.mode = mode;
-        this.requestedPermissions = permissions;
-    }
-
-    /**
-     * Constructs a TestSession which creates a test user on open, and destroys the user on
-     * close; This method should not be used in application code -- but is useful for creating unit tests
-     * that use the Facebook SDK.
-     *
-     * @param activity    the Activity to use for opening the session
-     * @param permissions list of strings containing permissions to request; nil will result in
-     *                    a common set of permissions (email, publish_actions) being requested
-     * @return a new TestSession that is in the CREATED state, ready to be opened
-     */
-    public static TestSession createSessionWithPrivateUser(Activity activity, List<String> permissions) {
-        return createTestSession(activity, permissions, Mode.PRIVATE, null);
-    }
-
-    /**
-     * Constructs a TestSession which uses a shared test user with the right permissions,
-     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
-     * tests).
-     * <p/>
-     * This method should not be used in application code -- but is useful for creating unit tests
-     * that use the Facebook SDK.
-     *
-     * @param activity    the Activity to use for opening the session
-     * @param permissions list of strings containing permissions to request; nil will result in
-     *                    a common set of permissions (email, publish_actions) being requested
-     * @return a new TestSession that is in the CREATED state, ready to be opened
-     */
-    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions) {
-        return createSessionWithSharedUser(activity, permissions, null);
-    }
-
-    /**
-     * Constructs a TestSession which uses a shared test user with the right permissions,
-     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
-     * tests).
-     * <p/>
-     * This method should not be used in application code -- but is useful for creating unit tests
-     * that use the Facebook SDK.
-     *
-     * @param activity             the Activity to use for opening the session
-     * @param permissions          list of strings containing permissions to request; nil will result in
-     *                             a common set of permissions (email, publish_actions) being requested
-     * @param sessionUniqueUserTag a string which will be used to make this user unique among other
-     *                             users with the same permissions. Useful for tests which require two or more users to interact
-     *                             with each other, and which therefore must have sessions associated with different users.
-     * @return a new TestSession that is in the CREATED state, ready to be opened
-     */
-    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions,
-            String sessionUniqueUserTag) {
-        return createTestSession(activity, permissions, Mode.SHARED, sessionUniqueUserTag);
-    }
-
-    /**
-     * Gets the Facebook Application ID for the application under test.
-     *
-     * @return the application ID
-     */
-    public static synchronized String getTestApplicationId() {
-        return testApplicationId;
-    }
-
-    /**
-     * Sets the Facebook Application ID for the application under test. This must be specified
-     * prior to creating a TestSession.
-     *
-     * @param applicationId the application ID
-     */
-    public static synchronized void setTestApplicationId(String applicationId) {
-        if (testApplicationId != null && !testApplicationId.equals(applicationId)) {
-            throw new FacebookException("Can't have more than one test application ID");
-        }
-        testApplicationId = applicationId;
-    }
-
-    /**
-     * Gets the Facebook Application Secret for the application under test.
-     *
-     * @return the application secret
-     */
-    public static synchronized String getTestApplicationSecret() {
-        return testApplicationSecret;
-    }
-
-    /**
-     * Sets the Facebook Application Secret for the application under test. This must be specified
-     * prior to creating a TestSession.
-     *
-     * @param applicationSecret the application secret
-     */
-    public static synchronized void setTestApplicationSecret(String applicationSecret) {
-        if (testApplicationSecret != null && !testApplicationSecret.equals(applicationSecret)) {
-            throw new FacebookException("Can't have more than one test application secret");
-        }
-        testApplicationSecret = applicationSecret;
-    }
-
-    /**
-     * Gets the ID of the test user that this TestSession is authenticated as.
-     *
-     * @return the Facebook user ID of the test user
-     */
-    public final String getTestUserId() {
-        return testAccountId;
-    }
-
-    private static synchronized TestSession createTestSession(Activity activity, List<String> permissions, Mode mode,
-            String sessionUniqueUserTag) {
-        if (Utility.isNullOrEmpty(testApplicationId) || Utility.isNullOrEmpty(testApplicationSecret)) {
-            throw new FacebookException("Must provide app ID and secret");
-        }
-
-        if (Utility.isNullOrEmpty(permissions)) {
-            permissions = Arrays.asList("email", "publish_actions");
-        }
-
-        return new TestSession(activity, permissions, new TestTokenCachingStrategy(), sessionUniqueUserTag,
-                mode);
-    }
-
-    private static synchronized void retrieveTestAccountsForAppIfNeeded() {
-        if (appTestAccounts != null) {
-            return;
-        }
-
-        appTestAccounts = new HashMap<String, TestAccount>();
-
-        // The data we need is split across two different FQL tables. We construct two queries, submit them
-        // together (the second one refers to the first one), then cross-reference the results.
-
-        // Get the test accounts for this app.
-        String testAccountQuery = String.format("SELECT id,access_token FROM test_account WHERE app_id = %s",
-                testApplicationId);
-        // Get the user names for those accounts.
-        String userQuery = "SELECT uid,name FROM user WHERE uid IN (SELECT id FROM #test_accounts)";
-
-        Bundle parameters = new Bundle();
-
-        // Build a JSON string that contains our queries and pass it as the 'q' parameter of the query.
-        JSONObject multiquery;
-        try {
-            multiquery = new JSONObject();
-            multiquery.put("test_accounts", testAccountQuery);
-            multiquery.put("users", userQuery);
-        } catch (JSONException exception) {
-            throw new FacebookException(exception);
-        }
-        parameters.putString("q", multiquery.toString());
-
-        // We need to authenticate as this app.
-        parameters.putString("access_token", getAppAccessToken());
-
-        Request request = new Request(null, "fql", parameters, null);
-        Response response = request.executeAndWait();
-
-        if (response.getError() != null) {
-            throw response.getError().getException();
-        }
-
-        FqlResponse fqlResponse = response.getGraphObjectAs(FqlResponse.class);
-
-        GraphObjectList<FqlResult> fqlResults = fqlResponse.getData();
-        if (fqlResults == null || fqlResults.size() != 2) {
-            throw new FacebookException("Unexpected number of results from FQL query");
-        }
-
-        // We get back two sets of results. The first is from the test_accounts query, the second from the users query.
-        Collection<TestAccount> testAccounts = fqlResults.get(0).getFqlResultSet().castToListOf(TestAccount.class);
-        Collection<UserAccount> userAccounts = fqlResults.get(1).getFqlResultSet().castToListOf(UserAccount.class);
-
-        // Use both sets of results to populate our static array of accounts.
-        populateTestAccounts(testAccounts, userAccounts);
-
-        return;
-    }
-
-    private static synchronized void populateTestAccounts(Collection<TestAccount> testAccounts,
-            Collection<UserAccount> userAccounts) {
-        // We get different sets of data from each of these queries. We want to combine them into a single data
-        // structure. We have added a Name property to the TestAccount interface, even though we don't really get
-        // a name back from the service from that query. We stick the Name from the corresponding UserAccount in it.
-        for (TestAccount testAccount : testAccounts) {
-            storeTestAccount(testAccount);
-        }
-
-        for (UserAccount userAccount : userAccounts) {
-            TestAccount testAccount = appTestAccounts.get(userAccount.getUid());
-            if (testAccount != null) {
-                testAccount.setName(userAccount.getName());
-            }
-        }
-    }
-
-    private static synchronized void storeTestAccount(TestAccount testAccount) {
-        appTestAccounts.put(testAccount.getId(), testAccount);
-    }
-
-    private static synchronized TestAccount findTestAccountMatchingIdentifier(String identifier) {
-        retrieveTestAccountsForAppIfNeeded();
-
-        for (TestAccount testAccount : appTestAccounts.values()) {
-            if (testAccount.getName().contains(identifier)) {
-                return testAccount;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public final String toString() {
-        String superString = super.toString();
-
-        return new StringBuilder().append("{TestSession").append(" testUserId:").append(testAccountId)
-                .append(" ").append(superString).append("}").toString();
-    }
-
-    @Override
-    void authorize(AuthorizationRequest request) {
-        if (mode == Mode.PRIVATE) {
-            createTestAccountAndFinishAuth();
-        } else {
-            findOrCreateSharedTestAccount();
-        }
-    }
-
-    @Override
-    void postStateChange(final SessionState oldState, final SessionState newState, final Exception error) {
-        // Make sure this doesn't get overwritten.
-        String id = testAccountId;
-
-        super.postStateChange(oldState, newState, error);
-
-        if (newState.isClosed() && id != null && mode == Mode.PRIVATE) {
-            deleteTestAccount(id, getAppAccessToken());
-        }
-    }
-
-    boolean getWasAskedToExtendAccessToken() {
-        return wasAskedToExtendAccessToken;
-    }
-
-    void forceExtendAccessToken(boolean forceExtendAccessToken) {
-        AccessToken currentToken = getTokenInfo();
-        setTokenInfo(
-                new AccessToken(currentToken.getToken(), new Date(), currentToken.getPermissions(),
-                        AccessTokenSource.TEST_USER, new Date(0)));
-        setLastAttemptedTokenExtendDate(new Date(0));
-    }
-
-    @Override
-    boolean shouldExtendAccessToken() {
-        boolean result = super.shouldExtendAccessToken();
-        wasAskedToExtendAccessToken = false;
-        return result;
-    }
-
-    @Override
-    void extendAccessToken() {
-        wasAskedToExtendAccessToken = true;
-        super.extendAccessToken();
-    }
-
-    void fakeTokenRefreshAttempt() {
-        setCurrentTokenRefreshRequest(new TokenRefreshRequest());
-    }
-
-    static final String getAppAccessToken() {
-        return testApplicationId + "|" + testApplicationSecret;
-    }
-
-    private void findOrCreateSharedTestAccount() {
-        TestAccount testAccount = findTestAccountMatchingIdentifier(getSharedTestAccountIdentifier());
-        if (testAccount != null) {
-            finishAuthWithTestAccount(testAccount);
-        } else {
-            createTestAccountAndFinishAuth();
-        }
-    }
-
-    private void finishAuthWithTestAccount(TestAccount testAccount) {
-        testAccountId = testAccount.getId();
-
-        AccessToken accessToken = AccessToken.createFromString(testAccount.getAccessToken(), requestedPermissions,
-                AccessTokenSource.TEST_USER);
-        finishAuthOrReauth(accessToken, null);
-    }
-
-    private TestAccount createTestAccountAndFinishAuth() {
-        Bundle parameters = new Bundle();
-        parameters.putString("installed", "true");
-        parameters.putString("permissions", getPermissionsString());
-        parameters.putString("access_token", getAppAccessToken());
-
-        // If we're in shared mode, we want to rename this user to encode its permissions, so we can find it later
-        // in another shared session. If we're in private mode, don't bother renaming it since we're just going to
-        // delete it at the end of the session.
-        if (mode == Mode.SHARED) {
-            parameters.putString("name", String.format("Shared %s Testuser", getSharedTestAccountIdentifier()));
-        }
-
-        String graphPath = String.format("%s/accounts/test-users", testApplicationId);
-        Request createUserRequest = new Request(null, graphPath, parameters, HttpMethod.POST);
-        Response response = createUserRequest.executeAndWait();
-
-        FacebookRequestError error = response.getError();
-        TestAccount testAccount = response.getGraphObjectAs(TestAccount.class);
-        if (error != null) {
-            finishAuthOrReauth(null, error.getException());
-            return null;
-        } else {
-            assert testAccount != null;
-
-            // If we are in shared mode, store this new account in the dictionary so we can re-use it later.
-            if (mode == Mode.SHARED) {
-                // Remember the new name we gave it, since we didn't get it back in the results of the create request.
-                testAccount.setName(parameters.getString("name"));
-                storeTestAccount(testAccount);
-            }
-
-            finishAuthWithTestAccount(testAccount);
-
-            return testAccount;
-        }
-    }
-
-    private void deleteTestAccount(String testAccountId, String appAccessToken) {
-        Bundle parameters = new Bundle();
-        parameters.putString("access_token", appAccessToken);
-
-        Request request = new Request(null, testAccountId, parameters, HttpMethod.DELETE);
-        Response response = request.executeAndWait();
-
-        FacebookRequestError error = response.getError();
-        GraphObject graphObject = response.getGraphObject();
-        if (error != null) {
-            Log.w(LOG_TAG, String.format("Could not delete test account %s: %s", testAccountId, error.getException().toString()));
-        } else if (graphObject.getProperty(Response.NON_JSON_RESPONSE_PROPERTY) == (Boolean) false) {
-            Log.w(LOG_TAG, String.format("Could not delete test account %s: unknown reason", testAccountId));
-        }
-    }
-
-    private String getPermissionsString() {
-        return TextUtils.join(",", requestedPermissions);
-    }
-
-    private String getSharedTestAccountIdentifier() {
-        // We use long even though hashes are ints to avoid sign issues.
-        long permissionsHash = getPermissionsString().hashCode() & 0xffffffffL;
-        long sessionTagHash = (sessionUniqueUserTag != null) ? sessionUniqueUserTag.hashCode() & 0xffffffffL : 0;
-
-        long combinedHash = permissionsHash ^ sessionTagHash;
-        return validNameStringFromInteger(combinedHash);
-    }
-
-    private String validNameStringFromInteger(long i) {
-        String s = Long.toString(i);
-        StringBuilder result = new StringBuilder("Perm");
-
-        // We know each character is a digit. Convert it into a letter 'a'-'j'. Avoid repeated characters
-        //  that might make Facebook reject the name by converting every other repeated character into one
-        //  10 higher ('k'-'t').
-        char lastChar = 0;
-        for (char c : s.toCharArray()) {
-            if (c == lastChar) {
-                c += 10;
-            }
-            result.append((char) (c + 'a' - '0'));
-            lastChar = c;
-        }
-
-        return result.toString();
-    }
-
-    private interface TestAccount extends GraphObject {
-        String getId();
-
-        String getAccessToken();
-
-        // Note: We don't actually get Name from our FQL query. We fill it in by correlating with UserAccounts.
-        String getName();
-
-        void setName(String name);
-    }
-
-    private interface UserAccount extends GraphObject {
-        String getUid();
-
-        String getName();
-
-        void setName(String name);
-    }
-
-    private interface FqlResult extends GraphObject {
-        GraphObjectList<GraphObject> getFqlResultSet();
-
-    }
-
-    private interface FqlResponse extends GraphObject {
-        GraphObjectList<FqlResult> getData();
-    }
-
-    private static final class TestTokenCachingStrategy extends TokenCachingStrategy {
-        private Bundle bundle;
-
-        @Override
-        public Bundle load() {
-            return bundle;
-        }
-
-        @Override
-        public void save(Bundle value) {
-            bundle = value;
-        }
-
-        @Override
-        public void clear() {
-            bundle = null;
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/TestUserManager.java b/facebook/src/com/facebook/TestUserManager.java
new file mode 100644
index 000000000..4f3cdf729
--- /dev/null
+++ b/facebook/src/com/facebook/TestUserManager.java
@@ -0,0 +1,322 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.facebook.internal.Utility;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This class manages Facebook test users.
+ */
+public class TestUserManager {
+
+    private static final String LOG_TAG = "TestUserManager";
+
+    private enum Mode {
+        PRIVATE,
+        SHARED,
+    }
+
+    private String testApplicationSecret;
+    private String testApplicationId;
+    private Map<String, JSONObject> appTestAccounts;
+
+    /**
+     * Constructor.
+     *
+     * @param testApplicationSecret The application secret.
+     * @param testApplicationId     The application id.
+     */
+    public TestUserManager(String testApplicationSecret, String testApplicationId) {
+        if (Utility.isNullOrEmpty(testApplicationId)
+                || Utility.isNullOrEmpty(testApplicationSecret)) {
+            throw new FacebookException("Must provide app ID and secret");
+        }
+
+        this.testApplicationSecret = testApplicationSecret;
+        this.testApplicationId = testApplicationId;
+    }
+
+    /**
+     * Gets the access token of the private test user for the application with the requested
+     * permissions.
+     *
+     * @param permissions The requested permissions.
+     * @return The access token of the private test user for the application.
+     */
+    public AccessToken getAccessTokenForPrivateUser(List<String> permissions) {
+        return getAccessTokenForUser(permissions, Mode.PRIVATE, null);
+    }
+
+    /**
+     * Gets the access token of the shared test user for the application with the requested
+     * permissions.
+     *
+     * @param permissions The requested permissions.
+     * @return The access token of the shared test user for the application.
+     */
+    public AccessToken getAccessTokenForSharedUser(List<String> permissions) {
+        return getAccessTokenForSharedUser(permissions, null);
+    }
+
+    /**
+     * Gets the access token of the shared test user with the tag for the application with the
+     * requested permissions.
+     *
+     * @param permissions   The requested permissions.
+     * @param uniqueUserTag The user tag.
+     * @return The requested shared user.
+     */
+    public AccessToken getAccessTokenForSharedUser(
+            List<String> permissions,
+            String uniqueUserTag) {
+        return getAccessTokenForUser(permissions, Mode.SHARED, uniqueUserTag);
+    }
+
+    /**
+     * Getter for the test application id.
+     *
+     * @return The test application id.
+     */
+    public synchronized String getTestApplicationId() {
+        return testApplicationId;
+    }
+
+    /**
+     * Getter for the test application secret.
+     *
+     * @return The test application secret.
+     */
+    public synchronized String getTestApplicationSecret() {
+        return testApplicationSecret;
+    }
+
+    private AccessToken getAccessTokenForUser(
+            List<String> permissions,
+            Mode mode,
+            String uniqueUserTag) {
+
+        retrieveTestAccountsForAppIfNeeded();
+
+        if (Utility.isNullOrEmpty(permissions)) {
+            permissions = Arrays.asList("email", "publish_actions");
+        }
+
+        JSONObject testAccount = null;
+        if (mode == Mode.PRIVATE) {
+            testAccount = createTestAccount(permissions, mode, uniqueUserTag);
+        } else {
+            testAccount = findOrCreateSharedTestAccount(permissions, mode, uniqueUserTag);
+        }
+
+        return new AccessToken(
+                testAccount.optString("access_token"),
+                testApplicationId,
+                testAccount.optString("id"),
+                permissions,
+                null,
+                AccessTokenSource.TEST_USER,
+                null,
+                null);
+    }
+
+    private synchronized void retrieveTestAccountsForAppIfNeeded() {
+        if (appTestAccounts != null) {
+            return;
+        }
+
+        appTestAccounts = new HashMap<String, JSONObject>();
+
+        // The data we need is split across two different graph API queries. We construct two
+        // queries, submit them together (the second one depends on the first one), then
+        // cross-reference the results.
+
+        GraphRequest.setDefaultBatchApplicationId(testApplicationId);
+
+        Bundle parameters = new Bundle();
+        parameters.putString("access_token", getAppAccessToken());
+
+        GraphRequest requestTestUsers =
+                new GraphRequest(null, "app/accounts/test-users", parameters, null);
+        requestTestUsers.setBatchEntryName("testUsers");
+        requestTestUsers.setBatchEntryOmitResultOnSuccess(false);
+
+        Bundle testUserNamesParam = new Bundle();
+        testUserNamesParam.putString("access_token", getAppAccessToken());
+        testUserNamesParam.putString("ids", "{result=testUsers:$.data.*.id}");
+        testUserNamesParam.putString("fields", "name");
+
+        GraphRequest requestTestUserNames = new GraphRequest(null, "", testUserNamesParam, null);
+        requestTestUserNames.setBatchEntryDependsOn("testUsers");
+
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestTestUsers,
+                requestTestUserNames);
+        if (responses == null || responses.size() != 2) {
+            throw new FacebookException("Unexpected number of results from TestUsers batch query");
+        }
+
+        JSONObject testAccountsResponse = responses.get(0).getJSONObject();
+        JSONArray testAccounts = testAccountsResponse.optJSONArray("data");
+
+        // Response should contain a map of test accounts: { id's => { user } }
+        JSONObject userAccountsMap = responses.get(1).getJSONObject();
+
+        populateTestAccounts(testAccounts, userAccountsMap);
+    }
+
+    private synchronized void populateTestAccounts(JSONArray testAccounts,
+                                                   JSONObject userAccountsMap) {
+
+        for (int i = 0; i < testAccounts.length(); ++i) {
+            JSONObject testAccount = testAccounts.optJSONObject(i);
+            JSONObject testUser = userAccountsMap.optJSONObject(testAccount.optString("id"));
+            try {
+                testAccount.put("name", testUser.optString("name"));
+            } catch (JSONException e) {
+                Log.e(LOG_TAG, "Could not set name", e);
+            }
+            storeTestAccount(testAccount);
+        }
+    }
+
+    private synchronized void storeTestAccount(JSONObject testAccount) {
+        appTestAccounts.put(testAccount.optString("id"), testAccount);
+    }
+
+    private synchronized JSONObject findTestAccountMatchingIdentifier(String identifier) {
+        for (JSONObject testAccount : appTestAccounts.values()) {
+            if (testAccount.optString("name").contains(identifier)) {
+                return testAccount;
+            }
+        }
+        return null;
+    }
+
+    final String getAppAccessToken() {
+        return testApplicationId + "|" + testApplicationSecret;
+    }
+
+    private JSONObject findOrCreateSharedTestAccount(List<String> permissions, Mode mode,
+                                                     String uniqueUserTag) {
+
+        JSONObject testAccount = findTestAccountMatchingIdentifier(
+                getSharedTestAccountIdentifier(permissions, uniqueUserTag));
+        if (testAccount != null) {
+            return testAccount;
+        } else {
+            return createTestAccount(permissions, mode, uniqueUserTag);
+        }
+    }
+
+    private String getSharedTestAccountIdentifier(List<String> permissions,
+                                                  String uniqueUserTag) {
+
+        // We use long even though hashes are ints to avoid sign issues.
+        long permissionsHash = getPermissionsString(permissions).hashCode() & 0xffffffffL;
+        long userTagHash = (uniqueUserTag != null)
+                ? uniqueUserTag.hashCode() & 0xffffffffL
+                : 0;
+
+        long combinedHash = permissionsHash ^ userTagHash;
+        return validNameStringFromInteger(combinedHash);
+    }
+
+    private String validNameStringFromInteger(long i) {
+        String s = Long.toString(i);
+        StringBuilder result = new StringBuilder("Perm");
+
+        // We know each character is a digit. Convert it into a letter 'a'-'j'. Avoid repeated
+        //  characters that might make Facebook reject the name by converting every other repeated
+        //  character into one 10 higher ('k'-'t').
+        char lastChar = 0;
+        for (char c : s.toCharArray()) {
+            if (c == lastChar) {
+                c += 10;
+            }
+            result.append((char) (c + 'a' - '0'));
+            lastChar = c;
+        }
+
+        return result.toString();
+    }
+
+    private JSONObject createTestAccount(
+            List<String> permissions,
+            Mode mode,
+            String uniqueUserTag) {
+        Bundle parameters = new Bundle();
+        parameters.putString("installed", "true");
+        parameters.putString("permissions", getPermissionsString(permissions));
+        parameters.putString("access_token", getAppAccessToken());
+
+        // If we're in shared mode, we want to rename this user to encode its permissions, so we can
+        // find it later. If we're in private mode, don't bother renaming it since we're just going
+        // to delete it at the end.
+        if (mode == Mode.SHARED) {
+            parameters.putString("name", String.format("Shared %s Testuser",
+                    getSharedTestAccountIdentifier(permissions, uniqueUserTag)));
+        }
+
+        String graphPath = String.format("%s/accounts/test-users", testApplicationId);
+        GraphRequest createUserRequest =
+                new GraphRequest(null, graphPath, parameters, HttpMethod.POST);
+        GraphResponse response = createUserRequest.executeAndWait();
+
+        FacebookRequestError error = response.getError();
+        JSONObject testAccount = response.getJSONObject();
+        if (error != null) {
+            return null;
+        } else {
+            assert testAccount != null;
+
+            // If we are in shared mode, store this new account in the dictionary so we can re-use
+            // it later.
+            if (mode == Mode.SHARED) {
+                // Remember the new name we gave it, since we didn't get it back in the results of
+                // the create request.
+                try {
+                    testAccount.put("name", parameters.getString("name"));
+                } catch (JSONException e) {
+                    Log.e(LOG_TAG, "Could not set name", e);
+                }
+                storeTestAccount(testAccount);
+            }
+
+            return testAccount;
+        }
+    }
+
+    private String getPermissionsString(List<String> permissions) {
+        return TextUtils.join(",", permissions);
+    }
+}
diff --git a/facebook/src/com/facebook/TokenCachingStrategy.java b/facebook/src/com/facebook/TokenCachingStrategy.java
deleted file mode 100644
index 6f18cc3fe..000000000
--- a/facebook/src/com/facebook/TokenCachingStrategy.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-import com.facebook.internal.Validate;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-/**
- * <p>
- * A base class for implementations of a {@link Session Session} token cache.
- * </p>
- * <p>
- * The Session constructor optionally takes a TokenCachingStrategy, from which it will
- * attempt to load a cached token during construction. Also, whenever the
- * Session updates its token, it will also save the token and associated state
- * to the TokenCachingStrategy.
- * </p>
- * <p>
- * This is the only mechanism supported for an Android service to use Session.
- * The service can create a custom TokenCachingStrategy that returns the Session provided
- * by an Activity through which the user logged in to Facebook.
- * </p>
- */
-public abstract class TokenCachingStrategy {
-    /**
-     * The key used by Session to store the token value in the Bundle during
-     * load and save.
-     */
-    public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token";
-
-    /**
-     * The key used by Session to store the expiration date value in the Bundle
-     * during load and save.
-     */
-    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCachingStrategy.ExpirationDate";
-
-    /**
-     * The key used by Session to store the last refresh date value in the
-     * Bundle during load and save.
-     */
-    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCachingStrategy.LastRefreshDate";
-
-    /**
-     * The key used by Session to store the user's id value in the Bundle during
-     * load and save.
-     */
-    public static final String USER_FBID_KEY = "com.facebook.TokenCachingStrategy.UserFBID";
-
-    /**
-     * The key used by Session to store an enum indicating the source of the token
-     * in the Bundle during load and save.
-     */
-    public static final String TOKEN_SOURCE_KEY = "com.facebook.TokenCachingStrategy.AccessTokenSource";
-
-    /**
-     * The key used by Session to store the list of permissions granted by the
-     * token in the Bundle during load and save.
-     */
-    public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions";
-
-    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
-    private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO";
-
-    /**
-     * Called during Session construction to get the token state. Typically this
-     * is loaded from a persistent store that was previously initialized via
-     * save.  The caller may choose to keep a reference to the returned Bundle
-     * indefinitely.  Therefore the TokenCachingStrategy should not store the returned Bundle
-     * and should return a new Bundle on every call to this method.
-     *
-     * @return A Bundle that represents the token state that was loaded.
-     */
-    public abstract Bundle load();
-
-    /**
-     * Called when a Session updates its token. This is passed a Bundle of
-     * values that should be stored durably for the purpose of being returned
-     * from a later call to load.  Some implementations may choose to store
-     * bundle beyond the scope of this call, so the caller should keep no
-     * references to the bundle to ensure that it is not modified later.
-     * 
-     * @param bundle
-     *            A Bundle that represents the token state to be saved.
-     */
-    public abstract void save(Bundle bundle);
-
-    /**
-     * Called when a Session learns its token is no longer valid or during a
-     * call to {@link Session#closeAndClearTokenInformation
-     * closeAndClearTokenInformation} to clear the durable state associated with
-     * the token.
-     */
-    public abstract void clear();
-
-    /**
-     * Returns a boolean indicating whether a Bundle contains properties that
-     * could be a valid saved token.
-     * 
-     * @param bundle
-     *            A Bundle to check for token information.
-     * @return a boolean indicating whether a Bundle contains properties that
-     *         could be a valid saved token.
-     */
-    public static boolean hasTokenInformation(Bundle bundle) {
-        if (bundle == null) {
-            return false;
-        }
-
-        String token = bundle.getString(TOKEN_KEY);
-        if ((token == null) || (token.length() == 0)) {
-            return false;
-        }
-
-        long expiresMilliseconds = bundle.getLong(EXPIRATION_DATE_KEY, 0L);
-        if (expiresMilliseconds == 0L) {
-            return false;
-        }
-
-        return true;
-    }
-
-    /**
-     * Gets the cached token value from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the token value was stored.
-     * @return the cached token value, or null.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static String getToken(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return bundle.getString(TOKEN_KEY);
-    }
-
-    /**
-     * Puts the token value into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the token value should be stored.
-     * @param value
-     *            The String representing the token value, or null.
-     *
-     * @throws NullPointerException if the passed in Bundle or token value are null
-     */
-    public static void putToken(Bundle bundle, String value) {
-        Validate.notNull(bundle, "bundle");
-        Validate.notNull(value, "value");
-        bundle.putString(TOKEN_KEY, value);
-    }
-
-    /**
-     * Gets the cached expiration date from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the expiration date was stored.
-     * @return the cached expiration date, or null.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static Date getExpirationDate(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return getDate(bundle, EXPIRATION_DATE_KEY);
-    }
-
-    /**
-     * Puts the expiration date into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the expiration date should be stored.
-     * @param value
-     *            The Date representing the expiration date.
-     *
-     * @throws NullPointerException if the passed in Bundle or date value are null
-     */
-    public static void putExpirationDate(Bundle bundle, Date value) {
-        Validate.notNull(bundle, "bundle");
-        Validate.notNull(value, "value");
-        putDate(bundle, EXPIRATION_DATE_KEY, value);
-    }
-
-    /**
-     * Gets the cached expiration date from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the expiration date was stored.
-     * @return the long representing the cached expiration date in milliseconds
-     *         since the epoch, or 0.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static long getExpirationMilliseconds(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return bundle.getLong(EXPIRATION_DATE_KEY);
-    }
-
-    /**
-     * Puts the expiration date into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the expiration date should be stored.
-     * @param value
-     *            The long representing the expiration date in milliseconds
-     *            since the epoch.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static void putExpirationMilliseconds(Bundle bundle, long value) {
-        Validate.notNull(bundle, "bundle");
-        bundle.putLong(EXPIRATION_DATE_KEY, value);
-    }
-
-    /**
-     * Gets the cached list of permissions from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the list of permissions was stored.
-     * @return the cached list of permissions.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static List<String> getPermissions(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return bundle.getStringArrayList(PERMISSIONS_KEY);
-    }
-
-    /**
-     * Puts the list of permissions into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the list of permissions should be stored.
-     * @param value
-     *            The List&lt;String&gt; representing the list of permissions,
-     *            or null.
-     *
-     * @throws NullPointerException if the passed in Bundle or permissions list are null
-     */
-    public static void putPermissions(Bundle bundle, List<String> value) {
-        Validate.notNull(bundle, "bundle");
-        Validate.notNull(value, "value");
-
-        ArrayList<String> arrayList;
-        if (value instanceof ArrayList<?>) {
-            arrayList = (ArrayList<String>) value;
-        } else {
-            arrayList = new ArrayList<String>(value);
-        }
-        bundle.putStringArrayList(PERMISSIONS_KEY, arrayList);
-    }
-
-    /**
-     * Gets the cached enum indicating the source of the token from the Bundle.
-     *
-     * @param bundle
-     *            A Bundle in which the enum was stored.
-     * @return enum indicating the source of the token
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static AccessTokenSource getSource(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        if (bundle.containsKey(TokenCachingStrategy.TOKEN_SOURCE_KEY)) {
-            return (AccessTokenSource) bundle.getSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY);
-        } else {
-            boolean isSSO = bundle.getBoolean(TokenCachingStrategy.IS_SSO_KEY);
-            return isSSO ? AccessTokenSource.FACEBOOK_APPLICATION_WEB : AccessTokenSource.WEB_VIEW;
-        }
-    }
-    /**
-     * Puts the enum indicating the source of the token into a Bundle.
-     *
-     * @param bundle
-     *            A Bundle in which the enum should be stored.
-     * @param value
-     *            enum indicating the source of the token
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static void putSource(Bundle bundle, AccessTokenSource value) {
-        Validate.notNull(bundle, "bundle");
-        bundle.putSerializable(TOKEN_SOURCE_KEY, value);
-    }
-
-    /**
-     * Gets the cached last refresh date from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the last refresh date was stored.
-     * @return the cached last refresh Date, or null.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static Date getLastRefreshDate(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return getDate(bundle, LAST_REFRESH_DATE_KEY);
-    }
-
-    /**
-     * Puts the last refresh date into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the last refresh date should be stored.
-     * @param value
-     *            The Date representing the last refresh date, or null.
-     *
-     * @throws NullPointerException if the passed in Bundle or date value are null
-     */
-    public static void putLastRefreshDate(Bundle bundle, Date value) {
-        Validate.notNull(bundle, "bundle");
-        Validate.notNull(value, "value");
-        putDate(bundle, LAST_REFRESH_DATE_KEY, value);
-    }
-
-    /**
-     * Gets the cached last refresh date from a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the last refresh date was stored.
-     * @return the cached last refresh date in milliseconds since the epoch.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static long getLastRefreshMilliseconds(Bundle bundle) {
-        Validate.notNull(bundle, "bundle");
-        return bundle.getLong(LAST_REFRESH_DATE_KEY);
-    }
-
-    /**
-     * Puts the last refresh date into a Bundle.
-     * 
-     * @param bundle
-     *            A Bundle in which the last refresh date should be stored.
-     * @param value
-     *            The long representing the last refresh date in milliseconds
-     *            since the epoch.
-     *
-     * @throws NullPointerException if the passed in Bundle is null
-     */
-    public static void putLastRefreshMilliseconds(Bundle bundle, long value) {
-        Validate.notNull(bundle, "bundle");
-        bundle.putLong(LAST_REFRESH_DATE_KEY, value);
-    }
-
-    static Date getDate(Bundle bundle, String key) {
-        if (bundle == null) {
-            return null;
-        }
-
-        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);
-        if (n == INVALID_BUNDLE_MILLISECONDS) {
-            return null;
-        }
-
-        return new Date(n);
-    }
-
-    static void putDate(Bundle bundle, String key, Date date) {
-        bundle.putLong(key, date.getTime());
-    }
-}
diff --git a/facebook/src/com/facebook/UiLifecycleHelper.java b/facebook/src/com/facebook/UiLifecycleHelper.java
deleted file mode 100644
index d1b74ff66..000000000
--- a/facebook/src/com/facebook/UiLifecycleHelper.java
+++ /dev/null
@@ -1,309 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Bundle;
-import android.support.v4.content.LocalBroadcastManager;
-import android.util.Log;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.widget.FacebookDialog;
-
-import java.util.UUID;
-
-/**
- * This class helps to create, automatically open (if applicable), save, and
- * restore the Active Session in a way that is similar to Android UI lifecycles.
- * <p>
- * When using this class, clients MUST call all the public methods from the
- * respective methods in either an Activity or Fragment. Failure to call all the
- * methods can result in improperly initialized or uninitialized Sessions.
- * <p>
- * This class should also be used by Activities that will be displaying native dialogs
- * provided by the Facebook application, in order to handle processing of the activity
- * results generated by those dialogs.
- */
-public class UiLifecycleHelper {
-    private static final String DIALOG_CALL_BUNDLE_SAVE_KEY =
-            "com.facebook.UiLifecycleHelper.pendingFacebookDialogCallKey";
-
-    private final static String ACTIVITY_NULL_MESSAGE = "activity cannot be null";
-
-    private final Activity activity;
-    private final Session.StatusCallback callback;
-    private final BroadcastReceiver receiver;
-    private final LocalBroadcastManager broadcastManager;
-    // Members related to handling FacebookDialog calls
-    private FacebookDialog.PendingCall pendingFacebookDialogCall;
-    private AppEventsLogger appEventsLogger;
-
-    /**
-     * Creates a new UiLifecycleHelper.
-     *
-     * @param activity the Activity associated with the helper. If calling from a Fragment,
-     *                 use {@link android.support.v4.app.Fragment#getActivity()}
-     * @param callback the callback for Session status changes, can be null
-     */
-    public UiLifecycleHelper(Activity activity, Session.StatusCallback callback) {
-        if (activity == null) {
-            throw new IllegalArgumentException(ACTIVITY_NULL_MESSAGE);
-        }
-        this.activity = activity;
-        this.callback = callback;
-        this.receiver = new ActiveSessionBroadcastReceiver();
-        this.broadcastManager = LocalBroadcastManager.getInstance(activity);
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onCreate method.
-     *
-     * @param savedInstanceState the previously saved state
-     */
-    public void onCreate(Bundle savedInstanceState) {
-        Session session = Session.getActiveSession();
-        if (session == null) {
-            if (savedInstanceState != null) {
-                session = Session.restoreSession(activity, null, callback, savedInstanceState);
-            }
-            if (session == null) {
-                session = new Session(activity);
-            }
-            Session.setActiveSession(session);
-        }
-        if (savedInstanceState != null) {
-            pendingFacebookDialogCall = savedInstanceState.getParcelable(DIALOG_CALL_BUNDLE_SAVE_KEY);
-        }
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onResume method.
-     */
-    public void onResume() {
-        Session session = Session.getActiveSession();
-        if (session != null) {
-            if (callback != null) {
-                session.addCallback(callback);
-            }
-            if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState())) {
-                session.openForRead(null);
-            }
-        }
-
-        // add the broadcast receiver
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-
-        // Add a broadcast receiver to listen to when the active Session
-        // is set or unset, and add/remove our callback as appropriate
-        broadcastManager.registerReceiver(receiver, filter);
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onActivityResult method.
-     *
-     * @param requestCode the request code
-     * @param resultCode the result code
-     * @param data the result data
-     */
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        onActivityResult(requestCode, resultCode, data, null);
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onActivityResult method, when the results of a FacebookDialog
-     * call are expected.
-     *
-     * @param requestCode the request code
-     * @param resultCode the result code
-     * @param data the result data
-     * @param dialogCallback the callback for handling FacebookDialog results, can be null
-     */
-    public void onActivityResult(int requestCode, int resultCode, Intent data,
-                FacebookDialog.Callback facebookDialogCallback) {
-        Session session = Session.getActiveSession();
-        if (session != null) {
-            session.onActivityResult(activity, requestCode, resultCode, data);
-        }
-
-        handleFacebookDialogActivityResult(requestCode, resultCode, data, facebookDialogCallback);
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onSaveInstanceState method.
-     *
-     * @param outState the bundle to save state in
-     */
-    public void onSaveInstanceState(Bundle outState) {
-        Session.saveSession(Session.getActiveSession(), outState);
-        outState.putParcelable(DIALOG_CALL_BUNDLE_SAVE_KEY, pendingFacebookDialogCall);
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onPause method.
-     */
-    public void onPause() {
-        // remove the broadcast receiver
-        broadcastManager.unregisterReceiver(receiver);
-
-        if (callback != null) {
-            Session session = Session.getActiveSession();
-            if (session != null) {
-                session.removeCallback(callback);
-            }
-        }
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onStop method.
-     */
-    public void onStop() {
-        AppEventsLogger.onContextStop();
-    }
-
-    /**
-     * To be called from an Activity or Fragment's onDestroy method.
-     */
-    public void onDestroy() {
-    }
-
-    /**
-     * Register that we are expecting results from a call to the Facebook application (e.g., from a native
-     * dialog provided by the Facebook app). Activity results forwarded to onActivityResults will be parsed
-     * and handled if they correspond to this call. Only a single pending FacebookDialog call can be tracked
-     * at a time; attempting to track another one will cancel the first one.
-     * @param appCall an PendingCall object containing the call ID
-     */
-    public void trackPendingDialogCall(FacebookDialog.PendingCall pendingCall) {
-        if (pendingFacebookDialogCall != null) {
-            // If one is already pending, cancel it; we don't allow multiple pending calls.
-            Log.i("Facebook", "Tracking new app call while one is still pending; canceling pending call.");
-            cancelPendingAppCall(null);
-        }
-        pendingFacebookDialogCall = pendingCall;
-    }
-
-    /**
-     * Retrieves an instance of AppEventsLogger that can be used for the current Session, if any. Different
-     * instances may be returned if the current Session changes, so this value should not be cached for long
-     * periods of time -- always call getAppEventsLogger to get the right logger for the current Session. If
-     * no Session is currently available, this method will return null.
-     *
-     * To ensure delivery of app events across Activity lifecycle events, calling Activities should be sure to
-     * call the onStop method.
-     *
-     * @return an AppEventsLogger to use for logging app events
-     */
-    public AppEventsLogger getAppEventsLogger() {
-        Session session = Session.getActiveSession();
-        if (session == null) {
-            return null;
-        }
-
-        if (appEventsLogger == null || !appEventsLogger.isValidForSession(session)) {
-            if (appEventsLogger != null) {
-                // Pretend we got stopped so the old logger will persist its results now, in case we get stopped
-                // before events get flushed.
-                AppEventsLogger.onContextStop();
-            }
-            appEventsLogger = AppEventsLogger.newLogger(activity, session);
-        }
-
-        return appEventsLogger;
-    }
-
-    /**
-     * The BroadcastReceiver implementation that either adds or removes the callback
-     * from the active Session object as it's SET or UNSET.
-     */
-    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
-                Session session = Session.getActiveSession();
-                if (session != null && callback != null) {
-                    session.addCallback(callback);
-                }
-            } else if (Session.ACTION_ACTIVE_SESSION_UNSET.equals(intent.getAction())) {
-                Session session = Session.getActiveSession();
-                if (session != null && callback != null) {
-                    session.removeCallback(callback);
-                }
-            }
-        }
-    }
-
-    private boolean handleFacebookDialogActivityResult(int requestCode, int resultCode, Intent data,
-            FacebookDialog.Callback facebookDialogCallback) {
-        if (pendingFacebookDialogCall == null || pendingFacebookDialogCall.getRequestCode() != requestCode) {
-            return false;
-        }
-
-        if (data == null) {
-            // We understand the request code, but have no Intent. This can happen if the called Activity crashes
-            // before it can be started; we treat this as a cancellation because we have no other information.
-            cancelPendingAppCall(facebookDialogCallback);
-            return true;
-        }
-
-        String callIdString = data.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID);
-        UUID callId = null;
-        if (callIdString != null) {
-            try {
-                callId = UUID.fromString(callIdString);
-            } catch (IllegalArgumentException exception) {
-            }
-        }
-
-        // Was this result for the call we are waiting on?
-        if (callId != null && pendingFacebookDialogCall.getCallId().equals(callId)) {
-            // Yes, we can handle it normally.
-            FacebookDialog.handleActivityResult(activity, pendingFacebookDialogCall, requestCode, data,
-                    facebookDialogCallback);
-        } else {
-            // No, send a cancellation error to the pending call and ignore the result, because we
-            // don't know what to do with it.
-            cancelPendingAppCall(facebookDialogCallback);
-        }
-
-        pendingFacebookDialogCall = null;
-        return true;
-    }
-
-    private void cancelPendingAppCall(FacebookDialog.Callback facebookDialogCallback) {
-        if (facebookDialogCallback != null) {
-            Intent pendingIntent = pendingFacebookDialogCall.getRequestIntent();
-
-            Intent cancelIntent = new Intent();
-            cancelIntent.putExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID,
-                    pendingIntent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID));
-            cancelIntent.putExtra(NativeProtocol.EXTRA_PROTOCOL_ACTION,
-                    pendingIntent.getStringExtra(NativeProtocol.EXTRA_PROTOCOL_ACTION));
-            cancelIntent.putExtra(NativeProtocol.EXTRA_PROTOCOL_VERSION,
-                    pendingIntent.getIntExtra(NativeProtocol.EXTRA_PROTOCOL_VERSION, 0));
-            cancelIntent.putExtra(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_UNKNOWN_ERROR);
-
-            FacebookDialog.handleActivityResult(activity, pendingFacebookDialogCall,
-                    pendingFacebookDialogCall.getRequestCode(), cancelIntent, facebookDialogCallback);
-        }
-        pendingFacebookDialogCall = null;
-    }
-}
diff --git a/facebook/src/com/facebook/android/AsyncFacebookRunner.java b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
deleted file mode 100644
index 2420fd4b3..000000000
--- a/facebook/src/com/facebook/android/AsyncFacebookRunner.java
+++ /dev/null
@@ -1,341 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.content.Context;
-import android.os.Bundle;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-/**
- * A sample implementation of asynchronous API requests. This class provides
- * the ability to execute API methods and have the call return immediately,
- * without blocking the calling thread. This is necessary when accessing the
- * API in the UI thread, for instance. The request response is returned to 
- * the caller via a callback interface, which the developer must implement.
- *
- * This sample implementation simply spawns a new thread for each request,
- * and makes the API call immediately.  This may work in many applications,
- * but more sophisticated users may re-implement this behavior using a thread
- * pool, a network thread, a request queue, or other mechanism.  Advanced
- * functionality could be built, such as rate-limiting of requests, as per
- * a specific application's needs.
- *
- * @deprecated
- *
- * @see RequestListener
- *        The callback interface.
- *
- * @author  Jim Brusstar (jimbru@fb.com),
- *          Yariv Sadan (yariv@fb.com),
- *          Luke Shepard (lshepard@fb.com)
- */
-@Deprecated
-public class AsyncFacebookRunner {
-
-    Facebook fb;
-
-    public AsyncFacebookRunner(Facebook fb) {
-        this.fb = fb;
-    }
-
-    /**
-     * Invalidate the current user session by removing the access token in
-     * memory, clearing the browser cookies, and calling auth.expireSession
-     * through the API. The application will be notified when logout is
-     * complete via the callback interface.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Session} for more info.
-     *
-     * @param context
-     *            The Android context in which the logout should be called: it
-     *            should be the same context in which the login occurred in
-     *            order to clear any stored cookies
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void logout(final Context context,
-                       final RequestListener listener,
-                       final Object state) {
-        new Thread() {
-            @Override public void run() {
-                try {
-                    String response = fb.logoutImpl(context);
-                    if (response.length() == 0 || response.equals("false")){
-                        listener.onFacebookError(new FacebookError(
-                                "auth.expireSession failed"), state);
-                        return;
-                    }
-                    listener.onComplete(response, state);
-                } catch (FileNotFoundException e) {
-                    listener.onFileNotFoundException(e, state);
-                } catch (MalformedURLException e) {
-                    listener.onMalformedURLException(e, state);
-                } catch (IOException e) {
-                    listener.onIOException(e, state);
-                }
-            }
-        }.start();
-    }
-
-    @Deprecated
-    public void logout(final Context context, final RequestListener listener) {
-        logout(context, listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to Facebook's old (pre-graph) API with the given
-     * parameters. One of the parameter keys must be "method" and its value
-     * should be a valid REST server API method.
-     * <p/>
-     * See http://developers.facebook.com/docs/reference/rest/
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * Example:
-     * <code>
-     *  Bundle parameters = new Bundle();
-     *  parameters.putString("method", "auth.expireSession", new Listener());
-     *  String response = request(parameters);
-     * </code>
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param parameters
-     *            Key-value pairs of parameters to the request. Refer to the
-     *            documentation: one of the parameters must be "method".
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(Bundle parameters,
-                        RequestListener listener,
-                        final Object state) {
-        request(null, parameters, "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(Bundle parameters, RequestListener listener) {
-        request(null, parameters, "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API without any parameters.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(String graphPath,
-                        RequestListener listener,
-                        final Object state) {
-        request(graphPath, new Bundle(), "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(String graphPath, RequestListener listener) {
-        request(graphPath, new Bundle(), "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given string parameters
-     * using an HTTP GET (default method).
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters "q" : "facebook" would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(String graphPath,
-                        Bundle parameters,
-                        RequestListener listener,
-                        final Object state) {
-        request(graphPath, parameters, "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(String graphPath,
-                        Bundle parameters,
-                        RequestListener listener) {
-        request(graphPath, parameters, "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given HTTP method and
-     * string parameters. Note that binary data parameters (e.g. pictures) are
-     * not yet supported by this helper function.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters {"q" : "facebook"} would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param httpMethod
-     *            http verb, e.g. "POST", "DELETE"
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(final String graphPath,
-                        final Bundle parameters,
-                        final String httpMethod,
-                        final RequestListener listener,
-                        final Object state) {
-        new Thread() {
-            @Override public void run() {
-                try {
-                    String resp = fb.requestImpl(graphPath, parameters, httpMethod);
-                    listener.onComplete(resp, state);
-                } catch (FileNotFoundException e) {
-                    listener.onFileNotFoundException(e, state);
-                } catch (MalformedURLException e) {
-                    listener.onMalformedURLException(e, state);
-                } catch (IOException e) {
-                    listener.onIOException(e, state);
-                }
-            }
-        }.start();
-    }
-
-    /**
-     * Callback interface for API requests.
-     * <p/>
-     * Each method includes a 'state' parameter that identifies the calling
-     * request. It will be set to the value passed when originally calling the
-     * request method, or null if none was passed.
-     * <p/>
-     * This interface is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     */
-    @Deprecated
-    public static interface RequestListener {
-
-        /**
-         * Called when a request completes with the given response.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onComplete(String response, Object state);
-
-        /**
-         * Called when a request has a network or request error.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onIOException(IOException e, Object state);
-
-        /**
-         * Called when a request fails because the requested resource is
-         * invalid or does not exist.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onFileNotFoundException(FileNotFoundException e,
-                                            Object state);
-
-        /**
-         * Called if an invalid graph path is provided (which may result in a
-         * malformed URL).
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onMalformedURLException(MalformedURLException e,
-                                            Object state);
-
-        /**
-         * Called when the server-side Facebook method fails.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onFacebookError(FacebookError e, Object state);
-
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/DialogError.java b/facebook/src/com/facebook/android/DialogError.java
deleted file mode 100644
index a99c4e613..000000000
--- a/facebook/src/com/facebook/android/DialogError.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-/**
- * Encapsulation of Dialog Error.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.FacebookException}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class DialogError extends Throwable {
-
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * The ErrorCode received by the WebView: see
-     * http://developer.android.com/reference/android/webkit/WebViewClient.html
-     */
-    private int mErrorCode;
-
-    /** The URL that the dialog was trying to load */
-    private String mFailingUrl;
-
-    @Deprecated
-    public DialogError(String message, int errorCode, String failingUrl) {
-        super(message);
-        mErrorCode = errorCode;
-        mFailingUrl = failingUrl;
-    }
-
-    @Deprecated
-    public int getErrorCode() {
-        return mErrorCode;
-    }
-
-    @Deprecated
-    public String getFailingUrl() {
-        return mFailingUrl;
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/Facebook.java b/facebook/src/com/facebook/android/Facebook.java
deleted file mode 100644
index 83cdabe9b..000000000
--- a/facebook/src/com/facebook/android/Facebook.java
+++ /dev/null
@@ -1,1356 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.*;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.content.pm.ResolveInfo;
-import android.content.pm.Signature;
-import android.net.Uri;
-import android.os.*;
-import com.facebook.*;
-import com.facebook.Session.StatusCallback;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.net.MalformedURLException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link Session} to manage session state,
- * {@link Request} to make API requests, and
- * {@link com.facebook.widget.WebDialog} to make dialog requests.
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class Facebook {
-
-    // Strings used in the authorization flow
-    @Deprecated
-    public static final String REDIRECT_URI = "fbconnect://success";
-    @Deprecated
-    public static final String CANCEL_URI = "fbconnect://cancel";
-    @Deprecated
-    public static final String TOKEN = "access_token";
-    @Deprecated
-    public static final String EXPIRES = "expires_in";
-    @Deprecated
-    public static final String SINGLE_SIGN_ON_DISABLED = "service_disabled";
-
-    @Deprecated
-    public static final Uri ATTRIBUTION_ID_CONTENT_URI =
-        Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
-    @Deprecated
-    public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
-
-    @Deprecated
-    public static final int FORCE_DIALOG_AUTH = -1;
-
-    private static final String LOGIN = "oauth";
-
-    // Used as default activityCode by authorize(). See authorize() below.
-    private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665;
-
-    // Facebook server endpoints: may be modified in a subclass for testing
-    @Deprecated
-    protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/";
-    @Deprecated
-    protected static String GRAPH_BASE_URL = "https://graph.facebook.com/";
-    @Deprecated
-    protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php";
-
-    private final Object lock = new Object();
-
-    private String accessToken = null;
-    private long accessExpiresMillisecondsAfterEpoch = 0;
-    private long lastAccessUpdateMillisecondsAfterEpoch = 0;
-    private String mAppId;
-
-    private Activity pendingAuthorizationActivity;
-    private String[] pendingAuthorizationPermissions;
-    private Session pendingOpeningSession;
-
-    private volatile Session session; // must synchronize this.sync to write
-    private boolean sessionInvalidated; // must synchronize this.sync to access
-    private SetterTokenCachingStrategy tokenCache;
-    private volatile Session userSetSession;
-
-    // If the last time we extended the access token was more than 24 hours ago
-    // we try to refresh the access token again.
-    final private static long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L;
-
-    /**
-     * Constructor for Facebook object.
-     * 
-     * @param appId
-     *            Your Facebook application ID. Found at
-     *            www.facebook.com/developers/apps.php.
-     */
-    @Deprecated
-    public Facebook(String appId) {
-        if (appId == null) {
-            throw new IllegalArgumentException("You must specify your application ID when instantiating "
-                    + "a Facebook object. See README for details.");
-        }
-        mAppId = appId;
-    }
-
-    /**
-     * Default authorize method. Grants only basic permissions.
-     * <p/>
-     * See authorize() below for @params.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorize(Activity activity, final DialogListener listener) {
-        authorize(activity, new String[]{}, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                listener);
-    }
-
-    /**
-     * Authorize method that grants custom permissions.
-     * <p/>
-     * See authorize() below for @params.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorize(Activity activity, String[] permissions, final DialogListener listener) {
-        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK, listener);
-    }
-
-    /**
-     * Full authorize method.
-     * <p/>
-     * Starts either an Activity or a dialog which prompts the user to log in to
-     * Facebook and grant the requested permissions to the given application.
-     * <p/>
-     * This method will, when possible, use Facebook's single sign-on for
-     * Android to obtain an access token. This involves proxying a call through
-     * the Facebook for Android stand-alone application, which will handle the
-     * authentication flow, and return an OAuth access token for making API
-     * calls.
-     * <p/>
-     * Because this process will not be available for all users, if single
-     * sign-on is not possible, this method will automatically fall back to the
-     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
-     * by Facebook in an embedded WebView, not by the client application. As
-     * such, the dialog makes a network request and renders HTML content rather
-     * than a native UI. The access token is retrieved from a redirect to a
-     * special URL that the WebView handles.
-     * <p/>
-     * Note that User credentials could be handled natively using the OAuth 2.0
-     * Username and Password Flow, but this is not supported by this SDK.
-     * <p/>
-     * See http://developers.facebook.com/docs/authentication/ and
-     * http://wiki.oauth.net/OAuth-2 for more details.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     * <p/>
-     * Also note that requests may be made to the API without calling authorize
-     * first, in which case only public information is returned.
-     * <p/>
-     * IMPORTANT: Note that single sign-on authentication will not function
-     * correctly if you do not include a call to the authorizeCallback() method
-     * in your onActivityResult() function! Please see below for more
-     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
-     * as the activityCode parameter in your call to authorize().
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param activity
-     *            The Android activity in which we want to display the
-     *            authorization dialog.
-     * @param permissions
-     *            A list of permissions required for this application: e.g.
-     *            "read_stream", "publish_stream", "offline_access", etc. see
-     *            http://developers.facebook.com/docs/authentication/permissions
-     *            This parameter should not be null -- if you do not require any
-     *            permissions, then pass in an empty String array.
-     * @param activityCode
-     *            Single sign-on requires an activity result to be called back
-     *            to the client application -- if you are waiting on other
-     *            activities to return data, pass a custom activity code here to
-     *            avoid collisions. If you would like to force the use of legacy
-     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
-     *            parameter. Otherwise just omit this parameter and Facebook
-     *            will use a suitable default. See
-     *            http://developer.android.com/reference/android/
-     *            app/Activity.html for more information.
-     * @param listener
-     *            Callback interface for notifying the calling application when
-     *            the authentication dialog has completed, failed, or been
-     *            canceled.
-     */
-    @Deprecated
-    public void authorize(Activity activity, String[] permissions, int activityCode, final DialogListener listener) {
-        SessionLoginBehavior behavior = (activityCode >= 0) ? SessionLoginBehavior.SSO_WITH_FALLBACK
-                : SessionLoginBehavior.SUPPRESS_SSO;
-
-        authorize(activity, permissions, activityCode, behavior, listener);
-    }
-
-    /**
-     * Full authorize method.
-     * 
-     * Starts either an Activity or a dialog which prompts the user to log in to
-     * Facebook and grant the requested permissions to the given application.
-     * 
-     * This method will, when possible, use Facebook's single sign-on for
-     * Android to obtain an access token. This involves proxying a call through
-     * the Facebook for Android stand-alone application, which will handle the
-     * authentication flow, and return an OAuth access token for making API
-     * calls.
-     * 
-     * Because this process will not be available for all users, if single
-     * sign-on is not possible, this method will automatically fall back to the
-     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
-     * by Facebook in an embedded WebView, not by the client application. As
-     * such, the dialog makes a network request and renders HTML content rather
-     * than a native UI. The access token is retrieved from a redirect to a
-     * special URL that the WebView handles.
-     * 
-     * Note that User credentials could be handled natively using the OAuth 2.0
-     * Username and Password Flow, but this is not supported by this SDK.
-     * 
-     * See http://developers.facebook.com/docs/authentication/ and
-     * http://wiki.oauth.net/OAuth-2 for more details.
-     * 
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     * 
-     * Also note that requests may be made to the API without calling authorize
-     * first, in which case only public information is returned.
-     * 
-     * IMPORTANT: Note that single sign-on authentication will not function
-     * correctly if you do not include a call to the authorizeCallback() method
-     * in your onActivityResult() function! Please see below for more
-     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
-     * as the activityCode parameter in your call to authorize().
-     * 
-     * @param activity
-     *            The Android activity in which we want to display the
-     *            authorization dialog.
-     * @param permissions
-     *            A list of permissions required for this application: e.g.
-     *            "read_stream", "publish_stream", "offline_access", etc. see
-     *            http://developers.facebook.com/docs/authentication/permissions
-     *            This parameter should not be null -- if you do not require any
-     *            permissions, then pass in an empty String array.
-     * @param activityCode
-     *            Single sign-on requires an activity result to be called back
-     *            to the client application -- if you are waiting on other
-     *            activities to return data, pass a custom activity code here to
-     *            avoid collisions. If you would like to force the use of legacy
-     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
-     *            parameter. Otherwise just omit this parameter and Facebook
-     *            will use a suitable default. See
-     *            http://developer.android.com/reference/android/
-     *            app/Activity.html for more information.
-     * @param behavior
-     *            The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *            specifies what behaviors should be attempted during
-     *            authorization.
-     * @param listener
-     *            Callback interface for notifying the calling application when
-     *            the authentication dialog has completed, failed, or been
-     *            canceled.
-     */
-    private void authorize(Activity activity, String[] permissions, int activityCode,
-                          SessionLoginBehavior behavior, final DialogListener listener) {
-        checkUserSession("authorize");
-        pendingOpeningSession = new Session.Builder(activity).
-                setApplicationId(mAppId).
-                setTokenCachingStrategy(getTokenCache()).
-                build();
-        pendingAuthorizationActivity = activity;
-        pendingAuthorizationPermissions = (permissions != null) ? permissions : new String[0];
-
-        StatusCallback callback = new StatusCallback() {
-            @Override
-            public void call(Session callbackSession, SessionState state, Exception exception) {
-                // Invoke user-callback.
-                onSessionCallback(callbackSession, state, exception, listener);
-            }
-        };
-
-        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
-                setCallback(callback).
-                setLoginBehavior(behavior).
-                setRequestCode(activityCode).
-                setPermissions(Arrays.asList(pendingAuthorizationPermissions));
-        openSession(pendingOpeningSession, openRequest, pendingAuthorizationPermissions.length > 0);
-    }
-
-    private void openSession(Session session, Session.OpenRequest openRequest, boolean isPublish) {
-        openRequest.setIsLegacy(true);
-        if (isPublish) {
-            session.openForPublish(openRequest);
-        } else {
-            session.openForRead(openRequest);
-        }
-    }
-
-    @SuppressWarnings("deprecation")
-    private void onSessionCallback(Session callbackSession, SessionState state, Exception exception,
-            DialogListener listener) {
-        Bundle extras = callbackSession.getAuthorizationBundle();
-
-        if (state == SessionState.OPENED) {
-            Session sessionToClose = null;
-
-            synchronized (Facebook.this.lock) {
-                if (callbackSession != Facebook.this.session) {
-                    sessionToClose = Facebook.this.session;
-                    Facebook.this.session = callbackSession;
-                    Facebook.this.sessionInvalidated = false;
-                }
-            }
-
-            if (sessionToClose != null) {
-                sessionToClose.close();
-            }
-
-            listener.onComplete(extras);
-        } else if (exception != null) {
-            if (exception instanceof FacebookOperationCanceledException) {
-                listener.onCancel();
-            } else if ((exception instanceof FacebookAuthorizationException) && (extras != null)
-                    && extras.containsKey(Session.WEB_VIEW_ERROR_CODE_KEY)
-                    && extras.containsKey(Session.WEB_VIEW_FAILING_URL_KEY)) {
-                DialogError error = new DialogError(exception.getMessage(),
-                        extras.getInt(Session.WEB_VIEW_ERROR_CODE_KEY),
-                        extras.getString(Session.WEB_VIEW_FAILING_URL_KEY));
-                listener.onError(error);
-            } else {
-                FacebookError error = new FacebookError(exception.getMessage());
-                listener.onFacebookError(error);
-            }
-        }
-    }
-
-    /**
-     * Helper to validate a service intent by resolving and checking the
-     * provider's package signature.
-     * 
-     * @param context
-     * @param intent
-     * @return true if the service intent resolution happens successfully and
-     *         the signatures match.
-     */
-    private boolean validateServiceIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
-        if (resolveInfo == null) {
-            return false;
-        }
-
-        return validateAppSignatureForPackage(context, resolveInfo.serviceInfo.packageName);
-    }
-
-    /**
-     * Query the signature for the application that would be invoked by the
-     * given intent and verify that it matches the FB application's signature.
-     * 
-     * @param context
-     * @param packageName
-     * @return true if the app's signature matches the expected signature.
-     */
-    private boolean validateAppSignatureForPackage(Context context, String packageName) {
-
-        PackageInfo packageInfo;
-        try {
-            packageInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
-        } catch (NameNotFoundException e) {
-            return false;
-        }
-
-        for (Signature signature : packageInfo.signatures) {
-            if (signature.toCharsString().equals(FB_APP_SIGNATURE)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * IMPORTANT: If you are using the deprecated authorize() method,
-     * this method must be invoked at the top of the calling
-     * activity's onActivityResult() function or Facebook authentication will
-     * not function properly!
-     * <p/>
-     * If your calling activity does not currently implement onActivityResult(),
-     * you must implement it and include a call to this method if you intend to
-     * use the authorize() method in this SDK.
-     * <p/>
-     * For more information, see
-     * http://developer.android.com/reference/android/app/
-     * Activity.html#onActivityResult(int, int, android.content.Intent)
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorizeCallback(int requestCode, int resultCode, Intent data) {
-        checkUserSession("authorizeCallback");
-        Session pending = this.pendingOpeningSession;
-        if (pending != null) {
-            if (pending.onActivityResult(this.pendingAuthorizationActivity, requestCode, resultCode, data)) {
-                this.pendingOpeningSession = null;
-                this.pendingAuthorizationActivity = null;
-                this.pendingAuthorizationPermissions = null;
-            }
-        }
-    }
-
-    /**
-     * Refresh OAuth access token method. Binds to Facebook for Android
-     * stand-alone application application to refresh the access token. This
-     * method tries to connect to the Facebook App which will handle the
-     * authentication flow, and return a new OAuth access token. This method
-     * will automatically replace the old token with a new one. Note that this
-     * method is asynchronous and the callback will be invoked in the original
-     * calling thread (not in a background thread).
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param context
-     *            The Android Context that will be used to bind to the Facebook
-     *            RefreshToken Service
-     * @param serviceListener
-     *            Callback interface for notifying the calling application when
-     *            the refresh request has completed or failed (can be null). In
-     *            case of a success a new token can be found inside the result
-     *            Bundle under Facebook.ACCESS_TOKEN key.
-     * @return true if the binding to the RefreshToken Service was created
-     */
-    @Deprecated
-    public boolean extendAccessToken(Context context, ServiceListener serviceListener) {
-        checkUserSession("extendAccessToken");
-        Intent intent = new Intent();
-
-        intent.setClassName("com.facebook.katana", "com.facebook.katana.platform.TokenRefreshService");
-
-        // Verify that the application whose package name is
-        // com.facebook.katana
-        // has the expected FB app signature.
-        if (!validateServiceIntent(context, intent)) {
-            return false;
-        }
-
-        return context.bindService(intent, new TokenRefreshServiceConnection(context, serviceListener),
-                Context.BIND_AUTO_CREATE);
-    }
-
-    /**
-     * Calls extendAccessToken if shouldExtendAccessToken returns true.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return the same value as extendAccessToken if the the token requires
-     *         refreshing, true otherwise
-     */
-    @Deprecated
-    public boolean extendAccessTokenIfNeeded(Context context, ServiceListener serviceListener) {
-        checkUserSession("extendAccessTokenIfNeeded");
-        if (shouldExtendAccessToken()) {
-            return extendAccessToken(context, serviceListener);
-        }
-        return true;
-    }
-
-    /**
-     * Check if the access token requires refreshing.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return true if the last time a new token was obtained was over 24 hours
-     *         ago.
-     */
-    @Deprecated
-    public boolean shouldExtendAccessToken() {
-        checkUserSession("shouldExtendAccessToken");
-        return isSessionValid()
-                && (System.currentTimeMillis() - lastAccessUpdateMillisecondsAfterEpoch >= REFRESH_TOKEN_BARRIER);
-    }
-
-    /**
-     * Handles connection to the token refresh service (this service is a part
-     * of Facebook App).
-     */
-    private class TokenRefreshServiceConnection implements ServiceConnection {
-
-        final Messenger messageReceiver = new Messenger(
-                new TokenRefreshConnectionHandler(Facebook.this, this));
-
-        final ServiceListener serviceListener;
-        final Context applicationsContext;
-
-        Messenger messageSender = null;
-
-        public TokenRefreshServiceConnection(Context applicationsContext, ServiceListener serviceListener) {
-            this.applicationsContext = applicationsContext;
-            this.serviceListener = serviceListener;
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            messageSender = new Messenger(service);
-            refreshToken();
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName arg) {
-            serviceListener.onError(new Error("Service disconnected"));
-            // We returned an error so there's no point in
-            // keeping the binding open.
-            applicationsContext.unbindService(TokenRefreshServiceConnection.this);
-        }
-
-        private void refreshToken() {
-            Bundle requestData = new Bundle();
-            requestData.putString(TOKEN, accessToken);
-
-            Message request = Message.obtain();
-            request.setData(requestData);
-            request.replyTo = messageReceiver;
-
-            try {
-                messageSender.send(request);
-            } catch (RemoteException e) {
-                serviceListener.onError(new Error("Service connection error"));
-            }
-        }
-    }
-
-    // Creating a static Handler class to reduce the possibility of a memory leak.
-    // Handler objects for the same thread all share a common Looper object, which they post messages
-    // to and read from. As messages contain target Handler, as long as there are messages with target
-    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
-    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
-    private static class TokenRefreshConnectionHandler extends Handler {
-        WeakReference<Facebook> facebookWeakReference;
-        WeakReference<TokenRefreshServiceConnection> connectionWeakReference;
-
-        TokenRefreshConnectionHandler(Facebook facebook, TokenRefreshServiceConnection connection) {
-            super();
-            facebookWeakReference = new WeakReference<Facebook>(facebook);
-            connectionWeakReference = new WeakReference<TokenRefreshServiceConnection>(connection);
-        }
-
-        @Override
-        @SuppressWarnings("deprecation")
-        public void handleMessage(Message msg) {
-            Facebook facebook = facebookWeakReference.get();
-            TokenRefreshServiceConnection connection = connectionWeakReference.get();
-            if (facebook == null || connection == null) {
-                return;
-            }
-
-            String token = msg.getData().getString(TOKEN);
-            // Legacy functions in Facebook class (and ServiceListener implementors) expect expires_in in
-            // milliseconds from epoch
-            long expiresAtMsecFromEpoch = msg.getData().getLong(EXPIRES) * 1000L;
-
-            if (token != null) {
-                facebook.setAccessToken(token);
-                facebook.setAccessExpires(expiresAtMsecFromEpoch);
-
-                Session refreshSession = facebook.session;
-                if (refreshSession != null) {
-                    // Session.internalRefreshToken expects the original bundle with expires_in in seconds from
-                    // epoch.
-                    LegacyHelper.extendTokenCompleted(refreshSession, msg.getData());
-                }
-
-                if (connection.serviceListener != null) {
-                    // To avoid confusion we should return the expiration time in
-                    // the same format as the getAccessExpires() function - that
-                    // is in milliseconds.
-                    Bundle resultBundle = (Bundle) msg.getData().clone();
-                    resultBundle.putLong(EXPIRES, expiresAtMsecFromEpoch);
-
-                    connection.serviceListener.onComplete(resultBundle);
-                }
-            } else if (connection.serviceListener != null) { // extract errors only if
-                // client wants them
-                String error = msg.getData().getString("error");
-                if (msg.getData().containsKey("error_code")) {
-                    int errorCode = msg.getData().getInt("error_code");
-                    connection.serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
-                } else {
-                    connection.serviceListener.onError(new Error(error != null ? error : "Unknown service error"));
-                }
-            }
-
-            // The refreshToken function should be called rarely,
-            // so there is no point in keeping the binding open.
-            connection.applicationsContext.unbindService(connection);
-        }
-    }
-
-    /**
-     * Invalidate the current user session by removing the access token in
-     * memory, clearing the browser cookie, and calling auth.expireSession
-     * through the API.
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param context
-     *            The Android context in which the logout should be called: it
-     *            should be the same context in which the login occurred in
-     *            order to clear any stored cookies
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the auth.expireSession response
-     *         ("true" if successful)
-     */
-    @Deprecated
-    public String logout(Context context) throws MalformedURLException, IOException {
-        return logoutImpl(context);
-    }
-
-    String logoutImpl(Context context) throws MalformedURLException, IOException  {
-        checkUserSession("logout");
-        Bundle b = new Bundle();
-        b.putString("method", "auth.expireSession");
-        String response = request(b);
-
-        long currentTimeMillis = System.currentTimeMillis();
-        Session sessionToClose = null;
-
-        synchronized (this.lock) {
-            sessionToClose = session;
-
-            session = null;
-            accessToken = null;
-            accessExpiresMillisecondsAfterEpoch = 0;
-            lastAccessUpdateMillisecondsAfterEpoch = currentTimeMillis;
-            sessionInvalidated = false;
-        }
-
-        if (sessionToClose != null) {
-            sessionToClose.closeAndClearTokenInformation();
-        }
-
-        return response;
-    }
-
-    /**
-     * Make a request to Facebook's old (pre-graph) API with the given
-     * parameters. One of the parameter keys must be "method" and its value
-     * should be a valid REST server API method.
-     * <p/>
-     * See http://developers.facebook.com/docs/reference/rest/
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * Example: <code>
-     *  Bundle parameters = new Bundle();
-     *  parameters.putString("method", "auth.expireSession");
-     *  String response = request(parameters);
-     * </code>
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param parameters
-     *            Key-value pairs of parameters to the request. Refer to the
-     *            documentation: one of the parameters must be "method".
-     * @throws IOException
-     *             if a network error occurs
-     * @throws MalformedURLException
-     *             if accessing an invalid endpoint
-     * @throws IllegalArgumentException
-     *             if one of the parameters is not "method"
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(Bundle parameters) throws MalformedURLException, IOException {
-        if (!parameters.containsKey("method")) {
-            throw new IllegalArgumentException("API method must be specified. "
-                    + "(parameters must contain key \"method\" and value). See"
-                    + " http://developers.facebook.com/docs/reference/rest/");
-        }
-        return requestImpl(null, parameters, "GET");
-    }
-
-    /**
-     * Make a request to the Facebook Graph API without any parameters.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath) throws MalformedURLException, IOException {
-        return requestImpl(graphPath, new Bundle(), "GET");
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given string parameters
-     * using an HTTP GET (default method).
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters "q" : "facebook" would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath, Bundle parameters) throws MalformedURLException, IOException {
-        return requestImpl(graphPath, parameters, "GET");
-    }
-
-    /**
-     * Synchronously make a request to the Facebook Graph API with the given
-     * HTTP method and string parameters. Note that binary data parameters (e.g.
-     * pictures) are not yet supported by this helper function.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param params
-     *            Key-value string parameters, e.g. the path "search" with
-     *            parameters {"q" : "facebook"} would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param httpMethod
-     *            http verb, e.g. "GET", "POST", "DELETE"
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
-            MalformedURLException, IOException {
-        return requestImpl(graphPath, params, httpMethod);
-    }
-
-    // Internal call to avoid deprecated warnings.
-    @SuppressWarnings("deprecation")
-    String requestImpl(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
-            MalformedURLException, IOException {
-        params.putString("format", "json");
-        if (isSessionValid()) {
-            params.putString(TOKEN, getAccessToken());
-        }
-        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath : RESTSERVER_URL;
-        return Util.openUrl(url, httpMethod, params);
-    }
-
-    /**
-     * Generate a UI dialog for the request action in the given Android context.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     *
-     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
-     *
-     * @param context
-     *            The Android context in which we will generate this dialog.
-     * @param action
-     *            String representation of the desired method: e.g. "login",
-     *            "stream.publish", ...
-     * @param listener
-     *            Callback interface to notify the application when the dialog
-     *            has completed.
-     */
-    @Deprecated
-    public void dialog(Context context, String action, DialogListener listener) {
-        dialog(context, action, new Bundle(), listener);
-    }
-
-    /**
-     * Generate a UI dialog for the request action in the given Android context
-     * with the provided parameters.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     *
-     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
-     * 
-     * @param context
-     *            The Android context in which we will generate this dialog.
-     * @param action
-     *            String representation of the desired method: e.g. "feed" ...
-     * @param parameters
-     *            String key-value pairs to be passed as URL parameters.
-     * @param listener
-     *            Callback interface to notify the application when the dialog
-     *            has completed.
-     */
-    @Deprecated
-    public void dialog(Context context, String action, Bundle parameters, final DialogListener listener) {
-        parameters.putString("display", "touch");
-        parameters.putString("redirect_uri", REDIRECT_URI);
-
-        if (action.equals(LOGIN)) {
-            parameters.putString("type", "user_agent");
-            parameters.putString("client_id", mAppId);
-        } else {
-            parameters.putString("app_id", mAppId);
-            // We do not want to add an access token when displaying the auth dialog.
-            if (isSessionValid()) {
-                parameters.putString(TOKEN, getAccessToken());
-            }
-        }
-
-        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
-            Util.showAlert(context, "Error", "Application requires permission to access the Internet");
-        } else {
-            new FbDialog(context, action, parameters, listener).show();
-        }
-    }
-
-    /**
-     * Returns whether the current access token is valid
-     *
-     * @return boolean - whether this object has an non-expired session token
-     */
-    @Deprecated
-    public boolean isSessionValid() {
-        return (getAccessToken() != null)
-                && ((getAccessExpires() == 0) || (System.currentTimeMillis() < getAccessExpires()));
-    }
-
-    /**
-     * Allows the user to set a Session for the Facebook class to use.
-     * If a Session is set here, then one should not use the authorize, logout,
-     * or extendAccessToken methods which alter the Session object since that may
-     * result in undefined behavior. Using those methods after setting the
-     * session here will result in exceptions being thrown.
-     *
-     * @param session the Session object to use, cannot be null
-     */
-    @Deprecated
-    public void setSession(Session session) {
-        if (session == null) {
-            throw new IllegalArgumentException("session cannot be null");
-        }
-        synchronized (this.lock) {
-            this.userSetSession = session;
-        }
-    }
-
-    private void checkUserSession(String methodName) {
-        if (userSetSession != null) {
-            throw new UnsupportedOperationException(
-                    String.format("Cannot call %s after setSession has been called.", methodName));
-        }
-    }
-
-    /**
-     * Get the underlying Session object to use with 3.0 api.
-     * 
-     * @return Session - underlying session
-     */
-    @Deprecated
-    public final Session getSession() {
-        while (true) {
-            String cachedToken = null;
-            Session oldSession = null;
-
-            synchronized (this.lock) {
-                if (userSetSession != null) {
-                    return userSetSession;
-                }
-                if ((session != null) || !sessionInvalidated) {
-                    return session;
-                }
-
-                cachedToken = accessToken;
-                oldSession = session;
-            }
-
-            if (cachedToken == null) {
-                return null;
-            }
-
-            // At this point we do not have a valid session, but mAccessToken is
-            // non-null.
-            // So we can try building a session based on that.
-            List<String> permissions;
-            if (oldSession != null) {
-                permissions = oldSession.getPermissions();
-            } else if (pendingAuthorizationPermissions != null) {
-                permissions = Arrays.asList(pendingAuthorizationPermissions);
-            } else {
-                permissions = Collections.<String>emptyList();
-            }
-
-            Session newSession = new Session.Builder(pendingAuthorizationActivity).
-                    setApplicationId(mAppId).
-                    setTokenCachingStrategy(getTokenCache()).
-                    build();
-            if (newSession.getState() != SessionState.CREATED_TOKEN_LOADED) {
-                return null;
-            }
-            Session.OpenRequest openRequest =
-                    new Session.OpenRequest(pendingAuthorizationActivity).setPermissions(permissions);
-            openSession(newSession, openRequest, !permissions.isEmpty());
-
-            Session invalidatedSession = null;
-            Session returnSession = null;
-
-            synchronized (this.lock) {
-                if (sessionInvalidated || (session == null)) {
-                    invalidatedSession = session;
-                    returnSession = session = newSession;
-                    sessionInvalidated = false;
-                }
-            }
-
-            if (invalidatedSession != null) {
-                invalidatedSession.close();
-            }
-
-            if (returnSession != null) {
-                return returnSession;
-            }
-            // Else token state changed between the synchronized blocks, so
-            // retry..
-        }
-    }
-
-    /**
-     * Retrieve the OAuth 2.0 access token for API access: treat with care.
-     * Returns null if no session exists.
-     *
-     * @return String - access token
-     */
-    @Deprecated
-    public String getAccessToken() {
-        Session s = getSession();
-        if (s != null) {
-            return s.getAccessToken();
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Retrieve the current session's expiration time (in milliseconds since
-     * Unix epoch), or 0 if the session doesn't expire or doesn't exist.
-     *
-     * @return long - session expiration time
-     */
-    @Deprecated
-    public long getAccessExpires() {
-        Session s = getSession();
-        if (s != null) {
-            return s.getExpirationDate().getTime();
-        } else {
-            return accessExpiresMillisecondsAfterEpoch;
-        }
-    }
-
-    /**
-     * Retrieve the last time the token was updated (in milliseconds since
-     * the Unix epoch), or 0 if the token has not been set.
-     *
-     * @return long - timestamp of the last token update.
-     */
-    @Deprecated
-    public long getLastAccessUpdate() {
-        return lastAccessUpdateMillisecondsAfterEpoch;
-    }
-
-    /**
-     * Restore the token, expiration time, and last update time from cached values.
-     * These should be values obtained from getAccessToken(), getAccessExpires, and
-     * getLastAccessUpdate() respectively.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param accessToken - access token
-     * @param accessExpires - access token expiration time
-     * @param lastAccessUpdate - timestamp of the last token update
-     */
-    @Deprecated
-    public void setTokenFromCache(String accessToken, long accessExpires, long lastAccessUpdate) {
-        checkUserSession("setTokenFromCache");
-        synchronized (this.lock) {
-            this.accessToken = accessToken;
-            accessExpiresMillisecondsAfterEpoch = accessExpires;
-            lastAccessUpdateMillisecondsAfterEpoch = lastAccessUpdate;
-        }
-    }
-
-    /**
-     * Set the OAuth 2.0 access token for API access.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param token
-     *            - access token
-     */
-    @Deprecated
-    public void setAccessToken(String token) {
-        checkUserSession("setAccessToken");
-        synchronized (this.lock) {
-            accessToken = token;
-            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
-            sessionInvalidated = true;
-        }
-    }
-
-    /**
-     * Set the current session's expiration time (in milliseconds since Unix
-     * epoch), or 0 if the session doesn't expire.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param timestampInMsec
-     *            - timestamp in milliseconds
-     */
-    @Deprecated
-    public void setAccessExpires(long timestampInMsec) {
-        checkUserSession("setAccessExpires");
-        synchronized (this.lock) {
-            accessExpiresMillisecondsAfterEpoch = timestampInMsec;
-            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
-            sessionInvalidated = true;
-        }
-    }
-
-    /**
-     * Set the current session's duration (in seconds since Unix epoch), or "0"
-     * if session doesn't expire.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param expiresInSecsFromNow
-     *            - duration in seconds (or 0 if the session doesn't expire)
-     */
-    @Deprecated
-    public void setAccessExpiresIn(String expiresInSecsFromNow) {
-        checkUserSession("setAccessExpiresIn");
-        if (expiresInSecsFromNow != null) {
-            long expires = expiresInSecsFromNow.equals("0") ? 0 : System.currentTimeMillis()
-                    + Long.parseLong(expiresInSecsFromNow) * 1000L;
-            setAccessExpires(expires);
-        }
-    }
-
-    /**
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return the String representing application ID
-     */
-    @Deprecated
-    public String getAppId() {
-        return mAppId;
-    }
-
-    /**
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param appId the String representing the application ID
-     */
-    @Deprecated
-    public void setAppId(String appId) {
-        checkUserSession("setAppId");
-        synchronized (this.lock) {
-            mAppId = appId;
-            sessionInvalidated = true;
-        }
-    }
-
-    private TokenCachingStrategy getTokenCache() {
-        // Intentionally not volatile/synchronized--it is okay if we race to
-        // create more than one of these.
-        if (tokenCache == null) {
-            tokenCache = new SetterTokenCachingStrategy();
-        }
-        return tokenCache;
-    }
-
-    private static String[] stringArray(List<String> list) {
-        int size = (list != null) ? list.size() : 0;
-        String[] array = new String[size];
-
-        if (list != null) {
-            for (int i = 0; i < array.length; i++) {
-                array[i] = list.get(i);
-            }
-        }
-
-        return array;
-    }
-
-    private static List<String> stringList(String[] array) {
-        if (array != null) {
-            return Arrays.asList(array);
-        } else {
-            return Collections.emptyList();
-        }
-    }
-
-    private class SetterTokenCachingStrategy extends TokenCachingStrategy {
-
-        @Override
-        public Bundle load() {
-            Bundle bundle = new Bundle();
-
-            if (accessToken != null) {
-                TokenCachingStrategy.putToken(bundle, accessToken);
-                TokenCachingStrategy.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
-                TokenCachingStrategy.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
-                TokenCachingStrategy.putSource(bundle, AccessTokenSource.WEB_VIEW);
-                TokenCachingStrategy.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
-            }
-
-            return bundle;
-        }
-
-        @Override
-        public void save(Bundle bundle) {
-            accessToken = TokenCachingStrategy.getToken(bundle);
-            accessExpiresMillisecondsAfterEpoch = TokenCachingStrategy.getExpirationMilliseconds(bundle);
-            pendingAuthorizationPermissions = stringArray(TokenCachingStrategy.getPermissions(bundle));
-            lastAccessUpdateMillisecondsAfterEpoch = TokenCachingStrategy.getLastRefreshMilliseconds(bundle);
-        }
-
-        @Override
-        public void clear() {
-            accessToken = null;
-        }
-    }
-
-    /**
-     * Get Attribution ID for app install conversion tracking.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param contentResolver
-     * @return Attribution ID that will be used for conversion tracking. It will be null only if
-     *         the user has not installed or logged in to the Facebook app.
-     */
-    @Deprecated
-    public static String getAttributionId(ContentResolver contentResolver) {
-        return Settings.getAttributionId(contentResolver);
-    }
-
-    /**
-     * Get the auto install publish setting.  If true, an install event will be published during authorize(), unless
-     * it has occurred previously or the app does not have install attribution enabled on the application's developer
-     * config page.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @return a Boolean indicating whether installation of the app should be auto-published.
-     */
-    @Deprecated
-    public boolean getShouldAutoPublishInstall() {
-        return Settings.getShouldAutoPublishInstall();
-    }
-
-    /**
-     * Sets whether auto publishing of installs will occur.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param value a Boolean indicating whether installation of the app should be auto-published.
-     */
-    @Deprecated
-    public void setShouldAutoPublishInstall(boolean value) {
-        Settings.setShouldAutoPublishInstall(value);
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
-     * multiple installs being published to the graph.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param context the current Android context
-     * @return Always false.  Earlier versions of the API returned true if it was no longer necessary to call.
-     * Apps should ignore this value, but for compatibility we will return false to ensure repeat calls (and the
-     * underlying code will prevent duplicate network traffic).
-     */
-    @Deprecated
-    public boolean publishInstall(final Context context) {
-        Settings.publishInstallAsync(context, mAppId);
-        return false;
-    }
-
-    /**
-     * Callback interface for dialog requests.
-     * <p/>
-     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
-     * <p/>
-     * All public members of this class are intentionally deprecated.
-     * New code should instead use
-     * {@link com.facebook.widget.WebDialog}
-     * <p/>
-     * Adding @Deprecated to this class causes warnings in other deprecated classes
-     * that reference this one.  That is the only reason this entire class is not
-     * deprecated.
-     *
-     * @devDocDeprecated
-     */
-    public static interface DialogListener {
-
-        /**
-         * Called when a dialog completes.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         * @param values
-         *            Key-value string pairs extracted from the response.
-         */
-        public void onComplete(Bundle values);
-
-        /**
-         * Called when a Facebook responds to a dialog with an error.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onFacebookError(FacebookError e);
-
-        /**
-         * Called when a dialog has an error.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onError(DialogError e);
-
-        /**
-         * Called when a dialog is canceled by the user.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onCancel();
-
-    }
-
-    /**
-     * Callback interface for service requests.
-     * <p/>
-     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
-     * <p/>
-     * All public members of this class are intentionally deprecated.
-     * New code should instead use
-     * {@link Session} to manage session state.
-     * <p/>
-     * Adding @Deprecated to this class causes warnings in other deprecated classes
-     * that reference this one.  That is the only reason this entire class is not
-     * deprecated.
-     *
-     * @devDocDeprecated
-     */
-    public static interface ServiceListener {
-
-        /**
-         * Called when a service request completes.
-         * 
-         * @param values
-         *            Key-value string pairs extracted from the response.
-         */
-        public void onComplete(Bundle values);
-
-        /**
-         * Called when a Facebook server responds to the request with an error.
-         */
-        public void onFacebookError(FacebookError e);
-
-        /**
-         * Called when a Facebook Service responds to the request with an error.
-         */
-        public void onError(Error e);
-
-    }
-
-    @Deprecated
-    public static final String FB_APP_SIGNATURE =
-        "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
-        + "b3009060355040613025553310b30090603550408130243413112301006035504"
-        + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
-        + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
-        + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
-        + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
-        + "55040613025553310b30090603550408130243413112301006035504071309506"
-        + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
-        + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
-        + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
-        + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
-        + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
-        + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
-        + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
-        + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
-        + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
-        + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
-        + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
-        + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
-        + "928a2";
-
-}
diff --git a/facebook/src/com/facebook/android/FacebookError.java b/facebook/src/com/facebook/android/FacebookError.java
deleted file mode 100644
index 41ae794fc..000000000
--- a/facebook/src/com/facebook/android/FacebookError.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-/**
- * Encapsulation of a Facebook Error: a Facebook request that could not be
- * fulfilled.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.FacebookException}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class FacebookError extends RuntimeException {
-
-    private static final long serialVersionUID = 1L;
-
-    private int mErrorCode = 0;
-    private String mErrorType;
-
-    @Deprecated
-    public FacebookError(String message) {
-        super(message);
-    }
-
-    @Deprecated
-    public FacebookError(String message, String type, int code) {
-        super(message);
-        mErrorType = type;
-        mErrorCode = code;
-    }
-
-    @Deprecated
-    public int getErrorCode() {
-        return mErrorCode;
-    }
-
-    @Deprecated
-    public String getErrorType() {
-        return mErrorType;
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/FbDialog.java b/facebook/src/com/facebook/android/FbDialog.java
deleted file mode 100644
index 603e69280..000000000
--- a/facebook/src/com/facebook/android/FbDialog.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.content.Context;
-import android.os.Bundle;
-import com.facebook.*;
-import com.facebook.android.Facebook.DialogListener;
-import com.facebook.widget.WebDialog;
-
-/**
- * This class is deprecated. See {@link com.facebook.widget.WebDialog}.
- */
-@Deprecated
-public class FbDialog extends WebDialog {
-    private DialogListener mListener;
-
-    public FbDialog(Context context, String url, DialogListener listener) {
-        this(context, url, listener, DEFAULT_THEME);
-    }
-
-    public FbDialog(Context context, String url, DialogListener listener, int theme) {
-        super(context, url, theme);
-        setDialogListener(listener);
-    }
-
-    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener) {
-        super(context, action, parameters, DEFAULT_THEME, null);
-        setDialogListener(listener);
-    }
-
-    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener,
-            int theme) {
-        super(context, action, parameters, theme, null);
-        setDialogListener(listener);
-    }
-
-    private void setDialogListener(DialogListener listener) {
-        this.mListener = listener;
-        setOnCompleteListener(new OnCompleteListener() {
-            @Override
-            public void onComplete(Bundle values, FacebookException error) {
-                callDialogListener(values, error);
-            }
-        });
-    }
-
-    private void callDialogListener(Bundle values, FacebookException error) {
-        if (mListener == null) {
-            return;
-        }
-
-        if (values != null) {
-            mListener.onComplete(values);
-        } else {
-            if (error instanceof FacebookDialogException) {
-                FacebookDialogException facebookDialogException = (FacebookDialogException) error;
-                DialogError dialogError = new DialogError(facebookDialogException.getMessage(),
-                        facebookDialogException.getErrorCode(), facebookDialogException.getFailingUrl());
-                mListener.onError(dialogError);
-            } else if (error instanceof FacebookOperationCanceledException) {
-                mListener.onCancel();
-            } else {
-                FacebookError facebookError = new FacebookError(error.getMessage());
-                mListener.onFacebookError(facebookError);
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/android/Util.java b/facebook/src/com/facebook/android/Util.java
deleted file mode 100644
index 4ece878df..000000000
--- a/facebook/src/com/facebook/android/Util.java
+++ /dev/null
@@ -1,314 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.app.AlertDialog.Builder;
-import android.content.Context;
-import android.os.Bundle;
-import com.facebook.internal.Utility;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.*;
-import java.net.*;
-
-/**
- * Utility class supporting the Facebook Object.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.Request}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public final class Util {
-
-    private final static String UTF8 = "UTF-8";
-
-    /**
-     * Generate the multi-part post body providing the parameters and boundary
-     * string
-     * 
-     * @param parameters the parameters need to be posted
-     * @param boundary the random string as boundary
-     * @return a string of the post body
-     */
-    @Deprecated
-    public static String encodePostBody(Bundle parameters, String boundary) {
-        if (parameters == null) return "";
-        StringBuilder sb = new StringBuilder();
-
-        for (String key : parameters.keySet()) {
-            Object parameter = parameters.get(key);
-            if (!(parameter instanceof String)) {
-                continue;
-            }
-
-            sb.append("Content-Disposition: form-data; name=\"" + key +
-                    "\"\r\n\r\n" + (String)parameter);
-            sb.append("\r\n" + "--" + boundary + "\r\n");
-        }
-
-        return sb.toString();
-    }
-
-    @Deprecated
-    public static String encodeUrl(Bundle parameters) {
-        if (parameters == null) {
-            return "";
-        }
-
-        StringBuilder sb = new StringBuilder();
-        boolean first = true;
-        for (String key : parameters.keySet()) {
-            Object parameter = parameters.get(key);
-            if (!(parameter instanceof String)) {
-                continue;
-            }
-
-            if (first) first = false; else sb.append("&");
-            sb.append(URLEncoder.encode(key) + "=" +
-                      URLEncoder.encode(parameters.getString(key)));
-        }
-        return sb.toString();
-    }
-
-    @Deprecated
-    public static Bundle decodeUrl(String s) {
-        Bundle params = new Bundle();
-        if (s != null) {
-            String array[] = s.split("&");
-            for (String parameter : array) {
-                String v[] = parameter.split("=");
-
-                try {
-                    if (v.length == 2) {
-                        params.putString(URLDecoder.decode(v[0], UTF8),
-                                         URLDecoder.decode(v[1], UTF8));
-                    } else if (v.length == 1) {
-                        params.putString(URLDecoder.decode(v[0], UTF8), "");
-                    }
-                } catch (UnsupportedEncodingException e) {
-                    // shouldn't happen
-                }
-            }
-        }
-        return params;
-    }
-
-    /**
-     * Parse a URL query and fragment parameters into a key-value bundle.
-     *
-     * @param url the URL to parse
-     * @return a dictionary bundle of keys and values
-     */
-    @Deprecated
-    public static Bundle parseUrl(String url) {
-        // hack to prevent MalformedURLException
-        url = url.replace("fbconnect", "http");
-        try {
-            URL u = new URL(url);
-            Bundle b = decodeUrl(u.getQuery());
-            b.putAll(decodeUrl(u.getRef()));
-            return b;
-        } catch (MalformedURLException e) {
-            return new Bundle();
-        }
-    }
-
-    
-    /**
-     * Connect to an HTTP URL and return the response as a string.
-     *
-     * Note that the HTTP method override is used on non-GET requests. (i.e.
-     * requests are made as "POST" with method specified in the body).
-     *
-     * @param url - the resource to open: must be a welformed URL
-     * @param method - the HTTP method to use ("GET", "POST", etc.)
-     * @param params - the query parameter for the URL (e.g. access_token=foo)
-     * @return the URL contents as a String
-     * @throws MalformedURLException - if the URL format is invalid
-     * @throws IOException - if a network problem occurs
-     */
-    @Deprecated
-    public static String openUrl(String url, String method, Bundle params)
-          throws MalformedURLException, IOException {
-        // random string as boundary for multi-part http post
-        String strBoundary = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
-        String endLine = "\r\n";
-
-        OutputStream os;
-
-        if (method.equals("GET")) {
-            url = url + "?" + encodeUrl(params);
-        }
-        Utility.logd("Facebook-Util", method + " URL: " + url);
-        HttpURLConnection conn =
-            (HttpURLConnection) new URL(url).openConnection();
-        conn.setRequestProperty("User-Agent", System.getProperties().
-                getProperty("http.agent") + " FacebookAndroidSDK");
-        if (!method.equals("GET")) {
-            Bundle dataparams = new Bundle();
-            for (String key : params.keySet()) {
-                Object parameter = params.get(key);
-                if (parameter instanceof byte[]) {
-                    dataparams.putByteArray(key, (byte[])parameter);
-                }
-            }
-
-            // use method override
-            if (!params.containsKey("method")) {
-                params.putString("method", method);
-            }
-
-            if (params.containsKey("access_token")) {
-                String decoded_token =
-                    URLDecoder.decode(params.getString("access_token"));
-                params.putString("access_token", decoded_token);
-            }
-
-            conn.setRequestMethod("POST");
-            conn.setRequestProperty(
-                    "Content-Type",
-                    "multipart/form-data;boundary="+strBoundary);
-            conn.setDoOutput(true);
-            conn.setDoInput(true);
-            conn.setRequestProperty("Connection", "Keep-Alive");
-            conn.connect();
-
-            os = new BufferedOutputStream(conn.getOutputStream());
-
-            try {
-                os.write(("--" + strBoundary +endLine).getBytes());
-                os.write((encodePostBody(params, strBoundary)).getBytes());
-                os.write((endLine + "--" + strBoundary + endLine).getBytes());
-
-                if (!dataparams.isEmpty()) {
-
-                    for (String key: dataparams.keySet()){
-                        os.write(("Content-Disposition: form-data; filename=\"" + key + "\"" + endLine).getBytes());
-                        os.write(("Content-Type: content/unknown" + endLine + endLine).getBytes());
-                        os.write(dataparams.getByteArray(key));
-                        os.write((endLine + "--" + strBoundary + endLine).getBytes());
-
-                    }
-                }
-                os.flush();
-            } finally {
-                os.close();
-            }
-        }
-
-        String response = "";
-        try {
-            response = read(conn.getInputStream());
-        } catch (FileNotFoundException e) {
-            // Error Stream contains JSON that we can parse to a FB error
-            response = read(conn.getErrorStream());
-        }
-        return response;
-    }
-
-    @Deprecated
-    private static String read(InputStream in) throws IOException {
-        StringBuilder sb = new StringBuilder();
-        BufferedReader r = new BufferedReader(new InputStreamReader(in), 1000);
-        for (String line = r.readLine(); line != null; line = r.readLine()) {
-            sb.append(line);
-        }
-        in.close();
-        return sb.toString();
-    }
-
-    /**
-     * Parse a server response into a JSON Object. This is a basic
-     * implementation using org.json.JSONObject representation. More
-     * sophisticated applications may wish to do their own parsing.
-     *
-     * The parsed JSON is checked for a variety of error fields and
-     * a FacebookException is thrown if an error condition is set,
-     * populated with the error message and error type or code if
-     * available.
-     *
-     * @param response - string representation of the response
-     * @return the response as a JSON Object
-     * @throws JSONException - if the response is not valid JSON
-     * @throws FacebookError - if an error condition is set
-     */
-    @Deprecated
-    public static JSONObject parseJson(String response)
-          throws JSONException, FacebookError {
-        // Edge case: when sending a POST request to /[post_id]/likes
-        // the return value is 'true' or 'false'. Unfortunately
-        // these values cause the JSONObject constructor to throw
-        // an exception.
-        if (response.equals("false")) {
-            throw new FacebookError("request failed");
-        }
-        if (response.equals("true")) {
-            response = "{value : true}";
-        }
-        JSONObject json = new JSONObject(response);
-
-        // errors set by the server are not consistent
-        // they depend on the method and endpoint
-        if (json.has("error")) {
-            JSONObject error = json.getJSONObject("error");
-            throw new FacebookError(
-                    error.getString("message"), error.getString("type"), 0);
-        }
-        if (json.has("error_code") && json.has("error_msg")) {
-            throw new FacebookError(json.getString("error_msg"), "",
-                    Integer.parseInt(json.getString("error_code")));
-        }
-        if (json.has("error_code")) {
-            throw new FacebookError("request failed", "",
-                    Integer.parseInt(json.getString("error_code")));
-        }
-        if (json.has("error_msg")) {
-            throw new FacebookError(json.getString("error_msg"));
-        }
-        if (json.has("error_reason")) {
-            throw new FacebookError(json.getString("error_reason"));
-        }
-        return json;
-    }
-
-    /**
-     * Display a simple alert dialog with the given text and title.
-     *
-     * @param context
-     *          Android context in which the dialog should be displayed
-     * @param title
-     *          Alert dialog title
-     * @param text
-     *          Alert dialog message
-     */
-    @Deprecated
-    public static void showAlert(Context context, String title, String text) {
-        Builder alertBuilder = new Builder(context);
-        alertBuilder.setTitle(title);
-        alertBuilder.setMessage(text);
-        alertBuilder.create().show();
-    }
-}
diff --git a/facebook/src/com/facebook/AppEventsConstants.java b/facebook/src/com/facebook/appevents/AppEventsConstants.java
similarity index 61%
rename from facebook/src/com/facebook/AppEventsConstants.java
rename to facebook/src/com/facebook/appevents/AppEventsConstants.java
index 24fd13872..826d0285c 100644
--- a/facebook/src/com/facebook/AppEventsConstants.java
+++ b/facebook/src/com/facebook/appevents/AppEventsConstants.java
@@ -1,24 +1,28 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook;
+package com.facebook.appevents;
 
 /**
- * Predefined event and parameter names for logging events common to many apps. Logging occurs through the
- * {@link AppEventsLogger#logEvent(String, android.os.Bundle)} family of methods.
+ * Predefined event and parameter names for logging events common to many apps. Logging occurs
+ * through the {@link AppEventsLogger#logEvent(String, android.os.Bundle)} family of methods.
  */
 public class AppEventsConstants {
     // Event names
@@ -28,13 +32,20 @@
     /** Log this event when an app is being activated. */
     public static final String EVENT_NAME_ACTIVATED_APP = "fb_mobile_activate_app";
 
-    /** Log this event when a user has completed registration with the app. */
-    public static final String EVENT_NAME_COMPLETED_REGISTRATION = "fb_mobile_complete_registration";
+    public static final String EVENT_NAME_DEACTIVATED_APP = "fb_mobile_deactivate_app";
 
-    /** Log this event when a user has viewed a form of content in the app. */
+    public static final String EVENT_NAME_SESSION_INTERRUPTIONS = "fb_mobile_app_interruptions";
+
+    public static final String EVENT_NAME_TIME_BETWEEN_SESSIONS = "fb_mobile_time_between_sessions";
+
+    /** Log this event when the user has completed registration with the app. */
+    public static final String EVENT_NAME_COMPLETED_REGISTRATION =
+            "fb_mobile_complete_registration";
+
+    /** Log this event when the user has viewed a form of content in the app. */
     public static final String EVENT_NAME_VIEWED_CONTENT = "fb_mobile_content_view";
 
-    /** Log this event when a user has performed a search within the app. */
+    /** Log this event when the user has performed a search within the app. */
     public static final String EVENT_NAME_SEARCHED = "fb_mobile_search";
 
     /**
@@ -70,9 +81,9 @@
     public static final String EVENT_NAME_ADDED_PAYMENT_INFO = "fb_mobile_add_payment_info";
 
     /**
-     * Log this event when the user has completed a purchase.
-     * The {@link AppEventsLogger#logPurchase(java.math.BigDecimal, java.util.Currency)} method is a shortcut for
-     * logging this event.
+     * Log this event when the user has completed a purchase. The {@link
+     * AppEventsLogger#logPurchase(java.math.BigDecimal, java.util.Currency)} method is a shortcut
+     * for logging this event.
      */
     public static final String EVENT_NAME_PURCHASED = "fb_mobile_purchase";
 
@@ -90,32 +101,30 @@
      */
     public static final String EVENT_NAME_SPENT_CREDITS = "fb_mobile_spent_credits";
 
-
-
-
     // Event parameters
 
     /**
-     * Parameter key used to specify currency used with logged event.  E.g. "USD", "EUR", "GBP".
-     * See ISO-4217 for specific values.  One reference for these is <http://en.wikipedia.org/wiki/ISO_4217>.
+     * Parameter key used to specify currency used with logged event.  E.g. "USD", "EUR", "GBP". See
+     * <a href="http://en.wikipedia.org/wiki/ISO_4217">ISO-4217</a>
+     * for specific values.
      */
     public static final String EVENT_PARAM_CURRENCY = "fb_currency";
 
     /**
-     * Parameter key used to specify method user has used to register for the app, e.g., "Facebook", "email",
-     * "Twitter", etc.
+     * Parameter key used to specify the method the user has used to register for the app, e.g.,
+     * "Facebook", "email", "Twitter", etc.
      */
     public static final String EVENT_PARAM_REGISTRATION_METHOD = "fb_registration_method";
 
     /**
-     * Parameter key used to specify a generic content type/family for the logged event, e.g. "music", "photo",
-     * "video".  Options to use will vary based upon what the app is all about.
+     * Parameter key used to specify a generic content type/family for the logged event, e.g.
+     * "music", "photo", "video".  Options to use will vary depending on the nature of the app.
      */
     public static final String EVENT_PARAM_CONTENT_TYPE = "fb_content_type";
 
     /**
      * Parameter key used to specify an ID for the specific piece of content being logged about.
-     * Could be an EAN, article identifier, etc., depending on the nature of the app.
+     * This could be an EAN, article identifier, etc., depending on the nature of the app.
      */
     public static final String EVENT_PARAM_CONTENT_ID = "fb_content_id";
 
@@ -124,7 +133,8 @@
 
     /**
      * Parameter key used to specify whether the activity being logged about was successful or not.
-     * EVENT_PARAM_VALUE_YES and EVENT_PARAM_VALUE_NO are good canonical values to use for this parameter.
+     * EVENT_PARAM_VALUE_YES and EVENT_PARAM_VALUE_NO are good canonical values to use for this
+     * parameter.
      */
     public static final String EVENT_PARAM_SUCCESS = "fb_success";
 
@@ -135,18 +145,19 @@
     public static final String EVENT_PARAM_MAX_RATING_VALUE = "fb_max_rating_value";
 
     /**
-     * Parameter key used to specify whether payment info is available for the EVENT_NAME_INITIATED_CHECKOUT event.
-     * EVENT_PARAM_VALUE_YES and EVENT_PARAM_VALUE_NO are good canonical values to use for this parameter.
+     * Parameter key used to specify whether payment info is available for the
+     * EVENT_NAME_INITIATED_CHECKOUT event. EVENT_PARAM_VALUE_YES and EVENT_PARAM_VALUE_NO are good
+     * canonical values to use for this parameter.
      */
     public static final String EVENT_PARAM_PAYMENT_INFO_AVAILABLE = "fb_payment_info_available";
 
     /**
-     * Parameter key used to specify how many items are being processed for an EVENT_NAME_INITIATED_CHECKOUT
-     * or EVENT_NAME_PURCHASE event.
+     * Parameter key used to specify how many items are being processed for an
+     * EVENT_NAME_INITIATED_CHECKOUT or EVENT_NAME_PURCHASE event.
      */
     public static final String EVENT_PARAM_NUM_ITEMS = "fb_num_items";
 
-    /** Parameter key used to specify the level achieved in a EVENT_NAME_LEVEL_ACHIEVED event. */
+    /** Parameter key used to specify the level achieved in an EVENT_NAME_LEVEL_ACHIEVED event. */
     public static final String EVENT_PARAM_LEVEL = "fb_level";
 
     /**
@@ -156,6 +167,10 @@
     public static final String EVENT_PARAM_DESCRIPTION = "fb_description";
 
 
+    /**
+     * Parameter key used to specify source application package.
+     */
+    public static final String EVENT_PARAM_SOURCE_APPLICATION = "fb_mobile_launch_source";
 
     // Parameter values
 
@@ -164,5 +179,4 @@
 
     /** No-valued parameter value to be used with parameter keys that need a Yes/No value */
     public static final String EVENT_PARAM_VALUE_NO = "0";
-
 }
diff --git a/facebook/src/com/facebook/appevents/AppEventsLogger.java b/facebook/src/com/facebook/appevents/AppEventsLogger.java
new file mode 100644
index 000000000..04a209fc3
--- /dev/null
+++ b/facebook/src/com/facebook/appevents/AppEventsLogger.java
@@ -0,0 +1,1695 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+import bolts.AppLinks;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookException;
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.LoggingBehavior;
+import com.facebook.internal.AppEventsLoggerUtility;
+import com.facebook.internal.AttributionIdentifiers;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.FileNotFoundException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+
+/**
+ * <p>
+ * The AppEventsLogger class allows the developer to log various types of events back to Facebook.  In order to log
+ * events, the app must create an instance of this class via a {@link #newLogger newLogger} method, and then call
+ * the various "log" methods off of that.
+ * </p>
+ * <p>
+ * This client-side event logging is then available through Facebook App Insights
+ * and for use with Facebook Ads conversion tracking and optimization.
+ * </p>
+ * <p>
+ * The AppEventsLogger class has a few related roles:
+ * </p>
+ * <ul>
+ * <li>
+ * Logging predefined and application-defined events to Facebook App Insights with a
+ * numeric value to sum across a large number of events, and an optional set of key/value
+ * parameters that define "segments" for this event (e.g., 'purchaserStatus' : 'frequent', or
+ * 'gamerLevel' : 'intermediate').  These events may also be used for ads conversion tracking,
+ * optimization, and other ads related targeting in the future.
+ * </li>
+ * <li>
+ * Methods that control the way in which events are flushed out to the Facebook servers.
+ * </li>
+ * </ul>
+ * <p>
+ * Here are some important characteristics of the logging mechanism provided by AppEventsLogger:
+ * <ul>
+ * <li>
+ * Events are not sent immediately when logged.  They're cached and flushed out to the
+ * Facebook servers in a number of situations:
+ * <ul>
+ * <li>when an event count threshold is passed (currently 100 logged events).</li>
+ * <li>when a time threshold is passed (currently 15 seconds).</li>
+ * <li>when an app has gone to background and is then brought back to the foreground.</li>
+ * </ul>
+ * <li>
+ * Events will be accumulated when the app is in a disconnected state, and sent when the connection
+ * is restored and one of the above 'flush' conditions are met.
+ * </li>
+ * <li>
+ * The AppEventsLogger class is intended to be used from the thread it was created on.  Multiple
+ * AppEventsLoggers may be created on other threads if desired.
+ * </li>
+ * <li>
+ * The developer can call the setFlushBehavior method to force the flushing of events to only
+ * occur on an explicit call to the `flush` method.
+ * </li>
+ * <li>
+ * The developer can turn on console debug output for event logging and flushing to the server by
+ * calling FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS);
+ * </li>
+ * </ul>
+ * </p>
+ * <p>
+ * Some things to note when logging events:
+ * <ul>
+ * <li>
+ * There is a limit on the number of unique event names an app can use, on the order of 300.
+ * </li>
+ * <li>
+ * There is a limit to the number of unique parameter names in the provided parameters that can
+ * be used per event, on the order of 25.  This is not just for an individual call, but for all
+ * invocations for that eventName.
+ * </li>
+ * <li>
+ * Event names and parameter names (the keys in the NSDictionary) must be between 2 and 40
+ * characters, and must consist of alphanumeric characters, _, -, or spaces.
+ * </li>
+ * <li>
+ * The length of each parameter value can be no more than on the order of 100 characters.
+ * </li>
+ * </ul>
+ * </p>
+ */
+public class AppEventsLogger {
+    // Enums
+
+    /**
+     * Controls when an AppEventsLogger sends log events to the server
+     */
+    public enum FlushBehavior {
+        /**
+         * Flush automatically: periodically (every 15 seconds or after every 100 events), and
+         * always at app reactivation. This is the default value.
+         */
+        AUTO,
+
+        /**
+         * Only flush when AppEventsLogger.flush() is explicitly invoked.
+         */
+        EXPLICIT_ONLY,
+    }
+
+    // Constants
+    private static final String TAG = AppEventsLogger.class.getCanonicalName();
+
+    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
+    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
+    private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
+    private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;
+
+    public static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";
+
+    private static final String SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT =
+            "_fbSourceApplicationHasBeenSet";
+
+    // Instance member variables
+    private final Context context;
+    private final AccessTokenAppIdPair accessTokenAppId;
+
+    private static Map<AccessTokenAppIdPair, SessionEventsState> stateMap =
+            new ConcurrentHashMap<AccessTokenAppIdPair, SessionEventsState>();
+    private static ScheduledThreadPoolExecutor backgroundExecutor;
+    private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
+    private static boolean requestInFlight;
+    private static Context applicationContext;
+    private static Object staticLock = new Object();
+    private static String anonymousAppDeviceGUID;
+    private static String sourceApplication;
+    private static boolean isOpenedByApplink;
+
+    private static class AccessTokenAppIdPair implements Serializable {
+        private static final long serialVersionUID = 1L;
+        private final String accessTokenString;
+        private final String applicationId;
+
+        AccessTokenAppIdPair(AccessToken accessToken) {
+            this(accessToken.getToken(), FacebookSdk.getApplicationId());
+        }
+
+        AccessTokenAppIdPair(String accessTokenString, String applicationId) {
+            this.accessTokenString = Utility.isNullOrEmpty(accessTokenString)
+                    ? null
+                    : accessTokenString;
+            this.applicationId = applicationId;
+        }
+
+        String getAccessTokenString() {
+            return accessTokenString;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        @Override
+        public int hashCode() {
+            return (accessTokenString == null ? 0 : accessTokenString.hashCode()) ^
+                    (applicationId == null ? 0 : applicationId.hashCode());
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (!(o instanceof AccessTokenAppIdPair)) {
+                return false;
+            }
+            AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
+            return Utility.areObjectsEqual(p.accessTokenString, accessTokenString) &&
+                    Utility.areObjectsEqual(p.applicationId, applicationId);
+        }
+
+        private static class SerializationProxyV1 implements Serializable {
+            private static final long serialVersionUID = -2488473066578201069L;
+            private final String accessTokenString;
+            private final String appId;
+
+            private SerializationProxyV1(String accessTokenString, String appId) {
+                this.accessTokenString = accessTokenString;
+                this.appId = appId;
+            }
+
+            private Object readResolve() {
+                return new AccessTokenAppIdPair(accessTokenString, appId);
+            }
+        }
+
+        private Object writeReplace() {
+            return new SerializationProxyV1(accessTokenString, applicationId);
+        }
+    }
+
+    /**
+     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be
+     * called whenever your app becomes active, typically in the onResume() method of each
+     * long-running Activity of your app.
+     * <p/>
+     * Use this method if your application ID is stored in application metadata, otherwise see
+     * {@link AppEventsLogger#activateApp(android.content.Context, String)}.
+     *
+     * @param context Used to access the applicationId and the attributionId for non-authenticated
+     *                users.
+     */
+    public static void activateApp(Context context) {
+        FacebookSdk.sdkInitialize(context);
+        activateApp(context, Utility.getMetadataApplicationId(context));
+    }
+
+    /**
+     * Notifies the events system that the app has launched & logs an activatedApp event.  Should be
+     * called whenever your app becomes active, typically in the onResume() method of each
+     * long-running Activity of your app.
+     *
+     * @param context       Used to access the attributionId for non-authenticated users.
+     * @param applicationId The specific applicationId to report the activation for.
+     */
+    public static void activateApp(Context context, String applicationId) {
+        if (context == null || applicationId == null) {
+            throw new IllegalArgumentException("Both context and applicationId must be non-null");
+        }
+
+        if ((context instanceof Activity)) {
+            setSourceApplication((Activity) context);
+        } else {
+          // If context is not an Activity, we cannot get intent nor calling activity.
+          resetSourceApplication();
+          Log.d(AppEventsLogger.class.getName(),
+              "To set source application the context of activateApp must be an instance of" +
+                      " Activity");
+        }
+
+        // activateApp supersedes publishInstall in the public API, so we need to explicitly invoke
+        // it, since the server can't reliably infer install state for all conditions of an app
+        // activate.
+        FacebookSdk.publishInstallAsync(context, applicationId);
+
+        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
+        final long eventTime = System.currentTimeMillis();
+        final String sourceApplicationInfo = getSourceApplication();
+        backgroundExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                logger.logAppSessionResumeEvent(eventTime, sourceApplicationInfo);
+            }
+        });
+    }
+
+    /**
+     * Notifies the events system that the app has been deactivated (put in the background) and
+     * tracks the application session information. Should be called whenever your app becomes
+     * inactive, typically in the onPause() method of each long-running Activity of your app.
+     *
+     * Use this method if your application ID is stored in application metadata, otherwise see
+     * {@link AppEventsLogger#deactivateApp(android.content.Context, String)}.
+     *
+     * @param context Used to access the applicationId and the attributionId for non-authenticated
+     *                users.
+     */
+    public static void deactivateApp(Context context) {
+        deactivateApp(context, Utility.getMetadataApplicationId(context));
+    }
+
+    /**
+     * Notifies the events system that the app has been deactivated (put in the background) and
+     * tracks the application session information. Should be called whenever your app becomes
+     * inactive, typically in the onPause() method of each long-running Activity of your app.
+     *
+     * @param context       Used to access the attributionId for non-authenticated users.
+     * @param applicationId The specific applicationId to track session information for.
+     */
+    public static void deactivateApp(Context context, String applicationId) {
+        if (context == null || applicationId == null) {
+            throw new IllegalArgumentException("Both context and applicationId must be non-null");
+        }
+
+        resetSourceApplication();
+
+        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
+        final long eventTime = System.currentTimeMillis();
+        backgroundExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                logger.logAppSessionSuspendEvent(eventTime);
+            }
+        });
+    }
+
+    private void logAppSessionResumeEvent(long eventTime, String sourceApplicationInfo) {
+        PersistedAppSessionInfo.onResume(
+                applicationContext,
+                accessTokenAppId,
+                this,
+                eventTime,
+                sourceApplicationInfo);
+    }
+
+    private void logAppSessionSuspendEvent(long eventTime) {
+        PersistedAppSessionInfo.onSuspend(applicationContext, accessTokenAppId, this, eventTime);
+    }
+
+    /**
+     * Build an AppEventsLogger instance to log events through.  The Facebook app that these events
+     * are targeted at comes from this application's metadata. The application ID used to log events
+     * will be determined from the app ID specified in the package metadata.
+     *
+     * @param context Used to access the applicationId and the attributionId for non-authenticated
+     *                users.
+     * @return AppEventsLogger instance to invoke log* methods on.
+     */
+    public static AppEventsLogger newLogger(Context context) {
+        return new AppEventsLogger(context, null, null);
+    }
+
+    /**
+     * Build an AppEventsLogger instance to log events through.
+     *
+     * @param context Used to access the attributionId for non-authenticated users.
+     * @param accessToken Access token to use for logging events. If null, the active access token
+     *                    will be used, if any; if not the logging will happen against the default
+     *                    app ID specified in the package metadata.
+     */
+    public static AppEventsLogger newLogger(Context context, AccessToken accessToken) {
+        return new AppEventsLogger(context, null, accessToken);
+    }
+
+    /**
+     * Build an AppEventsLogger instance to log events through.
+     *
+     * @param context       Used to access the attributionId for non-authenticated users.
+     * @param applicationId Explicitly specified Facebook applicationId to log events against.  If
+     *                      null, the default app ID specified in the package metadata will be
+     *                      used.
+     * @param accessToken   Access token to use for logging events. If null, the active access token
+     *                      will be used, if any; if not the logging will happen against the default
+     *                      app ID specified in the package metadata.
+     * @return AppEventsLogger instance to invoke log* methods on.
+     */
+    public static AppEventsLogger newLogger(
+            Context context,
+            String applicationId,
+            AccessToken accessToken) {
+        return new AppEventsLogger(context, applicationId, accessToken);
+    }
+
+    /**
+     * Build an AppEventsLogger instance to log events that are attributed to the application but
+     * not to any particular Session.
+     *
+     * @param context       Used to access the attributionId for non-authenticated users.
+     * @param applicationId Explicitly specified Facebook applicationId to log events against.  If
+     *                      null, the default app ID specified in the package metadata will be
+     *                      used.
+     * @return AppEventsLogger instance to invoke log* methods on.
+     */
+    public static AppEventsLogger newLogger(Context context, String applicationId) {
+        return new AppEventsLogger(context, applicationId, null);
+    }
+
+    /**
+     * The action used to indicate that a flush of app events has occurred. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_APP_EVENTS_FLUSHED = "com.facebook.sdk.APP_EVENTS_FLUSHED";
+
+    public static final String APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED =
+            "com.facebook.sdk.APP_EVENTS_NUM_EVENTS_FLUSHED";
+    public static final String APP_EVENTS_EXTRA_FLUSH_RESULT =
+            "com.facebook.sdk.APP_EVENTS_FLUSH_RESULT";
+
+    /**
+     * Access the behavior that AppEventsLogger uses to determine when to flush logged events to the
+     * server. This setting applies to all instances of AppEventsLogger.
+     *
+     * @return Specified flush behavior.
+     */
+    public static FlushBehavior getFlushBehavior() {
+        synchronized (staticLock) {
+            return flushBehavior;
+        }
+    }
+
+    /**
+     * Set the behavior that this AppEventsLogger uses to determine when to flush logged events to
+     * the server. This setting applies to all instances of AppEventsLogger.
+     *
+     * @param flushBehavior the desired behavior.
+     */
+    public static void setFlushBehavior(FlushBehavior flushBehavior) {
+        synchronized (staticLock) {
+            AppEventsLogger.flushBehavior = flushBehavior;
+        }
+    }
+
+    /**
+     * Log an app event with the specified name.
+     *
+     * @param eventName eventName used to denote the event.  Choose amongst the EVENT_NAME_*
+     *                  constants in {@link AppEventsConstants} when possible.  Or create your own
+     *                  if none of the EVENT_NAME_* constants are applicable. Event names should be
+     *                  40 characters or less, alphanumeric, and can include spaces, underscores or
+     *                  hyphens, but must not have a space or hyphen as the first character.  Any
+     *                  given app should have no more than ~300 distinct event names.
+     */
+    public void logEvent(String eventName) {
+        logEvent(eventName, null);
+    }
+
+    /**
+     * Log an app event with the specified name and the supplied value.
+     *
+     * @param eventName  eventName used to denote the event.  Choose amongst the EVENT_NAME_*
+     *                   constants in {@link AppEventsConstants} when possible.  Or create your own
+     *                   if none of the EVENT_NAME_* constants are applicable. Event names should be
+     *                   40 characters or less, alphanumeric, and can include spaces, underscores or
+     *                   hyphens, but must not have a space or hyphen as the first character.  Any
+     *                   given app should have no more than ~300 distinct event names. * @param
+     *                   eventName
+     * @param valueToSum a value to associate with the event which will be summed up in Insights for
+     *                   across all instances of the event, so that average values can be
+     *                   determined, etc.
+     */
+    public void logEvent(String eventName, double valueToSum) {
+        logEvent(eventName, valueToSum, null);
+    }
+
+    /**
+     * Log an app event with the specified name and set of parameters.
+     *
+     * @param eventName  eventName used to denote the event.  Choose amongst the EVENT_NAME_*
+     *                   constants in {@link AppEventsConstants} when possible.  Or create your own
+     *                   if none of the EVENT_NAME_* constants are applicable. Event names should be
+     *                   40 characters or less, alphanumeric, and can include spaces, underscores or
+     *                   hyphens, but must not have a space or hyphen as the first character.  Any
+     *                   given app should have no more than ~300 distinct event names.
+     * @param parameters A Bundle of parameters to log with the event.  Insights will allow looking
+     *                   at the logs of these events via different parameter values.  You can log on
+     *                   the order of 10 parameters with each distinct eventName.  It's advisable to
+     *                   limit the number of unique values provided for each parameter in the
+     *                   thousands.  As an example, don't attempt to provide a unique
+     *                   parameter value for each unique user in your app.  You won't get meaningful
+     *                   aggregate reporting on so many parameter values.  The values in the bundles
+     *                   should be Strings or numeric values.
+     */
+    public void logEvent(String eventName, Bundle parameters) {
+        logEvent(eventName, null, parameters, false);
+    }
+
+    /**
+     * Log an app event with the specified name, supplied value, and set of parameters.
+     *
+     * @param eventName  eventName used to denote the event.  Choose amongst the EVENT_NAME_*
+     *                   constants in {@link AppEventsConstants} when possible.  Or create your own
+     *                   if none of the EVENT_NAME_* constants are applicable. Event names should be
+     *                   40 characters or less, alphanumeric, and can include spaces, underscores or
+     *                   hyphens, but must not have a space or hyphen as the first character.  Any
+     *                   given app should have no more than ~300 distinct event names.
+     * @param valueToSum a value to associate with the event which will be summed up in Insights for
+     *                   across all instances of the event, so that average values can be
+     *                   determined, etc.
+     * @param parameters A Bundle of parameters to log with the event.  Insights will allow looking
+     *                   at the logs of these events via different parameter values.  You can log on
+     *                   the order of 10 parameters with each distinct eventName.  It's advisable to
+     *                   limit the number of unique values provided for each parameter in the
+     *                   thousands.  As an example, don't attempt to provide a unique
+     *                   parameter value for each unique user in your app.  You won't get meaningful
+     *                   aggregate reporting on so many parameter values.  The values in the bundles
+     *                   should be Strings or numeric values.
+     */
+    public void logEvent(String eventName, double valueToSum, Bundle parameters) {
+        logEvent(eventName, valueToSum, parameters, false);
+    }
+
+    /**
+     * Logs a purchase event with Facebook, in the specified amount and with the specified
+     * currency.
+     *
+     * @param purchaseAmount Amount of purchase, in the currency specified by the 'currency'
+     *                       parameter. This value will be rounded to the thousandths place (e.g.,
+     *                       12.34567 becomes 12.346).
+     * @param currency       Currency used to specify the amount.
+     */
+    public void logPurchase(BigDecimal purchaseAmount, Currency currency) {
+        logPurchase(purchaseAmount, currency, null);
+    }
+
+    /**
+     * Logs a purchase event with Facebook, in the specified amount and with the specified currency.
+     * Additional detail about the purchase can be passed in through the parameters bundle.
+     *
+     * @param purchaseAmount Amount of purchase, in the currency specified by the 'currency'
+     *                       parameter. This value will be rounded to the thousandths place (e.g.,
+     *                       12.34567 becomes 12.346).
+     * @param currency       Currency used to specify the amount.
+     * @param parameters     Arbitrary additional information for describing this event. This should
+     *                       have no more than 10 entries, and keys should be mostly consistent from
+     *                       one purchase event to the next.
+     */
+    public void logPurchase(BigDecimal purchaseAmount, Currency currency, Bundle parameters) {
+
+        if (purchaseAmount == null) {
+            notifyDeveloperError("purchaseAmount cannot be null");
+            return;
+        } else if (currency == null) {
+            notifyDeveloperError("currency cannot be null");
+            return;
+        }
+
+        if (parameters == null) {
+            parameters = new Bundle();
+        }
+        parameters.putString(AppEventsConstants.EVENT_PARAM_CURRENCY, currency.getCurrencyCode());
+
+        logEvent(AppEventsConstants.EVENT_NAME_PURCHASED, purchaseAmount.doubleValue(), parameters);
+        eagerFlush();
+    }
+
+    /**
+     * Explicitly flush any stored events to the server.  Implicit flushes may happen depending on
+     * the value of getFlushBehavior.  This method allows for explicit, app invoked flushing.
+     */
+    public void flush() {
+        flush(FlushReason.EXPLICIT);
+    }
+
+    /**
+     * Call this when the consuming Activity/Fragment receives an onStop() callback in order to
+     * persist any outstanding events to disk so they may be flushed at a later time. The next
+     * flush (explicit or not) will check for any outstanding events and if present, include them
+     * in that flush. Note that this call may trigger an I/O operation on the calling thread.
+     * Explicit use of this method is necessary.
+     */
+    public static void onContextStop() {
+        // TODO: (v4) add onContextStop() to samples that use the logger.
+        PersistedEvents.persistEvents(applicationContext, stateMap);
+    }
+
+    /**
+     * Determines if the logger is valid for the given access token.
+     * @param accessToken The access token to check.
+     * @return True if the access token is valid for this logger.
+     */
+    public boolean isValidForAccessToken(AccessToken accessToken) {
+        AccessTokenAppIdPair other = new AccessTokenAppIdPair(accessToken);
+        return accessTokenAppId.equals(other);
+    }
+
+    /**
+     * This method is intended only for internal use by the Facebook SDK and other use is
+     * unsupported.
+     */
+    public void logSdkEvent(String eventName, Double valueToSum, Bundle parameters) {
+        logEvent(eventName, valueToSum, parameters, true);
+    }
+
+    /**
+     * Returns the app ID this logger was configured to log to.
+     *
+     * @return the Facebook app ID
+     */
+    public String getApplicationId() {
+        return accessTokenAppId.getApplicationId();
+    }
+
+    //
+    // Private implementation
+    //
+
+    @SuppressWarnings("UnusedDeclaration")
+    private enum FlushReason {
+        EXPLICIT,
+        TIMER,
+        SESSION_CHANGE,
+        PERSISTED_EVENTS,
+        EVENT_THRESHOLD,
+        EAGER_FLUSHING_EVENT,
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    private enum FlushResult {
+        SUCCESS,
+        SERVER_ERROR,
+        NO_CONNECTIVITY,
+        UNKNOWN_ERROR
+    }
+
+    /**
+     * Constructor is private, newLogger() methods should be used to build an instance.
+     */
+    private AppEventsLogger(Context context, String applicationId, AccessToken accessToken) {
+        Validate.notNull(context, "context");
+        this.context = context;
+
+        if (accessToken == null) {
+            accessToken = AccessToken.getCurrentAccessToken();
+        }
+
+        // If we have a session and the appId passed is null or matches the session's app ID:
+        if (accessToken != null &&
+                (applicationId == null || applicationId.equals(accessToken.getApplicationId()))
+                ) {
+            accessTokenAppId = new AccessTokenAppIdPair(accessToken);
+        } else {
+            // If no app ID passed, get it from the manifest:
+            if (applicationId == null) {
+                applicationId = Utility.getMetadataApplicationId(context);
+            }
+            accessTokenAppId = new AccessTokenAppIdPair(null, applicationId);
+        }
+
+        synchronized (staticLock) {
+
+            if (applicationContext == null) {
+                applicationContext = context.getApplicationContext();
+            }
+        }
+
+        initializeTimersIfNeeded();
+    }
+
+    private static void initializeTimersIfNeeded() {
+        synchronized (staticLock) {
+            if (backgroundExecutor != null) {
+                return;
+            }
+            backgroundExecutor = new ScheduledThreadPoolExecutor(1);
+        }
+
+        final Runnable flushRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
+                    flushAndWait(FlushReason.TIMER);
+                }
+            }
+        };
+
+        backgroundExecutor.scheduleAtFixedRate(
+                flushRunnable,
+                0,
+                FLUSH_PERIOD_IN_SECONDS,
+                TimeUnit.SECONDS
+        );
+
+        final Runnable attributionRecheckRunnable = new Runnable() {
+            @Override
+            public void run() {
+                Set<String> applicationIds = new HashSet<String>();
+                synchronized (staticLock) {
+                    for (AccessTokenAppIdPair accessTokenAppId : stateMap.keySet()) {
+                        applicationIds.add(accessTokenAppId.getApplicationId());
+                    }
+                }
+                for (String applicationId : applicationIds) {
+                    Utility.queryAppSettings(applicationId, true);
+                }
+            }
+        };
+
+        backgroundExecutor.scheduleAtFixedRate(
+                attributionRecheckRunnable,
+                0,
+                APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS,
+                TimeUnit.SECONDS
+        );
+    }
+
+    private void logEvent(
+            String eventName,
+            Double valueToSum,
+            Bundle parameters,
+            boolean isImplicitlyLogged) {
+        AppEvent event = new AppEvent(
+                this.context,
+                eventName,
+                valueToSum,
+                parameters,
+                isImplicitlyLogged);
+        logEvent(context, event, accessTokenAppId);
+    }
+
+    private static void logEvent(final Context context,
+                                 final AppEvent event,
+                                 final AccessTokenAppIdPair accessTokenAppId) {
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                SessionEventsState state = getSessionEventsState(context, accessTokenAppId);
+                state.addEvent(event);
+                flushIfNecessary();
+            }
+        });
+    }
+
+    static void eagerFlush() {
+        if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
+            flush(FlushReason.EAGER_FLUSHING_EVENT);
+        }
+    }
+
+    private static void flushIfNecessary() {
+        synchronized (staticLock) {
+            if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
+                if (getAccumulatedEventCount() > NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
+                    flush(FlushReason.EVENT_THRESHOLD);
+                }
+            }
+        }
+    }
+
+    private static int getAccumulatedEventCount() {
+        synchronized (staticLock) {
+
+            int result = 0;
+            for (SessionEventsState state : stateMap.values()) {
+                result += state.getAccumulatedEventCount();
+            }
+            return result;
+        }
+    }
+
+    // Creates a new SessionEventsState if not already in the map.
+    private static SessionEventsState getSessionEventsState(
+            Context context,
+            AccessTokenAppIdPair accessTokenAppId) {
+        // Do this work outside of the lock to prevent deadlocks in implementation of
+        // AdvertisingIdClient.getAdvertisingIdInfo, because that implementation blocks waiting on
+        // the main thread, which may also grab this staticLock.
+        SessionEventsState state = stateMap.get(accessTokenAppId);
+        AttributionIdentifiers attributionIdentifiers = null;
+        if (state == null) {
+            // Retrieve attributionId, but we will only send it if attribution is supported for the
+            // app.
+            attributionIdentifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
+        }
+
+        synchronized (staticLock) {
+            // Check state again while we're locked.
+            state = stateMap.get(accessTokenAppId);
+            if (state == null) {
+                state = new SessionEventsState(
+                        attributionIdentifiers,
+                        context.getPackageName(),
+                        getAnonymousAppDeviceGUID(context));
+                stateMap.put(accessTokenAppId, state);
+            }
+            return state;
+        }
+    }
+
+    private static SessionEventsState getSessionEventsState(AccessTokenAppIdPair accessTokenAppId) {
+        synchronized (staticLock) {
+            return stateMap.get(accessTokenAppId);
+        }
+    }
+
+    private static void flush(final FlushReason reason) {
+
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                flushAndWait(reason);
+            }
+        });
+    }
+
+    private static void flushAndWait(final FlushReason reason) {
+
+        Set<AccessTokenAppIdPair> keysToFlush;
+        synchronized (staticLock) {
+            if (requestInFlight) {
+                return;
+            }
+            requestInFlight = true;
+            keysToFlush = new HashSet<AccessTokenAppIdPair>(stateMap.keySet());
+        }
+
+        accumulatePersistedEvents();
+
+        FlushStatistics flushResults = null;
+        try {
+            flushResults = buildAndExecuteRequests(reason, keysToFlush);
+        } catch (Exception e) {
+            Utility.logd(TAG, "Caught unexpected exception while flushing: ", e);
+        }
+
+        synchronized (staticLock) {
+            requestInFlight = false;
+        }
+
+        if (flushResults != null) {
+            final Intent intent = new Intent(ACTION_APP_EVENTS_FLUSHED);
+            intent.putExtra(APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, flushResults.numEvents);
+            intent.putExtra(APP_EVENTS_EXTRA_FLUSH_RESULT, flushResults.result);
+            LocalBroadcastManager.getInstance(applicationContext).sendBroadcast(intent);
+        }
+    }
+
+    private static FlushStatistics buildAndExecuteRequests(
+            FlushReason reason,
+            Set<AccessTokenAppIdPair> keysToFlush) {
+        FlushStatistics flushResults = new FlushStatistics();
+
+        boolean limitEventUsage = FacebookSdk.getLimitEventAndDataUsage(applicationContext);
+
+        List<GraphRequest> requestsToExecute = new ArrayList<GraphRequest>();
+        for (AccessTokenAppIdPair accessTokenAppId : keysToFlush) {
+            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppId);
+            if (sessionEventsState == null) {
+                continue;
+            }
+
+            GraphRequest request = buildRequestForSession(
+                    accessTokenAppId,
+                    sessionEventsState,
+                    limitEventUsage,
+                    flushResults);
+            if (request != null) {
+                requestsToExecute.add(request);
+            }
+        }
+
+        if (requestsToExecute.size() > 0) {
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
+                    flushResults.numEvents,
+                    reason.toString());
+
+            for (GraphRequest request : requestsToExecute) {
+                // Execute the request synchronously. Callbacks will take care of handling errors
+                // and updating our final overall result.
+                request.executeAndWait();
+            }
+            return flushResults;
+        }
+
+        return null;
+    }
+
+    private static class FlushStatistics {
+        public int numEvents = 0;
+        public FlushResult result = FlushResult.SUCCESS;
+    }
+
+    private static GraphRequest buildRequestForSession(
+            final AccessTokenAppIdPair accessTokenAppId,
+            final SessionEventsState sessionEventsState,
+            final boolean limitEventUsage,
+            final FlushStatistics flushState) {
+        String applicationId = accessTokenAppId.getApplicationId();
+
+        Utility.FetchedAppSettings fetchedAppSettings =
+                Utility.queryAppSettings(applicationId, false);
+
+        final GraphRequest postRequest = GraphRequest.newPostRequest(
+                null,
+                String.format("%s/activities", applicationId),
+                null,
+                null);
+
+        Bundle requestParameters = postRequest.getParameters();
+        if (requestParameters == null) {
+            requestParameters = new Bundle();
+        }
+        requestParameters.putString("access_token", accessTokenAppId.getAccessTokenString());
+        postRequest.setParameters(requestParameters);
+
+        if (fetchedAppSettings == null) {
+            return null;
+        }
+
+        int numEvents = sessionEventsState.populateRequest(
+                postRequest,
+                fetchedAppSettings.supportsImplicitLogging(),
+                limitEventUsage);
+
+        if (numEvents == 0) {
+            return null;
+        }
+
+        flushState.numEvents += numEvents;
+
+        postRequest.setCallback(new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                handleResponse(accessTokenAppId, postRequest, response, sessionEventsState, flushState);
+            }
+        });
+
+        return postRequest;
+    }
+
+    private static void handleResponse(
+            AccessTokenAppIdPair accessTokenAppId,
+            GraphRequest request,
+            GraphResponse response,
+            SessionEventsState sessionEventsState,
+            FlushStatistics flushState) {
+        FacebookRequestError error = response.getError();
+        String resultDescription = "Success";
+
+        FlushResult flushResult = FlushResult.SUCCESS;
+
+        if (error != null) {
+            final int NO_CONNECTIVITY_ERROR_CODE = -1;
+            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
+                resultDescription = "Failed: No Connectivity";
+                flushResult = FlushResult.NO_CONNECTIVITY;
+            } else {
+                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
+                        response.toString(),
+                        error.toString());
+                flushResult = FlushResult.SERVER_ERROR;
+            }
+        }
+
+        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
+            String eventsJsonString = (String) request.getTag();
+            String prettyPrintedEvents;
+
+            try {
+                JSONArray jsonArray = new JSONArray(eventsJsonString);
+                prettyPrintedEvents = jsonArray.toString(2);
+            } catch (JSONException exc) {
+                prettyPrintedEvents = "<Can't encode events for debug logging>";
+            }
+
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
+                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
+                    request.getGraphObject().toString(),
+                    resultDescription,
+                    prettyPrintedEvents);
+        }
+
+        sessionEventsState.clearInFlightAndStats(error != null);
+
+        if (flushResult == FlushResult.NO_CONNECTIVITY) {
+            // We may call this for multiple requests in a batch, which is slightly inefficient
+            // since in principle we could call it once for all failed requests, but the impact is
+            // likely to be minimal. We don't call this for other server errors, because if an event
+            // failed because it was malformed, etc., continually retrying it will cause subsequent
+            // events to not be logged either.
+            PersistedEvents.persistEvents(applicationContext, accessTokenAppId, sessionEventsState);
+        }
+
+        if (flushResult != FlushResult.SUCCESS) {
+            // We assume that connectivity issues are more significant to report than server issues.
+            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
+                flushState.result = flushResult;
+            }
+        }
+    }
+
+    private static int accumulatePersistedEvents() {
+        PersistedEvents persistedEvents = PersistedEvents.readAndClearStore(applicationContext);
+
+        int result = 0;
+        for (AccessTokenAppIdPair accessTokenAppId : persistedEvents.keySet()) {
+            SessionEventsState sessionEventsState =
+                    getSessionEventsState(applicationContext, accessTokenAppId);
+
+            List<AppEvent> events = persistedEvents.getEvents(accessTokenAppId);
+            sessionEventsState.accumulatePersistedEvents(events);
+            result += events.size();
+        }
+
+        return result;
+    }
+
+    /**
+     * Invoke this method, rather than throwing an Exception, for situations where user/server input
+     * might reasonably cause this to occur, and thus don't want an exception thrown at production
+     * time, but do want logging notification.
+     */
+    private static void notifyDeveloperError(String message) {
+        Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "AppEvents", message);
+    }
+
+    /**
+     * Source Application setters and getters
+     */
+    private static void setSourceApplication(Activity activity) {
+
+        ComponentName callingApplication = activity.getCallingActivity();
+        if (callingApplication != null) {
+            String callingApplicationPackage = callingApplication.getPackageName();
+            if (callingApplicationPackage.equals(activity.getPackageName())) {
+                // open by own app.
+                resetSourceApplication();
+                return;
+            }
+            sourceApplication = callingApplicationPackage;
+        }
+
+        // Tap icon to open an app will still get the old intent if the activity was opened by an
+        // intent before. Introduce an extra field in the intent to force clear the
+        // sourceApplication.
+        Intent openIntent = activity.getIntent();
+        if (openIntent == null ||
+                openIntent.getBooleanExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, false)) {
+            resetSourceApplication();
+            return;
+        }
+
+        Bundle applinkData = AppLinks.getAppLinkData(openIntent);
+
+        if (applinkData == null) {
+            resetSourceApplication();
+            return;
+        }
+
+        isOpenedByApplink = true;
+
+        Bundle applinkReferrerData = applinkData.getBundle("referer_app_link");
+
+        if (applinkReferrerData == null) {
+            sourceApplication = null;
+            return;
+        }
+
+        String applinkReferrerPackage = applinkReferrerData.getString("package");
+        sourceApplication = applinkReferrerPackage;
+
+        // Mark this intent has been used to avoid use this intent again and again.
+        openIntent.putExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, true);
+
+        return;
+    }
+
+    static void setSourceApplication(String applicationPackage, boolean openByAppLink) {
+        sourceApplication = applicationPackage;
+        isOpenedByApplink = openByAppLink;
+    }
+
+    static String getSourceApplication() {
+        String openType = "Unclassified";
+        if (isOpenedByApplink) {
+            openType = "Applink";
+        }
+        if (sourceApplication != null) {
+            return openType + "(" + sourceApplication + ")";
+        }
+        return openType;
+    }
+
+    static void resetSourceApplication() {
+        sourceApplication = null;
+        isOpenedByApplink = false;
+    }
+
+    /**
+     * Each app/device pair gets an GUID that is sent back with App Events and persisted with this
+     * app/device pair.
+     * @param context The application context.
+     * @return The GUID for this app/device pair.
+     */
+    public static String getAnonymousAppDeviceGUID(Context context) {
+
+        if (anonymousAppDeviceGUID == null) {
+            synchronized (staticLock) {
+                if (anonymousAppDeviceGUID == null) {
+
+                    SharedPreferences preferences = context.getSharedPreferences(
+                            APP_EVENT_PREFERENCES,
+                            Context.MODE_PRIVATE);
+                    anonymousAppDeviceGUID = preferences.getString("anonymousAppDeviceGUID", null);
+                    if (anonymousAppDeviceGUID == null) {
+                        // Arbitrarily prepend XZ to distinguish from device supplied identifiers.
+                        anonymousAppDeviceGUID = "XZ" + UUID.randomUUID().toString();
+
+                        context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
+                                .edit()
+                                .putString("anonymousAppDeviceGUID", anonymousAppDeviceGUID)
+                                .apply();
+                    }
+                }
+            }
+        }
+
+        return anonymousAppDeviceGUID;
+    }
+
+    //
+    // Deprecated Stuff
+    //
+
+
+    static class SessionEventsState {
+        private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
+        private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
+        private int numSkippedEventsDueToFullBuffer;
+        private AttributionIdentifiers attributionIdentifiers;
+        private String packageName;
+        private String anonymousAppDeviceGUID;
+
+        public static final String EVENT_COUNT_KEY = "event_count";
+        public static final String ENCODED_EVENTS_KEY = "encoded_events";
+        public static final String NUM_SKIPPED_KEY = "num_skipped";
+
+        private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;
+
+        public SessionEventsState(
+                AttributionIdentifiers identifiers,
+                String packageName,
+                String anonymousGUID) {
+            this.attributionIdentifiers = identifiers;
+            this.packageName = packageName;
+            this.anonymousAppDeviceGUID = anonymousGUID;
+        }
+
+        // Synchronize here and in other methods on this class, because could be coming in from
+        // different AppEventsLoggers on different threads pointing at the same session.
+        public synchronized void addEvent(AppEvent event) {
+            if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
+                numSkippedEventsDueToFullBuffer++;
+            } else {
+                accumulatedEvents.add(event);
+            }
+        }
+
+        public synchronized int getAccumulatedEventCount() {
+            return accumulatedEvents.size();
+        }
+
+        public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
+            if (moveToAccumulated) {
+                accumulatedEvents.addAll(inFlightEvents);
+            }
+            inFlightEvents.clear();
+            numSkippedEventsDueToFullBuffer = 0;
+        }
+
+        public int populateRequest(GraphRequest request, boolean includeImplicitEvents,
+                                   boolean limitEventUsage) {
+
+            int numSkipped;
+            JSONArray jsonArray;
+            synchronized (this) {
+                numSkipped = numSkippedEventsDueToFullBuffer;
+
+                // move all accumulated events to inFlight.
+                inFlightEvents.addAll(accumulatedEvents);
+                accumulatedEvents.clear();
+
+                jsonArray = new JSONArray();
+                for (AppEvent event : inFlightEvents) {
+                    if (includeImplicitEvents || !event.getIsImplicit()) {
+                        jsonArray.put(event.getJSONObject());
+                    }
+                }
+
+                if (jsonArray.length() == 0) {
+                    return 0;
+                }
+            }
+
+            populateRequest(request, numSkipped, jsonArray, limitEventUsage);
+            return jsonArray.length();
+        }
+
+        public synchronized List<AppEvent> getEventsToPersist() {
+            // We will only persist accumulated events, not ones currently in-flight. This means if
+            // an in-flight request fails, those requests will not be persisted and thus might be
+            // lost if the process terminates while the flush is in progress.
+            List<AppEvent> result = accumulatedEvents;
+            accumulatedEvents = new ArrayList<AppEvent>();
+            return result;
+        }
+
+        public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
+            // We won't skip events due to a full buffer, since we already accumulated them once and
+            // persisted them. But they will count against the buffer size when further events are
+            // accumulated.
+            accumulatedEvents.addAll(events);
+        }
+
+        private void populateRequest(GraphRequest request, int numSkipped, JSONArray events,
+                                     boolean limitEventUsage) {
+            JSONObject publishParams = null;
+            try {
+                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
+                        AppEventsLoggerUtility.GraphAPIActivityType.CUSTOM_APP_EVENTS,
+                        attributionIdentifiers,
+                        anonymousAppDeviceGUID,
+                        limitEventUsage,
+                        applicationContext);
+
+                if (numSkippedEventsDueToFullBuffer > 0) {
+                    publishParams.put("num_skipped_events", numSkipped);
+                }
+            } catch (JSONException e) {
+                // Swallow
+                publishParams = new JSONObject();
+            }
+            request.setGraphObject(publishParams);
+
+            Bundle requestParameters = request.getParameters();
+            if (requestParameters == null) {
+                requestParameters = new Bundle();
+            }
+
+            String jsonString = events.toString();
+            if (jsonString != null) {
+                requestParameters.putByteArray(
+                        "custom_events_file",
+                        getStringAsByteArray(jsonString));
+                request.setTag(jsonString);
+            }
+            request.setParameters(requestParameters);
+        }
+
+        private byte[] getStringAsByteArray(String jsonString) {
+            byte[] jsonUtf8 = null;
+            try {
+                jsonUtf8 = jsonString.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                // shouldn't happen, but just in case:
+                Utility.logd("Encoding exception: ", e);
+            }
+            return jsonUtf8;
+        }
+    }
+
+    static class AppEvent implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        private JSONObject jsonObject;
+        private boolean isImplicit;
+        private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
+        private String name;
+
+        public AppEvent(
+                Context context,
+                String eventName,
+                Double valueToSum,
+                Bundle parameters,
+                boolean isImplicitlyLogged
+        ) {
+            try {
+                validateIdentifier(eventName);
+
+                this.name = eventName;
+                isImplicit = isImplicitlyLogged;
+                jsonObject = new JSONObject();
+
+                jsonObject.put("_eventName", eventName);
+                jsonObject.put("_logTime", System.currentTimeMillis() / 1000);
+                jsonObject.put("_ui", Utility.getActivityName(context));
+
+                if (valueToSum != null) {
+                    jsonObject.put("_valueToSum", valueToSum.doubleValue());
+                }
+
+                if (isImplicit) {
+                    jsonObject.put("_implicitlyLogged", "1");
+                }
+
+                if (parameters != null) {
+                    for (String key : parameters.keySet()) {
+
+                        validateIdentifier(key);
+
+                        Object value = parameters.get(key);
+                        if (!(value instanceof String) && !(value instanceof Number)) {
+                            throw new FacebookException(
+                                    String.format(
+                                            "Parameter value '%s' for key '%s' should be a string" +
+                                                    " or a numeric type.",
+                                            value,
+                                            key)
+                            );
+                        }
+
+                        jsonObject.put(key, value.toString());
+                    }
+                }
+
+                if (!isImplicit) {
+                    Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                            "Created app event '%s'", jsonObject.toString());
+                }
+            } catch (JSONException jsonException) {
+
+                // If any of the above failed, just consider this an illegal event.
+                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                        "JSON encoding for app event failed: '%s'", jsonException.toString());
+                jsonObject = null;
+
+            } catch (FacebookException e) {
+                // If any of the above failed, just consider this an illegal event.
+                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                        "Invalid app event name or parameter:", e.toString());
+                jsonObject = null;
+            }
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
+            jsonObject = new JSONObject(jsonString);
+            this.isImplicit = isImplicit;
+        }
+
+        public boolean getIsImplicit() {
+            return isImplicit;
+        }
+
+        public JSONObject getJSONObject() {
+            return jsonObject;
+        }
+
+        // throw exception if not valid.
+        private void validateIdentifier(String identifier) throws FacebookException {
+
+            // Identifier should be 40 chars or less, and only have 0-9A-Za-z, underscore, hyphen,
+            // and space (but no hyphen or space in the first position).
+            final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";
+
+            final int MAX_IDENTIFIER_LENGTH = 40;
+            if (identifier == null
+                    || identifier.length() == 0
+                    || identifier.length() > MAX_IDENTIFIER_LENGTH) {
+                if (identifier == null) {
+                    identifier = "<None Provided>";
+                }
+                throw new FacebookException(
+                    String.format(
+                            Locale.ROOT,
+                            "Identifier '%s' must be less than %d characters",
+                            identifier,
+                            MAX_IDENTIFIER_LENGTH)
+                );
+            }
+
+            boolean alreadyValidated = false;
+            synchronized (validatedIdentifiers) {
+                alreadyValidated = validatedIdentifiers.contains(identifier);
+            }
+
+            if (!alreadyValidated) {
+                if (identifier.matches(regex)) {
+                    synchronized (validatedIdentifiers) {
+                        validatedIdentifiers.add(identifier);
+                    }
+                } else {
+                    throw new FacebookException(
+                            String.format(
+                                    "Skipping event named '%s' due to illegal name - must be " +
+                                            "under 40 chars and alphanumeric, _, - or space, and " +
+                                            "not start with a space or hyphen.",
+                                    identifier
+                            )
+                    );
+                }
+            }
+        }
+
+        private static class SerializationProxyV1 implements Serializable {
+            private static final long serialVersionUID = -2488473066578201069L;
+            private final String jsonString;
+            private final boolean isImplicit;
+
+            private SerializationProxyV1(String jsonString, boolean isImplicit) {
+                this.jsonString = jsonString;
+                this.isImplicit = isImplicit;
+            }
+
+            private Object readResolve() throws JSONException {
+                return new AppEvent(jsonString, isImplicit);
+            }
+        }
+
+        private Object writeReplace() {
+            return new SerializationProxyV1(jsonObject.toString(), isImplicit);
+        }
+
+        @Override
+        public String toString() {
+            return String.format(
+                    "\"%s\", implicit: %b, json: %s",
+                    jsonObject.optString("_eventName"),
+                    isImplicit,
+                    jsonObject.toString());
+        }
+    }
+
+    static class PersistedAppSessionInfo {
+        private static final String PERSISTED_SESSION_INFO_FILENAME =
+                "AppEventsLogger.persistedsessioninfo";
+
+        private static final Object staticLock = new Object();
+        private static boolean hasChanges = false;
+        private static boolean isLoaded = false;
+        private static Map<AccessTokenAppIdPair, FacebookTimeSpentData> appSessionInfoMap;
+
+        private static final Runnable appSessionInfoFlushRunnable = new Runnable() {
+            @Override
+            public void run() {
+                PersistedAppSessionInfo.saveAppSessionInformation(applicationContext);
+            }
+        };
+
+        @SuppressWarnings("unchecked")
+        private static void restoreAppSessionInformation(Context context) {
+            ObjectInputStream ois = null;
+
+            synchronized (staticLock) {
+                if (!isLoaded) {
+                    try {
+                        ois =
+                                new ObjectInputStream(
+                                        context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
+                        appSessionInfoMap = (HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>)
+                                ois.readObject();
+                        Logger.log(
+                                LoggingBehavior.APP_EVENTS,
+                                "AppEvents",
+                                "App session info loaded");
+                    } catch (FileNotFoundException fex) {
+                    } catch (Exception e) {
+                        Log.d(TAG, "Got unexpected exception: " + e.toString());
+                    } finally {
+                        Utility.closeQuietly(ois);
+                        context.deleteFile(PERSISTED_SESSION_INFO_FILENAME);
+                        if (appSessionInfoMap == null) {
+                            appSessionInfoMap =
+                                    new HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>();
+                        }
+                        // Regardless of the outcome of the load, the session information cache
+                        // is always deleted. Therefore, always treat the session information cache
+                        // as loaded
+                        isLoaded = true;
+                        hasChanges = false;
+                    }
+                }
+            }
+        }
+
+        static void saveAppSessionInformation(Context context) {
+            ObjectOutputStream oos = null;
+
+            synchronized (staticLock) {
+                if (hasChanges) {
+                    try {
+                        oos = new ObjectOutputStream(
+                                new BufferedOutputStream(
+                                        context.openFileOutput(
+                                                PERSISTED_SESSION_INFO_FILENAME,
+                                                Context.MODE_PRIVATE)
+                                )
+                        );
+                        oos.writeObject(appSessionInfoMap);
+                        hasChanges = false;
+                        Logger.log(
+                                LoggingBehavior.APP_EVENTS,
+                                "AppEvents",
+                                "App session info saved");
+                    } catch (Exception e) {
+                        Log.d(TAG, "Got unexpected exception: " + e.toString());
+                    } finally {
+                        Utility.closeQuietly(oos);
+                    }
+                }
+            }
+        }
+
+        static void onResume(
+                Context context,
+                AccessTokenAppIdPair accessTokenAppId,
+                AppEventsLogger logger,
+                long eventTime,
+                String sourceApplicationInfo
+        ) {
+            synchronized (staticLock) {
+                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
+                timeSpentData.onResume(logger, eventTime, sourceApplicationInfo);
+                onTimeSpentDataUpdate();
+            }
+        }
+
+        static void onSuspend(
+                Context context,
+                AccessTokenAppIdPair accessTokenAppId,
+                AppEventsLogger logger,
+                long eventTime
+        ) {
+            synchronized (staticLock) {
+                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
+                timeSpentData.onSuspend(logger, eventTime);
+                onTimeSpentDataUpdate();
+            }
+        }
+
+        private static FacebookTimeSpentData getTimeSpentData(
+                Context context,
+                AccessTokenAppIdPair accessTokenAppId
+        ) {
+            restoreAppSessionInformation(context);
+            FacebookTimeSpentData result = null;
+
+            result = appSessionInfoMap.get(accessTokenAppId);
+            if (result == null) {
+                result = new FacebookTimeSpentData();
+                appSessionInfoMap.put(accessTokenAppId, result);
+            }
+
+            return result;
+        }
+
+        private static void onTimeSpentDataUpdate() {
+            if (!hasChanges) {
+                hasChanges = true;
+                backgroundExecutor.schedule(
+                        appSessionInfoFlushRunnable,
+                        FLUSH_APP_SESSION_INFO_IN_SECONDS,
+                        TimeUnit.SECONDS);
+            }
+        }
+    }
+
+    // Read/write operations are thread-safe/atomic across all instances of PersistedEvents, but
+    // modifications to any individual instance are not thread-safe.
+    static class PersistedEvents {
+        static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";
+
+        private static Object staticLock = new Object();
+
+        private Context context;
+        private HashMap<AccessTokenAppIdPair, List<AppEvent>> persistedEvents =
+                new HashMap<AccessTokenAppIdPair, List<AppEvent>>();
+
+        private PersistedEvents(Context context) {
+            this.context = context;
+        }
+
+        public static PersistedEvents readAndClearStore(Context context) {
+            synchronized (staticLock) {
+                PersistedEvents persistedEvents = new PersistedEvents(context);
+
+                persistedEvents.readAndClearStore();
+
+                return persistedEvents;
+            }
+        }
+
+        public static void persistEvents(Context context, AccessTokenAppIdPair accessTokenAppId,
+                                         SessionEventsState eventsToPersist) {
+            Map<AccessTokenAppIdPair, SessionEventsState> map = new HashMap<AccessTokenAppIdPair, SessionEventsState>();
+            map.put(accessTokenAppId, eventsToPersist);
+            persistEvents(context, map);
+        }
+
+        public static void persistEvents(
+                Context context,
+                Map<AccessTokenAppIdPair,
+                        SessionEventsState> eventsToPersist) {
+            synchronized (staticLock) {
+                // Note that we don't track which instance of AppEventsLogger added a particular
+                // event to SessionEventsState; when a particular Context is being destroyed, we'll
+                // persist all accumulated events. More sophisticated tracking could be done to try
+                // to reduce unnecessary persisting of events, but the overall number of events is
+                // not expected to be large.
+                PersistedEvents persistedEvents = readAndClearStore(context);
+
+                for (Map.Entry<AccessTokenAppIdPair, SessionEventsState> entry
+                        : eventsToPersist.entrySet()) {
+                    List<AppEvent> events = entry.getValue().getEventsToPersist();
+                    if (events.size() == 0) {
+                        continue;
+                    }
+
+                    persistedEvents.addEvents(entry.getKey(), events);
+                }
+
+                persistedEvents.write();
+            }
+        }
+
+        public Set<AccessTokenAppIdPair> keySet() {
+            return persistedEvents.keySet();
+        }
+
+        public List<AppEvent> getEvents(AccessTokenAppIdPair accessTokenAppId) {
+            return persistedEvents.get(accessTokenAppId);
+        }
+
+        private void write() {
+            ObjectOutputStream oos = null;
+            try {
+                oos = new ObjectOutputStream(
+                        new BufferedOutputStream(
+                                context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
+                oos.writeObject(persistedEvents);
+            } catch (Exception e) {
+                Log.d(TAG, "Got unexpected exception: " + e.toString());
+            } finally {
+                Utility.closeQuietly(oos);
+            }
+        }
+
+        private void readAndClearStore() {
+            ObjectInputStream ois = null;
+            try {
+                ois = new ObjectInputStream(
+                        new BufferedInputStream(context.openFileInput(PERSISTED_EVENTS_FILENAME)));
+
+                @SuppressWarnings("unchecked")
+                HashMap<AccessTokenAppIdPair, List<AppEvent>> obj =
+                        (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();
+
+                // Note: We delete the store before we store the events; this means we'd prefer to
+                // lose some events in the case of exception rather than potentially log them twice.
+                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
+                persistedEvents = obj;
+            } catch (FileNotFoundException e) {
+                // Expected if we never persisted any events.
+            } catch (Exception e) {
+                Log.d(TAG, "Got unexpected exception: " + e.toString());
+            } finally {
+                Utility.closeQuietly(ois);
+            }
+        }
+
+        public void addEvents(
+                AccessTokenAppIdPair accessTokenAppId,
+                List<AppEvent> eventsToPersist) {
+            if (!persistedEvents.containsKey(accessTokenAppId)) {
+                persistedEvents.put(accessTokenAppId, new ArrayList<AppEvent>());
+            }
+            persistedEvents.get(accessTokenAppId).addAll(eventsToPersist);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/appevents/FacebookTimeSpentData.java b/facebook/src/com/facebook/appevents/FacebookTimeSpentData.java
new file mode 100644
index 000000000..ad7e40ba9
--- /dev/null
+++ b/facebook/src/com/facebook/appevents/FacebookTimeSpentData.java
@@ -0,0 +1,326 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.os.Bundle;
+import android.text.format.DateUtils;
+
+import com.facebook.LoggingBehavior;
+import com.facebook.internal.Logger;
+
+import java.util.Locale;
+import java.io.Serializable;
+
+class FacebookTimeSpentData implements Serializable {
+    // Constants
+    private static final long serialVersionUID = 1L;
+    private static final String TAG = AppEventsLogger.class.getCanonicalName();
+    private static final long FIRST_TIME_LOAD_RESUME_TIME = -1;
+    private static final long INTERRUPTION_THRESHOLD_MILLISECONDS = 1000;
+    private static final long NUM_MILLISECONDS_IDLE_TO_BE_NEW_SESSION =
+            60 * DateUtils.SECOND_IN_MILLIS;
+    private static final long APP_ACTIVATE_SUPPRESSION_PERIOD_IN_MILLISECONDS =
+            5 * DateUtils.MINUTE_IN_MILLIS;
+
+    // Should be kept in sync with the iOS sdk
+    private static final long[] INACTIVE_SECONDS_QUANTA =
+        new long[] {
+            5 * DateUtils.MINUTE_IN_MILLIS,
+            15 * DateUtils.MINUTE_IN_MILLIS,
+            30 * DateUtils.MINUTE_IN_MILLIS,
+            1 * DateUtils.HOUR_IN_MILLIS,
+            6 * DateUtils.HOUR_IN_MILLIS,
+            12 * DateUtils.HOUR_IN_MILLIS,
+            1 * DateUtils.DAY_IN_MILLIS,
+            2 * DateUtils.DAY_IN_MILLIS,
+            3 * DateUtils.DAY_IN_MILLIS,
+            7 * DateUtils.DAY_IN_MILLIS,
+            14 * DateUtils.DAY_IN_MILLIS,
+            21 * DateUtils.DAY_IN_MILLIS,
+            28 * DateUtils.DAY_IN_MILLIS,
+            60 * DateUtils.DAY_IN_MILLIS,
+            90 * DateUtils.DAY_IN_MILLIS,
+            120 * DateUtils.DAY_IN_MILLIS,
+            150 * DateUtils.DAY_IN_MILLIS,
+            180 * DateUtils.DAY_IN_MILLIS,
+            365 * DateUtils.DAY_IN_MILLIS,
+        };
+
+    private boolean isWarmLaunch;
+    private boolean isAppActive;
+    private long lastActivateEventLoggedTime;
+
+    // Member data that's persisted to disk
+    private long lastResumeTime;
+    private long lastSuspendTime;
+    private long millisecondsSpentInSession;
+    private int interruptionCount;
+    private String firstOpenSourceApplication;
+
+    /**
+     * Serialization proxy for the FacebookTimeSpentData class. This is version 1 of
+     * serialization. Future serializations may differ in format. This
+     * class should not be modified. If serializations formats change,
+     * create a new class SerializationProxyVx.
+     */
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = 6L;
+
+        private final long lastResumeTime;
+        private final long lastSuspendTime;
+        private final long millisecondsSpentInSession;
+        private final int interruptionCount;
+
+        SerializationProxyV1(
+            long lastResumeTime,
+            long lastSuspendTime,
+            long millisecondsSpentInSession,
+            int interruptionCount
+        ) {
+            this.lastResumeTime = lastResumeTime;
+            this.lastSuspendTime = lastSuspendTime;
+            this.millisecondsSpentInSession = millisecondsSpentInSession;
+            this.interruptionCount = interruptionCount;
+        }
+
+        private Object readResolve() {
+            return new FacebookTimeSpentData(
+                lastResumeTime,
+                lastSuspendTime,
+                millisecondsSpentInSession,
+                interruptionCount);
+        }
+    }
+
+
+    /**
+     * Constructor to be used for V1 serialization only, DO NOT CHANGE.
+     */
+    private FacebookTimeSpentData(
+            long lastResumeTime,
+            long lastSuspendTime,
+            long millisecondsSpentInSession,
+            int interruptionCount
+
+    ) {
+        resetSession();
+        this.lastResumeTime = lastResumeTime;
+        this.lastSuspendTime = lastSuspendTime;
+        this.millisecondsSpentInSession = millisecondsSpentInSession;
+        this.interruptionCount = interruptionCount;
+    }
+
+    /**
+     * Serialization proxy for the FacebookTimeSpentData class. This is version 2 of
+     * serialization. Future serializations may differ in format. This
+     * class should not be modified. If serializations formats change,
+     * create a new class SerializationProxyVx.
+     */
+    private static class SerializationProxyV2 implements Serializable {
+        private static final long serialVersionUID = 6L;
+
+        private final long lastResumeTime;
+        private final long lastSuspendTime;
+        private final long millisecondsSpentInSession;
+        private final int interruptionCount;
+        private final String firstOpenSourceApplication;
+
+        SerializationProxyV2(
+                long lastResumeTime,
+                long lastSuspendTime,
+                long millisecondsSpentInSession,
+                int interruptionCount,
+                String firstOpenSourceApplication
+
+        ) {
+            this.lastResumeTime = lastResumeTime;
+            this.lastSuspendTime = lastSuspendTime;
+            this.millisecondsSpentInSession = millisecondsSpentInSession;
+            this.interruptionCount = interruptionCount;
+            this.firstOpenSourceApplication = firstOpenSourceApplication;
+        }
+
+        private Object readResolve() {
+            return new FacebookTimeSpentData(
+                    lastResumeTime,
+                    lastSuspendTime,
+                    millisecondsSpentInSession,
+                    interruptionCount,
+                    firstOpenSourceApplication);
+        }
+    }
+
+    FacebookTimeSpentData() {
+        resetSession();
+    }
+
+    /**
+     * Constructor to be used for V2 serialization only, DO NOT CHANGE.
+     */
+    private FacebookTimeSpentData(
+        long lastResumeTime,
+        long lastSuspendTime,
+        long millisecondsSpentInSession,
+        int interruptionCount,
+        String firstOpenSourceApplication
+    ) {
+        resetSession();
+        this.lastResumeTime = lastResumeTime;
+        this.lastSuspendTime = lastSuspendTime;
+        this.millisecondsSpentInSession = millisecondsSpentInSession;
+        this.interruptionCount = interruptionCount;
+        this.firstOpenSourceApplication = firstOpenSourceApplication;
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV2(
+                lastResumeTime,
+                lastSuspendTime,
+                millisecondsSpentInSession,
+                interruptionCount,
+                firstOpenSourceApplication
+        );
+    }
+
+    void onSuspend(AppEventsLogger logger, long eventTime) {
+        if (!isAppActive) {
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Suspend for inactive app");
+            return;
+        }
+
+        long now = eventTime;
+        long delta = (now - lastResumeTime);
+        if (delta < 0) {
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Clock skew detected");
+            delta = 0;
+        }
+        millisecondsSpentInSession += delta;
+        lastSuspendTime = now;
+        isAppActive = false;
+    }
+
+    void onResume(AppEventsLogger logger, long eventTime, String sourceApplicationInfo) {
+        long now = eventTime;
+
+        // Retain old behavior for activated app event - log the event if the event hasn't
+        // been logged in the previous suppression interval or this is a cold launch.
+        // If this is a cold launch, always log the event. Otherwise, use the last
+        // event log time to determine if the app activate should be suppressed or not.
+        if (isColdLaunch() || ((now - lastActivateEventLoggedTime) >
+                APP_ACTIVATE_SUPPRESSION_PERIOD_IN_MILLISECONDS)) {
+            Bundle eventParams = new Bundle();
+            eventParams.putString(
+                    AppEventsConstants.EVENT_PARAM_SOURCE_APPLICATION,
+                    sourceApplicationInfo);
+            logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP, eventParams);
+            lastActivateEventLoggedTime = now;
+        }
+
+        // If this is an application that's not calling onSuspend yet, log and return. We can't
+        // track time spent for this application as there are no calls to onSuspend.
+        if (isAppActive) {
+          Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Resume for active app");
+          return;
+        }
+
+        long interruptionDurationMillis = wasSuspendedEver() ? now - lastSuspendTime : 0;
+        if (interruptionDurationMillis < 0) {
+          Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Clock skew detected");
+          interruptionDurationMillis = 0;
+        }
+
+        // If interruption duration is > new session threshold, then log old session
+        // event and start a new session.
+        if (interruptionDurationMillis > NUM_MILLISECONDS_IDLE_TO_BE_NEW_SESSION) {
+            logAppDeactivatedEvent(logger, interruptionDurationMillis);
+        } else {
+            // We're not logging this resume event - check to see if this should count
+            // as an interruption
+            if (interruptionDurationMillis > INTERRUPTION_THRESHOLD_MILLISECONDS) {
+                interruptionCount++;
+            }
+        }
+
+        // Set source application only for the first resume of the timespent session.
+        if (interruptionCount == 0) {
+            firstOpenSourceApplication = sourceApplicationInfo;
+        }
+
+        lastResumeTime = now;
+        isAppActive = true;
+    }
+
+    private void logAppDeactivatedEvent(AppEventsLogger logger,
+                                        long interruptionDurationMillis) {
+        // Log the old session information and clear the data
+        Bundle eventParams = new Bundle();
+        eventParams.putInt(
+                AppEventsConstants.EVENT_NAME_SESSION_INTERRUPTIONS,
+                interruptionCount);
+        eventParams.putString(
+                AppEventsConstants.EVENT_NAME_TIME_BETWEEN_SESSIONS,
+                String.format(
+                        Locale.ROOT,
+                        "session_quanta_%d",
+                        getQuantaIndex(interruptionDurationMillis)));
+        eventParams.putString(
+                AppEventsConstants.EVENT_PARAM_SOURCE_APPLICATION,
+                firstOpenSourceApplication);
+        logger.logEvent(
+                AppEventsConstants.EVENT_NAME_DEACTIVATED_APP,
+                (millisecondsSpentInSession/DateUtils.SECOND_IN_MILLIS),
+                eventParams);
+        resetSession();
+    }
+
+    private static int getQuantaIndex(long timeBetweenSessions) {
+        int quantaIndex = 0;
+
+        while (
+            quantaIndex < INACTIVE_SECONDS_QUANTA.length &&
+            INACTIVE_SECONDS_QUANTA[quantaIndex] < timeBetweenSessions
+        ) {
+            ++quantaIndex;
+        }
+
+        return quantaIndex;
+    }
+
+    private void resetSession() {
+        isAppActive = false;
+        lastResumeTime = FIRST_TIME_LOAD_RESUME_TIME;
+        lastSuspendTime = FIRST_TIME_LOAD_RESUME_TIME;
+        interruptionCount = 0;
+        millisecondsSpentInSession = 0;
+    }
+
+    private boolean wasSuspendedEver() {
+        return lastSuspendTime != FIRST_TIME_LOAD_RESUME_TIME;
+    }
+
+    private boolean isColdLaunch() {
+        // On the very first call in the process lifecycle, this will always
+        // return true. After that, it will always return false.
+        boolean result = !isWarmLaunch;
+        isWarmLaunch = true;
+        return result;
+    }
+}
diff --git a/facebook/src/com/facebook/AppLinkData.java b/facebook/src/com/facebook/applinks/AppLinkData.java
similarity index 58%
rename from facebook/src/com/facebook/AppLinkData.java
rename to facebook/src/com/facebook/applinks/AppLinkData.java
index 2c68b04cc..c49c8fc99 100644
--- a/facebook/src/com/facebook/AppLinkData.java
+++ b/facebook/src/com/facebook/applinks/AppLinkData.java
@@ -1,33 +1,42 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook;
+package com.facebook.applinks;
 
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Log;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.PlatformServiceClient;
+
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AttributionIdentifiers;
 import com.facebook.internal.Utility;
 import com.facebook.internal.Validate;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,12 +44,14 @@
 import java.util.Iterator;
 
 /**
- * Class to encapsulate an app link, and provide methods for constructing the data from various sources
+ * Class to encapsulate an app link, and provide methods for constructing the data from various
+ * sources
  */
 public class AppLinkData {
 
     /**
-     * Key that should be used to pull out the UTC Unix tap-time from the arguments for this app link.
+     * Key that should be used to pull out the UTC Unix tap-time from the arguments for this app
+     * link.
      */
     public static final String ARGUMENTS_TAPTIME_KEY = "com.facebook.platform.APPLINK_TAP_TIME_UTC";
     /**
@@ -48,12 +59,33 @@
      */
     public static final String ARGUMENTS_REFERER_DATA_KEY = "referer_data";
 
+    /**
+     * Key that should be used to pull out the native class that would have been used if the applink
+     * was deferred.
+     */
+    public static final String ARGUMENTS_NATIVE_CLASS_KEY =
+            "com.facebook.platform.APPLINK_NATIVE_CLASS";
+
+    /**
+     * Key that should be used to pull out the native url that would have been used if the applink
+     * was deferred.
+     */
+    public static final String ARGUMENTS_NATIVE_URL = "com.facebook.platform.APPLINK_NATIVE_URL";
+
     static final String BUNDLE_APPLINK_ARGS_KEY = "com.facebook.platform.APPLINK_ARGS";
     private static final String BUNDLE_AL_APPLINK_DATA_KEY = "al_applink_data";
     private static final String APPLINK_BRIDGE_ARGS_KEY = "bridge_args";
     private static final String APPLINK_METHOD_ARGS_KEY = "method_args";
     private static final String APPLINK_VERSION_KEY = "version";
     private static final String BRIDGE_ARGS_METHOD_KEY = "method";
+    private static final String DEFERRED_APP_LINK_EVENT = "DEFERRED_APP_LINK";
+    private static final String DEFERRED_APP_LINK_PATH = "%s/activities";
+
+    private static final String DEFERRED_APP_LINK_ARGS_FIELD = "applink_args";
+    private static final String DEFERRED_APP_LINK_CLASS_FIELD = "applink_class";
+    private static final String DEFERRED_APP_LINK_CLICK_TIME_FIELD = "click_time";
+    private static final String DEFERRED_APP_LINK_URL_FIELD = "applink_url";
+
     private static final String METHOD_ARGS_TARGET_URL_KEY = "target_url";
     private static final String METHOD_ARGS_REF_KEY = "ref";
     private static final String REFERER_DATA_REF_KEY = "fb_ref";
@@ -65,23 +97,27 @@
     private Bundle argumentBundle;
 
     /**
-     * Asynchronously fetches app link information that might have been stored for use
-     * after installation of the app
-     * @param context The context
-     * @param completionHandler CompletionHandler to be notified with the AppLinkData object or null if none is
-     *                          available.  Must not be null.
+     * Asynchronously fetches app link information that might have been stored for use after
+     * installation of the app
+     *
+     * @param context           The context
+     * @param completionHandler CompletionHandler to be notified with the AppLinkData object or null
+     *                          if none is available.  Must not be null.
      */
-    public static void fetchDeferredAppLinkData(Context context, CompletionHandler completionHandler) {
+    public static void fetchDeferredAppLinkData(
+            Context context,
+            CompletionHandler completionHandler) {
         fetchDeferredAppLinkData(context, null, completionHandler);
     }
 
     /**
-     * Asynchronously fetches app link information that might have been stored for use
-     * after installation of the app
-     * @param context The context
-     * @param applicationId Facebook application Id. If null, it is taken from the manifest
-     * @param completionHandler CompletionHandler to be notified with the AppLinkData object or null if none is
-     *                          available.  Must not be null.
+     * Asynchronously fetches app link information that might have been stored for use after
+     * installation of the app
+     *
+     * @param context           The context
+     * @param applicationId     Facebook application Id. If null, it is taken from the manifest
+     * @param completionHandler CompletionHandler to be notified with the AppLinkData object or null
+     *                          if none is available.  Must not be null.
      */
     public static void fetchDeferredAppLinkData(
             Context context,
@@ -96,46 +132,103 @@ public static void fetchDeferredAppLinkData(
 
         Validate.notNull(applicationId, "applicationId");
 
-        DeferredAppLinkDataClient client = new DeferredAppLinkDataClient(context, applicationId);
-        DeferredAppLinkDataClient.CompletedListener callback = new DeferredAppLinkDataClient.CompletedListener() {
+        final Context applicationContext = context.getApplicationContext();
+        final String applicationIdCopy = applicationId;
+        FacebookSdk.getExecutor().execute(new Runnable() {
             @Override
-            public void completed(Bundle result) {
-                AppLinkData appLinkData = null;
-                if (result != null) {
-                    final String appLinkArgsJsonString = result.getString(BUNDLE_APPLINK_ARGS_KEY);
-                    final long tapTimeUtc = result.getLong(ARGUMENTS_TAPTIME_KEY, -1);
+            public void run() {
+                fetchDeferredAppLinkFromServer(
+                        applicationContext, applicationIdCopy, completionHandler);
+            }
+        });
+    }
 
-                    // Now create the app link
+    private static void fetchDeferredAppLinkFromServer(
+            Context context,
+            String applicationId,
+            final CompletionHandler completionHandler) {
+
+        JSONObject deferredApplinkParams = new JSONObject();
+        try {
+            deferredApplinkParams.put("event", DEFERRED_APP_LINK_EVENT);
+            Utility.setAppEventAttributionParameters(deferredApplinkParams,
+                    AttributionIdentifiers.getAttributionIdentifiers(context),
+                    AppEventsLogger.getAnonymousAppDeviceGUID(context),
+                    FacebookSdk.getLimitEventAndDataUsage(context));
+            deferredApplinkParams.put("application_package_name", context.getPackageName());
+        } catch (JSONException e) {
+            throw new FacebookException("An error occurred while preparing deferred app link", e);
+        }
+
+        String deferredApplinkUrlPath = String.format(DEFERRED_APP_LINK_PATH, applicationId);
+        AppLinkData appLinkData = null;
+
+        try {
+            GraphRequest deferredApplinkRequest = GraphRequest.newPostRequest(
+                    null, deferredApplinkUrlPath, deferredApplinkParams, null);
+            GraphResponse deferredApplinkResponse = deferredApplinkRequest.executeAndWait();
+            JSONObject jsonResponse = deferredApplinkResponse.getJSONObject();
+            if (jsonResponse != null) {
+                final String appLinkArgsJsonString =
+                        jsonResponse.optString(DEFERRED_APP_LINK_ARGS_FIELD);
+                final long tapTimeUtc =
+                        jsonResponse.optLong(DEFERRED_APP_LINK_CLICK_TIME_FIELD, -1);
+                final String appLinkClassName =
+                        jsonResponse.optString(DEFERRED_APP_LINK_CLASS_FIELD);
+                final String appLinkUrl = jsonResponse.optString(DEFERRED_APP_LINK_URL_FIELD);
+
+                if (!TextUtils.isEmpty(appLinkArgsJsonString)) {
                     appLinkData = createFromJson(appLinkArgsJsonString);
+
                     if (tapTimeUtc != -1) {
                         try {
                             if (appLinkData.arguments != null) {
                                 appLinkData.arguments.put(ARGUMENTS_TAPTIME_KEY, tapTimeUtc);
                             }
                             if (appLinkData.argumentBundle != null) {
-                                appLinkData.argumentBundle.putString(ARGUMENTS_TAPTIME_KEY, Long.toString(tapTimeUtc));
+                                appLinkData.argumentBundle.putString(
+                                        ARGUMENTS_TAPTIME_KEY, Long.toString(tapTimeUtc));
+                            }
+                        } catch (JSONException e) {
+                            Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
+                        }
+                    }
+
+                    if (appLinkClassName != null) {
+                        try {
+                            if (appLinkData.arguments != null) {
+                                appLinkData.arguments.put(
+                                        ARGUMENTS_NATIVE_CLASS_KEY, appLinkClassName);
+                            }
+                            if (appLinkData.argumentBundle != null) {
+                                appLinkData.argumentBundle.putString(
+                                        ARGUMENTS_NATIVE_CLASS_KEY, appLinkClassName);
+                            }
+                        } catch (JSONException e) {
+                            Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
+                        }
+                    }
+
+                    if (appLinkUrl != null) {
+                        try {
+                            if (appLinkData.arguments != null) {
+                                appLinkData.arguments.put(ARGUMENTS_NATIVE_URL, appLinkUrl);
+                            }
+                            if (appLinkData.argumentBundle != null) {
+                                appLinkData.argumentBundle.putString(
+                                        ARGUMENTS_NATIVE_URL, appLinkUrl);
                             }
                         } catch (JSONException e) {
                             Log.d(TAG, "Unable to put tap time in AppLinkData.arguments");
                         }
                     }
                 }
-                completionHandler.onDeferredAppLinkDataFetched(appLinkData);
             }
-        };
-        client.setCompletedListener(callback);
-
-        if (!client.start()) {
-            // there is not a sufficient version of fb4a present to return a deferred app link, so kick off
-            // a call to the completion handler.
-            Handler handler = new Handler(Looper.getMainLooper());
-            handler.post(new Runnable() {
-                @Override
-                public void run() {
-                    completionHandler.onDeferredAppLinkDataFetched(null);
-                }
-            });
+        } catch (Exception e) {
+            Utility.logd(TAG, "Unable to fetch deferred applink from server");
         }
+
+        completionHandler.onDeferredAppLinkDataFetched(appLinkData);
     }
 
     /**
@@ -209,14 +302,16 @@ private static AppLinkData createFromJson(String jsonString) {
                     appLinkData.ref = appLinkData.arguments.getString(METHOD_ARGS_REF_KEY);
                 } else if (appLinkData.arguments.has(ARGUMENTS_REFERER_DATA_KEY)) {
                     // if it's not in the top level args, it could be in the "referer_data" blob
-                    JSONObject refererData = appLinkData.arguments.getJSONObject(ARGUMENTS_REFERER_DATA_KEY);
+                    JSONObject refererData = appLinkData.arguments.getJSONObject(
+                            ARGUMENTS_REFERER_DATA_KEY);
                     if (refererData.has(REFERER_DATA_REF_KEY)) {
                         appLinkData.ref = refererData.getString(REFERER_DATA_REF_KEY);
                     }
                 }
 
                 if (appLinkData.arguments.has(METHOD_ARGS_TARGET_URL_KEY)) {
-                    appLinkData.targetUri = Uri.parse(appLinkData.arguments.getString(METHOD_ARGS_TARGET_URL_KEY));
+                    appLinkData.targetUri = Uri.parse(
+                            appLinkData.arguments.getString(METHOD_ARGS_TARGET_URL_KEY));
                 }
 
                 appLinkData.argumentBundle = toBundle(appLinkData.arguments);
@@ -303,15 +398,6 @@ public String getRef() {
         return ref;
     }
 
-    /**
-     * This method has been deprecated. Please use {@link AppLinkData#getArgumentBundle()} instead.
-     * @return JSONObject property bag.
-     */
-    @Deprecated
-    public JSONObject getArguments() {
-        return arguments;
-    }
-
     /**
      * The full set of arguments for this app link. Properties like target uri & ref are typically
      * picked out of this set of arguments.
@@ -322,8 +408,9 @@ public Bundle getArgumentBundle() {
     }
 
     /**
-     * The referer data associated with the app link. This will contain Facebook specific information like
-     * fb_access_token, fb_expires_in, and fb_ref.
+     * The referer data associated with the app link. This will contain Facebook specific
+     * information like fb_access_token, fb_expires_in, and fb_ref.
+     *
      * @return the referer data.
      */
     public Bundle getRefererData() {
@@ -338,24 +425,11 @@ public Bundle getRefererData() {
      */
     public interface CompletionHandler {
         /**
-         * This method is called when deferred app link data has been fetched. If no app link data was found,
-         * this method is called with null
+         * This method is called when deferred app link data has been fetched. If no app link data
+         * was found, this method is called with null
+         *
          * @param appLinkData The app link data that was fetched. Null if none was found.
          */
         void onDeferredAppLinkDataFetched(AppLinkData appLinkData);
     }
-
-    final static class DeferredAppLinkDataClient extends PlatformServiceClient {
-
-        DeferredAppLinkDataClient(Context context, String applicationId) {
-            super(context, NativeProtocol.MESSAGE_GET_INSTALL_DATA_REQUEST, NativeProtocol.MESSAGE_GET_INSTALL_DATA_REPLY,
-                    NativeProtocol.PROTOCOL_VERSION_20130618, applicationId);
-        }
-
-        @Override
-        protected void populateRequestBundle(Bundle data) {
-            String packageName = getContext().getPackageName();
-            data.putString(NativeProtocol.EXTRA_GET_INSTALL_DATA_PACKAGE, packageName);
-        }
-    }
 }
diff --git a/facebook/src/com/facebook/applinks/FacebookAppLinkResolver.java b/facebook/src/com/facebook/applinks/FacebookAppLinkResolver.java
new file mode 100644
index 000000000..7db436eda
--- /dev/null
+++ b/facebook/src/com/facebook/applinks/FacebookAppLinkResolver.java
@@ -0,0 +1,260 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.applinks;
+
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.facebook.FacebookRequestError;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+
+import bolts.AppLink;
+import bolts.AppLinkResolver;
+import bolts.Continuation;
+import bolts.Task;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+/**
+ * Provides an implementation for the {@link AppLinkResolver AppLinkResolver} interface that uses
+ * the Facebook App Link index to resolve App Links given a URL. It also provides an additional
+ * helper method that can resolve multiple App Links in a single call.
+ */
+public class FacebookAppLinkResolver implements AppLinkResolver {
+
+    private static final String APP_LINK_KEY = "app_links";
+    private static final String APP_LINK_ANDROID_TARGET_KEY = "android";
+    private static final String APP_LINK_WEB_TARGET_KEY = "web";
+    private static final String APP_LINK_TARGET_PACKAGE_KEY = "package";
+    private static final String APP_LINK_TARGET_CLASS_KEY = "class";
+    private static final String APP_LINK_TARGET_APP_NAME_KEY = "app_name";
+    private static final String APP_LINK_TARGET_URL_KEY = "url";
+    private static final String APP_LINK_TARGET_SHOULD_FALLBACK_KEY = "should_fallback";
+
+    private final HashMap<Uri, AppLink> cachedAppLinks = new HashMap<Uri, AppLink>();
+
+    /**
+     * Asynchronously resolves App Link data for the passed in Uri
+     *
+     * @param uri Uri to be resolved into an App Link
+     * @return A Task that, when successful, will return an AppLink for the passed in Uri. This may
+     * be null if no App Link data was found for this Uri. In the case of general server errors, the
+     * task will be completed with the corresponding error.
+     */
+    public Task<AppLink> getAppLinkFromUrlInBackground(final Uri uri) {
+        ArrayList<Uri> uris = new ArrayList<Uri>();
+        uris.add(uri);
+
+        Task<Map<Uri, AppLink>> resolveTask = getAppLinkFromUrlsInBackground(uris);
+
+        return resolveTask.onSuccess(new Continuation<Map<Uri, AppLink>, AppLink>() {
+            @Override
+            public AppLink then(Task<Map<Uri, AppLink>> resolveUrisTask) throws Exception {
+                return resolveUrisTask.getResult().get(uri);
+            }
+        });
+    }
+
+    /**
+     * Asynchronously resolves App Link data for multiple URLs
+     *
+     * @param uris A list of Uri objects to resolve into App Links
+     * @return A Task that, when successful, will return a Map of Uri->AppLink for each Uri that was
+     * successfully resolved into an App Link. Uris that could not be resolved into App Links will
+     * not be present in the Map. In the case of general server errors, the task will be completed
+     * with the corresponding error.
+     */
+    public Task<Map<Uri, AppLink>> getAppLinkFromUrlsInBackground(List<Uri> uris) {
+        final Map<Uri, AppLink> appLinkResults = new HashMap<Uri, AppLink>();
+        final HashSet<Uri> urisToRequest = new HashSet<Uri>();
+        StringBuilder graphRequestFields = new StringBuilder();
+
+        for (Uri uri : uris) {
+            AppLink appLink = null;
+            synchronized (cachedAppLinks) {
+                appLink = cachedAppLinks.get(uri);
+            }
+
+            if (appLink != null) {
+                appLinkResults.put(uri, appLink);
+            } else {
+                if (!urisToRequest.isEmpty()) {
+                    graphRequestFields.append(',');
+                }
+                graphRequestFields.append(uri.toString());
+                urisToRequest.add(uri);
+            }
+        }
+
+        if (urisToRequest.isEmpty()) {
+            return Task.forResult(appLinkResults);
+        }
+
+        final Task<Map<Uri, AppLink>>.TaskCompletionSource taskCompletionSource = Task.create();
+
+        Bundle appLinkRequestParameters = new Bundle();
+
+        appLinkRequestParameters.putString("ids", graphRequestFields.toString());
+        appLinkRequestParameters.putString(
+                "fields",
+                String.format(
+                        "%s.fields(%s,%s)",
+                        APP_LINK_KEY,
+                        APP_LINK_ANDROID_TARGET_KEY,
+                        APP_LINK_WEB_TARGET_KEY));
+
+        GraphRequest appLinkRequest = new GraphRequest(
+                null, /* Access Token */
+                "", /* Graph path */
+                appLinkRequestParameters, /* Query parameters */
+                null, /* HttpMethod */
+                new GraphRequest.Callback() { /* Callback */
+                    @Override
+                    public void onCompleted(GraphResponse response) {
+                        FacebookRequestError error = response.getError();
+                        if (error != null) {
+                            taskCompletionSource.setError(error.getException());
+                            return;
+                        }
+
+                        JSONObject responseJson = response.getJSONObject();
+                        if (responseJson == null) {
+                            taskCompletionSource.setResult(appLinkResults);
+                            return;
+                        }
+
+                        for (Uri uri : urisToRequest) {
+                            String uriString = uri.toString();
+                            if (!responseJson.has(uriString)) {
+                                continue;
+                            }
+
+                            JSONObject urlData = null;
+                            try {
+                                urlData = responseJson.getJSONObject(uri.toString());
+                                JSONObject appLinkData = urlData.getJSONObject(APP_LINK_KEY);
+
+                                JSONArray rawTargets =
+                                        appLinkData.getJSONArray(APP_LINK_ANDROID_TARGET_KEY);
+
+                                int targetsCount = rawTargets.length();
+                                List<AppLink.Target> targets = new ArrayList<AppLink.Target>(targetsCount);
+
+                                for (int i = 0; i < targetsCount; i++) {
+                                    AppLink.Target target =
+                                            getAndroidTargetFromJson(rawTargets.getJSONObject(i));
+                                    if (target != null) {
+                                        targets.add(target);
+                                    }
+                                }
+
+                                Uri webFallbackUrl = getWebFallbackUriFromJson(uri, appLinkData);
+                                AppLink appLink = new AppLink(uri, targets, webFallbackUrl);
+
+                                appLinkResults.put(uri, appLink);
+                                synchronized (cachedAppLinks) {
+                                    cachedAppLinks.put(uri, appLink);
+                                }
+                            } catch (JSONException e) {
+                                // The data for this uri was missing or badly formed.
+                                continue;
+                            }
+                        }
+
+                        taskCompletionSource.setResult(appLinkResults);
+                    }
+                });
+
+        appLinkRequest.executeAsync();
+
+        return taskCompletionSource.getTask();
+    }
+
+    private static AppLink.Target getAndroidTargetFromJson(JSONObject targetJson) {
+        String packageName = tryGetStringFromJson(targetJson, APP_LINK_TARGET_PACKAGE_KEY, null);
+        if (packageName == null) {
+            // Package name is mandatory for each Android target
+            return null;
+        }
+        String className = tryGetStringFromJson(targetJson, APP_LINK_TARGET_CLASS_KEY, null);
+        String appName = tryGetStringFromJson(targetJson, APP_LINK_TARGET_APP_NAME_KEY, null);
+        String targetUrlString = tryGetStringFromJson(targetJson, APP_LINK_TARGET_URL_KEY, null);
+        Uri targetUri = null;
+        if (targetUrlString != null) {
+            targetUri = Uri.parse(targetUrlString);
+        }
+
+        return new AppLink.Target(packageName, className, targetUri, appName);
+    }
+
+    private static Uri getWebFallbackUriFromJson(Uri sourceUrl, JSONObject urlData) {
+        // Try and get a web target. This is best effort. Any failures results in null being
+        // returned.
+        try {
+            JSONObject webTarget = urlData.getJSONObject(APP_LINK_WEB_TARGET_KEY);
+            boolean shouldFallback = tryGetBooleanFromJson(
+                    webTarget, APP_LINK_TARGET_SHOULD_FALLBACK_KEY, true);
+            if (!shouldFallback) {
+                // Don't use a fallback url
+                return null;
+            }
+
+            String webTargetUrlString =
+                    tryGetStringFromJson(webTarget, APP_LINK_TARGET_URL_KEY, null);
+            Uri webUri = null;
+            if (webTargetUrlString != null) {
+                webUri = Uri.parse(webTargetUrlString);
+            }
+
+            // If we weren't able to parse a url from the web target, use the source url
+            return webUri != null ? webUri: sourceUrl;
+        } catch (JSONException e) {
+            // If we were missing a web target, just use the source as the web url
+            return sourceUrl;
+        }
+    }
+
+    private static String tryGetStringFromJson(
+            JSONObject json,
+            String propertyName,
+            String defaultValue) {
+        try {
+            return json.getString(propertyName);
+        } catch(JSONException e) {
+            return defaultValue;
+        }
+    }
+
+    private static boolean tryGetBooleanFromJson(
+            JSONObject json,
+            String propertyName,
+            boolean defaultValue) {
+        try {
+            return json.getBoolean(propertyName);
+        } catch (JSONException e) {
+            return defaultValue;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/AnalyticsEvents.java b/facebook/src/com/facebook/internal/AnalyticsEvents.java
index e01ac4371..dddd089bb 100644
--- a/facebook/src/com/facebook/internal/AnalyticsEvents.java
+++ b/facebook/src/com/facebook/internal/AnalyticsEvents.java
@@ -1,9 +1,29 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
 package com.facebook.internal;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public class AnalyticsEvents {
     public static final String EVENT_NATIVE_LOGIN_DIALOG_COMPLETE   = "fb_dialogs_native_login_dialog_complete";
@@ -13,10 +33,13 @@
     public static final String EVENT_PLACE_PICKER_USAGE             = "fb_place_picker_usage";
     public static final String EVENT_LOGIN_VIEW_USAGE               = "fb_login_view_usage";
     public static final String EVENT_USER_SETTINGS_USAGE            = "fb_user_settings_vc_usage";
+    public static final String EVENT_NATIVE_DIALOG_START            = "fb_native_dialog_start";
+    public static final String EVENT_NATIVE_DIALOG_COMPLETE         = "fb_native_dialog_complete";
 
     public static final String PARAMETER_WEB_LOGIN_E2E                  = "fb_web_login_e2e";
     public static final String PARAMETER_WEB_LOGIN_SWITCHBACK_TIME      = "fb_web_login_switchback_time";
     public static final String PARAMETER_APP_ID                         = "app_id";
+    public static final String PARAMETER_CALL_ID                        = "call_id";
     public static final String PARAMETER_ACTION_ID                      = "action_id";
     public static final String PARAMETER_NATIVE_LOGIN_DIALOG_START_TIME = "fb_native_login_dialog_start_time";
     public static final String PARAMETER_NATIVE_LOGIN_DIALOG_COMPLETE_TIME =
@@ -28,4 +51,59 @@
     public static final String PARAMETER_DIALOG_OUTCOME_VALUE_CANCELLED = "Cancelled";
     public static final String PARAMETER_DIALOG_OUTCOME_VALUE_FAILED    = "Failed";
 
+    public static final String EVENT_NATIVE_DIALOG_TYPE_SHARE           = "fb_dialogs_present_share";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_MESSAGE         = "fb_dialogs_present_message";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_OG_SHARE        = "fb_dialogs_present_share_og";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_OG_MESSAGE      = "fb_dialogs_present_message_og";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_PHOTO_SHARE     = "fb_dialogs_present_share_photo";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_PHOTO_MESSAGE   = "fb_dialogs_present_message_photo";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_VIDEO_SHARE     = "fb_dialogs_present_share_video";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_LIKE            = "fb_dialogs_present_like";
+
+    public static final String EVENT_LIKE_VIEW_CANNOT_PRESENT_DIALOG    = "fb_like_control_cannot_present_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_LIKE                 = "fb_like_control_did_like";
+    public static final String EVENT_LIKE_VIEW_DID_PRESENT_DIALOG       = "fb_like_control_did_present_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_PRESENT_FALLBACK     = "fb_like_control_did_present_fallback_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_TAP                  = "fb_like_control_did_tap";
+    public static final String EVENT_LIKE_VIEW_DID_UNLIKE               = "fb_like_control_did_unlike";
+    public static final String EVENT_LIKE_VIEW_DID_UNDO_QUICKLY         = "fb_like_control_did_undo_quickly";
+    public static final String EVENT_LIKE_VIEW_DIALOG_DID_SUCCEED       = "fb_like_control_dialog_did_succeed";
+    public static final String EVENT_LIKE_VIEW_ERROR                    = "fb_like_control_error";
+
+    public static final String PARAMETER_LIKE_VIEW_STYLE                = "style";
+    public static final String PARAMETER_LIKE_VIEW_AUXILIARY_POSITION   = "auxiliary_position";
+    public static final String PARAMETER_LIKE_VIEW_HORIZONTAL_ALIGNMENT = "horizontal_alignment";
+    public static final String PARAMETER_LIKE_VIEW_OBJECT_ID            = "object_id";
+    public static final String PARAMETER_LIKE_VIEW_OBJECT_TYPE          = "object_type";
+    public static final String PARAMETER_LIKE_VIEW_CURRENT_ACTION       = "current_action";
+    public static final String PARAMETER_LIKE_VIEW_ERROR_JSON           = "error";
+
+    public static final String PARAMETER_SHARE_OUTCOME                  = "fb_share_dialog_outcome";
+    public static final String PARAMETER_SHARE_OUTCOME_SUCCEEDED        = "succeeded";
+    public static final String PARAMETER_SHARE_OUTCOME_CANCELLED        = "cancelled";
+    public static final String PARAMETER_SHARE_OUTCOME_ERROR            = "error";
+    public static final String PARAMETER_SHARE_OUTCOME_UNKNOWN          = "unknown";
+    public static final String PARAMETER_SHARE_ERROR_MESSAGE            = "error_message";
+
+    public static final String PARAMETER_SHARE_DIALOG_SHOW              = "fb_share_dialog_show";
+    public static final String PARAMETER_SHARE_DIALOG_SHOW_WEB          = "web";
+    public static final String PARAMETER_SHARE_DIALOG_SHOW_NATIVE       = "native";
+    public static final String PARAMETER_SHARE_DIALOG_SHOW_AUTOMATIC    = "automatic";
+    public static final String PARAMETER_SHARE_DIALOG_SHOW_UNKNOWN      = "unknown";
+
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_TYPE      =
+            "fb_share_dialog_content_type";
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_VIDEO     = "video";
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_PHOTO     = "photo";
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_STATUS    = "status";
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_OPENGRAPH = "open_graph";
+    public static final String PARAMETER_SHARE_DIALOG_CONTENT_UNKNOWN   = "unknown";
+
+    public static final String EVENT_SHARE_RESULT = "fb_share_dialog_result";
+    public static final String EVENT_SHARE_DIALOG_SHOW                  = "fb_share_dialog_show";
+
+    public static final String EVENT_LIKE_BUTTON_CREATE                 = "fb_like_button_create";
+    public static final String EVENT_LOGIN_BUTTON_CREATE                = "fb_login_button_create";
+    public static final String EVENT_SHARE_BUTTON_CREATE                = "fb_share_button_create";
+    public static final String EVENT_SEND_BUTTON_CREATE                 = "fb_send_button_create";
 }
diff --git a/facebook/src/com/facebook/internal/AppCall.java b/facebook/src/com/facebook/internal/AppCall.java
new file mode 100644
index 000000000..e2bb3e8bd
--- /dev/null
+++ b/facebook/src/com/facebook/internal/AppCall.java
@@ -0,0 +1,131 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Intent;
+
+import java.util.UUID;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class AppCall {
+    private static AppCall currentPendingCall;
+
+    public static AppCall getCurrentPendingCall() {
+        return currentPendingCall;
+    }
+
+    public static synchronized AppCall finishPendingCall(
+            UUID callId,
+            int requestCode) {
+        AppCall pendingCall = getCurrentPendingCall();
+        if (pendingCall == null ||
+                !pendingCall.getCallId().equals(callId) ||
+                pendingCall.getRequestCode() != requestCode) {
+            return null;
+        }
+
+        setCurrentPendingCall(null);
+
+        return pendingCall;
+    }
+
+    private static synchronized boolean setCurrentPendingCall(
+            AppCall appCall) {
+        AppCall oldAppCall = getCurrentPendingCall();
+        currentPendingCall = appCall;
+
+        return oldAppCall != null;
+    }
+
+    private UUID callId;
+    private Intent requestIntent;
+    private int requestCode;
+
+    /**
+     * Constructor.
+     *
+     * @param requestCode the request code for this app call
+     */
+    public AppCall(int requestCode) {
+        this(requestCode, UUID.randomUUID());
+    }
+
+    /**
+     * Constructor
+     *
+     * @param requestCode the request code for this app call
+     * @param callId the call Id for this app call
+     */
+    public AppCall(int requestCode, UUID callId) {
+        this.callId = callId;
+        this.requestCode = requestCode;
+    }
+
+    /**
+     * Returns the Intent that was used to initiate this call to the
+     * Facebook application.
+     *
+     * @return the Intent
+     */
+    public Intent getRequestIntent() {
+        return requestIntent;
+    }
+
+    /**
+     * Returns the unique ID of this call to the Facebook application.
+     *
+     * @return the unique ID
+     */
+    public UUID getCallId() {
+        return callId;
+    }
+
+    /**
+     * Gets the request code for this call.
+     *
+     * @return the request code that will be passed to
+     * handleActivityResult upon completion.
+     */
+    public int getRequestCode() {
+        return requestCode;
+    }
+
+    public void setRequestCode(int requestCode) {
+        this.requestCode = requestCode;
+    }
+
+    public void setRequestIntent(Intent requestIntent) {
+        this.requestIntent = requestIntent;
+    }
+
+    /**
+     *
+     * @return Returns true if there was another AppCall that was
+     * already pending and is now canceled
+     */
+    public boolean setPending() {
+        return setCurrentPendingCall(this);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/AppEventsLoggerUtility.java b/facebook/src/com/facebook/internal/AppEventsLoggerUtility.java
new file mode 100644
index 000000000..8f62c23d5
--- /dev/null
+++ b/facebook/src/com/facebook/internal/AppEventsLoggerUtility.java
@@ -0,0 +1,82 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+
+import com.facebook.LoggingBehavior;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class AppEventsLoggerUtility {
+
+    public enum GraphAPIActivityType {
+        MOBILE_INSTALL_EVENT,
+        CUSTOM_APP_EVENTS,
+    }
+
+    private static final Map<GraphAPIActivityType, String> API_ACTIVITY_TYPE_TO_STRING =
+            new HashMap<GraphAPIActivityType, String>() {{
+                put(GraphAPIActivityType.MOBILE_INSTALL_EVENT, "MOBILE_APP_INSTALL");
+                put(GraphAPIActivityType.CUSTOM_APP_EVENTS, "CUSTOM_APP_EVENTS");
+            }};
+
+    public static JSONObject getJSONObjectForGraphAPICall(
+            GraphAPIActivityType activityType,
+            AttributionIdentifiers attributionIdentifiers,
+            String anonymousAppDeviceGUID,
+            boolean limitEventUsage,
+            Context context) throws JSONException {
+        JSONObject publishParams = new JSONObject();
+
+        publishParams.put("event", API_ACTIVITY_TYPE_TO_STRING.get(activityType));
+
+        Utility.setAppEventAttributionParameters(publishParams, attributionIdentifiers,
+                anonymousAppDeviceGUID, limitEventUsage);
+
+        // The code to get all the Extended info is safe but just in case we can wrap the
+        // whole call in its own try/catch block since some of the things it does might
+        // cause unexpected exceptions on rooted/funky devices:
+        try {
+            Utility.setAppEventExtendedDeviceInfoParameters(
+                    publishParams,
+                    context);
+        } catch (Exception e) {
+            // Swallow but log
+            Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                    "Fetching extended device info parameters failed: '%s'",
+                    e.toString());
+        }
+
+        publishParams.put("application_package_name", context.getPackageName());
+
+        return publishParams;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/AttributionIdentifiers.java b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
new file mode 100644
index 000000000..d45074f08
--- /dev/null
+++ b/facebook/src/com/facebook/internal/AttributionIdentifiers.java
@@ -0,0 +1,186 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Looper;
+import android.util.Log;
+
+import com.facebook.FacebookException;
+
+import java.lang.reflect.Method;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class AttributionIdentifiers {
+    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
+    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER =
+            "com.facebook.katana.provider.AttributionIdProvider";
+    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI =
+            "com.facebook.wakizashi.provider.AttributionIdProvider";
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
+    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";
+
+    // com.google.android.gms.common.ConnectionResult.SUCCESS
+    private static final int CONNECTION_RESULT_SUCCESS = 0;
+
+    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;
+
+    private String attributionId;
+    private String androidAdvertiserId;
+    private boolean limitTracking;
+    private long fetchTime;
+
+    private static AttributionIdentifiers recentlyFetchedIdentifiers;
+
+    private static AttributionIdentifiers getAndroidId(Context context) {
+        AttributionIdentifiers identifiers = new AttributionIdentifiers();
+        try {
+            // We can't call getAdvertisingIdInfo on the main thread or the app will potentially
+            // freeze, if this is the case throw:
+            if (Looper.myLooper() == Looper.getMainLooper()) {
+              throw new FacebookException("getAndroidId cannot be called on the main thread.");
+            }
+            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
+                    "com.google.android.gms.common.GooglePlayServicesUtil",
+                    "isGooglePlayServicesAvailable",
+                    Context.class
+            );
+
+            if (isGooglePlayServicesAvailable == null) {
+                return identifiers;
+            }
+
+            Object connectionResult = Utility.invokeMethodQuietly(
+                    null, isGooglePlayServicesAvailable, context);
+            if (!(connectionResult instanceof Integer)
+                    || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
+                return identifiers;
+            }
+
+            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
+                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
+                    "getAdvertisingIdInfo",
+                    Context.class
+            );
+            if (getAdvertisingIdInfo == null) {
+                return identifiers;
+            }
+            Object advertisingInfo = Utility.invokeMethodQuietly(
+                    null, getAdvertisingIdInfo, context);
+            if (advertisingInfo == null) {
+                return identifiers;
+            }
+
+            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
+            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(
+                    advertisingInfo.getClass(),
+                    "isLimitAdTrackingEnabled");
+            if (getId == null || isLimitAdTrackingEnabled == null) {
+                return identifiers;
+            }
+
+            identifiers.androidAdvertiserId =
+                    (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
+            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(
+                    advertisingInfo,
+                    isLimitAdTrackingEnabled);
+        } catch (Exception e) {
+            Utility.logd("android_id", e);
+        }
+        return identifiers;
+    }
+
+    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
+        if (recentlyFetchedIdentifiers != null &&
+            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime <
+                    IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
+            return recentlyFetchedIdentifiers;
+        }
+
+        AttributionIdentifiers identifiers = getAndroidId(context);
+        Cursor c = null;
+        try {
+            String [] projection = {
+                    ATTRIBUTION_ID_COLUMN_NAME,
+                    ANDROID_ID_COLUMN_NAME,
+                    LIMIT_TRACKING_COLUMN_NAME};
+            Uri providerUri = null;
+            if (context.getPackageManager().resolveContentProvider(
+                    ATTRIBUTION_ID_CONTENT_PROVIDER, 0) != null) {
+                providerUri = Uri.parse("content://" + ATTRIBUTION_ID_CONTENT_PROVIDER);
+            } else if (context.getPackageManager().resolveContentProvider(
+                    ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI, 0) != null) {
+                providerUri = Uri.parse("content://" + ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI);
+            }
+            if (providerUri == null) {
+                return identifiers;
+            }
+            c = context.getContentResolver().query(providerUri, projection, null, null, null);
+            if (c == null || !c.moveToFirst()) {
+                return identifiers;
+            }
+            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
+            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
+            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);
+
+            identifiers.attributionId = c.getString(attributionColumnIndex);
+
+            // if we failed to call Google's APIs directly (due to improper integration by the
+            // client), it may be possible for the local facebook application to relay it to us.
+            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 &&
+                    identifiers.getAndroidAdvertiserId() == null) {
+                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
+                identifiers.limitTracking =
+                        Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
+            }
+        } catch (Exception e) {
+            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
+            return null;
+        } finally {
+            if (c != null) {
+                c.close();
+            }
+        }
+
+        identifiers.fetchTime = System.currentTimeMillis();
+        recentlyFetchedIdentifiers = identifiers;
+        return identifiers;
+    }
+
+    public String getAttributionId() {
+        return attributionId;
+    }
+
+    public String getAndroidAdvertiserId() {
+        return androidAdvertiserId;
+    }
+
+    public boolean isTrackingLimited() {
+        return limitTracking;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/BoltsMeasurementEventListener.java b/facebook/src/com/facebook/internal/BoltsMeasurementEventListener.java
new file mode 100644
index 000000000..681a94838
--- /dev/null
+++ b/facebook/src/com/facebook/internal/BoltsMeasurementEventListener.java
@@ -0,0 +1,96 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.appevents.AppEventsLogger;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class BoltsMeasurementEventListener extends BroadcastReceiver {
+    private static BoltsMeasurementEventListener _instance;
+
+    private final static String MEASUREMENT_EVENT_NOTIFICATION_NAME =
+            "com.parse.bolts.measurement_event";
+    private final static String MEASUREMENT_EVENT_NAME_KEY = "event_name";
+    private final static String MEASUREMENT_EVENT_ARGS_KEY = "event_args";
+    private final static String BOLTS_MEASUREMENT_EVENT_PREFIX = "bf_";
+
+    private Context applicationContext;
+
+    private BoltsMeasurementEventListener(Context context) {
+        applicationContext = context.getApplicationContext();
+    }
+
+    private void open() {
+      LocalBroadcastManager broadcastManager =
+              LocalBroadcastManager.getInstance(applicationContext);
+      broadcastManager.registerReceiver(
+              this, new IntentFilter(MEASUREMENT_EVENT_NOTIFICATION_NAME));
+    }
+
+    private void close() {
+      LocalBroadcastManager broadcastManager =
+              LocalBroadcastManager.getInstance(applicationContext);
+      broadcastManager.unregisterReceiver(this);
+    }
+
+    public static BoltsMeasurementEventListener getInstance(Context context) {
+        if (_instance != null) {
+            return _instance;
+        }
+        _instance = new BoltsMeasurementEventListener(context);
+        _instance.open();
+        return _instance;
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        AppEventsLogger appEventsLogger = AppEventsLogger.newLogger(context);
+        String eventName = BOLTS_MEASUREMENT_EVENT_PREFIX +
+                intent.getStringExtra(MEASUREMENT_EVENT_NAME_KEY);
+        Bundle eventArgs = intent.getBundleExtra(MEASUREMENT_EVENT_ARGS_KEY);
+        Bundle logData = new Bundle();
+        for(String key : eventArgs.keySet()) {
+           String safeKey = key.replaceAll(
+                   "[^0-9a-zA-Z _-]", "-").replaceAll("^[ -]*", "").replaceAll("[ -]*$", "");
+           logData.putString(safeKey, (String)eventArgs.get(key));
+        }
+        appEventsLogger.logEvent(eventName, logData);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/BundleJSONConverter.java b/facebook/src/com/facebook/internal/BundleJSONConverter.java
new file mode 100644
index 000000000..18a2bf5f1
--- /dev/null
+++ b/facebook/src/com/facebook/internal/BundleJSONConverter.java
@@ -0,0 +1,201 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.os.Bundle;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ *
+ * A helper class that can round trip between JSON and Bundle objects that contains the types:
+ *   Boolean, Integer, Long, Double, String
+ * If other types are found, an IllegalArgumentException is thrown.
+ */
+public class BundleJSONConverter {
+    private static final Map<Class<?>, Setter> SETTERS = new HashMap<Class<?>, Setter>();
+
+    static {
+        SETTERS.put(Boolean.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putBoolean(key, (Boolean) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Integer.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putInt(key, (Integer) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Long.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putLong(key, (Long) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Double.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putDouble(key, (Double) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(String.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putString(key, (String) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(String[].class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                throw new IllegalArgumentException("Unexpected type from JSON");
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                JSONArray jsonArray = new JSONArray();
+                for (String stringValue : (String[])value) {
+                    jsonArray.put(stringValue);
+                }
+                json.put(key, jsonArray);
+            }
+        });
+
+        SETTERS.put(JSONArray.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                JSONArray jsonArray = (JSONArray)value;
+                ArrayList<String> stringArrayList = new ArrayList<String>();
+                // Empty list, can't even figure out the type, assume an ArrayList<String>
+                if (jsonArray.length() == 0) {
+                    bundle.putStringArrayList(key, stringArrayList);
+                    return;
+                }
+
+                // Only strings are supported for now
+                for (int i = 0; i < jsonArray.length(); i++) {
+                    Object current = jsonArray.get(i);
+                    if (current instanceof String) {
+                        stringArrayList.add((String)current);
+                    } else {
+                        throw new IllegalArgumentException("Unexpected type in an array: " + current.getClass());
+                    }
+                }
+                bundle.putStringArrayList(key, stringArrayList);
+            }
+
+            @Override
+            public void setOnJSON(JSONObject json, String key, Object value) throws JSONException {
+                throw new IllegalArgumentException("JSONArray's are not supported in bundles.");
+            }
+        });
+    }
+
+    public interface Setter {
+        public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException;
+        public void setOnJSON(JSONObject json, String key, Object value) throws JSONException;
+    }
+
+    public static JSONObject convertToJSON(Bundle bundle) throws JSONException {
+        JSONObject json = new JSONObject();
+
+        for(String key : bundle.keySet()) {
+            Object value = bundle.get(key);
+            if (value == null) {
+                // Null is not supported.
+                continue;
+            }
+
+            // Special case List<String> as getClass would not work, since List is an interface
+            if (value instanceof List<?>) {
+                JSONArray jsonArray = new JSONArray();
+                @SuppressWarnings("unchecked")
+                List<String> listValue = (List<String>)value;
+                for (String stringValue : listValue) {
+                    jsonArray.put(stringValue);
+                }
+                json.put(key, jsonArray);
+                continue;
+            }
+
+            // Special case Bundle as it's one way, on the return it will be JSONObject
+            if (value instanceof Bundle) {
+                json.put(key, convertToJSON((Bundle)value));
+                continue;
+            }
+
+            Setter setter = SETTERS.get(value.getClass());
+            if (setter == null) {
+                throw new IllegalArgumentException("Unsupported type: " + value.getClass());
+            }
+            setter.setOnJSON(json, key, value);
+        }
+
+        return json;
+    }
+
+    public static Bundle convertToBundle(JSONObject jsonObject) throws JSONException {
+        Bundle bundle = new Bundle();
+        @SuppressWarnings("unchecked")
+        Iterator<String> jsonIterator = jsonObject.keys();
+        while (jsonIterator.hasNext()) {
+            String key = jsonIterator.next();
+            Object value = jsonObject.get(key);
+            if (value == null || value == JSONObject.NULL) {
+                // Null is not supported.
+                continue;
+            }
+
+            // Special case JSONObject as it's one way, on the return it would be Bundle.
+            if (value instanceof JSONObject) {
+                bundle.putBundle(key, convertToBundle((JSONObject)value));
+                continue;
+            }
+
+            Setter setter = SETTERS.get(value.getClass());
+            if (setter == null) {
+                throw new IllegalArgumentException("Unsupported type: " + value.getClass());
+            }
+            setter.setOnBundle(bundle, key, value);
+        }
+
+        return bundle;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/CacheableRequestBatch.java b/facebook/src/com/facebook/internal/CacheableRequestBatch.java
deleted file mode 100644
index 83e2d2f44..000000000
--- a/facebook/src/com/facebook/internal/CacheableRequestBatch.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import com.facebook.Request;
-import com.facebook.RequestBatch;
-
-/**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-public class CacheableRequestBatch extends RequestBatch {
-    private String cacheKey;
-    private boolean forceRoundTrip;
-
-    public CacheableRequestBatch() {
-    }
-
-    public CacheableRequestBatch(Request... requests) {
-        super(requests);
-    }
-
-    public final String getCacheKeyOverride() {
-        return cacheKey;
-    }
-
-    // If this is set, the provided string will override the default key (the URL) for single requests.
-    // There is no default for multi-request batches, so no caching will be done unless the override is
-    // specified.
-    public final void setCacheKeyOverride(String cacheKey) {
-        this.cacheKey = cacheKey;
-    }
-
-    public final boolean getForceRoundTrip() {
-        return forceRoundTrip;
-    }
-
-    public final void setForceRoundTrip(boolean forceRoundTrip) {
-        this.forceRoundTrip = forceRoundTrip;
-    }
-
-}
diff --git a/facebook/src/com/facebook/internal/CallbackManagerImpl.java b/facebook/src/com/facebook/internal/CallbackManagerImpl.java
new file mode 100644
index 000000000..bc88153dc
--- /dev/null
+++ b/facebook/src/com/facebook/internal/CallbackManagerImpl.java
@@ -0,0 +1,112 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Intent;
+
+import com.facebook.CallbackManager;
+import com.facebook.FacebookSdk;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public final class CallbackManagerImpl implements CallbackManager {
+    private static Map<Integer, Callback> staticCallbacks = new HashMap<>();
+
+    /**
+     * If there is no explicit callback, but we still need to call the Facebook component,
+     * because it's going to update some state, e.g., login, like. Then we should register a
+     * static callback that can still handle the response.
+     * @param requestCode The request code.
+     * @param callback The callback for the feature.
+     */
+    public synchronized static void registerStaticCallback(
+            int requestCode,
+            Callback callback) {
+        Validate.notNull(callback, "callback");
+        if (staticCallbacks.containsKey(requestCode)) {
+            return;
+        }
+        staticCallbacks.put(requestCode, callback);
+    }
+
+    private static synchronized Callback getStaticCallback(Integer requestCode) {
+        return staticCallbacks.get(requestCode);
+    }
+
+    private static boolean runStaticCallback(
+            int requestCode,
+            int resultCode,
+            Intent data) {
+        Callback callback = getStaticCallback(requestCode);
+        if (callback != null) {
+            return callback.onActivityResult(resultCode, data);
+        }
+        return false;
+    }
+
+    private Map<Integer, Callback> callbacks = new HashMap<>();
+
+    public void registerCallback(int requestCode, Callback callback) {
+        Validate.notNull(callback, "callback");
+        callbacks.put(requestCode, callback);
+    }
+
+    @Override
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        Callback callback = callbacks.get(requestCode);
+        if (callback != null) {
+            return callback.onActivityResult(resultCode, data);
+        }
+        return runStaticCallback(requestCode, resultCode, data);
+    }
+
+    public interface Callback {
+        public boolean onActivityResult(int resultCode, Intent data);
+    }
+
+    public enum RequestCodeOffset {
+        Login(0),
+        Share(1),
+        Message(2),
+        Like(3),
+        GameRequest(4),
+        AppGroupCreate(5),
+        AppGroupJoin(6),
+        AppInvite(7),
+        ;
+
+        private final int offset;
+
+        RequestCodeOffset(int offset) {
+            this.offset = offset;
+        }
+
+        public int toRequestCode() {
+            return FacebookSdk.getCallbackRequestCodeOffset() + offset;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/CollectionMapper.java b/facebook/src/com/facebook/internal/CollectionMapper.java
new file mode 100644
index 000000000..255f2b4a2
--- /dev/null
+++ b/facebook/src/com/facebook/internal/CollectionMapper.java
@@ -0,0 +1,104 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.FacebookException;
+
+import java.util.Iterator;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class CollectionMapper {
+    public static <T> void iterate(final Collection<T> collection,
+                                   final ValueMapper valueMapper,
+                                   final OnMapperCompleteListener onMapperCompleteListener) {
+        final Mutable<Boolean> didReturnError = new Mutable<Boolean>(false);
+        final Mutable<Integer> pendingJobCount = new Mutable<Integer>(1);
+        final OnMapperCompleteListener jobCompleteListener = new OnMapperCompleteListener() {
+            @Override
+            public void onComplete() {
+                if (didReturnError.value) {
+                    return;
+                }
+                if (--pendingJobCount.value == 0) {
+                    onMapperCompleteListener.onComplete();
+                }
+            }
+
+            @Override
+            public void onError(FacebookException exception) {
+                if (didReturnError.value) {
+                    return;
+                }
+                didReturnError.value = true;
+                onMapperCompleteListener.onError(exception);
+            }
+        };
+        final Iterator<T> keyIterator = collection.keyIterator();
+        while (keyIterator.hasNext()) {
+            final T key = keyIterator.next();
+            final Object value = collection.get(key);
+            final OnMapValueCompleteListener onMapValueCompleteListener =
+                    new OnMapValueCompleteListener() {
+                        @Override
+                        public void onComplete(Object mappedValue) {
+                            collection.set(key, mappedValue, jobCompleteListener);
+                            jobCompleteListener.onComplete();
+                        }
+
+                        @Override
+                        public void onError(FacebookException exception) {
+                            jobCompleteListener.onError(exception);
+                        }
+                    };
+            pendingJobCount.value++;
+            valueMapper.mapValue(value, onMapValueCompleteListener);
+        }
+        jobCompleteListener.onComplete();
+    }
+
+    public static interface OnErrorListener {
+        public void onError(FacebookException exception);
+    }
+
+    public static interface OnMapperCompleteListener extends OnErrorListener {
+        public void onComplete();
+    }
+
+    public static interface OnMapValueCompleteListener extends OnErrorListener {
+        public void onComplete(Object mappedValue);
+    }
+
+    public static interface ValueMapper {
+        public void mapValue(Object value, OnMapValueCompleteListener onMapValueCompleteListener);
+    }
+
+    public static interface Collection<T> {
+        public Iterator<T> keyIterator();
+        public Object get(T key);
+        public void set(T key, Object value, OnErrorListener onErrorListener);
+    }
+
+    private CollectionMapper() {}
+}
diff --git a/facebook/src/com/facebook/internal/DialogFeature.java b/facebook/src/com/facebook/internal/DialogFeature.java
new file mode 100644
index 000000000..cac1b4c1c
--- /dev/null
+++ b/facebook/src/com/facebook/internal/DialogFeature.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public interface DialogFeature {
+    /**
+     * This method is for internal use only.
+     */
+    String getAction();
+
+    /**
+     * This method is for internal use only.
+     */
+    int getMinVersion();
+
+    /**
+     * This method is for internal use only.
+     *
+     * For all Enums that implement this interface, the name() method is already present. It returns
+     * the String representation of the Enum value, verbatim.
+     *
+     */
+    String name();
+}
diff --git a/facebook/src/com/facebook/internal/DialogPresenter.java b/facebook/src/com/facebook/internal/DialogPresenter.java
new file mode 100644
index 000000000..5dcc4bc7e
--- /dev/null
+++ b/facebook/src/com/facebook/internal/DialogPresenter.java
@@ -0,0 +1,270 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookActivity;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.appevents.AppEventsLogger;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class DialogPresenter {
+
+    public static void setupAppCallForCannotShowError(AppCall appCall) {
+        FacebookException e = new FacebookException(
+                "Unable to show the provided content via the web or the installed version of the " +
+                        "Facebook app. Some dialogs are only supported starting API 14.");
+        setupAppCallForValidationError(appCall, e);
+    }
+
+    public static void setupAppCallForValidationError(
+            AppCall appCall, FacebookException validationError) {
+        setupAppCallForErrorResult(appCall, validationError);
+    }
+
+    public interface ParameterProvider {
+        Bundle getParameters();
+        Bundle getLegacyParameters();
+    }
+
+    public static void present(AppCall appCall, Activity activity) {
+        activity.startActivityForResult(appCall.getRequestIntent(), appCall.getRequestCode());
+
+        appCall.setPending();
+    }
+
+    public static void present(AppCall appCall, Fragment fragment) {
+        fragment.startActivityForResult(appCall.getRequestIntent(), appCall.getRequestCode());
+
+        appCall.setPending();
+    }
+
+    public static boolean canPresentNativeDialogWithFeature(
+            DialogFeature feature) {
+        return getProtocolVersionForNativeDialog(feature)
+                != NativeProtocol.NO_PROTOCOL_AVAILABLE;
+    }
+
+    public static boolean canPresentWebFallbackDialogWithFeature(DialogFeature feature) {
+        return getDialogWebFallbackUri(feature) != null;
+    }
+
+    public static void setupAppCallForErrorResult(AppCall appCall, FacebookException exception) {
+        if (exception == null) {
+            return;
+        }
+        Validate.hasFacebookActivity(FacebookSdk.getApplicationContext());
+
+        Intent errorResultIntent = new Intent();
+        errorResultIntent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
+        errorResultIntent.setAction(FacebookActivity.PASS_THROUGH_CANCEL_ACTION);
+
+        NativeProtocol.setupProtocolRequestIntent(
+                errorResultIntent,
+                appCall.getCallId().toString(),
+                null,
+                NativeProtocol.getLatestKnownVersion(),
+                NativeProtocol.createBundleForException(exception));
+
+        appCall.setRequestIntent(errorResultIntent);
+    }
+
+    public static void setupAppCallForWebDialog(
+            AppCall appCall,
+            String actionName,
+            Bundle parameters) {
+        Validate.hasFacebookActivity(FacebookSdk.getApplicationContext());
+        Validate.hasInternetPermissions(FacebookSdk.getApplicationContext());
+
+        Bundle intentParameters = new Bundle();
+        intentParameters.putString(NativeProtocol.WEB_DIALOG_ACTION, actionName);
+        intentParameters.putBundle(NativeProtocol.WEB_DIALOG_PARAMS, parameters);
+
+        Intent webDialogIntent = new Intent();
+        NativeProtocol.setupProtocolRequestIntent(
+                webDialogIntent,
+                appCall.getCallId().toString(),
+                actionName,
+                NativeProtocol.getLatestKnownVersion(),
+                intentParameters);
+        webDialogIntent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
+        webDialogIntent.setAction(FacebookDialogFragment.TAG);
+
+        appCall.setRequestIntent(webDialogIntent);
+    }
+
+    public static void setupAppCallForWebFallbackDialog(
+            AppCall appCall,
+            Bundle parameters,
+            DialogFeature feature) {
+        Validate.hasFacebookActivity(FacebookSdk.getApplicationContext());
+        Validate.hasInternetPermissions(FacebookSdk.getApplicationContext());
+
+        String featureName = feature.name();
+        Uri fallbackUrl = getDialogWebFallbackUri(feature);
+        if (fallbackUrl == null) {
+            throw new FacebookException(
+                    "Unable to fetch the Url for the DialogFeature : '" + featureName + "'");
+        }
+
+        // Since we're talking to the server here, let's use the latest version we know about.
+        // We know we are going to be communicating over a bucketed protocol.
+        int protocolVersion = NativeProtocol.getLatestKnownVersion();
+        Bundle webParams = ServerProtocol.getQueryParamsForPlatformActivityIntentWebFallback(
+                appCall.getCallId().toString(),
+                protocolVersion,
+                parameters);
+        if (webParams == null) {
+            throw new FacebookException("Unable to fetch the app's key-hash");
+        }
+
+        // Now form the Uri
+        if (fallbackUrl.isRelative()) {
+            fallbackUrl = Utility.buildUri(
+                    ServerProtocol.getDialogAuthority(),
+                    fallbackUrl.toString(),
+                    webParams);
+        } else {
+            fallbackUrl = Utility.buildUri(
+                    fallbackUrl.getAuthority(),
+                    fallbackUrl.getPath(),
+                    webParams);
+        }
+
+        Bundle intentParameters = new Bundle();
+        intentParameters.putString(NativeProtocol.WEB_DIALOG_URL, fallbackUrl.toString());
+        intentParameters.putBoolean(NativeProtocol.WEB_DIALOG_IS_FALLBACK, true);
+
+        Intent webDialogIntent = new Intent();
+        NativeProtocol.setupProtocolRequestIntent(
+                webDialogIntent,
+                appCall.getCallId().toString(),
+                feature.getAction(),
+                NativeProtocol.getLatestKnownVersion(),
+                intentParameters);
+        webDialogIntent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
+        webDialogIntent.setAction(FacebookDialogFragment.TAG);
+
+        appCall.setRequestIntent(webDialogIntent);
+    }
+
+    public static void setupAppCallForNativeDialog(
+            AppCall appCall,
+            ParameterProvider parameterProvider,
+            DialogFeature feature) {
+        Context context = FacebookSdk.getApplicationContext();
+        String action = feature.getAction();
+        int protocolVersion = getProtocolVersionForNativeDialog(feature);
+        if (protocolVersion == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
+            throw new FacebookException(
+                    "Cannot present this dialog. This likely means that the " +
+                            "Facebook app is not installed.");
+        }
+
+        Bundle params;
+        if (NativeProtocol.isVersionCompatibleWithBucketedIntent(protocolVersion)) {
+            // Facebook app supports the new bucketed protocol
+            params = parameterProvider.getParameters();
+        } else {
+            // Facebook app only supports the old flat protocol
+            params = parameterProvider.getLegacyParameters();
+        }
+        if (params == null) {
+            params = new Bundle();
+        }
+
+        Intent intent = NativeProtocol.createPlatformActivityIntent(
+                context,
+                appCall.getCallId().toString(),
+                action,
+                protocolVersion,
+                params);
+        if (intent == null) {
+            throw new FacebookException(
+                    "Unable to create Intent; this likely means the" +
+                            "Facebook app is not installed.");
+        }
+
+        appCall.setRequestIntent(intent);
+    }
+
+    private static Uri getDialogWebFallbackUri(DialogFeature feature) {
+        String featureName = feature.name();
+        String action = feature.getAction();
+        String applicationId = FacebookSdk.getApplicationId();
+
+        Utility.DialogFeatureConfig config =
+                Utility.getDialogFeatureConfig(applicationId, action, featureName);
+        Uri fallbackUrl = null;
+        if (config != null) {
+            fallbackUrl = config.getFallbackUrl();
+        }
+
+        return fallbackUrl;
+    }
+
+    public static int getProtocolVersionForNativeDialog(
+            DialogFeature feature) {
+        String applicationId = FacebookSdk.getApplicationId();
+        String action = feature.getAction();
+        int[] featureVersionSpec = getVersionSpecForFeature(applicationId, action, feature);
+
+        return NativeProtocol.getLatestAvailableProtocolVersionForAction(
+                action,
+                featureVersionSpec);
+    }
+
+    private static int[] getVersionSpecForFeature(
+            String applicationId,
+            String actionName,
+            DialogFeature feature) {
+        // Return the value from DialogFeatureConfig if available. Otherwise, just
+        // default to the min-version
+        Utility.DialogFeatureConfig config =
+                Utility.getDialogFeatureConfig(applicationId, actionName, feature.name());
+        if (config != null) {
+            return config.getVersionSpec();
+        } else {
+            return new int[]{feature.getMinVersion()};
+        }
+    }
+
+    public static void logDialogActivity(
+            Context context,
+            String eventName,
+            String outcome) {
+        AppEventsLogger logger = AppEventsLogger.newLogger(context);
+        Bundle parameters = new Bundle();
+        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
+        logger.logSdkEvent(eventName, null, parameters);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FacebookDialogBase.java b/facebook/src/com/facebook/internal/FacebookDialogBase.java
new file mode 100644
index 000000000..e0956a4a8
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FacebookDialogBase.java
@@ -0,0 +1,229 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+
+import com.facebook.CallbackManager;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookDialog;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+
+import java.util.List;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public abstract class FacebookDialogBase<CONTENT, RESULT>
+        implements FacebookDialog<CONTENT, RESULT> {
+
+    private static final String TAG = "FacebookDialog";
+
+    protected static final Object BASE_AUTOMATIC_MODE = new Object();
+
+    private final Activity activity;
+    private final Fragment fragment;
+    private List<ModeHandler> modeHandlers;
+    private int requestCode;
+
+    protected FacebookDialogBase(final Activity activity, int requestCode) {
+        Validate.notNull(activity, "activity");
+        this.activity = activity;
+        this.fragment = null;
+        this.requestCode = requestCode;
+    }
+
+    protected FacebookDialogBase(final Fragment fragment, int requestCode) {
+        Validate.notNull(fragment, "fragment");
+        this.fragment = fragment;
+        this.activity = null;
+        this.requestCode = requestCode;
+
+        if (fragment.getActivity() == null) {
+            throw new IllegalArgumentException(
+                    "Cannot use a fragment that is not attached to an activity");
+        }
+    }
+
+    @Override
+    public final void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<RESULT> callback) {
+        if (!(callbackManager instanceof CallbackManagerImpl)) {
+            throw new FacebookException("Unexpected CallbackManager, " +
+                    "please use the provided Factory.");
+        }
+        registerCallbackImpl((CallbackManagerImpl)callbackManager, callback);
+    }
+
+    @Override
+    public final void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<RESULT> callback,
+            final int requestCode) {
+        setRequestCode(requestCode);
+        registerCallback(callbackManager, callback);
+    }
+
+    protected abstract void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<RESULT> callback);
+
+    /**
+     * Set the request code for the startActivityForResult call. The requestCode should be
+     * outside of the range of those reserved for the Facebook SDK
+     * {@link com.facebook.FacebookSdk#isFacebookRequestCode(int)}.
+     *
+     * @param requestCode the request code to use.
+     */
+     protected void setRequestCode(int requestCode) {
+         if (FacebookSdk.isFacebookRequestCode(requestCode)) {
+             throw new IllegalArgumentException("Request code " + requestCode +
+                     " cannot be within the range reserved by the Facebook SDK.");
+         }
+         this.requestCode = requestCode;
+     }
+
+    /**
+     * Returns the request code used for this dialog.
+     *
+     * @return the request code.
+     */
+    public int getRequestCode() {
+        return requestCode;
+    }
+
+     @Override
+    public boolean canShow(CONTENT content) {
+        return canShowImpl(content, BASE_AUTOMATIC_MODE);
+    }
+
+    // Pass in BASE_AUTOMATIC_MODE when Automatic mode choice is desired
+    protected boolean canShowImpl(CONTENT content, Object mode) {
+        boolean anyModeAllowed = (mode == BASE_AUTOMATIC_MODE);
+
+        for (ModeHandler handler : cachedModeHandlers()) {
+            if (!anyModeAllowed && !Utility.areObjectsEqual(handler.getMode(), mode)) {
+                continue;
+            }
+            if (handler.canShow(content)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void show(final CONTENT content) {
+        showImpl(content, BASE_AUTOMATIC_MODE);
+    }
+
+    // Pass in BASE_AUTOMATIC_MODE when Automatic mode choice is desired
+    protected void showImpl(final CONTENT content, final Object mode) {
+        AppCall appCall = createAppCallForMode(content, mode);
+        if (appCall != null) {
+            if (fragment != null) {
+                DialogPresenter.present(appCall, fragment);
+            } else {
+                DialogPresenter.present(appCall, activity);
+            }
+        } else {
+            // If we got a null appCall, then the derived dialog code is doing something wrong
+            String errorMessage = "No code path should ever result in a null appCall";
+            Log.e(TAG, errorMessage);
+            if (FacebookSdk.isDebugEnabled()) {
+                throw new IllegalStateException(errorMessage);
+            }
+        }
+    }
+
+    protected Activity getActivityContext() {
+        if (activity != null) {
+            return activity;
+        }
+
+        if (fragment != null) {
+            return fragment.getActivity();
+        }
+
+        return null;
+    }
+
+    private AppCall createAppCallForMode(final CONTENT content, final Object mode) {
+        boolean anyModeAllowed = (mode == BASE_AUTOMATIC_MODE);
+
+        AppCall appCall = null;
+        for (ModeHandler handler : cachedModeHandlers()) {
+            if (!anyModeAllowed && !Utility.areObjectsEqual(handler.getMode(), mode)) {
+                continue;
+            }
+            if (!handler.canShow(content)) {
+                continue;
+            }
+
+            try {
+                appCall = handler.createAppCall(content);
+            } catch (FacebookException e) {
+                appCall = createBaseAppCall();
+                DialogPresenter.setupAppCallForValidationError(appCall, e);
+            }
+            break;
+        }
+
+        if (appCall == null) {
+            appCall = createBaseAppCall();
+            DialogPresenter.setupAppCallForCannotShowError(appCall);
+        }
+
+        return appCall;
+    }
+
+    private List<ModeHandler> cachedModeHandlers() {
+        if (modeHandlers == null) {
+            modeHandlers = getOrderedModeHandlers();
+        }
+
+        return modeHandlers;
+    }
+
+    protected abstract List<ModeHandler> getOrderedModeHandlers();
+
+    protected abstract AppCall createBaseAppCall();
+
+    protected abstract class ModeHandler {
+        /**
+         * @return An object to signify a specific dialog-mode.
+         */
+        public Object getMode() {
+            return BASE_AUTOMATIC_MODE;
+        }
+
+        public abstract boolean canShow(final CONTENT content);
+
+        public abstract AppCall createAppCall(final CONTENT content);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FacebookDialogFragment.java b/facebook/src/com/facebook/internal/FacebookDialogFragment.java
new file mode 100644
index 000000000..fad56ee93
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FacebookDialogFragment.java
@@ -0,0 +1,161 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.app.Activity;
+import android.app.Dialog;
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.FragmentActivity;
+
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class FacebookDialogFragment extends DialogFragment {
+    private Dialog dialog;
+
+    public static final String TAG = "FacebookDialogFragment";
+
+    /**
+     * Setter for dialog. The dialog should be set before the show method is called.
+     * @param dialog The dialog that is wrapped.
+     */
+    public void setDialog(Dialog dialog) {
+        this.dialog = dialog;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (this.dialog == null) {
+            final FragmentActivity activity = getActivity();
+            Intent intent = activity.getIntent();
+            Bundle params = NativeProtocol.getMethodArgumentsFromIntent(intent);
+
+            boolean isWebFallback = params.getBoolean(NativeProtocol.WEB_DIALOG_IS_FALLBACK, false);
+            WebDialog webDialog;
+            if (!isWebFallback) {
+                String actionName = params.getString(NativeProtocol.WEB_DIALOG_ACTION);
+                Bundle webParams = params.getBundle(NativeProtocol.WEB_DIALOG_PARAMS);
+                if (Utility.isNullOrEmpty(actionName)) {
+                    Utility.logd(
+                            TAG,
+                            "Cannot start a WebDialog with an empty/missing 'actionName'");
+                    activity.finish();
+                    return;
+                }
+
+                webDialog = new WebDialog.Builder(activity, actionName, webParams)
+                        .setOnCompleteListener(new WebDialog.OnCompleteListener() {
+                            @Override
+                            public void onComplete(Bundle values, FacebookException error) {
+                                onCompleteWebDialog(values, error);
+                            }
+                        })
+                        .build();
+            } else {
+                String url = params.getString(NativeProtocol.WEB_DIALOG_URL);
+                if (Utility.isNullOrEmpty(url)) {
+                    Utility.logd(
+                            TAG,
+                            "Cannot start a fallback WebDialog with an empty/missing 'url'");
+                    activity.finish();
+                    return;
+                }
+
+                String redirectUrl =
+                        String.format("fb%s://bridge/", FacebookSdk.getApplicationId());
+                webDialog = new FacebookWebFallbackDialog(activity, url, redirectUrl);
+                webDialog.setOnCompleteListener(new WebDialog.OnCompleteListener() {
+                    @Override
+                    public void onComplete(Bundle values, FacebookException error) {
+                        // Error data is nested in the values since this is in the form of a
+                        // Native protocol response
+                        onCompleteWebFallbackDialog(values);
+                    }
+                });
+            }
+
+            this.dialog = webDialog;
+        }
+    }
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        // Prevents an NPE crash in the support library
+        if (dialog == null) {
+            onCompleteWebDialog(null, null);
+            setShowsDialog(false);
+        }
+        return dialog;
+    }
+
+    @Override
+    public void onConfigurationChanged (Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+
+        if (this.dialog instanceof WebDialog) {
+            ((WebDialog)this.dialog).resize();
+        }
+    }
+
+    @Override
+    public void onDestroyView() {
+        if (getDialog() != null && getRetainInstance()) {
+            getDialog().setDismissMessage(null);
+        }
+        super.onDestroyView();
+    }
+
+    private void onCompleteWebDialog(Bundle values, FacebookException error) {
+        FragmentActivity fragmentActivity = getActivity();
+
+        Intent resultIntent = NativeProtocol.createProtocolResultIntent(
+                fragmentActivity.getIntent(),
+                values,
+                error);
+
+        int resultCode = error == null ? Activity.RESULT_OK : Activity.RESULT_CANCELED;
+
+        fragmentActivity.setResult(resultCode, resultIntent);
+        fragmentActivity.finish();
+    }
+
+    private void onCompleteWebFallbackDialog(Bundle values) {
+        FragmentActivity fragmentActivity = getActivity();
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtras(values == null ? new Bundle() : values);
+
+        fragmentActivity.setResult(Activity.RESULT_OK, resultIntent);
+        fragmentActivity.finish();
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FacebookRequestErrorClassification.java b/facebook/src/com/facebook/internal/FacebookRequestErrorClassification.java
new file mode 100644
index 000000000..770af2ce9
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FacebookRequestErrorClassification.java
@@ -0,0 +1,235 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+package com.facebook.internal;
+
+import com.facebook.FacebookRequestError;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public final class FacebookRequestErrorClassification {
+    public static final int EC_SERVICE_UNAVAILABLE = 2;
+    public static final int EC_APP_TOO_MANY_CALLS = 4;
+    public static final int EC_RATE = 9;
+    public static final int EC_USER_TOO_MANY_CALLS = 17;
+    public static final int EC_INVALID_SESSION = 102;
+    public static final int EC_INVALID_TOKEN = 190;
+    public static final int EC_TOO_MANY_USER_ACTION_CALLS = 341;
+
+    public static final String KEY_RECOVERY_MESSAGE = "recovery_message";
+    public static final String KEY_NAME = "name";
+    public static final String KEY_OTHER = "other";
+    public static final String KEY_TRANSIENT = "transient";
+    public static final String KEY_LOGIN_RECOVERABLE = "login_recoverable";
+
+    // Key is error code, value is the subcodes. Null subcodes means all subcodes are accepted.
+    private final Map<Integer, Set<Integer>> otherErrors;
+    private final Map<Integer, Set<Integer>> transientErrors;
+    private final Map<Integer, Set<Integer>> loginRecoverableErrors;
+    private final String otherRecoveryMessage;
+    private final String transientRecoveryMessage;
+    private final String loginRecoverableRecoveryMessage;
+
+    private static FacebookRequestErrorClassification defaultInstance;
+
+    FacebookRequestErrorClassification(
+            Map<Integer, Set<Integer>> otherErrors,
+            Map<Integer, Set<Integer>> transientErrors,
+            Map<Integer, Set<Integer>> loginRecoverableErrors,
+            String otherRecoveryMessage,
+            String transientRecoveryMessage,
+            String loginRecoverableRecoveryMessage) {
+        this.otherErrors = otherErrors;
+        this.transientErrors = transientErrors;
+        this.loginRecoverableErrors = loginRecoverableErrors;
+        this.otherRecoveryMessage = otherRecoveryMessage;
+        this.transientRecoveryMessage = transientRecoveryMessage;
+        this.loginRecoverableRecoveryMessage = loginRecoverableRecoveryMessage;
+    }
+
+    public Map<Integer, Set<Integer>> getOtherErrors() {
+        return otherErrors;
+    }
+
+    public Map<Integer, Set<Integer>> getTransientErrors() {
+        return transientErrors;
+    }
+
+    public Map<Integer, Set<Integer>> getLoginRecoverableErrors() {
+        return loginRecoverableErrors;
+    }
+
+    public String getRecoveryMessage(FacebookRequestError.Category category) {
+        switch (category) {
+            case OTHER:
+                return otherRecoveryMessage;
+            case LOGIN_RECOVERABLE:
+                return loginRecoverableRecoveryMessage;
+            case TRANSIENT:
+                return transientRecoveryMessage;
+            default:
+                return null;
+        }
+    }
+
+    public FacebookRequestError.Category classify(
+            int errorCode,
+            int errorSubCode,
+            boolean isTransient) {
+        if (isTransient) {
+            return FacebookRequestError.Category.TRANSIENT;
+        }
+
+        if (otherErrors != null && otherErrors.containsKey(errorCode)) {
+            Set<Integer> subCodes = otherErrors.get(errorCode);
+            if (subCodes == null || subCodes.contains(errorSubCode)) {
+                return FacebookRequestError.Category.OTHER;
+            }
+        }
+
+        if (loginRecoverableErrors != null && loginRecoverableErrors.containsKey(errorCode)) {
+            Set<Integer> subCodes = loginRecoverableErrors.get(errorCode);
+            if (subCodes == null || subCodes.contains(errorSubCode)) {
+                return FacebookRequestError.Category.LOGIN_RECOVERABLE;
+            }
+        }
+
+        if (transientErrors != null && transientErrors.containsKey(errorCode)) {
+            Set<Integer> subCodes = transientErrors.get(errorCode);
+            if (subCodes == null || subCodes.contains(errorSubCode)) {
+                return FacebookRequestError.Category.TRANSIENT;
+            }
+        }
+        return FacebookRequestError.Category.OTHER;
+    }
+
+    public static synchronized FacebookRequestErrorClassification getDefaultErrorClassification() {
+        if (defaultInstance == null) {
+            defaultInstance = getDefaultErrorClassificationImpl();
+        }
+        return defaultInstance;
+    }
+
+    private static FacebookRequestErrorClassification getDefaultErrorClassificationImpl() {
+        Map<Integer, Set<Integer>> transientErrors = new HashMap<Integer, Set<Integer>>() {{
+            put(EC_SERVICE_UNAVAILABLE, null);
+            put(EC_APP_TOO_MANY_CALLS, null);
+            put(EC_RATE, null);
+            put(EC_USER_TOO_MANY_CALLS, null);
+            put(EC_TOO_MANY_USER_ACTION_CALLS, null);
+        }};
+
+        Map<Integer, Set<Integer>> loginRecoverableErrors = new HashMap<Integer, Set<Integer>>() {{
+            put(EC_INVALID_SESSION,null);
+            put(EC_INVALID_TOKEN,null);
+        }};
+
+        return new FacebookRequestErrorClassification(
+                null,
+                transientErrors,
+                loginRecoverableErrors,
+                null,
+                null,
+                null);
+    }
+
+    private static Map<Integer, Set<Integer>> parseJSONDefinition(JSONObject definition) {
+        JSONArray itemsArray = definition.optJSONArray("items");
+        if (itemsArray.length() == 0) {
+            return null;
+        }
+
+        Map<Integer, Set<Integer>> items = new HashMap<>();
+        for (int i = 0; i < itemsArray.length(); i++) {
+            JSONObject item = itemsArray.optJSONObject(i);
+            if (item == null) {
+                continue;
+            }
+            int code = item.optInt("code");
+            if (code == 0) {
+                continue;
+            }
+            Set<Integer> subcodes = null;
+            JSONArray subcodesArray = item.optJSONArray("subcodes");
+            if (subcodesArray != null && subcodesArray.length() > 0) {
+                subcodes = new HashSet<>();
+                for (int j = 0; j < subcodesArray.length(); j++) {
+                    int subCode = subcodesArray.optInt(j);
+                    if (subCode != 0) {
+                        subcodes.add(subCode);
+                    }
+                }
+            }
+            items.put(code, subcodes);
+        }
+        return items;
+    }
+
+    public static FacebookRequestErrorClassification createFromJSON(JSONArray jsonArray) {
+        if (jsonArray == null) {
+            return null;
+        }
+        Map<Integer, Set<Integer>> otherErrors = null;
+        Map<Integer, Set<Integer>> transientErrors = null;
+        Map<Integer, Set<Integer>> loginRecoverableErrors = null;
+        String otherRecoveryMessage = null;
+        String transientRecoveryMessage = null;
+        String loginRecoverableRecoveryMessage = null;
+
+        for (int i = 0; i < jsonArray.length(); i++) {
+            JSONObject definition = jsonArray.optJSONObject(i);
+            if (definition == null) {
+                continue;
+            }
+            String name = definition.optString(KEY_NAME);
+            if (name == null) {
+                continue;
+            }
+            if (name.equalsIgnoreCase(KEY_OTHER)) {
+                otherRecoveryMessage = definition.optString(KEY_RECOVERY_MESSAGE, null);
+                otherErrors = parseJSONDefinition(definition);
+            } else if (name.equalsIgnoreCase(KEY_TRANSIENT)) {
+                transientRecoveryMessage = definition.optString(KEY_RECOVERY_MESSAGE, null);
+                transientErrors = parseJSONDefinition(definition);
+            } else if (name.equalsIgnoreCase(KEY_LOGIN_RECOVERABLE)) {
+                loginRecoverableRecoveryMessage = definition.optString(KEY_RECOVERY_MESSAGE, null);
+                loginRecoverableErrors = parseJSONDefinition(definition);
+            }
+        }
+        return new FacebookRequestErrorClassification(
+            otherErrors,
+            transientErrors,
+            loginRecoverableErrors,
+            otherRecoveryMessage,
+            transientRecoveryMessage,
+            loginRecoverableRecoveryMessage
+        );
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
new file mode 100644
index 000000000..9d945cdcd
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
@@ -0,0 +1,149 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.webkit.WebView;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ * <p/>
+ * This dialog is used as a fallback when a native FacebookDialog could not be displayed. The
+ * primary reason for this separation is to keep this approach for internal use only until we
+ * stabilize the API.
+ */
+public class FacebookWebFallbackDialog extends WebDialog {
+    private static final String TAG = FacebookWebFallbackDialog.class.getName();
+    private static final int OS_BACK_BUTTON_RESPONSE_TIMEOUT_MILLISECONDS = 1500;
+
+    private boolean waitingForDialogToClose;
+
+    public FacebookWebFallbackDialog(Context context, String url, String expectedRedirectUrl) {
+        super(context, url);
+
+        setExpectedRedirectUrl(expectedRedirectUrl);
+    }
+
+    @Override
+    protected Bundle parseResponseUri(String url) {
+        Uri responseUri = Uri.parse(url);
+        Bundle queryParams = Utility.parseUrlQueryString(responseUri.getQuery());
+
+        // Convert Bridge args to the format that the Native dialog code understands.
+        String bridgeArgsJSONString =
+                queryParams.getString(ServerProtocol.FALLBACK_DIALOG_PARAM_BRIDGE_ARGS);
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_BRIDGE_ARGS);
+
+        if (!Utility.isNullOrEmpty(bridgeArgsJSONString)) {
+            Bundle bridgeArgs;
+            try {
+                JSONObject bridgeArgsJSON = new JSONObject(bridgeArgsJSONString);
+                bridgeArgs = BundleJSONConverter.convertToBundle(bridgeArgsJSON);
+                queryParams.putBundle(NativeProtocol.EXTRA_PROTOCOL_BRIDGE_ARGS, bridgeArgs);
+            } catch (JSONException je) {
+                Utility.logd(TAG, "Unable to parse bridge_args JSON", je);
+            }
+        }
+
+        // Convert Method results to the format that the Native dialog code understands.
+        String methodResultsJSONString =
+                queryParams.getString(ServerProtocol.FALLBACK_DIALOG_PARAM_METHOD_RESULTS);
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_METHOD_RESULTS);
+
+        if (!Utility.isNullOrEmpty(methodResultsJSONString)) {
+            methodResultsJSONString =
+                    Utility.isNullOrEmpty(methodResultsJSONString) ? "{}" : methodResultsJSONString;
+            Bundle methodResults;
+            try {
+                JSONObject methodArgsJSON = new JSONObject(methodResultsJSONString);
+                methodResults = BundleJSONConverter.convertToBundle(methodArgsJSON);
+                queryParams.putBundle(NativeProtocol.EXTRA_PROTOCOL_METHOD_RESULTS, methodResults);
+            } catch (JSONException je) {
+                Utility.logd(TAG, "Unable to parse bridge_args JSON", je);
+            }
+        }
+
+        // The web host does not send a numeric version back. Put the latest known version in there
+        // so NativeProtocol can continue parsing the response.
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_VERSION);
+        queryParams.putInt(
+                NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.getLatestKnownVersion());
+
+        return queryParams;
+    }
+
+    @Override
+    public void cancel() {
+        WebView webView = getWebView();
+
+        // If the page hasn't loaded, or the listener is already called, then we can't interrupt
+        // this cancellation. Either the JS won't be ready to consume the event, or the listener
+        // has already processed a result.
+        // So let's just handle this cancellation in the standard way.
+        if (!isPageFinished()
+                || isListenerCalled()
+                || webView == null
+                || !webView.isShown()) {
+            super.cancel();
+            return;
+        }
+
+        // Return right away if we have already queued up the delayed-cancel call.
+        if (waitingForDialogToClose) {
+            return;
+        }
+
+        waitingForDialogToClose = true;
+
+        // Now fire off the event that will tell the dialog to wind down.
+        String eventJS =
+                "(function() {" +
+                        "  var event = document.createEvent('Event');" +
+                        "  event.initEvent('fbPlatformDialogMustClose',true,true);" +
+                        "  document.dispatchEvent(event);" +
+                        "})();";
+        webView.loadUrl("javascript:" + eventJS);
+
+        // Set up a timeout for the dialog to respond. If the timer expires, we need to honor
+        // the user's desire to dismiss the dialog.
+        Handler handler = new Handler(Looper.getMainLooper());
+        handler.postDelayed(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        // If we get here, then the dialog did not close quickly enough.
+                        // So we need to honor the user's wish to cancel and we should do
+                        // so without allowing interruptions.
+                        FacebookWebFallbackDialog.super.cancel();
+                    }
+                },
+                OS_BACK_BUTTON_RESPONSE_TIMEOUT_MILLISECONDS);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FileLruCache.java b/facebook/src/com/facebook/internal/FileLruCache.java
index 0f23176b9..72e73d467 100644
--- a/facebook/src/com/facebook/internal/FileLruCache.java
+++ b/facebook/src/com/facebook/internal/FileLruCache.java
@@ -1,25 +1,30 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import android.content.Context;
 import android.util.Log;
+
+import com.facebook.FacebookSdk;
 import com.facebook.LoggingBehavior;
-import com.facebook.Settings;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.json.JSONTokener;
@@ -33,28 +38,31 @@
 // This class is intended to be thread-safe.
 //
 // There are two classes of files:  buffer files and cache files:
-// - A buffer file is in the process of being written, and there is an open stream on the file.  These files are
-//   named as "bufferN" where N is an incrementing integer.  On startup, we delete all existing files of this form.
-//   Once the stream is closed, we rename the buffer file to a cache file or attempt to delete if this fails.  We
-//   do not otherwise ever attempt to delete these files.
-// - A cache file is a non-changing file that is named by the md5 hash of the cache key.  We monitor the size of
-//   these files in aggregate and remove the oldest one(s) to stay under quota.  This process does not block threads
-//   calling into this class, so theoretically we could go arbitrarily over quota but in practice this should not
-//   happen because deleting files should be much cheaper than downloading new file content.
+// - A buffer file is in the process of being written, and there is an open stream on the file.
+//   These files are named as "bufferN" where N is an incrementing integer.  On startup, we delete
+//   all existing files of this form. Once the stream is closed, we rename the buffer file to a
+//   cache file or attempt to delete if this fails.  We do not otherwise ever attempt to delete
+//   these files.
+// - A cache file is a non-changing file that is named by the md5 hash of the cache key.  We monitor
+//   the size of these files in aggregate and remove the oldest one(s) to stay under quota.  This
+//   process does not block threads calling into this class, so theoretically we could go
+//   arbitrarily over quota but in practice this should not happen because deleting files should be
+//   much cheaper than downloading new file content.
 //
-// Since there can only ever be one thread accessing a particular buffer file, we do not synchronize access to these.
-// We do assume that file rename is atomic when converting a buffer file to a cache file, and that if multiple files
-// are renamed to a single target that exactly one of them continues to exist.
+// Since there can only ever be one thread accessing a particular buffer file, we do not synchronize
+// access to these. We do assume that file rename is atomic when converting a buffer file to a cache
+// file, and that if multiple files are renamed to a single target that exactly one of them
+// continues to exist.
 //
-// Standard POSIX file semantics guarantee being able to continue to use a file handle even after the
-// corresponding file has been deleted.  Given this and that cache files never change other than deleting in trim()
-// or clear(),  we only have to ensure that there is at most one trim() or clear() process deleting files at any
-// given time.
+// Standard POSIX file semantics guarantee being able to continue to use a file handle even after
+// the corresponding file has been deleted.  Given this and that cache files never change other than
+// deleting in trim() or clear(),  we only have to ensure that there is at most one trim() or
+// clear() process deleting files at any given time.
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public final class FileLruCache {
     static final String TAG = FileLruCache.class.getSimpleName();
@@ -72,10 +80,10 @@
     private AtomicLong lastClearCacheTime = new AtomicLong(0);
 
     // The value of tag should be a final String that works as a directory name.
-    public FileLruCache(Context context, String tag, Limits limits) {
+    public FileLruCache(String tag, Limits limits) {
         this.tag = tag;
         this.limits = limits;
-        this.directory = new File(context.getCacheDir(), tag);
+        this.directory = new File(FacebookSdk.getCacheDir(), tag);
         this.lock = new Object();
 
         // Ensure the cache dir exists
@@ -85,8 +93,9 @@ public FileLruCache(Context context, String tag, Limits limits) {
         }
     }
 
-    // This is not robust to files changing dynamically underneath it and should therefore only be used
-    // for test code.  If we ever need this for product code we need to think through synchronization.
+    // This is not robust to files changing dynamically underneath it and should therefore only be
+    // used for test code.  If we ever need this for product code we need to think through
+    // synchronization.
     // See the threading notes at the top of this class.
     //
     // Also, since trim() runs asynchronously now, this blocks until any pending trim has completed.
@@ -125,7 +134,8 @@ public InputStream get(String key, String contentTag) throws IOException {
             return null;
         }
 
-        BufferedInputStream buffered = new BufferedInputStream(input, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        BufferedInputStream buffered =
+                new BufferedInputStream(input, Utility.DEFAULT_STREAM_BUFFER_SIZE);
         boolean success = false;
 
         try {
@@ -147,8 +157,11 @@ public InputStream get(String key, String contentTag) throws IOException {
             }
 
             long accessTime = new Date().getTime();
-            Logger.log(LoggingBehavior.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
-                    + file.getName());
+            Logger.log(
+                    LoggingBehavior.CACHE,
+                    TAG,
+                    "Setting lastModified to " + Long.valueOf(accessTime) + " for " +
+                            file.getName());
             file.setLastModified(accessTime);
 
             success = true;
@@ -160,7 +173,7 @@ public InputStream get(String key, String contentTag) throws IOException {
         }
     }
 
-    OutputStream openPutStream(final String key) throws IOException {
+    public OutputStream openPutStream(final String key) throws IOException {
         return openPutStream(key, null);
     }
 
@@ -175,7 +188,11 @@ public OutputStream openPutStream(final String key, String contentTag) throws IO
         try {
             file = new FileOutputStream(buffer);
         } catch (FileNotFoundException e) {
-            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
+            Logger.log(
+                    LoggingBehavior.CACHE,
+                    Log.WARN,
+                    TAG,
+                    "Error creating buffer output stream: " + e);
             throw new IOException(e.getMessage());
         }
 
@@ -193,8 +210,10 @@ public void onClose() {
             }
         };
 
-        CloseCallbackOutputStream cleanup = new CloseCallbackOutputStream(file, renameToTargetCallback);
-        BufferedOutputStream buffered = new BufferedOutputStream(cleanup, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        CloseCallbackOutputStream cleanup =
+                new CloseCallbackOutputStream(file, renameToTargetCallback);
+        BufferedOutputStream buffered =
+                new BufferedOutputStream(cleanup, Utility.DEFAULT_STREAM_BUFFER_SIZE);
         boolean success = false;
 
         try {
@@ -211,7 +230,11 @@ public void onClose() {
             return buffered;
         } catch (JSONException e) {
             // JSON is an implementation detail of the cache, so don't let JSON exceptions out.
-            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
+            Logger.log(
+                    LoggingBehavior.CACHE,
+                    Log.WARN,
+                    TAG,
+                    "Error creating JSON header for cache file: " + e);
             throw new IOException(e.getMessage());
         } finally {
             if (!success) {
@@ -225,7 +248,7 @@ public void clearCache() {
         final File[] filesToDelete = directory.listFiles(BufferFile.excludeBufferFiles());
         lastClearCacheTime.set(System.currentTimeMillis());
         if (filesToDelete != null) {
-            Settings.getExecutor().execute(new Runnable() {
+            FacebookSdk.getExecutor().execute(new Runnable() {
                 @Override
                 public void run() {
                     for (File file : filesToDelete) {
@@ -236,14 +259,23 @@ public void run() {
         }
     }
 
+    /**
+     * The location of the cache.
+     * @return The location of the cache.
+     */
+    public String getLocation() {
+        return this.directory.getPath();
+    }
+
     private void renameToTargetAndTrim(String key, File buffer) {
         final File target = new File(directory, Utility.md5hash(key));
 
-        // This is triggered by close().  By the time close() returns, the file should be cached, so this needs to
-        // happen synchronously on this thread.
+        // This is triggered by close().  By the time close() returns, the file should be cached, so
+        // this needs to happen synchronously on this thread.
         //
-        // However, it does not need to be synchronized, since in the race we will just start an unnecesary trim
-        // operation.  Avoiding the cost of holding the lock across the file operation seems worth this cost.
+        // However, it does not need to be synchronized, since in the race we will just start an
+        // unnecessary trim operation.  Avoiding the cost of holding the lock across the file
+        // operation seems worth this cost.
         if (!buffer.renameTo(target)) {
             buffer.delete();
         }
@@ -267,7 +299,7 @@ private void postTrim() {
         synchronized (lock) {
             if (!isTrimPending) {
                 isTrimPending = true;
-                Settings.getExecutor().execute(new Runnable() {
+                FacebookSdk.getExecutor().execute(new Runnable() {
                     @Override
                     public void run() {
                         trim();
@@ -292,8 +324,11 @@ private void trim() {
                 for (File file : filesToTrim) {
                     ModifiedFile modified = new ModifiedFile(file);
                     heap.add(modified);
-                    Logger.log(LoggingBehavior.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
-                            + " name=" + modified.getFile().getName());
+                    Logger.log(
+                            LoggingBehavior.CACHE,
+                            TAG,
+                            "  trim considering time=" + Long.valueOf(modified.getModified()) +
+                                    " name=" + modified.getFile().getName());
 
                     size += file.length();
                     count++;
@@ -402,9 +437,11 @@ static JSONObject readHeader(InputStream stream) throws IOException {
             while (count < headerBytes.length) {
                 int readCount = stream.read(headerBytes, count, headerBytes.length - count);
                 if (readCount < 1) {
-                    Logger.log(LoggingBehavior.CACHE, TAG,
-                            "readHeader: stream.read stopped at " + Integer.valueOf(count) + " when expected "
-                                    + headerBytes.length);
+                    Logger.log(
+                            LoggingBehavior.CACHE,
+                            TAG,
+                            "readHeader: stream.read stopped at " + Integer.valueOf(count) +
+                                    " when expected " + headerBytes.length);
                     return null;
                 }
                 count += readCount;
@@ -416,7 +453,11 @@ static JSONObject readHeader(InputStream stream) throws IOException {
             try {
                 Object parsed = tokener.nextValue();
                 if (!(parsed instanceof JSONObject)) {
-                    Logger.log(LoggingBehavior.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
+                    Logger.log(
+                            LoggingBehavior.CACHE,
+                            TAG,
+                            "readHeader: expected JSONObject, got " +
+                                    parsed.getClass().getCanonicalName());
                     return null;
                 }
                 header = (JSONObject) parsed;
@@ -484,9 +525,10 @@ public int available() throws IOException {
         @Override
         public void close() throws IOException {
             // According to http://www.cs.cornell.edu/andru/javaspec/11.doc.html:
-            //  "If a finally clause is executed because of abrupt completion of a try block and the finally clause
-            //   itself completes abruptly, then the reason for the abrupt completion of the try block is discarded
-            //   and the new reason for abrupt completion is propagated from there."
+            //  "If a finally clause is executed because of abrupt completion of a try block and the
+            //   finally clause itself completes abruptly, then the reason for the abrupt completion
+            //   of the try block is discarded and the new reason for abrupt completion is
+            //   propagated from there."
             //
             // Android does appear to behave like this.
             try {
diff --git a/facebook/src/com/facebook/internal/GraphUtil.java b/facebook/src/com/facebook/internal/GraphUtil.java
new file mode 100644
index 000000000..93b4566ed
--- /dev/null
+++ b/facebook/src/com/facebook/internal/GraphUtil.java
@@ -0,0 +1,139 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.FacebookException;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ * <p/>
+ * This class provides utility methods that are useful in graph API interactions.
+ */
+public class GraphUtil {
+    private static final String[] dateFormats = new String[] {
+            "yyyy-MM-dd'T'HH:mm:ssZ",
+            "yyyy-MM-dd'T'HH:mm:ss",
+            "yyyy-MM-dd",
+    };
+
+    /**
+     * Creates a JSONObject for an open graph action that is suitable for posting.
+     * @param type the Open Graph action type for the object, or null if it will be specified later
+     * @return a JSONObject
+     */
+    public static JSONObject createOpenGraphActionForPost(String type) {
+        JSONObject action = new JSONObject();
+        if (type != null) {
+            try {
+                action.put("type", type);
+            } catch (JSONException e) {
+                throw new FacebookException(
+                        "An error occurred while setting up the open graph action",
+                        e);
+            }
+        }
+        return action;
+    }
+
+
+    /**
+     * Creates a JSONObject for an open graph object that is suitable for posting.
+     * @param type the Open Graph object type for the object, or null if it will be specified later
+     * @return a JSONObject
+     */
+    public static JSONObject createOpenGraphObjectForPost(String type) {
+        return createOpenGraphObjectForPost(type, null, null, null, null, null, null);
+    }
+
+    /**
+     * Creates a JSONObject for an open graph object that is suitable for posting.
+     * @param type the Open Graph object type for the object, or null if it will be specified later
+     * @param title the title of the object, or null if it will be specified later
+     * @param imageUrl the URL of an image associated with the object, or null
+     * @param url the URL associated with the object, or null
+     * @param description the description of the object, or null
+     * @param objectProperties the properties of the open graph object
+     * @param id the id of the object if the post is for update
+     * @return a JSONObject
+     */
+    public static JSONObject createOpenGraphObjectForPost(
+            String type,
+            String title,
+            String imageUrl,
+            String url,
+            String description,
+            JSONObject objectProperties,
+            String id) {
+        JSONObject openGraphObject = new JSONObject();
+        try {
+            if (type != null) {
+                openGraphObject.put("type", type);
+            }
+            openGraphObject.put("title", title);
+
+            if (imageUrl != null) {
+                JSONObject imageUrlObject = new JSONObject();
+                imageUrlObject.put("url", imageUrl);
+                JSONArray imageUrls = new JSONArray();
+                imageUrls.put(imageUrlObject);
+                openGraphObject.put("image", imageUrls);
+            }
+
+            openGraphObject.put("url", url);
+            openGraphObject.put("description", description);
+            openGraphObject.put(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY, true);
+
+            if (objectProperties != null) {
+                openGraphObject.put("data", objectProperties);
+            }
+
+            if (id != null) {
+                openGraphObject.put("id", id);
+            }
+        } catch (JSONException e) {
+            throw new FacebookException("An error occurred while setting up the graph object", e);
+        }
+        return openGraphObject;
+    }
+
+    /**
+     * Determines if the open graph object is for posting
+     * @param object The open graph object to check
+     * @return True if the open graph object was created for posting
+     */
+    public static boolean isOpenGraphObjectForPost(JSONObject object) {
+        return object != null
+                ? object.optBoolean(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY) : false;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/ImageDownloader.java b/facebook/src/com/facebook/internal/ImageDownloader.java
index dc55fb917..9309f2beb 100644
--- a/facebook/src/com/facebook/internal/ImageDownloader.java
+++ b/facebook/src/com/facebook/internal/ImageDownloader.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
@@ -19,9 +23,11 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import com.facebook.FacebookException;
+import com.facebook.R;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -30,8 +36,14 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
 public class ImageDownloader {
     private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;
     private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;
@@ -54,8 +66,9 @@ public static void downloadAsync(ImageRequest request) {
         // NOTE: This is the ONLY place where the original request's Url is read. From here on,
         // we will keep track of the Url separately. This is because we might be dealing with a
         // redirect response and the Url might change. We can't create our own new ImageRequests
-        // for these changed Urls since the caller might be doing some book-keeping with the request's
-        // object reference. So we keep the old references and just map them to new urls in the downloader
+        // for these changed Urls since the caller might be doing some book-keeping with the
+        // requests object reference. So we keep the old references and just map them to new urls in
+        // the downloader.
         RequestKey key = new RequestKey(request.getImageUri(), request.getCallerTag());
         synchronized (pendingRequests) {
             DownloaderContext downloaderContext = pendingRequests.get(key);
@@ -76,8 +89,9 @@ public static boolean cancelRequest(ImageRequest request) {
             DownloaderContext downloaderContext = pendingRequests.get(key);
             if (downloaderContext != null) {
                 // If we were able to find the request in our list of pending requests, then we will
-                // definitely be able to prevent an ImageResponse from being issued. This is regardless
-                // of whether a cache-read or network-download is underway for this request.
+                // definitely be able to prevent an ImageResponse from being issued. This is
+                // regardless of whether a cache-read or network-download is underway for this
+                // request.
                 cancelled = true;
 
                 if (downloaderContext.workItem.cancel()) {
@@ -105,10 +119,13 @@ public static void prioritizeRequest(ImageRequest request) {
 
     public static void clearCache(Context context) {
         ImageResponseCache.clearCache(context);
-        UrlRedirectCache.clearCache(context);
+        UrlRedirectCache.clearCache();
     }
 
-    private static void enqueueCacheRead(ImageRequest request, RequestKey key, boolean allowCachedRedirects) {
+    private static void enqueueCacheRead(
+            ImageRequest request,
+            RequestKey key,
+            boolean allowCachedRedirects) {
         enqueueRequest(
                 request,
                 key,
@@ -134,13 +151,14 @@ private static void enqueueRequest(
             downloaderContext.request = request;
             pendingRequests.put(key, downloaderContext);
 
-            // The creation of the WorkItem should be done after the pending request has been registered.
-            // This is necessary since the WorkItem might kick off right away and attempt to retrieve
-            // the request's DownloaderContext prior to it being ready for access.
+            // The creation of the WorkItem should be done after the pending request has been
+            // registered. This is necessary since the WorkItem might kick off right away and
+            // attempt to retrieve the request's DownloaderContext prior to it being ready for
+            // access.
             //
-            // It is also necessary to hold on to the lock until after the workItem is created, since
-            // calls to cancelRequest or prioritizeRequest might come in and expect a registered
-            // request to have a workItem available as well.
+            // It is also necessary to hold on to the lock until after the workItem is created,
+            // since calls to cancelRequest or prioritizeRequest might come in and expect a
+            // registered request to have a workItem available as well.
             downloaderContext.workItem = workQueue.addActiveWorkItem(workItem);
         }
     }
@@ -172,11 +190,14 @@ public void run() {
         }
     }
 
-    private static void readFromCache(RequestKey key, Context context, boolean allowCachedRedirects) {
+    private static void readFromCache(
+            RequestKey key,
+            Context context,
+            boolean allowCachedRedirects) {
         InputStream cachedStream = null;
         boolean isCachedRedirect = false;
         if (allowCachedRedirects) {
-            URI redirectUri = UrlRedirectCache.getRedirectedUri(context, key.uri);
+            Uri redirectUri = UrlRedirectCache.getRedirectedUri(key.uri);
             if (redirectUri != null) {
                 cachedStream = ImageResponseCache.getCachedImageStream(redirectUri, context);
                 isCachedRedirect = cachedStream != null;
@@ -222,11 +243,11 @@ private static void download(RequestKey key, Context context) {
 
                     String redirectLocation = connection.getHeaderField("location");
                     if (!Utility.isNullOrEmpty(redirectLocation)) {
-                        URI redirectUri = new URI(redirectLocation);
-                        UrlRedirectCache.cacheUriRedirect(context, key.uri, redirectUri);
+                        Uri redirectUri = Uri.parse(redirectLocation);
+                        UrlRedirectCache.cacheUriRedirect(key.uri, redirectUri);
 
-                        // Once the old downloader context is removed, we are thread-safe since this is the
-                        // only reference to it
+                        // Once the old downloader context is removed, we are thread-safe since this
+                        // is the only reference to it
                         DownloaderContext downloaderContext = removePendingRequest(key);
                         if (downloaderContext != null && !downloaderContext.isCancelled) {
                             enqueueCacheRead(
@@ -245,22 +266,24 @@ private static void download(RequestKey key, Context context) {
 
                 default:
                     stream = connection.getErrorStream();
-                    InputStreamReader reader = new InputStreamReader(stream);
-                    char[] buffer = new char[128];
-                    int bufferLength;
                     StringBuilder errorMessageBuilder = new StringBuilder();
-                    while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
-                        errorMessageBuilder.append(buffer, 0, bufferLength);
+                    if (stream != null) {
+                        InputStreamReader reader = new InputStreamReader(stream);
+                        char[] buffer = new char[128];
+                        int bufferLength;
+                        while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                            errorMessageBuilder.append(buffer, 0, bufferLength);
+                        }
+                        Utility.closeQuietly(reader);
+                    } else {
+                        errorMessageBuilder.append(
+                            context.getString(R.string.com_facebook_image_download_unknown_error));
                     }
-                    Utility.closeQuietly(reader);
-
                     error = new FacebookException(errorMessageBuilder.toString());
                     break;
             }
         } catch (IOException e) {
             error = e;
-        } catch (URISyntaxException e) {
-            error = e;
         } finally {
             Utility.closeQuietly(stream);
             Utility.disconnectQuietly(connection);
@@ -288,10 +311,10 @@ private static DownloaderContext removePendingRequest(RequestKey key) {
         private static final int HASH_SEED = 29; // Some random prime number
         private static final int HASH_MULTIPLIER = 37; // Some random prime number
 
-        URI uri;
+        Uri uri;
         Object tag;
 
-        RequestKey(URI url, Object tag) {
+        RequestKey(Uri url, Object tag) {
             this.uri = url;
             this.tag = tag;
         }
diff --git a/facebook/src/com/facebook/internal/ImageRequest.java b/facebook/src/com/facebook/internal/ImageRequest.java
index 2c84bf88f..f0dbfbf3e 100644
--- a/facebook/src/com/facebook/internal/ImageRequest.java
+++ b/facebook/src/com/facebook/internal/ImageRequest.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
@@ -21,7 +25,13 @@
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.Locale;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
 public class ImageRequest {
 
     public interface Callback {
@@ -35,24 +45,24 @@
 
     public static final int UNSPECIFIED_DIMENSION = 0;
 
-    private static final String PROFILEPIC_URL_FORMAT =
-            "https://graph.facebook.com/%s/picture";
+    private static final String SCHEME = "https";
+    private static final String AUTHORITY = "graph.facebook.com";
+    private static final String PATH = "%s/picture";
     private static final String HEIGHT_PARAM = "height";
     private static final String WIDTH_PARAM = "width";
     private static final String MIGRATION_PARAM = "migration_overrides";
     private static final String MIGRATION_VALUE = "{october_2012:true}";
 
     private Context context;
-    private URI imageUri;
+    private Uri imageUri;
     private Callback callback;
     private boolean allowCachedRedirects;
     private Object callerTag;
 
-    public static URI getProfilePictureUrl(
+    public static Uri getProfilePictureUri(
             String userId,
             int width,
-            int height)
-            throws URISyntaxException {
+            int height) {
 
         Validate.notNullOrEmpty(userId, "userId");
 
@@ -63,7 +73,11 @@ public static URI getProfilePictureUrl(
             throw new IllegalArgumentException("Either width or height must be greater than 0");
         }
 
-        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
+        Uri.Builder builder =
+                new Uri.Builder()
+                        .scheme(SCHEME)
+                        .authority(AUTHORITY)
+                        .path(String.format(Locale.US, PATH, userId));
 
         if (height != UNSPECIFIED_DIMENSION) {
             builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
@@ -75,7 +89,7 @@ public static URI getProfilePictureUrl(
 
         builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
 
-        return new URI(builder.toString());
+        return builder.build();
     }
 
     private ImageRequest(Builder builder) {
@@ -90,7 +104,7 @@ public Context getContext() {
         return context;
     }
 
-    public URI getImageUri() {
+    public Uri getImageUri() {
         return imageUri;
     }
 
@@ -109,17 +123,17 @@ public Object getCallerTag() {
     public static class Builder {
         // Required
         private Context context;
-        private URI imageUrl;
+        private Uri imageUrl;
 
         // Optional
         private Callback callback;
         private boolean allowCachedRedirects;
         private Object callerTag;
 
-        public Builder(Context context, URI imageUrl) {
-            Validate.notNull(imageUrl, "imageUrl");
+        public Builder(Context context, Uri imageUri) {
+            Validate.notNull(imageUri, "imageUri");
             this.context = context;
-            this.imageUrl = imageUrl;
+            this.imageUrl = imageUri;
         }
 
         public Builder setCallback(Callback callback) {
diff --git a/facebook/src/com/facebook/internal/ImageResponse.java b/facebook/src/com/facebook/internal/ImageResponse.java
index ce2d6045b..d62920eb8 100644
--- a/facebook/src/com/facebook/internal/ImageResponse.java
+++ b/facebook/src/com/facebook/internal/ImageResponse.java
@@ -1,23 +1,32 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
 import android.graphics.Bitmap;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
 public class ImageResponse {
 
     private ImageRequest request;
diff --git a/facebook/src/com/facebook/internal/ImageResponseCache.java b/facebook/src/com/facebook/internal/ImageResponseCache.java
index c61fd38ba..847c441d4 100644
--- a/facebook/src/com/facebook/internal/ImageResponseCache.java
+++ b/facebook/src/com/facebook/internal/ImageResponseCache.java
@@ -1,22 +1,27 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
 import android.content.Context;
+import android.net.Uri;
 import android.util.Log;
 import com.facebook.LoggingBehavior;
 
@@ -28,6 +33,11 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
 class ImageResponseCache {
     static final String TAG = ImageResponseCache.class.getSimpleName();
 
@@ -35,20 +45,20 @@
 
     synchronized static FileLruCache getCache(Context context) throws IOException{
         if (imageCache == null) {
-            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+            imageCache = new FileLruCache(TAG, new FileLruCache.Limits());
         }
         return imageCache;
     }
 
     // Get stream from cache, or return null if the image is not cached.
     // Does not throw if there was an error.
-    static InputStream getCachedImageStream(URI url, Context context) {
+    static InputStream getCachedImageStream(Uri uri, Context context) {
         InputStream imageStream = null;
-        if (url != null) {
-            if (isCDNURL(url)) {
+        if (uri != null) {
+            if (isCDNURL(uri)) {
                 try {
                     FileLruCache cache = getCache(context);
-                    imageStream = cache.get(url.toString());
+                    imageStream = cache.get(uri.toString());
                 } catch (IOException e) {
                     Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, e.toString());
                 }
@@ -58,32 +68,33 @@ static InputStream getCachedImageStream(URI url, Context context) {
         return imageStream;
     }
 
-    static InputStream interceptAndCacheImageStream(Context context, HttpURLConnection connection) throws IOException {
+    static InputStream interceptAndCacheImageStream(
+            Context context,
+            HttpURLConnection connection
+    ) throws IOException {
         InputStream stream = null;
         if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
-            URL url = connection.getURL();
+            Uri uri = Uri.parse(connection.getURL().toString());
             stream = connection.getInputStream(); // Default stream in case caching fails
             try {
-                if (isCDNURL(url.toURI())) {
+                if (isCDNURL(uri)) {
                     FileLruCache cache = getCache(context);
 
                     // Wrap stream with a caching stream
                     stream = cache.interceptAndPut(
-                            url.toString(),
+                            uri.toString(),
                             new BufferedHttpInputStream(stream, connection));
                 }
             } catch (IOException e) {
                 // Caching is best effort
-            } catch (URISyntaxException e) {
-            // Caching is best effort
             }
         }
         return stream;
     }
 
-   private static boolean isCDNURL(URI url) {
-        if (url != null) {
-            String uriHost = url.getHost();
+   private static boolean isCDNURL(Uri uri) {
+        if (uri != null) {
+            String uriHost = uri.getHost();
 
             if (uriHost.endsWith("fbcdn.net")) {
                 return true;
diff --git a/facebook/src/com/facebook/model/JsonUtil.java b/facebook/src/com/facebook/internal/JsonUtil.java
similarity index 70%
rename from facebook/src/com/facebook/model/JsonUtil.java
rename to facebook/src/com/facebook/internal/JsonUtil.java
index 6d2012236..021f9a7ef 100644
--- a/facebook/src/com/facebook/model/JsonUtil.java
+++ b/facebook/src/com/facebook/internal/JsonUtil.java
@@ -1,20 +1,24 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.model;
+package com.facebook.internal;
 
 import android.annotation.SuppressLint;
 import org.json.JSONException;
@@ -22,6 +26,11 @@
 
 import java.util.*;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
 class JsonUtil {
     static void jsonObjectClear(JSONObject jsonObject) {
         @SuppressWarnings("unchecked")
diff --git a/facebook/src/com/facebook/internal/Logger.java b/facebook/src/com/facebook/internal/Logger.java
index a0d43fbbf..335641b2a 100644
--- a/facebook/src/com/facebook/internal/Logger.java
+++ b/facebook/src/com/facebook/internal/Logger.java
@@ -1,32 +1,37 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
 import android.util.Log;
+
+import com.facebook.FacebookSdk;
 import com.facebook.LoggingBehavior;
-import com.facebook.Settings;
 
 import java.util.HashMap;
 import java.util.Map;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public class Logger {
     public static final String LOG_TAG_BASE = "FacebookSDK.";
@@ -37,14 +42,14 @@
     private StringBuilder contents;
     private int priority = Log.DEBUG;
 
-    // Note that the mapping of replaced strings is never emptied, so it should be used only for things that
-    // are not expected to be too numerous, such as access tokens.
+    // Note that the mapping of replaced strings is never emptied, so it should be used only for
+    // things that are not expected to be too numerous, such as access tokens.
     public synchronized static void registerStringToReplace(String original, String replace) {
         stringsToReplace.put(original, replace);
     }
 
     public synchronized static void registerAccessToken(String accessToken) {
-        if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) == false) {
+        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) == false) {
             registerStringToReplace(accessToken, "ACCESS_TOKEN_REMOVED");
         }
     }
@@ -54,22 +59,22 @@ public static void log(LoggingBehavior behavior, String tag, String string) {
     }
 
     public static void log(LoggingBehavior behavior, String tag, String format, Object... args) {
-        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+        if (FacebookSdk.isLoggingBehaviorEnabled(behavior)) {
             String string = String.format(format, args);
             log(behavior, Log.DEBUG, tag, string);
         }
     }
 
     public static void log(LoggingBehavior behavior, int priority, String tag, String string) {
-        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+        if (FacebookSdk.isLoggingBehaviorEnabled(behavior)) {
             string = replaceStrings(string);
             if (tag.startsWith(LOG_TAG_BASE) == false) {
                 tag = LOG_TAG_BASE + tag;
             }
             Log.println(priority, tag, string);
 
-            // Developer errors warrant special treatment by printing out a stack trace, to make both more noticeable,
-            // and let the source of the problem be more easily pinpointed.
+            // Developer errors warrant special treatment by printing out a stack trace, to make
+            // both more noticeable, and let the source of the problem be more easily pinpointed.
             if (behavior == LoggingBehavior.DEVELOPER_ERRORS) {
                 (new Exception()).printStackTrace();
             }
@@ -96,7 +101,8 @@ public int getPriority() {
     }
 
     public void setPriority(int value) {
-        Validate.oneOf(value, "value", Log.ASSERT, Log.DEBUG, Log.ERROR, Log.INFO, Log.VERBOSE, Log.WARN);
+        Validate.oneOf(
+                value, "value", Log.ASSERT, Log.DEBUG, Log.ERROR, Log.INFO, Log.VERBOSE, Log.WARN);
 
         priority = value;
     }
@@ -139,6 +145,6 @@ public void appendKeyValue(String key, Object value) {
     }
 
     private boolean shouldLog() {
-        return Settings.isLoggingBehaviorEnabled(behavior);
+        return FacebookSdk.isLoggingBehaviorEnabled(behavior);
     }
 }
diff --git a/facebook/src/com/facebook/internal/LoginAuthorizationType.java b/facebook/src/com/facebook/internal/LoginAuthorizationType.java
new file mode 100644
index 000000000..278a8c739
--- /dev/null
+++ b/facebook/src/com/facebook/internal/LoginAuthorizationType.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public enum LoginAuthorizationType {
+    READ,
+    PUBLISH
+}
diff --git a/facebook/src/com/facebook/internal/Mutable.java b/facebook/src/com/facebook/internal/Mutable.java
new file mode 100644
index 000000000..e422ce3b7
--- /dev/null
+++ b/facebook/src/com/facebook/internal/Mutable.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class Mutable<T> {
+    public T value;
+
+    public Mutable(T value) {
+        this.value = value;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/NativeAppCallAttachmentStore.java b/facebook/src/com/facebook/internal/NativeAppCallAttachmentStore.java
new file mode 100644
index 000000000..1b1932c04
--- /dev/null
+++ b/facebook/src/com/facebook/internal/NativeAppCallAttachmentStore.java
@@ -0,0 +1,272 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.util.Log;
+
+import com.facebook.FacebookContentProvider;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+
+import java.io.*;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ *
+ * <p>This class works in conjunction with {@link com.facebook.FacebookContentProvider} to allow
+ * apps to attach binary attachments (e.g., images) to native dialogs launched via the sdk.It stores
+ * attachments in temporary files and allows the Facebook application to retrieve them via the
+ * content provider.</p>
+ */
+public final class NativeAppCallAttachmentStore {
+    private static final String TAG = NativeAppCallAttachmentStore.class.getName();
+    static final String ATTACHMENTS_DIR_NAME = "com.facebook.NativeAppCallAttachmentStore.files";
+    private static File attachmentsDirectory;
+
+    private NativeAppCallAttachmentStore() {}
+
+    public static Attachment createAttachment(UUID callId, Bitmap attachmentBitmap) {
+        Validate.notNull(callId, "callId");
+        Validate.notNull(attachmentBitmap, "attachmentBitmap");
+
+        return new Attachment(callId, attachmentBitmap, null);
+    }
+
+    public static Attachment createAttachment(UUID callId, Uri attachmentUri) {
+        Validate.notNull(callId, "callId");
+        Validate.notNull(attachmentUri, "attachmentUri");
+
+        return new Attachment(callId, null, attachmentUri);
+    }
+
+    private static void processAttachmentBitmap(Bitmap bitmap, File outputFile) throws IOException {
+        FileOutputStream outputStream = new FileOutputStream(outputFile);
+        try {
+            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);
+        } finally {
+            Utility.closeQuietly(outputStream);
+        }
+    }
+
+    private static void processAttachmentFile(
+            Uri imageUri,
+            boolean isContentUri,
+            File outputFile) throws IOException {
+        FileOutputStream outputStream = new FileOutputStream(outputFile);
+        try {
+            InputStream inputStream = null;
+            if (!isContentUri) {
+                inputStream = new FileInputStream(imageUri.getPath());
+            } else {
+                inputStream = FacebookSdk
+                        .getApplicationContext()
+                        .getContentResolver()
+                        .openInputStream(imageUri);
+            }
+
+            Utility.copyAndCloseInputStream(inputStream, outputStream);
+        } finally {
+            Utility.closeQuietly(outputStream);
+        }
+    }
+
+    public static void addAttachments(Collection<Attachment> attachments) {
+        if (attachments == null || attachments.size() == 0) {
+            return;
+        }
+
+        // If this is the first time we've been instantiated, clean up any existing attachments.
+        if (attachmentsDirectory == null) {
+            cleanupAllAttachments();
+        }
+
+        ensureAttachmentsDirectoryExists();
+
+        List<File> filesToCleanup = new ArrayList<>();
+
+        try {
+            for (Attachment attachment : attachments) {
+                if (!attachment.isBinaryData) {
+                    continue;
+                }
+
+                File file = getAttachmentFile(
+                        attachment.callId,
+                        attachment.attachmentName,
+                        true);
+                filesToCleanup.add(file);
+
+                if (attachment.bitmap != null) {
+                    processAttachmentBitmap(attachment.bitmap, file);
+                } else if (attachment.imageUri != null) {
+                    processAttachmentFile(
+                            attachment.imageUri,
+                            attachment.isContentUri,
+                            file);
+                }
+            }
+        } catch (IOException exception) {
+            Log.e(TAG, "Got unexpected exception:" + exception);
+            for (File file : filesToCleanup) {
+                try {
+                    file.delete();
+                } catch (Exception e) {
+                    // Always try to delete other files.
+                }
+            }
+            throw new FacebookException(exception);
+        }
+    }
+
+    /**
+     * Removes any temporary files associated with a particular native app call.
+     *
+     * @param callId the unique ID of the call
+     */
+    public static void cleanupAttachmentsForCall(UUID callId) {
+        File dir = getAttachmentsDirectoryForCall(callId, false);
+        if (dir != null) {
+            Utility.deleteDirectory(dir);
+        }
+    }
+
+    public static File openAttachment(UUID callId, String attachmentName)
+            throws FileNotFoundException {
+        if (Utility.isNullOrEmpty(attachmentName) ||
+                callId == null) {
+            throw new FileNotFoundException();
+        }
+
+        try {
+            return getAttachmentFile(callId, attachmentName, false);
+        } catch (IOException e) {
+            // We don't try to create the file, so we shouldn't get any IOExceptions. But if we do,
+            // just act like the file wasn't found.
+            throw new FileNotFoundException();
+        }
+    }
+
+    synchronized static File getAttachmentsDirectory() {
+        if (attachmentsDirectory == null) {
+            attachmentsDirectory = new File(
+                    FacebookSdk.getApplicationContext().getCacheDir(),
+                    ATTACHMENTS_DIR_NAME);
+        }
+        return attachmentsDirectory;
+    }
+
+    static File ensureAttachmentsDirectoryExists() {
+        File dir = getAttachmentsDirectory();
+        dir.mkdirs();
+        return dir;
+    }
+
+    static File getAttachmentsDirectoryForCall(UUID callId, boolean create) {
+        if (attachmentsDirectory == null) {
+            return null;
+        }
+
+        File dir = new File(attachmentsDirectory, callId.toString());
+        if (create && !dir.exists()) {
+            dir.mkdirs();
+        }
+        return dir;
+    }
+
+    static File getAttachmentFile(
+            UUID callId,
+            String attachmentName,
+            boolean createDirs
+    ) throws IOException {
+        File dir = getAttachmentsDirectoryForCall(callId, createDirs);
+        if (dir == null) {
+            return null;
+        }
+
+        try {
+            return new File(dir, URLEncoder.encode(attachmentName, "UTF-8"));
+        } catch (UnsupportedEncodingException e) {
+            return null;
+        }
+    }
+
+    public static void cleanupAllAttachments() {
+        // Attachments directory may or may not exist; we won't create it if not, since we are just
+        // going to delete it.
+        File dir = getAttachmentsDirectory();
+        Utility.deleteDirectory(dir);
+    }
+
+    public static final class Attachment {
+        private final UUID callId;
+        private final String attachmentUrl;
+        private final String attachmentName;
+
+        private Bitmap bitmap;
+        private Uri imageUri;
+
+        private boolean isContentUri;
+        private boolean isBinaryData;
+
+        private Attachment(UUID callId, Bitmap bitmap, Uri uri) {
+            this.callId = callId;
+            this.bitmap = bitmap;
+            this.imageUri = uri;
+
+            if (uri != null) {
+                String scheme = uri.getScheme();
+                if ("content".equalsIgnoreCase(scheme)) {
+                    isContentUri = true;
+                    isBinaryData = true;
+                } else if ("file".equalsIgnoreCase(uri.getScheme())) {
+                    isBinaryData = true;
+                } else if (!Utility.isWebUri(uri)) {
+                    throw new FacebookException("Unsupported scheme for image Uri : " + scheme);
+                }
+            } else if (bitmap != null) {
+                isBinaryData = true;
+            } else {
+                throw new FacebookException("Cannot share a photo without a bitmap or Uri set");
+            }
+
+            attachmentName = !isBinaryData ? null : UUID.randomUUID().toString();
+            attachmentUrl = !isBinaryData
+                    ? this.imageUri.toString() // http(s) images can be used directly
+                    : FacebookContentProvider.getAttachmentUrl(
+                            FacebookSdk.getApplicationId(),
+                            callId,
+                            attachmentName);
+        }
+
+        public String getAttachmentUrl() {
+            return attachmentUrl;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/NativeProtocol.java b/facebook/src/com/facebook/internal/NativeProtocol.java
index 98417dcdc..f6aa30434 100644
--- a/facebook/src/com/facebook/internal/NativeProtocol.java
+++ b/facebook/src/com/facebook/internal/NativeProtocol.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
@@ -25,24 +29,31 @@
 import android.os.Build;
 import android.os.Bundle;
 import android.text.TextUtils;
-import com.facebook.*;
-import com.facebook.android.BuildConfig;
+import com.facebook.FacebookException;
+import com.facebook.FacebookOperationCanceledException;
+import com.facebook.FacebookSdk;
+import com.facebook.login.DefaultAudience;
 
 import java.util.*;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public final class NativeProtocol {
 
     public static final int NO_PROTOCOL_AVAILABLE = -1;
 
     private static final String FACEBOOK_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
-    private static final String FACEBOOK_TOKEN_REFRESH_ACTIVITY = "com.facebook.katana.platform.TokenRefreshService";
+    private static final String FACEBOOK_TOKEN_REFRESH_ACTIVITY =
+            "com.facebook.katana.platform.TokenRefreshService";
 
-    private static final String BASIC_INFO = "basic_info";
     public static final String FACEBOOK_PROXY_AUTH_PERMISSIONS_KEY = "scope";
     public static final String FACEBOOK_PROXY_AUTH_APP_ID_KEY = "client_id";
     public static final String FACEBOOK_PROXY_AUTH_E2E_KEY = "e2e";
@@ -57,18 +68,53 @@
     public static final int PROTOCOL_VERSION_20130502 = 20130502;
     public static final int PROTOCOL_VERSION_20130618 = 20130618;
     public static final int PROTOCOL_VERSION_20131107 = 20131107;
-    public static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
-    public static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
-    public static final String EXTRA_PROTOCOL_CALL_ID = "com.facebook.platform.protocol.CALL_ID";
-    public static final String EXTRA_GET_INSTALL_DATA_PACKAGE = "com.facebook.platform.extra.INSTALLDATA_PACKAGE";
+    public static final int PROTOCOL_VERSION_20140204 = 20140204;
+    public static final int PROTOCOL_VERSION_20140324 = 20140324;
+    public static final int PROTOCOL_VERSION_20140701 = 20140701;
+    public static final int PROTOCOL_VERSION_20141001 = 20141001;
+    public static final int PROTOCOL_VERSION_20141028 = 20141028;
+    public static final int PROTOCOL_VERSION_20141107 = 20141107; // Bucketed Result Intents
+    public static final int PROTOCOL_VERSION_20141218 = 20141218;
+
+    public static final String EXTRA_PROTOCOL_VERSION =
+            "com.facebook.platform.protocol.PROTOCOL_VERSION";
+    public static final String EXTRA_PROTOCOL_ACTION =
+            "com.facebook.platform.protocol.PROTOCOL_ACTION";
+    public static final String EXTRA_PROTOCOL_CALL_ID =
+            "com.facebook.platform.protocol.CALL_ID";
+    public static final String EXTRA_GET_INSTALL_DATA_PACKAGE =
+            "com.facebook.platform.extra.INSTALLDATA_PACKAGE";
+
+    public static final String EXTRA_PROTOCOL_BRIDGE_ARGS =
+            "com.facebook.platform.protocol.BRIDGE_ARGS";
+
+    public static final String EXTRA_PROTOCOL_METHOD_ARGS =
+            "com.facebook.platform.protocol.METHOD_ARGS";
+
+    public static final String EXTRA_PROTOCOL_METHOD_RESULTS =
+            "com.facebook.platform.protocol.RESULT_ARGS";
+
+    public static final String BRIDGE_ARG_APP_NAME_STRING = "app_name";
+    public static final String BRIDGE_ARG_ACTION_ID_STRING = "action_id";
+    public static final String BRIDGE_ARG_ERROR_BUNDLE = "error";
+
+    public static final String EXTRA_DIALOG_COMPLETE_KEY =
+            "com.facebook.platform.extra.DID_COMPLETE";
+    public static final String EXTRA_DIALOG_COMPLETION_GESTURE_KEY =
+            "com.facebook.platform.extra.COMPLETION_GESTURE";
+
+    public static final String RESULT_ARGS_DIALOG_COMPLETE_KEY = "didComplete";
+    public static final String RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY = "completionGesture";
 
     // Messages supported by PlatformService:
-    public static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000;
-    public static final int MESSAGE_GET_ACCESS_TOKEN_REPLY   = 0x10001;
-    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REQUEST = 0x10002;
-    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REPLY   = 0x10003;
-    public static final int MESSAGE_GET_INSTALL_DATA_REQUEST = 0x10004;
-    public static final int MESSAGE_GET_INSTALL_DATA_REPLY   = 0x10005;
+    public static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST    = 0x10000;
+    public static final int MESSAGE_GET_ACCESS_TOKEN_REPLY      = 0x10001;
+    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REQUEST      = 0x10002;
+    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REPLY        = 0x10003;
+    public static final int MESSAGE_GET_INSTALL_DATA_REQUEST    = 0x10004;
+    public static final int MESSAGE_GET_INSTALL_DATA_REPLY      = 0x10005;
+    public static final int MESSAGE_GET_LIKE_STATUS_REQUEST     = 0x10006;
+    public static final int MESSAGE_GET_LIKE_STATUS_REPLY       = 0x10007;
 
     // MESSAGE_ERROR_REPLY data keys:
     // See STATUS_*
@@ -81,28 +127,42 @@
     // EXTRA_EXPIRES_SECONDS_SINCE_EPOCH
     // EXTRA_PERMISSIONS
 
+    // MESSAGE_GET_LIKE_STATUS_REQUEST data keys:
+    // EXTRA_APPLICATION_ID
+    // EXTRA_OBJECT_ID
+
+    // MESSAGE_GET_LIKE_STATUS_REPLY data keys:
+    // EXTRA_OBJECT_IS_LIKED
+    // EXTRA_LIKE_COUNT_STRING_WITH_LIKE
+    // EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE
+    // EXTRA_SOCIAL_SENTENCE_WITH_LIKE
+    // EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE
+    // EXTRA_UNLIKE_TOKEN
+
     // MESSAGE_GET_PROTOCOL_VERSIONS_REPLY data keys:
     static final String EXTRA_PROTOCOL_VERSIONS = "com.facebook.platform.extra.PROTOCOL_VERSIONS";
 
     // Values of EXTRA_PROTOCOL_ACTION supported by PlatformActivity:
-    public static final String ACTION_LOGIN_DIALOG = "com.facebook.platform.action.request.LOGIN_DIALOG";
-    public static final String ACTION_FEED_DIALOG = "com.facebook.platform.action.request.FEED_DIALOG";
+    public static final String ACTION_FEED_DIALOG =
+            "com.facebook.platform.action.request.FEED_DIALOG";
+    public static final String ACTION_MESSAGE_DIALOG =
+            "com.facebook.platform.action.request.MESSAGE_DIALOG";
     public static final String ACTION_OGACTIONPUBLISH_DIALOG =
             "com.facebook.platform.action.request.OGACTIONPUBLISH_DIALOG";
-
-    // Values of EXTRA_PROTOCOL_ACTION values returned by PlatformActivity:
-    static final String ACTION_LOGIN_DIALOG_REPLY =
-            "com.facebook.platform.action.reply.LOGIN_DIALOG";
-    public static final String ACTION_FEED_DIALOG_REPLY =
-            "com.facebook.platform.action.reply.FEED_DIALOG";
-    public static final String ACTION_OGACTIONPUBLISH_DIALOG_REPLY =
-            "com.facebook.platform.action.reply.OGACTIONPUBLISH_DIALOG";
+    public static final String ACTION_OGMESSAGEPUBLISH_DIALOG =
+            "com.facebook.platform.action.request.OGMESSAGEPUBLISH_DIALOG";
+    public static final String ACTION_LIKE_DIALOG =
+            "com.facebook.platform.action.request.LIKE_DIALOG";
+    // The value of ACTION_APPINVITE_DIALOG is different since that is what is on the server.
+    public static final String ACTION_APPINVITE_DIALOG =
+            "com.facebook.platform.action.request.APPINVITES_DIALOG";
 
     // Extras supported for ACTION_LOGIN_DIALOG:
     public static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS";
-    public static final String EXTRA_WRITE_PRIVACY = "com.facebook.platform.extra.WRITE_PRIVACY";
     public static final String EXTRA_APPLICATION_ID = "com.facebook.platform.extra.APPLICATION_ID";
-    public static final String EXTRA_APPLICATION_NAME = "com.facebook.platform.extra.APPLICATION_NAME";
+    public static final String EXTRA_APPLICATION_NAME =
+            "com.facebook.platform.extra.APPLICATION_NAME";
+    public static final String EXTRA_USER_ID = "com.facebook.platform.extra.USER_ID";
 
     // Extras returned by setResult() for ACTION_LOGIN_DIALOG
     public static final String EXTRA_ACCESS_TOKEN = "com.facebook.platform.extra.ACCESS_TOKEN";
@@ -110,24 +170,13 @@
             "com.facebook.platform.extra.EXPIRES_SECONDS_SINCE_EPOCH";
     // EXTRA_PERMISSIONS
 
-    // Extras supported for ACTION_FEED_DIALOG:
-    public static final String EXTRA_PLACE_TAG = "com.facebook.platform.extra.PLACE";
-    public static final String EXTRA_FRIEND_TAGS = "com.facebook.platform.extra.FRIENDS";
-    public static final String EXTRA_LINK = "com.facebook.platform.extra.LINK";
-    public static final String EXTRA_IMAGE = "com.facebook.platform.extra.IMAGE";
-    public static final String EXTRA_TITLE = "com.facebook.platform.extra.TITLE";
-    public static final String EXTRA_SUBTITLE = "com.facebook.platform.extra.SUBTITLE";
-    public static final String EXTRA_DESCRIPTION = "com.facebook.platform.extra.DESCRIPTION";
-    public static final String EXTRA_REF = "com.facebook.platform.extra.REF";
-    public static final String EXTRA_DATA_FAILURES_FATAL = "com.facebook.platform.extra.DATA_FAILURES_FATAL";
-
-    // Extras supported for ACTION_OGACTIONPUBLISH_DIALOG:
-    public static final String EXTRA_ACTION = "com.facebook.platform.extra.ACTION";
-    public static final String EXTRA_ACTION_TYPE = "com.facebook.platform.extra.ACTION_TYPE";
-    public static final String EXTRA_PREVIEW_PROPERTY_NAME =
-            "com.facebook.platform.extra.PREVIEW_PROPERTY_NAME";
-
-    // OG objects will have this key to set to true if they should be created as part of OG Action publish
+    public static final String RESULT_ARGS_ACCESS_TOKEN = "access_token";
+    public static final String RESULT_ARGS_EXPIRES_SECONDS_SINCE_EPOCH =
+            "expires_seconds_since_epoch";
+    public static final String RESULT_ARGS_PERMISSIONS = "permissions";
+
+    // OG objects will have this key to set to true if they should be created as part of OG Action
+    // publish
     public static final String OPEN_GRAPH_CREATE_OBJECT_KEY = "fbsdk:create_object";
     // Determines whether an image is user generated
     public static final String IMAGE_USER_GENERATED_KEY = "user_generated";
@@ -143,6 +192,12 @@
     public static final String STATUS_ERROR_SUBCODE = "com.facebook.platform.status.ERROR_SUBCODE";
     public static final String STATUS_ERROR_JSON = "com.facebook.platform.status.ERROR_JSON";
 
+    public static final String BRIDGE_ARG_ERROR_TYPE = "error_type";
+    public static final String BRIDGE_ARG_ERROR_DESCRIPTION = "error_description";
+    public static final String BRIDGE_ARG_ERROR_CODE = "error_code";
+    public static final String BRIDGE_ARG_ERROR_SUBCODE = "error_subcode";
+    public static final String BRIDGE_ARG_ERROR_JSON = "error_json";
+
     // Expected values for ERROR_KEY_TYPE.  Clients should tolerate other values:
     public static final String ERROR_UNKNOWN_ERROR = "UnknownError";
     public static final String ERROR_PROTOCOL_ERROR = "ProtocolError";
@@ -152,27 +207,46 @@
     public static final String ERROR_PERMISSION_DENIED = "PermissionDenied";
     public static final String ERROR_SERVICE_DISABLED = "ServiceDisabled";
 
-    public static final String AUDIENCE_ME = "SELF";
-    public static final String AUDIENCE_FRIENDS = "ALL_FRIENDS";
-    public static final String AUDIENCE_EVERYONE = "EVERYONE";
+    public static final String WEB_DIALOG_URL = "url";
+    public static final String WEB_DIALOG_ACTION = "action";
+    public static final String WEB_DIALOG_PARAMS = "params";
+    public static final String WEB_DIALOG_IS_FALLBACK = "is_fallback";
 
-    // Request codes for different categories of native protocol calls.
-    public static final int DIALOG_REQUEST_CODE = 0xfacf;
+    public static final String AUDIENCE_ME = "only_me";
+    public static final String AUDIENCE_FRIENDS = "friends";
+    public static final String AUDIENCE_EVERYONE = "everyone";
 
     private static final String CONTENT_SCHEME = "content://";
-    private static final String PLATFORM_PROVIDER_VERSIONS = ".provider.PlatformProvider/versions";
+    private static final String PLATFORM_PROVIDER = ".provider.PlatformProvider";
+    private static final String PLATFORM_PROVIDER_VERSIONS = PLATFORM_PROVIDER + "/versions";
 
     // Columns returned by PlatformProvider
     private static final String PLATFORM_PROVIDER_VERSION_COLUMN = "version";
 
     private static abstract class NativeAppInfo {
         abstract protected String getPackage();
-        abstract protected String getSignature();
+
+        private static final String FBI_HASH = "a4b7452e2ed8f5f191058ca7bbfd26b0d3214bfc";
+        private static final String FBL_HASH = "5e8f16062ea3cd2c4a0d547876baa6f38cabf625";
+        private static final String FBR_HASH = "8a3c4b262d721acd49a4bf97d5213199c86fa2b9";
+
+        private static final HashSet<String> validAppSignatureHashes = buildAppSignatureHashes();
+
+        private TreeSet<Integer> availableVersions;
+
+        private static HashSet<String> buildAppSignatureHashes() {
+            HashSet<String> set = new HashSet<String>();
+            set.add(FBR_HASH);
+            set.add(FBI_HASH);
+            set.add(FBL_HASH);
+            return set;
+        }
 
         public boolean validateSignature(Context context, String packageName) {
             String brand = Build.BRAND;
             int applicationFlags = context.getApplicationInfo().flags;
-            if (brand.startsWith("generic") && (applicationFlags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
+            if (brand.startsWith("generic") &&
+                    (applicationFlags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                 // We are debugging on an emulator, don't validate package signature.
                 return true;
             }
@@ -186,7 +260,8 @@ public boolean validateSignature(Context context, String packageName) {
             }
 
             for (Signature signature : packageInfo.signatures) {
-                if (signature.toCharsString().equals(this.getSignature())) {
+                String hashedSignature = Utility.sha1hash(signature.toByteArray());
+                if (validAppSignatureHashes.contains(hashedSignature)) {
                     return true;
                 }
             }
@@ -194,53 +269,40 @@ public boolean validateSignature(Context context, String packageName) {
             return false;
         }
 
+        public TreeSet<Integer> getAvailableVersions() {
+            if (availableVersions == null) {
+                fetchAvailableVersions(false);
+            }
+            return availableVersions;
+        }
+
+        private synchronized void fetchAvailableVersions(boolean force) {
+            if (force || availableVersions == null) {
+                availableVersions = fetchAllAvailableProtocolVersionsForAppInfo(this);
+            }
+        }
     }
 
     private static class KatanaAppInfo extends NativeAppInfo {
         static final String KATANA_PACKAGE = "com.facebook.katana";
-        static final String KATANA_SIGNATURE =
-                "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
-                        + "b3009060355040613025553310b30090603550408130243413112301006035504"
-                        + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
-                        + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
-                        + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
-                        + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
-                        + "55040613025553310b30090603550408130243413112301006035504071309506"
-                        + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
-                        + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
-                        + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
-                        + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
-                        + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
-                        + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
-                        + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
-                        + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
-                        + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
-                        + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
-                        + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
-                        + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
-                        + "928a2";
-        @Override
-        protected String getSignature() {
-            return KATANA_SIGNATURE;
-        }
+
         @Override
         protected String getPackage() {
             return KATANA_PACKAGE;
         }
     }
 
-    private static class WakizashiAppInfo extends NativeAppInfo {
-        static final String WAKIZASHI_PACKAGE = "com.facebook.wakizashi";
+    private static class MessengerAppInfo extends NativeAppInfo {
+        static final String MESSENGER_PACKAGE = "com.facebook.orca";
 
         @Override
-        public boolean validateSignature(Context context, String packageName) {
-            return true;
+        protected String getPackage() {
+            return MESSENGER_PACKAGE;
         }
+    }
 
-        @Override
-        protected String getSignature() {
-            return null;
-        }
+    private static class WakizashiAppInfo extends NativeAppInfo {
+        static final String WAKIZASHI_PACKAGE = "com.facebook.wakizashi";
 
         @Override
         protected String getPackage() {
@@ -251,16 +313,15 @@ protected String getPackage() {
     private static final NativeAppInfo FACEBOOK_APP_INFO = new KatanaAppInfo();
     private static List<NativeAppInfo> facebookAppInfoList = buildFacebookAppList();
     private static Map<String, List<NativeAppInfo>> actionToAppInfoMap = buildActionToAppInfoMap();
+    private static AtomicBoolean protocolVersionsAsyncUpdating = new AtomicBoolean(false);
 
     private static List<NativeAppInfo> buildFacebookAppList() {
         List<NativeAppInfo> list = new ArrayList<NativeAppInfo>();
 
-        // Katana needs to be the first thing in the list since it will get selected as the default FACEBOOK_APP_INFO
+        // Katana needs to be the first thing in the list since it will get selected as the default
+        // FACEBOOK_APP_INFO
         list.add(FACEBOOK_APP_INFO);
-
-        if(BuildConfig.DEBUG) {
-            list.add(new WakizashiAppInfo());
-        }
+        list.add(new WakizashiAppInfo());
 
         return list;
     }
@@ -268,10 +329,16 @@ protected String getPackage() {
     private static Map<String, List<NativeAppInfo>> buildActionToAppInfoMap() {
         Map<String, List<NativeAppInfo>> map = new HashMap<String, List<NativeAppInfo>>();
 
+        ArrayList<NativeAppInfo> messengerAppInfoList = new ArrayList<NativeAppInfo>();
+        messengerAppInfoList.add(new MessengerAppInfo());
+
         // Add individual actions and the list they should try
         map.put(ACTION_OGACTIONPUBLISH_DIALOG, facebookAppInfoList);
         map.put(ACTION_FEED_DIALOG, facebookAppInfoList);
-        map.put(ACTION_LOGIN_DIALOG, facebookAppInfoList);
+        map.put(ACTION_LIKE_DIALOG, facebookAppInfoList);
+        map.put(ACTION_APPINVITE_DIALOG, facebookAppInfoList);
+        map.put(ACTION_MESSAGE_DIALOG, messengerAppInfoList);
+        map.put(ACTION_OGMESSAGEPUBLISH_DIALOG, messengerAppInfoList);
 
         return map;
     }
@@ -310,39 +377,98 @@ static Intent validateServiceIntent(Context context, Intent intent, NativeAppInf
         return intent;
     }
 
-    public static Intent createProxyAuthIntent(Context context, String applicationId, List<String> permissions,
-            String e2e) {
-        Intent intent = new Intent()
-                .setClassName(FACEBOOK_APP_INFO.getPackage(), FACEBOOK_PROXY_AUTH_ACTIVITY)
-                .putExtra(FACEBOOK_PROXY_AUTH_APP_ID_KEY, applicationId);
+    public static Intent createProxyAuthIntent(
+            Context context,
+            String applicationId,
+            Collection<String> permissions,
+            String e2e,
+            boolean isRerequest,
+            boolean isForPublish,
+            DefaultAudience defaultAudience) {
+        for (NativeAppInfo appInfo : facebookAppInfoList) {
+            Intent intent = new Intent()
+                    .setClassName(appInfo.getPackage(), FACEBOOK_PROXY_AUTH_ACTIVITY)
+                    .putExtra(FACEBOOK_PROXY_AUTH_APP_ID_KEY, applicationId);
 
-        if (!Utility.isNullOrEmpty(permissions)) {
-            intent.putExtra(FACEBOOK_PROXY_AUTH_PERMISSIONS_KEY, TextUtils.join(",", permissions));
-        }
-        if (!Utility.isNullOrEmpty(e2e)) {
-            intent.putExtra(FACEBOOK_PROXY_AUTH_E2E_KEY, e2e);
-        }
+            if (!Utility.isNullOrEmpty(permissions)) {
+                intent.putExtra(
+                        FACEBOOK_PROXY_AUTH_PERMISSIONS_KEY, TextUtils.join(",", permissions));
+            }
+            if (!Utility.isNullOrEmpty(e2e)) {
+                intent.putExtra(FACEBOOK_PROXY_AUTH_E2E_KEY, e2e);
+            }
+
+            intent.putExtra(
+                    ServerProtocol.DIALOG_PARAM_RESPONSE_TYPE,
+                    ServerProtocol.DIALOG_RESPONSE_TYPE_TOKEN_AND_SIGNED_REQUEST);
+            intent.putExtra(
+                    ServerProtocol.DIALOG_PARAM_RETURN_SCOPES,
+                    ServerProtocol.DIALOG_RETURN_SCOPES_TRUE);
+            if (isForPublish) {
+                intent.putExtra(
+                        ServerProtocol.DIALOG_PARAM_DEFAULT_AUDIENCE,
+                        defaultAudience.getNativeProtocolAudience());
+            }
+
+            // Override the API Version for Auth
+            intent.putExtra(
+                    ServerProtocol.DIALOG_PARAM_LEGACY_OVERRIDE,
+                    ServerProtocol.GRAPH_API_VERSION);
+
+            // Set the re-request auth type for requests
+            if (isRerequest) {
+                intent.putExtra(
+                        ServerProtocol.DIALOG_PARAM_AUTH_TYPE,
+                        ServerProtocol.DIALOG_REREQUEST_AUTH_TYPE);
+            }
+
+            intent = validateActivityIntent(context, intent, appInfo);
 
-        return validateActivityIntent(context, intent, FACEBOOK_APP_INFO);
+            if (intent != null) {
+                return intent;
+            }
+        }
+        return null;
     }
 
     public static Intent createTokenRefreshIntent(Context context) {
-        Intent intent = new Intent()
-                .setClassName(FACEBOOK_APP_INFO.getPackage(), FACEBOOK_TOKEN_REFRESH_ACTIVITY);
+        for (NativeAppInfo appInfo : facebookAppInfoList) {
+            Intent intent = new Intent()
+                    .setClassName(appInfo.getPackage(), FACEBOOK_TOKEN_REFRESH_ACTIVITY);
+
+            intent = validateServiceIntent(context, intent, appInfo);
 
-        return validateServiceIntent(context, intent, FACEBOOK_APP_INFO);
+            if (intent != null) {
+                return intent;
+            }
+        }
+        return null;
+    }
+
+    public static final int getLatestKnownVersion() {
+        return KNOWN_PROTOCOL_VERSIONS.get(0);
     }
 
     // Note: be sure this stays sorted in descending order; add new versions at the beginning
     private static final List<Integer> KNOWN_PROTOCOL_VERSIONS =
             Arrays.asList(
+                    PROTOCOL_VERSION_20141218,
+                    PROTOCOL_VERSION_20141107,
+                    PROTOCOL_VERSION_20141028,
+                    PROTOCOL_VERSION_20141001,
+                    PROTOCOL_VERSION_20140701,
+                    PROTOCOL_VERSION_20140324,
+                    PROTOCOL_VERSION_20140204,
                     PROTOCOL_VERSION_20131107,
                     PROTOCOL_VERSION_20130618,
                     PROTOCOL_VERSION_20130502,
                     PROTOCOL_VERSION_20121101
             );
 
-    private static Intent findActivityIntent(Context context, String activityAction, String internalAction) {
+    private static Intent findActivityIntent(
+            Context context,
+            String activityAction,
+            String internalAction) {
         List<NativeAppInfo> list = actionToAppInfoMap.get(internalAction);
         if (list == null) {
             return null;
@@ -363,19 +489,97 @@ private static Intent findActivityIntent(Context context, String activityAction,
         return intent;
     }
 
-    public static Intent createPlatformActivityIntent(Context context, String action, int version, Bundle extras) {
+    public static boolean isVersionCompatibleWithBucketedIntent(int version) {
+        return KNOWN_PROTOCOL_VERSIONS.contains(version) && version >= PROTOCOL_VERSION_20140701;
+    }
+
+    /**
+     * Will create an Intent that can be used to invoke an action in a Facebook app via the
+     * Native Protocol
+     */
+    public static Intent createPlatformActivityIntent(
+            Context context,
+            String callId,
+            String action,
+            int version,
+            Bundle extras) {
         Intent intent = findActivityIntent(context, INTENT_ACTION_PLATFORM_ACTIVITY, action);
         if (intent == null) {
             return null;
         }
 
-        intent.putExtras(extras)
-                .putExtra(EXTRA_PROTOCOL_VERSION, version)
-                .putExtra(EXTRA_PROTOCOL_ACTION, action);
+        setupProtocolRequestIntent(intent, callId, action, version, extras);
 
         return intent;
     }
 
+    /**
+     * Will setup the passed in Intent in the shape of a Native Protocol request Intent.
+     */
+    public static void setupProtocolRequestIntent(
+            Intent intent,
+            String callId,
+            String action,
+            int version,
+            Bundle params) {
+        String applicationId = FacebookSdk.getApplicationId();
+        String applicationName = FacebookSdk.getApplicationName();
+
+        intent.putExtra(EXTRA_PROTOCOL_VERSION, version)
+                .putExtra(EXTRA_PROTOCOL_ACTION, action)
+                .putExtra(EXTRA_APPLICATION_ID, applicationId);
+
+        if (isVersionCompatibleWithBucketedIntent(version)) {
+            // This is a bucketed intent
+            Bundle bridgeArguments = new Bundle();
+            bridgeArguments.putString(BRIDGE_ARG_ACTION_ID_STRING, callId);
+            Utility.putNonEmptyString(bridgeArguments, BRIDGE_ARG_APP_NAME_STRING, applicationName);
+
+            intent.putExtra(EXTRA_PROTOCOL_BRIDGE_ARGS, bridgeArguments);
+
+            Bundle methodArguments = (params == null) ? new Bundle() : params;
+            intent.putExtra(EXTRA_PROTOCOL_METHOD_ARGS, methodArguments);
+        } else {
+            // This is the older flat intent
+            intent.putExtra(EXTRA_PROTOCOL_CALL_ID, callId);
+            if (!Utility.isNullOrEmpty(applicationName)) {
+                intent.putExtra(EXTRA_APPLICATION_NAME, applicationName);
+            }
+            intent.putExtras(params);
+        }
+    }
+
+    /**
+     * Use this method to set a result on an Activity, where the result needs to be in the shape
+     * of the native protocol used for native dialogs.
+     */
+    public static Intent createProtocolResultIntent(
+            Intent requestIntent,
+            Bundle results,
+            FacebookException error) {
+        UUID callId = NativeProtocol.getCallIdFromIntent(requestIntent);
+        if (callId == null) {
+            return null;
+        }
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtra(EXTRA_PROTOCOL_VERSION, getProtocolVersionFromIntent(requestIntent));
+
+        Bundle bridgeArguments = new Bundle();
+        bridgeArguments.putString(BRIDGE_ARG_ACTION_ID_STRING, callId.toString());
+        if (error != null) {
+            bridgeArguments.putBundle(
+                    BRIDGE_ARG_ERROR_BUNDLE, NativeProtocol.createBundleForException(error));
+        }
+        resultIntent.putExtra(EXTRA_PROTOCOL_BRIDGE_ARGS, bridgeArguments);
+
+        if (results != null) {
+            resultIntent.putExtra(EXTRA_PROTOCOL_METHOD_RESULTS, results);
+        }
+
+        return resultIntent;
+    }
+
     public static Intent createPlatformServiceIntent(Context context) {
         for (NativeAppInfo appInfo : facebookAppInfoList) {
             Intent intent = new Intent(INTENT_ACTION_PLATFORM_SERVICE)
@@ -389,99 +593,153 @@ public static Intent createPlatformServiceIntent(Context context) {
         return null;
     }
 
-    public static Intent createLoginDialog20121101Intent(Context context, String applicationId, ArrayList<String> permissions,
-            String audience) {
-        Intent intent = findActivityIntent(context, INTENT_ACTION_PLATFORM_ACTIVITY, ACTION_LOGIN_DIALOG);
+    public static int getProtocolVersionFromIntent(Intent intent) {
+        return intent.getIntExtra(EXTRA_PROTOCOL_VERSION, 0);
+    }
+
+    public static UUID getCallIdFromIntent(Intent intent) {
         if (intent == null) {
             return null;
         }
+        int version = getProtocolVersionFromIntent(intent);
+        String callIdString = null;
+        if (isVersionCompatibleWithBucketedIntent(version)) {
+            Bundle bridgeArgs = intent.getBundleExtra(EXTRA_PROTOCOL_BRIDGE_ARGS);
+            if (bridgeArgs != null) {
+                callIdString = bridgeArgs.getString(BRIDGE_ARG_ACTION_ID_STRING);
+            }
+        } else {
+            callIdString = intent.getStringExtra(EXTRA_PROTOCOL_CALL_ID);
+        }
 
-        intent.putExtra(EXTRA_PROTOCOL_VERSION, PROTOCOL_VERSION_20121101)
-              .putExtra(EXTRA_PROTOCOL_ACTION, ACTION_LOGIN_DIALOG)
-              .putExtra(EXTRA_APPLICATION_ID, applicationId)
-              .putStringArrayListExtra(EXTRA_PERMISSIONS, ensureDefaultPermissions(permissions))
-              .putExtra(EXTRA_PROTOCOL_CALL_ID, generateCallId())
-              .putExtra(EXTRA_WRITE_PRIVACY, ensureDefaultAudience(audience));
+        UUID callId = null;
+        if (callIdString != null) {
+            try {
+                callId = UUID.fromString(callIdString);
+            } catch (IllegalArgumentException exception) {
+            }
+        }
+        return callId;
+    }
 
-        return intent;
+    public static Bundle getBridgeArgumentsFromIntent(Intent intent) {
+        int version = getProtocolVersionFromIntent(intent);
+        if (!isVersionCompatibleWithBucketedIntent(version)) {
+            return null;
+        }
+
+        return intent.getBundleExtra(EXTRA_PROTOCOL_BRIDGE_ARGS);
+    }
+
+    public static Bundle getMethodArgumentsFromIntent(Intent intent) {
+        int version = getProtocolVersionFromIntent(intent);
+        if (!isVersionCompatibleWithBucketedIntent(version)) {
+            return intent.getExtras();
+        }
+
+        return intent.getBundleExtra(EXTRA_PROTOCOL_METHOD_ARGS);
+    }
+
+    public static Bundle getSuccessResultsFromIntent(Intent resultIntent) {
+        int version = getProtocolVersionFromIntent(resultIntent);
+        Bundle extras = resultIntent.getExtras();
+        if (!isVersionCompatibleWithBucketedIntent(version) || extras == null) {
+            return extras;
+        }
+
+        return extras.getBundle(EXTRA_PROTOCOL_METHOD_RESULTS);
     }
 
     public static boolean isErrorResult(Intent resultIntent) {
-        return resultIntent.hasExtra(STATUS_ERROR_TYPE);
+        Bundle bridgeArgs = getBridgeArgumentsFromIntent(resultIntent);
+        if (bridgeArgs != null) {
+            return bridgeArgs.containsKey(BRIDGE_ARG_ERROR_BUNDLE);
+        } else {
+            return resultIntent.hasExtra(STATUS_ERROR_TYPE);
+        }
     }
 
-    public static Exception getErrorFromResult(Intent resultIntent) {
+    public static Bundle getErrorDataFromResultIntent(Intent resultIntent) {
         if (!isErrorResult(resultIntent)) {
             return null;
         }
 
-        String type = resultIntent.getStringExtra(STATUS_ERROR_TYPE);
-        String description = resultIntent.getStringExtra(STATUS_ERROR_DESCRIPTION);
-
-        if (type.equalsIgnoreCase(ERROR_USER_CANCELED)) {
-            return new FacebookOperationCanceledException(description);
+        Bundle bridgeArgs = getBridgeArgumentsFromIntent(resultIntent);
+        if (bridgeArgs != null) {
+            return bridgeArgs.getBundle(BRIDGE_ARG_ERROR_BUNDLE);
         }
-        /* TODO parse error values and create appropriate exception class */
-        return new FacebookException(description);
-    }
 
-    private static String generateCallId() {
-        return UUID.randomUUID().toString();
+        return resultIntent.getExtras();
     }
 
-    private static String ensureDefaultAudience(String audience) {
-        if (Utility.isNullOrEmpty(audience)) {
-            return AUDIENCE_ME;
-        } else {
-            return audience;
+    public static FacebookException getExceptionFromErrorData(Bundle errorData) {
+        if (errorData == null) {
+            return null;
         }
-    }
 
-    private static ArrayList<String> ensureDefaultPermissions(ArrayList<String> permissions) {
-        ArrayList<String> updated;
+        String type = errorData.getString(BRIDGE_ARG_ERROR_TYPE);
+        if (type == null) {
+            type = errorData.getString(STATUS_ERROR_TYPE);
+        }
 
-        // Return if we are doing publish, or if basic_info is already included
-        if (Utility.isNullOrEmpty(permissions)) {
-            updated = new ArrayList<String>();
-        } else {
-            for (String permission : permissions) {
-                if (Session.isPublishPermission(permission) || BASIC_INFO.equals(permission)) {
-                    return permissions;
-                }
-            }
-            updated = new ArrayList<String>(permissions);
+        String description = errorData.getString(BRIDGE_ARG_ERROR_DESCRIPTION);
+        if (description == null) {
+            description = errorData.getString(STATUS_ERROR_DESCRIPTION);
         }
 
-        updated.add(BASIC_INFO);
-        return updated;
+        if (type != null && type.equalsIgnoreCase(ERROR_USER_CANCELED)) {
+            return new FacebookOperationCanceledException(description);
+        }
+
+        /* TODO parse error values and create appropriate exception class */
+        return new FacebookException(description);
     }
 
-    public static boolean isServiceDisabledResult20121101(Intent data) {
-        int protocolVersion = data.getIntExtra(EXTRA_PROTOCOL_VERSION, 0);
-        String errorType = data.getStringExtra(STATUS_ERROR_TYPE);
+    public static Bundle createBundleForException(FacebookException e) {
+        if (e == null) {
+            return null;
+        }
+
+        Bundle errorBundle = new Bundle();
+        errorBundle.putString(BRIDGE_ARG_ERROR_DESCRIPTION, e.toString());
+        if (e instanceof FacebookOperationCanceledException) {
+            errorBundle.putString(BRIDGE_ARG_ERROR_TYPE, ERROR_USER_CANCELED);
+        }
 
-        return ((PROTOCOL_VERSION_20121101 == protocolVersion) && ERROR_SERVICE_DISABLED.equals(errorType));
+        return errorBundle;
     }
 
-    public static int getLatestAvailableProtocolVersionForService(Context context, final int minimumVersion) {
+    public static int getLatestAvailableProtocolVersionForService(final int minimumVersion) {
         // Services are currently always against the Facebook App
-        return getLatestAvailableProtocolVersionForAppInfoList(context, facebookAppInfoList, minimumVersion);
+        return getLatestAvailableProtocolVersionForAppInfoList(
+                facebookAppInfoList, new int[]{minimumVersion});
     }
 
-    public static int getLatestAvailableProtocolVersionForAction(Context context, String action, final int minimumVersion) {
+    public static int getLatestAvailableProtocolVersionForAction(
+            String action,
+            int[] versionSpec) {
         List<NativeAppInfo> appInfoList = actionToAppInfoMap.get(action);
-        return getLatestAvailableProtocolVersionForAppInfoList(context, appInfoList, minimumVersion);
+        return getLatestAvailableProtocolVersionForAppInfoList(appInfoList, versionSpec);
     }
 
-    private static int getLatestAvailableProtocolVersionForAppInfoList(Context context, List<NativeAppInfo> appInfoList,
-            final int minimumVersion) {
+    private static int getLatestAvailableProtocolVersionForAppInfoList(
+            List<NativeAppInfo> appInfoList,
+            int[] versionSpec) {
+        // Kick off an update
+        updateAllAvailableProtocolVersionsAsync();
+
         if (appInfoList == null) {
             return NO_PROTOCOL_AVAILABLE;
         }
 
         // Could potentially cache the NativeAppInfo to latestProtocolVersion
         for (NativeAppInfo appInfo : appInfoList) {
-            int protocolVersion = getLatestAvailableProtocolVersionForAppInfo(context, appInfo, minimumVersion);
+            int protocolVersion =
+                    computeLatestAvailableVersionFromVersionSpec(
+                            appInfo.getAvailableVersions(),
+                            getLatestKnownVersion(),
+                            versionSpec);
+
             if (protocolVersion != NO_PROTOCOL_AVAILABLE) {
                 return protocolVersion;
             }
@@ -490,30 +748,99 @@ private static int getLatestAvailableProtocolVersionForAppInfoList(Context conte
         return NO_PROTOCOL_AVAILABLE;
     }
 
-    private static int getLatestAvailableProtocolVersionForAppInfo(Context context, NativeAppInfo appInfo,
-            final int minimumVersion) {
-        ContentResolver contentResolver = context.getContentResolver();
+    public static void updateAllAvailableProtocolVersionsAsync() {
+        if (!protocolVersionsAsyncUpdating.compareAndSet(false, true)) {
+            return;
+        }
+
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    for (NativeAppInfo appInfo : facebookAppInfoList) {
+                        appInfo.fetchAvailableVersions(true);
+                    }
+                } finally {
+                    protocolVersionsAsyncUpdating.set(false);
+                }
+            }
+        });
+    }
+
+    private static TreeSet<Integer> fetchAllAvailableProtocolVersionsForAppInfo(
+            NativeAppInfo appInfo) {
+        TreeSet<Integer> allAvailableVersions = new TreeSet<>();
+
+        Context appContext = FacebookSdk.getApplicationContext();
+        ContentResolver contentResolver = appContext.getContentResolver();
 
         String [] projection = new String[]{ PLATFORM_PROVIDER_VERSION_COLUMN };
         Uri uri = buildPlatformProviderVersionURI(appInfo);
-        Cursor c = contentResolver.query(uri, projection, null, null, null);
-        if (c == null) {
-            return NO_PROTOCOL_AVAILABLE;
-        }
+        Cursor c = null;
+        try {
+            // First see if the base provider exists as a check for whether the native app is
+            // installed. We do this prior to querying, to prevent errors from being output to
+            // logcat saying that the provider was not found.
+            PackageManager pm = FacebookSdk.getApplicationContext().getPackageManager();
+            String contentProviderName = appInfo.getPackage() + PLATFORM_PROVIDER;
+            ProviderInfo pInfo = pm.resolveContentProvider(contentProviderName, 0);
+            if (pInfo != null) {
+                c = contentResolver.query(uri, projection, null, null, null);
+                if (c != null) {
+                    while (c.moveToNext()) {
+                        int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
+                        allAvailableVersions.add(version);
+                    }
+                }
+            }
 
-        Set<Integer> versions = new HashSet<Integer>();
-        while (c.moveToNext()) {
-            int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
-            versions.add(version);
+            return allAvailableVersions;
+        } finally {
+            if (c != null) {
+                c.close();
+            }
         }
+    }
+
+    public static int computeLatestAvailableVersionFromVersionSpec(
+            TreeSet<Integer> allAvailableFacebookAppVersions,
+            int latestSdkVersion,
+            int[] versionSpec) {
+        // Remember that these ranges are sorted in ascending order and can be unbounded. So we are
+        // starting from the end of the version-spec array and working backwards, to try get the
+        // newest possible version
+        int versionSpecIndex = versionSpec.length - 1;
+        Iterator<Integer> fbAppVersionsIterator =
+                allAvailableFacebookAppVersions.descendingIterator();
+        int latestFacebookAppVersion = -1;
+
+        while (fbAppVersionsIterator.hasNext()) {
+            int fbAppVersion = fbAppVersionsIterator.next();
+
+            // We're holding on to the greatest fb-app version available.
+            latestFacebookAppVersion = Math.max(latestFacebookAppVersion, fbAppVersion);
+
+            // If there is a newer version in the versionSpec, throw it away, we don't have it
+            while (versionSpecIndex >= 0 && versionSpec[versionSpecIndex] > fbAppVersion) {
+                versionSpecIndex--;
+            }
 
-        for (Integer knownVersion : KNOWN_PROTOCOL_VERSIONS) {
-            if (knownVersion < minimumVersion) {
+            if (versionSpecIndex < 0) {
+                // There was no fb app version that fell into any range in the versionSpec - or -
+                // the versionSpec was empty, which means that this action is not supported.
                 return NO_PROTOCOL_AVAILABLE;
             }
 
-            if (versions.contains(knownVersion)) {
-                return knownVersion;
+            // If we are here, we know we are within a range specified in the versionSpec. We should
+            // see if it is a disabled or enabled range.
+
+            if (versionSpec[versionSpecIndex] == fbAppVersion) {
+                // if the versionSpecIndex is even, it is enabled; if odd, disabled
+                return (
+                        versionSpecIndex % 2 == 0 ?
+                                Math.min(latestFacebookAppVersion, latestSdkVersion) :
+                                NO_PROTOCOL_AVAILABLE
+                );
             }
         }
 
diff --git a/facebook/src/com/facebook/internal/PermissionType.java b/facebook/src/com/facebook/internal/PermissionType.java
new file mode 100644
index 000000000..0bf617f6c
--- /dev/null
+++ b/facebook/src/com/facebook/internal/PermissionType.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public enum PermissionType {
+    READ,
+    PUBLISH
+}
diff --git a/facebook/src/com/facebook/internal/PlatformServiceClient.java b/facebook/src/com/facebook/internal/PlatformServiceClient.java
index 16d619c3b..e3bc3f090 100644
--- a/facebook/src/com/facebook/internal/PlatformServiceClient.java
+++ b/facebook/src/com/facebook/internal/PlatformServiceClient.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
@@ -23,9 +27,9 @@
 import android.os.*;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 abstract public class PlatformServiceClient implements ServiceConnection {
     private final Context context;
@@ -38,7 +42,11 @@
     private final String applicationId;
     private final int protocolVersion;
 
-    public PlatformServiceClient(Context context, int requestMessage, int replyMessage, int protocolVersion,
+    public PlatformServiceClient(
+            Context context,
+            int requestMessage,
+            int replyMessage,
+            int protocolVersion,
             String applicationId) {
         Context applicationContext = context.getApplicationContext();
 
@@ -70,7 +78,8 @@ public boolean start() {
         }
 
         // Make sure that the service can handle the requested protocol version
-        int availableVersion = NativeProtocol.getLatestAvailableProtocolVersionForService(context, protocolVersion);
+        int availableVersion = NativeProtocol.getLatestAvailableProtocolVersionForService(
+                protocolVersion);
         if (availableVersion == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
             return false;
         }
@@ -96,7 +105,11 @@ public void onServiceConnected(ComponentName name, IBinder service) {
 
     public void onServiceDisconnected(ComponentName name) {
         sender = null;
-        context.unbindService(this);
+        try {
+            context.unbindService(this);
+        } catch (IllegalArgumentException ex) {
+            // Do nothing, the connection was already unbound
+        }
         callback(null);
     }
 
diff --git a/facebook/src/com/facebook/internal/ProfileInformationCache.java b/facebook/src/com/facebook/internal/ProfileInformationCache.java
new file mode 100644
index 000000000..dcfe0252c
--- /dev/null
+++ b/facebook/src/com/facebook/internal/ProfileInformationCache.java
@@ -0,0 +1,46 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import org.json.JSONObject;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ *
+ * Caches the profile information associated to a specific access token. This minimizes the number
+ * of request we need to make to the server.
+ */
+class ProfileInformationCache {
+    final private static ConcurrentHashMap<String, JSONObject> infoCache =
+            new ConcurrentHashMap<>();
+
+    public static JSONObject getProfileInformation(String accessToken) {
+        return infoCache.get(accessToken);
+    }
+
+    public static void putProfileInformation(String key, JSONObject value) {
+        infoCache.put(key, value);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/ServerProtocol.java b/facebook/src/com/facebook/internal/ServerProtocol.java
index 6f3dd7d49..ea69f6172 100644
--- a/facebook/src/com/facebook/internal/ServerProtocol.java
+++ b/facebook/src/com/facebook/internal/ServerProtocol.java
@@ -1,48 +1,79 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import com.facebook.Settings;
-import com.facebook.internal.Utility;
+import android.content.Context;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.facebook.FacebookSdk;
+import com.facebook.LoggingBehavior;
+
+import org.json.JSONException;
+import org.json.JSONObject;
 
 import java.util.Collection;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public final class ServerProtocol {
+    private static final String TAG = ServerProtocol.class.getName();
+
     private static final String DIALOG_AUTHORITY_FORMAT = "m.%s";
     public static final String DIALOG_PATH = "dialog/";
-    public static final String DIALOG_PARAM_SCOPE = "scope";
-    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
-    public static final String DIALOG_PARAM_DISPLAY = "display";
-    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
-    public static final String DIALOG_PARAM_TYPE = "type";
     public static final String DIALOG_PARAM_ACCESS_TOKEN = "access_token";
     public static final String DIALOG_PARAM_APP_ID = "app_id";
+    public static final String DIALOG_PARAM_AUTH_TYPE = "auth_type";
+    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
+    public static final String DIALOG_PARAM_DISPLAY = "display";
+    public static final String DIALOG_PARAM_DISPLAY_TOUCH = "touch";
     public static final String DIALOG_PARAM_E2E = "e2e";
+    public static final String DIALOG_PARAM_LEGACY_OVERRIDE = "legacy_override";
+    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
+    public static final String DIALOG_PARAM_RESPONSE_TYPE = "response_type";
+    public static final String DIALOG_PARAM_RETURN_SCOPES = "return_scopes";
+    public static final String DIALOG_PARAM_SCOPE = "scope";
+    public static final String DIALOG_PARAM_DEFAULT_AUDIENCE = "default_audience";
+    public static final String DIALOG_REREQUEST_AUTH_TYPE = "rerequest";
+    public static final String DIALOG_RESPONSE_TYPE_TOKEN_AND_SIGNED_REQUEST
+            = "token,signed_request";
+    public static final String DIALOG_RETURN_SCOPES_TRUE = "true";
+    public static final String DIALOG_REDIRECT_URI = "fbconnect://success";
+    public static final String DIALOG_CANCEL_URI = "fbconnect://cancel";
+
+    public static final String FALLBACK_DIALOG_PARAM_APP_ID = "app_id";
+    public static final String FALLBACK_DIALOG_PARAM_BRIDGE_ARGS = "bridge_args";
+    public static final String FALLBACK_DIALOG_PARAM_KEY_HASH = "android_key_hash";
+    public static final String FALLBACK_DIALOG_PARAM_METHOD_ARGS = "method_args";
+    public static final String FALLBACK_DIALOG_PARAM_METHOD_RESULTS = "method_results";
+    public static final String FALLBACK_DIALOG_PARAM_VERSION = "version";
+    public static final String FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH = "touch";
 
     // URL components
     private static final String GRAPH_VIDEO_URL_FORMAT = "https://graph-video.%s";
     private static final String GRAPH_URL_FORMAT = "https://graph.%s";
-    private static final String REST_URL_FORMAT = "https://api.%s/method";
-    public static final String BATCHED_REST_METHOD_URL_BASE = "method/";
+    public static final String GRAPH_API_VERSION = "v2.3";
 
     public static final Collection<String> errorsProxyAuthDisabled =
             Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
@@ -50,18 +81,60 @@
             Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
 
     public static final String getDialogAuthority() {
-        return String.format(DIALOG_AUTHORITY_FORMAT, Settings.getFacebookDomain());
+        return String.format(DIALOG_AUTHORITY_FORMAT, FacebookSdk.getFacebookDomain());
     }
 
     public static final String getGraphUrlBase() {
-        return String.format(GRAPH_URL_FORMAT, Settings.getFacebookDomain());
+        return String.format(GRAPH_URL_FORMAT, FacebookSdk.getFacebookDomain());
     }
 
     public static final String getGraphVideoUrlBase() {
-        return String.format(GRAPH_VIDEO_URL_FORMAT, Settings.getFacebookDomain());
+        return String.format(GRAPH_VIDEO_URL_FORMAT, FacebookSdk.getFacebookDomain());
     }
 
-    public static final String getRestUrlBase() {
-        return String.format(REST_URL_FORMAT, Settings.getFacebookDomain());
+    public static final String getAPIVersion() {
+        return GRAPH_API_VERSION;
+    }
+
+    public static Bundle getQueryParamsForPlatformActivityIntentWebFallback(
+            String callId,
+            int version,
+            Bundle methodArgs) {
+
+        Context context = FacebookSdk.getApplicationContext();
+        String keyHash = FacebookSdk.getApplicationSignature(context);
+        if (Utility.isNullOrEmpty(keyHash)) {
+            return null;
+        }
+
+        Bundle webParams = new Bundle();
+
+        webParams.putString(FALLBACK_DIALOG_PARAM_KEY_HASH, keyHash);
+        webParams.putString(FALLBACK_DIALOG_PARAM_APP_ID, FacebookSdk.getApplicationId());
+        webParams.putInt(FALLBACK_DIALOG_PARAM_VERSION, version);
+        webParams.putString(DIALOG_PARAM_DISPLAY, FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH);
+
+        Bundle bridgeArguments = new Bundle();
+        bridgeArguments.putString(NativeProtocol.BRIDGE_ARG_ACTION_ID_STRING, callId);
+
+        methodArgs = (methodArgs == null) ? new Bundle() : methodArgs;
+
+        try {
+            JSONObject bridgeArgsJSON = BundleJSONConverter.convertToJSON(bridgeArguments);
+            JSONObject methodArgsJSON = BundleJSONConverter.convertToJSON(methodArgs);
+
+            if (bridgeArgsJSON == null || methodArgsJSON == null) {
+                return null;
+            }
+
+            webParams.putString(FALLBACK_DIALOG_PARAM_BRIDGE_ARGS, bridgeArgsJSON.toString());
+            webParams.putString(FALLBACK_DIALOG_PARAM_METHOD_ARGS, methodArgsJSON.toString());
+        } catch (JSONException je) {
+            webParams = null;
+            Logger.log(LoggingBehavior.DEVELOPER_ERRORS, Log.ERROR, TAG,
+                    "Error creating Url -- " + je);
+        }
+
+        return webParams;
     }
 }
diff --git a/facebook/src/com/facebook/internal/SessionAuthorizationType.java b/facebook/src/com/facebook/internal/SessionAuthorizationType.java
deleted file mode 100644
index 85083b8d6..000000000
--- a/facebook/src/com/facebook/internal/SessionAuthorizationType.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-/**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-public enum SessionAuthorizationType {
-    READ,
-    PUBLISH
-}
diff --git a/facebook/src/com/facebook/internal/SessionTracker.java b/facebook/src/com/facebook/internal/SessionTracker.java
deleted file mode 100644
index 5584ef3be..000000000
--- a/facebook/src/com/facebook/internal/SessionTracker.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.support.v4.content.LocalBroadcastManager;
-import com.facebook.Session;
-import com.facebook.SessionState;
-
-/**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-public class SessionTracker {
-
-    private Session session;
-    private final Session.StatusCallback callback;
-    private final BroadcastReceiver receiver;
-    private final LocalBroadcastManager broadcastManager;
-    private boolean isTracking = false;
-
-    /**
-     * Constructs a SessionTracker to track the active Session object.
-     * 
-     * @param context the context object.
-     * @param callback the callback to use whenever the active Session's 
-     *                 state changes
-     */
-    public SessionTracker(Context context, Session.StatusCallback callback) {
-        this(context, callback, null);
-    }
-    
-    /**
-     * Constructs a SessionTracker to track the Session object passed in.
-     * If the Session is null, then it will track the active Session instead.
-     * 
-     * @param context the context object.
-     * @param callback the callback to use whenever the Session's state changes
-     * @param session the Session object to track
-     */
-    SessionTracker(Context context, Session.StatusCallback callback, Session session) {
-        this(context, callback, session, true);
-    }
-    
-    /**
-     * Constructs a SessionTracker to track the Session object passed in.
-     * If the Session is null, then it will track the active Session instead.
-     * 
-     * @param context the context object.
-     * @param callback the callback to use whenever the Session's state changes
-     * @param session the Session object to track
-     * @param startTracking whether to start tracking the Session right away
-     */
-    public SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
-        this.callback = new CallbackWrapper(callback);
-        this.session = session;
-        this.receiver = new ActiveSessionBroadcastReceiver();
-        this.broadcastManager = LocalBroadcastManager.getInstance(context);
-
-        if (startTracking) {
-            startTracking();
-        }
-    }
-
-    /**
-     * Returns the current Session that's being tracked.
-     * 
-     * @return the current Session associated with this tracker
-     */
-    public Session getSession() {
-        return (session == null) ? Session.getActiveSession() : session;
-    }
-
-    /**
-     * Returns the current Session that's being tracked if it's open, 
-     * otherwise returns null.
-     * 
-     * @return the current Session if it's open, otherwise returns null
-     */
-    public Session getOpenSession() {
-        Session openSession = getSession();
-        if (openSession != null && openSession.isOpened()) {
-            return openSession;
-        }
-        return null;
-    }
-
-    /**
-     * Set the Session object to track.
-     * 
-     * @param newSession the new Session object to track
-     */
-    public void setSession(Session newSession) {
-        if (newSession == null) {
-            if (session != null) {
-                // We're current tracking a Session. Remove the callback
-                // and start tracking the active Session.
-                session.removeCallback(callback);
-                session = null;
-                addBroadcastReceiver();
-                if (getSession() != null) {
-                    getSession().addCallback(callback);
-                }
-            }
-        } else {
-            if (session == null) {
-                // We're currently tracking the active Session, but will be
-                // switching to tracking a different Session object.
-                Session activeSession = Session.getActiveSession();
-                if (activeSession != null) {
-                    activeSession.removeCallback(callback);
-                }
-                broadcastManager.unregisterReceiver(receiver);
-            } else {
-                // We're currently tracking a Session, but are now switching 
-                // to a new Session, so we remove the callback from the old 
-                // Session, and add it to the new one.
-                session.removeCallback(callback);
-            }
-            session = newSession;
-            session.addCallback(callback);
-        }
-    }
-
-    /**
-     * Start tracking the Session (either active or the one given). 
-     */
-    public void startTracking() {
-        if (isTracking) {
-            return;
-        }
-        if (this.session == null) {
-            addBroadcastReceiver();
-        }        
-        // if the session is not null, then add the callback to it right away
-        if (getSession() != null) {
-            getSession().addCallback(callback);
-        }
-        isTracking = true;
-    }
-
-    /**
-     * Stop tracking the Session and remove any callbacks attached
-     * to those sessions.
-     */
-    public void stopTracking() {
-        if (!isTracking) {
-            return;
-        }
-        Session session = getSession();
-        if (session != null) {
-            session.removeCallback(callback);
-        }
-        broadcastManager.unregisterReceiver(receiver);
-        isTracking = false;
-    }
-    
-    /**
-     * Returns whether it's currently tracking the Session.
-     * 
-     * @return true if currently tracking the Session
-     */
-    public boolean isTracking() {
-        return isTracking;
-    }
-
-    /**
-     * Returns whether it's currently tracking the active Session.
-     *
-     * @return true if the currently tracked session is the active Session.
-     */
-    public boolean isTrackingActiveSession() {
-        return session == null;
-    }
-    
-    private void addBroadcastReceiver() {
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-        
-        // Add a broadcast receiver to listen to when the active Session
-        // is set or unset, and add/remove our callback as appropriate    
-        broadcastManager.registerReceiver(receiver, filter);
-    }
-
-    /**
-     * The BroadcastReceiver implementation that either adds or removes the callback
-     * from the active Session object as it's SET or UNSET.
-     */
-    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
-                Session session = Session.getActiveSession();
-                if (session != null) {
-                    session.addCallback(SessionTracker.this.callback);
-                }
-            }
-        }
-    }
-
-    private class CallbackWrapper implements Session.StatusCallback {
-
-        private final Session.StatusCallback wrapped;
-        public CallbackWrapper(Session.StatusCallback wrapped) {
-            this.wrapped = wrapped;
-        }
-
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            if (wrapped != null && isTracking()) {
-                wrapped.call(session, state, exception);
-            }
-            // if we're not tracking the Active Session, and the current session
-            // is closed, then start tracking the Active Session.
-            if (session == SessionTracker.this.session && state.isClosed()) {
-                setSession(null);
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/internal/UrlRedirectCache.java b/facebook/src/com/facebook/internal/UrlRedirectCache.java
index 2123da8ff..bf4c5b269 100644
--- a/facebook/src/com/facebook/internal/UrlRedirectCache.java
+++ b/facebook/src/com/facebook/internal/UrlRedirectCache.java
@@ -1,22 +1,26 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import android.content.Context;
+import android.net.Uri;
 import android.util.Log;
 import com.facebook.LoggingBehavior;
 
@@ -24,23 +28,26 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.net.URI;
-import java.net.URISyntaxException;
 
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
 class UrlRedirectCache {
     static final String TAG = UrlRedirectCache.class.getSimpleName();
     private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
 
     private volatile static FileLruCache urlRedirectCache;
 
-    synchronized static FileLruCache getCache(Context context) throws IOException{
+    synchronized static FileLruCache getCache() throws IOException{
         if (urlRedirectCache == null) {
-            urlRedirectCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+            urlRedirectCache = new FileLruCache(TAG, new FileLruCache.Limits());
         }
         return urlRedirectCache;
     }
 
-    static URI getRedirectedUri(Context context, URI uri) {
+    static Uri getRedirectedUri(Uri uri) {
         if (uri == null) {
             return null;
         }
@@ -49,7 +56,7 @@ static URI getRedirectedUri(Context context, URI uri) {
         InputStreamReader reader = null;
         try {
             InputStream stream;
-            FileLruCache cache = getCache(context);
+            FileLruCache cache = getCache();
             boolean redirectExists = false;
             while ((stream = cache.get(uriString, REDIRECT_CONTENT_TAG)) != null) {
                 redirectExists = true;
@@ -69,10 +76,8 @@ static URI getRedirectedUri(Context context, URI uri) {
             }
 
             if (redirectExists) {
-                return new URI(uriString);
+                return Uri.parse(uriString);
             }
-        } catch (URISyntaxException e) {
-            // caching is best effort, so ignore the exception
         } catch (IOException ioe) {
         } finally {
             Utility.closeQuietly(reader);
@@ -81,14 +86,14 @@ static URI getRedirectedUri(Context context, URI uri) {
         return null;
     }
 
-    static void cacheUriRedirect(Context context, URI fromUri, URI toUri) {
+    static void cacheUriRedirect(Uri fromUri, Uri toUri) {
         if (fromUri == null || toUri == null) {
             return;
         }
 
         OutputStream redirectStream = null;
         try {
-            FileLruCache cache = getCache(context);
+            FileLruCache cache = getCache();
             redirectStream = cache.openPutStream(fromUri.toString(), REDIRECT_CONTENT_TAG);
             redirectStream.write(toUri.toString().getBytes());
         } catch (IOException e) {
@@ -98,9 +103,9 @@ static void cacheUriRedirect(Context context, URI fromUri, URI toUri) {
         }
     }
 
-    static void clearCache(Context context) {
+    static void clearCache() {
         try {
-            getCache(context).clearCache();
+            getCache().clearCache();
         } catch (IOException e) {
             Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "clearCache failed " + e.getMessage());
         }
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
index 28afbf84f..57e2467ef 100644
--- a/facebook/src/com/facebook/internal/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -1,88 +1,331 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
+import android.content.SharedPreferences;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.database.Cursor;
 import android.net.Uri;
 import android.os.Bundle;
-import android.os.Parcelable;
-import android.provider.Settings.Secure;
+import android.os.Parcel;
+import android.provider.OpenableColumns;
 import android.text.TextUtils;
 import android.util.Log;
 import android.webkit.CookieManager;
 import android.webkit.CookieSyncManager;
-import com.facebook.*;
-import com.facebook.android.BuildConfig;
-import com.facebook.model.GraphObject;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.HttpMethod;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
 import java.io.*;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.HttpURLConnection;
 import java.net.URLConnection;
+
+import java.net.URLDecoder;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public final class Utility {
     static final String LOG_TAG = "FacebookSDK";
     private static final String HASH_ALGORITHM_MD5 = "MD5";
     private static final String HASH_ALGORITHM_SHA1 = "SHA-1";
     private static final String URL_SCHEME = "https";
-    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
-    private static final String SUPPORTS_IMPLICIT_SDK_LOGGING = "supports_implicit_sdk_logging";
-    private static final String [] APP_SETTING_FIELDS = new String[] {
-            SUPPORTS_ATTRIBUTION,
-            SUPPORTS_IMPLICIT_SDK_LOGGING
+    private static final String APP_SETTINGS_PREFS_STORE =
+            "com.facebook.internal.preferences.APP_SETTINGS";
+    private static final String APP_SETTINGS_PREFS_KEY_FORMAT =
+            "com.facebook.internal.APP_SETTINGS.%s";
+    private static final String APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING =
+            "supports_implicit_sdk_logging";
+    private static final String APP_SETTING_NUX_CONTENT = "gdpv4_nux_content";
+    private static final String APP_SETTING_NUX_ENABLED = "gdpv4_nux_enabled";
+    private static final String APP_SETTING_DIALOG_CONFIGS = "android_dialog_configs";
+    private static final String APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES =
+            "android_sdk_error_categories";
+    private static final String EXTRA_APP_EVENTS_INFO_FORMAT_VERSION = "a1";
+    private static final String DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR = "\\|";
+    private static final String DIALOG_CONFIG_NAME_KEY = "name";
+    private static final String DIALOG_CONFIG_VERSIONS_KEY = "versions";
+    private static final String DIALOG_CONFIG_URL_KEY = "url";
+
+    private final static String UTF8 = "UTF-8";
+
+    private static final String[] APP_SETTING_FIELDS = new String[]{
+            APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING,
+            APP_SETTING_NUX_CONTENT,
+            APP_SETTING_NUX_ENABLED,
+            APP_SETTING_DIALOG_CONFIGS,
+            APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES
     };
     private static final String APPLICATION_FIELDS = "fields";
 
-    // This is the default used by the buffer streams, but they trace a warning if you do not specify.
+    // This is the default used by the buffer streams, but they trace a warning if you do not
+    // specify.
     public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
 
     private static Map<String, FetchedAppSettings> fetchedAppSettings =
             new ConcurrentHashMap<String, FetchedAppSettings>();
 
+    private static AtomicBoolean loadingSettings = new AtomicBoolean(false);
+
     public static class FetchedAppSettings {
-        private boolean supportsAttribution;
         private boolean supportsImplicitLogging;
+        private String nuxContent;
+        private boolean nuxEnabled;
+        private Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap;
+        private FacebookRequestErrorClassification errorClassification;
 
-        private FetchedAppSettings(boolean supportsAttribution, boolean supportsImplicitLogging) {
-            this.supportsAttribution = supportsAttribution;
+        private FetchedAppSettings(boolean supportsImplicitLogging,
+                                   String nuxContent,
+                                   boolean nuxEnabled,
+                                   Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap,
+                                   FacebookRequestErrorClassification errorClassification) {
             this.supportsImplicitLogging = supportsImplicitLogging;
-        }
-
-        public boolean supportsAttribution() {
-            return supportsAttribution;
+            this.nuxContent = nuxContent;
+            this.nuxEnabled = nuxEnabled;
+            this.dialogConfigMap = dialogConfigMap;
+            this.errorClassification = errorClassification;
         }
 
         public boolean supportsImplicitLogging() {
             return supportsImplicitLogging;
         }
+
+        public String getNuxContent() {
+            return nuxContent;
+        }
+
+        public boolean getNuxEnabled() {
+            return nuxEnabled;
+        }
+
+        public Map<String, Map<String, DialogFeatureConfig>> getDialogConfigurations() {
+            return dialogConfigMap;
+        }
+
+        public FacebookRequestErrorClassification getErrorClassification() {
+            return errorClassification;
+        }
+    }
+
+    public static class DialogFeatureConfig {
+        private static DialogFeatureConfig parseDialogConfig(JSONObject dialogConfigJSON) {
+            String dialogNameWithFeature = dialogConfigJSON.optString(DIALOG_CONFIG_NAME_KEY);
+            if (Utility.isNullOrEmpty(dialogNameWithFeature)) {
+                return null;
+            }
+
+            String[] components = dialogNameWithFeature.split(
+                    DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR);
+            if (components.length != 2) {
+                // We expect the format to be dialogName|FeatureName, where both components are
+                // non-empty.
+                return null;
+            }
+
+            String dialogName = components[0];
+            String featureName = components[1];
+            if (isNullOrEmpty(dialogName) || isNullOrEmpty(featureName)) {
+                return null;
+            }
+
+            String urlString = dialogConfigJSON.optString(DIALOG_CONFIG_URL_KEY);
+            Uri fallbackUri = null;
+            if (!Utility.isNullOrEmpty(urlString)) {
+                fallbackUri = Uri.parse(urlString);
+            }
+
+            JSONArray versionsJSON = dialogConfigJSON.optJSONArray(DIALOG_CONFIG_VERSIONS_KEY);
+
+            int[] featureVersionSpec = parseVersionSpec(versionsJSON);
+
+            return new DialogFeatureConfig(
+                    dialogName, featureName, fallbackUri, featureVersionSpec);
+        }
+
+        private static int[] parseVersionSpec(JSONArray versionsJSON) {
+            // Null signifies no overrides to the min-version as specified by the SDK.
+            // An empty array would basically turn off the dialog (i.e no supported versions), so
+            // DON'T default to that.
+            int[] versionSpec = null;
+            if (versionsJSON != null) {
+                int numVersions = versionsJSON.length();
+                versionSpec = new int[numVersions];
+                for (int i = 0; i < numVersions; i++) {
+                    // See if the version was stored directly as an Integer
+                    int version = versionsJSON.optInt(i, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+                    if (version == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
+                        // If not, then see if it was stored as a string that can be parsed out.
+                        // If even that fails, then we will leave it as NO_PROTOCOL_AVAILABLE
+                        String versionString = versionsJSON.optString(i);
+                        if (!isNullOrEmpty(versionString)) {
+                            try {
+                                version = Integer.parseInt(versionString);
+                            } catch (NumberFormatException nfe) {
+                                logd(LOG_TAG, nfe);
+                                version = NativeProtocol.NO_PROTOCOL_AVAILABLE;
+                            }
+                        }
+                    }
+
+                    versionSpec[i] = version;
+                }
+            }
+
+            return versionSpec;
+        }
+
+        private String dialogName;
+        private String featureName;
+        private Uri fallbackUrl;
+        private int[] featureVersionSpec;
+
+        private DialogFeatureConfig(
+                String dialogName,
+                String featureName,
+                Uri fallbackUrl,
+                int[] featureVersionSpec) {
+            this.dialogName = dialogName;
+            this.featureName = featureName;
+            this.fallbackUrl = fallbackUrl;
+            this.featureVersionSpec = featureVersionSpec;
+        }
+
+        public String getDialogName() {
+            return dialogName;
+        }
+
+        public String getFeatureName() {
+            return featureName;
+        }
+
+        public Uri getFallbackUrl() {
+            return fallbackUrl;
+        }
+
+        public int[] getVersionSpec() {
+            return featureVersionSpec;
+        }
+    }
+
+    /**
+     * Each array represents a set of closed or open Range, like so: [0,10,50,60] - Ranges are
+     * {0-9}, {50-59} [20] - Ranges are {20-} [30,40,100] - Ranges are {30-39}, {100-}
+     * <p/>
+     * All Ranges in the array have a closed lower bound. Only the last Range in each array may be
+     * open. It is assumed that the passed in arrays are sorted with ascending order. It is assumed
+     * that no two elements in a given are equal (i.e. no 0-length ranges)
+     * <p/>
+     * The method returns an intersect of the two passed in Range-sets
+     *
+     * @param range1 The first range
+     * @param range2 The second range
+     * @return The intersection of the two ranges.
+     */
+    public static int[] intersectRanges(int[] range1, int[] range2) {
+        if (range1 == null) {
+            return range2;
+        } else if (range2 == null) {
+            return range1;
+        }
+
+        int[] outputRange = new int[range1.length + range2.length];
+        int outputIndex = 0;
+        int index1 = 0, lower1, upper1;
+        int index2 = 0, lower2, upper2;
+        while (index1 < range1.length && index2 < range2.length) {
+            int newRangeLower = Integer.MIN_VALUE, newRangeUpper = Integer.MAX_VALUE;
+            lower1 = range1[index1];
+            upper1 = Integer.MAX_VALUE;
+
+            lower2 = range2[index2];
+            upper2 = Integer.MAX_VALUE;
+
+            if (index1 < range1.length - 1) {
+                upper1 = range1[index1 + 1];
+            }
+            if (index2 < range2.length - 1) {
+                upper2 = range2[index2 + 1];
+            }
+
+            if (lower1 < lower2) {
+                if (upper1 > lower2) {
+                    newRangeLower = lower2;
+                    if (upper1 > upper2) {
+                        newRangeUpper = upper2;
+                        index2 += 2;
+                    } else {
+                        newRangeUpper = upper1;
+                        index1 += 2;
+                    }
+                } else {
+                    index1 += 2;
+                }
+            } else {
+                if (upper2 > lower1) {
+                    newRangeLower = lower1;
+                    if (upper2 > upper1) {
+                        newRangeUpper = upper1;
+                        index1 += 2;
+                    } else {
+                        newRangeUpper = upper2;
+                        index2 += 2;
+                    }
+                } else {
+                    index2 += 2;
+                }
+            }
+
+            if (newRangeLower != Integer.MIN_VALUE) {
+                outputRange[outputIndex++] = newRangeLower;
+                if (newRangeUpper != Integer.MAX_VALUE) {
+                    outputRange[outputIndex++] = newRangeUpper;
+                } else {
+                    // If we reach an unbounded/open range, then we know we're done.
+                    break;
+                }
+            }
+        }
+
+        return Arrays.copyOf(outputRange, outputIndex);
     }
 
     // Returns true iff all items in subset are in superset, treating null and
@@ -110,6 +353,23 @@ public static boolean isNullOrEmpty(String s) {
         return (s == null) || (s.length() == 0);
     }
 
+    /**
+     * Use this when you want to normalize empty and null strings
+     * This way, Utility.areObjectsEqual can used for comparison, where a null string is to be
+     * treated the same as an empty string.
+     *
+     * @param s                  The string to coerce
+     * @param valueIfNullOrEmpty The value if s is null or empty.
+     * @return The original string s if it's not null or empty, otherwise the valueIfNullOrEmpty
+     */
+    public static String coerceValueIfNullOrEmpty(String s, String valueIfNullOrEmpty) {
+        if (isNullOrEmpty(s)) {
+            return valueIfNullOrEmpty;
+        }
+
+        return s;
+    }
+
     public static <T> Collection<T> unmodifiableCollection(T... ts) {
         return Collections.unmodifiableCollection(Arrays.asList(ts));
     }
@@ -122,23 +382,42 @@ public static boolean isNullOrEmpty(String s) {
         return arrayList;
     }
 
-    static String md5hash(String key) {
+    public static <T> HashSet<T> hashSet(T... ts) {
+        HashSet<T> hashSet = new HashSet<T>(ts.length);
+        for (T t : ts) {
+            hashSet.add(t);
+        }
+        return hashSet;
+    }
+
+    public static String md5hash(String key) {
         return hashWithAlgorithm(HASH_ALGORITHM_MD5, key);
     }
 
-    private static String sha1hash(String key) {
+    public static String sha1hash(String key) {
         return hashWithAlgorithm(HASH_ALGORITHM_SHA1, key);
     }
 
+    public static String sha1hash(byte[] bytes) {
+        return hashWithAlgorithm(HASH_ALGORITHM_SHA1, bytes);
+    }
+
     private static String hashWithAlgorithm(String algorithm, String key) {
-        MessageDigest hash = null;
+        return hashWithAlgorithm(algorithm, key.getBytes());
+    }
+
+    private static String hashWithAlgorithm(String algorithm, byte[] bytes) {
+        MessageDigest hash;
         try {
             hash = MessageDigest.getInstance(algorithm);
         } catch (NoSuchAlgorithmException e) {
             return null;
         }
+        return hashBytes(hash, bytes);
+    }
 
-        hash.update(key.getBytes());
+    private static String hashBytes(MessageDigest hash, byte[] bytes) {
+        hash.update(bytes);
         byte[] digest = hash.digest();
         StringBuilder builder = new StringBuilder();
         for (int b : digest) {
@@ -153,25 +432,99 @@ public static Uri buildUri(String authority, String path, Bundle parameters) {
         builder.scheme(URL_SCHEME);
         builder.authority(authority);
         builder.path(path);
-        for (String key : parameters.keySet()) {
-            Object parameter = parameters.get(key);
-            if (parameter instanceof String) {
-                builder.appendQueryParameter(key, (String) parameter);
+        if (parameters != null) {
+            for (String key : parameters.keySet()) {
+                Object parameter = parameters.get(key);
+                if (parameter instanceof String) {
+                    builder.appendQueryParameter(key, (String) parameter);
+                }
             }
         }
         return builder.build();
     }
 
-    public static void putObjectInBundle(Bundle bundle, String key, Object value) {
-        if (value instanceof String) {
+    public static Bundle parseUrlQueryString(String queryString) {
+        Bundle params = new Bundle();
+        if (!isNullOrEmpty(queryString)) {
+            String array[] = queryString.split("&");
+            for (String parameter : array) {
+                String keyValuePair[] = parameter.split("=");
+
+                try {
+                    if (keyValuePair.length == 2) {
+                        params.putString(
+                                URLDecoder.decode(keyValuePair[0], UTF8),
+                                URLDecoder.decode(keyValuePair[1], UTF8));
+                    } else if (keyValuePair.length == 1) {
+                        params.putString(
+                                URLDecoder.decode(keyValuePair[0], UTF8),
+                                "");
+                    }
+                } catch (UnsupportedEncodingException e) {
+                    // shouldn't happen
+                    logd(LOG_TAG, e);
+                }
+            }
+        }
+        return params;
+    }
+
+    public static void putNonEmptyString(Bundle b, String key, String value) {
+        if (!Utility.isNullOrEmpty(value)) {
+            b.putString(key, value);
+        }
+    }
+
+    public static void putCommaSeparatedStringList(Bundle b, String key, ArrayList<String> list) {
+        if (list != null) {
+            StringBuilder builder = new StringBuilder();
+            for (String string : list) {
+                builder.append(string);
+                builder.append(",");
+            }
+            String commaSeparated = "";
+            if (builder.length() > 0) {
+                commaSeparated = builder.substring(0, builder.length() - 1);
+            }
+            b.putString(key, commaSeparated);
+        }
+    }
+
+    public static void putUri(Bundle b, String key, Uri uri) {
+        if (uri != null) {
+            Utility.putNonEmptyString(b, key, uri.toString());
+        }
+    }
+
+    public static boolean putJSONValueInBundle(Bundle bundle, String key, Object value) {
+        if (value == null) {
+            bundle.remove(key);
+        } else if (value instanceof Boolean) {
+            bundle.putBoolean(key, (boolean) value);
+        } else if (value instanceof boolean[]) {
+            bundle.putBooleanArray(key, (boolean[]) value);
+        } else if (value instanceof Double) {
+            bundle.putDouble(key, (double) value);
+        } else if (value instanceof double[]) {
+            bundle.putDoubleArray(key, (double[]) value);
+        } else if (value instanceof Integer) {
+            bundle.putInt(key, (int) value);
+        } else if (value instanceof int[]) {
+            bundle.putIntArray(key, (int[]) value);
+        } else if (value instanceof Long) {
+            bundle.putLong(key, (long) value);
+        } else if (value instanceof long[]) {
+            bundle.putLongArray(key, (long[]) value);
+        } else if (value instanceof String) {
             bundle.putString(key, (String) value);
-        } else if (value instanceof Parcelable) {
-            bundle.putParcelable(key, (Parcelable) value);
-        } else if (value instanceof byte[]) {
-            bundle.putByteArray(key, (byte[]) value);
+        } else if (value instanceof JSONArray) {
+            bundle.putString(key, ((JSONArray) value).toString());
+        } else if (value instanceof JSONObject) {
+            bundle.putString(key, ((JSONObject) value).toString());
         } else {
-            throw new FacebookException("attempted to add unsupported type to Bundle");
+            return false;
         }
+        return true;
     }
 
     public static void closeQuietly(Closeable closeable) {
@@ -186,24 +539,16 @@ public static void closeQuietly(Closeable closeable) {
 
     public static void disconnectQuietly(URLConnection connection) {
         if (connection instanceof HttpURLConnection) {
-            ((HttpURLConnection)connection).disconnect();
+            ((HttpURLConnection) connection).disconnect();
         }
     }
 
     public static String getMetadataApplicationId(Context context) {
         Validate.notNull(context, "context");
 
-        try {
-            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
-                    context.getPackageName(), PackageManager.GET_META_DATA);
-            if (ai.metaData != null) {
-                return ai.metaData.getString(Session.APPLICATION_ID_PROPERTY);
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-            // if we can't find it in the manifest, just return null
-        }
+        FacebookSdk.sdkInitialize(context);
 
-        return null;
+        return FacebookSdk.getApplicationId();
     }
 
     static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
@@ -224,9 +569,13 @@ public static String getMetadataApplicationId(Context context) {
         return map;
     }
 
-    // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
-    public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
-            throws JSONException {
+    // Returns either a JSONObject or JSONArray representation of the 'key' property of
+    // 'jsonObject'.
+    public static Object getStringPropertyAsJSON(
+            JSONObject jsonObject,
+            String key,
+            String nonJSONPropertyKey
+    ) throws JSONException {
         Object value = jsonObject.opt(key);
         if (value != null && value instanceof String) {
             JSONTokener tokener = new JSONTokener((String) value);
@@ -237,9 +586,8 @@ public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key,
             if (nonJSONPropertyKey != null) {
                 // Facebook sometimes gives us back a non-JSON value such as
                 // literal "true" or "false" as a result.
-                // If we got something like that, we present it to the caller as
-                // a GraphObject with a single
-                // property. We only do this if the caller wants that behavior.
+                // If we got something like that, we present it to the caller as a JSONObject
+                // with a single property. We only do this if the caller wants that behavior.
                 jsonObject = new JSONObject();
                 jsonObject.putOpt(nonJSONPropertyKey, value);
                 return jsonObject;
@@ -274,6 +622,31 @@ public static String readStreamToString(InputStream inputStream) throws IOExcept
         }
     }
 
+    public static int copyAndCloseInputStream(InputStream inputStream, OutputStream outputStream)
+            throws IOException {
+        BufferedInputStream bufferedInputStream = null;
+        int totalBytes = 0;
+        try {
+            bufferedInputStream = new BufferedInputStream(inputStream);
+
+            byte[] buffer = new byte[8192];
+            int bytesRead;
+            while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
+                outputStream.write(buffer, 0, bytesRead);
+                totalBytes += bytesRead;
+            }
+        } finally {
+            if (bufferedInputStream != null) {
+                bufferedInputStream.close();
+            }
+            if (inputStream != null) {
+                inputStream.close();
+            }
+        }
+
+        return totalBytes;
+    }
+
     public static boolean stringsEqualOrEmpty(String a, String b) {
         boolean aEmpty = TextUtils.isEmpty(a);
         boolean bEmpty = TextUtils.isEmpty(b);
@@ -291,8 +664,8 @@ public static boolean stringsEqualOrEmpty(String a, String b) {
     }
 
     private static void clearCookiesForDomain(Context context, String domain) {
-        // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
-        // has never been created.
+        // This is to work around a bug where CookieManager may fail to instantiate if
+        // CookieSyncManager has never been created.
         CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
         syncManager.sync();
 
@@ -307,7 +680,8 @@ private static void clearCookiesForDomain(Context context, String domain) {
         for (String cookie : splitCookies) {
             String[] cookieParts = cookie.split("=");
             if (cookieParts.length > 0) {
-                String newCookie = cookieParts[0].trim() + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
+                String newCookie = cookieParts[0].trim() +
+                        "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
                 cookieManager.setCookie(domain, newCookie);
             }
         }
@@ -315,8 +689,9 @@ private static void clearCookiesForDomain(Context context, String domain) {
     }
 
     public static void clearFacebookCookies(Context context) {
-        // setCookie acts differently when trying to expire cookies between builds of Android that are using
-        // Chromium HTTP stack and those that are not. Using both of these domains to ensure it works on both.
+        // setCookie acts differently when trying to expire cookies between builds of Android that
+        // are using Chromium HTTP stack and those that are not. Using both of these domains to
+        // ensure it works on both.
         clearCookiesForDomain(context, "facebook.com");
         clearCookiesForDomain(context, ".facebook.com");
         clearCookiesForDomain(context, "https://facebook.com");
@@ -324,17 +699,23 @@ public static void clearFacebookCookies(Context context) {
     }
 
     public static void logd(String tag, Exception e) {
-        if (BuildConfig.DEBUG && tag != null && e != null) {
+        if (FacebookSdk.isDebugEnabled() && tag != null && e != null) {
             Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
         }
     }
 
     public static void logd(String tag, String msg) {
-        if (BuildConfig.DEBUG && tag != null && msg != null) {
+        if (FacebookSdk.isDebugEnabled() && tag != null && msg != null) {
             Log.d(tag, msg);
         }
     }
 
+    public static void logd(String tag, String msg, Throwable t) {
+        if (FacebookSdk.isDebugEnabled() && !isNullOrEmpty(tag)) {
+            Log.d(tag, msg, t);
+        }
+    }
+
     public static <T> boolean areObjectsEqual(T a, T b) {
         if (a == null) {
             return b == null;
@@ -342,39 +723,188 @@ public static void logd(String tag, String msg) {
         return a.equals(b);
     }
 
-    // Note that this method makes a synchronous Graph API call, so should not be called from the main thread.
-    public static FetchedAppSettings queryAppSettings(final String applicationId, final boolean forceRequery) {
+    public static boolean hasSameId(JSONObject a, JSONObject b) {
+        if (a == null || b == null || !a.has("id") || !b.has("id")) {
+            return false;
+        }
+        if (a.equals(b)) {
+            return true;
+        }
+        String idA = a.optString("id");
+        String idB = b.optString("id");
+        if (idA == null || idB == null) {
+            return false;
+        }
+        return idA.equals(idB);
+    }
+
+    public static void loadAppSettingsAsync(
+            final Context context,
+            final String applicationId
+    ) {
+        boolean canStartLoading = loadingSettings.compareAndSet(false, true);
+        if (Utility.isNullOrEmpty(applicationId) ||
+                fetchedAppSettings.containsKey(applicationId) ||
+                !canStartLoading) {
+            return;
+        }
+
+        final String settingsKey = String.format(APP_SETTINGS_PREFS_KEY_FORMAT, applicationId);
 
+        FacebookSdk.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                JSONObject resultJSON = getAppSettingsQueryResponse(applicationId);
+                if (resultJSON != null) {
+                    parseAppSettingsFromJSON(applicationId, resultJSON);
+
+                    SharedPreferences sharedPrefs = context.getSharedPreferences(
+                            APP_SETTINGS_PREFS_STORE,
+                            Context.MODE_PRIVATE);
+                    sharedPrefs.edit()
+                            .putString(settingsKey, resultJSON.toString())
+                            .apply();
+                }
+
+                loadingSettings.set(false);
+            }
+        });
+
+        // Also see if we had a cached copy and use that immediately.
+        SharedPreferences sharedPrefs = context.getSharedPreferences(
+                APP_SETTINGS_PREFS_STORE,
+                Context.MODE_PRIVATE);
+        String settingsJSONString = sharedPrefs.getString(settingsKey, null);
+        if (!isNullOrEmpty(settingsJSONString)) {
+            JSONObject settingsJSON = null;
+            try {
+                settingsJSON = new JSONObject(settingsJSONString);
+            } catch (JSONException je) {
+                logd(LOG_TAG, je);
+            }
+            if (settingsJSON != null) {
+                parseAppSettingsFromJSON(applicationId, settingsJSON);
+            }
+        }
+    }
+
+    // This call only gets the app settings if they're already fetched
+    public static FetchedAppSettings getAppSettingsWithoutQuery(final String applicationId) {
+        return applicationId != null ? fetchedAppSettings.get(applicationId) : null;
+    }
+
+    // Note that this method makes a synchronous Graph API call, so should not be called from the
+    // main thread.
+    public static FetchedAppSettings queryAppSettings(
+            final String applicationId,
+            final boolean forceRequery) {
         // Cache the last app checked results.
         if (!forceRequery && fetchedAppSettings.containsKey(applicationId)) {
             return fetchedAppSettings.get(applicationId);
         }
 
-        Bundle appSettingsParams = new Bundle();
-        appSettingsParams.putString(APPLICATION_FIELDS, TextUtils.join(",", APP_SETTING_FIELDS));
+        JSONObject response = getAppSettingsQueryResponse(applicationId);
+        if (response == null) {
+            return null;
+        }
 
-        Request request = Request.newGraphPathRequest(null, applicationId, null);
-        request.setParameters(appSettingsParams);
+        return parseAppSettingsFromJSON(applicationId, response);
+    }
 
-        GraphObject supportResponse = request.executeAndWait().getGraphObject();
+    private static FetchedAppSettings parseAppSettingsFromJSON(
+            String applicationId,
+            JSONObject settingsJSON) {
+        JSONArray errorClassificationJSON =
+                settingsJSON.optJSONArray(APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES);
+        FacebookRequestErrorClassification errorClassification =
+                errorClassificationJSON == null
+                        ? FacebookRequestErrorClassification.getDefaultErrorClassification()
+                        : FacebookRequestErrorClassification.createFromJSON(
+                        errorClassificationJSON
+                );
         FetchedAppSettings result = new FetchedAppSettings(
-                safeGetBooleanFromResponse(supportResponse, SUPPORTS_ATTRIBUTION),
-                safeGetBooleanFromResponse(supportResponse, SUPPORTS_IMPLICIT_SDK_LOGGING));
+                settingsJSON.optBoolean(APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING, false),
+                settingsJSON.optString(APP_SETTING_NUX_CONTENT, ""),
+                settingsJSON.optBoolean(APP_SETTING_NUX_ENABLED, false),
+                parseDialogConfigurations(settingsJSON.optJSONObject(APP_SETTING_DIALOG_CONFIGS)),
+                errorClassification
+        );
 
         fetchedAppSettings.put(applicationId, result);
 
         return result;
     }
 
-    private static boolean safeGetBooleanFromResponse(GraphObject response, String propertyName) {
-        Object result = false;
-        if (response != null) {
-            result = response.getProperty(propertyName);
+    // Note that this method makes a synchronous Graph API call, so should not be called from the
+    // main thread.
+    private static JSONObject getAppSettingsQueryResponse(String applicationId) {
+        Bundle appSettingsParams = new Bundle();
+        appSettingsParams.putString(APPLICATION_FIELDS, TextUtils.join(",", APP_SETTING_FIELDS));
+
+        GraphRequest request = GraphRequest.newGraphPathRequest(null, applicationId, null);
+        request.setSkipClientToken(true);
+        request.setParameters(appSettingsParams);
+
+        return request.executeAndWait().getJSONObject();
+    }
+
+    public static DialogFeatureConfig getDialogFeatureConfig(
+            String applicationId,
+            String actionName,
+            String featureName) {
+        if (Utility.isNullOrEmpty(actionName) || Utility.isNullOrEmpty(featureName)) {
+            return null;
         }
-        if (!(result instanceof Boolean)) {
-            result = false;
+
+        FetchedAppSettings settings = fetchedAppSettings.get(applicationId);
+        if (settings != null) {
+            Map<String, DialogFeatureConfig> featureMap =
+                    settings.getDialogConfigurations().get(actionName);
+            if (featureMap != null) {
+                return featureMap.get(featureName);
+            }
         }
-        return (Boolean) result;
+        return null;
+    }
+
+    private static Map<String, Map<String, DialogFeatureConfig>> parseDialogConfigurations(
+            JSONObject dialogConfigResponse) {
+        HashMap<String, Map<String, DialogFeatureConfig>> dialogConfigMap = new HashMap<String, Map<String, DialogFeatureConfig>>();
+
+        if (dialogConfigResponse != null) {
+            JSONArray dialogConfigData = dialogConfigResponse.optJSONArray("data");
+            if (dialogConfigData != null) {
+                for (int i = 0; i < dialogConfigData.length(); i++) {
+                    DialogFeatureConfig dialogConfig = DialogFeatureConfig.parseDialogConfig(
+                            dialogConfigData.optJSONObject(i));
+                    if (dialogConfig == null) {
+                        continue;
+                    }
+
+                    String dialogName = dialogConfig.getDialogName();
+                    Map<String, DialogFeatureConfig> featureMap = dialogConfigMap.get(dialogName);
+                    if (featureMap == null) {
+                        featureMap = new HashMap<String, DialogFeatureConfig>();
+                        dialogConfigMap.put(dialogName, featureMap);
+                    }
+                    featureMap.put(dialogConfig.getFeatureName(), dialogConfig);
+                }
+            }
+        }
+
+        return dialogConfigMap;
+    }
+
+    public static String safeGetStringFromResponse(JSONObject response, String propertyName) {
+        return response != null ? response.optString(propertyName, "") : "";
+    }
+
+    public static JSONObject tryGetJSONObjectFromResponse(JSONObject response, String propertyKey) {
+        return response != null ? response.optJSONObject(propertyKey) : null;
+    }
+
+    public static JSONArray tryGetJSONArrayFromResponse(JSONObject response, String propertyKey) {
+        return response != null ? response.optJSONArray(propertyKey) : null;
     }
 
     public static void clearCaches(Context context) {
@@ -404,29 +934,298 @@ public static void deleteDirectory(File directoryOrFile) {
         return result;
     }
 
-    // Return a hash of the android_id combined with the appid.  Intended to dedupe requests on the server side
-    // in order to do counting of users unknown to Facebook.  Because we put the appid into the key prior to hashing,
-    // we cannot do correlation of the same user across multiple apps -- this is intentional.  When we transition to
-    // the Google advertising ID, we'll get rid of this and always send that up.
-    public static String getHashedDeviceAndAppID(Context context, String applicationId) {
-        String androidId = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);
+    public static List<String> jsonArrayToStringList(JSONArray jsonArray) throws JSONException {
+        ArrayList<String> result = new ArrayList<>();
+
+        for (int i = 0; i < jsonArray.length(); i++) {
+            result.add(jsonArray.getString(i));
+        }
+
+        return result;
+    }
+
+    public static void setAppEventAttributionParameters(
+            JSONObject params,
+            AttributionIdentifiers attributionIdentifiers,
+            String anonymousAppDeviceGUID,
+            boolean limitEventUsage) throws JSONException {
+        if (attributionIdentifiers != null && attributionIdentifiers.getAttributionId() != null) {
+            params.put("attribution", attributionIdentifiers.getAttributionId());
+        }
+
+        if (attributionIdentifiers != null &&
+                attributionIdentifiers.getAndroidAdvertiserId() != null) {
+            params.put("advertiser_id", attributionIdentifiers.getAndroidAdvertiserId());
+            params.put("advertiser_tracking_enabled", !attributionIdentifiers.isTrackingLimited());
+        }
+
+        params.put("anon_id", anonymousAppDeviceGUID);
+        params.put("application_tracking_enabled", !limitEventUsage);
+    }
+
+    public static void setAppEventExtendedDeviceInfoParameters(
+            JSONObject params,
+            Context appContext
+    ) throws JSONException {
+        JSONArray extraInfoArray = new JSONArray();
+        extraInfoArray.put(EXTRA_APP_EVENTS_INFO_FORMAT_VERSION);
+
+        // Application Manifest info:
+        String pkgName = appContext.getPackageName();
+        int versionCode = -1;
+        String versionName = "";
+
+        try {
+            PackageInfo pi = appContext.getPackageManager().getPackageInfo(pkgName, 0);
+            versionCode = pi.versionCode;
+            versionName = pi.versionName;
+        } catch (PackageManager.NameNotFoundException e) {
+            // Swallow
+        }
 
-        if (androidId == null) {
+        // Application Manifest info:
+        extraInfoArray.put(pkgName);
+        extraInfoArray.put(versionCode);
+        extraInfoArray.put(versionName);
+
+        params.put("extinfo", extraInfoArray.toString());
+    }
+
+    public static Method getMethodQuietly(
+            Class<?> clazz,
+            String methodName,
+            Class<?>... parameterTypes) {
+        try {
+            return clazz.getMethod(methodName, parameterTypes);
+        } catch (NoSuchMethodException ex) {
             return null;
+        }
+    }
+
+    public static Method getMethodQuietly(
+            String className,
+            String methodName,
+            Class<?>... parameterTypes) {
+        try {
+            Class<?> clazz = Class.forName(className);
+            return getMethodQuietly(clazz, methodName, parameterTypes);
+        } catch (ClassNotFoundException ex) {
+            return null;
+        }
+    }
+
+    public static Object invokeMethodQuietly(Object receiver, Method method, Object... args) {
+        try {
+            return method.invoke(receiver, args);
+        } catch (IllegalAccessException ex) {
+            return null;
+        } catch (InvocationTargetException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the name of the current activity if the context is an activity, otherwise return
+     * "unknown"
+     */
+    public static String getActivityName(Context context) {
+        if (context == null) {
+            return "null";
+        } else if (context == context.getApplicationContext()) {
+            return "unknown";
         } else {
-            return sha1hash(androidId + applicationId);
+            return context.getClass().getSimpleName();
         }
     }
 
-    public static void setAppEventAttributionParameters(GraphObject params,
-            String attributionId, String hashedDeviceAndAppId, boolean limitEventUsage) {
-        // Send attributionID if it exists, otherwise send a hashed device+appid specific value as the advertiser_id.
-        if (attributionId != null) {
-            params.setProperty("attribution", attributionId);
-        } else if (hashedDeviceAndAppId != null) {
-            params.setProperty("advertiser_id", hashedDeviceAndAppId);
+    public interface Predicate<T> {
+        public boolean apply(T item);
+    }
+
+    public static <T> List<T> filter(final List<T> target, final Predicate<T> predicate) {
+        if (target == null) {
+            return null;
+        }
+        final List<T> list = new ArrayList<T>();
+        for (T item : target) {
+            if (predicate.apply(item)) {
+                list.add(item);
+            }
         }
+        return (list.size() == 0 ? null : list);
+    }
+
+    public interface Mapper<T, K> {
+        public K apply(T item);
+    }
+
+    public static <T, K> List<K> map(final List<T> target, final Mapper<T, K> mapper) {
+        if (target == null) {
+            return null;
+        }
+        final List<K> list = new ArrayList<K>();
+        for (T item : target) {
+            final K mappedItem = mapper.apply(item);
+            if (mappedItem != null) {
+                list.add(mappedItem);
+            }
+        }
+        return (list.size() == 0 ? null : list);
+    }
 
-        params.setProperty("application_tracking_enabled", !limitEventUsage);
+    public static String getUriString(final Uri uri) {
+        return (uri == null ? null : uri.toString());
+    }
+
+    public static boolean isWebUri(final Uri uri) {
+        return (uri != null)
+                && ("http".equalsIgnoreCase(uri.getScheme())
+                || "https".equalsIgnoreCase(uri.getScheme()));
+    }
+
+    public static boolean isContentUri(final Uri uri) {
+        return (uri != null) && ("content".equalsIgnoreCase(uri.getScheme()));
+    }
+
+    public static boolean isFileUri(final Uri uri) {
+        return (uri != null) && ("file".equalsIgnoreCase(uri.getScheme()));
+    }
+
+    public static long getContentSize(final Uri contentUri) {
+        Cursor cursor = null;
+        try {
+            cursor = FacebookSdk
+                    .getApplicationContext()
+                    .getContentResolver()
+                    .query(contentUri, null, null, null, null);
+            int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);
+
+            cursor.moveToFirst();
+            return cursor.getLong(sizeIndex);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    public static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long secondsFromBase = Long.MIN_VALUE;
+
+        Object secondsObject = bundle.get(key);
+        if (secondsObject instanceof Long) {
+            secondsFromBase = (Long) secondsObject;
+        } else if (secondsObject instanceof String) {
+            try {
+                secondsFromBase = Long.parseLong((String) secondsObject);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+
+        if (secondsFromBase == 0) {
+            return new Date(Long.MAX_VALUE);
+        } else {
+            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
+        }
+    }
+
+    public static void writeStringMapToParcel(Parcel parcel, final Map<String, String> map) {
+        if (map == null) {
+            // 0 is for empty map, -1 to indicate null
+            parcel.writeInt(-1);
+        } else {
+            parcel.writeInt(map.size());
+            for (Map.Entry<String, String> entry : map.entrySet()) {
+                parcel.writeString(entry.getKey());
+                parcel.writeString(entry.getValue());
+            }
+        }
+    }
+
+    public static Map<String, String> readStringMapFromParcel(Parcel parcel) {
+        int size = parcel.readInt();
+        if (size < 0) {
+            return null;
+        }
+        Map<String, String> map = new HashMap<>();
+        for (int i = 0; i < size; i++) {
+            map.put(parcel.readString(), parcel.readString());
+        }
+        return map;
+    }
+
+    public static boolean isCurrentAccessToken(AccessToken token) {
+        return token != null ? token.equals(AccessToken.getCurrentAccessToken()) : false;
+    }
+
+    public interface GraphMeRequestWithCacheCallback {
+        void onSuccess(JSONObject userInfo);
+
+        void onFailure(FacebookException error);
+    }
+
+    public static void getGraphMeRequestWithCacheAsync(
+            final String accessToken,
+            final GraphMeRequestWithCacheCallback callback) {
+        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
+        if (cachedValue != null) {
+            callback.onSuccess(cachedValue);
+            return;
+        }
+
+        GraphRequest.Callback graphCallback = new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                if (response.getError() != null) {
+                    callback.onFailure(response.getError().getException());
+                } else {
+                    ProfileInformationCache.putProfileInformation(
+                            accessToken,
+                            response.getJSONObject());
+                    callback.onSuccess(response.getJSONObject());
+                }
+            }
+        };
+        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
+        graphRequest.setCallback(graphCallback);
+        graphRequest.executeAsync();
+    }
+
+    public static JSONObject awaitGetGraphMeRequestWithCache(
+            final String accessToken) {
+        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
+        if (cachedValue != null) {
+            return cachedValue;
+        }
+
+        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
+        GraphResponse response = graphRequest.executeAndWait();
+        if (response.getError() != null) {
+            return null;
+        }
+
+        return response.getJSONObject();
+    }
+
+    private static GraphRequest getGraphMeRequestWithCache(
+            final String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id,name,first_name,middle_name,last_name,link");
+        parameters.putString("access_token", accessToken);
+        GraphRequest graphRequest = new GraphRequest(
+                null,
+                "me",
+                parameters,
+                HttpMethod.GET,
+                null);
+        return graphRequest;
     }
 }
+
diff --git a/facebook/src/com/facebook/internal/Validate.java b/facebook/src/com/facebook/internal/Validate.java
index 5f74ac97c..ce393d9d7 100644
--- a/facebook/src/com/facebook/internal/Validate.java
+++ b/facebook/src/com/facebook/internal/Validate.java
@@ -1,29 +1,67 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
+import android.Manifest;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.os.Looper;
+import android.util.Log;
+
+import com.facebook.FacebookActivity;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.FacebookSdkNotInitializedException;
+import com.facebook.LoggingBehavior;
+
 import java.util.Collection;
 
 /**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
  */
 public final class Validate {
+
+    private static final String TAG = Validate.class.getName();
+
+    private static final String NO_INTERNET_PERMISSION_REASON =
+            "No internet permissions granted for the app, please add " +
+            "<uses-permission android:name=\"android.permission.INTERNET\" /> " +
+            "to your AndroidManifest.xml.";
+
+    private static final String FACEBOOK_ACTIVITY_NOT_FOUND_REASON =
+            "FacebookActivity is not declared in the AndroidManifest.xml, please add " +
+            "com.facebook.FacebookActivity to your AndroidManifest.xml file. See " +
+            "https://developers.facebook.com/docs/android/getting-started for more info.";
+
+    private static final String CONTENT_PROVIDER_NOT_FOUND_REASON =
+            "A ContentProvider for this app was not set up in the AndroidManifest.xml, please " +
+            "add %s as a provider to your AndroidManifest.xml file. See " +
+            "https://developers.facebook.com/docs/sharing/android for more info.";
+
+    private static final String CONTENT_PROVIDER_BASE = "com.facebook.app.FacebookContentProvider";
+
     public static void notNull(Object arg, String name) {
         if (arg == null) {
             throw new NullPointerException("Argument '" + name + "' cannot be null");
@@ -40,7 +78,8 @@ public static void notNull(Object arg, String name) {
         Validate.notNull(container, name);
         for (T item : container) {
             if (item == null) {
-                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+                throw new NullPointerException("Container '" + name +
+                        "' cannot contain null values");
             }
         }
     }
@@ -49,10 +88,12 @@ public static void containsNoNullOrEmpty(Collection<String> container, String na
         Validate.notNull(container, name);
         for (String item : container) {
             if (item == null) {
-                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+                throw new NullPointerException("Container '" + name +
+                        "' cannot contain null values");
             }
             if (item.length() == 0) {
-                throw new IllegalArgumentException("Container '" + name + "' cannot contain empty values");
+                throw new IllegalArgumentException("Container '" + name +
+                        "' cannot contain empty values");
             }
         }
     }
@@ -62,6 +103,12 @@ public static void containsNoNullOrEmpty(Collection<String> container, String na
         Validate.notEmpty(container, name);
     }
 
+    public static void runningOnUiThread() {
+        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
+            throw new FacebookException("This method should be called from the UI thread");
+        }
+    }
+
     public static void notNullOrEmpty(String arg, String name) {
         if (Utility.isNullOrEmpty(arg)) {
             throw new IllegalArgumentException("Argument '" + name + "' cannot be null or empty");
@@ -80,6 +127,77 @@ public static void oneOf(Object arg, String name, Object... values) {
                 }
             }
         }
-        throw new IllegalArgumentException("Argument '" + name + "' was not one of the allowed values");
+        throw new IllegalArgumentException("Argument '" + name +
+                "' was not one of the allowed values");
+    }
+
+    public static void sdkInitialized() {
+        if (!FacebookSdk.isInitialized()) {
+            throw new FacebookSdkNotInitializedException(
+                    "The SDK has not been initialized, make sure to call " +
+                    "FacebookSdk.sdkInitialize() first.");
+        }
+    }
+
+    public static String hasAppID() {
+        String id = FacebookSdk.getApplicationId();
+        if (id == null) {
+            throw new IllegalStateException("No App ID found, please set the App ID.");
+        }
+        return id;
+    }
+
+    public static void hasInternetPermissions(Context context) {
+        Validate.hasInternetPermissions(context, true);
+    }
+
+    public static void hasInternetPermissions(Context context, boolean shouldThrow) {
+        Validate.notNull(context, "context");
+        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) ==
+                PackageManager.PERMISSION_DENIED) {
+            if (shouldThrow) {
+                throw new IllegalStateException(NO_INTERNET_PERMISSION_REASON);
+            } else {
+                Log.w(TAG, NO_INTERNET_PERMISSION_REASON);
+            }
+        }
+    }
+
+    public static void hasFacebookActivity(Context context) {
+        Validate.hasFacebookActivity(context, true);
+    }
+
+    public static void hasFacebookActivity(Context context, boolean shouldThrow) {
+        Validate.notNull(context, "context");
+        PackageManager pm = context.getPackageManager();
+        ActivityInfo activityInfo = null;
+        if (pm != null) {
+            ComponentName componentName =
+                    new ComponentName(context, FacebookActivity.class);
+            try {
+                activityInfo = pm.getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);
+            } catch (PackageManager.NameNotFoundException e) {
+            }
+        }
+        if (activityInfo == null) {
+            if (shouldThrow) {
+                throw new IllegalStateException(FACEBOOK_ACTIVITY_NOT_FOUND_REASON);
+            } else {
+                Log.w(TAG, FACEBOOK_ACTIVITY_NOT_FOUND_REASON);
+            }
+        }
+    }
+
+    public static void hasContentProvider(Context context) {
+        Validate.notNull(context, "context");
+        String appId = Validate.hasAppID();
+        PackageManager pm = context.getPackageManager();
+        if (pm != null) {
+            String providerName = CONTENT_PROVIDER_BASE + appId;
+            if (pm.resolveContentProvider(providerName, 0) == null) {
+                throw new IllegalStateException(
+                        String.format(CONTENT_PROVIDER_NOT_FOUND_REASON, providerName));
+            }
+        }
     }
 }
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/internal/WebDialog.java
similarity index 53%
rename from facebook/src/com/facebook/widget/WebDialog.java
rename to facebook/src/com/facebook/internal/WebDialog.java
index aaced5ccd..28d7279ab 100644
--- a/facebook/src/com/facebook/widget/WebDialog.java
+++ b/facebook/src/com/facebook/internal/WebDialog.java
@@ -1,20 +1,24 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.internal;
 
 import android.annotation.SuppressLint;
 import android.app.Dialog;
@@ -37,13 +41,13 @@
 import android.widget.ImageView;
 import android.widget.LinearLayout;
 import com.facebook.*;
-import com.facebook.android.*;
-import com.facebook.internal.Logger;
-import com.facebook.internal.ServerProtocol;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
+import com.facebook.R;
 
 /**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ *
  * This class provides a mechanism for displaying Facebook Web dialogs inside a Dialog. Helper
  * methods are provided to construct commonly-used dialogs, or a caller can specify arbitrary
  * parameters to call other dialogs.
@@ -51,7 +55,7 @@
 public class WebDialog extends Dialog {
     private static final String LOG_TAG = Logger.LOG_TAG_BASE + "WebDialog";
     private static final String DISPLAY_TOUCH = "touch";
-    private static final String USER_AGENT = "user_agent";
+    private static final int API_EC_DIALOG_CANCEL = 4201;
     static final String REDIRECT_URI = "fbconnect://success";
     static final String CANCEL_URI = "fbconnect://cancel";
     static final boolean DISABLE_SSL_CHECK_FOR_TESTING = false;
@@ -73,6 +77,7 @@
     public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;
 
     private String url;
+    private String expectedRedirectUrl = REDIRECT_URI;
     private OnCompleteListener onCompleteListener;
     private WebView webView;
     private ProgressDialog spinner;
@@ -80,6 +85,7 @@
     private FrameLayout contentFrameLayout;
     private boolean listenerCalled = false;
     private boolean isDetached = false;
+    private boolean isPageFinished = false;
 
     /**
      * Interface that implements a listener to be called when the user's interaction with the
@@ -140,9 +146,10 @@ public WebDialog(Context context, String action, Bundle parameters, int theme, O
         parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
 
         parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, DISPLAY_TOUCH);
-        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, USER_AGENT);
 
-        Uri uri = Utility.buildUri(ServerProtocol.getDialogAuthority(), ServerProtocol.DIALOG_PATH + action,
+        Uri uri = Utility.buildUri(
+                ServerProtocol.getDialogAuthority(),
+                ServerProtocol.getAPIVersion() + "/" + ServerProtocol.DIALOG_PATH + action,
                 parameters);
         this.url = uri.toString();
         onCompleteListener = listener;
@@ -166,17 +173,32 @@ public OnCompleteListener getOnCompleteListener() {
         return onCompleteListener;
     }
 
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            cancel();
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
     @Override
     public void dismiss() {
         if (webView != null) {
             webView.stopLoading();
         }
         if (!isDetached) {
-            if (spinner.isShowing()) {
+            if (spinner != null && spinner.isShowing()) {
                 spinner.dismiss();
             }
-            super.dismiss();
         }
+        super.dismiss();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        resize();
     }
 
     @Override
@@ -195,21 +217,13 @@ public void onAttachedToWindow() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        setOnCancelListener(new OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialogInterface) {
-                sendCancelToListener();
-            }
-        });
-
         spinner = new ProgressDialog(getContext());
         spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
         spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
         spinner.setOnCancelListener(new OnCancelListener() {
             @Override
             public void onCancel(DialogInterface dialogInterface) {
-                sendCancelToListener();
-                WebDialog.this.dismiss();
+                cancel();
             }
         });
 
@@ -217,7 +231,7 @@ public void onCancel(DialogInterface dialogInterface) {
         contentFrameLayout = new FrameLayout(getContext());
 
         // First calculate how big the frame layout should be
-        calculateSize();
+        resize();
         getWindow().setGravity(Gravity.CENTER);
 
         // resize the dialog if the soft keyboard comes up
@@ -245,7 +259,32 @@ public void onCancel(DialogInterface dialogInterface) {
         setContentView(contentFrameLayout);
     }
 
-    private void calculateSize() {
+    protected void setExpectedRedirectUrl(String expectedRedirectUrl) {
+        this.expectedRedirectUrl = expectedRedirectUrl;
+    }
+
+    protected Bundle parseResponseUri(String urlString) {
+        Uri u = Uri.parse(urlString);
+
+        Bundle b = Utility.parseUrlQueryString(u.getQuery());
+        b.putAll(Utility.parseUrlQueryString(u.getFragment()));
+
+        return b;
+    }
+
+    protected boolean isListenerCalled() {
+        return listenerCalled;
+    }
+
+    protected boolean isPageFinished() {
+        return isPageFinished;
+    }
+
+    protected WebView getWebView() {
+        return webView;
+    }
+
+    public void resize() {
         WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
         Display display = wm.getDefaultDisplay();
         DisplayMetrics metrics = new DisplayMetrics();
@@ -291,14 +330,15 @@ private int getScaledSize(int screenSize, float density, int noPaddingSize, int
         return (int) (screenSize * scaleFactor);
     }
 
-    private void sendSuccessToListener(Bundle values) {
+    protected void sendSuccessToListener(Bundle values) {
         if (onCompleteListener != null && !listenerCalled) {
             listenerCalled = true;
             onCompleteListener.onComplete(values, null);
+            dismiss();
         }
     }
 
-    private void sendErrorToListener(Throwable error) {
+    protected void sendErrorToListener(Throwable error) {
         if (onCompleteListener != null && !listenerCalled) {
             listenerCalled = true;
             FacebookException facebookException = null;
@@ -308,11 +348,14 @@ private void sendErrorToListener(Throwable error) {
                 facebookException = new FacebookException(error);
             }
             onCompleteListener.onComplete(null, facebookException);
+            dismiss();
         }
     }
 
-    private void sendCancelToListener() {
-        sendErrorToListener(new FacebookOperationCanceledException());
+    public void cancel() {
+        if (onCompleteListener != null && !listenerCalled) {
+            sendErrorToListener(new FacebookOperationCanceledException());
+        }
     }
 
     private void createCrossImage() {
@@ -321,8 +364,7 @@ private void createCrossImage() {
         crossImageView.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                sendCancelToListener();
-                WebDialog.this.dismiss();
+                cancel();
             }
         });
         Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
@@ -336,7 +378,18 @@ public void onClick(View v) {
     @SuppressLint("SetJavaScriptEnabled")
     private void setUpWebView(int margin) {
         LinearLayout webViewContainer = new LinearLayout(getContext());
-        webView = new WebView(getContext());
+        webView = new WebView(getContext().getApplicationContext()) {
+            /* Prevent NPE on Motorola 2.2 devices
+             * See https://groups.google.com/forum/?fromgroups=#!topic/android-developers/ktbwY2gtLKQ
+             */
+            @Override
+            public void onWindowFocusChanged(boolean hasWindowFocus) {
+                try {
+                    super.onWindowFocusChanged(hasWindowFocus);
+                } catch (NullPointerException e) {
+                }
+            }
+        };
         webView.setVerticalScrollBarEnabled(false);
         webView.setHorizontalScrollBarEnabled(false);
         webView.setWebViewClient(new DialogWebViewClient());
@@ -346,6 +399,19 @@ private void setUpWebView(int margin) {
                 ViewGroup.LayoutParams.MATCH_PARENT));
         webView.setVisibility(View.INVISIBLE);
         webView.getSettings().setSavePassword(false);
+        webView.getSettings().setSaveFormData(false);
+        webView.setFocusable(true);
+        webView.setFocusableInTouchMode(true);
+        webView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                if (!v.hasFocus())
+                {
+                    v.requestFocus();
+                }
+                return false;
+            }
+        });
 
         webViewContainer.setPadding(margin, margin, margin, margin);
         webViewContainer.addView(webView);
@@ -355,11 +421,10 @@ private void setUpWebView(int margin) {
 
     private class DialogWebViewClient extends WebViewClient {
         @Override
-        @SuppressWarnings("deprecation")
         public boolean shouldOverrideUrlLoading(WebView view, String url) {
             Utility.logd(LOG_TAG, "Redirect URL: " + url);
-            if (url.startsWith(WebDialog.REDIRECT_URI)) {
-                Bundle values = Util.parseUrl(url);
+            if (url.startsWith(WebDialog.this.expectedRedirectUrl)) {
+                Bundle values = parseResponseUri(url);
 
                 String error = values.getString("error");
                 if (error == null) {
@@ -367,6 +432,9 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 }
 
                 String errorMessage = values.getString("error_msg");
+                if (errorMessage == null) {
+                    errorMessage = values.getString("error_message");
+                }
                 if (errorMessage == null) {
                     errorMessage = values.getString("error_description");
                 }
@@ -385,17 +453,16 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
                     sendSuccessToListener(values);
                 } else if (error != null && (error.equals("access_denied") ||
                         error.equals("OAuthAccessDeniedException"))) {
-                    sendCancelToListener();
+                    cancel();
+                } else if (errorCode == API_EC_DIALOG_CANCEL) {
+                    cancel();
                 } else {
                     FacebookRequestError requestError = new FacebookRequestError(errorCode, error, errorMessage);
                     sendErrorToListener(new FacebookServiceException(requestError, errorMessage));
                 }
-
-                WebDialog.this.dismiss();
                 return true;
             } else if (url.startsWith(WebDialog.CANCEL_URI)) {
-                sendCancelToListener();
-                WebDialog.this.dismiss();
+                cancel();
                 return true;
             } else if (url.contains(DISPLAY_TOUCH)) {
                 return false;
@@ -411,7 +478,6 @@ public void onReceivedError(WebView view, int errorCode,
                 String description, String failingUrl) {
             super.onReceivedError(view, errorCode, description, failingUrl);
             sendErrorToListener(new FacebookDialogException(description, errorCode, failingUrl));
-            WebDialog.this.dismiss();
         }
 
         @Override
@@ -421,9 +487,8 @@ public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError e
             } else {
                 super.onReceivedSslError(view, handler, error);
 
-                sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
                 handler.cancel();
-                WebDialog.this.dismiss();
+                sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
             }
         }
 
@@ -449,45 +514,53 @@ public void onPageFinished(WebView view, String url) {
             contentFrameLayout.setBackgroundColor(Color.TRANSPARENT);
             webView.setVisibility(View.VISIBLE);
             crossImageView.setVisibility(View.VISIBLE);
+            isPageFinished = true;
         }
     }
 
-    private static class BuilderBase<CONCRETE extends BuilderBase<?>> {
+    public static class Builder {
         private Context context;
-        private Session session;
         private String applicationId;
         private String action;
         private int theme = DEFAULT_THEME;
         private OnCompleteListener listener;
         private Bundle parameters;
+        private AccessToken accessToken;
 
-        protected BuilderBase(Context context, String action) {
-            Session activeSession = Session.getActiveSession();
-            if (activeSession != null && activeSession.isOpened()) {
-                this.session = activeSession;
-            } else {
+        /**
+         * Constructor that builds a dialog using either the current access token, or the
+         * application id specified in the application/meta-data.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, String action, Bundle parameters) {
+            accessToken = AccessToken.getCurrentAccessToken();
+            if (accessToken == null) {
                 String applicationId = Utility.getMetadataApplicationId(context);
                 if (applicationId != null) {
                     this.applicationId = applicationId;
                 } else {
-                    throw new FacebookException("Attempted to create a builder without an open" +
-                            " Active Session or a valid default Application ID.");
+                    throw new FacebookException("Attempted to create a builder without a valid" +
+                            " access token or a valid default Application ID.");
                 }
             }
-            finishInit(context, action, null);
-        }
-
-        protected BuilderBase(Context context, Session session, String action, Bundle parameters) {
-            Validate.notNull(session, "session");
-            if (!session.isOpened()) {
-                throw new FacebookException("Attempted to use a Session that was not open.");
-            }
-            this.session = session;
 
             finishInit(context, action, parameters);
         }
 
-        protected BuilderBase(Context context, String applicationId, String action, Bundle parameters) {
+        /**
+         * Constructor that builds a dialog without an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param applicationId the application ID to be included in the dialog URL.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, String applicationId, String action, Bundle parameters) {
             if (applicationId == null) {
                 applicationId = Utility.getMetadataApplicationId(context);
             }
@@ -503,11 +576,9 @@ protected BuilderBase(Context context, String applicationId, String action, Bund
          * @param theme a theme identifier which will be passed to the Dialog class
          * @return the builder
          */
-        public CONCRETE setTheme(int theme) {
+        public Builder setTheme(int theme) {
             this.theme = theme;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
+            return this;
         }
 
         /**
@@ -516,11 +587,9 @@ public CONCRETE setTheme(int theme) {
          * @param listener the listener to notify, or null if no notification is desired
          * @return the builder
          */
-        public CONCRETE setOnCompleteListener(OnCompleteListener listener) {
+        public Builder setOnCompleteListener(OnCompleteListener listener) {
             this.listener = listener;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
+            return this;
         }
 
         /**
@@ -530,9 +599,13 @@ public CONCRETE setOnCompleteListener(OnCompleteListener listener) {
          * @return the WebDialog
          */
         public WebDialog build() {
-            if (session != null && session.isOpened()) {
-                parameters.putString(ServerProtocol.DIALOG_PARAM_APP_ID, session.getApplicationId());
-                parameters.putString(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, session.getAccessToken());
+            if (accessToken != null) {
+                parameters.putString(
+                        ServerProtocol.DIALOG_PARAM_APP_ID,
+                        accessToken.getApplicationId());
+                parameters.putString(
+                        ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN,
+                        accessToken.getToken());
             } else {
                 parameters.putString(ServerProtocol.DIALOG_PARAM_APP_ID, applicationId);
             }
@@ -540,23 +613,23 @@ public WebDialog build() {
             return new WebDialog(context, action, parameters, theme, listener);
         }
 
-        protected String getApplicationId() {
+        public String getApplicationId() {
             return applicationId;
         }
 
-        protected Context getContext() {
+        public Context getContext() {
             return context;
         }
 
-        protected int getTheme() {
+        public int getTheme() {
             return theme;
         }
 
-        protected Bundle getParameters() {
+        public Bundle getParameters() {
             return parameters;
         }
 
-        protected WebDialog.OnCompleteListener getListener() {
+        public WebDialog.OnCompleteListener getListener() {
             return listener;
         }
 
@@ -570,322 +643,4 @@ private void finishInit(Context context, String action, Bundle parameters) {
             }
         }
     }
-
-    /**
-     * Provides a builder that allows construction of an arbitary Facebook web dialog.
-     */
-    public static class Builder extends BuilderBase<Builder> {
-        /**
-         * Constructor that builds a dialog using either the active session, or the application
-         * id specified in the application/meta-data.
-         *
-         * @param context the Context within which the dialog will be shown.
-         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
-         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
-         */
-        public Builder(Context context, String action) {
-            super(context, action);
-        }
-
-        /**
-         * Constructor that builds a dialog for an authenticated user.
-         *
-         * @param context the Context within which the dialog will be shown.
-         * @param session the Session representing an authenticating user to use for
-         *                showing the dialog; must not be null, and must be opened.
-         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
-         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
-         * @param parameters a Bundle containing parameters to pass as part of the URL.
-         */
-        public Builder(Context context, Session session, String action, Bundle parameters) {
-            super(context, session, action, parameters);
-        }
-
-        /**
-         * Constructor that builds a dialog without an authenticated user.
-         *
-         * @param context the Context within which the dialog will be shown.
-         * @param applicationId the application ID to be included in the dialog URL.
-         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
-         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
-         * @param parameters a Bundle containing parameters to pass as part of the URL.
-         */
-        public Builder(Context context, String applicationId, String action, Bundle parameters) {
-            super(context, applicationId, action, parameters);
-        }
-    }
-
-    /**
-     * Provides a builder that allows construction of the parameters for showing
-     * the <a href="https://developers.facebook.com/docs/reference/dialogs/feed">Feed Dialog</a>.
-     */
-    public static class FeedDialogBuilder extends BuilderBase<FeedDialogBuilder> {
-        private static final String FEED_DIALOG = "feed";
-        private static final String FROM_PARAM = "from";
-        private static final String TO_PARAM = "to";
-        private static final String LINK_PARAM = "link";
-        private static final String PICTURE_PARAM = "picture";
-        private static final String SOURCE_PARAM = "source";
-        private static final String NAME_PARAM = "name";
-        private static final String CAPTION_PARAM = "caption";
-        private static final String DESCRIPTION_PARAM = "description";
-
-        /**
-         * Constructor that builds a Feed Dialog using either the active session, or the application
-         * ID specified in the application/meta-data.
-         *
-         * @param context the Context within which the dialog will be shown.
-         */
-        public FeedDialogBuilder(Context context) {
-            super(context, FEED_DIALOG);
-        }
-
-        /**
-         * Constructor that builds a Feed Dialog using the provided session.
-         *
-         * @param context the Context within which the dialog will be shown.
-         * @param session the Session representing an authenticating user to use for
-         *                showing the dialog; must not be null, and must be opened.
-         */
-        public FeedDialogBuilder(Context context, Session session) {
-            super(context, session, FEED_DIALOG, null);
-        }
-
-        /**
-         * Constructor that builds a Feed Dialog using the provided session and parameters.
-         *
-         * @param context    the Context within which the dialog will be shown.
-         * @param session    the Session representing an authenticating user to use for
-         *                   showing the dialog; must not be null, and must be opened.
-         * @param parameters a Bundle containing parameters to pass as part of the
-         *                   dialog URL. No validation is done on these parameters; it is
-         *                   the caller's responsibility to ensure they are valid. For more information,
-         *                   see <a href="https://developers.facebook.com/docs/reference/dialogs/feed/">
-         *                   https://developers.facebook.com/docs/reference/dialogs/feed/</a>.
-         */
-        public FeedDialogBuilder(Context context, Session session, Bundle parameters) {
-            super(context, session, FEED_DIALOG, parameters);
-        }
-
-        /**
-         * Constructor that builds a Feed Dialog using the provided application ID and parameters.
-         *
-         * @param context       the Context within which the dialog will be shown.
-         * @param applicationId the application ID to use. If null, the application ID specified in the
-         *                      application/meta-data will be used instead.
-         * @param parameters    a Bundle containing parameters to pass as part of the
-         *                      dialog URL. No validation is done on these parameters; it is
-         *                      the caller's responsibility to ensure they are valid. For more information,
-         *                      see <a href="https://developers.facebook.com/docs/reference/dialogs/feed/">
-         *                      https://developers.facebook.com/docs/reference/dialogs/feed/</a>.
-         */
-        public FeedDialogBuilder(Context context, String applicationId, Bundle parameters) {
-            super(context, applicationId, FEED_DIALOG, parameters);
-        }
-
-        /**
-         * Sets the ID of the profile that is posting to Facebook. If none is specified,
-         * the default is "me". This profile must be either the authenticated user or a
-         * Page that the user is an administrator of.
-         *
-         * @param id Facebook ID of the profile to post from
-         * @return the builder
-         */
-        public FeedDialogBuilder setFrom(String id) {
-            getParameters().putString(FROM_PARAM, id);
-            return this;
-        }
-
-        /**
-         * Sets the ID of the profile that the story will be published to. If not specified, it
-         * will default to the same profile that the story is being published from.
-         *
-         * @param id Facebook ID of the profile to post to
-         * @return the builder
-         */
-        public FeedDialogBuilder setTo(String id) {
-            getParameters().putString(TO_PARAM, id);
-            return this;
-        }
-
-        /**
-         * Sets the URL of a link to be shared.
-         *
-         * @param link the URL
-         * @return the builder
-         */
-        public FeedDialogBuilder setLink(String link) {
-            getParameters().putString(LINK_PARAM, link);
-            return this;
-        }
-
-        /**
-         * Sets the URL of a picture to be shared.
-         *
-         * @param picture the URL of the picture
-         * @return the builder
-         */
-        public FeedDialogBuilder setPicture(String picture) {
-            getParameters().putString(PICTURE_PARAM, picture);
-            return this;
-        }
-
-        /**
-         * Sets the URL of a media file attached to this post. If this is set, any picture
-         * set via setPicture will be ignored.
-         *
-         * @param source the URL of the media file
-         * @return the builder
-         */
-        public FeedDialogBuilder setSource(String source) {
-            getParameters().putString(SOURCE_PARAM, source);
-            return this;
-        }
-
-        /**
-         * Sets the name of the item being shared.
-         *
-         * @param name the name
-         * @return the builder
-         */
-        public FeedDialogBuilder setName(String name) {
-            getParameters().putString(NAME_PARAM, name);
-            return this;
-        }
-
-        /**
-         * Sets the caption to be displayed.
-         *
-         * @param caption the caption
-         * @return the builder
-         */
-        public FeedDialogBuilder setCaption(String caption) {
-            getParameters().putString(CAPTION_PARAM, caption);
-            return this;
-        }
-
-        /**
-         * Sets the description to be displayed.
-         *
-         * @param description the description
-         * @return the builder
-         */
-        public FeedDialogBuilder setDescription(String description) {
-            getParameters().putString(DESCRIPTION_PARAM, description);
-            return this;
-        }
-    }
-
-    /**
-     * Provides a builder that allows construction of the parameters for showing
-     * the <a href="https://developers.facebook.com/docs/reference/dialogs/requests">Requests Dialog</a>.
-     */
-    public static class RequestsDialogBuilder extends BuilderBase<RequestsDialogBuilder> {
-        private static final String APPREQUESTS_DIALOG = "apprequests";
-        private static final String MESSAGE_PARAM = "message";
-        private static final String TO_PARAM = "to";
-        private static final String DATA_PARAM = "data";
-        private static final String TITLE_PARAM = "title";
-
-        /**
-         * Constructor that builds a Requests Dialog using either the active session, or the application
-         * ID specified in the application/meta-data.
-         *
-         * @param context the Context within which the dialog will be shown.
-         */
-        public RequestsDialogBuilder(Context context) {
-            super(context, APPREQUESTS_DIALOG);
-        }
-
-        /**
-         * Constructor that builds a Requests Dialog using the provided session.
-         *
-         * @param context the Context within which the dialog will be shown.
-         * @param session the Session representing an authenticating user to use for
-         *                showing the dialog; must not be null, and must be opened.
-         */
-        public RequestsDialogBuilder(Context context, Session session) {
-            super(context, session, APPREQUESTS_DIALOG, null);
-        }
-
-        /**
-         * Constructor that builds a Requests Dialog using the provided session and parameters.
-         *
-         * @param context    the Context within which the dialog will be shown.
-         * @param session    the Session representing an authenticating user to use for
-         *                   showing the dialog; must not be null, and must be opened.
-         * @param parameters a Bundle containing parameters to pass as part of the
-         *                   dialog URL. No validation is done on these parameters; it is
-         *                   the caller's responsibility to ensure they are valid. For more information,
-         *                   see <a href="https://developers.facebook.com/docs/reference/dialogs/requests/">
-         *                   https://developers.facebook.com/docs/reference/dialogs/requests/</a>.
-         */
-        public RequestsDialogBuilder(Context context, Session session, Bundle parameters) {
-            super(context, session, APPREQUESTS_DIALOG, parameters);
-        }
-
-        /**
-         * Constructor that builds a Requests Dialog using the provided application ID and parameters.
-         *
-         * @param context       the Context within which the dialog will be shown.
-         * @param applicationId the application ID to use. If null, the application ID specified in the
-         *                      application/meta-data will be used instead.
-         * @param parameters    a Bundle containing parameters to pass as part of the
-         *                      dialog URL. No validation is done on these parameters; it is
-         *                      the caller's responsibility to ensure they are valid. For more information,
-         *                      see <a href="https://developers.facebook.com/docs/reference/dialogs/requests/">
-         *                      https://developers.facebook.com/docs/reference/dialogs/requests/</a>.
-         */
-        public RequestsDialogBuilder(Context context, String applicationId, Bundle parameters) {
-            super(context, applicationId, APPREQUESTS_DIALOG, parameters);
-        }
-
-        /**
-         * Sets the string users receiving the request will see. The maximum length
-         * is 60 characters.
-         *
-         * @param message the message
-         * @return the builder
-         */
-        public RequestsDialogBuilder setMessage(String message) {
-            getParameters().putString(MESSAGE_PARAM, message);
-            return this;
-        }
-
-        /**
-         * Sets the user ID or user name the request will be sent to. If this is not
-         * specified, a friend selector will be displayed and the user can select up
-         * to 50 friends.
-         *
-         * @param id the id or user name to send the request to
-         * @return the builder
-         */
-        public RequestsDialogBuilder setTo(String id) {
-            getParameters().putString(TO_PARAM, id);
-            return this;
-        }
-
-        /**
-         * Sets optional data which can be used for tracking; maximum length is 255
-         * characters.
-         *
-         * @param data the data
-         * @return the builder
-         */
-        public RequestsDialogBuilder setData(String data) {
-            getParameters().putString(DATA_PARAM, data);
-            return this;
-        }
-
-        /**
-         * Sets an optional title for the dialog; maximum length is 50 characters.
-         *
-         * @param title the title
-         * @return the builder
-         */
-        public RequestsDialogBuilder setTitle(String title) {
-            getParameters().putString(TITLE_PARAM, title);
-            return this;
-        }
-    }
 }
diff --git a/facebook/src/com/facebook/internal/WorkQueue.java b/facebook/src/com/facebook/internal/WorkQueue.java
index f90f6acd7..1624cb8ff 100644
--- a/facebook/src/com/facebook/internal/WorkQueue.java
+++ b/facebook/src/com/facebook/internal/WorkQueue.java
@@ -1,26 +1,35 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
 
-import com.facebook.Settings;
+import com.facebook.FacebookSdk;
 
 import java.util.concurrent.Executor;
 
-class WorkQueue {
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class WorkQueue {
     public static final int DEFAULT_MAX_CONCURRENT = 8;
 
     private final Object workLock = new Object();
@@ -32,24 +41,24 @@
     private WorkNode runningJobs = null;
     private int runningCount = 0;
 
-    WorkQueue() {
+    public WorkQueue() {
         this(DEFAULT_MAX_CONCURRENT);
     }
 
-    WorkQueue(int maxConcurrent) {
-        this(maxConcurrent, Settings.getExecutor());
+    public WorkQueue(int maxConcurrent) {
+        this(maxConcurrent, FacebookSdk.getExecutor());
     }
 
-    WorkQueue(int maxConcurrent, Executor executor) {
+    public WorkQueue(int maxConcurrent, Executor executor) {
         this.maxConcurrent = maxConcurrent;
         this.executor = executor;
     }
 
-    WorkItem addActiveWorkItem(Runnable callback) {
+    public WorkItem addActiveWorkItem(Runnable callback) {
         return addActiveWorkItem(callback, true);
     }
 
-    WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
+    public WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
         WorkNode node = new WorkNode(callback);
         synchronized (workLock) {
             pendingJobs = node.addToList(pendingJobs, addToFront);
@@ -59,7 +68,7 @@ WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
         return node;
     }
 
-    void validate() {
+    public void validate() {
         synchronized (workLock) {
             // Verify that all running items know they are running, and counts match
             int count = 0;
@@ -213,7 +222,7 @@ void verify(boolean shouldBeRunning) {
         }
     }
 
-    interface WorkItem {
+    public interface WorkItem {
         boolean cancel();
         boolean isRunning();
         void moveToFront();
diff --git a/facebook/src/com/facebook/login/DefaultAudience.java b/facebook/src/com/facebook/login/DefaultAudience.java
new file mode 100644
index 000000000..e54fe3499
--- /dev/null
+++ b/facebook/src/com/facebook/login/DefaultAudience.java
@@ -0,0 +1,61 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * Certain operations such as publishing a status or publishing a photo require an audience. When
+ * the user grants an application permission to perform a publish operation, a default audience is
+ * selected as the publication ceiling for the application. This enumerated value allows the
+ * application to select which audience to ask the user to grant publish permission for.
+ */
+public enum DefaultAudience {
+    /**
+     * Represents an invalid default audience value, can be used when only reading.
+     */
+    NONE(null),
+
+    /**
+     * Indicates only the user is able to see posts made by the application.
+     */
+    ONLY_ME(NativeProtocol.AUDIENCE_ME),
+
+    /**
+     * Indicates that the user's friends are able to see posts made by the application.
+     */
+    FRIENDS(NativeProtocol.AUDIENCE_FRIENDS),
+
+    /**
+     * Indicates that all Facebook users are able to see posts made by the application.
+     */
+    EVERYONE(NativeProtocol.AUDIENCE_EVERYONE);
+
+    private final String nativeProtocolAudience;
+
+    private DefaultAudience(String protocol) {
+        nativeProtocolAudience = protocol;
+    }
+
+    public String getNativeProtocolAudience() {
+        return nativeProtocolAudience;
+    }
+}
diff --git a/facebook/src/com/facebook/login/GetTokenClient.java b/facebook/src/com/facebook/login/GetTokenClient.java
new file mode 100644
index 000000000..b2bc7c070
--- /dev/null
+++ b/facebook/src/com/facebook/login/GetTokenClient.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+
+import android.content.Context;
+import android.os.Bundle;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.PlatformServiceClient;
+
+final class GetTokenClient extends PlatformServiceClient {
+
+    GetTokenClient(Context context, String applicationId) {
+        super(
+                context,
+                NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REQUEST,
+                NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REPLY,
+                NativeProtocol.PROTOCOL_VERSION_20121101,
+                applicationId);
+    }
+
+    @Override
+    protected void populateRequestBundle(Bundle data) {
+    }
+}
+
diff --git a/facebook/src/com/facebook/login/GetTokenLoginMethodHandler.java b/facebook/src/com/facebook/login/GetTokenLoginMethodHandler.java
new file mode 100644
index 000000000..311fa06f5
--- /dev/null
+++ b/facebook/src/com/facebook/login/GetTokenLoginMethodHandler.java
@@ -0,0 +1,194 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.FacebookException;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Utility;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+class GetTokenLoginMethodHandler extends LoginMethodHandler {
+    private GetTokenClient getTokenClient;
+
+    GetTokenLoginMethodHandler(LoginClient loginClient) {
+        super(loginClient);
+    }
+
+    @Override
+    String getNameForLogging() {
+        return "get_token";
+    }
+
+    @Override
+    void cancel() {
+        if (getTokenClient != null) {
+            getTokenClient.cancel();
+            getTokenClient = null;
+        }
+    }
+
+    boolean tryAuthorize(final LoginClient.Request request) {
+        getTokenClient = new GetTokenClient(loginClient.getActivity(),
+            request.getApplicationId());
+        if (!getTokenClient.start()) {
+            return false;
+        }
+
+        loginClient.notifyBackgroundProcessingStart();
+
+        GetTokenClient.CompletedListener callback = new GetTokenClient.CompletedListener() {
+            @Override
+            public void completed(Bundle result) {
+                getTokenCompleted(request, result);
+            }
+        };
+
+        getTokenClient.setCompletedListener(callback);
+        return true;
+    }
+
+    void getTokenCompleted(LoginClient.Request request, Bundle result) {
+        getTokenClient = null;
+
+        loginClient.notifyBackgroundProcessingStop();
+
+        if (result != null) {
+            ArrayList<String> currentPermissions =
+                    result.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+            Set<String> permissions = request.getPermissions();
+            if ((currentPermissions != null) &&
+                    ((permissions == null) || currentPermissions.containsAll(permissions))) {
+                // We got all the permissions we needed, so we can complete the auth now.
+                complete(request, result);
+                return;
+            }
+
+            // We didn't get all the permissions we wanted, so update the request with just the
+            // permissions we still need.
+            Set<String> newPermissions = new HashSet<String>();
+            for (String permission : permissions) {
+                if (!currentPermissions.contains(permission)) {
+                    newPermissions.add(permission);
+                }
+            }
+            if (!newPermissions.isEmpty()) {
+                addLoggingExtra(
+                    LoginLogger.EVENT_EXTRAS_NEW_PERMISSIONS,
+                    TextUtils.join(",", newPermissions)
+                );
+            }
+
+            request.setPermissions(newPermissions);
+        }
+
+        loginClient.tryNextHandler();
+    }
+
+    void onComplete(final LoginClient.Request request, final Bundle result) {
+        AccessToken token = createAccessTokenFromNativeLogin(
+                result,
+                AccessTokenSource.FACEBOOK_APPLICATION_SERVICE,
+                request.getApplicationId());
+        LoginClient.Result outcome =
+                LoginClient.Result.createTokenResult(loginClient.getPendingRequest(), token);
+        loginClient.completeAndValidate(outcome);
+    }
+
+    // Workaround for old facebook apps that don't return the userid.
+    void complete(final LoginClient.Request request, final Bundle result) {
+        String userId = result.getString(NativeProtocol.EXTRA_USER_ID);
+        // If the result is missing the UserId request it
+        if (userId == null || userId.isEmpty()) {
+            loginClient.notifyBackgroundProcessingStart();
+
+            String accessToken = result.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+            Utility.getGraphMeRequestWithCacheAsync(
+                    accessToken,
+                    new Utility.GraphMeRequestWithCacheCallback() {
+                        @Override
+                        public void onSuccess(JSONObject userInfo) {
+                            try {
+                                String userId = userInfo.getString("id");
+                                result.putString(NativeProtocol.EXTRA_USER_ID, userId);
+                                onComplete(request, result);
+                            } catch (JSONException ex) {
+                                loginClient.complete(LoginClient.Result.createErrorResult(
+                                        loginClient.getPendingRequest(),
+                                        "Caught exception",
+                                        ex.getMessage()));
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(FacebookException error) {
+                            loginClient.complete(LoginClient.Result.createErrorResult(
+                                    loginClient.getPendingRequest(),
+                                    "Caught exception",
+                                    error.getMessage()));
+                        }
+                    });
+        } else {
+            onComplete(request, result);
+        }
+
+    }
+
+    GetTokenLoginMethodHandler(Parcel source) {
+        super(source);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+    }
+
+    public static final Parcelable.Creator<GetTokenLoginMethodHandler> CREATOR =
+            new Parcelable.Creator() {
+
+        @Override
+        public GetTokenLoginMethodHandler createFromParcel(Parcel source) {
+            return new GetTokenLoginMethodHandler(source);
+        }
+
+        @Override
+        public GetTokenLoginMethodHandler[] newArray(int size) {
+            return new GetTokenLoginMethodHandler[size];
+        }
+    };
+}
diff --git a/facebook/src/com/facebook/login/KatanaProxyLoginMethodHandler.java b/facebook/src/com/facebook/login/KatanaProxyLoginMethodHandler.java
new file mode 100644
index 000000000..31d185ca0
--- /dev/null
+++ b/facebook/src/com/facebook/login/KatanaProxyLoginMethodHandler.java
@@ -0,0 +1,171 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.FacebookException;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+
+class KatanaProxyLoginMethodHandler extends LoginMethodHandler {
+
+    KatanaProxyLoginMethodHandler(LoginClient loginClient) {
+        super(loginClient);
+    }
+
+    @Override
+    String getNameForLogging() {
+        return "katana_proxy_auth";
+    }
+
+    @Override
+    boolean tryAuthorize(LoginClient.Request request) {
+        String e2e = LoginClient.getE2E();
+        Intent intent = NativeProtocol.createProxyAuthIntent(
+                loginClient.getActivity(),
+                request.getApplicationId(),
+                request.getPermissions(),
+                e2e,
+                request.isRerequest(),
+                request.hasPublishPermission(),
+                request.getDefaultAudience());
+
+        addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);
+
+        return tryIntent(intent, LoginClient.getLoginRequestCode());
+    }
+
+    @Override
+    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        // Handle stuff
+        LoginClient.Result outcome;
+
+        LoginClient.Request request = loginClient.getPendingRequest();
+
+        if (data == null) {
+            // This happens if the user presses 'Back'.
+            outcome = LoginClient.Result.createCancelResult(request, "Operation canceled");
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            outcome = LoginClient.Result.createCancelResult(request, data.getStringExtra("error"));
+        } else if (resultCode != Activity.RESULT_OK) {
+            outcome = LoginClient.Result.createErrorResult(request,
+                    "Unexpected resultCode from authorization.", null);
+        } else {
+            outcome = handleResultOk(request, data);
+        }
+
+        if (outcome != null) {
+            loginClient.completeAndValidate(outcome);
+        } else {
+            loginClient.tryNextHandler();
+        }
+        return true;
+    }
+
+    private LoginClient.Result handleResultOk(LoginClient.Request request, Intent data) {
+        Bundle extras = data.getExtras();
+        String error = extras.getString("error");
+        if (error == null) {
+            error = extras.getString("error_type");
+        }
+        String errorCode = extras.getString("error_code");
+        String errorMessage = extras.getString("error_message");
+        if (errorMessage == null) {
+            errorMessage = extras.getString("error_description");
+        }
+
+        String e2e = extras.getString(NativeProtocol.FACEBOOK_PROXY_AUTH_E2E_KEY);
+        if (!Utility.isNullOrEmpty(e2e)) {
+            logWebLoginCompleted(e2e);
+        }
+
+        if (error == null && errorCode == null && errorMessage == null) {
+            try {
+                AccessToken token = createAccessTokenFromWebBundle(request.getPermissions(),
+                        extras, AccessTokenSource.FACEBOOK_APPLICATION_WEB,
+                        request.getApplicationId());
+                return LoginClient.Result.createTokenResult(request, token);
+            } catch (FacebookException ex) {
+                return LoginClient.Result.createErrorResult(request, null, ex.getMessage());
+            }
+        } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
+            return null;
+        } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
+            return LoginClient.Result.createCancelResult(request, null);
+        } else {
+            return LoginClient.Result.createErrorResult(request, error, errorMessage, errorCode);
+        }
+    }
+
+    protected boolean tryIntent(Intent intent, int requestCode) {
+        if (intent == null) {
+            return false;
+        }
+
+        try {
+            loginClient.getFragment().startActivityForResult(intent, requestCode);
+        } catch (ActivityNotFoundException e) {
+            // We don't expect this to happen, since we've already validated the intent and bailed
+            // out before now if it couldn't be resolved.
+            return false;
+        }
+
+        return true;
+    }
+
+    KatanaProxyLoginMethodHandler(Parcel source) {
+        super(source);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+    }
+
+    public static final Parcelable.Creator<KatanaProxyLoginMethodHandler> CREATOR =
+            new Parcelable.Creator() {
+
+                @Override
+                public KatanaProxyLoginMethodHandler createFromParcel(Parcel source) {
+                    return new KatanaProxyLoginMethodHandler(source);
+                }
+
+                @Override
+                public KatanaProxyLoginMethodHandler[] newArray(int size) {
+                    return new KatanaProxyLoginMethodHandler[size];
+                }
+            };
+}
diff --git a/facebook/src/com/facebook/login/LoginBehavior.java b/facebook/src/com/facebook/login/LoginBehavior.java
new file mode 100644
index 000000000..e2d4fd6fb
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginBehavior.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+/**
+ * Specifies the behaviors to try during login.
+ */
+public enum LoginBehavior {
+    /**
+     * Specifies that login should attempt Single Sign On (SSO), and if that
+     * does not work fall back to dialog auth. This is the default behavior.
+     */
+    SSO_WITH_FALLBACK(true, true),
+
+    /**
+     * Specifies that login should only attempt SSO. If SSO fails, then the
+     * login fails.
+     */
+    SSO_ONLY(true, false),
+
+    /**
+     * Specifies that SSO should not be attempted, and to only use dialog auth.
+     */
+    SUPPRESS_SSO(false, true);
+
+    private final boolean allowsKatanaAuth;
+    private final boolean allowsWebViewAuth;
+
+    private LoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
+        this.allowsKatanaAuth = allowsKatanaAuth;
+        this.allowsWebViewAuth = allowsWebViewAuth;
+    }
+
+    boolean allowsKatanaAuth() {
+        return allowsKatanaAuth;
+    }
+
+    boolean allowsWebViewAuth() {
+        return allowsWebViewAuth;
+    }
+}
diff --git a/facebook/src/com/facebook/login/LoginClient.java b/facebook/src/com/facebook/login/LoginClient.java
new file mode 100644
index 000000000..a4ced69f6
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginClient.java
@@ -0,0 +1,738 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.text.TextUtils;
+
+import com.facebook.AccessToken;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.appevents.AppEventsConstants;
+import com.facebook.FacebookException;
+import com.facebook.HttpMethod;
+import com.facebook.R;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+class LoginClient implements Parcelable {
+    LoginMethodHandler [] handlersToTry;
+    int currentHandler = -1;
+    Fragment fragment;
+    OnCompletedListener onCompletedListener;
+    BackgroundProcessingListener backgroundProcessingListener;
+    boolean checkedInternetPermission;
+    Request pendingRequest;
+    Map<String, String> loggingExtras;
+    private LoginLogger loginLogger;
+
+    public interface OnCompletedListener {
+        void onCompleted(Result result);
+    }
+
+    interface BackgroundProcessingListener {
+        void onBackgroundProcessingStarted();
+
+        void onBackgroundProcessingStopped();
+    }
+
+    public LoginClient(Fragment fragment) {
+        this.fragment = fragment;
+    }
+
+    public Fragment getFragment() {
+        return fragment;
+    }
+
+    void setFragment(Fragment fragment) {
+        if (this.fragment != null) {
+            throw new FacebookException("Can't set fragment once it is already set.");
+        }
+        this.fragment = fragment;
+    }
+
+    FragmentActivity getActivity() {
+        return fragment.getActivity();
+    }
+
+
+    public Request getPendingRequest() {
+        return pendingRequest;
+    }
+
+    public static int getLoginRequestCode() {
+        return CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode();
+    }
+
+    void startOrContinueAuth(Request request) {
+        if (!getInProgress()) {
+            authorize(request);
+        }
+    }
+
+    void authorize(Request request) {
+        if (request == null) {
+            return;
+        }
+
+        if (pendingRequest != null) {
+            throw new FacebookException("Attempted to authorize while a request is pending.");
+        }
+
+        if (AccessToken.getCurrentAccessToken() != null && !checkInternetPermission()) {
+            // We're going to need INTERNET permission later and don't have it, so fail early.
+            return;
+        }
+        pendingRequest = request;
+        handlersToTry = getHandlersToTry(request);
+        tryNextHandler();
+    }
+
+    boolean getInProgress() {
+        return pendingRequest != null && currentHandler >= 0;
+    }
+
+    void cancelCurrentHandler() {
+        if (currentHandler >= 0) {
+            getCurrentHandler().cancel();
+        }
+    }
+
+    private LoginMethodHandler getCurrentHandler() {
+        if (currentHandler >= 0) {
+            return handlersToTry[currentHandler];
+        } else {
+            return null;
+        }
+    }
+
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (pendingRequest != null) {
+            return getCurrentHandler()
+                    .onActivityResult(requestCode, resultCode, data);
+        }
+        return false;
+    }
+
+    private LoginMethodHandler [] getHandlersToTry(Request request) {
+        ArrayList<LoginMethodHandler> handlers = new ArrayList<LoginMethodHandler>();
+
+        final LoginBehavior behavior = request.getLoginBehavior();
+
+        if (behavior.allowsKatanaAuth()) {
+            handlers.add(new GetTokenLoginMethodHandler(this));
+            handlers.add(new KatanaProxyLoginMethodHandler(this));
+        }
+
+        if (behavior.allowsWebViewAuth()) {
+            handlers.add(new WebViewLoginMethodHandler(this));
+        }
+
+        LoginMethodHandler [] result = new LoginMethodHandler[handlers.size()];
+        handlers.toArray(result);
+        return result;
+    }
+
+    boolean checkInternetPermission() {
+        if (checkedInternetPermission) {
+            return true;
+        }
+
+        int permissionCheck = checkPermission(Manifest.permission.INTERNET);
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            Activity activity = getActivity();
+            String errorType = activity.getString(R.string.com_facebook_internet_permission_error_title);
+            String errorDescription = activity.getString(R.string.com_facebook_internet_permission_error_message);
+            complete(Result.createErrorResult(pendingRequest, errorType, errorDescription));
+
+            return false;
+        }
+
+        checkedInternetPermission = true;
+        return true;
+    }
+
+    void tryNextHandler() {
+        if (currentHandler >= 0) {
+            logAuthorizationMethodComplete(
+                    getCurrentHandler().getNameForLogging(),
+                    LoginLogger.EVENT_PARAM_METHOD_RESULT_SKIPPED,
+                    null,
+                    null,
+                    getCurrentHandler().methodLoggingExtras);
+        }
+
+        while (handlersToTry != null && currentHandler < (handlersToTry.length - 1)) {
+            currentHandler++;
+
+            boolean started = tryCurrentHandler();
+
+            if (started) {
+                return;
+            }
+        }
+
+        if (pendingRequest != null) {
+            // We went through all handlers without successfully attempting an auth.
+            completeWithFailure();
+        }
+    }
+
+    private void completeWithFailure() {
+        complete(Result.createErrorResult(pendingRequest, "Login attempt failed.", null));
+    }
+
+    private void addLoggingExtra(String key, String value, boolean accumulate) {
+        if (loggingExtras == null) {
+            loggingExtras = new HashMap<String, String>();
+        }
+        if (loggingExtras.containsKey(key) && accumulate) {
+            value = loggingExtras.get(key) + "," + value;
+        }
+        loggingExtras.put(key, value);
+    }
+
+    boolean tryCurrentHandler() {
+        LoginMethodHandler handler = getCurrentHandler();
+        if (handler.needsInternetPermission() && !checkInternetPermission()) {
+            addLoggingExtra(
+                LoginLogger.EVENT_EXTRAS_MISSING_INTERNET_PERMISSION,
+                AppEventsConstants.EVENT_PARAM_VALUE_YES,
+                false
+            );
+            return false;
+        }
+
+        boolean tried = handler.tryAuthorize(pendingRequest);
+        if (tried) {
+            getLogger().logAuthorizationMethodStart(pendingRequest.getAuthId(),
+                    handler.getNameForLogging());
+        } else {
+            // We didn't try it, so we don't get any other completion
+            // notification -- log that we skipped it.
+            addLoggingExtra(
+                LoginLogger.EVENT_EXTRAS_NOT_TRIED,
+                    handler.getNameForLogging(),
+                true
+            );
+        }
+
+        return tried;
+    }
+
+    void completeAndValidate(Result outcome) {
+        // Do we need to validate a successful result (as in the case of a reauth)?
+        if (outcome.token != null && AccessToken.getCurrentAccessToken() != null) {
+            validateSameFbidAndFinish(outcome);
+        } else {
+            // We're done, just notify the listener.
+            complete(outcome);
+        }
+    }
+
+    void complete(Result outcome) {
+        LoginMethodHandler handler = getCurrentHandler();
+
+        // This might be null if, for some reason, none of the handlers were successfully tried
+        // (in which case we already logged that).
+        if (handler != null) {
+            logAuthorizationMethodComplete(handler.getNameForLogging(), outcome,
+                    handler.methodLoggingExtras);
+        }
+
+        if (loggingExtras != null) {
+            // Pass this back to the caller for logging at the aggregate level.
+            outcome.loggingExtras = loggingExtras;
+        }
+
+        handlersToTry = null;
+        currentHandler = -1;
+        pendingRequest = null;
+        loggingExtras = null;
+
+        notifyOnCompleteListener(outcome);
+    }
+
+    OnCompletedListener getOnCompletedListener() {
+        return onCompletedListener;
+    }
+
+    void setOnCompletedListener(OnCompletedListener onCompletedListener) {
+        this.onCompletedListener = onCompletedListener;
+    }
+
+    BackgroundProcessingListener getBackgroundProcessingListener() {
+        return backgroundProcessingListener;
+    }
+
+
+    void setBackgroundProcessingListener(
+            BackgroundProcessingListener backgroundProcessingListener) {
+        this.backgroundProcessingListener = backgroundProcessingListener;
+    }
+
+    int checkPermission(String permission) {
+        return getActivity().checkCallingOrSelfPermission(permission);
+    }
+
+    void validateSameFbidAndFinish(Result pendingResult) {
+        if (pendingResult.token == null) {
+            throw new FacebookException("Can't validate without a token");
+        }
+
+        AccessToken previousToken = AccessToken.getCurrentAccessToken();
+        AccessToken newToken = pendingResult.token;
+
+        try {
+            Result result = null;
+            if (previousToken != null && newToken != null &&
+                    previousToken.getUserId().equals(newToken.getUserId())) {
+                result = Result.createTokenResult(pendingRequest, pendingResult.token);
+            } else {
+                result = Result
+                        .createErrorResult(
+                                pendingRequest,
+                                "User logged in as different Facebook user.",
+                                null);
+            }
+            complete(result);
+        } catch (Exception ex) {
+            complete(Result.createErrorResult(
+                    pendingRequest,
+                    "Caught exception",
+                    ex.getMessage()));
+        }
+    }
+
+    private static AccessToken createFromTokenWithRefreshedPermissions(
+            AccessToken token,
+            Collection<String> grantedPermissions,
+            Collection<String> declinedPermissions) {
+        return new AccessToken(
+                token.getToken(),
+                token.getApplicationId(),
+                token.getUserId(),
+                grantedPermissions,
+                declinedPermissions,
+                token.getSource(),
+                token.getExpires(),
+                token.getLastRefresh());
+    }
+
+    private LoginLogger getLogger() {
+        if (loginLogger == null ||
+            !loginLogger.getApplicationId().equals(pendingRequest.getApplicationId())) {
+
+            loginLogger = new LoginLogger(getActivity(), pendingRequest.getApplicationId());
+        }
+        return loginLogger;
+    }
+
+    private void notifyOnCompleteListener(Result outcome) {
+        if (onCompletedListener != null) {
+            onCompletedListener.onCompleted(outcome);
+        }
+    }
+
+    void notifyBackgroundProcessingStart() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStarted();
+        }
+    }
+
+    void notifyBackgroundProcessingStop() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStopped();
+        }
+    }
+
+    private void logAuthorizationMethodComplete(
+            String method,
+            Result result,
+            Map<String, String> loggingExtras) {
+        logAuthorizationMethodComplete(method,
+                result.code.getLoggingValue(),
+                result.errorMessage,
+                result.errorCode,
+                loggingExtras);
+    }
+
+    private void logAuthorizationMethodComplete(
+            String method,
+            String result,
+            String errorMessage,
+            String errorCode,
+            Map<String, String> loggingExtras) {
+        if (pendingRequest == null) {
+            // We don't expect this to happen, but if it does, log an event for diagnostic purposes.
+            getLogger().logUnexpectedError(
+                    LoginLogger.EVENT_NAME_LOGIN_METHOD_COMPLETE,
+                    "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest.",
+                    method
+            );
+        } else {
+            getLogger().logAuthorizationMethodComplete(pendingRequest.getAuthId(), method, result,
+                    errorMessage, errorCode, loggingExtras);
+        }
+    }
+
+    static String getE2E() {
+        JSONObject e2e = new JSONObject();
+        try {
+            e2e.put("init", System.currentTimeMillis());
+        } catch (JSONException e) {
+        }
+        return e2e.toString();
+    }
+
+    public static class Request implements Parcelable {
+        private final LoginBehavior loginBehavior;
+        private Set<String> permissions;
+        private final DefaultAudience defaultAudience;
+        private final String applicationId;
+        private final String authId;
+        private boolean isRerequest = false;
+
+        Request(
+                LoginBehavior loginBehavior,
+                Set<String> permissions,
+                DefaultAudience defaultAudience,
+                String applicationId,
+                String authId) {
+            this.loginBehavior = loginBehavior;
+            this.permissions = permissions != null ? permissions : new HashSet<String>();
+            this.defaultAudience = defaultAudience;
+            this.applicationId = applicationId;
+            this.authId = authId;
+        }
+
+        Set<String> getPermissions() {
+            return permissions;
+        }
+
+        void setPermissions(Set<String> permissions) {
+            Validate.notNull(permissions, "permissions");
+            this.permissions = permissions;
+        }
+
+        LoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        DefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        String getAuthId() {
+            return authId;
+        }
+
+        boolean isRerequest() {
+            return isRerequest;
+        }
+
+        void setRerequest(boolean isRerequest) {
+            this.isRerequest = isRerequest;
+        }
+
+        boolean hasPublishPermission() {
+            for (String permission : permissions) {
+                if (LoginManager.isPublishPermission(permission)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private Request(Parcel parcel) {
+            String enumValue = parcel.readString();
+            this.loginBehavior = enumValue != null ? LoginBehavior.valueOf(enumValue) : null;
+            ArrayList<String> permissionsList = new ArrayList<>();
+            parcel.readStringList(permissionsList);
+            this.permissions = new HashSet<String>(permissionsList);
+            enumValue = parcel.readString();
+            this.defaultAudience = enumValue != null ? DefaultAudience.valueOf(enumValue) : null;
+            this.applicationId = parcel.readString();
+            this.authId = parcel.readString();
+            this.isRerequest = parcel.readByte() != 0 ? true : false;
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(loginBehavior != null ? loginBehavior.name() : null);
+            dest.writeStringList(new ArrayList<String>(permissions));
+            dest.writeString(defaultAudience != null ? defaultAudience.name() : null);
+            dest.writeString(applicationId);
+            dest.writeString(authId);
+            dest.writeByte((byte)(isRerequest ? 1 : 0));
+        }
+
+        public static final Parcelable.Creator<Request> CREATOR = new Parcelable.Creator() {
+            @Override
+            public Request createFromParcel(Parcel source) {
+                return new Request(source);
+            }
+
+            @Override
+            public Request[] newArray(int size) {
+                return new Request[size];
+            }
+        };
+    }
+
+    public static class Result implements Parcelable {
+        enum Code {
+            SUCCESS("success"),
+            CANCEL("cancel"),
+            ERROR("error");
+
+            private final String loggingValue;
+
+            Code(String loggingValue) {
+                this.loggingValue = loggingValue;
+            }
+
+            // For consistency across platforms, we want to use specific string values when logging
+            // these results.
+            String getLoggingValue() {
+                return loggingValue;
+            }
+        }
+
+        final Code code;
+        final AccessToken token;
+        final String errorMessage;
+        final String errorCode;
+        final Request request;
+        public Map<String, String> loggingExtras;
+
+        Result(
+                Request request,
+                Code code,
+                AccessToken token,
+                String errorMessage,
+                String errorCode) {
+            Validate.notNull(code, "code");
+            this.request = request;
+            this.token = token;
+            this.errorMessage = errorMessage;
+            this.code = code;
+            this.errorCode = errorCode;
+        }
+
+        static Result createTokenResult(Request request, AccessToken token) {
+            return new Result(request, Code.SUCCESS, token, null, null);
+        }
+
+        static Result createCancelResult(Request request, String message) {
+            return new Result(request, Code.CANCEL, null, message, null);
+        }
+
+        static Result createErrorResult(
+                Request request,
+                String errorType,
+                String errorDescription) {
+            return createErrorResult(request, errorType, errorDescription, null);
+        }
+
+        static Result createErrorResult(
+                Request request,
+                String errorType,
+                String errorDescription,
+                String errorCode) {
+            String message = TextUtils.join(
+                    ": ",
+                    Utility.asListNoNulls(errorType, errorDescription));
+            return new Result(request, Code.ERROR, null, message, errorCode);
+        }
+
+        private Result(Parcel parcel) {
+            this.code = Code.valueOf(parcel.readString());
+            this.token = parcel.readParcelable(AccessToken.class.getClassLoader());
+            this.errorMessage = parcel.readString();
+            this.errorCode = parcel.readString();
+            this.request = parcel.readParcelable(Request.class.getClassLoader());
+            this.loggingExtras = Utility.readStringMapFromParcel(parcel);
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(code.name());
+            dest.writeParcelable(token, flags);
+            dest.writeString(errorMessage);
+            dest.writeString(errorCode);
+            dest.writeParcelable(request, flags);
+            Utility.writeStringMapToParcel(dest, loggingExtras);
+        }
+
+        public static final Parcelable.Creator<Result> CREATOR = new Parcelable.Creator() {
+            @Override
+            public Result createFromParcel(Parcel source) {
+                return new Result(source);
+            }
+
+            @Override
+            public Result[] newArray(int size) {
+                return new Result[size];
+            }
+        };
+    }
+
+    /**
+     * Internal helper class that is used to hold two different permission lists (granted and
+     * declined)
+     */
+    private static class PermissionsPair {
+        List<String> grantedPermissions;
+        List<String> declinedPermissions;
+
+        public PermissionsPair(List<String> grantedPermissions, List<String> declinedPermissions) {
+            this.grantedPermissions = grantedPermissions;
+            this.declinedPermissions = declinedPermissions;
+        }
+
+        public List<String> getGrantedPermissions() {
+            return grantedPermissions;
+        }
+
+        public List<String> getDeclinedPermissions() {
+            return declinedPermissions;
+        }
+    }
+
+    /**
+     * This parses a server response to a call to me/permissions.  It will return the list of
+     * granted permissions. It will optionally update an access token with the requested permissions.
+     *
+     * @param response The server response
+     * @return A list of granted permissions or null if an error
+     */
+    private static PermissionsPair handlePermissionResponse(GraphResponse response) {
+        if (response.getError() != null) {
+            return null;
+        }
+
+        JSONObject result = response.getJSONObject();
+        if (result == null) {
+            return null;
+        }
+
+        JSONArray data = result.optJSONArray("data");
+        if (data == null || data.length() == 0) {
+            return null;
+        }
+        List<String> grantedPermissions = new ArrayList<String>(data.length());
+        List<String> declinedPermissions = new ArrayList<String>(data.length());
+
+        for (int i = 0; i < data.length(); ++i) {
+            JSONObject object = data.optJSONObject(i);
+            String permission = object.optString("permission");
+            if (permission == null || permission.equals("installed")) {
+                continue;
+            }
+            String status = object.optString("status");
+            if (status == null) {
+                continue;
+            }
+            if(status.equals("granted")) {
+                grantedPermissions.add(permission);
+            } else if (status.equals("declined")) {
+                declinedPermissions.add(permission);
+            }
+        }
+
+        return new PermissionsPair(grantedPermissions, declinedPermissions);
+    }
+
+    // Parcelable implementation
+
+    public LoginClient(Parcel source) {
+        Object [] o = source.readParcelableArray(LoginMethodHandler.class.getClassLoader());
+        handlersToTry = new LoginMethodHandler[o.length];
+        for (int i = 0; i < o.length; ++i) {
+            handlersToTry[i] = (LoginMethodHandler) o[i];
+            handlersToTry[i].setLoginClient(this);
+        }
+        currentHandler = source.readInt();
+        pendingRequest = source.readParcelable(Request.class.getClassLoader());
+        loggingExtras = Utility.readStringMapFromParcel(source);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeParcelableArray(handlersToTry, flags);
+        dest.writeInt(currentHandler);
+        dest.writeParcelable(pendingRequest, flags);
+        Utility.writeStringMapToParcel(dest, loggingExtras);
+    }
+
+    public static final Parcelable.Creator<LoginClient> CREATOR = new Parcelable.Creator() {
+        @Override
+        public LoginClient createFromParcel(Parcel source) {
+            return new LoginClient(source);
+        }
+
+        @Override
+        public LoginClient[] newArray(int size) {
+            return new LoginClient[size];
+        }
+    };
+}
diff --git a/facebook/src/com/facebook/login/LoginFragment.java b/facebook/src/com/facebook/login/LoginFragment.java
new file mode 100644
index 000000000..9b2244b28
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginFragment.java
@@ -0,0 +1,206 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.facebook.R;
+
+/**
+ * This Fragment is a necessary part of the overall Facebook login process
+ * but is not meant to be used directly.
+ *
+ * @see com.facebook.FacebookActivity
+ */
+
+public class LoginFragment extends Fragment {
+    static final String RESULT_KEY = "com.facebook.LoginFragment:Result";
+
+    private static final String TAG = "LoginFragment";
+    private static final String NULL_CALLING_PKG_ERROR_MSG =
+            "Cannot call LoginFragment with a null calling package. " +
+                    "This can occur if the launchMode of the caller is singleInstance.";
+    private static final String EXTRA_REQUEST = "request";
+    private static final String SAVED_LOGIN_CLIENT = "loginClient";
+
+    private String callingPackage;
+    private LoginClient loginClient;
+    private LoginClient.Request request;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (savedInstanceState != null) {
+            loginClient = savedInstanceState.getParcelable(SAVED_LOGIN_CLIENT);
+            loginClient.setFragment(this);
+        } else {
+            loginClient = new LoginClient(this);
+        }
+
+        loginClient.setOnCompletedListener(new LoginClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(LoginClient.Result outcome) {
+                onLoginClientCompleted(outcome);
+            }
+        });
+
+        Activity activity = getActivity();
+        if (activity == null) {
+            return;
+        }
+
+        initializeCallingPackage(activity);
+        if (activity.getIntent() != null) {
+            request = (LoginClient.Request)
+                    activity.getIntent().getParcelableExtra(EXTRA_REQUEST);
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        loginClient.cancelCurrentHandler();
+        super.onDestroy();
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        // If the back button has been pressed during a login we should still send a cancel result
+        if (loginClient.getInProgress()) {
+            LoginClient.Result outcome = LoginClient.Result.createCancelResult(
+                    request,
+                    "Operation canceled");
+
+            Bundle bundle = new Bundle();
+            bundle.putParcelable(RESULT_KEY, outcome);
+
+            Intent resultIntent = new Intent();
+            resultIntent.putExtras(bundle);
+
+            getActivity().setResult(Activity.RESULT_CANCELED, resultIntent);
+            getActivity().finish();
+        }
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
+                             @Nullable Bundle savedInstanceState) {
+        final View view = inflater.inflate(R.layout.com_facebook_login_fragment, container, false);
+
+        loginClient.setBackgroundProcessingListener(
+                new LoginClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+                view.findViewById(
+                        R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
+            }
+
+            @Override
+            public void onBackgroundProcessingStopped() {
+                view.findViewById(
+                        R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+            }
+        });
+
+        return view;
+    }
+
+    private void onLoginClientCompleted(LoginClient.Result outcome) {
+        request = null;
+
+        int resultCode = (outcome.code == LoginClient.Result.Code.CANCEL) ?
+                Activity.RESULT_CANCELED : Activity.RESULT_OK;
+
+        Bundle bundle = new Bundle();
+        bundle.putParcelable(RESULT_KEY, outcome);
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtras(bundle);
+
+        // The activity might be detached we will send a cancel result in onDetach
+        if (isAdded()) {
+            getActivity().setResult(resultCode, resultIntent);
+            getActivity().finish();
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        // If the calling package is null, this generally means that the callee was started
+        // with a launchMode of singleInstance. Unfortunately, Android does not allow a result
+        // to be set when the callee is a singleInstance, so we log an error and return.
+        if (callingPackage == null) {
+            Log.e(TAG, NULL_CALLING_PKG_ERROR_MSG);
+            getActivity().finish();
+            return;
+        }
+
+        loginClient.startOrContinueAuth(request);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        getActivity().findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(
+                View.GONE);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        loginClient.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putParcelable(SAVED_LOGIN_CLIENT, loginClient);
+    }
+
+    private void initializeCallingPackage(final Activity activity) {
+        ComponentName componentName = activity.getCallingActivity();
+        if (componentName == null) {
+            return;
+        }
+        callingPackage = componentName.getPackageName();
+    }
+
+    static Bundle populateIntentExtras(LoginClient.Request request) {
+        Bundle extras = new Bundle();
+        extras.putParcelable(EXTRA_REQUEST, request);
+        return extras;
+    }
+}
diff --git a/facebook/src/com/facebook/login/LoginLogger.java b/facebook/src/com/facebook/login/LoginLogger.java
new file mode 100644
index 000000000..65e43ce80
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginLogger.java
@@ -0,0 +1,186 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.text.TextUtils;
+
+import com.facebook.appevents.AppEventsLogger;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Map;
+
+class LoginLogger {
+    // Constants for logging login-related data.
+    static final String EVENT_NAME_LOGIN_METHOD_START = "fb_mobile_login_method_start";
+    static final String EVENT_NAME_LOGIN_METHOD_COMPLETE = "fb_mobile_login_method_complete";
+    static final String EVENT_PARAM_METHOD_RESULT_SKIPPED = "skipped";
+    static final String EVENT_NAME_LOGIN_START = "fb_mobile_login_start";
+    static final String EVENT_NAME_LOGIN_COMPLETE = "fb_mobile_login_complete";
+    // Note: to ensure stability of column mappings across the four different event types, we
+    // prepend a column index to each name, and we log all columns with all events, even if they are
+    // empty.
+    static final String EVENT_PARAM_AUTH_LOGGER_ID = "0_auth_logger_id";
+    static final String EVENT_PARAM_TIMESTAMP = "1_timestamp_ms";
+    static final String EVENT_PARAM_LOGIN_RESULT = "2_result";
+    static final String EVENT_PARAM_METHOD = "3_method";
+    static final String EVENT_PARAM_ERROR_CODE = "4_error_code";
+    static final String EVENT_PARAM_ERROR_MESSAGE = "5_error_message";
+    static final String EVENT_PARAM_EXTRAS = "6_extras";
+    static final String EVENT_EXTRAS_TRY_LOGIN_ACTIVITY = "try_login_activity";
+    static final String EVENT_EXTRAS_MISSING_INTERNET_PERMISSION = "no_internet_permission";
+    static final String EVENT_EXTRAS_NOT_TRIED = "not_tried";
+    static final String EVENT_EXTRAS_NEW_PERMISSIONS = "new_permissions";
+    static final String EVENT_EXTRAS_LOGIN_BEHAVIOR = "login_behavior";
+    static final String EVENT_EXTRAS_REQUEST_CODE = "request_code";
+    static final String EVENT_EXTRAS_PERMISSIONS = "permissions";
+    static final String EVENT_EXTRAS_DEFAULT_AUDIENCE = "default_audience";
+    static final String EVENT_EXTRAS_IS_REAUTHORIZE = "isReauthorize";
+
+    private final AppEventsLogger appEventsLogger;
+    private String applicationId;
+
+    LoginLogger(Context context, String applicationId) {
+        this.applicationId = applicationId;
+
+        appEventsLogger = AppEventsLogger.newLogger(context, applicationId);
+    }
+
+    public String getApplicationId() {
+        return applicationId;
+    }
+
+    static Bundle newAuthorizationLoggingBundle(String authLoggerId) {
+        // We want to log all parameters for all events, to ensure stability of columns across
+        // different event types.
+        Bundle bundle = new Bundle();
+        bundle.putLong(EVENT_PARAM_TIMESTAMP, System.currentTimeMillis());
+        bundle.putString(EVENT_PARAM_AUTH_LOGGER_ID, authLoggerId);
+        bundle.putString(EVENT_PARAM_METHOD, "");
+        bundle.putString(EVENT_PARAM_LOGIN_RESULT, "");
+        bundle.putString(EVENT_PARAM_ERROR_MESSAGE, "");
+        bundle.putString(EVENT_PARAM_ERROR_CODE, "");
+        bundle.putString(EVENT_PARAM_EXTRAS, "");
+        return bundle;
+    }
+
+    public void logStartLogin(LoginClient.Request pendingLoginRequest) {
+        Bundle bundle = newAuthorizationLoggingBundle(pendingLoginRequest.getAuthId());
+
+        // Log what we already know about the call in start event
+        try {
+            JSONObject extras = new JSONObject();
+            extras.put(EVENT_EXTRAS_LOGIN_BEHAVIOR,
+                    pendingLoginRequest.getLoginBehavior().toString());
+            extras.put(EVENT_EXTRAS_REQUEST_CODE, LoginClient.getLoginRequestCode());
+            extras.put(EVENT_EXTRAS_PERMISSIONS,
+                    TextUtils.join(",", pendingLoginRequest.getPermissions()));
+            extras.put(EVENT_EXTRAS_DEFAULT_AUDIENCE,
+                    pendingLoginRequest.getDefaultAudience().toString());
+            extras.put(EVENT_EXTRAS_IS_REAUTHORIZE, pendingLoginRequest.isRerequest());
+            bundle.putString(EVENT_PARAM_EXTRAS, extras.toString());
+        } catch (JSONException e) {
+        }
+
+        appEventsLogger.logSdkEvent(EVENT_NAME_LOGIN_START, null, bundle);
+    }
+
+    public void logCompleteLogin(String loginRequestId, Map<String, String> loggingExtras,
+        LoginClient.Result.Code result, Map<String, String> resultExtras, Exception exception) {
+
+        Bundle bundle = newAuthorizationLoggingBundle(loginRequestId);
+        if (result != null) {
+            bundle.putString(EVENT_PARAM_LOGIN_RESULT, result.getLoggingValue());
+        }
+        if (exception != null && exception.getMessage() != null) {
+            bundle.putString(EVENT_PARAM_ERROR_MESSAGE, exception.getMessage());
+        }
+
+        // Combine extras from the request and from the result.
+        JSONObject jsonObject = null;
+        if (loggingExtras.isEmpty() == false) {
+            jsonObject = new JSONObject(loggingExtras);
+        }
+        if (resultExtras != null) {
+            if (jsonObject == null) {
+                jsonObject = new JSONObject();
+            }
+            try {
+                for (Map.Entry<String, String> entry : resultExtras.entrySet()) {
+                    jsonObject.put(entry.getKey(), entry.getValue());
+                }
+            } catch (JSONException e) {
+            }
+        }
+        if (jsonObject != null) {
+            bundle.putString(EVENT_PARAM_EXTRAS, jsonObject.toString());
+        }
+
+        appEventsLogger.logSdkEvent(EVENT_NAME_LOGIN_COMPLETE, null, bundle);
+    }
+
+    public void logAuthorizationMethodStart(String authId, String method) {
+        Bundle bundle = LoginLogger.newAuthorizationLoggingBundle(authId);
+        bundle.putString(EVENT_PARAM_METHOD, method);
+
+        appEventsLogger.logSdkEvent(EVENT_NAME_LOGIN_METHOD_START, null, bundle);
+    }
+
+    public void logAuthorizationMethodComplete(String authId, String method, String result,
+        String errorMessage, String errorCode, Map<String, String> loggingExtras) {
+
+        Bundle bundle;
+        bundle = LoginLogger.newAuthorizationLoggingBundle(authId);
+        if (result != null) {
+            bundle.putString(LoginLogger.EVENT_PARAM_LOGIN_RESULT, result);
+        }
+        if (errorMessage != null) {
+            bundle.putString(LoginLogger.EVENT_PARAM_ERROR_MESSAGE, errorMessage);
+        }
+        if (errorCode != null) {
+            bundle.putString(LoginLogger.EVENT_PARAM_ERROR_CODE, errorCode);
+        }
+        if (loggingExtras != null && !loggingExtras.isEmpty()) {
+            JSONObject jsonObject = new JSONObject(loggingExtras);
+            bundle.putString(LoginLogger.EVENT_PARAM_EXTRAS, jsonObject.toString());
+        }
+        bundle.putString(EVENT_PARAM_METHOD, method);
+
+        appEventsLogger.logSdkEvent(EVENT_NAME_LOGIN_METHOD_COMPLETE, null, bundle);
+    }
+
+    public void logUnexpectedError(String eventName, String errorMessage) {
+        logUnexpectedError(eventName, errorMessage, "");
+    }
+
+    public void logUnexpectedError(String eventName, String errorMessage, String method) {
+        Bundle bundle = newAuthorizationLoggingBundle("");
+        bundle.putString(EVENT_PARAM_LOGIN_RESULT,
+                LoginClient.Result.Code.ERROR.getLoggingValue());
+        bundle.putString(EVENT_PARAM_ERROR_MESSAGE, errorMessage);
+        bundle.putString(EVENT_PARAM_METHOD, method);
+
+        appEventsLogger.logSdkEvent(eventName, null, bundle);
+    }
+}
diff --git a/facebook/src/com/facebook/login/LoginManager.java b/facebook/src/com/facebook/login/LoginManager.java
new file mode 100644
index 000000000..fb1eb2266
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginManager.java
@@ -0,0 +1,551 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.content.Context;
+
+import com.facebook.AccessToken;
+import com.facebook.CallbackManager;
+import com.facebook.FacebookActivity;
+import com.facebook.FacebookAuthorizationException;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphResponse;
+import com.facebook.Profile;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.Validate;
+import com.facebook.appevents.AppEventsConstants;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ * This class manages login and permissions for Facebook.
+ */
+public class LoginManager {
+    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
+    private static final String MANAGE_PERMISSION_PREFIX = "manage";
+    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = getOtherPublishPermissions();
+
+    private static volatile LoginManager instance;
+
+    private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;
+    private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
+    private LoginClient.Request pendingLoginRequest;
+    private HashMap<String, String> pendingLoggingExtras;
+    private Context context;
+    private LoginLogger loginLogger;
+
+    LoginManager() {
+        Validate.sdkInitialized();
+    }
+
+    /**
+     * Getter for the login manager.
+     * @return The login manager.
+     */
+    public static LoginManager getInstance() {
+        if (instance == null) {
+            synchronized (LoginManager.class) {
+                if (instance == null) {
+                    instance = new LoginManager();
+                }
+            }
+        }
+
+        return instance;
+    }
+
+    /**
+     * Starts the login process to resolve the error defined in the response. The registered login
+     * callbacks will be called on completion.
+     *
+     * @param activity The activity which is starting the login process.
+     * @param response The response that has the error.
+     */
+    public void resolveError(final Activity activity, final GraphResponse response) {
+        startLogin(
+                new ActivityStartActivityDelegate(activity),
+                createLoginRequestFromResponse(response)
+        );
+    }
+
+    /**
+     * Starts the login process to resolve the error defined in the response. The registered login
+     * callbacks will be called on completion.
+     *
+     * @param fragment The fragment which is starting the login process.
+     * @param response The response that has the error.
+     */
+    public void resolveError(final Fragment fragment, final GraphResponse response) {
+        startLogin(
+                new FragmentStartActivityDelegate(fragment),
+                createLoginRequestFromResponse(response)
+        );
+    }
+
+    private LoginClient.Request createLoginRequestFromResponse(final GraphResponse response) {
+        Validate.notNull(response, "response");
+        AccessToken failedToken = response.getRequest().getAccessToken();
+        return createLoginRequest(failedToken != null ? failedToken.getPermissions() : null);
+    }
+
+    /**
+     * Registers a login callback to the given callback manager.
+     * @param callbackManager The callback manager that will encapsulate the callback.
+     * @param callback The login callback that will be called on login completion.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<LoginResult> callback) {
+        if (!(callbackManager instanceof CallbackManagerImpl)) {
+            throw new FacebookException("Unexpected CallbackManager, " +
+                    "please use the provided Factory.");
+        }
+        ((CallbackManagerImpl) callbackManager).registerCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return LoginManager.this.onActivityResult(
+                                resultCode,
+                                data,
+                                callback);
+                    }
+                }
+        );
+    }
+
+    boolean onActivityResult(int resultCode, Intent data) {
+        return onActivityResult(resultCode, data, null);
+    }
+
+    boolean onActivityResult(int resultCode, Intent data, FacebookCallback<LoginResult>  callback) {
+
+        if (pendingLoginRequest == null) {
+            return false;
+        }
+
+        FacebookException exception = null;
+        AccessToken newToken = null;
+        LoginClient.Result.Code code = LoginClient.Result.Code.ERROR;
+        Map<String, String> loggingExtras = null;
+
+        boolean isCanceled = false;
+        if (data != null) {
+            LoginClient.Result result = (LoginClient.Result)
+                    data.getParcelableExtra(LoginFragment.RESULT_KEY);
+            if (result != null) {
+                code = result.code;
+                if (resultCode == Activity.RESULT_OK) {
+                    if (result.code == LoginClient.Result.Code.SUCCESS) {
+                        newToken = result.token;
+                    } else {
+                        exception = new FacebookAuthorizationException(result.errorMessage);
+                    }
+                } else if (resultCode == Activity.RESULT_CANCELED) {
+                    isCanceled = true;
+                }
+                loggingExtras = result.loggingExtras;
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            isCanceled = true;
+            code = LoginClient.Result.Code.CANCEL;
+        }
+
+        if (exception == null && newToken == null && !isCanceled) {
+            exception = new FacebookException("Unexpected call to LoginManager.onActivityResult");
+        }
+
+        logCompleteLogin(code, loggingExtras, exception);
+
+        finishLogin(newToken, exception, isCanceled, callback);
+
+        return true;
+    }
+
+    /**
+     * Getter for the login behavior.
+     * @return the login behavior.
+     */
+    public LoginBehavior getLoginBehavior() {
+        return loginBehavior;
+    }
+
+    /**
+     * Setter for the login behavior.
+     * @param loginBehavior The login behavior.
+     * @return The login manager.
+     */
+    public LoginManager setLoginBehavior(LoginBehavior loginBehavior) {
+        this.loginBehavior = loginBehavior;
+        return this;
+    }
+
+    /**
+     * Getter for the default audience.
+     * @return The default audience.
+     */
+    public DefaultAudience getDefaultAudience() {
+        return defaultAudience;
+    }
+
+    /**
+     * Setter for the default audience.
+     * @param defaultAudience The default audience.
+     * @return The login manager.
+     */
+    public LoginManager setDefaultAudience(DefaultAudience defaultAudience) {
+        this.defaultAudience = defaultAudience;
+        return this;
+    }
+
+    /**
+     * Logs out the user.
+     */
+    public void logOut() {
+        AccessToken.setCurrentAccessToken(null);
+        Profile.setCurrentProfile(null);
+    }
+
+    /**
+     * Logs the user in with the requested read permissions.
+     * @param fragment    The fragment which is starting the login process.
+     * @param permissions The requested permissions.
+     */
+    public void logInWithReadPermissions(Fragment fragment, Collection<String> permissions) {
+        validateReadPermissions(permissions);
+
+        LoginClient.Request loginRequest = createLoginRequest(permissions);
+        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
+    }
+
+    /**
+     * Logs the user in with the requested read permissions.
+     * @param activity    The activity which is starting the login process.
+     * @param permissions The requested permissions.
+     */
+    public void logInWithReadPermissions(Activity activity, Collection<String> permissions) {
+        validateReadPermissions(permissions);
+
+        LoginClient.Request loginRequest = createLoginRequest(permissions);
+        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
+    }
+
+    /**
+     * Logs the user in with the requested publish permissions.
+     * @param fragment    The fragment which is starting the login process.
+     * @param permissions The requested permissions.
+     */
+    public void logInWithPublishPermissions(Fragment fragment, Collection<String> permissions) {
+        validatePublishPermissions(permissions);
+
+        LoginClient.Request loginRequest = createLoginRequest(permissions);
+        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
+    }
+
+    /**
+     * Logs the user in with the requested publish permissions.
+     * @param activity    The activity which is starting the login process.
+     * @param permissions The requested permissions.
+     */
+    public void logInWithPublishPermissions(Activity activity, Collection<String> permissions) {
+        validatePublishPermissions(permissions);
+
+        LoginClient.Request loginRequest = createLoginRequest(permissions);
+        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
+    }
+
+    LoginClient.Request getPendingLoginRequest() {
+        return pendingLoginRequest;
+    }
+
+    private void validateReadPermissions(Collection<String> permissions) {
+        if (permissions == null) {
+            return;
+        }
+        for (String permission : permissions) {
+            if (isPublishPermission(permission)) {
+                throw new FacebookException(
+                    String.format(
+                        "Cannot pass a publish or manage permission (%s) to a request for read " +
+                                "authorization",
+                        permission));
+            }
+        }
+    }
+
+    private void validatePublishPermissions(Collection<String> permissions) {
+        if (permissions == null) {
+            return;
+        }
+        for (String permission : permissions) {
+            if (!isPublishPermission(permission)) {
+                throw new FacebookException(
+                    String.format(
+                        "Cannot pass a read permission (%s) to a request for publish authorization",
+                        permission));
+            }
+        }
+    }
+
+    static boolean isPublishPermission(String permission) {
+        return permission != null &&
+            (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
+                permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
+                OTHER_PUBLISH_PERMISSIONS.contains(permission));
+    }
+
+    private static Set<String> getOtherPublishPermissions() {
+        HashSet<String> set = new HashSet<String>() {{
+            add("ads_management");
+            add("create_event");
+            add("rsvp_event");
+        }};
+        return Collections.unmodifiableSet(set);
+    }
+
+    private LoginClient.Request createLoginRequest(Collection<String> permissions) {
+        LoginClient.Request request = new LoginClient.Request(
+                loginBehavior,
+                Collections.unmodifiableSet(
+                        permissions != null ? new HashSet(permissions) : new HashSet<String>()),
+                defaultAudience,
+                FacebookSdk.getApplicationId(),
+                UUID.randomUUID().toString()
+        );
+        request.setRerequest(AccessToken.getCurrentAccessToken() != null);
+        return request;
+    }
+
+    private void startLogin(
+            StartActivityDelegate startActivityDelegate,
+            LoginClient.Request request
+    ) throws FacebookException {
+
+        this.pendingLoginRequest = request;
+        this.pendingLoggingExtras = new HashMap<>();
+        this.context = startActivityDelegate.getActivityContext();
+
+        logStartLogin();
+
+        // Make sure the static handler for login is registered if there isn't an explicit callback
+        CallbackManagerImpl.registerStaticCallback(
+                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return LoginManager.this.onActivityResult(resultCode, data);
+                    }
+                }
+        );
+
+        boolean started = tryFacebookActivity(startActivityDelegate, request);
+
+        pendingLoggingExtras.put(
+                LoginLogger.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
+                started ?
+                AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO
+        );
+
+        if (!started) {
+            FacebookException exception = new FacebookException(
+                    "Log in attempt failed: FacebookActivity could not be started." +
+                            " Please make sure you added FacebookActivity to the AndroidManifest.");
+            logCompleteLogin(LoginClient.Result.Code.ERROR, null, exception);
+            this.pendingLoginRequest = null;
+            throw exception;
+        }
+    }
+
+    private LoginLogger getLogger() {
+        if (loginLogger == null ||
+                !loginLogger.getApplicationId().equals(
+                        pendingLoginRequest.getApplicationId())) {
+            loginLogger = new LoginLogger(
+                    context,
+                    pendingLoginRequest.getApplicationId());
+        }
+        return loginLogger;
+    }
+
+    private void logStartLogin() {
+        getLogger().logStartLogin(pendingLoginRequest);
+    }
+
+    private void logCompleteLogin(LoginClient.Result.Code result, Map<String, String> resultExtras,
+                                  Exception exception) {
+        if (pendingLoginRequest == null) {
+            // We don't expect this to happen, but if it does, log an event for diagnostic purposes.
+            getLogger().logUnexpectedError(
+                LoginLogger.EVENT_NAME_LOGIN_COMPLETE,
+                "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest."
+            );
+        } else {
+            getLogger().logCompleteLogin(
+                    pendingLoginRequest.getAuthId(),
+                    pendingLoggingExtras,
+                    result,
+                    resultExtras,
+                    exception);
+        }
+    }
+
+    private boolean tryFacebookActivity(
+            StartActivityDelegate startActivityDelegate,
+            LoginClient.Request request) {
+
+        Intent intent = getFacebookActivityIntent(request);
+
+        if (!resolveIntent(intent)) {
+            return false;
+        }
+
+        try {
+            startActivityDelegate.startActivityForResult(
+                    intent,
+                    LoginClient.getLoginRequestCode());
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean resolveIntent(Intent intent) {
+        ResolveInfo resolveInfo = FacebookSdk.getApplicationContext().getPackageManager()
+            .resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return false;
+        }
+        return true;
+    }
+
+    private Intent getFacebookActivityIntent(LoginClient.Request request) {
+        Intent intent = new Intent();
+        intent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
+        intent.setAction(request.getLoginBehavior().toString());
+
+        // Let FacebookActivity populate extras appropriately
+        LoginClient.Request authClientRequest = request;
+        Bundle extras = LoginFragment.populateIntentExtras(authClientRequest);
+        intent.putExtras(extras);
+
+        return intent;
+    }
+
+    static LoginResult computeLoginResult(
+            final LoginClient.Request request,
+            final AccessToken newToken
+    ) {
+        Set<String> requestedPermissions = request.getPermissions();
+        Set<String> grantedPermissions = new HashSet<String>(newToken.getPermissions());
+
+        // If it's a reauth, subset the granted permissions to just the requested permissions
+        // so we don't report implicit permissions like user_profile as recently granted.
+        if (request.isRerequest()) {
+            grantedPermissions.retainAll(requestedPermissions);
+        }
+
+        Set<String> deniedPermissions = new HashSet<String>(requestedPermissions);
+        deniedPermissions.removeAll(grantedPermissions);
+        return new LoginResult(newToken, grantedPermissions, deniedPermissions);
+    }
+
+    private void finishLogin(
+            AccessToken newToken,
+            FacebookException exception,
+            boolean isCanceled,
+            FacebookCallback<LoginResult>  callback) {
+        if (newToken != null) {
+            AccessToken.setCurrentAccessToken(newToken);
+            Profile.fetchProfileForCurrentAccessToken();
+        }
+
+        if (callback != null) {
+            LoginResult loginResult = newToken != null
+                    ? computeLoginResult(pendingLoginRequest, newToken)
+                    : null;
+            // If there are no granted permissions, the operation is treated as cancel.
+            if (isCanceled
+                    || (loginResult != null
+                           && loginResult.getRecentlyGrantedPermissions().size() == 0)) {
+                callback.onCancel();
+                return;
+            }
+            if (exception != null) {
+                callback.onError(exception);
+            } else if (newToken != null) {
+                callback.onSuccess(loginResult);
+            }
+        }
+    }
+
+    private static class ActivityStartActivityDelegate implements StartActivityDelegate {
+        private final Activity activity;
+
+        ActivityStartActivityDelegate(final Activity activity) {
+            Validate.notNull(activity, "activity");
+            this.activity = activity;
+        }
+
+        @Override
+        public void startActivityForResult(Intent intent, int requestCode) {
+            activity.startActivityForResult(intent, requestCode);
+        }
+
+        @Override
+        public Activity getActivityContext() {
+            return activity;
+        }
+    }
+
+    private static class FragmentStartActivityDelegate implements StartActivityDelegate {
+        private final Fragment fragment;
+
+        FragmentStartActivityDelegate(final Fragment fragment) {
+            Validate.notNull(fragment, "fragment");
+            this.fragment = fragment;
+        }
+
+        @Override
+        public void startActivityForResult(Intent intent, int requestCode) {
+            fragment.startActivityForResult(intent, requestCode);
+        }
+
+        @Override
+        public Activity getActivityContext() {
+            return fragment.getActivity();
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/login/LoginMethodHandler.java b/facebook/src/com/facebook/login/LoginMethodHandler.java
new file mode 100644
index 000000000..4412561b9
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginMethodHandler.java
@@ -0,0 +1,198 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Base64;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.FacebookAuthorizationException;
+import com.facebook.FacebookException;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+abstract class LoginMethodHandler implements Parcelable {
+    Map<String, String> methodLoggingExtras;
+    protected LoginClient loginClient;
+
+    LoginMethodHandler(LoginClient loginClient) {
+        this.loginClient = loginClient;
+    }
+
+    LoginMethodHandler(Parcel source) {
+        methodLoggingExtras = Utility.readStringMapFromParcel(source);
+    }
+
+    // This should only be used if restoring from a Parcel
+    void setLoginClient(LoginClient loginClient) {
+        if (this.loginClient != null) {
+            throw new FacebookException("Can't set LoginClient if it is already set.");
+        }
+        this.loginClient = loginClient;
+    }
+
+    abstract boolean tryAuthorize(LoginClient.Request request);
+
+    abstract String getNameForLogging();
+
+    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        return false;
+    }
+
+    boolean needsInternetPermission() {
+        return false;
+    }
+
+    void cancel() {
+    }
+
+    protected void addLoggingExtra(String key, Object value) {
+        if (methodLoggingExtras == null) {
+            methodLoggingExtras = new HashMap<String, String>();
+        }
+        methodLoggingExtras.put(key, value == null ? null : value.toString());
+    }
+
+    protected void logWebLoginCompleted(String e2e) {
+        String applicationId = loginClient.getPendingRequest().getApplicationId();
+        AppEventsLogger appEventsLogger =
+                AppEventsLogger.newLogger(loginClient.getActivity(), applicationId);
+
+        Bundle parameters = new Bundle();
+        parameters.putString(AnalyticsEvents.PARAMETER_WEB_LOGIN_E2E, e2e);
+        parameters.putLong(
+                AnalyticsEvents.PARAMETER_WEB_LOGIN_SWITCHBACK_TIME, System.currentTimeMillis());
+        parameters.putString(AnalyticsEvents.PARAMETER_APP_ID, applicationId);
+
+        appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_WEB_LOGIN_COMPLETE, null, parameters);
+    }
+
+    static AccessToken createAccessTokenFromNativeLogin(
+            Bundle bundle,
+            AccessTokenSource source,
+            String applicationId) {
+        Date expires = Utility.getBundleLongAsDate(
+                bundle, NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date(0));
+        ArrayList<String> permissions = bundle.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+        String token = bundle.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+
+        if (Utility.isNullOrEmpty(token)) {
+            return null;
+        }
+
+        String userId = bundle.getString(NativeProtocol.EXTRA_USER_ID);
+
+        return new AccessToken(
+                token,
+                applicationId,
+                userId,
+                permissions,
+                null,
+                source,
+                expires,
+                new Date());
+    }
+
+    public static AccessToken createAccessTokenFromWebBundle(
+            Collection<String> requestedPermissions,
+            Bundle bundle,
+            AccessTokenSource source,
+            String applicationId) throws FacebookException {
+        Date expires = Utility.getBundleLongAsDate(bundle, AccessToken.EXPIRES_IN_KEY, new Date());
+        String token = bundle.getString(AccessToken.ACCESS_TOKEN_KEY);
+
+        // With Login v4, we now get back the actual permissions granted, so update the permissions
+        // to be the real thing
+        String grantedPermissions = bundle.getString("granted_scopes");
+        if (!Utility.isNullOrEmpty(grantedPermissions)) {
+            requestedPermissions = new ArrayList<String>(
+                    Arrays.asList(grantedPermissions.split(",")));
+        }
+        String deniedPermissions = bundle.getString("denied_scopes");
+        List<String> declinedPermissions = null;
+        if (!Utility.isNullOrEmpty(deniedPermissions)) {
+            declinedPermissions = new ArrayList<String>(
+                    Arrays.asList(deniedPermissions.split(",")));
+        }
+
+        if (Utility.isNullOrEmpty(token)) {
+            return null;
+        }
+
+        String signed_request = bundle.getString("signed_request");
+        String userId = getUserIDFromSignedRequest(signed_request);
+
+        return new AccessToken(
+                token,
+                applicationId,
+                userId,
+                requestedPermissions,
+                declinedPermissions,
+                source,
+                expires,
+                new Date());
+    }
+
+    private static String getUserIDFromSignedRequest(
+            String signedRequest) throws FacebookException {
+        if (signedRequest == null || signedRequest.isEmpty()) {
+            throw new FacebookException(
+                    "Authorization response does not contain the signed_request");
+        }
+
+        try {
+            String[] signatureAndPayload = signedRequest.split("\\.");
+            if (signatureAndPayload.length == 2) {
+                byte[] data = Base64.decode(signatureAndPayload[1], Base64.DEFAULT);
+                String dataStr = new String(data, "UTF-8");
+                JSONObject jsonObject = new JSONObject(dataStr);
+                return jsonObject.getString("user_id");
+            }
+        } catch (UnsupportedEncodingException ex) {
+        } catch (JSONException ex) {
+        }
+        throw new FacebookException("Failed to retrieve user_id from signed_request");
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        Utility.writeStringMapToParcel(dest, methodLoggingExtras);
+    }
+}
diff --git a/facebook/src/com/facebook/login/LoginResult.java b/facebook/src/com/facebook/login/LoginResult.java
new file mode 100644
index 000000000..1fe643122
--- /dev/null
+++ b/facebook/src/com/facebook/login/LoginResult.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import com.facebook.AccessToken;
+
+import java.util.Set;
+
+/**
+ * This class shows the results of a login operation.
+ */
+public class LoginResult {
+    private final AccessToken accessToken;
+    private final Set<String> recentlyGrantedPermissions;
+    private final Set<String> recentlyDeniedPermissions;
+
+    /**
+     * The constructor.
+     *
+     * @param accessToken                The new access token.
+     * @param recentlyGrantedPermissions The recently granted permissions.
+     * @param recentlyDeniedPermissions  The recently denied permissions.
+     */
+    public LoginResult(
+            AccessToken accessToken,
+            Set<String> recentlyGrantedPermissions,
+            Set<String> recentlyDeniedPermissions) {
+        this.accessToken = accessToken;
+        this.recentlyGrantedPermissions = recentlyGrantedPermissions;
+        this.recentlyDeniedPermissions = recentlyDeniedPermissions;
+    }
+
+    /**
+     * Getter for the new access token.
+     * @return the new access token.
+     */
+    public AccessToken getAccessToken() {
+        return accessToken;
+    }
+
+    /**
+     * Getter for the recently granted permissions.
+     * @return the recently granted permissions.
+     */
+    public Set<String> getRecentlyGrantedPermissions() {
+        return recentlyGrantedPermissions;
+    }
+
+    /**
+     * Getter for the recently denied permissions.
+     * @return the recently denied permissions.
+     */
+    public Set<String> getRecentlyDeniedPermissions() {
+        return recentlyDeniedPermissions;
+    }
+}
diff --git a/facebook/src/com/facebook/login/StartActivityDelegate.java b/facebook/src/com/facebook/login/StartActivityDelegate.java
new file mode 100644
index 000000000..d30461be3
--- /dev/null
+++ b/facebook/src/com/facebook/login/StartActivityDelegate.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.app.Activity;
+import android.content.Intent;
+
+interface StartActivityDelegate {
+    public void startActivityForResult(Intent intent, int requestCode);
+
+    public Activity getActivityContext();
+}
diff --git a/facebook/src/com/facebook/login/WebViewLoginMethodHandler.java b/facebook/src/com/facebook/login/WebViewLoginMethodHandler.java
new file mode 100644
index 000000000..bb323602f
--- /dev/null
+++ b/facebook/src/com/facebook/login/WebViewLoginMethodHandler.java
@@ -0,0 +1,289 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.app.FragmentActivity;
+import android.text.TextUtils;
+import android.webkit.CookieSyncManager;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenSource;
+import com.facebook.appevents.AppEventsConstants;
+import com.facebook.internal.FacebookDialogFragment;
+import com.facebook.FacebookException;
+import com.facebook.FacebookOperationCanceledException;
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookServiceException;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.WebDialog;
+
+import java.util.Locale;
+
+class WebViewLoginMethodHandler extends LoginMethodHandler {
+    private static final String WEB_VIEW_AUTH_HANDLER_STORE =
+            "com.facebook.login.AuthorizationClient.WebViewAuthHandler.TOKEN_STORE_KEY";
+    private static final String WEB_VIEW_AUTH_HANDLER_TOKEN_KEY = "TOKEN";
+
+    private WebDialog loginDialog;
+    private String e2e;
+
+    WebViewLoginMethodHandler(LoginClient loginClient) {
+        super(loginClient);
+    }
+
+    @Override
+    String getNameForLogging() {
+        return "web_view";
+    }
+
+    @Override
+    boolean needsInternetPermission() {
+        return true;
+    }
+
+    @Override
+    void cancel() {
+        if (loginDialog != null) {
+            loginDialog.cancel();
+            loginDialog = null;
+        }
+    }
+
+    @Override
+    boolean tryAuthorize(final LoginClient.Request request) {
+        Bundle parameters = new Bundle();
+        if (!Utility.isNullOrEmpty(request.getPermissions())) {
+            String scope = TextUtils.join(",", request.getPermissions());
+            parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
+            addLoggingExtra(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
+        }
+
+        DefaultAudience audience = request.getDefaultAudience();
+        parameters.putString(
+                ServerProtocol.DIALOG_PARAM_DEFAULT_AUDIENCE, audience.getNativeProtocolAudience());
+
+        AccessToken previousToken = AccessToken.getCurrentAccessToken();
+        String previousTokenString = previousToken != null ? previousToken.getToken() : null;
+        if (previousTokenString != null
+                && (previousTokenString.equals(loadCookieToken()))) {
+            parameters.putString(
+                    ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN,
+                    previousTokenString);
+            // Don't log the actual access token, just its presence or absence.
+            addLoggingExtra(
+                    ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN,
+                    AppEventsConstants.EVENT_PARAM_VALUE_YES);
+        } else {
+            // The call to clear cookies will create the first instance of CookieSyncManager if
+            // necessary
+            Utility.clearFacebookCookies(loginClient.getActivity());
+            addLoggingExtra(
+                    ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN,
+                    AppEventsConstants.EVENT_PARAM_VALUE_NO);
+        }
+
+        WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
+            @Override
+            public void onComplete(Bundle values, FacebookException error) {
+                onWebDialogComplete(request, values, error);
+            }
+        };
+
+        e2e = LoginClient.getE2E();
+        addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);
+
+        FragmentActivity fragmentActivity = loginClient.getActivity();
+        WebDialog.Builder builder = new AuthDialogBuilder(
+                fragmentActivity,
+                request.getApplicationId(),
+                parameters)
+                .setE2E(e2e)
+                .setIsRerequest(request.isRerequest())
+                .setOnCompleteListener(listener);
+        loginDialog = builder.build();
+
+        FacebookDialogFragment dialogFragment = new FacebookDialogFragment();
+        dialogFragment.setRetainInstance(true);
+        dialogFragment.setDialog(loginDialog);
+        dialogFragment.show(fragmentActivity.getSupportFragmentManager(),
+                FacebookDialogFragment.TAG);
+
+        return true;
+    }
+
+    void onWebDialogComplete(LoginClient.Request request, Bundle values,
+            FacebookException error) {
+        LoginClient.Result outcome;
+        if (values != null) {
+            // Actual e2e we got from the dialog should be used for logging.
+            if (values.containsKey(ServerProtocol.DIALOG_PARAM_E2E)) {
+                e2e = values.getString(ServerProtocol.DIALOG_PARAM_E2E);
+            }
+
+            try {
+                AccessToken token = createAccessTokenFromWebBundle(
+                        request.getPermissions(),
+                        values,
+                        AccessTokenSource.WEB_VIEW,
+                        request.getApplicationId());
+                outcome = LoginClient.Result.createTokenResult(
+                        loginClient.getPendingRequest(),
+                        token);
+
+                // Ensure any cookies set by the dialog are saved
+                // This is to work around a bug where CookieManager may fail to instantiate if
+                // CookieSyncManager has never been created.
+                CookieSyncManager syncManager =
+                        CookieSyncManager.createInstance(loginClient.getActivity());
+                syncManager.sync();
+                saveCookieToken(token.getToken());
+            } catch (FacebookException ex) {
+                outcome = LoginClient.Result.createErrorResult(
+                        loginClient.getPendingRequest(),
+                        null,
+                        ex.getMessage());
+            }
+        } else {
+            if (error instanceof FacebookOperationCanceledException) {
+                outcome = LoginClient.Result.createCancelResult(loginClient.getPendingRequest(),
+                        "User canceled log in.");
+            } else {
+                // Something went wrong, don't log a completion event since it will skew timing
+                // results.
+                e2e = null;
+
+                String errorCode = null;
+                String errorMessage = error.getMessage();
+                if (error instanceof FacebookServiceException) {
+                    FacebookRequestError requestError =
+                            ((FacebookServiceException)error).getRequestError();
+                    errorCode = String.format(Locale.ROOT, "%d", requestError.getErrorCode());
+                    errorMessage = requestError.toString();
+                }
+                outcome = LoginClient.Result.createErrorResult(loginClient.getPendingRequest(),
+                        null, errorMessage, errorCode);
+            }
+        }
+
+        if (!Utility.isNullOrEmpty(e2e)) {
+            logWebLoginCompleted(e2e);
+        }
+
+        loginClient.completeAndValidate(outcome);
+    }
+
+    private void saveCookieToken(String token) {
+        Context context = loginClient.getActivity();
+        context.getSharedPreferences(
+                WEB_VIEW_AUTH_HANDLER_STORE,
+                Context.MODE_PRIVATE)
+            .edit()
+            .putString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, token)
+            .apply();
+    }
+
+    private String loadCookieToken() {
+        Context context = loginClient.getActivity();
+        SharedPreferences sharedPreferences = context.getSharedPreferences(
+                WEB_VIEW_AUTH_HANDLER_STORE,
+                Context.MODE_PRIVATE);
+        return sharedPreferences.getString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, "");
+    }
+
+    static class AuthDialogBuilder extends WebDialog.Builder {
+        private static final String OAUTH_DIALOG = "oauth";
+        static final String REDIRECT_URI = "fbconnect://success";
+        private String e2e;
+        private boolean isRerequest;
+
+        public AuthDialogBuilder(Context context, String applicationId, Bundle parameters) {
+            super(context, applicationId, OAUTH_DIALOG, parameters);
+        }
+
+        public AuthDialogBuilder setE2E(String e2e) {
+            this.e2e = e2e;
+            return this;
+        }
+
+        public AuthDialogBuilder setIsRerequest(boolean isRerequest) {
+            this.isRerequest = isRerequest;
+            return this;
+        }
+
+        @Override
+        public WebDialog build() {
+            Bundle parameters = getParameters();
+            parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getApplicationId());
+            parameters.putString(ServerProtocol.DIALOG_PARAM_E2E, e2e);
+            parameters.putString(
+                    ServerProtocol.DIALOG_PARAM_RESPONSE_TYPE,
+                    ServerProtocol.DIALOG_RESPONSE_TYPE_TOKEN_AND_SIGNED_REQUEST);
+            parameters.putString(
+                    ServerProtocol.DIALOG_PARAM_RETURN_SCOPES,
+                    ServerProtocol.DIALOG_RETURN_SCOPES_TRUE);
+
+            // Set the re-request auth type for requests
+            if (isRerequest) {
+                parameters.putString(
+                        ServerProtocol.DIALOG_PARAM_AUTH_TYPE,
+                        ServerProtocol.DIALOG_REREQUEST_AUTH_TYPE);
+            }
+
+            return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
+        }
+    }
+
+    WebViewLoginMethodHandler(Parcel source) {
+        super(source);
+        e2e = source.readString();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+        dest.writeString(e2e);
+    }
+
+    public static final Parcelable.Creator<WebViewLoginMethodHandler> CREATOR =
+            new Parcelable.Creator() {
+
+                @Override
+                public WebViewLoginMethodHandler createFromParcel(Parcel source) {
+                    return new WebViewLoginMethodHandler(source);
+                }
+
+                @Override
+                public WebViewLoginMethodHandler[] newArray(int size) {
+                    return new WebViewLoginMethodHandler[size];
+                }
+            };}
diff --git a/facebook/src/com/facebook/login/widget/LoginButton.java b/facebook/src/com/facebook/login/widget/LoginButton.java
new file mode 100644
index 000000000..d3b230551
--- /dev/null
+++ b/facebook/src/com/facebook/login/widget/LoginButton.java
@@ -0,0 +1,778 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login.widget;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.os.Bundle;
+import android.util.AttributeSet;
+import android.view.View;
+import com.facebook.*;
+import com.facebook.R;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.LoginAuthorizationType;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Utility.FetchedAppSettings;
+import com.facebook.login.DefaultAudience;
+import com.facebook.login.LoginBehavior;
+import com.facebook.login.LoginManager;
+import com.facebook.login.LoginResult;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A Log In/Log Out button that maintains login state and logs in/out for the app.
+ * <p/>
+ * This control requires the app ID to be specified in the AndroidManifest.xml.
+ */
+public class LoginButton extends FacebookButtonBase {
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode();
+
+    // ***
+    // Keep all the enum values in sync with attrs.xml
+    // ***
+
+    /**
+     * The display modes for the login button tool tip.
+     */
+    public static enum ToolTipMode {
+        /**
+         * Default display mode. A server query will determine if the tool tip should be displayed
+         * and, if so, what the string shown to the user should be.
+         */
+        AUTOMATIC("automatic", 0),
+
+        /**
+         * Display the tool tip with a local string--regardless of what the server returns
+         */
+        DISPLAY_ALWAYS("display_always", 1),
+
+        /**
+         * Never display the tool tip--regardless of what the server says
+         */
+        NEVER_DISPLAY("never_display", 2);
+
+        public static ToolTipMode DEFAULT = AUTOMATIC;
+
+        public static ToolTipMode fromInt(int enumValue) {
+            for (ToolTipMode mode : values()) {
+                if (mode.getValue() == enumValue) {
+                    return mode;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private ToolTipMode(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        public int getValue() {
+            return intValue;
+        }
+    }
+
+    private static final String TAG = LoginButton.class.getName();
+    private boolean confirmLogout;
+    private String loginText;
+    private String logoutText;
+    private LoginButtonProperties properties = new LoginButtonProperties();
+    private String loginLogoutEventName = AnalyticsEvents.EVENT_LOGIN_VIEW_USAGE;
+    private boolean toolTipChecked;
+    private ToolTipPopup.Style toolTipStyle = ToolTipPopup.Style.BLUE;
+    private ToolTipMode toolTipMode;
+    private long toolTipDisplayTime = ToolTipPopup.DEFAULT_POPUP_DISPLAY_TIME;
+    private ToolTipPopup toolTipPopup;
+    private AccessTokenTracker accessTokenTracker;
+    private LoginManager loginManager;
+
+    static class LoginButtonProperties {
+        private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
+        private List<String> permissions = Collections.<String>emptyList();
+        private LoginAuthorizationType authorizationType = null;
+        private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;
+
+        public void setDefaultAudience(DefaultAudience defaultAudience) {
+            this.defaultAudience = defaultAudience;
+        }
+
+        public DefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        public void setReadPermissions(List<String> permissions) {
+
+            if (LoginAuthorizationType.PUBLISH.equals(authorizationType)) {
+                throw new UnsupportedOperationException("Cannot call setReadPermissions after " +
+                        "setPublishPermissions has been called.");
+            }
+            this.permissions = permissions;
+            authorizationType = LoginAuthorizationType.READ;
+        }
+
+        public void setPublishPermissions(List<String> permissions) {
+
+            if (LoginAuthorizationType.READ.equals(authorizationType)) {
+                throw new UnsupportedOperationException("Cannot call setPublishPermissions after " +
+                        "setReadPermissions has been called.");
+            }
+            if (Utility.isNullOrEmpty(permissions)) {
+                throw new IllegalArgumentException(
+                        "Permissions for publish actions cannot be null or empty.");
+            }
+            this.permissions = permissions;
+            authorizationType = LoginAuthorizationType.PUBLISH;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        public void clearPermissions() {
+            permissions = null;
+            authorizationType = null;
+        }
+
+        public void setLoginBehavior(LoginBehavior loginBehavior) {
+            this.loginBehavior = loginBehavior;
+        }
+
+        public LoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML
+     *
+     * @see View#View(Context, AttributeSet)
+     */
+    public LoginButton(Context context) {
+        super(
+                context,
+                null,
+                0,
+                0,
+                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE,
+                DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML
+     *
+     * @see View#View(Context, AttributeSet)
+     */
+    public LoginButton(Context context, AttributeSet attrs) {
+        super(
+                context,
+                attrs,
+                0,
+                0,
+                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE,
+                DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML and applying a style.
+     *
+     * @see View#View(Context, AttributeSet, int)
+     */
+    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
+        super(
+                context,
+                attrs,
+                defStyle,
+                0,
+                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE,
+                DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Sets the default audience to use when the user logs in.
+     * This value is only useful when specifying publish permissions for the native
+     * login dialog.
+     *
+     * @param defaultAudience the default audience value to use
+     */
+    public void setDefaultAudience(DefaultAudience defaultAudience) {
+        properties.setDefaultAudience(defaultAudience);
+    }
+
+    /**
+     * Gets the default audience to use when the user logs in.
+     * This value is only useful when specifying publish permissions for the native
+     * login dialog.
+     *
+     * @return the default audience value to use
+     */
+    public DefaultAudience getDefaultAudience() {
+        return properties.getDefaultAudience();
+    }
+
+    /**
+     * Set the permissions to use when the user logs in. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the user logs in. If this is called
+     * after login, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * It's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by using the LoginManager explicitly).
+     *
+     * @param permissions the read permissions to use
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(List<String> permissions) {
+        properties.setReadPermissions(permissions);
+    }
+
+    /**
+     * Set the permissions to use when the user logs in. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the user logs in. If this is called
+     * after login, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * It's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by using the LoginManager explicitly).
+     *
+     * @param permissions the read permissions to use
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(String... permissions) {
+        properties.setReadPermissions(Arrays.asList(permissions));
+    }
+
+
+    /**
+     * Set the permissions to use when the user logs in. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the user logs in. If this is called
+     * after login, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * It's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by using the LoginManager explicitly).
+     *
+     * @param permissions the publish permissions to use
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException      if permissions is null or empty
+     */
+    public void setPublishPermissions(List<String> permissions) {
+        properties.setPublishPermissions(permissions);
+    }
+
+    /**
+     * Set the permissions to use when the user logs in. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the user logs in. If this is called
+     * after login, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * It's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by using the LoginManager explicitly).
+     *
+     * @param permissions the publish permissions to use
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException      if permissions is null or empty
+     */
+    public void setPublishPermissions(String... permissions) {
+        properties.setPublishPermissions(Arrays.asList(permissions));
+    }
+
+
+    /**
+     * Clears the permissions currently associated with this LoginButton.
+     */
+    public void clearPermissions() {
+        properties.clearPermissions();
+    }
+
+    /**
+     * Sets the login behavior during authorization. If null is specified, the default
+     * ({@link com.facebook.login.LoginBehavior LoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @param loginBehavior The {@link com.facebook.login.LoginBehavior LoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public void setLoginBehavior(LoginBehavior loginBehavior) {
+        properties.setLoginBehavior(loginBehavior);
+    }
+
+    /**
+     * Gets the login behavior during authorization. If null is returned, the default
+     * ({@link com.facebook.login.LoginBehavior LoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @return loginBehavior The {@link com.facebook.login.LoginBehavior LoginBehavior} that
+     * specifies what behaviors should be attempted during
+     * authorization.
+     */
+    public LoginBehavior getLoginBehavior() {
+        return properties.getLoginBehavior();
+    }
+
+    /**
+     * Sets the style (background) of the Tool Tip popup. Currently a blue style and a black
+     * style are supported. Blue is default
+     *
+     * @param toolTipStyle The style of the tool tip popup.
+     */
+    public void setToolTipStyle(ToolTipPopup.Style toolTipStyle) {
+        this.toolTipStyle = toolTipStyle;
+    }
+
+    /**
+     * Sets the mode of the Tool Tip popup. Currently supported modes are default (normal
+     * behavior), always_on (popup remains up until forcibly dismissed), and always_off (popup
+     * doesn't show)
+     *
+     * @param toolTipMode The new mode for the tool tip
+     */
+    public void setToolTipMode(ToolTipMode toolTipMode) {
+        this.toolTipMode = toolTipMode;
+    }
+
+    /**
+     * Return the current {@link ToolTipMode} for this LoginButton
+     *
+     * @return The {@link ToolTipMode}
+     */
+    public ToolTipMode getToolTipMode() {
+        return toolTipMode;
+    }
+
+    /**
+     * Sets the amount of time (in milliseconds) that the tool tip will be shown to the user. The
+     * default is {@value ToolTipPopup#DEFAULT_POPUP_DISPLAY_TIME}. Any value that is less than or
+     * equal to zero will cause the tool tip to be displayed indefinitely.
+     *
+     * @param displayTime The amount of time (in milliseconds) that the tool tip will be displayed
+     *                    to the user
+     */
+    public void setToolTipDisplayTime(long displayTime) {
+        this.toolTipDisplayTime = displayTime;
+    }
+
+    /**
+     * Gets the current amount of time (in ms) that the tool tip will be displayed to the user.
+     *
+     * @return The current amount of time (in ms) that the tool tip will be displayed.
+     */
+    public long getToolTipDisplayTime() {
+        return toolTipDisplayTime;
+    }
+
+    /**
+     * Dismisses the Tooltip if it is currently visible
+     */
+    public void dismissToolTip() {
+        if (toolTipPopup != null) {
+            toolTipPopup.dismiss();
+            toolTipPopup = null;
+        }
+    }
+
+    /**
+     * Registers a login callback to the given callback manager.
+     *
+     * @param callbackManager The callback manager that will encapsulate the callback.
+     * @param callback        The login callback that will be called on login completion.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<LoginResult> callback) {
+        getLoginManager().registerCallback(callbackManager, callback);
+    }
+
+    /**
+     * Registers a login callback to the given callback manager.
+     *
+     * @param callbackManager The callback manager that will encapsulate the callback.
+     * @param callback        The login callback that will be called on login completion.
+     * @param requestCode     The request code to use, this should be outside of the range of those
+     *                        reserved for the Facebook SDK
+     *                        {@link com.facebook.FacebookSdk#isFacebookRequestCode(int)}.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<LoginResult> callback,
+            final int requestCode) {
+        setRequestCode(requestCode);
+        registerCallback(callbackManager, callback);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (accessTokenTracker != null && !accessTokenTracker.isTracking()) {
+            accessTokenTracker.startTracking();
+            setButtonText();
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (!toolTipChecked && !isInEditMode()) {
+            toolTipChecked = true;
+            checkToolTipSettings();
+        }
+    }
+
+    private void showToolTipPerSettings(FetchedAppSettings settings) {
+        if (settings != null && settings.getNuxEnabled() && getVisibility() == View.VISIBLE) {
+            String toolTipString = settings.getNuxContent();
+            displayToolTip(toolTipString);
+        }
+    }
+
+    private void displayToolTip(String toolTipString) {
+        toolTipPopup = new ToolTipPopup(toolTipString, this);
+        toolTipPopup.setStyle(toolTipStyle);
+        toolTipPopup.setNuxDisplayTime(toolTipDisplayTime);
+        toolTipPopup.show();
+    }
+
+    private void checkToolTipSettings() {
+        switch (toolTipMode) {
+            case AUTOMATIC:
+                // kick off an async request
+                final String appId = Utility.getMetadataApplicationId(getContext());
+                FacebookSdk.getExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        final FetchedAppSettings settings = Utility.queryAppSettings(appId, false);
+                        getActivity().runOnUiThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                showToolTipPerSettings(settings);
+                            }
+                        });
+                    }
+                });
+                break;
+            case DISPLAY_ALWAYS:
+                String toolTipString = getResources().getString(
+                        R.string.com_facebook_tooltip_default);
+                displayToolTip(toolTipString);
+                break;
+            case NEVER_DISPLAY:
+                break;
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        setButtonText();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (accessTokenTracker != null) {
+            accessTokenTracker.stopTracking();
+        }
+        dismissToolTip();
+    }
+
+    @Override
+    protected void onVisibilityChanged(View changedView, int visibility) {
+        super.onVisibilityChanged(changedView, visibility);
+        // If the visibility is not VISIBLE, we want to dismiss the tooltip if it is there
+        if (visibility != VISIBLE) {
+            dismissToolTip();
+        }
+    }
+
+    // For testing purposes only
+    List<String> getPermissions() {
+        return properties.getPermissions();
+    }
+
+    void setProperties(LoginButtonProperties properties) {
+        this.properties = properties;
+    }
+
+    @Override
+    protected void configureButton(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        super.configureButton(context, attrs, defStyleAttr, defStyleRes);
+        setInternalOnClickListener(new LoginClickListener());
+
+        parseLoginButtonAttributes(context, attrs, defStyleAttr, defStyleRes);
+
+        if (isInEditMode()) {
+            // cannot use a drawable in edit mode, so setting the background color instead
+            // of a background resource.
+            setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+            // hardcoding in edit mode as getResources().getString() doesn't seem to work in
+            // IntelliJ
+            loginText = "Log in with Facebook";
+        } else {
+            accessTokenTracker = new AccessTokenTracker() {
+                @Override
+                protected void onCurrentAccessTokenChanged(
+                        AccessToken oldAccessToken,
+                        AccessToken currentAccessToken) {
+                    setButtonText();
+                }
+            };
+        }
+
+        setButtonText();
+    }
+
+    @Override
+    protected int getDefaultStyleResource() {
+        return R.style.com_facebook_loginview_default_style;
+    }
+
+    private void parseLoginButtonAttributes(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        this.toolTipMode = ToolTipMode.DEFAULT;
+        final TypedArray a = context.getTheme().obtainStyledAttributes(
+                attrs,
+                R.styleable.com_facebook_login_view,
+                defStyleAttr,
+                defStyleRes);
+        try {
+            confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_com_facebook_confirm_logout, true);
+            loginText = a.getString(R.styleable.com_facebook_login_view_com_facebook_login_text);
+            logoutText = a.getString(R.styleable.com_facebook_login_view_com_facebook_logout_text);
+            toolTipMode = ToolTipMode.fromInt(a.getInt(
+                    R.styleable.com_facebook_login_view_com_facebook_tooltip_mode,
+                    ToolTipMode.DEFAULT.getValue()));
+        } finally {
+            a.recycle();
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        Paint.FontMetrics fontMetrics = getPaint().getFontMetrics();
+        int height = (getCompoundPaddingTop() +
+                (int)Math.ceil(Math.abs(fontMetrics.top) + Math.abs(fontMetrics.bottom)) +
+                getCompoundPaddingBottom());
+
+        final Resources resources = getResources();
+        String text = loginText;
+        int logInWidth;
+        int width;
+        if (text == null) {
+            text = resources.getString(R.string.com_facebook_loginview_log_in_button_long);
+            logInWidth = measureButtonWidth(text);
+            width = resolveSize(logInWidth, widthMeasureSpec);
+            if (width < logInWidth) {
+                text = resources.getString(R.string.com_facebook_loginview_log_in_button);
+            }
+        }
+        logInWidth = measureButtonWidth(text);
+
+        text = logoutText;
+        if (text == null) {
+            text = resources.getString(R.string.com_facebook_loginview_log_out_button);
+        }
+        int logOutWidth = measureButtonWidth(text);
+
+        width = resolveSize(Math.max(logInWidth, logOutWidth), widthMeasureSpec);
+        setMeasuredDimension(width, height);
+    }
+
+    private int measureButtonWidth(final String text) {
+        int textWidth = measureTextWidth(text);
+        int width = (getCompoundPaddingLeft() +
+                getCompoundDrawablePadding() +
+                textWidth +
+                getCompoundPaddingRight());
+        return width;
+    }
+
+    private void setButtonText() {
+        final Resources resources = getResources();
+        if (AccessToken.getCurrentAccessToken() != null) {
+            setText((logoutText != null) ?
+                    logoutText :
+                    resources.getString(R.string.com_facebook_loginview_log_out_button));
+        } else {
+            if (loginText != null) {
+                setText(loginText);
+            } else {
+                String text = resources.getString(
+                        R.string.com_facebook_loginview_log_in_button_long);
+                int width = getWidth();
+                // if the width is 0, we are going to measure size, so use the long text
+                if (width != 0) {
+                    // we have a specific width, check if the long text fits
+                    int measuredWidth = measureButtonWidth(text);
+                    if (measuredWidth > width) {
+                        // it doesn't fit, use the shorter text
+                        text = resources.getString(R.string.com_facebook_loginview_log_in_button);
+                    }
+                }
+                setText(text);
+            }
+        }
+    }
+
+    private class LoginClickListener implements OnClickListener {
+
+        @Override
+        public void onClick(View v) {
+            Context context = getContext();
+
+            AccessToken accessToken = AccessToken.getCurrentAccessToken();
+
+            if (accessToken != null) {
+                // Log out
+                if (confirmLogout) {
+                    // Create a confirmation dialog
+                    String logout = getResources().getString(
+                            R.string.com_facebook_loginview_log_out_action);
+                    String cancel = getResources().getString(
+                            R.string.com_facebook_loginview_cancel_action);
+                    String message;
+                    Profile profile = Profile.getCurrentProfile();
+                    if (profile != null && profile.getName() != null) {
+                        message = String.format(
+                                getResources().getString(
+                                        R.string.com_facebook_loginview_logged_in_as),
+                                profile.getName());
+                    } else {
+                        message = getResources().getString(
+                                R.string.com_facebook_loginview_logged_in_using_facebook);
+                    }
+                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
+                    builder.setMessage(message)
+                            .setCancelable(true)
+                            .setPositiveButton(logout, new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    getLoginManager().logOut();
+                                }
+                            })
+                            .setNegativeButton(cancel, null);
+                    builder.create().show();
+                } else {
+                    getLoginManager().logOut();
+                }
+            } else {
+                LoginManager loginManager = getLoginManager();
+                loginManager.setDefaultAudience(getDefaultAudience());
+                loginManager.setLoginBehavior(getLoginBehavior());
+
+                if (LoginAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
+                    if (LoginButton.this.getFragment() != null) {
+                        loginManager.logInWithPublishPermissions(
+                                LoginButton.this.getFragment(),
+                                properties.permissions);
+                    } else {
+                        loginManager.logInWithPublishPermissions(
+                                LoginButton.this.getActivity(),
+                                properties.permissions);
+                    }
+                } else {
+                    if (LoginButton.this.getFragment() != null) {
+                        loginManager.logInWithReadPermissions(
+                                LoginButton.this.getFragment(),
+                                properties.permissions);
+                    } else {
+                        loginManager.logInWithReadPermissions(
+                                LoginButton.this.getActivity(),
+                                properties.permissions);
+                    }
+                }
+            }
+
+            AppEventsLogger logger = AppEventsLogger.newLogger(getContext());
+
+            Bundle parameters = new Bundle();
+            parameters.putInt("logging_in", (accessToken != null) ? 0 : 1);
+
+            logger.logSdkEvent(loginLogoutEventName, null, parameters);
+
+            callExternalOnClickListener(v);
+        }
+    }
+
+    LoginManager getLoginManager() {
+        if (loginManager == null) {
+            loginManager = LoginManager.getInstance();
+        }
+        return loginManager;
+    }
+
+    void setLoginManager(LoginManager loginManager) {
+        this.loginManager = loginManager;
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ProfilePictureView.java b/facebook/src/com/facebook/login/widget/ProfilePictureView.java
similarity index 83%
rename from facebook/src/com/facebook/widget/ProfilePictureView.java
rename to facebook/src/com/facebook/login/widget/ProfilePictureView.java
index fdc87288b..b92c39107 100644
--- a/facebook/src/com/facebook/widget/ProfilePictureView.java
+++ b/facebook/src/com/facebook/login/widget/ProfilePictureView.java
@@ -1,20 +1,24 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.login.widget;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -29,11 +33,9 @@
 import android.widget.ImageView;
 import com.facebook.FacebookException;
 import com.facebook.LoggingBehavior;
-import com.facebook.android.R;
+import com.facebook.R;
 import com.facebook.internal.*;
 
-import java.net.URISyntaxException;
-
 /**
  * View that displays the profile photo of a supplied profile ID, while conforming
  * to user specified dimensions.
@@ -238,7 +240,7 @@ public final OnErrorListener getOnErrorListener() {
 
     /**
      * Sets an OnErrorListener for this instance of ProfilePictureView to call into when
-     * certain exceptions occur.
+     * certain errors occur.
      *
      * @param onErrorListener The Listener object to set
      */
@@ -297,7 +299,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 
     /**
      * In addition to calling super.Layout(), we also attempt to get a new image that
-     * is properly size for the layout dimensions
+     * is properly sized for the layout dimensions
      */
     @Override
     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
@@ -382,9 +384,11 @@ private void initialize(Context context) {
     }
 
     private void parseAttributes(AttributeSet attrs) {
-        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
-        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
-        isCropped = a.getBoolean(R.styleable.com_facebook_profile_picture_view_is_cropped, IS_CROPPED_DEFAULT_VALUE);
+        TypedArray a = getContext().obtainStyledAttributes(
+                attrs, R.styleable.com_facebook_profile_picture_view);
+        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_com_facebook_preset_size, CUSTOM));
+        isCropped = a.getBoolean(
+                R.styleable.com_facebook_profile_picture_view_com_facebook_is_cropped, IS_CROPPED_DEFAULT_VALUE);
         a.recycle();
     }
 
@@ -402,18 +406,24 @@ private void refreshImage(boolean force) {
     }
 
     private void setBlankProfilePicture() {
+        // If we have a pending image download request cancel it
+        if (lastRequest != null) {
+            ImageDownloader.cancelRequest(lastRequest);
+        }
+
         if (customizedDefaultProfilePicture == null) {
-          int blankImageResource = isCropped() ?
-                  R.drawable.com_facebook_profile_picture_blank_square :
-                  R.drawable.com_facebook_profile_picture_blank_portrait;
-          setImageBitmap( BitmapFactory.decodeResource(getResources(), blankImageResource));
-	} else {
-          // Update profile image dimensions.
-          updateImageQueryParameters();
-          // Resize inputBitmap to new dimensions of queryWidth and queryHeight.
-          Bitmap scaledBitmap = Bitmap.createScaledBitmap(customizedDefaultProfilePicture, queryWidth, queryHeight, false);
-          setImageBitmap(scaledBitmap);
-	}
+            int blankImageResource = isCropped() ?
+                    R.drawable.com_facebook_profile_picture_blank_square :
+                    R.drawable.com_facebook_profile_picture_blank_portrait;
+            setImageBitmap(BitmapFactory.decodeResource(getResources(), blankImageResource));
+        } else {
+            // Update profile image dimensions.
+            updateImageQueryParameters();
+            // Resize inputBitmap to new dimensions of queryWidth and queryHeight.
+            Bitmap scaledBitmap = Bitmap.createScaledBitmap(
+                    customizedDefaultProfilePicture, queryWidth, queryHeight, false);
+            setImageBitmap(scaledBitmap);
+        }
     }
 
     private void setImageBitmap(Bitmap imageBitmap) {
@@ -424,34 +434,30 @@ private void setImageBitmap(Bitmap imageBitmap) {
     }
 
     private void sendImageRequest(boolean allowCachedResponse) {
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getContext(),
-                    ImageRequest.getProfilePictureUrl(profileId, queryWidth,  queryHeight));
-
-            ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
-                    .setCallerTag(this)
-                    .setCallback(
-                    new ImageRequest.Callback() {
-                        @Override
-                        public void onCompleted(ImageResponse response) {
-                            processResponse(response);
-                        }
-                    })
-                    .build();
-
-            // Make sure to cancel the old request before sending the new one to prevent
-            // accidental cancellation of the new request. This could happen if the URL and
-            // caller tag stayed the same.
-            if (lastRequest != null) {
-                ImageDownloader.cancelRequest(lastRequest);
-            }
-            lastRequest = request;
-
-            ImageDownloader.downloadAsync(request);
-        } catch (URISyntaxException e) {
-            Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, e.toString());
+        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                getContext(),
+                ImageRequest.getProfilePictureUri(profileId, queryWidth, queryHeight));
+
+        ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
+                .setCallerTag(this)
+                .setCallback(
+                new ImageRequest.Callback() {
+                    @Override
+                    public void onCompleted(ImageResponse response) {
+                        processResponse(response);
+                    }
+                })
+                .build();
+
+        // Make sure to cancel the old request before sending the new one to prevent
+        // accidental cancellation of the new request. This could happen if the URL and
+        // caller tag stayed the same.
+        if (lastRequest != null) {
+            ImageDownloader.cancelRequest(lastRequest);
         }
+        lastRequest = request;
+
+        ImageDownloader.downloadAsync(request);
     }
 
     private void processResponse(ImageResponse response) {
@@ -466,7 +472,8 @@ private void processResponse(ImageResponse response) {
                 OnErrorListener listener = onErrorListener;
                 if (listener != null) {
                     listener.onError(new FacebookException(
-                            "Error in downloading profile picture for profileId: " + getProfileId(), error));
+                            "Error in downloading profile picture for profileId: " +
+                                    getProfileId(), error));
                 } else {
                     Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, error.toString());
                 }
diff --git a/facebook/src/com/facebook/login/widget/ToolTipPopup.java b/facebook/src/com/facebook/login/widget/ToolTipPopup.java
new file mode 100644
index 000000000..017960820
--- /dev/null
+++ b/facebook/src/com/facebook/login/widget/ToolTipPopup.java
@@ -0,0 +1,240 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login.widget;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.PopupWindow;
+import android.widget.TextView;
+import com.facebook.R;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * This displays a popup tool tip for a specified view.
+ */
+public class ToolTipPopup {
+
+    /**
+     * The values here describe the styles available for the tool tip class.
+     */
+    public static enum Style {
+        /**
+         * The tool tip will be shown with a blue style; including a blue background and blue
+         * arrows.
+         */
+        BLUE,
+        
+        /**
+         * The tool tip will be shown with a black style; including a black background and black
+         * arrows.
+         */
+        BLACK
+    }
+    
+    /**
+     * The default time that the tool tip will be displayed
+     */
+    public static final long DEFAULT_POPUP_DISPLAY_TIME = 6000;
+    
+    private final String mText;
+    private final WeakReference<View> mAnchorViewRef;
+    private final Context mContext;
+    private PopupContentView mPopupContent;
+    private PopupWindow mPopupWindow;
+    private Style mStyle = Style.BLUE;
+    private long mNuxDisplayTime = DEFAULT_POPUP_DISPLAY_TIME;
+    
+    private final ViewTreeObserver.OnScrollChangedListener mScrollListener = 
+            new ViewTreeObserver.OnScrollChangedListener() {
+                @Override
+                public void onScrollChanged() {
+                    if (mAnchorViewRef.get() != null && 
+                            mPopupWindow != null && 
+                            mPopupWindow.isShowing()) {
+                        if (mPopupWindow.isAboveAnchor()) {
+                            mPopupContent.showBottomArrow();
+                        } else {
+                            mPopupContent.showTopArrow();
+                        }
+                    }
+                }
+            };
+    
+    /**
+     * Create a new ToolTipPopup
+     * @param text The text to be displayed in the tool tip
+     * @param anchor The view to anchor this tool tip to.
+     */
+    public ToolTipPopup(String text, View anchor) {
+        mText = text;
+        mAnchorViewRef = new WeakReference<View>(anchor);
+        mContext = anchor.getContext();
+    }
+    
+    /**
+     * Sets the {@link Style} of this tool tip.
+     * @param mStyle the style for the tool tip
+     */
+    public void setStyle(Style mStyle) {
+        this.mStyle = mStyle;
+    }
+    
+    /**
+     * Display this tool tip to the user
+     */
+    public void show() {
+        if (mAnchorViewRef.get() != null) {
+            mPopupContent = new PopupContentView(mContext);
+            TextView body = (TextView) mPopupContent.findViewById(
+                    R.id.com_facebook_tooltip_bubble_view_text_body);
+            body.setText(mText);
+            if (mStyle == Style.BLUE) {
+                mPopupContent.bodyFrame.setBackgroundResource(
+                        R.drawable.com_facebook_tooltip_blue_background);
+                mPopupContent.bottomArrow.setImageResource(
+                        R.drawable.com_facebook_tooltip_blue_bottomnub);
+                mPopupContent.topArrow.setImageResource(
+                        R.drawable.com_facebook_tooltip_blue_topnub);
+                mPopupContent.xOut.setImageResource(R.drawable.com_facebook_tooltip_blue_xout);
+            } else {
+                mPopupContent.bodyFrame.setBackgroundResource(
+                        R.drawable.com_facebook_tooltip_black_background);
+                mPopupContent.bottomArrow.setImageResource(
+                        R.drawable.com_facebook_tooltip_black_bottomnub);
+                mPopupContent.topArrow.setImageResource(
+                        R.drawable.com_facebook_tooltip_black_topnub);
+                mPopupContent.xOut.setImageResource(R.drawable.com_facebook_tooltip_black_xout);
+            }
+            
+            final Window window = ((Activity) mContext).getWindow();
+            final View decorView = window.getDecorView();
+            final int decorWidth = decorView.getWidth();
+            final int decorHeight = decorView.getHeight();
+            registerObserver();
+            mPopupContent.measure(
+                    View.MeasureSpec.makeMeasureSpec(decorWidth, View.MeasureSpec.AT_MOST), 
+                    View.MeasureSpec.makeMeasureSpec(decorHeight, View.MeasureSpec.AT_MOST));
+            mPopupWindow = new PopupWindow(
+                    mPopupContent, 
+                    mPopupContent.getMeasuredWidth(),
+                    mPopupContent.getMeasuredHeight());
+            mPopupWindow.showAsDropDown(mAnchorViewRef.get());
+            updateArrows();
+            if (mNuxDisplayTime > 0) {
+                mPopupContent.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        dismiss();
+                    }
+                }, mNuxDisplayTime);
+            }
+            mPopupWindow.setTouchable(true);
+            mPopupContent.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    dismiss();
+                }
+            });
+        }
+    }
+    
+    /**
+     * Set the time (in milliseconds) the tool tip will be displayed. Any number less than or equal
+     * to 0 will cause the tool tip to be displayed indefinitely
+     * @param displayTime The amount of time (in milliseconds) to display the tool tip
+     */
+    public void setNuxDisplayTime(long displayTime) {
+        this.mNuxDisplayTime = displayTime;
+    }
+    
+    private void updateArrows() {
+        if (mPopupWindow != null && mPopupWindow.isShowing()) {
+            if (mPopupWindow.isAboveAnchor()) {
+                mPopupContent.showBottomArrow();
+            } else {
+                mPopupContent.showTopArrow();
+            }
+        }
+    }
+    
+    /**
+     * Dismiss the tool tip
+     */
+    public void dismiss() {
+        unregisterObserver();
+        if (mPopupWindow != null) {
+            mPopupWindow.dismiss();
+        }
+    }
+    
+    private void registerObserver() {
+        unregisterObserver();
+        if (mAnchorViewRef.get() != null) {
+            mAnchorViewRef.get().getViewTreeObserver().addOnScrollChangedListener(mScrollListener);
+        }
+    }
+    
+    private void unregisterObserver() {
+        if (mAnchorViewRef.get() != null) {
+            mAnchorViewRef.get().getViewTreeObserver().removeOnScrollChangedListener(
+                    mScrollListener);
+        }
+    }
+    
+    private class PopupContentView extends FrameLayout {
+        private ImageView topArrow;
+        private ImageView bottomArrow;
+        private View bodyFrame;
+        private ImageView xOut;
+        
+        public PopupContentView(Context context) {
+            super(context);
+            init();
+        }
+        
+        private void init() {
+            LayoutInflater inflater = LayoutInflater.from(getContext());
+            inflater.inflate(R.layout.com_facebook_tooltip_bubble, this);
+            topArrow = (ImageView) findViewById(R.id.com_facebook_tooltip_bubble_view_top_pointer);
+            bottomArrow = (ImageView) findViewById(
+                    R.id.com_facebook_tooltip_bubble_view_bottom_pointer);
+            bodyFrame = findViewById(R.id.com_facebook_body_frame);
+            xOut = (ImageView) findViewById(R.id.com_facebook_button_xout);
+        }
+        
+        public void showTopArrow() {
+            topArrow.setVisibility(View.VISIBLE);
+            bottomArrow.setVisibility(View.INVISIBLE);
+        }
+        
+        public void showBottomArrow() {
+            topArrow.setVisibility(View.INVISIBLE);
+            bottomArrow.setVisibility(View.VISIBLE);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/messenger/MessengerThreadParams.java b/facebook/src/com/facebook/messenger/MessengerThreadParams.java
new file mode 100644
index 000000000..dcc1ff52a
--- /dev/null
+++ b/facebook/src/com/facebook/messenger/MessengerThreadParams.java
@@ -0,0 +1,86 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.messenger;
+
+import java.util.List;
+
+/**
+ * Parameters describing the Intent that Messenger sent to the app. Returned by
+ * {@link MessengerUtils#getMessengerThreadParamsForIntent}.
+ */
+public class MessengerThreadParams {
+
+  /**
+   * The origin of the flow that user originated from.
+   */
+  public enum Origin {
+    /**
+     * The user clicked on a reply link in Messenger to a particular message.
+     */
+    REPLY_FLOW,
+
+    /**
+     * The user clicked an app shortcut in Messenger.
+     */
+    COMPOSE_FLOW,
+
+    /**
+     * The user came from a flow that was not known at the time this code was written.
+     */
+    UNKNOWN
+  }
+
+  /**
+   * The origin of the flow that the user originated from.
+   */
+  public final Origin origin;
+
+  /**
+   * A token representing the thread the user originated from. This is an opaque value that is not
+   * meant for the app to consume. It exists to complete the flow back to Messenger.
+   */
+  public final String threadToken;
+
+  /**
+   * Metadata that originated from content the app originally set when it sent the request to
+   * Messenger.
+   */
+  public final String metadata;
+
+  /**
+   * The list of participants in the thread represented as App-scoped User IDs. This may not
+   * always be set and will only ever be set for apps that include Facebook login. When set, it
+   * will only include the participants in the thread that have logged into the app. See
+   * <a href="https://developers.facebook.com/docs/apps/upgrading">docs</a> for more info.
+   */
+  public final List<String> participants;
+
+  public MessengerThreadParams(
+      Origin origin,
+      String threadToken,
+      String metadata,
+      List<String> participants) {
+    this.threadToken = threadToken;
+    this.metadata = metadata;
+    this.participants = participants;
+    this.origin = origin;
+  }
+}
diff --git a/facebook/src/com/facebook/messenger/MessengerUtils.java b/facebook/src/com/facebook/messenger/MessengerUtils.java
new file mode 100644
index 000000000..af847c14d
--- /dev/null
+++ b/facebook/src/com/facebook/messenger/MessengerUtils.java
@@ -0,0 +1,296 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.messenger;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.facebook.FacebookSdk;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import bolts.AppLinks;
+
+/**
+ * Utilities for Messenger Content Platform.
+ * <p>
+ *   Applications should specify the app id in their manifest or call
+ *   {@link com.facebook.FacebookSdk#setApplicationId(String)} } in
+ *   their application startup path. For specifying in the manifest, add a meta tag in your
+ *   &lt;application&gt; tag.
+ *
+ *   <pre>
+ *    &lt;meta-data android:name="com.facebook.sdk.ApplicationId" android:value="YOUR_APP_ID"/&gt;
+ *   </pre>
+ *
+ * </p>
+ *
+ * <p>
+ *   When sharing to Messenger, apps should call the {@link #shareToMessenger} method. For example,
+ *
+ *   <pre>
+ *     ShareToMessengerParams params = ShareToMessengerParams.newBuilder(uri, "image/*")
+ *         .setMetaData(metaData)
+ *         .build();
+ *     MessengerUtils.shareToMessenger(this, REQUEST_CODE_SHARE_TO_MESSENGER, params);
+ *   </pre>
+ *
+ *   To handle receiving a composer shortcut or reply intent from Messenger, apps should
+ *   put the following intent filter in their manifest for the activity that receives the intent:
+ *
+ *   <pre>
+ *           &lt;intent-filter&gt;
+ *             &lt;action android:name="android.intent.action.PICK" /&gt;
+ *             &lt;category android:name="android.intent.category.DEFAULT"/&gt;
+ *             &lt;category android:name="com.facebook.orca.category.PLATFORM_THREAD_20150311"/&gt;
+ *           &lt;/intent-filter&gt;
+ *   </pre>
+ *
+ *   When handling the intent, then call {@link #getMessengerThreadParamsForIntent} to receive
+ *   the parameters for messenger. When the user has clicked the Send button to send the content
+ *   to Messenger, then call {@link #finishShareToMessenger} to return the data back to Messenger.
+ * </p>
+ */
+public class MessengerUtils {
+
+  private static final String TAG = "MessengerUtils";
+
+  public static final String PACKAGE_NAME = "com.facebook.orca";
+
+  public static final String EXTRA_PROTOCOL_VERSION = "com.facebook.orca.extra.PROTOCOL_VERSION";
+  public static final String EXTRA_APP_ID = "com.facebook.orca.extra.APPLICATION_ID";
+  public static final String EXTRA_REPLY_TOKEN_KEY = "com.facebook.orca.extra.REPLY_TOKEN";
+  public static final String EXTRA_THREAD_TOKEN_KEY = "com.facebook.orca.extra.THREAD_TOKEN";
+  public static final String EXTRA_METADATA = "com.facebook.orca.extra.METADATA";
+  public static final String EXTRA_EXTERNAL_URI = "com.facebook.orca.extra.EXTERNAL_URI";
+  public static final String EXTRA_PARTICIPANTS = "com.facebook.orca.extra.PARTICIPANTS";
+  public static final String EXTRA_IS_REPLY = "com.facebook.orca.extra.IS_REPLY";
+  public static final String EXTRA_IS_COMPOSE = "com.facebook.orca.extra.IS_COMPOSE";
+  public static final int PROTOCOL_VERSION_20150314 = 20150314;
+
+  public static final String ORCA_THREAD_CATEGORY_20150314 =
+      "com.facebook.orca.category.PLATFORM_THREAD_20150314";
+
+  /**
+   * Starts an intent to share a piece of media on Messenger using the messenger content platform.
+   *
+   * @param activity the activity sharing the content
+   * @param requestCode a unique request code for {@link Activity#startActivityForResult}
+   * @param shareToMessengerParams parameters for what to share
+   */
+  public static void shareToMessenger(
+      Activity activity,
+      int requestCode,
+      ShareToMessengerParams shareToMessengerParams) {
+    if (!MessengerUtils.hasMessengerInstalled(activity)) {
+      MessengerUtils.openMessengerInPlayStore(activity);
+      return;
+    }
+
+    Set<Integer> allAvailableVersions = getAllAvailableProtocolVersions(activity);
+    if (allAvailableVersions.contains(PROTOCOL_VERSION_20150314)) {
+      shareToMessenger20150314(activity, requestCode, shareToMessengerParams);
+    } else {
+      // TODO -- should we show a upgrade dialog?
+      MessengerUtils.openMessengerInPlayStore(activity);
+    }
+  }
+
+  private static void shareToMessenger20150314(
+      Activity activity,
+      int requestCode,
+      ShareToMessengerParams shareToMessengerParams) {
+    try {
+      Intent shareIntent = new Intent(Intent.ACTION_SEND);
+      shareIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+      shareIntent.setPackage(PACKAGE_NAME);
+      shareIntent.putExtra(Intent.EXTRA_STREAM, shareToMessengerParams.uri);
+      shareIntent.setType(shareToMessengerParams.mimeType);
+      String appId = FacebookSdk.getApplicationId();
+      if (appId != null) {
+        shareIntent.putExtra(EXTRA_PROTOCOL_VERSION, PROTOCOL_VERSION_20150314);
+        shareIntent.putExtra(EXTRA_APP_ID, appId);
+        shareIntent.putExtra(EXTRA_METADATA, shareToMessengerParams.metaData);
+        shareIntent.putExtra(EXTRA_EXTERNAL_URI, shareToMessengerParams.externalUri);
+      }
+
+      activity.startActivityForResult(shareIntent, requestCode);
+    } catch (ActivityNotFoundException e) {
+      Intent openMessenger = activity.getPackageManager().getLaunchIntentForPackage(PACKAGE_NAME);
+      activity.startActivity(openMessenger);
+    }
+  }
+
+  /**
+   * When handling an {@code Intent} from Messenger, call this to parse the parameters of the
+   * intent.
+   *
+   * @param intent the intent of the activity
+   * @return a {@link MessengerThreadParams} or null if this intent wasn't recognized as a request
+   *     from Messenger to share.
+   */
+  public static MessengerThreadParams getMessengerThreadParamsForIntent(Intent intent) {
+    Set<String> categories = intent.getCategories();
+    if (categories == null) {
+      return null;
+    }
+    if (categories.contains(ORCA_THREAD_CATEGORY_20150314)) {
+      Bundle appLinkExtras = AppLinks.getAppLinkExtras(intent);
+      String threadToken = appLinkExtras.getString(EXTRA_THREAD_TOKEN_KEY);
+      String metadata = appLinkExtras.getString(EXTRA_METADATA);
+      String participants = appLinkExtras.getString(EXTRA_PARTICIPANTS);
+      boolean isReply = appLinkExtras.getBoolean(EXTRA_IS_REPLY);
+      boolean isCompose = appLinkExtras.getBoolean(EXTRA_IS_COMPOSE);
+      MessengerThreadParams.Origin origin = MessengerThreadParams.Origin.UNKNOWN;
+      if (isReply) {
+        origin = MessengerThreadParams.Origin.REPLY_FLOW;
+      } else if (isCompose) {
+        origin = MessengerThreadParams.Origin.COMPOSE_FLOW;
+      }
+
+      return new MessengerThreadParams(
+          origin,
+          threadToken,
+          metadata,
+          parseParticipants(participants));
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Finishes the activity and returns the media item the user picked to Messenger.
+   *
+   * @param activity the activity that received the original intent from Messenger
+   * @param shareToMessengerParams parameters for what to share
+   */
+  public static void finishShareToMessenger(
+      Activity activity,
+      ShareToMessengerParams shareToMessengerParams) {
+    Intent originalIntent = activity.getIntent();
+    Set<String> categories = originalIntent.getCategories();
+    if (categories == null) {
+      // This shouldn't happen.
+      activity.setResult(Activity.RESULT_CANCELED, null);
+      activity.finish();
+      return;
+    }
+
+    if (categories.contains(ORCA_THREAD_CATEGORY_20150314)) {
+      Bundle appLinkExtras = AppLinks.getAppLinkExtras(originalIntent);
+
+      Intent resultIntent = new Intent();
+      if (categories.contains(ORCA_THREAD_CATEGORY_20150314)) {
+        resultIntent.putExtra(EXTRA_PROTOCOL_VERSION, MessengerUtils.PROTOCOL_VERSION_20150314);
+        String threadToken = appLinkExtras.getString(MessengerUtils.EXTRA_THREAD_TOKEN_KEY);
+        resultIntent.putExtra(EXTRA_THREAD_TOKEN_KEY, threadToken);
+      } else {
+        throw new RuntimeException(); // Can't happen.
+      }
+      resultIntent.setDataAndType(shareToMessengerParams.uri, shareToMessengerParams.mimeType);
+      resultIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+      resultIntent.putExtra(EXTRA_APP_ID, FacebookSdk.getApplicationId());
+      resultIntent.putExtra(EXTRA_METADATA, shareToMessengerParams.metaData);
+      resultIntent.putExtra(EXTRA_EXTERNAL_URI, shareToMessengerParams.externalUri);
+      activity.setResult(Activity.RESULT_OK, resultIntent);
+      activity.finish();
+    } else {
+      // This shouldn't happen.
+      activity.setResult(Activity.RESULT_CANCELED, null);
+      activity.finish();
+    }
+  }
+
+  /**
+   * Checks whether any version of messenger is installed.
+   *
+   * @param context an android context
+   * @return whether any version of messenger is installed
+   */
+  public static boolean hasMessengerInstalled(Context context) {
+    try {
+      context.getPackageManager().getPackageInfo(PACKAGE_NAME, 0);
+      return true;
+    } catch (PackageManager.NameNotFoundException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Opens the play store to install Messenger.
+   *
+   * @param context an android context.
+   */
+  public static void openMessengerInPlayStore(Context context) {
+    try {
+      startViewUri(context, "market://details?id=" + PACKAGE_NAME);
+    } catch (ActivityNotFoundException anfe) {
+      startViewUri(context, "http://play.google.com/store/apps/details?id=" + PACKAGE_NAME);
+    }
+  }
+
+  private static Set<Integer> getAllAvailableProtocolVersions(Context context) {
+    ContentResolver contentResolver = context.getContentResolver();
+    Set<Integer> allAvailableVersions = new HashSet<Integer>();
+    Uri uri = Uri.parse("content://com.facebook.orca.provider.MessengerPlatformProvider/versions");
+    String [] projection = new String[]{ "version" };
+    Cursor c = contentResolver.query(uri, projection, null, null, null);
+    if (c != null) {
+      try {
+        int versionColumnIndex = c.getColumnIndex("version");
+        while (c.moveToNext()) {
+          int version = c.getInt(versionColumnIndex);
+          allAvailableVersions.add(version);
+        }
+      } finally {
+        c.close();
+      }
+    }
+    return allAvailableVersions;
+  }
+
+  private static void startViewUri(Context context, String uri) {
+    context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(uri)));
+  }
+
+  private static List<String> parseParticipants(String s) {
+    if (s == null || s.length() == 0) {
+      return Collections.emptyList();
+    }
+    String[] parts = s.split(",");
+    List<String> ret = new ArrayList<String>();
+    for (String part : parts) {
+      ret.add(part.trim());
+    }
+    return ret;
+  }
+}
diff --git a/facebook/src/com/facebook/messenger/ShareToMessengerParams.java b/facebook/src/com/facebook/messenger/ShareToMessengerParams.java
new file mode 100644
index 000000000..9bb413384
--- /dev/null
+++ b/facebook/src/com/facebook/messenger/ShareToMessengerParams.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.messenger;
+
+import android.net.Uri;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Parameters used by {@link MessengerUtils} for sending the media to Messenger to share.
+ * See <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for
+ * more info.
+ */
+public class ShareToMessengerParams {
+
+  public static final Set<String> VALID_URI_SCHEMES;
+  public static final Set<String> VALID_MIME_TYPES;
+  public static final Set<String> VALID_EXTERNAL_URI_SCHEMES;
+
+  static {
+    Set<String> validMimeTypes = new HashSet<String>();
+    validMimeTypes.add("image/*");
+    validMimeTypes.add("image/jpeg");
+    validMimeTypes.add("image/png");
+    validMimeTypes.add("image/gif");
+    validMimeTypes.add("image/webp");
+    validMimeTypes.add("video/*");
+    validMimeTypes.add("video/mp4");
+    validMimeTypes.add("audio/*");
+    validMimeTypes.add("audio/mpeg");
+    VALID_MIME_TYPES = Collections.unmodifiableSet(validMimeTypes);
+
+    Set<String> validUriSchemes = new HashSet<String>();
+    validUriSchemes.add("content");
+    validUriSchemes.add("android.resource");
+    validUriSchemes.add("file");
+    VALID_URI_SCHEMES = Collections.unmodifiableSet(validUriSchemes);
+
+    Set<String> validExternalUriSchemes = new HashSet<String>();
+    validExternalUriSchemes.add("http");
+    validExternalUriSchemes.add("https");
+    VALID_EXTERNAL_URI_SCHEMES = Collections.unmodifiableSet(validExternalUriSchemes);
+  }
+
+  /**
+   * The URI of the local image, video, or audio clip to send to messenger. Must be
+   * a file://, content://, or res:// URI.
+   */
+  public final Uri uri;
+
+  /**
+   * The mime type of the content. See {@link #VALID_MIME_TYPES} for what mime types are supported.
+   */
+  public final String mimeType;
+
+  /**
+   * The metadata to attach to the content to shared. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   */
+  public final String metaData;
+
+  /**
+   * An external URI that Messenger can use to download the content on Facebook's servers
+   * instead of requiring the Messenger application to upload the content. The content returned by
+   * the this URI must be exactly the same as the content specified by {@link #uri}. If the
+   * content is different, Messenger may fail to send the content. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   */
+  public final Uri externalUri;
+
+  ShareToMessengerParams(ShareToMessengerParamsBuilder builder) {
+    uri = builder.getUri();
+    mimeType = builder.getMimeType();
+    metaData = builder.getMetaData();
+    externalUri = builder.getExternalUri();
+
+    if (uri == null) {
+      throw new NullPointerException("Must provide non-null uri");
+    }
+    if (mimeType == null) {
+      throw new NullPointerException("Must provide mimeType");
+    }
+    if (!VALID_URI_SCHEMES.contains(uri.getScheme())) {
+      throw new IllegalArgumentException("Unsupported URI scheme: " + uri.getScheme());
+    }
+    if (!VALID_MIME_TYPES.contains(mimeType)) {
+      throw new IllegalArgumentException("Unsupported mime-type: " + mimeType);
+    }
+    if (externalUri != null) {
+      if (!VALID_EXTERNAL_URI_SCHEMES.contains(externalUri.getScheme())) {
+        throw new IllegalArgumentException("Unsupported external uri scheme: " +
+            externalUri.getScheme());
+      }
+    }
+  }
+
+  /**
+   * Creates a new builder for creating a {@link ShareToMessengerParams} instance
+   *
+   * @param uri the uri of the local content. Must be a file://, content://, or res:// URI.
+   * @param mimeType the mime-type of the content. See {@link #VALID_MIME_TYPES} for what mime
+   *                 types are supported.
+   * @return the builder instance
+   */
+  public static ShareToMessengerParamsBuilder newBuilder(Uri uri, String mimeType) {
+    return new ShareToMessengerParamsBuilder(uri, mimeType);
+  }
+}
diff --git a/facebook/src/com/facebook/messenger/ShareToMessengerParamsBuilder.java b/facebook/src/com/facebook/messenger/ShareToMessengerParamsBuilder.java
new file mode 100644
index 000000000..ad42d6c28
--- /dev/null
+++ b/facebook/src/com/facebook/messenger/ShareToMessengerParamsBuilder.java
@@ -0,0 +1,122 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.messenger;
+
+import android.net.Uri;
+
+/**
+ * Builder for {@link ShareToMessengerParams}.
+ */
+public class ShareToMessengerParamsBuilder {
+
+  private final Uri mUri;
+  private final String mMimeType;
+  private String mMetaData;
+  private Uri mExternalUri;
+
+  ShareToMessengerParamsBuilder(Uri uri, String mimeType) {
+    mUri = uri;
+    mMimeType = mimeType;
+  }
+
+  /**
+   * Gets the URI of the local image, video, or audio clip to send to messenger. Must be
+   * a file://, content://, or res:// URI.
+   *
+   * @return the uri
+   */
+  public Uri getUri() {
+    return mUri;
+  }
+
+  /**
+   * Gets the mime type of the content. See {@link ShareToMessengerParams#VALID_MIME_TYPES} for
+   * what mime types are supported.
+   *
+   * @return the mime type
+   */
+  public String getMimeType() {
+    return mMimeType;
+  }
+
+  /**
+   * Sets the metadata to attach to the content to shared. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   *
+   * @param metaData the metadata to attach to the message
+   * @return this builder
+   */
+  public ShareToMessengerParamsBuilder setMetaData(String metaData) {
+    mMetaData = metaData;
+    return this;
+  }
+
+  /**
+   * Gets the metadata to attach to the content to shared. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   *
+   * @return the metadata to attach to the message
+   */
+  public String getMetaData() {
+    return mMetaData;
+  }
+
+  /**
+   * Sets an external URI that Messenger can use to download the content on Facebook's servers
+   * instead of requiring the Messenger application to upload the content. The content returned by
+   * the this URI must be exactly the same as the content specified by {@link #getUri()}. If the
+   * content is different, Messenger may fail to send the content. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   *
+   * @param externalUri the external uri to set
+   * @return this builder
+   */
+  public ShareToMessengerParamsBuilder setExternalUri(Uri externalUri) {
+    mExternalUri = externalUri;
+    return this;
+  }
+
+  /**
+   * Gets an external URI that Messenger can use to download the content on Facebook's servers
+   * instead of requiring the Messenger application to upload the content. The content returned by
+   * the this URI must be exactly the same as the content specified by {@link #getUri()}. If the
+   * content is different, Messenger may fail to send the content. See
+   * <a href="https://developers.facebook.com/docs/messenger/android">developer docs</a> for more
+   * info.
+   *
+   * @return the external URI
+   */
+  public Uri getExternalUri() {
+    return mExternalUri;
+  }
+
+  /**
+   * Builds the parameter object.
+   *
+   * @return the parameter object
+   */
+  public ShareToMessengerParams build() {
+    return new ShareToMessengerParams(this);
+  }
+}
diff --git a/facebook/src/com/facebook/model/CreateGraphObject.java b/facebook/src/com/facebook/model/CreateGraphObject.java
deleted file mode 100644
index 92e7a2af5..000000000
--- a/facebook/src/com/facebook/model/CreateGraphObject.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/**
- * Use this annotation setters in an interface that derives from
- * GraphObject, if you wish to provide a setter that takes a primitive data type (e.g., String)
- * or a List of primitive data types, but actually populates its underlying property with a
- * new GraphObject with a property equal to the specified value (or a List of such GraphObjects).
- * This is useful for providing "helper" setters to avoid requiring callers to instantiate a GraphObject
- * just to set a single property on it (e.g., 'url' or 'id').
- *
- * The String value provided to this annotation should be the name of the property that will be
- * populated on the newly-created GraphObject using the value that was passed to the setter.
- *
- * This annotation has no effect if applied to a getter.
- */
-@Retention(RetentionPolicy.RUNTIME)
-public @interface CreateGraphObject {
-    String value();
-}
diff --git a/facebook/src/com/facebook/model/GraphLocation.java b/facebook/src/com/facebook/model/GraphLocation.java
deleted file mode 100644
index 9074a4976..000000000
--- a/facebook/src/com/facebook/model/GraphLocation.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-/**
- * Provides a strongly-typed representation of a Location as defined by the Graph API.
- *
- * Note that this interface is intended to be used with GraphObject.Factory
- * and not implemented directly.
- */
-public interface GraphLocation extends GraphObject {
-    /**
-     * Returns the street component of the location.
-     * 
-     * @return the street component of the location, or null
-     */
-    public String getStreet();
-
-    /**
-     * Sets the street component of the location.
-     * 
-     * @param street
-     *            the street component of the location, or null
-     */
-    public void setStreet(String street);
-
-    /**
-     * Gets the city component of the location.
-     * 
-     * @return the city component of the location
-     */
-    public String getCity();
-
-    /**
-     * Sets the city component of the location.
-     * 
-     * @param city
-     *            the city component of the location
-     */
-    public void setCity(String city);
-
-    /**
-     * Returns the state component of the location.
-     * 
-     * @return the state component of the location
-     */
-    public String getState();
-
-    /**
-     * Sets the state component of the location.
-     * 
-     * @param state
-     *            the state component of the location
-     */
-    public void setState(String state);
-
-    /**
-     * Returns the country component of the location.
-     * 
-     * @return the country component of the location
-     */
-    public String getCountry();
-
-    /**
-     * Sets the country component of the location
-     * 
-     * @param country
-     *            the country component of the location
-     */
-    public void setCountry(String country);
-
-    /**
-     * Returns the postal code component of the location.
-     * 
-     * @return the postal code component of the location
-     */
-    public String getZip();
-
-    /**
-     * Sets the postal code component of the location.
-     * 
-     * @param zip
-     *            the postal code component of the location
-     */
-    public void setZip(String zip);
-
-    /**
-     * Returns the latitude component of the location.
-     * 
-     * @return the latitude component of the location
-     */
-    public double getLatitude();
-
-    /**
-     * Sets the latitude component of the location.
-     * 
-     * @param latitude
-     *            the latitude component of the location
-     */
-    public void setLatitude(double latitude);
-
-    /**
-     * Returns the longitude component of the location.
-     * 
-     * @return the longitude component of the location
-     */
-    public double getLongitude();
-
-    /**
-     * Sets the longitude component of the location.
-     * 
-     * @param longitude
-     *            the longitude component of the location
-     */
-    public void setLongitude(double longitude);
-}
diff --git a/facebook/src/com/facebook/model/GraphMultiResult.java b/facebook/src/com/facebook/model/GraphMultiResult.java
deleted file mode 100644
index dbcdbad3e..000000000
--- a/facebook/src/com/facebook/model/GraphMultiResult.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-/**
- * Defines a GraphObject that represents the result of a query that returns multiple GraphObjects
- * nested under a "data" property.
- *
- * Note that this interface is intended to be used with GraphObject.Factory
- * and not implemented directly.
- */
-public interface GraphMultiResult extends GraphObject {
-    /**
-     * Provides access to the GraphObjects that make up the result set.
-     * @return a list of GraphObjects
-     */
-    public GraphObjectList<GraphObject> getData();
-}
diff --git a/facebook/src/com/facebook/model/GraphObject.java b/facebook/src/com/facebook/model/GraphObject.java
deleted file mode 100644
index c6684e698..000000000
--- a/facebook/src/com/facebook/model/GraphObject.java
+++ /dev/null
@@ -1,839 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import com.facebook.FacebookGraphObjectException;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.lang.reflect.*;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-/**
- * GraphObject is the primary interface used by the Facebook SDK for Android to represent objects in the Facebook
- * Social Graph and the Facebook Open Graph (OG). It is the base interface for all typed access to graph objects
- * in the SDK. No concrete classes implement GraphObject or its derived interfaces. Rather, they are implemented as
- * proxies (see the {@link com.facebook.model.GraphObject.Factory Factory} class) that provide strongly-typed property
- * getters and setters to access the underlying data. Since the primary use case for graph objects is sending and
- * receiving them over the wire to/from Facebook services, they are represented as JSONObjects. No validation is done
- * that a graph object is actually of a specific type -- any graph object can be treated as any GraphObject-derived
- * interface, and the presence or absence of specific properties determines its suitability for use as that
- * particular type of object.
- * <br/>
- */
-public interface GraphObject {
-    /**
-     * Returns a new proxy that treats this graph object as a different GraphObject-derived type.
-     * @param graphObjectClass the type of GraphObject to return
-     * @return a new instance of the GraphObject-derived-type that references the same underlying data
-     */
-    <T extends GraphObject> T cast(Class<T> graphObjectClass);
-
-    /**
-     * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
-     * inner JSON representation.
-     * @return a Java Collections map representing the GraphObject state
-     */
-    Map<String, Object> asMap();
-
-    /**
-     * Gets the underlying JSONObject representation of this graph object.
-     * @return the underlying JSONObject representation of this graph object
-     */
-    JSONObject getInnerJSONObject();
-
-    /**
-     * Gets a property of the GraphObject
-     * @param propertyName the name of the property to get
-     * @return the value of the named property
-     */
-    Object getProperty(String propertyName);
-
-    /**
-     * Gets a property of the GraphObject, cast to a particular GraphObject-derived interface. This gives some of
-     * the benefits of having a property getter defined to return a GraphObject-derived type without requiring
-     * explicit definition of an interface to define the getter.
-     * @param propertyName the name of the property to get
-     * @param graphObjectClass the GraphObject-derived interface to cast the property to
-     * @return
-     */
-    <T extends GraphObject> T getPropertyAs(String propertyName, Class<T> graphObjectClass);
-
-    /**
-     * Gets a property of the GraphObject, cast to a a list of instances of a particular GraphObject-derived interface.
-     * This gives some of the benefits of having a property getter defined to return a GraphObject-derived type without
-     * requiring explicit definition of an interface to define the getter.
-     * @param propertyName the name of the property to get
-     * @param graphObjectClass the GraphObject-derived interface to cast the property to a list of
-     * @return
-     */
-    <T extends GraphObject> GraphObjectList<T> getPropertyAsList(String propertyName, Class<T> graphObjectClass);
-
-    /**
-     * Sets a property of the GraphObject
-     * @param propertyName the name of the property to set
-     * @param propertyValue the value of the named property to set
-     */
-    void setProperty(String propertyName, Object propertyValue);
-
-    /**
-     * Removes a property of the GraphObject
-     * @param propertyName the name of the property to remove
-     */
-    void removeProperty(String propertyName);
-
-    /**
-     * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
-     * to underlying collections and name/value property bags via strongly-typed property getters and setters.
-     * <p/>
-     * This supports get/set properties that use primitive types, JSON types, Date, other GraphObject types, Iterable,
-     * Collection, List, and GraphObjectList.
-     */
-    final class Factory {
-        private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
-        private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
-                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
-                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
-
-        // No objects of this type should exist.
-        private Factory() {
-        }
-
-        /**
-         * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
-         * @param json the JSONObject containing the data to be exposed
-         * @return a GraphObject that represents the underlying data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static GraphObject create(JSONObject json) {
-            return create(json, GraphObject.class);
-        }
-
-        /**
-         * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
-         * @param json the JSONObject containing the data to be exposed
-         * @param graphObjectClass the GraphObject-derived type to return
-         * @return a graphObjectClass that represents the underlying data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static <T extends GraphObject> T create(JSONObject json, Class<T> graphObjectClass) {
-            return createGraphObjectProxy(graphObjectClass, json);
-        }
-
-        /**
-         * Creates a GraphObject proxy that initially contains no data.
-         * @return a GraphObject with no data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static GraphObject create() {
-            return create(GraphObject.class);
-        }
-
-        /**
-         * Creates a GraphObject-derived proxy that initially contains no data.
-         * @param graphObjectClass the GraphObject-derived type to return
-         * @return a graphObjectClass with no data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static <T extends GraphObject> T create(Class<T> graphObjectClass) {
-            return createGraphObjectProxy(graphObjectClass, new JSONObject());
-        }
-
-        /**
-         * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
-         * @param a a graph object
-         * @param b another graph object
-         * @return true if both graph objects have an ID and it is the same ID, false otherwise
-         */
-        public static boolean hasSameId(GraphObject a, GraphObject b) {
-            if (a == null || b == null || !a.asMap().containsKey("id") || !b.asMap().containsKey("id")) {
-                return false;
-            }
-            if (a.equals(b)) {
-                return true;
-            }
-            Object idA = a.getProperty("id");
-            Object idB = b.getProperty("id");
-            if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
-                return false;
-            }
-            return idA.equals(idB);
-        }
-
-        /**
-         * Creates a GraphObjectList-derived proxy that provides typed access to the data in an underlying JSONArray.
-         * @param array the JSONArray containing the data to be exposed
-         * @param graphObjectClass the GraphObject-derived type to return
-         * @return a graphObjectClass that represents the underlying data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static <T> GraphObjectList<T> createList(JSONArray array, Class<T> graphObjectClass) {
-            return new GraphObjectListImpl<T>(array, graphObjectClass);
-        }
-
-        /**
-         * Creates a GraphObjectList-derived proxy that initially contains no data.
-         * @param graphObjectClass the GraphObject-derived type to return
-         * @return a GraphObjectList with no data
-         *
-         * @throws com.facebook.FacebookException
-         *            If the passed in Class is not a valid GraphObject interface
-         */
-        public static <T> GraphObjectList<T> createList(Class<T> graphObjectClass) {
-            return createList(new JSONArray(), graphObjectClass);
-        }
-
-        private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
-            verifyCanProxyClass(graphObjectClass);
-
-            Class<?>[] interfaces = new Class<?>[] { graphObjectClass };
-            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
-
-            @SuppressWarnings("unchecked")
-            T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
-            return graphObject;
-        }
-
-        private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
-            Class<?>[] interfaces = new Class<?>[]{Map.class};
-            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
-
-            @SuppressWarnings("unchecked")
-            Map<String, Object> graphObject = (Map<String, Object>) Proxy
-                    .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
-            return graphObject;
-        }
-
-        private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
-            return verifiedGraphObjectClasses.contains(graphObjectClass);
-        }
-
-        private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
-            verifiedGraphObjectClasses.add(graphObjectClass);
-        }
-
-        private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
-            if (hasClassBeenVerified(graphObjectClass)) {
-                return;
-            }
-
-            if (!graphObjectClass.isInterface()) {
-                throw new FacebookGraphObjectException("Factory can only wrap interfaces, not class: "
-                        + graphObjectClass.getName());
-            }
-
-            Method[] methods = graphObjectClass.getMethods();
-            for (Method method : methods) {
-                String methodName = method.getName();
-                int parameterCount = method.getParameterTypes().length;
-                Class<?> returnType = method.getReturnType();
-                boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
-
-                if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
-                    // Don't worry about any methods from GraphObject or one of its base classes.
-                    continue;
-                } else if (parameterCount == 1 && returnType == Void.TYPE) {
-                    if (hasPropertyNameOverride) {
-                        // If a property override is present, it MUST be valid. We don't fallback
-                        // to using the method name
-                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
-                            continue;
-                        }
-                    } else if (methodName.startsWith("set") && methodName.length() > 3) {
-                        // Looks like a valid setter
-                        continue;
-                    }
-                } else if (parameterCount == 0 && returnType != Void.TYPE) {
-                    if (hasPropertyNameOverride) {
-                        // If a property override is present, it MUST be valid. We don't fallback
-                        // to using the method name
-                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
-                            continue;
-                        }
-                    } else if (methodName.startsWith("get") && methodName.length() > 3) {
-                        // Looks like a valid getter
-                        continue;
-                    }
-                }
-
-                throw new FacebookGraphObjectException("Factory can't proxy method: " + method.toString());
-            }
-
-            recordClassHasBeenVerified(graphObjectClass);
-        }
-
-        // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
-        // generic parameter types.
-        static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
-                ParameterizedType expectedTypeAsParameterizedType) {
-            if (value == null) {
-                if (boolean.class.equals(expectedType)) {
-                    @SuppressWarnings("unchecked")
-                    U result = (U) (Boolean) false;
-                    return result;
-                } else if (char.class.equals(expectedType)) {
-                    @SuppressWarnings("unchecked")
-                    U result = (U) (Character) '\0';
-                    return result;
-                } else if (expectedType.isPrimitive()) {
-                    @SuppressWarnings("unchecked")
-                    U result = (U) (Number) 0;
-                    return result;
-                } else {
-                    return null;
-                }
-            }
-
-            Class<?> valueType = value.getClass();
-            if (expectedType.isAssignableFrom(valueType)) {
-                @SuppressWarnings("unchecked")
-                U result = (U) value;
-                return result;
-            }
-
-            if (expectedType.isPrimitive()) {
-                // If the result is a primitive, let the runtime succeed or fail at unboxing it.
-                @SuppressWarnings("unchecked")
-                U result = (U) value;
-                return result;
-            }
-
-            if (GraphObject.class.isAssignableFrom(expectedType)) {
-                @SuppressWarnings("unchecked")
-                Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
-
-                // We need a GraphObject, but we don't have one.
-                if (JSONObject.class.isAssignableFrom(valueType)) {
-                    // We can wrap a JSONObject as a GraphObject.
-                    @SuppressWarnings("unchecked")
-                    U result = (U) createGraphObjectProxy(graphObjectClass, (JSONObject) value);
-                    return result;
-                } else if (GraphObject.class.isAssignableFrom(valueType)) {
-                    // We can cast a GraphObject-derived class to another GraphObject-derived class.
-                    @SuppressWarnings("unchecked")
-                    U result = (U) ((GraphObject) value).cast(graphObjectClass);
-                    return result;
-                } else {
-                    throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
-                }
-            } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
-                    || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
-                if (expectedTypeAsParameterizedType == null) {
-                    throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
-                }
-
-                Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
-
-                if (actualTypeArguments == null || actualTypeArguments.length != 1
-                        || !(actualTypeArguments[0] instanceof Class<?>)) {
-                    throw new FacebookGraphObjectException(
-                            "Expect collection properties to be of a type with exactly one generic parameter.");
-                }
-                Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
-
-                if (JSONArray.class.isAssignableFrom(valueType)) {
-                    JSONArray jsonArray = (JSONArray) value;
-                    @SuppressWarnings("unchecked")
-                    U result = (U) createList(jsonArray, collectionGenericArgument);
-                    return result;
-                } else {
-                    throw new FacebookGraphObjectException("Can't create Collection from " + valueType.getName());
-                }
-            } else if (String.class.equals(expectedType)) {
-                if (Double.class.isAssignableFrom(valueType) ||
-                        Float.class.isAssignableFrom(valueType)) {
-                    @SuppressWarnings("unchecked")
-                    U result = (U) String.format("%f", value);
-                    return result;
-                } else if (Number.class.isAssignableFrom(valueType)) {
-                    @SuppressWarnings("unchecked")
-                    U result = (U) String.format("%d", value);
-                    return result;
-                }
-            } else if (Date.class.equals(expectedType)) {
-                if (String.class.isAssignableFrom(valueType)) {
-                    for (SimpleDateFormat format : dateFormats) {
-                        try {
-                            Date date = format.parse((String) value);
-                            if (date != null) {
-                                @SuppressWarnings("unchecked")
-                                U result = (U) date;
-                                return result;
-                            }
-                        } catch (ParseException e) {
-                            // Keep going.
-                        }
-                    }
-                }
-            }
-            throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
-                    + expectedType.getName());
-        }
-
-        static String convertCamelCaseToLowercaseWithUnderscores(String string) {
-            string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
-            return string.toLowerCase(Locale.US);
-        }
-
-        private static Object getUnderlyingJSONObject(Object obj) {
-            if (obj == null) {
-                return null;
-            }
-
-            Class<?> objClass = obj.getClass();
-            if (GraphObject.class.isAssignableFrom(objClass)) {
-                GraphObject graphObject = (GraphObject) obj;
-                return graphObject.getInnerJSONObject();
-            } else if (GraphObjectList.class.isAssignableFrom(objClass)) {
-                GraphObjectList<?> graphObjectList = (GraphObjectList<?>) obj;
-                return graphObjectList.getInnerJSONArray();
-            } else if (Iterable.class.isAssignableFrom(objClass)) {
-                JSONArray jsonArray = new JSONArray();
-                Iterable<?> iterable = (Iterable<?>) obj;
-                for (Object o : iterable ) {
-                    if (GraphObject.class.isAssignableFrom(o.getClass())) {
-                        jsonArray.put(((GraphObject)o).getInnerJSONObject());
-                    } else {
-                        jsonArray.put(o);
-                    }
-                }
-                return jsonArray;
-            }
-            return obj;
-        }
-
-        private abstract static class ProxyBase<STATE> implements InvocationHandler {
-            // Pre-loaded Method objects for the methods in java.lang.Object
-            private static final String EQUALS_METHOD = "equals";
-            private static final String TOSTRING_METHOD = "toString";
-
-            protected final STATE state;
-
-            protected ProxyBase(STATE state) {
-                this.state = state;
-            }
-
-            // Declared to return Object just to simplify implementation of proxy helpers.
-            protected final Object throwUnexpectedMethodSignature(Method method) {
-                throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
-                        + method.toString());
-            }
-
-            protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
-                String methodName = method.getName();
-                if (methodName.equals(EQUALS_METHOD)) {
-                    Object other = args[0];
-
-                    if (other == null) {
-                        return false;
-                    }
-
-                    InvocationHandler handler = Proxy.getInvocationHandler(other);
-                    if (!(handler instanceof GraphObjectProxy)) {
-                        return false;
-                    }
-                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
-                    return this.state.equals(otherProxy.state);
-                } else if (methodName.equals(TOSTRING_METHOD)) {
-                    return toString();
-                }
-
-                // For others, just defer to the implementation object.
-                return method.invoke(this.state, args);
-            }
-
-        }
-
-        private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
-            private static final String CLEAR_METHOD = "clear";
-            private static final String CONTAINSKEY_METHOD = "containsKey";
-            private static final String CONTAINSVALUE_METHOD = "containsValue";
-            private static final String ENTRYSET_METHOD = "entrySet";
-            private static final String GET_METHOD = "get";
-            private static final String ISEMPTY_METHOD = "isEmpty";
-            private static final String KEYSET_METHOD = "keySet";
-            private static final String PUT_METHOD = "put";
-            private static final String PUTALL_METHOD = "putAll";
-            private static final String REMOVE_METHOD = "remove";
-            private static final String SIZE_METHOD = "size";
-            private static final String VALUES_METHOD = "values";
-            private static final String CAST_METHOD = "cast";
-            private static final String CASTTOMAP_METHOD = "asMap";
-            private static final String GETPROPERTY_METHOD = "getProperty";
-            private static final String GETPROPERTYAS_METHOD = "getPropertyAs";
-            private static final String GETPROPERTYASLIST_METHOD = "getPropertyAsList";
-            private static final String SETPROPERTY_METHOD = "setProperty";
-            private static final String REMOVEPROPERTY_METHOD = "removeProperty";
-            private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
-
-            private final Class<?> graphObjectClass;
-
-            public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
-                super(state);
-                this.graphObjectClass = graphObjectClass;
-            }
-
-            @Override
-            public String toString() {
-                return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
-            }
-
-            @Override
-            public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                Class<?> declaringClass = method.getDeclaringClass();
-
-                if (declaringClass == Object.class) {
-                    return proxyObjectMethods(proxy, method, args);
-                } else if (declaringClass == Map.class) {
-                    return proxyMapMethods(method, args);
-                } else if (declaringClass == GraphObject.class) {
-                    return proxyGraphObjectMethods(proxy, method, args);
-                } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
-                    return proxyGraphObjectGettersAndSetters(method, args);
-                }
-
-                return throwUnexpectedMethodSignature(method);
-            }
-
-            private final Object proxyMapMethods(Method method, Object[] args) {
-                String methodName = method.getName();
-                if (methodName.equals(CLEAR_METHOD)) {
-                    JsonUtil.jsonObjectClear(this.state);
-                    return null;
-                } else if (methodName.equals(CONTAINSKEY_METHOD)) {
-                    return this.state.has((String) args[0]);
-                } else if (methodName.equals(CONTAINSVALUE_METHOD)) {
-                    return JsonUtil.jsonObjectContainsValue(this.state, args[0]);
-                } else if (methodName.equals(ENTRYSET_METHOD)) {
-                    return JsonUtil.jsonObjectEntrySet(this.state);
-                } else if (methodName.equals(GET_METHOD)) {
-                    return this.state.opt((String) args[0]);
-                } else if (methodName.equals(ISEMPTY_METHOD)) {
-                    return this.state.length() == 0;
-                } else if (methodName.equals(KEYSET_METHOD)) {
-                    return JsonUtil.jsonObjectKeySet(this.state);
-                } else if (methodName.equals(PUT_METHOD)) {
-                    return setJSONProperty(args);
-                } else if (methodName.equals(PUTALL_METHOD)) {
-                    Map<String, Object> map = null;
-                    if (args[0] instanceof Map<?, ?>) {
-                        @SuppressWarnings("unchecked")
-                        Map<String, Object> castMap = (Map<String, Object>) args[0];
-                        map = castMap;
-                    } else if (args[0] instanceof GraphObject) {
-                        map = ((GraphObject) args[0]).asMap();
-                    } else {
-                        return null;
-                    }
-                    JsonUtil.jsonObjectPutAll(this.state, map);
-                    return null;
-                } else if (methodName.equals(REMOVE_METHOD)) {
-                    this.state.remove((String) args[0]);
-                    return null;
-                } else if (methodName.equals(SIZE_METHOD)) {
-                    return this.state.length();
-                } else if (methodName.equals(VALUES_METHOD)) {
-                    return JsonUtil.jsonObjectValues(this.state);
-                }
-
-                return throwUnexpectedMethodSignature(method);
-            }
-
-            private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
-                String methodName = method.getName();
-                if (methodName.equals(CAST_METHOD)) {
-                    @SuppressWarnings("unchecked")
-                    Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
-
-                    if (graphObjectClass != null &&
-                            graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
-                        return proxy;
-                    }
-                    return Factory.createGraphObjectProxy(graphObjectClass, this.state);
-                } else if (methodName.equals(GETINNERJSONOBJECT_METHOD)) {
-                    InvocationHandler handler = Proxy.getInvocationHandler(proxy);
-                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
-                    return otherProxy.state;
-                } else if (methodName.equals(CASTTOMAP_METHOD)) {
-                    return Factory.createGraphObjectProxyForMap(this.state);
-                } else if (methodName.equals(GETPROPERTY_METHOD)) {
-                    return state.opt((String) args[0]);
-                } else if (methodName.equals(GETPROPERTYAS_METHOD)) {
-                    Object value = state.opt((String) args[0]);
-                    Class<?> expectedType = (Class<?>) args[1];
-
-                    return coerceValueToExpectedType(value, expectedType, null);
-                } else if (methodName.equals(GETPROPERTYASLIST_METHOD)) {
-                    Object value = state.opt((String) args[0]);
-                    final Class<?> expectedType = (Class<?>) args[1];
-
-                    ParameterizedType parameterizedType = new ParameterizedType() {
-                        @Override
-                        public Type[] getActualTypeArguments() {
-                            return new Type[]{ expectedType };
-                        }
-
-                        @Override
-                        public Type getOwnerType() {
-                            return null;
-                        }
-
-                        @Override
-                        public Type getRawType() {
-                            return GraphObjectList.class;
-                        }
-                    };
-                    return coerceValueToExpectedType(value, GraphObjectList.class, parameterizedType);
-                } else if (methodName.equals(SETPROPERTY_METHOD)) {
-                    return setJSONProperty(args);
-                } else if (methodName.equals(REMOVEPROPERTY_METHOD)) {
-                    this.state.remove((String) args[0]);
-                    return null;
-                }
-
-                return throwUnexpectedMethodSignature(method);
-            }
-
-            private Object createGraphObjectsFromParameters(CreateGraphObject createGraphObject, Object value) {
-                if (createGraphObject != null &&
-                        !Utility.isNullOrEmpty(createGraphObject.value())) {
-                    String propertyName = createGraphObject.value();
-                    if (List.class.isAssignableFrom(value.getClass())) {
-                        GraphObjectList<GraphObject> graphObjects = GraphObject.Factory.createList(GraphObject.class);
-                        @SuppressWarnings("unchecked")
-                        List<Object> values = (List<Object>)value;
-                        for (Object obj : values) {
-                            GraphObject graphObject = GraphObject.Factory.create();
-                            graphObject.setProperty(propertyName, obj);
-                            graphObjects.add(graphObject);
-                        }
-
-                        value = graphObjects;
-                    } else {
-                        GraphObject graphObject = GraphObject.Factory.create();
-                        graphObject.setProperty(propertyName, value);
-
-                        value = graphObject;
-                    }
-                }
-
-                return value;
-            }
-
-            private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
-                String methodName = method.getName();
-                int parameterCount = method.getParameterTypes().length;
-                PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
-
-                String key = propertyNameOverride != null ? propertyNameOverride.value() :
-                        convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
-
-                // If it's a get or a set on a GraphObject-derived class, we can handle it.
-                if (parameterCount == 0) {
-                    // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
-                    Object value = this.state.opt(key);
-
-                    Class<?> expectedType = method.getReturnType();
-
-                    Type genericReturnType = method.getGenericReturnType();
-                    ParameterizedType parameterizedReturnType = null;
-                    if (genericReturnType instanceof ParameterizedType) {
-                        parameterizedReturnType = (ParameterizedType) genericReturnType;
-                    }
-
-                    value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
-
-                    return value;
-                } else if (parameterCount == 1) {
-                    // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
-                    CreateGraphObject createGraphObjectAnnotation = method.getAnnotation(CreateGraphObject.class);
-                    Object value = createGraphObjectsFromParameters(createGraphObjectAnnotation, args[0]);
-
-                    // If this is a wrapped object, store the underlying JSONObject instead, in order to serialize
-                    // correctly.
-                    value = getUnderlyingJSONObject(value);
-                    this.state.putOpt(key, value);
-                    return null;
-                }
-
-                return throwUnexpectedMethodSignature(method);
-            }
-
-            private Object setJSONProperty(Object[] args) {
-                String name = (String) args[0];
-                Object property = args[1];
-                Object value = getUnderlyingJSONObject(property);
-                try {
-                    state.putOpt(name, value);
-                } catch (JSONException e) {
-                    throw new IllegalArgumentException(e);
-                }
-                return null;
-            }
-        }
-
-        private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
-            private final JSONArray state;
-            private final Class<?> itemType;
-
-            public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
-                Validate.notNull(state, "state");
-                Validate.notNull(itemType, "itemType");
-
-                this.state = state;
-                this.itemType = itemType;
-            }
-
-            @Override
-            public String toString() {
-                return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
-            }
-
-            @Override
-            public void add(int location, T object) {
-                // We only support adding at the end of the list, due to JSONArray restrictions.
-                if (location < 0) {
-                    throw new IndexOutOfBoundsException();
-                } else if (location < size()) {
-                    throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
-                }
-
-                put(location, object);
-            }
-
-            @Override
-            public T set(int location, T object) {
-                checkIndex(location);
-
-                T result = get(location);
-                put(location, object);
-                return result;
-            }
-
-            @Override
-            public int hashCode() {
-                return state.hashCode();
-            }
-
-            @Override
-            public boolean equals(Object obj) {
-                if (obj == null) {
-                    return false;
-                } else if (this == obj) {
-                    return true;
-                } else if (getClass() != obj.getClass()) {
-                    return false;
-                }
-                @SuppressWarnings("unchecked")
-                GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
-                return state.equals(other.state);
-            }
-
-            @SuppressWarnings("unchecked")
-            @Override
-            public T get(int location) {
-                checkIndex(location);
-
-                Object value = state.opt(location);
-
-                // Class<?> expectedType = method.getReturnType();
-                // Type genericType = method.getGenericReturnType();
-                T result = (T) coerceValueToExpectedType(value, itemType, null);
-
-                return result;
-            }
-
-            @Override
-            public int size() {
-                return state.length();
-            }
-
-            @Override
-            public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
-                if (GraphObject.class.isAssignableFrom(itemType)) {
-                    if (graphObjectClass.isAssignableFrom(itemType)) {
-                        @SuppressWarnings("unchecked")
-                        GraphObjectList<U> result = (GraphObjectList<U>)this;
-                        return result;
-                    }
-
-                    return createList(state, graphObjectClass);
-                } else {
-                    throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
-                            + itemType);
-                }
-            }
-
-            @Override
-            public final JSONArray getInnerJSONArray() {
-                return state;
-            }
-
-            @Override
-            public void clear() {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            public boolean remove(Object o) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            public boolean removeAll(Collection<?> c) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            public boolean retainAll(Collection<?> c) {
-                throw new UnsupportedOperationException();
-            }
-
-            private void checkIndex(int index) {
-                if (index < 0 || index >= state.length()) {
-                    throw new IndexOutOfBoundsException();
-                }
-            }
-
-            private void put(int index, T obj) {
-                Object underlyingObject = getUnderlyingJSONObject(obj);
-                try {
-                    state.put(index, underlyingObject);
-                } catch (JSONException e) {
-                    throw new IllegalArgumentException(e);
-                }
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/model/GraphObjectList.java b/facebook/src/com/facebook/model/GraphObjectList.java
deleted file mode 100644
index e4184fa34..000000000
--- a/facebook/src/com/facebook/model/GraphObjectList.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import org.json.JSONArray;
-
-import java.util.List;
-
-/**
- * GraphObjectList is the primary representation of a collection of graph objects in the Facebook SDK for Android.
- * It is not implemented by any concrete classes, but rather by a proxy (see the {@link com.facebook.model.GraphObject.Factory Factory}
- * class). A GraphObjectList can actually contain elements of any type, not just graph objects, but its principal
- * use in the SDK is to contain types derived from GraphObject.
- * <br/>
- *
- * @param <T> the type of elements in the list
- */
-public interface GraphObjectList<T> extends List<T> {
-    // cast method is only supported if T extends GraphObject
-    /**
-     * If T is derived from GraphObject, returns a new GraphObjectList exposing the same underlying data as a new
-     * GraphObject-derived type.
-     * @param graphObjectClass the GraphObject-derived type to return a list of
-     * @return a list representing the same underlying data, exposed as the new GraphObject-derived type
-     * @throws com.facebook.FacebookGraphObjectException if T does not derive from GraphObject
-     */
-    public <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass);
-    /**
-     * Gets the underlying JSONArray representation of the data.
-     * @return the underlying JSONArray representation of the data
-     */
-    public JSONArray getInnerJSONArray();
-}
diff --git a/facebook/src/com/facebook/model/GraphPlace.java b/facebook/src/com/facebook/model/GraphPlace.java
deleted file mode 100644
index 1d624b7f1..000000000
--- a/facebook/src/com/facebook/model/GraphPlace.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-/**
- * Provides a strongly-typed representation of a Place as defined by the Graph API.
- *
- * Note that this interface is intended to be used with GraphObject.Factory
- * and not implemented directly.
- */
-public interface GraphPlace extends GraphObject {
-    /**
-     * Returns the ID of the place.
-     * @return the ID of the place
-     */
-    public String getId();
-    /**
-     * Sets the ID of the place.
-     * @param id the ID of the place
-     */
-    public void setId(String id);
-
-    /**
-     * Returns the name of the place.
-     * @return the name of the place
-     */
-    public String getName();
-    /**
-     * Sets the name of the place.
-     * @param name the name of the place
-     */
-    public void setName(String name);
-
-    /**
-     * Returns the category of the place.
-     * @return the category of the place
-     */
-    public String getCategory();
-    /**
-     * Sets the category of the place.
-     * @param category the category of the place
-     */
-    public void setCategory(String category);
-
-    /**
-     * Returns the location of the place.
-     * @return the location of the place
-     */
-    public GraphLocation getLocation();
-    /**
-     * Sets the location of the place.
-     * @param location the location of the place
-     */
-    public void setLocation(GraphLocation location);
-}
diff --git a/facebook/src/com/facebook/model/GraphUser.java b/facebook/src/com/facebook/model/GraphUser.java
deleted file mode 100644
index c2daca049..000000000
--- a/facebook/src/com/facebook/model/GraphUser.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-/**
- * Provides a strongly-typed representation of a User as defined by the Graph API.
- *
- * Note that this interface is intended to be used with GraphObject.Factory
- * and not implemented directly.
- */
-public interface GraphUser extends GraphObject {
-    /**
-     * Returns the ID of the user.
-     * @return the ID of the user
-     */
-    public String getId();
-    /**
-     * Sets the ID of the user.
-     * @param id the ID of the user
-     */
-    public void setId(String id);
-
-    /**
-     * Returns the name of the user.
-     * @return the name of the user
-     */
-    public String getName();
-    /**
-     * Sets the name of the user.
-     * @param name the name of the user
-     */
-    public void setName(String name);
-
-    /**
-     * Returns the first name of the user.
-     * @return the first name of the user
-     */
-    public String getFirstName();
-    /**
-     * Sets the first name of the user.
-     * @param firstName the first name of the user
-     */
-    public void setFirstName(String firstName);
-
-    /**
-     * Returns the middle name of the user.
-     * @return the middle name of the user
-     */
-    public String getMiddleName();
-    /**
-     * Sets the middle name of the user.
-     * @param middleName the middle name of the user
-     */
-    public void setMiddleName(String middleName);
-
-    /**
-     * Returns the last name of the user.
-     * @return the last name of the user
-     */
-    public String getLastName();
-    /**
-     * Sets the last name of the user.
-     * @param lastName the last name of the user
-     */
-    public void setLastName(String lastName);
-
-    /**
-     * Returns the Facebook URL of the user.
-     * @return the Facebook URL of the user
-     */
-    public String getLink();
-    /**
-     * Sets the Facebook URL of the user.
-     * @param link the Facebook URL of the user
-     */
-    public void setLink(String link);
-
-    /**
-     * Returns the Facebook username of the user.
-     * @return the Facebook username of the user
-     */
-    public String getUsername();
-    /**
-     * Sets the Facebook username of the user.
-     * @param username the Facebook username of the user
-     */
-    public void setUsername(String username);
-
-    /**
-     * Returns the birthday of the user.
-     * @return the birthday of the user
-     */
-    public String getBirthday();
-    /**
-     * Sets the birthday of the user.
-     * @param birthday the birthday of the user
-     */
-    public void setBirthday(String birthday);
-
-    /**
-     * Returns the current city of the user.
-     * @return the current city of the user
-     */
-    public GraphLocation getLocation();
-    /**
-     * Sets the current city of the user.
-     * @param location the current city of the user
-     */
-    public void setLocation(GraphLocation location);
-}
diff --git a/facebook/src/com/facebook/model/OpenGraphAction.java b/facebook/src/com/facebook/model/OpenGraphAction.java
deleted file mode 100644
index d82d34a80..000000000
--- a/facebook/src/com/facebook/model/OpenGraphAction.java
+++ /dev/null
@@ -1,306 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import org.json.JSONObject;
-
-import java.util.Date;
-import java.util.List;
-
-/**
- * Provides a strongly-typed representation of an Open Graph Action.
- * For more documentation of OG Actions, see: https://developers.facebook.com/docs/opengraph/actions/
- *
- * Note that this interface is intended to be used with GraphObject.Factory or OpenGraphAction.Factory
- * and not implemented directly.
- */
-public interface OpenGraphAction extends GraphObject {
-    /**
-     * Gets the ID of the action.
-     * @return the ID
-     */
-    String getId();
-
-    /**
-     * Sets the ID of the action.
-     * @param id the ID
-     */
-    void setId(String id);
-
-    /**
-     * Gets the type of the action, which is a string in the form "mynamespace:mytype".
-     * @return the type
-     */
-    String getType();
-
-    /**
-     * Sets the type of the action, which is a string in the form "mynamespace:mytype".
-     * @param type the type
-     */
-    void setType(String type);
-
-    /**
-     * Gets the start time of the action.
-     * @return the start time
-     */
-    Date getStartTime();
-
-    /**
-     * Sets the start time of the action.
-     * @param startTime the start time
-     */
-    void setStartTime(Date startTime);
-
-    /**
-     * Gets the end time of the action.
-     * @return the end time
-     */
-    Date getEndTime();
-
-    /**
-     * Sets the end time of the action.
-     * @param endTime the end time
-     */
-    void setEndTime(Date endTime);
-
-    /**
-     * Gets the time the action was published, if any.
-     * @return the publish time
-     */
-    Date getPublishTime();
-
-    /**
-     * Sets the time the action was published.
-     * @param publishTime the publish time
-     */
-    void setPublishTime(Date publishTime);
-
-    /**
-     * Gets the time the action was created.
-     * @return the creation time
-     */
-    public Date getCreatedTime();
-
-    /**
-     * Sets the time the action was created.
-     * @param createdTime the creation time
-     */
-    public void setCreatedTime(Date createdTime);
-
-    /**
-     * Gets the time the action expires at.
-     * @return the expiration time
-     */
-    public Date getExpiresTime();
-
-    /**
-     * Sets the time the action expires at.
-     * @param expiresTime the expiration time
-     */
-    public void setExpiresTime(Date expiresTime);
-
-    /**
-     * Gets the unique string which will be passed to the OG Action owner's website
-     * when a user clicks through this action on Facebook.
-     * @return the ref string
-     */
-    String getRef();
-
-    /**
-     * Sets the unique string which will be passed to the OG Action owner's website
-     * when a user clicks through this action on Facebook.
-     * @param ref the ref string
-     */
-    void setRef(String ref);
-
-    /**
-     * Gets the message assoicated with the action.
-     * @return the message
-     */
-    String getMessage();
-
-    /**
-     * Sets the message associated with the action.
-     * @param message the message
-     */
-    void setMessage(String message);
-
-    /**
-     * Gets the place where the action took place.
-     * @return the place
-     */
-    GraphPlace getPlace();
-
-    /**
-     * Sets the place where the action took place.
-     * @param place the place
-     */
-    void setPlace(GraphPlace place);
-
-    /**
-     * Gets the list of profiles that were tagged in the action.
-     * @return the profiles that were tagged in the action
-     */
-    GraphObjectList<GraphObject> getTags();
-
-    /**
-     * Sets the list of profiles that were tagged in the action.
-     * @param tags the profiles that were tagged in the action
-     */
-    void setTags(List<? extends GraphObject> tags);
-
-    /**
-     * Gets the images that were associated with the action.
-     * @return the images
-     */
-    List<JSONObject> getImage();
-
-    /**
-     * Sets the images that were associated with the action.
-     * @param image the images
-     */
-    void setImage(List<JSONObject> image);
-
-    /**
-     * Sets the images associated with the Open Graph action by specifying their URLs. This is a helper
-     * that will create GraphObjects with the correct URLs and populate the property with those objects.
-     * @param urls the URLs
-     */
-    @CreateGraphObject("url")
-    @PropertyName("image")
-    void setImageUrls(List<String> urls);
-
-    /**
-     * Gets the from-user associated with the action.
-     * @return the user
-     */
-    GraphUser getFrom();
-
-    /**
-     * Sets the from-user associated with the action.
-     * @param from the from-user
-     */
-    void setFrom(GraphUser from);
-
-    /**
-     * Gets the 'likes' that have been performed on this action.
-     * @return the likes
-     */
-    public JSONObject getLikes();
-
-    /**
-     * Sets the 'likes' that have been performed on this action.
-     * @param likes the likes
-     */
-    public void setLikes(JSONObject likes);
-
-    /**
-     * Gets the application that created this action.
-     * @return the application
-     */
-    GraphObject getApplication();
-
-    /**
-     * Sets the application that created this action.
-     * @param application the application
-     */
-    void setApplication(GraphObject application);
-
-    /**
-     * Gets the comments that have been made on this action.
-     * @return the comments
-     */
-    public JSONObject getComments();
-
-    /**
-     * Sets the comments that have been made on this action.
-     * @param comments the comments
-     */
-    void setComments(JSONObject comments);
-
-    /**
-     * Gets the type-specific data for this action; for instance, any properties
-     * referencing Open Graph objects will appear under here.
-     * @return a GraphObject representing the type-specific data
-     */
-    GraphObject getData();
-
-    /**
-     * Sets the type-specific data for this action.
-     * @param data a GraphObject representing the type-specific data
-     */
-    void setData(GraphObject data);
-
-
-    /**
-     * Gets whether the action has been explicitly shared by the user. See
-     * <a href="https://developers.facebook.com/docs/opengraph/guides/explicit-sharing/">Explicit Sharing</a> for
-     * more information.
-     * @return true if this action was explicitly shared
-     */
-    @PropertyName("fb:explicitly_shared")
-    boolean getExplicitlyShared();
-
-    /**
-     * Sets whether the action has been explicitly shared by the user. See
-     * <a href="https://developers.facebook.com/docs/opengraph/guides/explicit-sharing/">Explicit Sharing</a> for
-     * more information. You should only specify this property if explicit sharing has been enabled for an
-     * Open Graph action type.
-     * @param explicitlyShared true if this action was explicitly shared
-     */
-    @PropertyName("fb:explicitly_shared")
-    void setExplicitlyShared(boolean explicitlyShared);
-
-    /**
-     * Exposes helpers for creating instances of OpenGraphAction.
-     */
-    final class Factory {
-        /**
-         * Creates an OpenGraphAction suitable for posting via, e.g., a native Share dialog.
-         * @return an OpenGraphAction
-         */
-        @Deprecated
-        public static OpenGraphAction createForPost() {
-            return createForPost(OpenGraphAction.class, null);
-        }
-
-        /**
-         * Creates an OpenGraphAction suitable for posting via, e.g., a native Share dialog.
-         * @param type the Open Graph action type for the action, or null if it will be specified later
-         * @return an OpenGraphAction
-         */
-        public static OpenGraphAction createForPost(String type) {
-            return createForPost(OpenGraphAction.class, type);
-        }
-
-        /**
-         * Creates an OpenGraphAction suitable for posting via, e.g., a native Share dialog.
-         * @param type the Open Graph action type for the action, or null if it will be specified later
-         * @param graphObjectClass the OpenGraphAction-derived type to return
-         * @return an OpenGraphAction
-         */
-        public static <T extends OpenGraphAction> T createForPost(Class<T> graphObjectClass, String type) {
-            T object = GraphObject.Factory.create(graphObjectClass);
-
-            if (type != null) {
-                object.setType(type);
-            }
-
-            return object;
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/model/OpenGraphObject.java b/facebook/src/com/facebook/model/OpenGraphObject.java
deleted file mode 100644
index 285de4198..000000000
--- a/facebook/src/com/facebook/model/OpenGraphObject.java
+++ /dev/null
@@ -1,318 +0,0 @@
-package com.facebook.model;
-
-import com.facebook.internal.NativeProtocol;
-
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-/**
- * Provides a strongly-typed representation of an Open Graph Object.
- * For more documentation of OG Objects, see: https://developers.facebook.com/docs/opengraph/using-object-api/
- *
- * Note that this interface is intended to be used with GraphObject.Factory or OpenGraphObject.Factory
- * and not implemented directly.
- */
-public interface OpenGraphObject extends GraphObject {
-    /**
-     * Gets the ID of the object.
-     * @return the ID
-     */
-    String getId();
-
-    /**
-     * Sets the ID of the object.
-     * @param id the ID
-     */
-    void setId(String id);
-
-    /**
-     * Gets the type of the object, which is a string in the form "mynamespace:mytype".
-     * @return the type
-     */
-    String getType();
-
-    /**
-     * Sets the type of the object, which is a string in the form "mynamespace:mytype".
-     * @param type the type
-     */
-    void setType(String type);
-
-    /**
-     * Gets the URL associated with the Open Graph object.
-     * @return the URL
-     */
-    String getUrl();
-
-    /**
-     * Sets the URL associated with the Open Graph object.
-     * @param url the URL
-     */
-    void setUrl(String url);
-
-    /**
-     * Gets the title of the Open Graph object.
-     * @return the title
-     */
-    String getTitle();
-
-    /**
-     * Sets the title of the Open Graph object.
-     * @param title the title
-     */
-    void setTitle(String title);
-
-
-    /**
-     * Gets the description of the Open Graph object.
-     * @return the description
-     */
-    String getDescription();
-
-    /**
-     * Sets the description of the Open Graph Object
-     * @param description the description
-     */
-    void setDescription(String description);
-
-    /**
-     * Gets the images associated with the Open Graph object.
-     * @return the images
-     */
-    GraphObjectList<GraphObject> getImage();
-
-    /**
-     * Sets the images associated with the Open Graph object.
-     * @param images the images
-     */
-    void setImage(GraphObjectList<GraphObject> images);
-
-    /**
-     * Sets the images associated with the Open Graph object by specifying their URLs. This is a helper
-     * that will create GraphObjects with the correct URLs and populate the property with those objects.
-     * @param urls the URLs
-     */
-    @CreateGraphObject("url")
-    @PropertyName("image")
-    void setImageUrls(List<String> urls);
-
-    /**
-     * Gets the videos associated with the Open Graph object.
-     * @return the videos
-     */
-    GraphObjectList<GraphObject> getVideo();
-
-    /**
-     * Sets the videos associated with the Open Graph object.
-     * @param videos the videos
-     */
-    void setVideo(GraphObjectList<GraphObject> videos);
-
-    /**
-     * Gets the audio associated with the Open Graph object.
-     * @return the audio
-     */
-    GraphObjectList<GraphObject> getAudio();
-
-    /**
-     * Sets the audio associated with the Open Graph object.
-     * @param audios the audio
-     */
-    void setAudio(GraphObjectList<GraphObject> audios);
-
-    /**
-     * Gets the "determiner" for the Open Graph object. This is the word such as "a", "an", or "the" that will
-     * appear before the title of the object.
-     * @return the determiner string
-     */
-    String getDeterminer();
-
-    /**
-     * Sets the "determiner" for the Open Graph object. This is the word such as "a", "an", or "the" that will
-     * appear before the title of the object.
-     * @param determiner the determiner string
-     */
-    void setDeterminer(String determiner);
-
-    /**
-     * Gets the list of related resources for the Open Graph object.
-     * @return a list of URLs of related resources
-     */
-    List<String> getSeeAlso();
-
-    /**
-     * Sets the list of related resources for the Open Graph object.
-     * @param seeAlso a list of URLs of related resources
-     */
-    void setSeeAlso(List<String> seeAlso);
-
-    /**
-     * Gets the name of the site hosting the Open Graph object, if any.
-     * @return the name of the site
-     */
-    String getSiteName();
-
-    /**
-     * Sets the name of the site hosting the Open Graph object.
-     * @param siteName the name of the site
-     */
-    void setSiteName(String siteName);
-
-    /**
-     * Gets the date and time the Open Graph object was created.
-     * @return the creation time
-     */
-    Date getCreatedTime();
-
-    /**
-     * Sets the date and time the Open Graph object was created.
-     * @param createdTime the creation time
-     */
-    void setCreatedTime(Date createdTime);
-
-    /**
-     * Gets the date and time the Open Graph object was last updated.
-     * @return the update time
-     */
-    Date getUpdatedTime();
-
-    /**
-     * Sets the date and time the Open Graph object was last updated.
-     * @param updatedTime the update time
-     */
-    void setUpdatedTime(Date updatedTime);
-
-    /**
-     * Gets the application that created this object.
-     * @return the application
-     */
-    GraphObject getApplication();
-
-    /**
-     * Sets the application that created this object.
-     * @param application the application
-     */
-    void setApplication(GraphObject application);
-
-    /**
-     * Gets whether the Open Graph object was created by scraping a Web resource or not.
-     * @return true if the Open Graph object was created by scraping the Web, false if not
-     */
-    boolean getIsScraped();
-
-    /**
-     * Sets whether the Open Graph object was created by scraping a Web resource or not.
-     * @param isScraped true if the Open Graph object was created by scraping the Web, false if not
-     */
-    void setIsScraped(boolean isScraped);
-
-    /**
-     * Gets the Open Graph action which was created when this Open Graph action was posted, if it is a user-owned
-     * object, otherwise null. The post action controls the privacy of this object.
-     * @return the ID of the post action, if any, or null
-     */
-    String getPostActionId();
-
-    /**
-     * Sets the Open Graph action which was created when this Open Graph action was posted, if it is a user-owned
-     * object, otherwise null. The post action controls the privacy of this object.
-     * @param postActionId the ID of the post action, if any, or null
-     */
-    void setPostActionId(String postActionId);
-
-    /**
-     * Gets the type-specific properties of the Open Graph object, if any. Any custom properties that are defined on an
-     * application-defined Open Graph object type will appear here.
-     * @return a GraphObject containing the type-specific properties
-     */
-    GraphObject getData();
-
-    /**
-     * Sets the type-specific properties of the Open Graph object, if any. Any custom properties that are defined on an
-     * application-defined Open Graph object type will appear here.
-     * @param data a GraphObject containing the type-specific properties
-     */
-    void setData(GraphObject data);
-
-    /**
-     * Gets whether the object represents a new object that should be created as part of publishing via, e.g., the
-     * native Share dialog. This flag has no effect on explicit publishing of an action via, e.g., a POST to the
-     * '/me/objects/object_type' endpoint.
-     * @return true if the native Share dialog should create the object as part of publishing an action, false if not
-     */
-    @PropertyName(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)
-    boolean getCreateObject();
-
-    /**
-     * Sets whether the object represents a new object that should be created as part of publishing via, e.g., the
-     * native Share dialog. This flag has no effect on explicit publishing of an action via, e.g., a POST to the
-     * '/me/objects/object_type' endpoint.
-     * @param createObject true if the native Share dialog should create the object as part of publishing an action,
-     *                     false if not
-     */
-    @PropertyName(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)
-    void setCreateObject(boolean createObject);
-
-    /**
-     * Exposes helpers for creating instances of OpenGraphObject.
-     */
-    final class Factory {
-        /**
-         * Creates an OpenGraphObject suitable for posting via, e.g., a native Share dialog. The object will have
-         * no properties other than a 'create_object' and 'data' property, ready to be populated.
-         * @param type the Open Graph object type for the object, or null if it will be specified later
-         * @return an OpenGraphObject
-         */
-        public static OpenGraphObject createForPost(String type) {
-            return createForPost(OpenGraphObject.class, type);
-        }
-
-        /**
-         * Creates an OpenGraphObject suitable for posting via, e.g., a native Share dialog. The object will have
-         * no properties other than a 'create_object' and 'data' property, ready to be populated.
-         * @param graphObjectClass the OpenGraphObject-derived type to return
-         * @param type the Open Graph object type for the object, or null if it will be specified later
-         * @return an OpenGraphObject
-         */
-        public static <T extends OpenGraphObject> T createForPost(Class<T> graphObjectClass, String type) {
-            return createForPost(graphObjectClass, type, null, null, null, null);
-        }
-
-        /**
-         * Creates an OpenGraphObject suitable for posting via, e.g., a native Share dialog. The object will have
-         * the specified properties, plus a 'create_object' and 'data' property, ready to be populated.
-         * @param graphObjectClass the OpenGraphObject-derived type to return
-         * @param type the Open Graph object type for the object, or null if it will be specified later
-         * @param title the title of the object, or null if it will be specified later
-         * @param imageUrl the URL of an image associated with the object, or null
-         * @param url the URL associated with the object, or null
-         * @param description the description of the object, or null
-         * @return an OpenGraphObject
-         */
-        public static <T extends OpenGraphObject> T createForPost(Class<T> graphObjectClass, String type, String title,
-                String imageUrl, String url, String description) {
-            T object = GraphObject.Factory.create(graphObjectClass);
-
-            if (type != null) {
-                object.setType(type);
-            }
-            if (title != null) {
-                object.setTitle(title);
-            }
-            if (imageUrl != null) {
-                object.setImageUrls(Arrays.asList(imageUrl));
-            }
-            if (url != null) {
-                object.setUrl(url);
-            }
-            if (description != null) {
-                object.setDescription(description);
-            }
-
-            object.setCreateObject(true);
-            object.setData(GraphObject.Factory.create());
-
-            return object;
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/model/PropertyName.java b/facebook/src/com/facebook/model/PropertyName.java
deleted file mode 100644
index 1e705fe6f..000000000
--- a/facebook/src/com/facebook/model/PropertyName.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/**
- * Use this annotation on getters and setters in an interface that derives from
- * GraphObject, if you wish to override the default property name that is inferred
- * from the name of the method.
- *
- * If this annotation is specified on a method, it must contain a non-empty String
- * value that represents the name of the property that the method is a getter or setter
- * for.
- */
-@Retention(RetentionPolicy.RUNTIME)
-public @interface PropertyName {
-    String value();
-}
diff --git a/facebook/src/com/facebook/share/ShareApi.java b/facebook/src/com/facebook/share/ShareApi.java
new file mode 100644
index 000000000..adb6f1709
--- /dev/null
+++ b/facebook/src/com/facebook/share/ShareApi.java
@@ -0,0 +1,661 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share;
+
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookGraphResponseException;
+import com.facebook.FacebookRequestError;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.HttpMethod;
+import com.facebook.internal.CollectionMapper;
+import com.facebook.internal.Mutable;
+import com.facebook.internal.Utility;
+import com.facebook.share.internal.ShareContentValidation;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.internal.VideoUploader;
+import com.facebook.share.model.*;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.FileNotFoundException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.*;
+
+/**
+ * Provides an interface for sharing through the graph API. Using this class requires an access
+ * token in AccessToken.currentAccessToken that has been granted the "publish_actions" permission.
+ */
+public final class ShareApi {
+    private static final String TAG = "ShareApi";
+
+    private String message;
+    private final ShareContent shareContent;
+
+    /**
+     * Convenience method to share a piece of content.
+     *
+     * @param shareContent the content to share.
+     * @param callback     the callback to call once the share is complete.
+     */
+    public static void share(
+            final ShareContent shareContent,
+            final FacebookCallback<Sharer.Result> callback) {
+        new ShareApi(shareContent)
+                .share(callback);
+    }
+
+    /**
+     * Constructs a new instance.
+     *
+     * @param shareContent the content to share.
+     */
+    public ShareApi(final ShareContent shareContent) {
+        this.shareContent = shareContent;
+    }
+
+    /**
+     * Returns the message the person has provided through the custom dialog that will accompany the
+     * share content.
+     * @return the message.
+     */
+    public String getMessage() {
+        return this.message;
+    }
+
+    /**
+     * Sets the message the person has provided through the custom dialog that will accompany the
+     * share content.
+     * @param message the message.
+     */
+    public void setMessage(final String message) {
+        this.message = message;
+    }
+
+    /**
+     * Returns the content to be shared.
+     *
+     * @return the content to be shared.
+     */
+    public ShareContent getShareContent() {
+        return this.shareContent;
+    }
+
+    /**
+     * Returns true if the content can be shared. Warns if the access token is missing the
+     * publish_actions permission. Doesn't fail when this permission is missing, because the app
+     * could have been granted that permission in another installation.
+     *
+     * @return true if the content can be shared.
+     */
+    public boolean canShare() {
+        if (this.getShareContent() == null) {
+            return false;
+        }
+        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken == null) {
+            return false;
+        }
+        final Set<String> permissions = accessToken.getPermissions();
+        if (permissions == null || !permissions.contains("publish_actions")) {
+            Log.w(TAG, "The publish_actions permissions are missing, the share will fail unless" +
+                    " this app was authorized to publish in another installation.");
+        }
+
+        return true;
+    }
+
+    /**
+     * Share the content.
+     *
+     * @param callback the callback to call once the share is complete.
+     */
+    public void share(FacebookCallback<Sharer.Result> callback) {
+        if (!this.canShare()) {
+            ShareInternalUtility.invokeCallbackWithError(
+                    callback, "Insufficient permissions for sharing content via Api.");
+            return;
+        }
+        final ShareContent shareContent = this.getShareContent();
+
+        // Validate the share content
+        try {
+            ShareContentValidation.validateForApiShare(shareContent);
+        } catch (FacebookException ex) {
+            ShareInternalUtility.invokeCallbackWithException(callback, ex);
+            return;
+        }
+
+        if (shareContent instanceof ShareLinkContent) {
+            this.shareLinkContent((ShareLinkContent) shareContent, callback);
+        } else if (shareContent instanceof SharePhotoContent) {
+            this.sharePhotoContent((SharePhotoContent) shareContent, callback);
+        } else if (shareContent instanceof ShareVideoContent) {
+            this.shareVideoContent((ShareVideoContent) shareContent, callback);
+        } else if (shareContent instanceof ShareOpenGraphContent) {
+            this.shareOpenGraphContent((ShareOpenGraphContent) shareContent, callback);
+        }
+
+    }
+
+    private void addCommonParameters(final Bundle bundle, ShareContent shareContent) {
+        final List<String> peopleIds = shareContent.getPeopleIds();
+        if ((peopleIds != null) && !peopleIds.isEmpty()) {
+            bundle.putString("tags", TextUtils.join(", ", peopleIds));
+        }
+        bundle.putString("place", shareContent.getPlaceId());
+        bundle.putString("ref", shareContent.getRef());
+    }
+
+    private void shareOpenGraphContent(final ShareOpenGraphContent openGraphContent,
+                                       final FacebookCallback<Sharer.Result> callback) {
+        // In order to create a new Open Graph action using a custom object that does not already
+        // exist (objectID or URL), you must first send a request to post the object and then
+        // another to post the action.  If a local image is supplied with the object or action, that
+        // must be staged first and then referenced by the staging URL that is returned by that
+        // request.
+        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                final JSONObject data = response.getJSONObject();
+                final String postId = (data == null ? null : data.optString("id"));
+                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
+            }
+        };
+        final ShareOpenGraphAction action = openGraphContent.getAction();
+        final Bundle parameters = action.getBundle();
+        this.addCommonParameters(parameters, openGraphContent);
+        parameters.putString("message", this.getMessage());
+        final CollectionMapper.OnMapperCompleteListener stageCallback = new CollectionMapper
+                .OnMapperCompleteListener() {
+            @Override
+            public void onComplete() {
+                try {
+                    handleImagesOnAction(parameters);
+
+                    new GraphRequest(
+                            AccessToken.getCurrentAccessToken(),
+                            "/me/" + URLEncoder.encode(action.getActionType(), "UTF-8"),
+                            parameters,
+                            HttpMethod.POST,
+                            requestCallback).executeAsync();
+                } catch (final UnsupportedEncodingException ex) {
+                    ShareInternalUtility.invokeCallbackWithException(callback, ex);
+                }
+            }
+
+            @Override
+            public void onError(FacebookException exception) {
+                ShareInternalUtility.invokeCallbackWithException(callback, exception);
+            }
+        };
+        this.stageOpenGraphAction(parameters, stageCallback);
+    }
+
+    private static void handleImagesOnAction(Bundle parameters) {
+        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
+        // we need to pass the entire values of the contents of the 'image' property, as they
+        // contain important metadata beyond just a URL.
+        String imageStr = parameters.getString("image");
+        if (imageStr != null) {
+            try {
+                // Check to see if this is an json array. Will throw if not
+                JSONArray images = new JSONArray(imageStr);
+                for (int i = 0; i < images.length(); ++i) {
+                    JSONObject jsonImage = images.optJSONObject(i);
+                    if(jsonImage != null) {
+                        putImageInBundleWithArrayFormat(parameters, i, jsonImage);
+                    } else {
+                        // If we don't have jsonImage we probably just have a url
+                        String url = images.getString(i);
+                        parameters.putString(String.format(Locale.ROOT, "image[%d][url]", i), url);
+                    }
+                }
+                parameters.remove("image");
+                return;
+            } catch (JSONException ex) {
+                // We couldn't parse the string as an array
+            }
+
+            // If the image is not in an array it might just be an single photo
+            try {
+                JSONObject image = new JSONObject(imageStr);
+                putImageInBundleWithArrayFormat(parameters, 0, image);
+                parameters.remove("image");
+            } catch (JSONException exception) {
+                // The image was not in array format or a json object and can be safely passed
+                // without modification
+            }
+        }
+    }
+
+    private static void putImageInBundleWithArrayFormat(
+            Bundle parameters,
+            int index,
+            JSONObject image) throws JSONException{
+        Iterator<String> keys = image.keys();
+        while (keys.hasNext()) {
+            String property = keys.next();
+            String key = String.format(Locale.ROOT, "image[%d][%s]", index, property);
+            parameters.putString(key, image.get(property).toString());
+        }
+    }
+
+    private void sharePhotoContent(final SharePhotoContent photoContent,
+                                   final FacebookCallback<Sharer.Result> callback) {
+        final Mutable<Integer> requestCount = new Mutable<Integer>(0);
+        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        final ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
+        final ArrayList<JSONObject> results = new ArrayList<JSONObject>();
+        final ArrayList<GraphResponse> errorResponses = new ArrayList<GraphResponse>();
+        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                final JSONObject result = response.getJSONObject();
+                if (result != null) {
+                    results.add(result);
+                }
+                if (response.getError() != null) {
+                    errorResponses.add(response);
+                }
+                requestCount.value -= 1;
+                if (requestCount.value == 0) {
+                    if (!errorResponses.isEmpty()) {
+                        ShareInternalUtility.invokeCallbackWithResults(
+                                callback,
+                                null,
+                                errorResponses.get(0));
+                    } else if (!results.isEmpty()) {
+                        final String postId = results.get(0).optString("id");
+                        ShareInternalUtility.invokeCallbackWithResults(
+                                callback,
+                                postId,
+                                response);
+                    }
+                }
+            }
+        };
+        try {
+            for (SharePhoto photo : photoContent.getPhotos()) {
+                final Bitmap bitmap = photo.getBitmap();
+                final Uri photoUri = photo.getImageUrl();
+                String caption = photo.getCaption();
+                if (caption == null) {
+                    caption = this.getMessage();
+                }
+                if (bitmap != null) {
+                    requests.add(ShareInternalUtility.newUploadPhotoRequest(
+                            accessToken,
+                            bitmap,
+                            caption,
+                            requestCallback));
+                } else if (photoUri != null) {
+                    requests.add(ShareInternalUtility.newUploadPhotoRequest(
+                            accessToken,
+                            photoUri,
+                            caption,
+                            requestCallback));
+                }
+            }
+            requestCount.value += requests.size();
+            for (GraphRequest request : requests) {
+                request.executeAsync();
+            }
+        } catch (final FileNotFoundException ex) {
+            ShareInternalUtility.invokeCallbackWithException(callback, ex);
+        }
+    }
+
+    private void shareLinkContent(final ShareLinkContent linkContent,
+                                  final FacebookCallback<Sharer.Result> callback) {
+        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                final JSONObject data = response.getJSONObject();
+                final String postId = (data == null ? null : data.optString("id"));
+                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
+            }
+        };
+        final Bundle parameters = new Bundle();
+        this.addCommonParameters(parameters, linkContent);
+        parameters.putString("message", this.getMessage());
+        parameters.putString("link", Utility.getUriString(linkContent.getContentUrl()));
+        parameters.putString("picture", Utility.getUriString(linkContent.getImageUrl()));
+        parameters.putString("name", linkContent.getContentTitle());
+        parameters.putString("description", linkContent.getContentDescription());
+        parameters.putString("ref", linkContent.getRef());
+        new GraphRequest(
+                AccessToken.getCurrentAccessToken(),
+                "/me/feed",
+                parameters,
+                HttpMethod.POST,
+                requestCallback).executeAsync();
+    }
+
+    private void shareVideoContent(final ShareVideoContent videoContent,
+                                   final FacebookCallback<Sharer.Result> callback) {
+        try {
+            VideoUploader.uploadAsync(videoContent, callback);
+        } catch (final FileNotFoundException ex) {
+            ShareInternalUtility.invokeCallbackWithException(callback, ex);
+        }
+    }
+
+    private static void stageArrayList(final ArrayList arrayList,
+                                       final CollectionMapper.OnMapValueCompleteListener
+                                               onArrayListStagedListener) {
+        final JSONArray stagedObject = new JSONArray();
+        final CollectionMapper.Collection<Integer> collection = new CollectionMapper
+                .Collection<Integer>() {
+            @Override
+            public Iterator<Integer> keyIterator() {
+                final int size = arrayList.size();
+                final Mutable<Integer> current = new Mutable<Integer>(0);
+                return new Iterator<Integer>() {
+                    @Override
+                    public boolean hasNext() {
+                        return current.value < size;
+                    }
+
+                    @Override
+                    public Integer next() {
+                        return current.value++;
+                    }
+
+                    @Override
+                    public void remove() {
+                    }
+                };
+            }
+
+            @Override
+            public Object get(Integer key) {
+                return arrayList.get(key);
+            }
+
+            @Override
+            public void set(Integer key,
+                            Object value,
+                            CollectionMapper.OnErrorListener onErrorListener) {
+                try {
+                    stagedObject.put(key, value);
+                } catch (final JSONException ex) {
+                    String message = ex.getLocalizedMessage();
+                    if (message == null) {
+                        message = "Error staging object.";
+                    }
+                    onErrorListener.onError(new FacebookException(message));
+                }
+            }
+        };
+        final CollectionMapper.OnMapperCompleteListener onStagedArrayMapperCompleteListener =
+                new CollectionMapper.OnMapperCompleteListener() {
+                    @Override
+                    public void onComplete() {
+                        onArrayListStagedListener.onComplete(stagedObject);
+                    }
+
+                    @Override
+                    public void onError(FacebookException exception) {
+                        onArrayListStagedListener.onError(exception);
+                    }
+                };
+        stageCollectionValues(collection, onStagedArrayMapperCompleteListener);
+    }
+
+    private static <T> void stageCollectionValues(final CollectionMapper.Collection<T> collection,
+                                                  final CollectionMapper.OnMapperCompleteListener
+                                                          onCollectionValuesStagedListener) {
+        final CollectionMapper.ValueMapper valueMapper = new CollectionMapper.ValueMapper() {
+            @Override
+            public void mapValue(Object value,
+                                 CollectionMapper.OnMapValueCompleteListener
+                                         onMapValueCompleteListener) {
+                if (value instanceof ArrayList) {
+                    stageArrayList((ArrayList) value, onMapValueCompleteListener);
+                } else if (value instanceof ShareOpenGraphObject) {
+                    stageOpenGraphObject(
+                            (ShareOpenGraphObject) value,
+                            onMapValueCompleteListener);
+                } else if (value instanceof SharePhoto) {
+                    stagePhoto((SharePhoto) value, onMapValueCompleteListener);
+                } else {
+                    onMapValueCompleteListener.onComplete(value);
+                }
+            }
+        };
+        CollectionMapper.iterate(collection, valueMapper, onCollectionValuesStagedListener);
+    }
+
+    private static void stageOpenGraphAction(final Bundle parameters,
+                                             final CollectionMapper.OnMapperCompleteListener
+                                                     onOpenGraphActionStagedListener) {
+        final CollectionMapper.Collection<String> collection = new CollectionMapper
+                .Collection<String>() {
+            @Override
+            public Iterator<String> keyIterator() {
+                return parameters.keySet().iterator();
+            }
+
+            @Override
+            public Object get(String key) {
+                return parameters.get(key);
+            }
+
+            @Override
+            public void set(String key,
+                            Object value,
+                            CollectionMapper.OnErrorListener onErrorListener) {
+                if (!Utility.putJSONValueInBundle(parameters, key, value)) {
+                    onErrorListener.onError(
+                            new FacebookException("Unexpected value: " + value.toString()));
+                }
+            }
+        };
+        stageCollectionValues(collection, onOpenGraphActionStagedListener);
+    }
+
+    private static void stageOpenGraphObject(final ShareOpenGraphObject object,
+                                             final CollectionMapper.OnMapValueCompleteListener
+                                                     onOpenGraphObjectStagedListener) {
+        String type = object.getString("type");
+        if (type == null) {
+            type = object.getString("og:type");
+        }
+
+        if (type == null) {
+            onOpenGraphObjectStagedListener.onError(
+                    new FacebookException("Open Graph objects must contain a type value."));
+            return;
+        }
+        final JSONObject stagedObject = new JSONObject();
+        final CollectionMapper.Collection<String> collection = new CollectionMapper
+                .Collection<String>() {
+            @Override
+            public Iterator<String> keyIterator() {
+                return object.keySet().iterator();
+            }
+
+            @Override
+            public Object get(String key) {
+                return object.get(key);
+            }
+
+            @Override
+            public void set(String key,
+                            Object value,
+                            CollectionMapper.OnErrorListener onErrorListener) {
+                try {
+                    stagedObject.put(key, value);
+                } catch (final JSONException ex) {
+                    String message = ex.getLocalizedMessage();
+                    if (message == null) {
+                        message = "Error staging object.";
+                    }
+                    onErrorListener.onError(new FacebookException(message));
+                }
+            }
+        };
+        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                final FacebookRequestError error = response.getError();
+                if (error != null) {
+                    String message = error.getErrorMessage();
+                    if (message == null) {
+                        message = "Error staging Open Graph object.";
+                    }
+                    onOpenGraphObjectStagedListener.onError(
+                            new FacebookGraphResponseException(response, message));
+                    return;
+                }
+                final JSONObject data = response.getJSONObject();
+                if (data == null) {
+                    onOpenGraphObjectStagedListener.onError(
+                            new FacebookGraphResponseException(response,
+                                    "Error staging Open Graph object."));
+                    return;
+                }
+                final String stagedObjectId = data.optString("id");
+                if (stagedObjectId == null) {
+                    onOpenGraphObjectStagedListener.onError(
+                            new FacebookGraphResponseException(response,
+                                    "Error staging Open Graph object."));
+                    return;
+                }
+                onOpenGraphObjectStagedListener.onComplete(stagedObjectId);
+            }
+        };
+        final String ogType = type;
+        final CollectionMapper.OnMapperCompleteListener onMapperCompleteListener =
+                new CollectionMapper.OnMapperCompleteListener() {
+                    @Override
+                    public void onComplete() {
+                        final String objectString = stagedObject.toString();
+                        final Bundle parameters = new Bundle();
+                        parameters.putString("object", objectString);
+                        try {
+                            new GraphRequest(
+                                    AccessToken.getCurrentAccessToken(),
+                                    "/me/objects/" + URLEncoder.encode(ogType, "UTF-8"),
+                                    parameters,
+                                    HttpMethod.POST,
+                                    requestCallback).executeAsync();
+                        } catch (final UnsupportedEncodingException ex) {
+                            String message = ex.getLocalizedMessage();
+                            if (message == null) {
+                                message = "Error staging Open Graph object.";
+                            }
+                            onOpenGraphObjectStagedListener.onError(new FacebookException(message));
+                        }
+                    }
+
+                    @Override
+                    public void onError(FacebookException exception) {
+                        onOpenGraphObjectStagedListener.onError(exception);
+                    }
+                };
+        stageCollectionValues(collection, onMapperCompleteListener);
+    }
+
+    private static void stagePhoto(final SharePhoto photo,
+                                   final CollectionMapper.OnMapValueCompleteListener
+                                           onPhotoStagedListener) {
+        final Bitmap bitmap = photo.getBitmap();
+        final Uri imageUrl = photo.getImageUrl();
+        if ((bitmap != null) || (imageUrl != null)) {
+            final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
+                @Override
+                public void onCompleted(GraphResponse response) {
+                    final FacebookRequestError error = response.getError();
+                    if (error != null) {
+                        String message = error.getErrorMessage();
+                        if (message == null) {
+                            message = "Error staging photo.";
+                        }
+                        onPhotoStagedListener.onError(
+                                new FacebookGraphResponseException(response, message));
+                        return;
+                    }
+                    final JSONObject data = response.getJSONObject();
+                    if (data == null) {
+                        onPhotoStagedListener.onError(
+                                new FacebookException("Error staging photo."));
+                        return;
+                    }
+                    final String stagedImageUri = data.optString("uri");
+                    if (stagedImageUri == null) {
+                        onPhotoStagedListener.onError(
+                                new FacebookException("Error staging photo."));
+                        return;
+                    }
+
+                    final JSONObject stagedObject = new JSONObject();
+                    try {
+                        stagedObject.put("url", stagedImageUri);
+                        stagedObject.put("user_generated", photo.getUserGenerated());
+                    } catch (final JSONException ex) {
+                        String message = ex.getLocalizedMessage();
+                        if (message == null) {
+                            message = "Error staging photo.";
+                        }
+                        onPhotoStagedListener.onError(new FacebookException(message));
+                        return;
+                    }
+                    onPhotoStagedListener.onComplete(stagedObject);
+                }
+            };
+            if (bitmap != null) {
+                ShareInternalUtility.newUploadStagingResourceWithImageRequest(
+                        AccessToken.getCurrentAccessToken(),
+                        bitmap,
+                        requestCallback).executeAsync();
+            } else {
+                try {
+                    ShareInternalUtility.newUploadStagingResourceWithImageRequest(
+                            AccessToken.getCurrentAccessToken(),
+                            imageUrl,
+                            requestCallback).executeAsync();
+                } catch (final FileNotFoundException ex) {
+                    String message = ex.getLocalizedMessage();
+                    if (message == null) {
+                        message = "Error staging photo.";
+                    }
+                    onPhotoStagedListener.onError(new FacebookException(message));
+                }
+            }
+        } else {
+            onPhotoStagedListener.onError(
+                    new FacebookException("Photos must have an imageURL or bitmap."));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/ShareBuilder.java b/facebook/src/com/facebook/share/ShareBuilder.java
new file mode 100644
index 000000000..53df49f3a
--- /dev/null
+++ b/facebook/src/com/facebook/share/ShareBuilder.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share;
+
+/**
+ * Interface for builders related to sharing.
+ * @param <P> The class of the object to be built.
+ * @param <E> The concrete builder class.
+ */
+public interface ShareBuilder<P, E extends ShareBuilder> {
+    /**
+     * Builds the object.
+     * @return The built object.
+     */
+    public P build();
+}
diff --git a/facebook/src/com/facebook/share/Sharer.java b/facebook/src/com/facebook/share/Sharer.java
new file mode 100644
index 000000000..1f22d52a4
--- /dev/null
+++ b/facebook/src/com/facebook/share/Sharer.java
@@ -0,0 +1,68 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share;
+
+/**
+ * The common interface for components that initiate sharing.
+ * @see com.facebook.share.widget.ShareDialog
+ * @see com.facebook.share.widget.MessageDialog
+ */
+public interface Sharer {
+    /**
+     * Specifies whether the sharer should fail if it finds an error with the share content.
+     * If false, the share dialog will still be displayed without the data that was mis-configured.
+     * For example, an invalid placeID specified on the shareContent would produce a data error.
+     * @return A Boolean value.
+     */
+    public boolean getShouldFailOnDataError();
+
+    /**
+     * Specifies whether the sharer should fail if it finds an error with the share content.
+     * If false, the share dialog will still be displayed without the data that was mis-configured.
+     * For example, an invalid placeID specified on the shareContent would produce a data error.
+     *
+     * @param shouldFailOnDataError whether the dialog should fail if it finds an error.
+     */
+    public void setShouldFailOnDataError(boolean shouldFailOnDataError);
+
+    /**
+     * Helper object for handling the result from a share dialog or share operation
+     */
+    public static class Result {
+        final String postId;
+
+        /**
+         * Constructor.
+         * @param postId the resulting post id.
+         */
+        public Result(String postId) {
+            this.postId = postId;
+        }
+
+        /**
+         * Returns the post id, if available.
+         * @return the post id.
+         */
+        public String getPostId() {
+            return postId;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/AppInviteDialogFeature.java b/facebook/src/com/facebook/share/internal/AppInviteDialogFeature.java
new file mode 100644
index 000000000..b6d224742
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/AppInviteDialogFeature.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum AppInviteDialogFeature implements DialogFeature {
+
+    // This matches a value in a sitevar. DO NOT CHANGE
+    APP_INVITES_DIALOG(NativeProtocol.PROTOCOL_VERSION_20140701);
+
+    private int minVersion;
+
+    AppInviteDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    public String getAction() {
+        return NativeProtocol.ACTION_APPINVITE_DIALOG;
+    }
+
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/GameRequestValidation.java b/facebook/src/com/facebook/share/internal/GameRequestValidation.java
new file mode 100644
index 000000000..a9641f7b0
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/GameRequestValidation.java
@@ -0,0 +1,61 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.Validate;
+import com.facebook.share.model.GameRequestContent;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ *
+ * Validates GameRequestContent before it is shown by GameRequestDialog
+ */
+public class GameRequestValidation {
+
+    public static void validate(GameRequestContent content) {
+        Validate.notNull(content.getMessage(), "message");
+        if (content.getObjectId() != null ^
+                (content.getActionType() == GameRequestContent.ActionType.ASKFOR
+                || content.getActionType() == GameRequestContent.ActionType.SEND)) {
+            throw new IllegalArgumentException(
+                    "Object id should be provided if and only if action type is send or askfor");
+        }
+
+        // parameters to, filters, suggestions are mutually exclusive
+        int mutex = 0;
+        if (content.getTo() != null) {
+            mutex++;
+        }
+        if (content.getSuggestions() != null) {
+            mutex++;
+        }
+        if (content.getFilters() != null) {
+            mutex++;
+        }
+        if (mutex > 1) {
+            throw new IllegalArgumentException(
+                    "Parameters to, filters and suggestions are mutually exclusive");
+        }
+    }
+
+}
diff --git a/facebook/src/com/facebook/share/internal/LegacyNativeDialogParameters.java b/facebook/src/com/facebook/share/internal/LegacyNativeDialogParameters.java
new file mode 100644
index 000000000..67ebe55b8
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LegacyNativeDialogParameters.java
@@ -0,0 +1,158 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.content.Context;
+import android.os.Bundle;
+
+import com.facebook.FacebookException;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import com.facebook.share.model.ShareContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.SharePhotoContent;
+import com.facebook.share.model.ShareVideoContent;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class LegacyNativeDialogParameters {
+
+    public static Bundle create(
+            UUID callId,
+            ShareContent shareContent,
+            boolean shouldFailOnDataError) {
+        Validate.notNull(shareContent, "shareContent");
+        Validate.notNull(callId, "callId");
+
+        Bundle nativeParams = null;
+        if (shareContent instanceof ShareLinkContent) {
+            final ShareLinkContent linkContent = (ShareLinkContent)shareContent;
+            nativeParams = create(linkContent, shouldFailOnDataError);
+        } else if (shareContent instanceof SharePhotoContent) {
+            final SharePhotoContent photoContent = (SharePhotoContent)shareContent;
+            List<String> photoUrls = ShareInternalUtility.getPhotoUrls(
+                    photoContent,
+                    callId);
+
+            nativeParams = create(photoContent, photoUrls, shouldFailOnDataError);
+        } else if (shareContent instanceof ShareVideoContent) {
+            final ShareVideoContent videoContent = (ShareVideoContent)shareContent;
+            nativeParams = create(videoContent, shouldFailOnDataError);
+        } else if (shareContent instanceof ShareOpenGraphContent) {
+            final ShareOpenGraphContent openGraphContent = (ShareOpenGraphContent) shareContent;
+            final ShareOpenGraphAction action = openGraphContent.getAction();
+            try {
+                JSONObject openGraphActionJSON = ShareInternalUtility.toJSONObjectForCall(
+                        callId, action);
+
+                nativeParams = create(openGraphContent, openGraphActionJSON, shouldFailOnDataError);
+            } catch (final JSONException e) {
+                throw new FacebookException(
+                        "Unable to create a JSON Object from the provided ShareOpenGraphContent: "
+                                + e.getMessage());
+            }
+        }
+
+        return nativeParams;
+    }
+
+    private static Bundle create(ShareLinkContent linkContent, boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(linkContent, dataErrorsFatal);
+
+        Utility.putNonEmptyString(
+                params, ShareConstants.LEGACY_TITLE, linkContent.getContentTitle());
+        Utility.putNonEmptyString(
+                params, ShareConstants.LEGACY_DESCRIPTION, linkContent.getContentDescription());
+        Utility.putUri(params, ShareConstants.LEGACY_IMAGE, linkContent.getImageUrl());
+
+        return params;
+    }
+
+    private static Bundle create(
+            SharePhotoContent photoContent,
+            List<String> imageUrls,
+            boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(photoContent, dataErrorsFatal);
+
+        params.putStringArrayList(ShareConstants.LEGACY_PHOTOS, new ArrayList<>(imageUrls));
+
+        return params;
+    }
+
+    private static Bundle create(ShareVideoContent videoContent, boolean dataErrorsFatal) {
+        // Not supported
+        return null;
+    }
+
+    private static Bundle create(
+            ShareOpenGraphContent openGraphContent,
+            JSONObject openGraphActionJSON,
+            boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(openGraphContent, dataErrorsFatal);
+
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.LEGACY_PREVIEW_PROPERTY_NAME,
+                openGraphContent.getPreviewPropertyName());
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.LEGACY_ACTION_TYPE,
+                openGraphContent.getAction().getActionType());
+
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.LEGACY_ACTION,
+                openGraphActionJSON.toString());
+
+        return params;
+    }
+
+    private static Bundle createBaseParameters(ShareContent content, boolean dataErrorsFatal) {
+        Bundle params = new Bundle();
+
+        Utility.putUri(params, ShareConstants.LEGACY_LINK, content.getContentUrl());
+        Utility.putNonEmptyString(params, ShareConstants.LEGACY_PLACE_TAG, content.getPlaceId());
+        Utility.putNonEmptyString(params, ShareConstants.LEGACY_REF, content.getRef());
+
+        params.putBoolean(ShareConstants.LEGACY_DATA_FAILURES_FATAL, dataErrorsFatal);
+
+        List<String> peopleIds = content.getPeopleIds();
+        if (!Utility.isNullOrEmpty(peopleIds)) {
+            params.putStringArrayList(
+                    ShareConstants.LEGACY_FRIEND_TAGS,
+                    new ArrayList<>(peopleIds));
+        }
+
+        return params;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeActionController.java b/facebook/src/com/facebook/share/internal/LikeActionController.java
new file mode 100644
index 000000000..8f21b829e
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeActionController.java
@@ -0,0 +1,1682 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.app.Activity;
+import android.content.*;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.v4.app.Fragment;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+
+import com.facebook.*;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.BundleJSONConverter;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.FileLruCache;
+import com.facebook.internal.Logger;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.WorkQueue;
+import com.facebook.share.widget.LikeView;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Locale;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class LikeActionController {
+
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_UPDATED =
+            "com.facebook.sdk.LikeActionController.UPDATED";
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR =
+            "com.facebook.sdk.LikeActionController.DID_ERROR";
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_DID_RESET =
+            "com.facebook.sdk.LikeActionController.DID_RESET";
+
+    public static final String ACTION_OBJECT_ID_KEY =
+            "com.facebook.sdk.LikeActionController.OBJECT_ID";
+
+    public static final String ERROR_INVALID_OBJECT_ID = "Invalid Object Id";
+    public static final String ERROR_PUBLISH_ERROR = "Unable to publish the like/unlike action";
+
+    private static final String TAG = LikeActionController.class.getSimpleName();
+
+    private static final int LIKE_ACTION_CONTROLLER_VERSION = 3;
+    private static final int MAX_CACHE_SIZE = 128;
+    // MAX_OBJECT_SUFFIX basically accommodates for 1000 access token changes before the async
+    // disk-cache-clear finishes. The value is reasonably arbitrary.
+    private static final int MAX_OBJECT_SUFFIX = 1000;
+
+    private static final String LIKE_ACTION_CONTROLLER_STORE =
+            "com.facebook.LikeActionController.CONTROLLER_STORE_KEY";
+    private static final String LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY =
+            "PENDING_CONTROLLER_KEY";
+    private static final String LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY = "OBJECT_SUFFIX";
+
+    private static final String JSON_INT_VERSION_KEY =
+            "com.facebook.share.internal.LikeActionController.version";
+    private static final String JSON_STRING_OBJECT_ID_KEY = "object_id";
+    private static final String JSON_INT_OBJECT_TYPE_KEY = "object_type";
+    private static final String JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY =
+            "like_count_string_with_like";
+    private static final String JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY =
+            "like_count_string_without_like";
+    private static final String JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY =
+            "social_sentence_with_like";
+    private static final String JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY =
+            "social_sentence_without_like";
+    private static final String JSON_BOOL_IS_OBJECT_LIKED_KEY = "is_object_liked";
+    private static final String JSON_STRING_UNLIKE_TOKEN_KEY = "unlike_token";
+    private static final String JSON_BUNDLE_FACEBOOK_DIALOG_ANALYTICS_BUNDLE =
+            "facebook_dialog_analytics_bundle";
+
+    private static final String LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY = "object_is_liked";
+    private static final String LIKE_DIALOG_RESPONSE_LIKE_COUNT_STRING_KEY = "like_count_string";
+    private static final String LIKE_DIALOG_RESPONSE_SOCIAL_SENTENCE_KEY = "social_sentence";
+    private static final String LIKE_DIALOG_RESPONSE_UNLIKE_TOKEN_KEY = "unlike_token";
+
+    private static final int ERROR_CODE_OBJECT_ALREADY_LIKED = 3501;
+
+    private static FileLruCache controllerDiskCache;
+    private static final ConcurrentHashMap<String, LikeActionController> cache =
+            new ConcurrentHashMap<>();
+
+    // This MUST be 1 for proper synchronization
+    private static WorkQueue mruCacheWorkQueue = new WorkQueue(1);
+    // This MUST be 1 for proper synchronization
+    private static WorkQueue diskIOWorkQueue = new WorkQueue(1);
+
+    private static Handler handler;
+    private static String objectIdForPendingController;
+    private static boolean isInitialized;
+    private static volatile int objectSuffix;
+    private static AccessTokenTracker accessTokenTracker;
+
+    private String objectId;
+    private LikeView.ObjectType objectType;
+    private boolean isObjectLiked;
+    private String likeCountStringWithLike;
+    private String likeCountStringWithoutLike;
+    private String socialSentenceWithLike;
+    private String socialSentenceWithoutLike;
+    private String unlikeToken;
+
+    private String verifiedObjectId;
+    private boolean objectIsPage;
+    private boolean isObjectLikedOnServer;
+
+    private boolean isPendingLikeOrUnlike;
+
+    private Bundle facebookDialogAnalyticsBundle;
+
+    private AppEventsLogger appEventsLogger;
+
+    /**
+     * Called from CallbackManager to process any pending likes that had resulted in the Like
+     * dialog being displayed
+     *
+     * @param requestCode From the originating call to onActivityResult
+     * @param resultCode  From the originating call to onActivityResult
+     * @param data        From the originating call to onActivityResult
+     * @return Indication of whether the Intent was handled
+     */
+    public static boolean handleOnActivityResult(final int requestCode,
+                                                 final int resultCode,
+                                                 final Intent data) {
+        // See if we were waiting on a Like dialog completion.
+        if (Utility.isNullOrEmpty(objectIdForPendingController)) {
+            Context appContext = FacebookSdk.getApplicationContext();
+            SharedPreferences sharedPreferences = appContext.getSharedPreferences(
+                    LIKE_ACTION_CONTROLLER_STORE,
+                    Context.MODE_PRIVATE);
+
+            objectIdForPendingController = sharedPreferences.getString(
+                    LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY,
+                    null);
+        }
+
+        if (Utility.isNullOrEmpty(objectIdForPendingController)) {
+            // Doesn't look like we were waiting on a Like dialog completion
+            return false;
+        }
+
+        getControllerForObjectId(
+                objectIdForPendingController,
+                LikeView.ObjectType.UNKNOWN,
+                new CreationCallback() {
+                    @Override
+                    public void onComplete(
+                            LikeActionController likeActionController,
+                            FacebookException error) {
+                        if (error == null) {
+                            likeActionController.onActivityResult(
+                                    requestCode,
+                                    resultCode,
+                                    data);
+                        } else {
+                            Utility.logd(TAG, error);
+                        }
+                    }
+                });
+
+        return true;
+    }
+
+    /**
+     * Called by the LikeView when an object-id is set on it.
+     *
+     * @param objectId Object Id
+     * @param callback Callback to be invoked when the LikeActionController has been created.
+     */
+    public static void getControllerForObjectId(
+            String objectId,
+            LikeView.ObjectType objectType,
+            CreationCallback callback) {
+        if (!isInitialized) {
+            performFirstInitialize();
+        }
+
+        LikeActionController controllerForObject = getControllerFromInMemoryCache(objectId);
+        if (controllerForObject != null) {
+            // Direct object-cache hit
+            verifyControllerAndInvokeCallback(controllerForObject, objectType, callback);
+        } else {
+            diskIOWorkQueue.addActiveWorkItem(
+                    new CreateLikeActionControllerWorkItem(objectId, objectType, callback));
+        }
+    }
+
+    private static void verifyControllerAndInvokeCallback(
+            LikeActionController likeActionController,
+            LikeView.ObjectType objectType,
+            CreationCallback callback) {
+        LikeView.ObjectType bestObjectType = ShareInternalUtility.getMostSpecificObjectType(
+                objectType,
+                likeActionController.objectType);
+        FacebookException error = null;
+        if (bestObjectType == null) {
+            // Looks like the existing controller has an object_type for this object_id that is
+            // not compatible with the requested object type.
+            error = new FacebookException(
+                    "Object with id:\"%s\" is already marked as type:\"%s\". " +
+                            "Cannot change the type to:\"%s\"",
+                    likeActionController.objectId,
+                    likeActionController.objectType.toString(),
+                    objectType.toString());
+            likeActionController = null;
+        } else {
+            likeActionController.objectType = bestObjectType;
+        }
+
+        invokeCallbackWithController(callback, likeActionController, error);
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the CreateLikeActionControllerWorkItem class to ensure
+     * that it happens on the right thread, at the right time.
+     */
+    private static void createControllerForObjectIdAndType(
+            String objectId,
+            LikeView.ObjectType objectType,
+            CreationCallback callback) {
+        // Check again to see if the controller was created before attempting to deserialize/create
+        // one. Need to check this in the case where multiple LikeViews are looking for a controller
+        // for the same object and all got queued up to create one. We only want the first one to go
+        // through with the creation, and the rest should get the same instance from the
+        // object-cache.
+        LikeActionController controllerForObject = getControllerFromInMemoryCache(objectId);
+        if (controllerForObject != null) {
+            // Direct object-cache hit
+            verifyControllerAndInvokeCallback(controllerForObject, objectType, callback);
+            return;
+        }
+
+        // Try deserialize from disk
+        controllerForObject = deserializeFromDiskSynchronously(objectId);
+
+        if (controllerForObject == null) {
+            controllerForObject = new LikeActionController(objectId, objectType);
+            serializeToDiskAsync(controllerForObject);
+        }
+
+        // Update object-cache.
+        putControllerInMemoryCache(objectId, controllerForObject);
+
+        // Refresh the controller on the Main thread.
+        final LikeActionController controllerToRefresh = controllerForObject;
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                controllerToRefresh.refreshStatusAsync();
+            }
+        });
+
+        invokeCallbackWithController(callback, controllerToRefresh, null);
+    }
+
+    private synchronized static void performFirstInitialize() {
+        if (isInitialized) {
+            return;
+        }
+
+        handler = new Handler(Looper.getMainLooper());
+
+        Context appContext = FacebookSdk.getApplicationContext();
+        SharedPreferences sharedPreferences = appContext.getSharedPreferences(
+                LIKE_ACTION_CONTROLLER_STORE,
+                Context.MODE_PRIVATE);
+
+        objectSuffix = sharedPreferences.getInt(LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY, 1);
+        controllerDiskCache = new FileLruCache(TAG, new FileLruCache.Limits());
+
+        registerAccessTokenTracker();
+
+        CallbackManagerImpl.registerStaticCallback(
+                CallbackManagerImpl.RequestCodeOffset.Like.toRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return handleOnActivityResult(
+                                CallbackManagerImpl.RequestCodeOffset.Like.toRequestCode(),
+                                resultCode,
+                                data);
+                    }
+                });
+
+        isInitialized = true;
+    }
+
+    private static void invokeCallbackWithController(
+            final CreationCallback callback,
+            final LikeActionController controller,
+            final FacebookException error) {
+        if (callback == null) {
+            return;
+        }
+
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                callback.onComplete(controller, error);
+            }
+        });
+    }
+
+    //
+    // In-memory mru-caching code
+    //
+
+    private static void registerAccessTokenTracker() {
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(
+                    AccessToken oldAccessToken,
+                    AccessToken currentAccessToken) {
+                Context appContext = FacebookSdk.getApplicationContext();
+                if (currentAccessToken == null) {
+                    // Bump up the objectSuffix so that we don't have a filename collision between a
+                    // cache-clear and and a cache-read/write.
+                    //
+                    // NOTE: We know that onReceive() was called on the main thread. This means that
+                    // even this code is running on the main thread, and therefore, there aren't
+                    // synchronization issues with incrementing the objectSuffix and clearing the
+                    // caches here.
+                    objectSuffix = (objectSuffix + 1) % MAX_OBJECT_SUFFIX;
+                    appContext.getSharedPreferences(
+                            LIKE_ACTION_CONTROLLER_STORE,
+                            Context.MODE_PRIVATE)
+                            .edit()
+                            .putInt(LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY, objectSuffix)
+                            .apply();
+
+                    // Only clearing the actual caches. The MRU index will self-clean with usage.
+                    // Clearing the caches is necessary to prevent leaking like-state across
+                    // users.
+                    cache.clear();
+                    controllerDiskCache.clearCache();
+                }
+                broadcastAction(null, ACTION_LIKE_ACTION_CONTROLLER_DID_RESET);
+            }
+        };
+    }
+
+    private static void putControllerInMemoryCache(
+            String objectId,
+            LikeActionController controllerForObject) {
+        String cacheKey = getCacheKeyForObjectId(objectId);
+        // Move this object to the front. Also trim cache if necessary
+        mruCacheWorkQueue.addActiveWorkItem(new MRUCacheWorkItem(cacheKey, true));
+
+        cache.put(cacheKey, controllerForObject);
+    }
+
+    private static LikeActionController getControllerFromInMemoryCache(String objectId) {
+        String cacheKey = getCacheKeyForObjectId(objectId);
+
+        LikeActionController controller = cache.get(cacheKey);
+        if (controller != null) {
+            // Move this object to the front
+            mruCacheWorkQueue.addActiveWorkItem(new MRUCacheWorkItem(cacheKey, false));
+        }
+
+        return controller;
+    }
+
+    //
+    // Disk caching code
+    //
+
+    private static void serializeToDiskAsync(LikeActionController controller) {
+        String controllerJson = serializeToJson(controller);
+        String cacheKey = getCacheKeyForObjectId(controller.objectId);
+
+        if (!Utility.isNullOrEmpty(controllerJson) && !Utility.isNullOrEmpty(cacheKey)) {
+            diskIOWorkQueue.addActiveWorkItem(
+                    new SerializeToDiskWorkItem(cacheKey, controllerJson));
+        }
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the SerializeToDiskWorkItem class to ensure that it
+     * happens on the right thread, at the right time.
+     */
+    private static void serializeToDiskSynchronously(String cacheKey, String controllerJson) {
+        OutputStream outputStream = null;
+        try {
+            outputStream = controllerDiskCache.openPutStream(cacheKey);
+            outputStream.write(controllerJson.getBytes());
+        } catch (IOException e) {
+            Log.e(TAG, "Unable to serialize controller to disk", e);
+        } finally {
+            if (outputStream != null) {
+                Utility.closeQuietly(outputStream);
+            }
+        }
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the CreateLikeActionControllerWorkItem class to ensure
+     * that it happens on the right thread, at the right time.
+     */
+    private static LikeActionController deserializeFromDiskSynchronously(String objectId) {
+        LikeActionController controller = null;
+
+        InputStream inputStream = null;
+        try {
+            String cacheKey = getCacheKeyForObjectId(objectId);
+            inputStream = controllerDiskCache.get(cacheKey);
+            if (inputStream != null) {
+                String controllerJsonString = Utility.readStreamToString(inputStream);
+                if (!Utility.isNullOrEmpty(controllerJsonString)) {
+                    controller = deserializeFromJson(controllerJsonString);
+                }
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "Unable to deserialize controller from disk", e);
+            controller = null;
+        } finally {
+            if (inputStream != null) {
+                Utility.closeQuietly(inputStream);
+            }
+        }
+
+        return controller;
+    }
+
+    private static LikeActionController deserializeFromJson(String controllerJsonString) {
+        LikeActionController controller;
+
+        try {
+            JSONObject controllerJson = new JSONObject(controllerJsonString);
+            int version = controllerJson.optInt(JSON_INT_VERSION_KEY, -1);
+            if (version != LIKE_ACTION_CONTROLLER_VERSION) {
+                // Don't attempt to deserialize a controller that might be serialized differently
+                // than expected.
+                return null;
+            }
+
+            String objectId = controllerJson.getString(JSON_STRING_OBJECT_ID_KEY);
+            int objectTypeInt = controllerJson.optInt(
+                    JSON_INT_OBJECT_TYPE_KEY,
+                    LikeView.ObjectType.UNKNOWN.getValue());
+
+            controller = new LikeActionController(
+                    objectId,
+                    LikeView.ObjectType.fromInt(objectTypeInt));
+
+            // Make sure to default to null and not empty string, to keep the logic elsewhere
+            // functioning properly.
+            controller.likeCountStringWithLike =
+                    controllerJson.optString(JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY, null);
+            controller.likeCountStringWithoutLike =
+                    controllerJson.optString(JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY, null);
+            controller.socialSentenceWithLike =
+                    controllerJson.optString(JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY, null);
+            controller.socialSentenceWithoutLike =
+                    controllerJson.optString(JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY, null);
+            controller.isObjectLiked = controllerJson.optBoolean(JSON_BOOL_IS_OBJECT_LIKED_KEY);
+            controller.unlikeToken = controllerJson.optString(JSON_STRING_UNLIKE_TOKEN_KEY, null);
+
+            JSONObject analyticsJSON = controllerJson.optJSONObject(
+                    JSON_BUNDLE_FACEBOOK_DIALOG_ANALYTICS_BUNDLE);
+            if (analyticsJSON != null) {
+                controller.facebookDialogAnalyticsBundle =
+                        BundleJSONConverter.convertToBundle(analyticsJSON);
+            }
+        } catch (JSONException e) {
+            Log.e(TAG, "Unable to deserialize controller from JSON", e);
+            controller = null;
+        }
+
+        return controller;
+    }
+
+    private static String serializeToJson(LikeActionController controller) {
+        JSONObject controllerJson = new JSONObject();
+        try {
+            controllerJson.put(JSON_INT_VERSION_KEY, LIKE_ACTION_CONTROLLER_VERSION);
+            controllerJson.put(JSON_STRING_OBJECT_ID_KEY, controller.objectId);
+            controllerJson.put(JSON_INT_OBJECT_TYPE_KEY, controller.objectType.getValue());
+            controllerJson.put(
+                    JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY,
+                    controller.likeCountStringWithLike);
+            controllerJson.put(
+                    JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY,
+                    controller.likeCountStringWithoutLike);
+            controllerJson.put(
+                    JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY,
+                    controller.socialSentenceWithLike);
+            controllerJson.put(
+                    JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY,
+                    controller.socialSentenceWithoutLike);
+            controllerJson.put(JSON_BOOL_IS_OBJECT_LIKED_KEY, controller.isObjectLiked);
+            controllerJson.put(JSON_STRING_UNLIKE_TOKEN_KEY, controller.unlikeToken);
+            if (controller.facebookDialogAnalyticsBundle != null) {
+                JSONObject analyticsJSON =
+                        BundleJSONConverter.convertToJSON(
+                                controller.facebookDialogAnalyticsBundle);
+                if (analyticsJSON != null) {
+                    controllerJson.put(
+                            JSON_BUNDLE_FACEBOOK_DIALOG_ANALYTICS_BUNDLE,
+                            analyticsJSON);
+                }
+            }
+        } catch (JSONException e) {
+            Log.e(TAG, "Unable to serialize controller to JSON", e);
+            return null;
+        }
+
+        return controllerJson.toString();
+    }
+
+    private static String getCacheKeyForObjectId(String objectId) {
+        String accessTokenPortion = null;
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
+            accessTokenPortion = accessToken.getToken();
+        }
+        if (accessTokenPortion != null) {
+            // Cache-key collisions are not something to worry about here, since we only store state
+            // for one access token. Even in the case where the previous access tokens serialized
+            // files have not been deleted yet, the objectSuffix will be different due to the access
+            // token change, thus making the key different.
+            accessTokenPortion = Utility.md5hash(accessTokenPortion);
+        }
+        return String.format(
+                Locale.ROOT,
+                "%s|%s|com.fb.sdk.like|%d",
+                objectId,
+                Utility.coerceValueIfNullOrEmpty(accessTokenPortion, ""),
+                objectSuffix);
+    }
+
+    //
+    // Broadcast handling code
+    //
+
+    private static void broadcastAction(
+            LikeActionController controller,
+            String action) {
+        broadcastAction(controller, action, null);
+    }
+
+    private static void broadcastAction(
+            LikeActionController controller,
+            String action,
+            Bundle data) {
+        Intent broadcastIntent = new Intent(action);
+        if (controller != null) {
+            if (data == null) {
+                data = new Bundle();
+            }
+
+            data.putString(ACTION_OBJECT_ID_KEY, controller.getObjectId());
+        }
+
+        if (data != null) {
+            broadcastIntent.putExtras(data);
+        }
+        LocalBroadcastManager.getInstance(FacebookSdk.getApplicationContext())
+                .sendBroadcast(broadcastIntent);
+    }
+
+    /**
+     * Constructor
+     */
+    private LikeActionController(String objectId, LikeView.ObjectType objectType) {
+        this.objectId = objectId;
+        this.objectType = objectType;
+    }
+
+    /**
+     * Gets the the associated object id
+     *
+     * @return object id
+     */
+    public String getObjectId() {
+        return objectId;
+    }
+
+    /**
+     * Gets the String representation of the like-count for the associated object
+     *
+     * @return String representation of the like-count for the associated object
+     */
+    public String getLikeCountString() {
+        return isObjectLiked ? likeCountStringWithLike : likeCountStringWithoutLike;
+    }
+
+    /**
+     * Gets the String representation of the like-count for the associated object
+     *
+     * @return String representation of the like-count for the associated object
+     */
+    public String getSocialSentence() {
+        return isObjectLiked ? socialSentenceWithLike : socialSentenceWithoutLike;
+    }
+
+    /**
+     * Indicates whether the associated object is liked
+     *
+     * @return Indication of whether the associated object is liked
+     */
+    public boolean isObjectLiked() {
+        return isObjectLiked;
+    }
+
+    /**
+     * Indicates whether the LikeView should enable itself.
+     *
+     * @return Indication of whether the LikeView should enable itself.
+     */
+    public boolean shouldEnableView() {
+        if (LikeDialog.canShowNativeDialog() || LikeDialog.canShowWebFallback()) {
+            return true;
+        }
+        if (objectIsPage || (objectType == LikeView.ObjectType.PAGE)) {
+            // If we can't use the dialogs, then we can't like Pages.
+            // Before any requests are made to the server, we have to rely on the object type set
+            // by the app. If we have permissions to make requests, we will know the real type after
+            // the first request.
+            return false;
+        }
+
+        // See if we have publish permissions.
+        // NOTE: This will NOT be accurate if the app has the type set as UNKNOWN, and the
+        // underlying object is a page.
+        AccessToken token = AccessToken.getCurrentAccessToken();
+        return token != null
+                && token.getPermissions() != null
+                && token.getPermissions().contains("publish_actions");
+    }
+
+    /**
+     * Entry-point to the code that performs the like/unlike action.
+     */
+    public void toggleLike(Activity activity, Fragment fragment, Bundle analyticsParameters) {
+        getAppEventsLogger().logSdkEvent(
+                AnalyticsEvents.EVENT_LIKE_VIEW_DID_TAP,
+                null,
+                analyticsParameters);
+
+        boolean shouldLikeObject = !this.isObjectLiked;
+
+        if (canUseOGPublish()) {
+            // Update UI Like state optimistically
+            updateLikeState(shouldLikeObject);
+            if (isPendingLikeOrUnlike) {
+                // If the user toggled the button quickly, and there is still a publish underway,
+                // don't fire off another request. Also log this behavior.
+
+                getAppEventsLogger().logSdkEvent(
+                        AnalyticsEvents.EVENT_LIKE_VIEW_DID_UNDO_QUICKLY,
+                        null,
+                        analyticsParameters);
+            } else if (!publishLikeOrUnlikeAsync(shouldLikeObject, analyticsParameters)) {
+                // We were not able to send a graph request to unlike or like the object
+                // Undo the optimistic state-update and show the dialog instead
+                updateLikeState(!shouldLikeObject);
+                presentLikeDialog(activity, fragment, analyticsParameters);
+            }
+        } else {
+            presentLikeDialog(activity, fragment, analyticsParameters);
+        }
+    }
+
+    private AppEventsLogger getAppEventsLogger() {
+        if (appEventsLogger == null) {
+            appEventsLogger = AppEventsLogger.newLogger(FacebookSdk.getApplicationContext());
+        }
+        return appEventsLogger;
+    }
+
+    private boolean publishLikeOrUnlikeAsync(
+            boolean shouldLikeObject,
+            Bundle analyticsParameters) {
+        boolean requested = false;
+        if (canUseOGPublish()) {
+            if (shouldLikeObject) {
+                requested = true;
+                publishLikeAsync(analyticsParameters);
+            } else if (!Utility.isNullOrEmpty(this.unlikeToken)) {
+                requested = true;
+                publishUnlikeAsync(analyticsParameters);
+            }
+        }
+
+        return requested;
+    }
+
+    /**
+     * Only to be called after an OG-publish was attempted and something went wrong. The Button
+     * state is reverted and an error is returned to the LikeViews
+     */
+    private void publishDidError(boolean oldLikeState) {
+        updateLikeState(oldLikeState);
+
+        Bundle errorBundle = new Bundle();
+        errorBundle.putString(
+                NativeProtocol.STATUS_ERROR_DESCRIPTION,
+                ERROR_PUBLISH_ERROR);
+
+        broadcastAction(
+                LikeActionController.this,
+                ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR,
+                errorBundle);
+    }
+
+    private void updateLikeState(boolean isObjectLiked) {
+        updateState(isObjectLiked,
+                this.likeCountStringWithLike,
+                this.likeCountStringWithoutLike,
+                this.socialSentenceWithLike,
+                this.socialSentenceWithoutLike,
+                this.unlikeToken);
+    }
+
+    private void updateState(boolean isObjectLiked,
+                             String likeCountStringWithLike,
+                             String likeCountStringWithoutLike,
+                             String socialSentenceWithLike,
+                             String socialSentenceWithoutLike,
+                             String unlikeToken) {
+        // Normalize all empty strings to null, so that we don't have any problems with comparison.
+        likeCountStringWithLike = Utility.coerceValueIfNullOrEmpty(likeCountStringWithLike, null);
+        likeCountStringWithoutLike =
+                Utility.coerceValueIfNullOrEmpty(likeCountStringWithoutLike, null);
+        socialSentenceWithLike = Utility.coerceValueIfNullOrEmpty(socialSentenceWithLike, null);
+        socialSentenceWithoutLike =
+                Utility.coerceValueIfNullOrEmpty(socialSentenceWithoutLike, null);
+        unlikeToken = Utility.coerceValueIfNullOrEmpty(unlikeToken, null);
+
+        boolean stateChanged = isObjectLiked != this.isObjectLiked ||
+                !Utility.areObjectsEqual(
+                        likeCountStringWithLike,
+                        this.likeCountStringWithLike) ||
+                !Utility.areObjectsEqual(
+                        likeCountStringWithoutLike,
+                        this.likeCountStringWithoutLike) ||
+                !Utility.areObjectsEqual(socialSentenceWithLike, this.socialSentenceWithLike) ||
+                !Utility.areObjectsEqual(
+                        socialSentenceWithoutLike,
+                        this.socialSentenceWithoutLike) ||
+                !Utility.areObjectsEqual(unlikeToken, this.unlikeToken);
+
+        if (!stateChanged) {
+            return;
+        }
+
+        this.isObjectLiked = isObjectLiked;
+        this.likeCountStringWithLike = likeCountStringWithLike;
+        this.likeCountStringWithoutLike = likeCountStringWithoutLike;
+        this.socialSentenceWithLike = socialSentenceWithLike;
+        this.socialSentenceWithoutLike = socialSentenceWithoutLike;
+        this.unlikeToken = unlikeToken;
+
+        serializeToDiskAsync(this);
+
+        broadcastAction(this, ACTION_LIKE_ACTION_CONTROLLER_UPDATED);
+    }
+
+    private void presentLikeDialog(
+            final Activity activity,
+            final Fragment fragment,
+            final Bundle analyticsParameters) {
+        String analyticsEvent = null;
+
+        if (LikeDialog.canShowNativeDialog()) {
+            analyticsEvent = AnalyticsEvents.EVENT_LIKE_VIEW_DID_PRESENT_DIALOG;
+        } else if (LikeDialog.canShowWebFallback()) {
+            analyticsEvent = AnalyticsEvents.EVENT_LIKE_VIEW_DID_PRESENT_FALLBACK;
+        } else {
+            // We will get here if the user tapped the button when dialogs cannot be shown.
+            logAppEventForError("present_dialog", analyticsParameters);
+            Utility.logd(TAG, "Cannot show the Like Dialog on this device.");
+
+            // If we got to this point, we should ask the views to check if they should now
+            // be disabled.
+            broadcastAction(null, ACTION_LIKE_ACTION_CONTROLLER_UPDATED);
+        }
+
+        // Using the value of analyticsEvent to see if we can show any version of the dialog.
+        // Written this way just to prevent extra lines of code.
+        if (analyticsEvent != null) {
+            String objectTypeString = (this.objectType != null)
+                    ? this.objectType.toString()
+                    : LikeView.ObjectType.UNKNOWN.toString();
+            LikeContent likeContent = new LikeContent.Builder()
+                    .setObjectId(this.objectId)
+                    .setObjectType(objectTypeString)
+                    .build();
+
+            if (fragment != null) {
+                new LikeDialog(fragment).show(likeContent);
+            } else {
+                new LikeDialog(activity).show(likeContent);
+            }
+
+            saveState(analyticsParameters);
+
+            getAppEventsLogger().logSdkEvent(
+                    AnalyticsEvents.EVENT_LIKE_VIEW_DID_PRESENT_DIALOG,
+                    null,
+                    analyticsParameters);
+        }
+    }
+
+    private void onActivityResult(
+            int requestCode,
+            int resultCode,
+            Intent data) {
+        // Look for results
+        ShareInternalUtility.handleActivityResult(
+                requestCode,
+                resultCode,
+                data,
+                getResultProcessor(facebookDialogAnalyticsBundle));
+
+        // The handlers from above will run synchronously. So by the time we get here, it should be
+        // safe to stop tracking this call and also serialize the controller to disk
+        clearState();
+    }
+
+    private ResultProcessor getResultProcessor(final Bundle analyticsParameters) {
+        return new ResultProcessor(null) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle data) {
+                if (data == null || !data.containsKey(LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY)) {
+                    // This is an empty result that we can't handle.
+                    return;
+                }
+
+                boolean isObjectLiked = data.getBoolean(LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY);
+
+                // Default to known/cached state, if properties are missing.
+                String likeCountStringWithLike =
+                        LikeActionController.this.likeCountStringWithLike;
+                String likeCountStringWithoutLike =
+                        LikeActionController.this.likeCountStringWithoutLike;
+                if (data.containsKey(LIKE_DIALOG_RESPONSE_LIKE_COUNT_STRING_KEY)) {
+                    likeCountStringWithLike =
+                            data.getString(LIKE_DIALOG_RESPONSE_LIKE_COUNT_STRING_KEY);
+                    likeCountStringWithoutLike = likeCountStringWithLike;
+                }
+
+                String socialSentenceWithLike = LikeActionController.this.socialSentenceWithLike;
+                String socialSentenceWithoutWithoutLike =
+                        LikeActionController.this.socialSentenceWithoutLike;
+                if (data.containsKey(LIKE_DIALOG_RESPONSE_SOCIAL_SENTENCE_KEY)) {
+                    socialSentenceWithLike = data.getString(
+                            LIKE_DIALOG_RESPONSE_SOCIAL_SENTENCE_KEY);
+                    socialSentenceWithoutWithoutLike = socialSentenceWithLike;
+                }
+
+                String unlikeToken = data.containsKey(LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY)
+                        ? data.getString(LIKE_DIALOG_RESPONSE_UNLIKE_TOKEN_KEY)
+                        : LikeActionController.this.unlikeToken;
+
+                Bundle logParams =
+                        (analyticsParameters == null) ? new Bundle() : analyticsParameters;
+                logParams.putString(
+                        AnalyticsEvents.PARAMETER_CALL_ID,
+                        appCall.getCallId().toString());
+                getAppEventsLogger().logSdkEvent(
+                        AnalyticsEvents.EVENT_LIKE_VIEW_DIALOG_DID_SUCCEED,
+                        null,
+                        logParams);
+
+                updateState(
+                        isObjectLiked,
+                        likeCountStringWithLike,
+                        likeCountStringWithoutLike,
+                        socialSentenceWithLike,
+                        socialSentenceWithoutWithoutLike,
+                        unlikeToken);
+            }
+
+            @Override
+            public void onError(AppCall appCall, FacebookException error) {
+                Logger.log(
+                        LoggingBehavior.REQUESTS,
+                        TAG,
+                        "Like Dialog failed with error : %s",
+                        error);
+
+                Bundle logParams = analyticsParameters == null ? new Bundle() : analyticsParameters;
+                logParams.putString(
+                        AnalyticsEvents.PARAMETER_CALL_ID,
+                        appCall.getCallId().toString());
+
+                // Log the error and AppEvent
+                logAppEventForError("present_dialog", logParams);
+
+                broadcastAction(
+                        LikeActionController.this,
+                        ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR,
+                        NativeProtocol.createBundleForException(error));
+            }
+
+            @Override
+            public void onCancel(AppCall appCall) {
+                onError(appCall, new FacebookOperationCanceledException());
+            }
+        };
+    }
+
+    private void saveState(Bundle analyticsParameters) {
+        // Save off the call id for processing the response
+        storeObjectIdForPendingController(objectId);
+
+        // Store off the analytics parameters as well, for completion-logging
+        facebookDialogAnalyticsBundle = analyticsParameters;
+
+        // Serialize to disk, in case we get terminated while waiting for the dialog to complete
+        serializeToDiskAsync(this);
+    }
+
+    private void clearState() {
+        facebookDialogAnalyticsBundle = null;
+
+        storeObjectIdForPendingController(null);
+    }
+
+    private static void storeObjectIdForPendingController(String objectId) {
+        objectIdForPendingController = objectId;
+        Context appContext = FacebookSdk.getApplicationContext();
+
+        appContext.getSharedPreferences(LIKE_ACTION_CONTROLLER_STORE, Context.MODE_PRIVATE)
+                .edit()
+                .putString(
+                        LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY,
+                        objectIdForPendingController)
+                .apply();
+    }
+
+    private boolean canUseOGPublish() {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        // Verify that the object isn't a Page, that we have permissions and that, if we're
+        // unliking, then we have an unlike token.
+        return !objectIsPage &&
+                verifiedObjectId != null &&
+                accessToken != null &&
+                accessToken.getPermissions() != null &&
+                accessToken.getPermissions().contains("publish_actions");
+    }
+
+    private void publishLikeAsync(final Bundle analyticsParameters) {
+        isPendingLikeOrUnlike = true;
+
+        fetchVerifiedObjectId(new RequestCompletionCallback() {
+            @Override
+            public void onComplete() {
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    // Could not get a verified id
+                    Bundle errorBundle = new Bundle();
+                    errorBundle.putString(
+                            NativeProtocol.STATUS_ERROR_DESCRIPTION,
+                            ERROR_INVALID_OBJECT_ID);
+
+                    broadcastAction(
+                            LikeActionController.this,
+                            ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR,
+                            errorBundle);
+                    return;
+                }
+
+                // Perform the Like.
+                GraphRequestBatch requestBatch = new GraphRequestBatch();
+                final PublishLikeRequestWrapper likeRequest =
+                        new PublishLikeRequestWrapper(verifiedObjectId, objectType);
+                likeRequest.addToBatch(requestBatch);
+                requestBatch.addCallback(new GraphRequestBatch.Callback() {
+                    @Override
+                    public void onBatchCompleted(GraphRequestBatch batch) {
+                        isPendingLikeOrUnlike = false;
+
+                        if (likeRequest.error != null) {
+                            // We already updated the UI to show button in the Liked state. Since
+                            // this failed, let's revert back to the Unliked state and broadcast
+                            // an error
+                            publishDidError(false);
+                        } else {
+                            unlikeToken =
+                                    Utility.coerceValueIfNullOrEmpty(likeRequest.unlikeToken, null);
+                            isObjectLikedOnServer = true;
+
+                            getAppEventsLogger().logSdkEvent(
+                                    AnalyticsEvents.EVENT_LIKE_VIEW_DID_LIKE,
+                                    null,
+                                    analyticsParameters);
+
+                            // See if the user toggled the button back while this request was
+                            // completing
+                            publishAgainIfNeeded(analyticsParameters);
+                        }
+                    }
+                });
+
+                requestBatch.executeAsync();
+            }
+        });
+    }
+
+    private void publishUnlikeAsync(final Bundle analyticsParameters) {
+        isPendingLikeOrUnlike = true;
+
+        // Perform the Unlike.
+        GraphRequestBatch requestBatch = new GraphRequestBatch();
+        final PublishUnlikeRequestWrapper unlikeRequest =
+                new PublishUnlikeRequestWrapper(unlikeToken);
+        unlikeRequest.addToBatch(requestBatch);
+        requestBatch.addCallback(new GraphRequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(GraphRequestBatch batch) {
+                isPendingLikeOrUnlike = false;
+
+                if (unlikeRequest.error != null) {
+                    // We already updated the UI to show button in the Unliked state. Since this
+                    // failed, let's revert back to the Liked state and broadcast an error.
+                    publishDidError(true);
+                } else {
+                    unlikeToken = null;
+                    isObjectLikedOnServer = false;
+
+                    getAppEventsLogger().logSdkEvent(
+                            AnalyticsEvents.EVENT_LIKE_VIEW_DID_UNLIKE,
+                            null,
+                            analyticsParameters);
+
+                    // See if the user toggled the button back while this request was
+                    // completing
+                    publishAgainIfNeeded(analyticsParameters);
+                }
+            }
+        });
+
+        requestBatch.executeAsync();
+    }
+
+    private void refreshStatusAsync() {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken == null) {
+            // Only when we know that there is no active access token should we attempt getting like
+            // state from the service. Otherwise, use the access token to make sure we get the
+            // correct like state.
+            refreshStatusViaService();
+            return;
+        }
+
+        fetchVerifiedObjectId(new RequestCompletionCallback() {
+            @Override
+            public void onComplete() {
+                final GetOGObjectLikesRequestWrapper objectLikesRequest =
+                        new GetOGObjectLikesRequestWrapper(verifiedObjectId, objectType);
+                final GetEngagementRequestWrapper engagementRequest =
+                        new GetEngagementRequestWrapper(verifiedObjectId, objectType);
+
+                GraphRequestBatch requestBatch = new GraphRequestBatch();
+                objectLikesRequest.addToBatch(requestBatch);
+                engagementRequest.addToBatch(requestBatch);
+
+                requestBatch.addCallback(new GraphRequestBatch.Callback() {
+                    @Override
+                    public void onBatchCompleted(GraphRequestBatch batch) {
+                        if (objectLikesRequest.error != null ||
+                                engagementRequest.error != null) {
+                            // Refreshing is best-effort. If the refresh fails, don't lose old
+                            // state.
+                            Logger.log(
+                                    LoggingBehavior.REQUESTS,
+                                    TAG,
+                                    "Unable to refresh like state for id: '%s'", objectId);
+                            return;
+                        }
+
+                        updateState(
+                                objectLikesRequest.objectIsLiked,
+                                engagementRequest.likeCountStringWithLike,
+                                engagementRequest.likeCountStringWithoutLike,
+                                engagementRequest.socialSentenceStringWithLike,
+                                engagementRequest.socialSentenceStringWithoutLike,
+                                objectLikesRequest.unlikeToken);
+                    }
+                });
+
+                requestBatch.executeAsync();
+            }
+        });
+    }
+
+    private void refreshStatusViaService() {
+        LikeStatusClient likeStatusClient = new LikeStatusClient(
+                FacebookSdk.getApplicationContext(),
+                FacebookSdk.getApplicationId(),
+                objectId);
+        if (!likeStatusClient.start()) {
+            return;
+        }
+
+        LikeStatusClient.CompletedListener callback = new LikeStatusClient.CompletedListener() {
+            @Override
+            public void completed(Bundle result) {
+                // Don't lose old state if the service response is incomplete.
+                if (result == null || !result.containsKey(ShareConstants.EXTRA_OBJECT_IS_LIKED)) {
+                    return;
+                }
+
+                boolean objectIsLiked = result.getBoolean(ShareConstants.EXTRA_OBJECT_IS_LIKED);
+
+                String likeCountWithLike =
+                        result.containsKey(ShareConstants.EXTRA_LIKE_COUNT_STRING_WITH_LIKE)
+                                ? result.getString(ShareConstants.EXTRA_LIKE_COUNT_STRING_WITH_LIKE)
+                                : LikeActionController.this.likeCountStringWithLike;
+
+                String likeCountWithoutLike =
+                        result.containsKey(ShareConstants.EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE)
+                                ? result.getString(
+                                ShareConstants.EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE)
+                                : LikeActionController.this.likeCountStringWithoutLike;
+
+                String socialSentenceWithLike =
+                        result.containsKey(ShareConstants.EXTRA_SOCIAL_SENTENCE_WITH_LIKE)
+                                ? result.getString(ShareConstants.EXTRA_SOCIAL_SENTENCE_WITH_LIKE)
+                                : LikeActionController.this.socialSentenceWithLike;
+
+                String socialSentenceWithoutLike =
+                        result.containsKey(ShareConstants.EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE)
+                                ? result.getString(
+                                ShareConstants.EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE)
+                                : LikeActionController.this.socialSentenceWithoutLike;
+
+                String unlikeToken =
+                        result.containsKey(ShareConstants.EXTRA_UNLIKE_TOKEN)
+                                ? result.getString(ShareConstants.EXTRA_UNLIKE_TOKEN)
+                                : LikeActionController.this.unlikeToken;
+
+                updateState(
+                        objectIsLiked,
+                        likeCountWithLike,
+                        likeCountWithoutLike,
+                        socialSentenceWithLike,
+                        socialSentenceWithoutLike,
+                        unlikeToken);
+            }
+        };
+
+        likeStatusClient.setCompletedListener(callback);
+    }
+
+    private void publishAgainIfNeeded(final Bundle analyticsParameters) {
+        if (isObjectLiked != isObjectLikedOnServer &&
+                !publishLikeOrUnlikeAsync(isObjectLiked, analyticsParameters)) {
+            // Unable to re-publish the new desired state. Signal that there is an error and
+            // revert the like state back.
+            publishDidError(!isObjectLiked);
+        }
+    }
+
+    private void fetchVerifiedObjectId(final RequestCompletionCallback completionHandler) {
+        if (!Utility.isNullOrEmpty(verifiedObjectId)) {
+            if (completionHandler != null) {
+                completionHandler.onComplete();
+            }
+
+            return;
+        }
+
+        final GetOGObjectIdRequestWrapper objectIdRequest =
+                new GetOGObjectIdRequestWrapper(objectId, objectType);
+        final GetPageIdRequestWrapper pageIdRequest =
+                new GetPageIdRequestWrapper(objectId, objectType);
+
+        GraphRequestBatch requestBatch = new GraphRequestBatch();
+        objectIdRequest.addToBatch(requestBatch);
+        pageIdRequest.addToBatch(requestBatch);
+
+        requestBatch.addCallback(new GraphRequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(GraphRequestBatch batch) {
+                verifiedObjectId = objectIdRequest.verifiedObjectId;
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    verifiedObjectId = pageIdRequest.verifiedObjectId;
+                    objectIsPage = pageIdRequest.objectIsPage;
+                }
+
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    Logger.log(LoggingBehavior.DEVELOPER_ERRORS,
+                            TAG,
+                            "Unable to verify the FB id for '%s'. Verify that it is a valid FB" +
+                                    " object or page",
+                            objectId);
+                    logAppEventForError("get_verified_id",
+                            pageIdRequest.error != null
+                                    ? pageIdRequest.error
+                                    : objectIdRequest.error);
+                }
+
+                if (completionHandler != null) {
+                    completionHandler.onComplete();
+                }
+            }
+        });
+
+        requestBatch.executeAsync();
+    }
+
+    private void logAppEventForError(String action, Bundle parameters) {
+        Bundle logParams = new Bundle(parameters);
+        logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_ID, objectId);
+        logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_TYPE, objectType.toString());
+        logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_CURRENT_ACTION, action);
+
+        getAppEventsLogger().logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_ERROR, null, logParams);
+    }
+
+    private void logAppEventForError(String action, FacebookRequestError error) {
+        Bundle logParams = new Bundle();
+        if (error != null) {
+            JSONObject requestResult = error.getRequestResult();
+            if (requestResult != null) {
+                logParams.putString(
+                        AnalyticsEvents.PARAMETER_LIKE_VIEW_ERROR_JSON,
+                        requestResult.toString());
+            }
+        }
+        logAppEventForError(action, logParams);
+    }
+
+    //
+    // Interfaces
+    //
+
+    /**
+     * Used by the call to getControllerForObjectId()
+     */
+    public interface CreationCallback {
+        public void onComplete(
+                LikeActionController likeActionController,
+                FacebookException error);
+    }
+
+    /**
+     * Used by all the request wrappers
+     */
+    private interface RequestCompletionCallback {
+        void onComplete();
+    }
+
+    //
+    // Inner classes
+    //
+
+    private class GetOGObjectIdRequestWrapper extends AbstractRequestWrapper {
+        String verifiedObjectId;
+
+        GetOGObjectIdRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            super(objectId, objectType);
+
+            Bundle objectIdRequestParams = new Bundle();
+            objectIdRequestParams.putString("fields", "og_object.fields(id)");
+            objectIdRequestParams.putString("ids", objectId);
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    "",
+                    objectIdRequestParams,
+                    HttpMethod.GET));
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            // If this object Id is for a Page, an error will be received for this request
+            // We will then rely on the other request to come through.
+            if (error.getErrorMessage().contains("og_object")) {
+                this.error = null;
+            } else {
+                Logger.log(LoggingBehavior.REQUESTS,
+                        TAG,
+                        "Error getting the FB id for object '%s' with type '%s' : %s",
+                        objectId,
+                        objectType,
+                        error);
+            }
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+            JSONObject results = Utility.tryGetJSONObjectFromResponse(
+                    response.getJSONObject(),
+                    objectId);
+            if (results != null) {
+                // See if we can get the OG object Id out
+                JSONObject ogObject = results.optJSONObject("og_object");
+                if (ogObject != null) {
+                    verifiedObjectId = ogObject.optString("id");
+                }
+            }
+        }
+    }
+
+    private class GetPageIdRequestWrapper extends AbstractRequestWrapper {
+        String verifiedObjectId;
+        boolean objectIsPage;
+
+        GetPageIdRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            super(objectId, objectType);
+
+            Bundle pageIdRequestParams = new Bundle();
+            pageIdRequestParams.putString("fields", "id");
+            pageIdRequestParams.putString("ids", objectId);
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    "",
+                    pageIdRequestParams,
+                    HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+            JSONObject results = Utility.tryGetJSONObjectFromResponse(
+                    response.getJSONObject(),
+                    objectId);
+            if (results != null) {
+                verifiedObjectId = results.optString("id");
+                objectIsPage = !Utility.isNullOrEmpty(verifiedObjectId);
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error getting the FB id for object '%s' with type '%s' : %s",
+                    objectId,
+                    objectType,
+                    error);
+        }
+    }
+
+    private class PublishLikeRequestWrapper extends AbstractRequestWrapper {
+        String unlikeToken;
+
+        PublishLikeRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            super(objectId, objectType);
+
+            Bundle likeRequestParams = new Bundle();
+            likeRequestParams.putString("object", objectId);
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    "me/og.likes",
+                    likeRequestParams,
+                    HttpMethod.POST));
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+            unlikeToken = Utility.safeGetStringFromResponse(response.getJSONObject(), "id");
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            int errorCode = error.getErrorCode();
+            if (errorCode == ERROR_CODE_OBJECT_ALREADY_LIKED) {
+                // This isn't an error for us. Client was just out of sync with server
+                // This will prevent us from showing the dialog for this.
+
+                // However, there is no unliketoken. So a subsequent unlike WILL show the dialog
+                this.error = null;
+            } else {
+                Logger.log(LoggingBehavior.REQUESTS,
+                        TAG,
+                        "Error liking object '%s' with type '%s' : %s",
+                        objectId,
+                        objectType,
+                        error);
+                logAppEventForError("publish_like", error);
+            }
+        }
+    }
+
+    private class PublishUnlikeRequestWrapper extends AbstractRequestWrapper {
+        private String unlikeToken;
+
+        PublishUnlikeRequestWrapper(String unlikeToken) {
+            super(null, null);
+
+            this.unlikeToken = unlikeToken;
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    unlikeToken,
+                    null,
+                    HttpMethod.DELETE));
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error unliking object with unlike token '%s' : %s", unlikeToken, error);
+            logAppEventForError("publish_unlike", error);
+        }
+    }
+
+    private class GetOGObjectLikesRequestWrapper extends AbstractRequestWrapper {
+        // Initialize the like status to what we currently have. This way, empty/error responses
+        // don't end up clearing out the state.
+        boolean objectIsLiked = LikeActionController.this.isObjectLiked;
+        String unlikeToken;
+
+        GetOGObjectLikesRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            super(objectId, objectType);
+
+            Bundle requestParams = new Bundle();
+            requestParams.putString("fields", "id,application");
+            requestParams.putString("object", objectId);
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    "me/og.likes",
+                    requestParams,
+                    HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+            JSONArray dataSet = Utility.tryGetJSONArrayFromResponse(
+                    response.getJSONObject(),
+                    "data");
+            if (dataSet != null) {
+                for (int i = 0; i < dataSet.length(); i++) {
+                    JSONObject data = dataSet.optJSONObject(i);
+                    if (data != null) {
+                        objectIsLiked = true;
+                        JSONObject appData = data.optJSONObject("application");
+                        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+                        if (appData != null &&
+                                accessToken != null &&
+                                Utility.areObjectsEqual(
+                                        accessToken.getApplicationId(),
+                                        appData.optString("id"))) {
+                            unlikeToken = data.optString("id");
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error fetching like status for object '%s' with type '%s' : %s",
+                    objectId,
+                    objectType,
+                    error);
+            logAppEventForError("get_og_object_like", error);
+        }
+    }
+
+    private class GetEngagementRequestWrapper extends AbstractRequestWrapper {
+        // Initialize the like status to what we currently have. This way, empty/error responses
+        // don't end up clearing out the state.
+        String likeCountStringWithLike = LikeActionController.this.likeCountStringWithLike;
+        String likeCountStringWithoutLike = LikeActionController.this.likeCountStringWithoutLike;
+        String socialSentenceStringWithLike = LikeActionController.this.socialSentenceWithLike;
+        String socialSentenceStringWithoutLike =
+                LikeActionController.this.socialSentenceWithoutLike;
+
+        GetEngagementRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            super(objectId, objectType);
+
+            Bundle requestParams = new Bundle();
+            requestParams.putString(
+                    "fields",
+                    "engagement.fields(" +
+                            "count_string_with_like," +
+                            "count_string_without_like," +
+                            "social_sentence_with_like," +
+                            "social_sentence_without_like)");
+
+            setRequest(new GraphRequest(
+                    AccessToken.getCurrentAccessToken(),
+                    objectId,
+                    requestParams,
+                    HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(GraphResponse response) {
+            JSONObject engagementResults = Utility.tryGetJSONObjectFromResponse(
+                    response.getJSONObject(),
+                    "engagement");
+            if (engagementResults != null) {
+                // Missing properties in the response should default to cached like status
+                likeCountStringWithLike =
+                        engagementResults.optString(
+                                "count_string_with_like",
+                                likeCountStringWithLike);
+
+                likeCountStringWithoutLike =
+                        engagementResults.optString(
+                                "count_string_without_like",
+                                likeCountStringWithoutLike);
+
+                socialSentenceStringWithLike =
+                        engagementResults.optString(
+                                "social_sentence_with_like",
+                                socialSentenceStringWithLike);
+
+                socialSentenceStringWithoutLike =
+                        engagementResults.optString(
+                                "social_sentence_without_like",
+                                socialSentenceStringWithoutLike);
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error fetching engagement for object '%s' with type '%s' : %s",
+                    objectId,
+                    objectType,
+                    error);
+            logAppEventForError("get_engagement", error);
+        }
+    }
+
+    private abstract class AbstractRequestWrapper {
+        private GraphRequest request;
+        protected String objectId;
+        protected LikeView.ObjectType objectType;
+
+        FacebookRequestError error;
+
+        protected AbstractRequestWrapper(String objectId, LikeView.ObjectType objectType) {
+            this.objectId = objectId;
+            this.objectType = objectType;
+        }
+
+        void addToBatch(GraphRequestBatch batch) {
+            batch.add(request);
+        }
+
+        protected void setRequest(GraphRequest request) {
+            this.request = request;
+            // Make sure that our requests are hitting the latest version of the API known to this
+            // sdk.
+            request.setVersion(ServerProtocol.GRAPH_API_VERSION);
+            request.setCallback(new GraphRequest.Callback() {
+                @Override
+                public void onCompleted(GraphResponse response) {
+                    error = response.getError();
+                    if (error != null) {
+                        processError(error);
+                    } else {
+                        processSuccess(response);
+                    }
+                }
+            });
+        }
+
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error running request for object '%s' with type '%s' : %s",
+                    objectId,
+                    objectType,
+                    error);
+        }
+
+        protected abstract void processSuccess(GraphResponse response);
+    }
+
+    // Performs cache re-ordering/trimming to keep most-recently-used items up front
+    // ** NOTE ** It is expected that only _ONE_ MRUCacheWorkItem is ever running. This is enforced
+    // by setting the concurrency of the WorkQueue to 1. Changing the concurrency will most likely
+    // lead to errors.
+    private static class MRUCacheWorkItem implements Runnable {
+        private static ArrayList<String> mruCachedItems = new ArrayList<String>();
+        private String cacheItem;
+        private boolean shouldTrim;
+
+        MRUCacheWorkItem(String cacheItem, boolean shouldTrim) {
+            this.cacheItem = cacheItem;
+            this.shouldTrim = shouldTrim;
+        }
+
+        @Override
+        public void run() {
+            if (cacheItem != null) {
+                mruCachedItems.remove(cacheItem);
+                mruCachedItems.add(0, cacheItem);
+            }
+            if (shouldTrim && mruCachedItems.size() >= MAX_CACHE_SIZE) {
+                int targetSize = MAX_CACHE_SIZE / 2; // Optimize for fewer trim-passes.
+                while (targetSize < mruCachedItems.size()) {
+                    String cacheKey = mruCachedItems.remove(mruCachedItems.size() - 1);
+
+                    // Here is where we actually remove from the cache of LikeActionControllers.
+                    cache.remove(cacheKey);
+                }
+            }
+        }
+    }
+
+    private static class SerializeToDiskWorkItem implements Runnable {
+        private String cacheKey;
+        private String controllerJson;
+
+        SerializeToDiskWorkItem(String cacheKey, String controllerJson) {
+            this.cacheKey = cacheKey;
+            this.controllerJson = controllerJson;
+        }
+
+        @Override
+        public void run() {
+            serializeToDiskSynchronously(cacheKey, controllerJson);
+        }
+    }
+
+    private static class CreateLikeActionControllerWorkItem implements Runnable {
+        private String objectId;
+        private LikeView.ObjectType objectType;
+        private CreationCallback callback;
+
+        CreateLikeActionControllerWorkItem(
+                String objectId,
+                LikeView.ObjectType objectType,
+                CreationCallback callback) {
+            this.objectId = objectId;
+            this.objectType = objectType;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            createControllerForObjectIdAndType(objectId, objectType, callback);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeBoxCountView.java b/facebook/src/com/facebook/share/internal/LikeBoxCountView.java
new file mode 100644
index 000000000..23cf68ffe
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeBoxCountView.java
@@ -0,0 +1,229 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.content.Context;
+import android.graphics.*;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+import com.facebook.R;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class LikeBoxCountView extends FrameLayout {
+
+    public enum LikeBoxCountViewCaretPosition {
+        LEFT,
+        TOP,
+        RIGHT,
+        BOTTOM
+    }
+
+    private TextView likeCountLabel;
+    private LikeBoxCountViewCaretPosition caretPosition = LikeBoxCountViewCaretPosition.LEFT;
+
+    private float caretHeight;
+    private float caretWidth;
+    private float borderRadius;
+    private Paint borderPaint;
+    private int textPadding;
+    private int additionalTextPadding;
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public LikeBoxCountView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Sets the text for this view
+     * @param text
+     */
+    public void setText(String text) {
+        likeCountLabel.setText(text);
+    }
+
+    /**
+     * Sets the caret's position. This will trigger a layout of the view.
+     * @param caretPosition
+     */
+    public void setCaretPosition(LikeBoxCountViewCaretPosition caretPosition) {
+        this.caretPosition = caretPosition;
+
+        // Since the presence of a caret will move that edge closer to the text, let's add
+        // some padding (equal to caretHeight) in that same direction
+        switch (caretPosition) {
+            case LEFT:
+                setAdditionalTextPadding(additionalTextPadding, 0, 0, 0);
+                break;
+            case TOP:
+                setAdditionalTextPadding(0, additionalTextPadding, 0, 0);
+                break;
+            case RIGHT:
+                setAdditionalTextPadding(0, 0, additionalTextPadding, 0);
+                break;
+            case BOTTOM:
+                setAdditionalTextPadding(0, 0, 0, additionalTextPadding);
+                break;
+        }
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        int top = getPaddingTop(), left = getPaddingLeft();
+        int right = getWidth() - getPaddingRight(), bottom = getHeight() - getPaddingBottom();
+
+        switch (caretPosition) {
+            case BOTTOM:
+                bottom -= caretHeight;
+                break;
+            case LEFT:
+                left += caretHeight;
+                break;
+            case TOP:
+                top += caretHeight;
+                break;
+            case RIGHT:
+                right -= caretHeight;
+                break;
+        }
+
+        drawBorder(canvas, left, top, right, bottom);
+    }
+
+    private void initialize(Context context) {
+        setWillNotDraw(false); // Required for the onDraw() method to be called on a FrameLayout
+        caretHeight = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_caret_height);
+        caretWidth = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_caret_width);
+        borderRadius = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_border_radius);
+
+        borderPaint = new Paint();
+        borderPaint.setColor(
+                getResources().getColor(R.color.com_facebook_likeboxcountview_border_color));
+        borderPaint.setStrokeWidth(getResources().getDimension(R.dimen.com_facebook_likeboxcountview_border_width));
+        borderPaint.setStyle(Paint.Style.STROKE);
+
+        initializeLikeCountLabel(context);
+
+        addView(likeCountLabel);
+
+        setCaretPosition(this.caretPosition);
+    }
+
+    private void initializeLikeCountLabel(Context context) {
+        likeCountLabel = new TextView(context);
+        LayoutParams likeCountLabelLayoutParams = new LayoutParams(
+                ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT);
+        likeCountLabel.setLayoutParams(likeCountLabelLayoutParams);
+        likeCountLabel.setGravity(Gravity.CENTER);
+        likeCountLabel.setTextSize(
+                TypedValue.COMPLEX_UNIT_PX,
+                getResources().getDimension(R.dimen.com_facebook_likeboxcountview_text_size));
+        likeCountLabel.setTextColor(
+                getResources().getColor(R.color.com_facebook_likeboxcountview_text_color));
+        textPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeboxcountview_text_padding);
+
+        // Calculate the additional text padding that will be applied in the direction of the caret.
+        additionalTextPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeboxcountview_caret_height);
+    }
+
+    private void setAdditionalTextPadding(int left, int top, int right, int bottom) {
+        likeCountLabel.setPadding(
+                textPadding + left,
+                textPadding + top,
+                textPadding + right,
+                textPadding + bottom);
+    }
+
+    private void drawBorder(Canvas canvas, float left, float top, float right, float bottom) {
+        Path borderPath = new Path();
+
+        float ovalSize = 2.0f * borderRadius;
+
+        // Top left corner
+        borderPath.addArc(new RectF(left, top, left + ovalSize, top + ovalSize), -180, 90);
+
+        // Top caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.TOP) {
+            borderPath.lineTo(left + (right - left - caretWidth) / 2, top);
+            borderPath.lineTo(left + (right - left) / 2, top - caretHeight);
+            borderPath.lineTo(left + (right - left + caretWidth) / 2, top);
+        }
+
+        // Move to top right corner
+        borderPath.lineTo(right - borderRadius, top);
+
+        // Top right corner
+        borderPath.addArc(new RectF(right - ovalSize, top, right, top + ovalSize), -90, 90);
+
+        // Right caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.RIGHT) {
+            borderPath.lineTo(right, top + (bottom - top - caretWidth) / 2);
+            borderPath.lineTo(right + caretHeight, top + (bottom - top) / 2);
+            borderPath.lineTo(right, top + (bottom - top + caretWidth) / 2);
+        }
+
+        // Move to bottom right corner
+        borderPath.lineTo(right, bottom - borderRadius);
+
+        // Bottom right corner
+        borderPath.addArc(new RectF(right - ovalSize, bottom - ovalSize, right, bottom), 0, 90);
+
+        // Bottom caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.BOTTOM) {
+            borderPath.lineTo(left + (right - left + caretWidth) / 2, bottom);
+            borderPath.lineTo(left + (right - left) / 2, bottom + caretHeight);
+            borderPath.lineTo(left + (right - left - caretWidth) / 2, bottom);
+        }
+
+        // Move to bottom left corner
+        borderPath.lineTo(left + borderRadius, bottom);
+
+        // Bottom left corner
+        borderPath.addArc(new RectF(left, bottom - ovalSize, left + ovalSize, bottom), 90, 90);
+
+        // Left caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.LEFT) {
+            borderPath.lineTo(left, top + (bottom - top + caretWidth) / 2);
+            borderPath.lineTo(left - caretHeight, top + (bottom - top) / 2);
+            borderPath.lineTo(left, top + (bottom - top - caretWidth) / 2);
+        }
+
+        // Move back to the beginning
+        borderPath.lineTo(left, top + borderRadius);
+
+        canvas.drawPath(borderPath, borderPaint);
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeButton.java b/facebook/src/com/facebook/share/internal/LikeButton.java
new file mode 100644
index 000000000..82e4b3fac
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeButton.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import com.facebook.FacebookButtonBase;
+import com.facebook.R;
+import com.facebook.internal.AnalyticsEvents;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ */
+public class LikeButton extends FacebookButtonBase {
+    public LikeButton(Context context, boolean isLiked) {
+        super(context, null, 0, 0, AnalyticsEvents.EVENT_LIKE_BUTTON_CREATE, 0);
+        this.setSelected(isLiked);
+    }
+
+    @Override
+    public void setSelected(boolean selected) {
+        super.setSelected(selected);
+        updateForLikeStatus();
+    }
+
+    @Override
+    protected void configureButton(
+            Context context,
+            AttributeSet attrs,
+            int defStyleAttr,
+            int defStyleRes) {
+        super.configureButton(context, attrs, defStyleAttr, defStyleRes);
+        updateForLikeStatus();
+    }
+
+    @Override
+    protected int getDefaultStyleResource() {
+        return R.style.com_facebook_button_like;
+    }
+
+    private void updateForLikeStatus() {
+        // the compound drawables don't support selectors, so we need to update for the status
+        if (isSelected()) {
+            this.setCompoundDrawablesWithIntrinsicBounds(
+                    R.drawable.com_facebook_button_like_icon_selected, 0, 0, 0);
+            this.setText(getResources().getString(R.string.com_facebook_like_button_liked));
+        } else {
+            this.setCompoundDrawablesWithIntrinsicBounds(
+                    R.drawable.com_facebook_button_icon, 0, 0, 0);
+            this.setText(getResources().getString(R.string.com_facebook_like_button_not_liked));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeContent.java b/facebook/src/com/facebook/share/internal/LikeContent.java
new file mode 100644
index 000000000..49e71a8b8
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeContent.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.os.Parcel;
+
+import com.facebook.share.model.ShareModel;
+import com.facebook.share.model.ShareModelBuilder;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ *
+ * Represents content that is set on a LikeView to allow users to like and unlike it.
+ */
+public class LikeContent implements ShareModel {
+
+    private final String objectId;
+    private final String objectType;
+
+    private LikeContent(final Builder builder) {
+        this.objectId = builder.objectId;
+        this.objectType = builder.objectType;
+    }
+
+    LikeContent(final Parcel in) {
+        this.objectId = in.readString();
+        this.objectType = in.readString();
+    }
+
+    /**
+     * Gets the object Id for the LikeView.
+     *
+     * @return the object Id
+     */
+    public String getObjectId() {
+        return objectId;
+    }
+
+    /**
+     * Gets the type of the object for the LikeView.
+     *
+     * @return the type of the object
+     */
+    public String getObjectType() {
+        return objectType;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeString(this.objectId);
+        out.writeString(this.objectType);
+    }
+
+    /**
+     * Builder class for a concrete instance of AppInviteContent
+     */
+    public static class Builder
+            implements ShareModelBuilder<LikeContent, Builder> {
+        private String objectId;
+        private String objectType;
+
+        /**
+         * Sets the object Id for the LikeView
+         * @param objectId the object Id
+         */
+        public Builder setObjectId(final String objectId) {
+            this.objectId = objectId;
+            return this;
+        }
+
+        /**
+         * Sets the type of the object for the LikeView
+         * @param objectType the type of the object
+         */
+        public Builder setObjectType(final String objectType) {
+            this.objectType = objectType;
+            return this;
+        }
+
+        @Override
+        public LikeContent build() {
+            return new LikeContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final LikeContent content) {
+            if (content == null) {
+                return this;
+            }
+            return this
+                    .setObjectId(content.getObjectId())
+                    .setObjectType(content.getObjectType());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom((LikeContent) parcel
+                    .readParcelable(LikeContent.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeDialog.java b/facebook/src/com/facebook/share/internal/LikeDialog.java
new file mode 100644
index 000000000..774dd6570
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeDialog.java
@@ -0,0 +1,158 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.app.Activity;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+
+import com.facebook.FacebookCallback;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.DialogPresenter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class LikeDialog extends FacebookDialogBase<LikeContent, LikeDialog.Result> {
+
+    private static final String TAG = "LikeDialog";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Like.toRequestCode();
+
+    public static final class Result {
+    }
+
+    // Public for internal use
+    public static boolean canShowNativeDialog() {
+        return (Build.VERSION.SDK_INT >= ShareConstants.MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS) &&
+                DialogPresenter.canPresentNativeDialogWithFeature(getFeature());
+    }
+
+    // Public for internal use
+    public static boolean canShowWebFallback() {
+        return (Build.VERSION.SDK_INT >= ShareConstants.MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS) &&
+                DialogPresenter.canPresentWebFallbackDialogWithFeature(getFeature());
+    }
+
+    LikeDialog(Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+    }
+
+    LikeDialog(Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new NativeHandler());
+        handlers.add(new WebFallbackHandler());
+
+        return handlers;
+    }
+
+    @Override
+    protected void registerCallbackImpl (
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        throw new UnsupportedOperationException("registerCallback is not supported for LikeDialog");
+    }
+
+    private class NativeHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final LikeContent content) {
+            return (content != null) && LikeDialog.canShowNativeDialog();
+        }
+
+        @Override
+        public AppCall createAppCall(final LikeContent content) {
+            final AppCall appCall = createBaseAppCall();
+
+            DialogPresenter.setupAppCallForNativeDialog(
+                    appCall,
+                    new DialogPresenter.ParameterProvider() {
+                        @Override
+                        public Bundle getParameters() {
+                            return createParameters(content);
+                        }
+
+                        @Override
+                        public Bundle getLegacyParameters() {
+                            // Like is not supported with legacy fb4a devices. Should never get here
+                            Log.e(TAG, "Attempting to present the Like Dialog with an outdated " +
+                                    "Facebook app on the device");
+                            return new Bundle();
+                        }
+                    },
+                    getFeature());
+
+            return appCall;
+        }
+    }
+
+    private class WebFallbackHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final LikeContent content) {
+            return (content != null) && LikeDialog.canShowWebFallback();
+        }
+
+        @Override
+        public AppCall createAppCall(final LikeContent content) {
+            final AppCall appCall = createBaseAppCall();
+
+            DialogPresenter.setupAppCallForWebFallbackDialog(
+                    appCall,
+                    createParameters(content),
+                    getFeature());
+
+            return appCall;
+        }
+    }
+
+    private static DialogFeature getFeature() {
+        return LikeDialogFeature.LIKE_DIALOG;
+    }
+
+    private static Bundle createParameters(final LikeContent likeContent) {
+        Bundle params = new Bundle();
+
+        params.putString(ShareConstants.OBJECT_ID, likeContent.getObjectId());
+        params.putString(ShareConstants.OBJECT_TYPE, likeContent.getObjectType());
+
+        return params;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeDialogFeature.java b/facebook/src/com/facebook/share/internal/LikeDialogFeature.java
new file mode 100644
index 000000000..3ab0c9150
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeDialogFeature.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum LikeDialogFeature implements DialogFeature {
+
+    // This matches a value in a sitevar. DO NOT CHANGE
+    LIKE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20140701);
+
+    private int minVersion;
+
+    LikeDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    public String getAction() {
+        return NativeProtocol.ACTION_LIKE_DIALOG;
+    }
+
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/LikeStatusClient.java b/facebook/src/com/facebook/share/internal/LikeStatusClient.java
new file mode 100644
index 000000000..f890db8a5
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/LikeStatusClient.java
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+
+import android.content.Context;
+import android.os.Bundle;
+
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.PlatformServiceClient;
+import com.facebook.share.internal.ShareConstants;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the Facebook SDK for
+ * Android. Use of any of the classes in this package is unsupported, and they may be modified or
+ * removed without warning at any time.
+ *
+ * This class executes service calls to fetch like-state of objects from the Facebook Application,
+ * if available.
+ */
+final class LikeStatusClient extends PlatformServiceClient {
+    private String objectId;
+
+    LikeStatusClient(Context context, String applicationId, String objectId) {
+        super(context,
+                NativeProtocol.MESSAGE_GET_LIKE_STATUS_REQUEST,
+                NativeProtocol.MESSAGE_GET_LIKE_STATUS_REPLY,
+                NativeProtocol.PROTOCOL_VERSION_20141001,
+                applicationId);
+
+        this.objectId = objectId;
+    }
+
+    @Override
+    protected void populateRequestBundle(Bundle data) {
+        // Only thing we need to pass in is the object id.
+        data.putString(ShareConstants.EXTRA_OBJECT_ID, objectId);
+    }
+}
+
diff --git a/facebook/src/com/facebook/share/internal/MessageDialogFeature.java b/facebook/src/com/facebook/share/internal/MessageDialogFeature.java
new file mode 100644
index 000000000..40199d8b0
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/MessageDialogFeature.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum MessageDialogFeature implements DialogFeature {
+    /**
+     * Indicates whether the native Message dialog itself is supported by the installed version of
+     * the Facebook Messenger application.
+     */
+    MESSAGE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20140204),
+    /**
+     * Indicates whether the native Message dialog supports sharing of photo images.
+     */
+    PHOTOS(NativeProtocol.PROTOCOL_VERSION_20140324),
+    /**
+     * Indicates whether the native Message dialog supports sharing of videos.
+     */
+    VIDEO(NativeProtocol.PROTOCOL_VERSION_20141218),
+    ;
+
+    private int minVersion;
+
+    MessageDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public String getAction() {
+        return NativeProtocol.ACTION_MESSAGE_DIALOG;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/NativeDialogParameters.java b/facebook/src/com/facebook/share/internal/NativeDialogParameters.java
new file mode 100644
index 000000000..16eb1ecc1
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/NativeDialogParameters.java
@@ -0,0 +1,170 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.content.Context;
+import android.os.Bundle;
+
+import com.facebook.FacebookException;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import com.facebook.share.model.ShareContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.SharePhotoContent;
+import com.facebook.share.model.ShareVideo;
+import com.facebook.share.model.ShareVideoContent;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class NativeDialogParameters {
+
+    public static Bundle create(
+            UUID callId,
+            ShareContent shareContent,
+            boolean shouldFailOnDataError) {
+        Validate.notNull(shareContent, "shareContent");
+        Validate.notNull(callId, "callId");
+
+        Bundle nativeParams = null;
+        if (shareContent instanceof ShareLinkContent) {
+            final ShareLinkContent linkContent = (ShareLinkContent) shareContent;
+            nativeParams = create(linkContent, shouldFailOnDataError);
+        } else if (shareContent instanceof SharePhotoContent) {
+            final SharePhotoContent photoContent = (SharePhotoContent) shareContent;
+            List<String> photoUrls = ShareInternalUtility.getPhotoUrls(
+                    photoContent,
+                    callId);
+
+            nativeParams = create(photoContent, photoUrls, shouldFailOnDataError);
+        } else if (shareContent instanceof ShareVideoContent) {
+            final ShareVideoContent videoContent = (ShareVideoContent) shareContent;
+            nativeParams = create(videoContent, shouldFailOnDataError);
+        } else if (shareContent instanceof ShareOpenGraphContent) {
+            final ShareOpenGraphContent openGraphContent = (ShareOpenGraphContent) shareContent;
+            final ShareOpenGraphAction action = openGraphContent.getAction();
+            try {
+                JSONObject openGraphActionJSON = ShareInternalUtility.toJSONObjectForCall(
+                        callId, action);
+                openGraphActionJSON = ShareInternalUtility.removeNamespacesFromOGJsonObject(
+                        openGraphActionJSON, false);
+                nativeParams = create(openGraphContent, openGraphActionJSON, shouldFailOnDataError);
+            } catch (final JSONException e) {
+                throw new FacebookException(
+                        "Unable to create a JSON Object from the provided ShareOpenGraphContent: "
+                                + e.getMessage());
+            }
+        }
+
+        return nativeParams;
+    }
+
+    private static Bundle create(ShareLinkContent linkContent, boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(linkContent, dataErrorsFatal);
+
+        Utility.putNonEmptyString(params, ShareConstants.TITLE, linkContent.getContentTitle());
+        Utility.putNonEmptyString(
+                params, ShareConstants.DESCRIPTION, linkContent.getContentDescription());
+        Utility.putUri(params, ShareConstants.IMAGE_URL, linkContent.getImageUrl());
+
+        return params;
+    }
+
+    private static Bundle create(
+            SharePhotoContent photoContent,
+            List<String> imageUrls,
+            boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(photoContent, dataErrorsFatal);
+
+        params.putStringArrayList(ShareConstants.PHOTOS, new ArrayList<>(imageUrls));
+
+        return params;
+    }
+
+    private static Bundle create(ShareVideoContent videoContent, boolean dataErrorsFatal) {
+        ShareVideo video = videoContent.getVideo();
+        Bundle params = createBaseParameters(videoContent, dataErrorsFatal);
+
+        Utility.putNonEmptyString(params, ShareConstants.TITLE, videoContent.getContentTitle());
+        Utility.putNonEmptyString(
+                params, ShareConstants.DESCRIPTION, videoContent.getContentDescription());
+        Utility.putUri(params, ShareConstants.VIDEO_URL, video.getLocalUrl());
+
+        return params;
+    }
+
+    private static Bundle create(
+            ShareOpenGraphContent openGraphContent,
+            JSONObject openGraphActionJSON,
+            boolean dataErrorsFatal) {
+        Bundle params = createBaseParameters(openGraphContent, dataErrorsFatal);
+
+        // Strip namespace from preview property name
+        String previewProperty = ShareInternalUtility.getFieldNameAndNamespaceFromFullName(
+                openGraphContent.getPreviewPropertyName()).second;
+
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.PREVIEW_PROPERTY_NAME,
+                previewProperty);
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.ACTION_TYPE,
+                openGraphContent.getAction().getActionType());
+
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.ACTION,
+                openGraphActionJSON.toString());
+
+        return params;
+    }
+
+    private static Bundle createBaseParameters(ShareContent content, boolean dataErrorsFatal) {
+        Bundle params = new Bundle();
+
+        Utility.putUri(params, ShareConstants.CONTENT_URL, content.getContentUrl());
+        Utility.putNonEmptyString(params, ShareConstants.PLACE_ID, content.getPlaceId());
+        Utility.putNonEmptyString(params, ShareConstants.REF, content.getRef());
+
+        params.putBoolean(ShareConstants.DATA_FAILURES_FATAL, dataErrorsFatal);
+
+        List<String> peopleIds = content.getPeopleIds();
+        if (!Utility.isNullOrEmpty(peopleIds)) {
+            params.putStringArrayList(
+                    ShareConstants.PEOPLE_IDS,
+                    new ArrayList<String>(peopleIds));
+        }
+
+        return params;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/OpenGraphActionDialogFeature.java b/facebook/src/com/facebook/share/internal/OpenGraphActionDialogFeature.java
new file mode 100644
index 000000000..5eefbcebe
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/OpenGraphActionDialogFeature.java
@@ -0,0 +1,57 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum OpenGraphActionDialogFeature implements DialogFeature {
+    /**
+     * Indicates whether the native Open Graph action dialog itself is supported by the installed
+     * version of the Facebook application.
+     */
+    OG_ACTION_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618);
+
+    private int minVersion;
+
+    OpenGraphActionDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public String getAction() {
+        return NativeProtocol.ACTION_OGACTIONPUBLISH_DIALOG;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/OpenGraphJSONUtility.java b/facebook/src/com/facebook/share/internal/OpenGraphJSONUtility.java
new file mode 100644
index 000000000..dfa01941d
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/OpenGraphJSONUtility.java
@@ -0,0 +1,121 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import com.facebook.internal.Validate;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphObject;
+import com.facebook.share.model.SharePhoto;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ *
+ * Utility methods for JSON representation of Open Graph models.
+ */
+public final class OpenGraphJSONUtility {
+    /**
+     * Converts an action to a JSONObject.
+     *
+     * NOTE: All images are removed from the JSON representation and must be added to the builder
+     * separately.
+     *
+     * @param action {@link com.facebook.share.model.ShareOpenGraphAction} to be converted.
+     * @return {@link org.json.JSONObject} representing the action.
+     * @throws JSONException
+     */
+    public static JSONObject toJSONObject(
+            final ShareOpenGraphAction action,
+            final PhotoJSONProcessor photoJSONProcessor) throws JSONException {
+        final JSONObject result = new JSONObject();
+        final Set<String> keys = action.keySet();
+        for (String key : keys) {
+            result.put(key, toJSONValue(action.get(key), photoJSONProcessor));
+        }
+        return result;
+    }
+
+    private static JSONObject toJSONObject(
+            final ShareOpenGraphObject object,
+            final PhotoJSONProcessor photoJSONProcessor) throws JSONException {
+        final JSONObject result = new JSONObject();
+        final Set<String> keys = object.keySet();
+        for (String key : keys) {
+            result.put(key, toJSONValue(object.get(key), photoJSONProcessor));
+        }
+        return result;
+    }
+
+    private static JSONArray toJSONArray(
+            final List list,
+            final PhotoJSONProcessor photoJSONProcessor) throws JSONException {
+        final JSONArray result = new JSONArray();
+        for (Object item : list) {
+            result.put(toJSONValue(item, photoJSONProcessor));
+        }
+        return result;
+    }
+
+    public static Object toJSONValue(
+            @Nullable final Object object,
+            final PhotoJSONProcessor photoJSONProcessor) throws JSONException {
+        if (object == null) {
+            return JSONObject.NULL;
+        }
+        if ((object instanceof String) ||
+                (object instanceof Boolean) ||
+                (object instanceof Double) ||
+                (object instanceof Float) ||
+                (object instanceof Integer) ||
+                (object instanceof Long)) {
+            return object;
+        }
+        if (object instanceof SharePhoto) {
+            if (photoJSONProcessor != null) {
+                return photoJSONProcessor.toJSONObject((SharePhoto) object);
+            }
+            return null;
+        }
+        if (object instanceof ShareOpenGraphObject) {
+            return toJSONObject((ShareOpenGraphObject) object, photoJSONProcessor);
+        }
+        if (object instanceof List) {
+            return toJSONArray((List) object, photoJSONProcessor);
+        }
+        throw new IllegalArgumentException(
+                "Invalid object found for JSON serialization: " +object.toString());
+    }
+
+    private OpenGraphJSONUtility() {}
+
+    public interface PhotoJSONProcessor {
+        public JSONObject toJSONObject(SharePhoto photo);
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/OpenGraphMessageDialogFeature.java b/facebook/src/com/facebook/share/internal/OpenGraphMessageDialogFeature.java
new file mode 100644
index 000000000..b064b7e77
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/OpenGraphMessageDialogFeature.java
@@ -0,0 +1,57 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum OpenGraphMessageDialogFeature implements DialogFeature {
+    /**
+     * Indicates whether the native Open Graph Message dialog itself is supported by the installed
+     * version of the Facebook Messenger application.
+     */
+    OG_MESSAGE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20140204);
+
+    private int minVersion;
+
+    OpenGraphMessageDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public String getAction() {
+        return NativeProtocol.ACTION_OGMESSAGEPUBLISH_DIALOG;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/ResultProcessor.java b/facebook/src/com/facebook/share/internal/ResultProcessor.java
new file mode 100644
index 000000000..0633d99da
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/ResultProcessor.java
@@ -0,0 +1,62 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.os.Bundle;
+
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.internal.AppCall;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ *
+ * Callback class to allow derivations of FacebookDialogBase to do custom operations
+ */
+public abstract class ResultProcessor {
+    private FacebookCallback appCallback;
+
+    public ResultProcessor(FacebookCallback callback) {
+        this.appCallback = callback;
+    }
+
+    public abstract void onSuccess(AppCall appCall, Bundle results);
+
+    /**
+     * Override this if anything needs to be done on cancellation (e.g. Logging)
+     */
+    public void onCancel(AppCall appCall) {
+        if (appCallback != null) {
+            appCallback.onCancel();
+        }
+    }
+
+    /**
+     * Override this if anything needs to be done on error (e.g. Logging)
+     */
+    public void onError(AppCall appCall, FacebookException error) {
+        if (appCallback != null) {
+            appCallback.onError(error);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/ShareConstants.java b/facebook/src/com/facebook/share/internal/ShareConstants.java
new file mode 100644
index 000000000..1d23422a0
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/ShareConstants.java
@@ -0,0 +1,120 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class ShareConstants {
+
+    public static final int MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS = 14;
+
+    public static final String WEB_DIALOG_PARAM_DATA = "data";
+    public static final String WEB_DIALOG_PARAM_MESSAGE = "message";
+    public static final String WEB_DIALOG_PARAM_TO = "to";
+    public static final String WEB_DIALOG_PARAM_TITLE = "title";
+    public static final String WEB_DIALOG_PARAM_ACTION_TYPE = "action_type";
+    public static final String WEB_DIALOG_PARAM_OBJECT_ID = "object_id";
+    public static final String WEB_DIALOG_PARAM_FILTERS = "filters";
+    public static final String WEB_DIALOG_PARAM_SUGGESTIONS = "suggestions";
+
+    public static final String WEB_DIALOG_PARAM_HREF = "href";
+    public static final String WEB_DIALOG_PARAM_ACTION_PROPERTIES = "action_properties";
+
+    public static final String WEB_DIALOG_PARAM_LINK = "link";
+    public static final String WEB_DIALOG_PARAM_PICTURE = "picture";
+    public static final String WEB_DIALOG_PARAM_NAME = "name";
+    public static final String WEB_DIALOG_PARAM_DESCRIPTION = "description";
+
+    public static final String WEB_DIALOG_PARAM_ID = "id";
+
+    public static final String WEB_DIALOG_PARAM_PRIVACY = "privacy";
+
+    public static final String WEB_DIALOG_RESULT_PARAM_POST_ID = "post_id";
+    public static final String WEB_DIALOG_RESULT_PARAM_REQUEST_ID = "request";
+    public static final String WEB_DIALOG_RESULT_PARAM_TO_ARRAY_MEMBER = "to[%d]";
+
+    // Extras supported for ACTION_FEED_DIALOG:
+    public static final String LEGACY_PLACE_TAG = "com.facebook.platform.extra.PLACE";
+    public static final String LEGACY_FRIEND_TAGS = "com.facebook.platform.extra.FRIENDS";
+    public static final String LEGACY_LINK = "com.facebook.platform.extra.LINK";
+    public static final String LEGACY_IMAGE = "com.facebook.platform.extra.IMAGE";
+    public static final String LEGACY_TITLE = "com.facebook.platform.extra.TITLE";
+    public static final String LEGACY_DESCRIPTION = "com.facebook.platform.extra.DESCRIPTION";
+    public static final String LEGACY_REF = "com.facebook.platform.extra.REF";
+    public static final String LEGACY_DATA_FAILURES_FATAL =
+            "com.facebook.platform.extra.DATA_FAILURES_FATAL";
+    public static final String LEGACY_PHOTOS = "com.facebook.platform.extra.PHOTOS";
+
+    public static final String PLACE_ID = "PLACE";
+    public static final String PEOPLE_IDS = "FRIENDS";
+    public static final String CONTENT_URL = "LINK";
+    public static final String IMAGE_URL = "IMAGE";
+    public static final String TITLE = "TITLE";
+    public static final String DESCRIPTION = "DESCRIPTION";
+    public static final String REF = "REF";
+    public static final String DATA_FAILURES_FATAL = "DATA_FAILURES_FATAL";
+    public static final String PHOTOS = "PHOTOS";
+    public static final String VIDEO_URL = "VIDEO";
+
+    // Extras supported for ACTION_OGACTIONPUBLISH_DIALOG:
+    public static final String LEGACY_ACTION = "com.facebook.platform.extra.ACTION";
+    public static final String LEGACY_ACTION_TYPE = "com.facebook.platform.extra.ACTION_TYPE";
+    public static final String LEGACY_PREVIEW_PROPERTY_NAME =
+            "com.facebook.platform.extra.PREVIEW_PROPERTY_NAME";
+
+    public static final String ACTION = "ACTION";
+    public static final String ACTION_TYPE = "ACTION_TYPE";
+    public static final String PREVIEW_PROPERTY_NAME = "PREVIEW_PROPERTY_NAME";
+
+    // Method args supported for ACTION_LIKE_DIALOG
+    public static final String OBJECT_ID = "object_id";
+    public static final String OBJECT_TYPE = "object_type";
+
+    // Method args supported for ACTION_APPINVITE_DIALOG
+    public static final String APPLINK_URL = "app_link_url";
+    public static final String PREVIEW_IMAGE_URL = "preview_image_url";
+
+    // Extras supported for MESSAGE_GET_LIKE_STATUS_REQUEST:
+    public static final String EXTRA_OBJECT_ID = "com.facebook.platform.extra.OBJECT_ID";
+
+    // Extras supported in MESSAGE_GET_LIKE_STATUS_REPLY:
+    public static final String EXTRA_OBJECT_IS_LIKED =
+            "com.facebook.platform.extra.OBJECT_IS_LIKED";
+    public static final String EXTRA_LIKE_COUNT_STRING_WITH_LIKE =
+            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITH_LIKE";
+    public static final String EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE =
+            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITHOUT_LIKE";
+    public static final String EXTRA_SOCIAL_SENTENCE_WITH_LIKE =
+            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITH_LIKE";
+    public static final String EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE =
+            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITHOUT_LIKE";
+    public static final String EXTRA_UNLIKE_TOKEN = "com.facebook.platform.extra.UNLIKE_TOKEN";
+
+    // Result keys from Native sharing dialogs
+    public static final String EXTRA_RESULT_POST_ID = "com.facebook.platform.extra.POST_ID";
+    public static final String RESULT_POST_ID = "postId";
+
+    public static final int MAXIMUM_PHOTO_COUNT = 6;
+    static final String MY_VIDEOS = "me/videos";
+}
diff --git a/facebook/src/com/facebook/share/internal/ShareContentValidation.java b/facebook/src/com/facebook/share/internal/ShareContentValidation.java
new file mode 100644
index 000000000..446c012c0
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/ShareContentValidation.java
@@ -0,0 +1,360 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.graphics.Bitmap;
+import android.net.Uri;
+
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import com.facebook.share.model.ShareContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.ShareOpenGraphObject;
+import com.facebook.share.model.ShareOpenGraphValueContainer;
+import com.facebook.share.model.SharePhoto;
+import com.facebook.share.model.SharePhotoContent;
+import com.facebook.share.model.ShareVideo;
+import com.facebook.share.model.ShareVideoContent;
+
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class ShareContentValidation {
+
+    private static Validator WebShareValidator;
+    private static Validator DefaultValidator;
+    private static Validator ApiValidator;
+
+    public static void validateForMessage(ShareContent content) {
+        validate(content, getDefaultValidator());
+    }
+
+    public static void validateForNativeShare(ShareContent content) {
+        validate(content, getDefaultValidator());
+    }
+
+    public static void validateForWebShare(ShareContent content) {
+        validate(content, getWebShareValidator());
+    }
+
+    public static void validateForApiShare(ShareContent content) {
+        validate(content, getApiValidator());
+    }
+
+    private static Validator getDefaultValidator() {
+        if (DefaultValidator == null) {
+            DefaultValidator = new Validator();
+        }
+        return DefaultValidator;
+    }
+
+    private static Validator getApiValidator() {
+        if (ApiValidator == null) {
+            ApiValidator = new ApiValidator();
+        }
+        return ApiValidator;
+    }
+
+    private static Validator getWebShareValidator() {
+        if (WebShareValidator == null) {
+            WebShareValidator = new WebShareValidator();
+        }
+        return WebShareValidator;
+    }
+
+    private static void validate(ShareContent content, Validator validator)
+            throws FacebookException {
+        if (content == null) {
+            throw new FacebookException("Must provide non-null content to share");
+        }
+
+        if (content instanceof ShareLinkContent) {
+            validator.validate((ShareLinkContent) content);
+        } else if (content instanceof SharePhotoContent) {
+            validator.validate((SharePhotoContent) content);
+        } else if (content instanceof ShareVideoContent) {
+            validator.validate((ShareVideoContent) content);
+        } else if (content instanceof ShareOpenGraphContent) {
+            validator.validate((ShareOpenGraphContent) content);
+        }
+    }
+
+    private static void validateLinkContent(
+            ShareLinkContent linkContent, Validator validator) {
+        Uri imageUrl = linkContent.getImageUrl();
+        if (imageUrl != null && !Utility.isWebUri(imageUrl)) {
+            throw new FacebookException("Image Url must be an http:// or https:// url");
+        }
+    }
+
+    private static void validatePhotoContent(
+            SharePhotoContent photoContent, Validator validator) {
+        List<SharePhoto> photos = photoContent.getPhotos();
+        if (photos == null || photos.isEmpty()) {
+            throw new FacebookException("Must specify at least one Photo in SharePhotoContent.");
+        }
+        if (photos.size() > ShareConstants.MAXIMUM_PHOTO_COUNT) {
+            throw new FacebookException(
+                    String.format(
+                            Locale.ROOT,
+                            "Cannot add more than %d photos.",
+                            ShareConstants.MAXIMUM_PHOTO_COUNT));
+        }
+
+        for (SharePhoto photo : photos) {
+            validator.validate(photo);
+        }
+    }
+
+    private static void validatePhotoForApi(SharePhoto photo, Validator validator) {
+        if (photo == null) {
+            throw new FacebookException("Cannot share a null SharePhoto");
+        }
+
+        Bitmap photoBitmap = photo.getBitmap();
+        Uri photoUri = photo.getImageUrl();
+
+        if (photoBitmap == null) {
+            if (photoUri == null) {
+                throw new FacebookException(
+                        "SharePhoto does not have a Bitmap or ImageUrl specified");
+            }
+
+            if (Utility.isWebUri(photoUri) && !validator.isOpenGraphContent()) {
+                throw new FacebookException(
+                        "Cannot set the ImageUrl of a SharePhoto to the Uri of an image on the " +
+                                "web when sharing SharePhotoContent");
+            }
+        }
+    }
+
+    private static void validatePhotoForNativeDialog(SharePhoto photo, Validator validator) {
+        validatePhotoForApi(photo, validator);
+
+        if (photo.getBitmap() != null || !Utility.isWebUri(photo.getImageUrl())) {
+            Validate.hasContentProvider(FacebookSdk.getApplicationContext());
+        }
+    }
+
+    private static void validatePhotoForWebDialog(SharePhoto photo, Validator validator) {
+        if (photo == null) {
+            throw new FacebookException("Cannot share a null SharePhoto");
+        }
+
+        Uri imageUri = photo.getImageUrl();
+        if (imageUri == null || !Utility.isWebUri(imageUri)) {
+            throw new FacebookException(
+                    "SharePhoto must have a non-null imageUrl set to the Uri of an image " +
+                            "on the web");
+        }
+    }
+
+    private static void validateVideoContent(
+            ShareVideoContent videoContent, Validator validator) {
+        validator.validate(videoContent.getVideo());
+
+        SharePhoto previewPhoto = videoContent.getPreviewPhoto();
+        if (previewPhoto != null) {
+            validator.validate(previewPhoto);
+        }
+    }
+
+    private static void validateVideo(ShareVideo video, Validator validator) {
+        if (video == null) {
+            throw new FacebookException("Cannot share a null ShareVideo");
+        }
+
+        if (video.getLocalUrl() == null) {
+            throw new FacebookException("ShareVideo does not have a LocalUrl specified");
+        }
+    }
+
+    private static void validateOpenGraphContent(
+            ShareOpenGraphContent openGraphContent, Validator validator) {
+        validator.validate(openGraphContent.getAction());
+
+        String previewPropertyName = openGraphContent.getPreviewPropertyName();
+        if (Utility.isNullOrEmpty(previewPropertyName)) {
+            throw new FacebookException("Must specify a previewPropertyName.");
+        }
+
+        if (openGraphContent.getAction().get(previewPropertyName) == null) {
+            throw new FacebookException(
+                    "Property \"" + previewPropertyName + "\" was not found on the action. " +
+                            "The name of the preview property must match the name of an " +
+                            "action property.");
+        }
+    }
+
+    private static void validateOpenGraphAction(
+            ShareOpenGraphAction openGraphAction,
+            Validator validator) {
+        if (openGraphAction == null) {
+            throw new FacebookException("Must specify a non-null ShareOpenGraphAction");
+        }
+
+        if (Utility.isNullOrEmpty(openGraphAction.getActionType())) {
+            throw new FacebookException("ShareOpenGraphAction must have a non-empty actionType");
+        }
+
+        validator.validate((ShareOpenGraphValueContainer) openGraphAction, false);
+    }
+
+    private static void validateOpenGraphObject(
+            ShareOpenGraphObject openGraphObject,
+            Validator validator) {
+        if (openGraphObject == null) {
+            throw new FacebookException("Cannot share a null ShareOpenGraphObject");
+        }
+
+        validator.validate((ShareOpenGraphValueContainer) openGraphObject, true);
+    }
+
+    private static void validateOpenGraphValueContainer(
+            ShareOpenGraphValueContainer valueContainer,
+            Validator validator,
+            boolean requireNamespace) {
+        Set<String> keySet = valueContainer.keySet();
+        for (String key : keySet) {
+            validateOpenGraphKey(key, requireNamespace);
+            Object o = valueContainer.get(key);
+            if (o instanceof List) {
+                List list = (List) o;
+                for (Object objectInList : list) {
+                    if (objectInList == null) {
+                        throw new FacebookException(
+                                "Cannot put null objects in Lists in " +
+                                        "ShareOpenGraphObjects and ShareOpenGraphActions");
+                    }
+                    validateOpenGraphValueContainerObject(objectInList, validator);
+                }
+            } else {
+                validateOpenGraphValueContainerObject(o, validator);
+            }
+        }
+    }
+
+    private static void validateOpenGraphKey(String key, boolean requireNamespace) {
+        if (!requireNamespace) {
+            return;
+        }
+
+        String[] components = key.split(":");
+        if (components.length < 2) {
+            throw new FacebookException("Open Graph keys must be namespaced: %s", key);
+        }
+        for (String component : components) {
+            if (component.isEmpty()) {
+                throw new FacebookException("Invalid key found in Open Graph dictionary: %s", key);
+            }
+        }
+    }
+
+    private static void validateOpenGraphValueContainerObject(
+            Object o, Validator validator) {
+        if (o instanceof ShareOpenGraphObject) {
+            validator.validate((ShareOpenGraphObject) o);
+        } else if (o instanceof SharePhoto) {
+            validator.validate((SharePhoto) o);
+        }
+    }
+
+    private static class WebShareValidator extends Validator {
+        @Override
+        public void validate(final SharePhotoContent photoContent) {
+            throw new FacebookException("Cannot share SharePhotoContent via web sharing dialogs");
+        }
+
+        @Override
+        public void validate(final ShareVideoContent videoContent) {
+            throw new FacebookException("Cannot share ShareVideoContent via web sharing dialogs");
+        }
+
+        @Override
+        public void validate(final SharePhoto photo) {
+            validatePhotoForWebDialog(photo, this);
+        }
+    }
+
+    private static class ApiValidator extends Validator {
+        @Override
+        public void validate(final SharePhoto photo) {
+            validatePhotoForApi(photo, this);
+        }
+
+    }
+
+    private static class Validator {
+        private boolean isOpenGraphContent = false;
+
+        public void validate(final ShareLinkContent linkContent) {
+            validateLinkContent(linkContent, this);
+        }
+
+        public void validate(final SharePhotoContent photoContent) {
+            validatePhotoContent(photoContent, this);
+        }
+
+        public void validate(final ShareVideoContent videoContent) {
+            validateVideoContent(videoContent, this);
+        }
+
+        public void validate(final ShareOpenGraphContent openGraphContent) {
+            isOpenGraphContent = true;
+            validateOpenGraphContent(openGraphContent, this);
+        }
+
+        public void validate(final ShareOpenGraphAction openGraphAction) {
+            validateOpenGraphAction(openGraphAction, this);
+        }
+
+        public void validate(final ShareOpenGraphObject openGraphObject) {
+            validateOpenGraphObject(openGraphObject, this);
+        }
+
+        public void validate(final ShareOpenGraphValueContainer openGraphValueContainer,
+                             boolean requireNamespace) {
+            validateOpenGraphValueContainer(openGraphValueContainer, this, requireNamespace);
+        }
+
+        public void validate(final SharePhoto photo) {
+            validatePhotoForNativeDialog(photo, this);
+        }
+
+        public void validate(final ShareVideo video) {
+            validateVideo(video, this);
+        }
+
+        public boolean isOpenGraphContent() {
+            return isOpenGraphContent;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/ShareDialogFeature.java b/facebook/src/com/facebook/share/internal/ShareDialogFeature.java
new file mode 100644
index 000000000..3348cc8b7
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/ShareDialogFeature.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public enum ShareDialogFeature implements DialogFeature {
+    /**
+     * Indicates whether the native Share dialog itself is supported by the installed version of the
+     * Facebook application.
+     */
+    SHARE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618),
+    /**
+     * Indicates whether the native Share dialog supports sharing of photo images.
+     */
+    PHOTOS(NativeProtocol.PROTOCOL_VERSION_20140204),
+    /**
+     * Indicates whether the native Share dialog supports sharing of videos.
+     */
+    VIDEO(NativeProtocol.PROTOCOL_VERSION_20141028),
+    ;
+
+    private int minVersion;
+
+    ShareDialogFeature(int minVersion) {
+        this.minVersion = minVersion;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public String getAction() {
+        return NativeProtocol.ACTION_FEED_DIALOG;
+    }
+
+    /**
+     * This method is for internal use only.
+     */
+    public int getMinVersion() {
+        return minVersion;
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/ShareInternalUtility.java b/facebook/src/com/facebook/share/internal/ShareInternalUtility.java
new file mode 100644
index 000000000..9152d24bb
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/ShareInternalUtility.java
@@ -0,0 +1,967 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Pair;
+
+import com.facebook.AccessToken;
+import com.facebook.CallbackManager;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookGraphResponseException;
+import com.facebook.FacebookOperationCanceledException;
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphRequest.Callback;
+import com.facebook.GraphResponse;
+import com.facebook.internal.GraphUtil;
+import com.facebook.HttpMethod;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.NativeAppCallAttachmentStore;
+import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.share.Sharer;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.SharePhoto;
+import com.facebook.share.model.SharePhotoContent;
+import com.facebook.share.widget.LikeView;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public final class ShareInternalUtility {
+    private static final String OBJECT_PARAM = "object";
+    private static final String MY_PHOTOS = "me/photos";
+    private static final String MY_FEED = "me/feed";
+    private static final String MY_STAGING_RESOURCES = "me/staging_resources";
+    private static final String MY_OBJECTS_FORMAT = "me/objects/%s";
+    private static final String MY_ACTION_FORMAT = "me/%s";
+
+    // Parameter names/values
+    private static final String PICTURE_PARAM = "picture";
+    private static final String CAPTION_PARAM = "caption";
+    private static final String STAGING_PARAM = "file";
+
+    public static void invokeCallbackWithException(
+            FacebookCallback<Sharer.Result> callback,
+            final Exception exception) {
+        if (exception instanceof FacebookException) {
+            invokeOnErrorCallback(callback, (FacebookException) exception);
+            return;
+        }
+        invokeCallbackWithError(
+                callback,
+                "Error preparing share content: " + exception.getLocalizedMessage());
+    }
+
+    public static void invokeCallbackWithError(
+            FacebookCallback<Sharer.Result> callback,
+            String error) {
+        invokeOnErrorCallback(callback, error);
+    }
+
+    public static void invokeCallbackWithResults(
+            FacebookCallback<Sharer.Result> callback,
+            final String postId,
+            final GraphResponse graphResponse) {
+        FacebookRequestError requestError = graphResponse.getError();
+        if (requestError != null) {
+            String errorMessage = requestError.getErrorMessage();
+            if (Utility.isNullOrEmpty(errorMessage)) {
+                errorMessage = "Unexpected error sharing.";
+            }
+            invokeOnErrorCallback(callback, graphResponse, errorMessage);
+        } else {
+            invokeOnSuccessCallback(callback, postId);
+        }
+    }
+
+    /**
+     * Determines whether the native dialog completed normally (without error or exception).
+     *
+     * @param result the bundle passed back to onActivityResult
+     * @return true if the native dialog completed normally
+     */
+    public static boolean getNativeDialogDidComplete(Bundle result) {
+        if (result.containsKey(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETE_KEY)) {
+            return result.getBoolean(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETE_KEY);
+        }
+        return result.getBoolean(NativeProtocol.EXTRA_DIALOG_COMPLETE_KEY, false);
+    }
+
+    /**
+     * Returns the gesture with which the user completed the native dialog. This is only returned
+     * if the user has previously authorized the calling app with basic permissions.
+     *
+     * @param result the bundle passed back to onActivityResult
+     * @return "post" or "cancel" as the completion gesture
+     */
+    public static String getNativeDialogCompletionGesture(Bundle result) {
+        if (result.containsKey(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY)) {
+            return result.getString(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY);
+        }
+        return result.getString(NativeProtocol.EXTRA_DIALOG_COMPLETION_GESTURE_KEY);
+    }
+
+    /**
+     * Returns the id of the published post. This is only returned if the user has previously
+     * given the app publish permissions.
+     *
+     * @param result the bundle passed back to onActivityResult
+     * @return the id of the published post
+     */
+    public static String getShareDialogPostId(Bundle result) {
+        if (result.containsKey(ShareConstants.RESULT_POST_ID)) {
+            return result.getString(ShareConstants.RESULT_POST_ID);
+        }
+        if (result.containsKey(ShareConstants.EXTRA_RESULT_POST_ID)) {
+            return result.getString(ShareConstants.EXTRA_RESULT_POST_ID);
+        }
+        return result.getString(ShareConstants.WEB_DIALOG_RESULT_PARAM_POST_ID);
+    }
+
+    public static boolean handleActivityResult(
+            int requestCode,
+            int resultCode,
+            Intent data,
+            ResultProcessor resultProcessor) {
+        AppCall appCall = getAppCallFromActivityResult(requestCode, resultCode, data);
+        if (appCall == null) {
+            return false;
+        }
+
+        NativeAppCallAttachmentStore.cleanupAttachmentsForCall(appCall.getCallId());
+        if (resultProcessor == null) {
+            return true;
+        }
+
+        FacebookException exception = NativeProtocol.getExceptionFromErrorData(
+                NativeProtocol.getErrorDataFromResultIntent(data));
+        if (exception != null) {
+            if (exception instanceof FacebookOperationCanceledException) {
+                resultProcessor.onCancel(appCall);
+            } else {
+                resultProcessor.onError(appCall, exception);
+            }
+        } else {
+            // If here, we did not find an error in the result.
+            Bundle results = NativeProtocol.getSuccessResultsFromIntent(data);
+            resultProcessor.onSuccess(appCall, results);
+        }
+
+        return true;
+    }
+
+    // Custom handling for Share so that we can log results
+    public static ResultProcessor getShareResultProcessor(
+            final FacebookCallback<Sharer.Result> callback) {
+        return new ResultProcessor(callback) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle results) {
+                if (results != null) {
+                    final String gesture = getNativeDialogCompletionGesture(results);
+                    if (gesture == null || "post".equalsIgnoreCase(gesture)) {
+                        String postId = getShareDialogPostId(results);
+                        invokeOnSuccessCallback(callback, postId);
+                    } else if ("cancel".equalsIgnoreCase(gesture)) {
+                        invokeOnCancelCallback(callback);
+                    } else {
+                        invokeOnErrorCallback(
+                                callback,
+                                new FacebookException(NativeProtocol.ERROR_UNKNOWN_ERROR));
+                    }
+                }
+            }
+
+            @Override
+            public void onCancel(AppCall appCall) {
+                invokeOnCancelCallback(callback);
+            }
+
+            @Override
+            public void onError(AppCall appCall, FacebookException error) {
+                invokeOnErrorCallback(callback, error);
+            }
+        };
+    }
+
+    private static AppCall getAppCallFromActivityResult(int requestCode,
+                                                        int resultCode,
+                                                        Intent data) {
+        UUID callId = NativeProtocol.getCallIdFromIntent(data);
+        if (callId == null) {
+            return null;
+        }
+
+        return AppCall.finishPendingCall(callId, requestCode);
+    }
+
+    public static void registerStaticShareCallback(
+            final int requestCode) {
+        CallbackManagerImpl.registerStaticCallback(
+                requestCode,
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return handleActivityResult(
+                                requestCode,
+                                resultCode,
+                                data,
+                                getShareResultProcessor(null));
+                    }
+                }
+        );
+    }
+
+    public static void registerSharerCallback(
+            final int requestCode,
+            final CallbackManager callbackManager,
+            final FacebookCallback<Sharer.Result> callback) {
+        if (!(callbackManager instanceof CallbackManagerImpl)) {
+            throw new FacebookException("Unexpected CallbackManager, " +
+                    "please use the provided Factory.");
+        }
+
+        ((CallbackManagerImpl) callbackManager).registerCallback(
+                requestCode,
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return handleActivityResult(
+                                requestCode,
+                                resultCode,
+                                data,
+                                getShareResultProcessor(callback));
+                    }
+                });
+    }
+
+    public static List<String> getPhotoUrls(
+            final SharePhotoContent photoContent,
+            final UUID appCallId) {
+        List<SharePhoto> photos;
+        if (photoContent == null || (photos = photoContent.getPhotos()) == null) {
+            return null;
+        }
+
+        List<NativeAppCallAttachmentStore.Attachment> attachments = Utility.map(
+                photos,
+                new Utility.Mapper<SharePhoto, NativeAppCallAttachmentStore.Attachment>() {
+                    @Override
+                    public NativeAppCallAttachmentStore.Attachment apply(SharePhoto item) {
+                        return getAttachment(appCallId, item);
+                    }
+                });
+
+        List<String> attachmentUrls = Utility.map(
+                attachments,
+                new Utility.Mapper<NativeAppCallAttachmentStore.Attachment, String>() {
+                    @Override
+                    public String apply(NativeAppCallAttachmentStore.Attachment item) {
+                        return item.getAttachmentUrl();
+                    }
+                });
+
+        NativeAppCallAttachmentStore.addAttachments(attachments);
+
+        return attachmentUrls;
+    }
+
+    public static JSONObject toJSONObjectForCall(
+            final UUID callId,
+            final ShareOpenGraphAction action)
+            throws JSONException {
+
+        final ArrayList<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>();
+        JSONObject actionJSON = OpenGraphJSONUtility.toJSONObject(
+                action,
+                new OpenGraphJSONUtility.PhotoJSONProcessor() {
+                    @Override
+                    public JSONObject toJSONObject(SharePhoto photo) {
+                        NativeAppCallAttachmentStore.Attachment attachment = getAttachment(
+                                callId,
+                                photo);
+
+                        if (attachment == null) {
+                            return null;
+                        }
+
+                        attachments.add(attachment);
+
+                        JSONObject photoJSONObject = new JSONObject();
+                        try {
+                            photoJSONObject.put(
+                                    NativeProtocol.IMAGE_URL_KEY, attachment.getAttachmentUrl());
+                            if (photo.getUserGenerated()) {
+                                photoJSONObject.put(NativeProtocol.IMAGE_USER_GENERATED_KEY, true);
+                            }
+                        } catch (JSONException e) {
+                            throw new FacebookException("Unable to attach images", e);
+                        }
+                        return photoJSONObject;
+                    }
+                });
+
+        NativeAppCallAttachmentStore.addAttachments(attachments);
+
+        return actionJSON;
+    }
+
+    public static JSONObject toJSONObjectForWeb(
+            final ShareOpenGraphContent shareOpenGraphContent)
+            throws JSONException {
+        ShareOpenGraphAction action = shareOpenGraphContent.getAction();
+
+        return OpenGraphJSONUtility.toJSONObject(
+                action,
+                new OpenGraphJSONUtility.PhotoJSONProcessor() {
+                    @Override
+                    public JSONObject toJSONObject(SharePhoto photo) {
+                        Uri photoUri = photo.getImageUrl();
+                        JSONObject photoJSONObject = new JSONObject();
+                        try {
+                            photoJSONObject.put(
+                                    NativeProtocol.IMAGE_URL_KEY, photoUri.toString());
+                        } catch (JSONException e) {
+                            throw new FacebookException("Unable to attach images", e);
+                        }
+                        return photoJSONObject;
+                    }
+                });
+    }
+
+    public static JSONArray removeNamespacesFromOGJsonArray(
+            JSONArray jsonArray,
+            boolean requireNamespace) throws JSONException {
+        JSONArray newArray = new JSONArray();
+        for (int i = 0; i < jsonArray.length(); ++i) {
+            Object value = jsonArray.get(i);
+            if (value instanceof JSONArray) {
+                value = removeNamespacesFromOGJsonArray((JSONArray) value, requireNamespace);
+            } else if (value instanceof JSONObject) {
+                value = removeNamespacesFromOGJsonObject((JSONObject) value, requireNamespace);
+            }
+            newArray.put(value);
+        }
+
+        return newArray;
+    }
+
+    public static JSONObject removeNamespacesFromOGJsonObject(
+            JSONObject jsonObject,
+            boolean requireNamespace) {
+        if (jsonObject == null) {
+            return null;
+        }
+
+        try {
+            JSONObject newJsonObject = new JSONObject();
+            JSONObject data = new JSONObject();
+            JSONArray names = jsonObject.names();
+            for (int i = 0; i < names.length(); ++i) {
+                String key = names.getString(i);
+                Object value = null;
+                value = jsonObject.get(key);
+                if (value instanceof JSONObject) {
+                    value = removeNamespacesFromOGJsonObject((JSONObject) value, true);
+                } else if (value instanceof JSONArray) {
+                    value = removeNamespacesFromOGJsonArray((JSONArray) value, true);
+                }
+
+                Pair<String, String> fieldNameAndNamespace = getFieldNameAndNamespaceFromFullName(
+                        key);
+                String namespace = fieldNameAndNamespace.first;
+                String fieldName = fieldNameAndNamespace.second;
+
+                if (requireNamespace) {
+                    if (namespace != null && namespace.equals("fbsdk")) {
+                        newJsonObject.put(key, value);
+                    } else if (namespace == null || namespace.equals("og")) {
+                        newJsonObject.put(fieldName, value);
+                    } else {
+                        data.put(fieldName, value);
+                    }
+                } else if (namespace != null && namespace.equals("fb")) {
+                    newJsonObject.put(key, value);
+                } else {
+                    newJsonObject.put(fieldName, value);
+                }
+            }
+
+            if (data.length() > 0) {
+                newJsonObject.put("data", data);
+            }
+
+            return newJsonObject;
+        } catch (JSONException e) {
+            throw new FacebookException("Failed to create json object from share content");
+        }
+    }
+
+    public static Pair<String, String> getFieldNameAndNamespaceFromFullName(String fullName) {
+        String namespace = null;
+        String fieldName;
+        int index = fullName.indexOf(':');
+        if (index != -1 && fullName.length() > index + 1) {
+            namespace = fullName.substring(0, index);
+            fieldName = fullName.substring(index + 1);
+        } else {
+            fieldName = fullName;
+        }
+        return new Pair<>(namespace, fieldName);
+    }
+
+    ;
+
+    private ShareInternalUtility() {
+    }
+
+    private static NativeAppCallAttachmentStore.Attachment getAttachment(
+            UUID callId,
+            SharePhoto photo) {
+        Bitmap bitmap = photo.getBitmap();
+        Uri photoUri = photo.getImageUrl();
+        NativeAppCallAttachmentStore.Attachment attachment = null;
+        if (bitmap != null) {
+            attachment = NativeAppCallAttachmentStore.createAttachment(
+                    callId,
+                    bitmap);
+        } else if (photoUri != null) {
+            attachment = NativeAppCallAttachmentStore.createAttachment(
+                    callId,
+                    photoUri);
+        }
+
+        return attachment;
+    }
+
+    static void invokeOnCancelCallback(FacebookCallback<Sharer.Result> callback) {
+        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_CANCELLED, null);
+        if (callback != null) {
+            callback.onCancel();
+        }
+    }
+
+    static void invokeOnSuccessCallback(
+            FacebookCallback<Sharer.Result> callback,
+            String postId) {
+        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_SUCCEEDED, null);
+        if (callback != null) {
+            callback.onSuccess(new Sharer.Result(postId));
+        }
+    }
+
+    static void invokeOnErrorCallback(
+            FacebookCallback<Sharer.Result> callback,
+            GraphResponse response,
+            String message) {
+        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
+        if (callback != null) {
+            callback.onError(new FacebookGraphResponseException(response, message));
+        }
+    }
+
+
+    static void invokeOnErrorCallback(
+            FacebookCallback<Sharer.Result> callback,
+            String message) {
+        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
+        if (callback != null) {
+            callback.onError(new FacebookException(message));
+        }
+    }
+
+    static void invokeOnErrorCallback(
+            FacebookCallback<Sharer.Result> callback,
+            FacebookException ex) {
+        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, ex.getMessage());
+        if (callback != null) {
+            callback.onError(ex);
+        }
+    }
+
+    private static void logShareResult(String shareOutcome, String errorMessage) {
+        Context context = FacebookSdk.getApplicationContext();
+        AppEventsLogger logger = AppEventsLogger.newLogger(context);
+        Bundle parameters = new Bundle();
+        parameters.putString(
+                AnalyticsEvents.PARAMETER_SHARE_OUTCOME,
+                shareOutcome
+        );
+
+        if (errorMessage != null) {
+            parameters.putString(AnalyticsEvents.PARAMETER_SHARE_ERROR_MESSAGE, errorMessage);
+        }
+        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_RESULT, null, parameters);
+    }
+
+    /**
+     * Creates a new Request configured to create a user owned Open Graph object.
+     *
+     * @param accessToken     the accessToken to use, or null
+     * @param openGraphObject the Open Graph object to create; must not be null, and must have a
+     *                        non-empty type and title
+     * @param callback        a callback that will be called when the request is completed to handle
+     *                        success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newPostOpenGraphObjectRequest(
+            AccessToken accessToken,
+            JSONObject openGraphObject,
+            Callback callback) {
+        if (openGraphObject == null) {
+            throw new FacebookException("openGraphObject cannot be null");
+        }
+        if (Utility.isNullOrEmpty(openGraphObject.optString("type"))) {
+            throw new FacebookException("openGraphObject must have non-null 'type' property");
+        }
+        if (Utility.isNullOrEmpty(openGraphObject.optString("title"))) {
+            throw new FacebookException("openGraphObject must have non-null 'title' property");
+        }
+
+        String path = String.format(MY_OBJECTS_FORMAT, openGraphObject.optString("type"));
+        Bundle bundle = new Bundle();
+        bundle.putString(OBJECT_PARAM, openGraphObject.toString());
+        return new GraphRequest(accessToken, path, bundle, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to create a user owned Open Graph object.
+     *
+     * @param accessToken      the access token to use, or null
+     * @param type             the fully-specified Open Graph object type (e.g.,
+     *                         my_app_namespace:my_object_name); must not be null
+     * @param title            the title of the Open Graph object; must not be null
+     * @param imageUrl         the link to an image to be associated with the Open Graph object; may
+     *                         be null
+     * @param url              the url to be associated with the Open Graph object; may be null
+     * @param description      the description to be associated with the object; may be null
+     * @param objectProperties any additional type-specific properties for the Open Graph object;
+     *                         may be null
+     * @param callback         a callback that will be called when the request is completed to
+     *                         handle success or error conditions; may be null
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newPostOpenGraphObjectRequest(
+            AccessToken accessToken,
+            String type,
+            String title,
+            String imageUrl,
+            String url,
+            String description,
+            JSONObject objectProperties,
+            Callback callback) {
+        JSONObject openGraphObject = GraphUtil.createOpenGraphObjectForPost(
+                type, title, imageUrl, url, description, objectProperties, null);
+        return newPostOpenGraphObjectRequest(accessToken, openGraphObject, callback);
+    }
+
+    /**
+     * Creates a new Request configured to publish an Open Graph action.
+     *
+     * @param accessToken     the access token to use, or null
+     * @param openGraphAction the Open Graph action to create; must not be null, and must have a
+     *                        non-empty 'type'
+     * @param callback        a callback that will be called when the request is completed to handle
+     *                        success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newPostOpenGraphActionRequest(
+            AccessToken accessToken,
+            JSONObject openGraphAction,
+            Callback callback) {
+        if (openGraphAction == null) {
+            throw new FacebookException("openGraphAction cannot be null");
+        }
+        String type = openGraphAction.optString("type");
+        if (Utility.isNullOrEmpty(type)) {
+            throw new FacebookException("openGraphAction must have non-null 'type' property");
+        }
+
+        String path = String.format(MY_ACTION_FORMAT, type);
+        return GraphRequest.newPostRequest(accessToken, path, openGraphAction, callback);
+    }
+
+    /**
+     * Creates a new Request configured to update a user owned Open Graph object.
+     *
+     * @param accessToken     the access token to use, or null
+     * @param openGraphObject the Open Graph object to update, which must have a valid 'id'
+     *                        property
+     * @param callback        a callback that will be called when the request is completed to handle
+     *                        success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newUpdateOpenGraphObjectRequest(
+            AccessToken accessToken,
+            JSONObject openGraphObject,
+            Callback callback) {
+        if (openGraphObject == null) {
+            throw new FacebookException("openGraphObject cannot be null");
+        }
+
+        String path = openGraphObject.optString("id");
+        if (path == null) {
+            throw new FacebookException("openGraphObject must have an id");
+        }
+
+        Bundle bundle = new Bundle();
+        bundle.putString(OBJECT_PARAM, openGraphObject.toString());
+        return new GraphRequest(accessToken, path, bundle, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to update a user owned Open Graph object.
+     *
+     * @param accessToken      the access token to use, or null
+     * @param id               the id of the Open Graph object
+     * @param title            the title of the Open Graph object
+     * @param imageUrl         the link to an image to be associated with the Open Graph object
+     * @param url              the url to be associated with the Open Graph object
+     * @param description      the description to be associated with the object
+     * @param objectProperties any additional type-specific properties for the Open Graph object
+     * @param callback         a callback that will be called when the request is completed to
+     *                         handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newUpdateOpenGraphObjectRequest(
+            AccessToken accessToken,
+            String id,
+            String title,
+            String imageUrl,
+            String url,
+            String description,
+            JSONObject objectProperties,
+            Callback callback) {
+        JSONObject openGraphObject = GraphUtil.createOpenGraphObjectForPost(
+                null, title, imageUrl, url, description, objectProperties, id);
+        return newUpdateOpenGraphObjectRequest(accessToken, openGraphObject, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     *
+     * @param accessToken the access token to use, or null
+     * @param image       the image to upload
+     * @param caption     the user generated caption for the photo.
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newUploadPhotoRequest(
+            AccessToken accessToken,
+            Bitmap image,
+            String caption,
+            Callback callback) {
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, image);
+        if (caption != null && !caption.isEmpty()) {
+            parameters.putString(CAPTION_PARAM, caption);
+        }
+
+        return new GraphRequest(accessToken, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The
+     * photo will be read from the specified file.
+     *
+     * @param accessToken the access token to use, or null
+     * @param file        the file containing the photo to upload
+     * @param caption     the user generated caption for the photo.
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     * @throws java.io.FileNotFoundException
+     */
+    public static GraphRequest newUploadPhotoRequest(
+            AccessToken accessToken,
+            File file,
+            String caption,
+            Callback callback
+    ) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor =
+                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, descriptor);
+        if (caption != null && !caption.isEmpty()) {
+            parameters.putString(CAPTION_PARAM, caption);
+        }
+
+        return new GraphRequest(accessToken, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The
+     * photo will be read from the specified Uri.
+     *
+     * @param accessToken the access token to use, or null
+     * @param photoUri    the file:// or content:// Uri to the photo on device.
+     * @param caption     the user generated caption for the photo.
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     * @throws FileNotFoundException
+     */
+    public static GraphRequest newUploadPhotoRequest(
+            AccessToken accessToken,
+            Uri photoUri,
+            String caption,
+            Callback callback)
+            throws FileNotFoundException {
+        if (Utility.isFileUri(photoUri)) {
+            return newUploadPhotoRequest(
+                    accessToken,
+                    new File(photoUri.getPath()),
+                    caption,
+                    callback);
+        } else if (!Utility.isContentUri(photoUri)) {
+            throw new FacebookException("The photo Uri must be either a file:// or content:// Uri");
+        }
+
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, photoUri);
+
+        return new GraphRequest(accessToken, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param accessToken the access token to use, or null
+     * @param message     the text of the status update
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newStatusUpdateRequest(
+            AccessToken accessToken,
+            String message,
+            Callback callback) {
+        return newStatusUpdateRequest(accessToken, message, (String) null, null, callback);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param accessToken the access token to use, or null
+     * @param message     the text of the status update
+     * @param placeId     an optional place id to associate with the post
+     * @param tagIds      an optional list of user ids to tag in the post
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    private static GraphRequest newStatusUpdateRequest(
+            AccessToken accessToken,
+            String message,
+            String placeId,
+            List<String> tagIds,
+            Callback callback) {
+
+        Bundle parameters = new Bundle();
+        parameters.putString("message", message);
+
+        if (placeId != null) {
+            parameters.putString("place", placeId);
+        }
+
+        if (tagIds != null && tagIds.size() > 0) {
+            String tags = TextUtils.join(",", tagIds);
+            parameters.putString("tags", tags);
+        }
+
+        return new GraphRequest(accessToken, MY_FEED, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param accessToken the access token to use, or null
+     * @param message     the text of the status update
+     * @param place       an optional place to associate with the post
+     * @param tags        an optional list of users to tag in the post
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newStatusUpdateRequest(
+            AccessToken accessToken,
+            String message,
+            JSONObject place,
+            List<JSONObject> tags,
+            Callback callback) {
+
+        List<String> tagIds = null;
+        if (tags != null) {
+            tagIds = new ArrayList<String>(tags.size());
+            for (JSONObject tag : tags) {
+                tagIds.add(tag.optString("id"));
+            }
+        }
+        String placeId = place == null ? null : place.optString("id");
+        return newStatusUpdateRequest(accessToken, message, placeId, tagIds, callback);
+    }
+
+
+    /**
+     * Creates a new Request configured to upload an image to create a staging resource. Staging
+     * resources allow you to post binary data such as images, in preparation for a post of an Open
+     * Graph object or action which references the image. The URI returned when uploading a staging
+     * resource may be passed as the image property for an Open Graph object or action.
+     *
+     * @param accessToken the access token to use, or null
+     * @param image       the image to upload
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static GraphRequest newUploadStagingResourceWithImageRequest(
+            AccessToken accessToken,
+            Bitmap image,
+            Callback callback) {
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(STAGING_PARAM, image);
+
+        return new GraphRequest(
+                accessToken,
+                MY_STAGING_RESOURCES,
+                parameters,
+                HttpMethod.POST,
+                callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload an image to create a staging resource. Staging
+     * resources allow you to post binary data such as images, in preparation for a post of an Open
+     * Graph object or action which references the image. The URI returned when uploading a staging
+     * resource may be passed as the image property for an Open Graph object or action.
+     *
+     * @param accessToken the access token to use, or null
+     * @param file        the file containing the image to upload
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     * @throws FileNotFoundException
+     */
+    public static GraphRequest newUploadStagingResourceWithImageRequest(
+            AccessToken accessToken,
+            File file,
+            Callback callback
+    ) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor =
+                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        GraphRequest.ParcelableResourceWithMimeType<ParcelFileDescriptor> resourceWithMimeType =
+                new GraphRequest.ParcelableResourceWithMimeType<>(descriptor, "image/png");
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);
+
+        return new GraphRequest(
+                accessToken,
+                MY_STAGING_RESOURCES,
+                parameters,
+                HttpMethod.POST,
+                callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload an image to create a staging resource. Staging
+     * resources allow you to post binary data such as images, in preparation for a post of an Open
+     * Graph object or action which references the image. The URI returned when uploading a staging
+     * resource may be passed as the image property for an Open Graph object or action.
+     *
+     * @param accessToken the access token to use, or null
+     * @param imageUri    the file:// or content:// Uri pointing to the image to upload
+     * @param callback    a callback that will be called when the request is completed to handle
+     *                    success or error conditions
+     * @return a Request that is ready to execute
+     * @throws FileNotFoundException
+     */
+    public static GraphRequest newUploadStagingResourceWithImageRequest(
+            AccessToken accessToken,
+            Uri imageUri,
+            Callback callback
+    ) throws FileNotFoundException {
+        if (Utility.isFileUri(imageUri)) {
+            return newUploadStagingResourceWithImageRequest(
+                    accessToken,
+                    new File(imageUri.getPath()),
+                    callback);
+        } else if (!Utility.isContentUri(imageUri)) {
+            throw new FacebookException("The image Uri must be either a file:// or content:// Uri");
+        }
+
+        GraphRequest.ParcelableResourceWithMimeType<Uri> resourceWithMimeType =
+                new GraphRequest.ParcelableResourceWithMimeType<>(imageUri, "image/png");
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);
+
+        return new GraphRequest(
+                accessToken,
+                MY_STAGING_RESOURCES,
+                parameters,
+                HttpMethod.POST,
+                callback);
+    }
+
+    @Nullable
+    public static LikeView.ObjectType getMostSpecificObjectType(
+            LikeView.ObjectType objectType1,
+            LikeView.ObjectType objectType2) {
+        if (objectType1 == objectType2) {
+            return objectType1;
+        }
+
+        if (objectType1 == LikeView.ObjectType.UNKNOWN) {
+            return objectType2;
+        } else if (objectType2 == LikeView.ObjectType.UNKNOWN) {
+            return objectType1;
+        } else {
+            // We can't have a PAGE and an OPEN_GRAPH type be compatible.
+            return null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/VideoUploader.java b/facebook/src/com/facebook/share/internal/VideoUploader.java
new file mode 100644
index 000000000..6653750d8
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/VideoUploader.java
@@ -0,0 +1,628 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookGraphResponseException;
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.HttpMethod;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import com.facebook.internal.WorkQueue;
+import com.facebook.share.Sharer;
+import com.facebook.share.model.ShareVideo;
+import com.facebook.share.model.ShareVideoContent;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class VideoUploader {
+
+    private static final String TAG = "VideoUploader";
+
+    private static final String PARAM_UPLOAD_PHASE = "upload_phase";
+    private static final String PARAM_VALUE_UPLOAD_START_PHASE = "start";
+    private static final String PARAM_VALUE_UPLOAD_TRANSFER_PHASE = "transfer";
+    private static final String PARAM_VALUE_UPLOAD_FINISH_PHASE = "finish";
+
+    private static final String PARAM_TITLE = "title";
+    private static final String PARAM_DESCRIPTION = "description";
+    private static final String PARAM_REF = "ref";
+    private static final String PARAM_FILE_SIZE = "file_size";
+    private static final String PARAM_SESSION_ID = "upload_session_id";
+    private static final String PARAM_VIDEO_ID = "video_id";
+    private static final String PARAM_START_OFFSET = "start_offset";
+    private static final String PARAM_END_OFFSET = "end_offset";
+    private static final String PARAM_VIDEO_FILE_CHUNK = "video_file_chunk";
+
+    private static final String ERROR_UPLOAD = "Video upload failed";
+    private static final String ERROR_BAD_SERVER_RESPONSE = "Unexpected error in server response";
+
+    private static final int UPLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;
+    private static final int MAX_RETRIES_PER_PHASE = 2;
+    private static final int RETRY_DELAY_UNIT_MS = 5000;
+    private static final int RETRY_DELAY_BACK_OFF_FACTOR = 3;
+
+    private static boolean initialized;
+
+    private static Handler handler;
+    private static WorkQueue uploadQueue = new WorkQueue(UPLOAD_QUEUE_MAX_CONCURRENT);
+
+    private static Set<UploadContext> pendingUploads = new HashSet<>();
+
+    private static AccessTokenTracker accessTokenTracker;
+
+    public static synchronized void uploadAsync(
+            ShareVideoContent videoContent,
+            FacebookCallback<Sharer.Result> callback)
+            throws FileNotFoundException {
+        uploadAsync(videoContent, "me", callback);
+    }
+
+    public static synchronized void uploadAsync(
+            ShareVideoContent videoContent,
+            String targetId,
+            FacebookCallback<Sharer.Result> callback)
+            throws FileNotFoundException {
+        if (!initialized) {
+            registerAccessTokenTracker();
+            initialized = true;
+        }
+
+        Validate.notNull(videoContent, "videoContent");
+        Validate.notNull(targetId, "targetId");
+        ShareVideo video = videoContent.getVideo();
+        Validate.notNull(video, "videoContent.video");
+        Uri videoUri = video.getLocalUrl();
+        Validate.notNull(videoUri, "videoContent.video.localUrl");
+
+        UploadContext uploadContext = new UploadContext(videoContent, targetId, callback);
+        uploadContext.initialize();
+
+        pendingUploads.add(uploadContext);
+
+        enqueueUploadStart(
+                uploadContext,
+                0);
+    }
+
+    private static synchronized void cancelAllRequests() {
+        for (UploadContext uploadContext : pendingUploads) {
+            uploadContext.isCanceled = true;
+        }
+    }
+
+    private static synchronized void removePendingUpload(
+            UploadContext uploadContext) {
+        pendingUploads.remove(uploadContext);
+    }
+
+    private static synchronized Handler getHandler() {
+        if (handler == null) {
+            handler = new Handler(Looper.getMainLooper());
+        }
+        return handler;
+    }
+
+    private static void issueResponse(
+            final UploadContext uploadContext,
+            final FacebookException error,
+            final String videoId) {
+        // Remove the UploadContext synchronously
+        // Once the UploadContext is removed, this is the only reference to it.
+        removePendingUpload(uploadContext);
+
+        Utility.closeQuietly(uploadContext.videoStream);
+
+        if (uploadContext.callback != null) {
+            if (error != null) {
+                ShareInternalUtility.invokeOnErrorCallback(uploadContext.callback, error);
+            } else if (uploadContext.isCanceled) {
+                ShareInternalUtility.invokeOnCancelCallback(uploadContext.callback);
+            } else {
+                ShareInternalUtility.invokeOnSuccessCallback(uploadContext.callback, videoId);
+            }
+        }
+    }
+
+    private static void enqueueUploadStart(UploadContext uploadContext, int completedRetries) {
+        enqueueRequest(
+                uploadContext,
+                new StartUploadWorkItem(
+                        uploadContext,
+                        completedRetries));
+    }
+
+    private static void enqueueUploadChunk(
+            UploadContext uploadContext,
+            String chunkStart,
+            String chunkEnd,
+            int completedRetries) {
+        enqueueRequest(
+                uploadContext,
+                new TransferChunkWorkItem(
+                        uploadContext,
+                        chunkStart,
+                        chunkEnd,
+                        completedRetries));
+    }
+
+    private static void enqueueUploadFinish(UploadContext uploadContext, int completedRetries) {
+        enqueueRequest(
+                uploadContext,
+                new FinishUploadWorkItem(
+                        uploadContext,
+                        completedRetries));
+    }
+
+    private static synchronized void enqueueRequest(
+            UploadContext uploadContext,
+            Runnable workItem) {
+        uploadContext.workItem = uploadQueue.addActiveWorkItem(workItem);
+    }
+
+    private static byte[] getChunk(
+            UploadContext uploadContext,
+            String chunkStart,
+            String chunkEnd)
+            throws IOException {
+        if (!Utility.areObjectsEqual(chunkStart, uploadContext.chunkStart)) {
+            // Something went wrong in the book-keeping here.
+            logError(
+                    null,
+                    "Error reading video chunk. Expected chunk '%s'. Requested chunk '%s'.",
+                    uploadContext.chunkStart,
+                    chunkStart);
+            return null;
+        }
+
+        long chunkStartLong = Long.parseLong(chunkStart);
+        long chunkEndLong = Long.parseLong(chunkEnd);
+        int chunkSize = (int) (chunkEndLong - chunkStartLong);
+
+        ByteArrayOutputStream byteBufferStream = new ByteArrayOutputStream();
+        int bufferSize = Math.min(8192, chunkSize);
+        byte[] buffer = new byte[bufferSize];
+
+        int len = 0;
+        while ((len = uploadContext.videoStream.read(buffer)) != -1) {
+            byteBufferStream.write(buffer, 0, len);
+
+            chunkSize -= len;
+            if (chunkSize == 0) {
+                // Done!
+                break;
+            } else if (chunkSize < 0) {
+                // This should not happen. Signal an error.
+                logError(
+                        null,
+                        "Error reading video chunk. Expected buffer length - '%d'. Actual - '%d'.",
+                        chunkSize + len,
+                        len);
+                return null;
+            }
+        }
+
+        uploadContext.chunkStart = chunkEnd;
+
+        return byteBufferStream.toByteArray();
+    }
+
+    private static void registerAccessTokenTracker() {
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(
+                    AccessToken oldAccessToken,
+                    AccessToken currentAccessToken) {
+                if (oldAccessToken == null) {
+                    // If we never had an access token, then there would be no pending uploads.
+                    return;
+                }
+
+                if (currentAccessToken == null ||
+                        !Utility.areObjectsEqual(
+                                currentAccessToken.getUserId(),
+                                oldAccessToken.getUserId())) {
+                    // Cancel any pending uploads since the user changed.
+                    cancelAllRequests();
+                }
+            }
+        };
+    }
+
+    private static void logError(
+            Exception e,
+            String format,
+            Object... args) {
+        Log.e(TAG, String.format(Locale.ROOT, format, args), e);
+    }
+
+    private static class UploadContext {
+        public final Uri videoUri;
+        public final String title;
+        public final String description;
+        public final String ref;
+        public final String targetId;
+
+        public final AccessToken accessToken;
+
+        public final FacebookCallback<Sharer.Result> callback;
+
+        public String sessionId;
+        public String videoId;
+        public InputStream videoStream;
+        public long videoSize;
+        public String chunkStart = "0";
+        public boolean isCanceled;
+        public WorkQueue.WorkItem workItem;
+
+        private UploadContext(
+                ShareVideoContent videoContent,
+                String targetId,
+                FacebookCallback<Sharer.Result> callback) {
+            // Store off the access token right away so that under no circumstances will we
+            // end up with different tokens between phases. We will rely on the access token tracker
+            // to cancel pending uploads.
+            this.accessToken = AccessToken.getCurrentAccessToken();
+            this.videoUri = videoContent.getVideo().getLocalUrl();
+            this.title = videoContent.getContentTitle();
+            this.description = videoContent.getContentDescription();
+            this.ref = videoContent.getRef();
+            this.targetId = targetId;
+            this.callback = callback;
+        }
+
+        private void initialize()
+                throws FileNotFoundException {
+            ParcelFileDescriptor fileDescriptor = null;
+            try {
+                if (Utility.isFileUri(videoUri)) {
+                    fileDescriptor = ParcelFileDescriptor.open(
+                            new File(videoUri.getPath()),
+                            ParcelFileDescriptor.MODE_READ_ONLY);
+                    videoSize = fileDescriptor.getStatSize();
+                    videoStream = new ParcelFileDescriptor.AutoCloseInputStream(fileDescriptor);
+                } else if (Utility.isContentUri(videoUri)) {
+                    videoSize = Utility.getContentSize(videoUri);
+                    videoStream = FacebookSdk
+                            .getApplicationContext()
+                            .getContentResolver()
+                            .openInputStream(videoUri);
+                } else {
+                    throw new FacebookException("Uri must be a content:// or file:// uri");
+                }
+            } catch (FileNotFoundException e) {
+                Utility.closeQuietly(videoStream);
+
+                throw e;
+            } finally {
+                Utility.closeQuietly(fileDescriptor);
+            }
+        }
+    }
+
+    private static class StartUploadWorkItem extends UploadWorkItemBase {
+        static final Set<Integer> transientErrorCodes = new HashSet<Integer>() {{
+            add(6000);
+        }};
+
+        public StartUploadWorkItem(UploadContext uploadContext, int completedRetries) {
+            super(uploadContext, completedRetries);
+        }
+
+        @Override
+        public Bundle getParameters() {
+            Bundle parameters = new Bundle();
+            parameters.putString(PARAM_UPLOAD_PHASE, PARAM_VALUE_UPLOAD_START_PHASE);
+            parameters.putLong(PARAM_FILE_SIZE, uploadContext.videoSize);
+
+            return parameters;
+        }
+
+        @Override
+        protected void handleSuccess(JSONObject jsonObject)
+                throws JSONException {
+            uploadContext.sessionId = jsonObject.getString(PARAM_SESSION_ID);
+            uploadContext.videoId = jsonObject.getString(PARAM_VIDEO_ID);
+            String startOffset = jsonObject.getString(PARAM_START_OFFSET);
+            String endOffset = jsonObject.getString(PARAM_END_OFFSET);
+
+            enqueueUploadChunk(
+                    uploadContext,
+                    startOffset,
+                    endOffset,
+                    0);
+        }
+
+        @Override
+        protected void handleError(FacebookException error) {
+            logError(error, "Error starting video upload");
+            endUploadWithFailure(error);
+        }
+
+        @Override
+        protected Set<Integer> getTransientErrorCodes() {
+            return transientErrorCodes;
+        }
+
+        @Override
+        protected void enqueueRetry(int retriesCompleted) {
+            enqueueUploadStart(uploadContext, retriesCompleted);
+        }
+    }
+
+    private static class TransferChunkWorkItem extends UploadWorkItemBase {
+        static final Set<Integer> transientErrorCodes = new HashSet<Integer>() {{
+            add(1363019);
+            add(1363021);
+            add(1363030);
+            add(1363033);
+            add(1363041);
+        }};
+
+        private String chunkStart;
+        private String chunkEnd;
+
+        public TransferChunkWorkItem(
+                UploadContext uploadContext,
+                String chunkStart,
+                String chunkEnd,
+                int completedRetries) {
+            super(uploadContext, completedRetries);
+            this.chunkStart = chunkStart;
+            this.chunkEnd = chunkEnd;
+        }
+
+        @Override
+        public Bundle getParameters()
+                throws IOException {
+            Bundle parameters = new Bundle();
+            parameters.putString(PARAM_UPLOAD_PHASE, PARAM_VALUE_UPLOAD_TRANSFER_PHASE);
+            parameters.putString(PARAM_SESSION_ID, uploadContext.sessionId);
+            parameters.putString(PARAM_START_OFFSET, chunkStart);
+
+            byte[] chunk = getChunk(uploadContext, chunkStart, chunkEnd);
+            if (chunk != null) {
+                parameters.putByteArray(PARAM_VIDEO_FILE_CHUNK, chunk);
+            } else {
+                throw new FacebookException("Error reading video");
+            }
+
+            return parameters;
+        }
+
+        @Override
+        protected void handleSuccess(JSONObject jsonObject)
+                throws JSONException {
+            String startOffset = jsonObject.getString(PARAM_START_OFFSET);
+            String endOffset = jsonObject.getString(PARAM_END_OFFSET);
+
+            if (Utility.areObjectsEqual(startOffset, endOffset)) {
+                enqueueUploadFinish(
+                        uploadContext,
+                        0);
+            } else {
+                enqueueUploadChunk(
+                        uploadContext,
+                        startOffset,
+                        endOffset,
+                        0);
+            }
+        }
+
+        @Override
+        protected void handleError(FacebookException error) {
+            logError(error, "Error uploading video '%s'", uploadContext.videoId);
+            endUploadWithFailure(error);
+        }
+
+        @Override
+        protected Set<Integer> getTransientErrorCodes() {
+            return transientErrorCodes;
+        }
+
+        @Override
+        protected void enqueueRetry(int retriesCompleted) {
+            enqueueUploadChunk(uploadContext, chunkStart, chunkEnd, retriesCompleted);
+        }
+    }
+
+    private static class FinishUploadWorkItem extends UploadWorkItemBase {
+        static final Set<Integer> transientErrorCodes = new HashSet<Integer>() {{
+            add(1363011);
+        }};
+
+        public FinishUploadWorkItem(UploadContext uploadContext, int completedRetries) {
+            super(uploadContext, completedRetries);
+        }
+
+        @Override
+        public Bundle getParameters() {
+            Bundle parameters = new Bundle();
+            parameters.putString(PARAM_UPLOAD_PHASE, PARAM_VALUE_UPLOAD_FINISH_PHASE);
+            parameters.putString(PARAM_SESSION_ID, uploadContext.sessionId);
+            Utility.putNonEmptyString(parameters, PARAM_TITLE, uploadContext.title);
+            Utility.putNonEmptyString(parameters, PARAM_DESCRIPTION, uploadContext.description);
+            Utility.putNonEmptyString(parameters, PARAM_REF, uploadContext.ref);
+
+            return parameters;
+        }
+
+        @Override
+        protected void handleSuccess(JSONObject jsonObject)
+                throws JSONException {
+            if (jsonObject.getBoolean("success")) {
+                issueResponseOnMainThread(null, uploadContext.videoId);
+            } else {
+                handleError(new FacebookException(ERROR_BAD_SERVER_RESPONSE));
+            }
+        }
+
+        @Override
+        protected void handleError(FacebookException error) {
+            logError(error, "Video '%s' failed to finish uploading", uploadContext.videoId);
+            endUploadWithFailure(error);
+        }
+
+        @Override
+        protected Set<Integer> getTransientErrorCodes() {
+            return transientErrorCodes;
+        }
+
+        @Override
+        protected void enqueueRetry(int retriesCompleted) {
+            enqueueUploadFinish(uploadContext, retriesCompleted);
+        }
+    }
+
+    private static abstract class UploadWorkItemBase implements Runnable {
+        protected UploadContext uploadContext;
+        protected int completedRetries;
+
+        protected UploadWorkItemBase(
+                UploadContext uploadContext,
+                int completedRetries) {
+            this.uploadContext = uploadContext;
+            this.completedRetries = completedRetries;
+        }
+
+        @Override
+        public void run() {
+            if (!uploadContext.isCanceled) {
+                try {
+                    executeGraphRequestSynchronously(getParameters());
+                } catch (FacebookException fe) {
+                    endUploadWithFailure(fe);
+                } catch (Exception e) {
+                    endUploadWithFailure(new FacebookException(ERROR_UPLOAD, e));
+                }
+            } else {
+                // No specific failure here.
+                endUploadWithFailure(null);
+            }
+        }
+
+        protected void executeGraphRequestSynchronously(Bundle parameters) {
+            GraphRequest request = new GraphRequest(
+                    uploadContext.accessToken,
+                    String.format(Locale.ROOT, "%s/videos", uploadContext.targetId),
+                    parameters,
+                    HttpMethod.POST,
+                    null);
+            GraphResponse response = request.executeAndWait();
+
+            if (response != null) {
+                FacebookRequestError error = response.getError();
+                JSONObject responseJSON = response.getJSONObject();
+                if (error != null) {
+                    if (!attemptRetry(error.getSubErrorCode())) {
+                        handleError(new FacebookGraphResponseException(response, ERROR_UPLOAD));
+                    }
+                } else if (responseJSON != null) {
+                    try {
+                        handleSuccess(responseJSON);
+                    } catch (JSONException e) {
+                        endUploadWithFailure(new FacebookException(ERROR_BAD_SERVER_RESPONSE, e));
+                    }
+                } else {
+                    handleError(new FacebookException(ERROR_BAD_SERVER_RESPONSE));
+                }
+            } else {
+                handleError(new FacebookException(ERROR_BAD_SERVER_RESPONSE));
+            }
+        }
+
+        private boolean attemptRetry(int errorCode) {
+            if (completedRetries < MAX_RETRIES_PER_PHASE &&
+                    getTransientErrorCodes().contains(errorCode)) {
+                int delay = RETRY_DELAY_UNIT_MS * (int) Math.pow(
+                        RETRY_DELAY_BACK_OFF_FACTOR, completedRetries);
+
+                // Enqueuing the retry from the main thread which should be a lightweight
+                // action with no I/O.
+                getHandler().postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        enqueueRetry(completedRetries + 1);
+                    }
+                }, delay);
+
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        protected void endUploadWithFailure(FacebookException error) {
+            issueResponseOnMainThread(error, null);
+        }
+
+        protected void issueResponseOnMainThread(
+                final FacebookException error,
+                final String videoId) {
+            getHandler().post(new Runnable() {
+                @Override
+                public void run() {
+                    issueResponse(uploadContext, error, videoId);
+                }
+            });
+        }
+
+        protected abstract Bundle getParameters()
+                throws Exception;
+
+        protected abstract void handleSuccess(JSONObject jsonObject)
+                throws JSONException;
+
+        protected abstract void handleError(FacebookException error);
+
+        protected abstract Set<Integer> getTransientErrorCodes();
+
+        protected abstract void enqueueRetry(int retriesCompleted);
+    }
+}
diff --git a/facebook/src/com/facebook/share/internal/WebDialogParameters.java b/facebook/src/com/facebook/share/internal/WebDialogParameters.java
new file mode 100644
index 000000000..6ae172b29
--- /dev/null
+++ b/facebook/src/com/facebook/share/internal/WebDialogParameters.java
@@ -0,0 +1,167 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.internal;
+
+import android.os.Bundle;
+
+import com.facebook.FacebookException;
+import com.facebook.internal.Utility;
+import com.facebook.share.model.AppGroupCreationContent;
+import com.facebook.share.model.GameRequestContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.model.ShareOpenGraphContent;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Locale;
+
+/**
+ * com.facebook.share.internal is solely for the use of other packages within the
+ * Facebook SDK for Android. Use of any of the classes in this package is
+ * unsupported, and they may be modified or removed without warning at any time.
+ */
+public class WebDialogParameters {
+
+    public static Bundle create(AppGroupCreationContent appGroupCreationContent) {
+        Bundle webParams = new Bundle();
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_NAME,
+                appGroupCreationContent.getName());
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
+                appGroupCreationContent.getDescription());
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_PRIVACY,
+                appGroupCreationContent
+                        .getAppGroupPrivacy().toString().toLowerCase(Locale.ENGLISH));
+
+        return webParams;
+    }
+
+    public static Bundle create(GameRequestContent gameRequestContent) {
+        Bundle webParams = new Bundle();
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_MESSAGE,
+                gameRequestContent.getMessage());
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_TO,
+                gameRequestContent.getTo());
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_TITLE,
+                gameRequestContent.getTitle());
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_DATA,
+                gameRequestContent.getData());
+        if (gameRequestContent.getActionType() != null) {
+            Utility.putNonEmptyString(
+                    webParams,
+                    ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
+                    gameRequestContent.getActionType().toString().toLowerCase(Locale.ENGLISH));
+        }
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_OBJECT_ID,
+                gameRequestContent.getObjectId());
+        if (gameRequestContent.getFilters() != null) {
+            Utility.putNonEmptyString(
+                    webParams,
+                    ShareConstants.WEB_DIALOG_PARAM_FILTERS,
+                    gameRequestContent.getFilters().toString().toLowerCase(Locale.ENGLISH));
+        }
+        Utility.putCommaSeparatedStringList(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_SUGGESTIONS,
+                gameRequestContent.getSuggestions());
+        return webParams;
+    }
+
+    public static Bundle create(ShareLinkContent shareLinkContent) {
+        Bundle params = new Bundle();
+        Utility.putUri(
+                params,
+                ShareConstants.WEB_DIALOG_PARAM_HREF,
+                shareLinkContent.getContentUrl());
+
+        return params;
+    }
+
+    public static Bundle create(ShareOpenGraphContent shareOpenGraphContent) {
+        Bundle params = new Bundle();
+
+        Utility.putNonEmptyString(
+                params,
+                ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
+                shareOpenGraphContent.getAction().getActionType());
+
+        try {
+            JSONObject ogJSON = ShareInternalUtility.toJSONObjectForWeb(shareOpenGraphContent);
+            ogJSON = ShareInternalUtility.removeNamespacesFromOGJsonObject(ogJSON, false);
+            if (ogJSON != null) {
+                Utility.putNonEmptyString(
+                        params,
+                        ShareConstants.WEB_DIALOG_PARAM_ACTION_PROPERTIES,
+                        ogJSON.toString());
+            }
+        } catch (JSONException e) {
+            throw new FacebookException("Unable to serialize the ShareOpenGraphContent to JSON", e);
+        }
+
+        return params;
+    }
+
+    public static Bundle createForFeed(ShareLinkContent shareLinkContent) {
+        Bundle webParams = new Bundle();
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_NAME,
+                shareLinkContent.getContentTitle());
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
+                shareLinkContent.getContentDescription());
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_LINK,
+                Utility.getUriString(shareLinkContent.getContentUrl()));
+
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_PICTURE,
+                Utility.getUriString(shareLinkContent.getImageUrl()));
+
+        return webParams;
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/AppGroupCreationContent.java b/facebook/src/com/facebook/share/model/AppGroupCreationContent.java
new file mode 100644
index 000000000..2beecba20
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/AppGroupCreationContent.java
@@ -0,0 +1,163 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+
+/**
+ * Describes the content that will be displayed by the AppGroupCreationDialog
+ */
+public final class AppGroupCreationContent implements ShareModel {
+    private final String name;
+    private final String description;
+    private AppGroupPrivacy privacy;
+
+    private AppGroupCreationContent(final Builder builder) {
+        this.name = builder.name;
+        this.description = builder.description;
+        this.privacy = builder.privacy;
+    }
+
+    AppGroupCreationContent(final Parcel in) {
+        this.name = in.readString();
+        this.description = in.readString();
+        this.privacy = AppGroupPrivacy.valueOf(in.readString());
+    }
+
+    /**
+     * Gets the name of the group that will be created.
+     *
+     * @return name of the group
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * Gets the description of the group that will be created.
+     *
+     * @return the description
+     */
+    public String getDescription() {
+        return this.description;
+    }
+
+    /**
+     * Gets the privacy for the group that will be created
+     *
+     * @return the privacy of the group
+     */
+    public AppGroupPrivacy getAppGroupPrivacy() {
+        return this.privacy;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeString(this.name);
+        out.writeString(this.description);
+        out.writeString(this.privacy.toString());
+    }
+
+    /**
+     * Specifies the privacy of a group.
+     */
+    public enum AppGroupPrivacy {
+        /**
+         * Anyone can see the group, who's in it and what members post.
+         */
+        Open,
+
+        /**
+         * Anyone can see the group and who's in it, but only members can see posts.
+         */
+        Closed,
+    }
+
+    /**
+     * Builder class for a concrete instance of AppGroupCreationContent
+     */
+    public static class Builder
+            implements ShareModelBuilder<AppGroupCreationContent, Builder> {
+        private String name;
+        private String description;
+        private AppGroupPrivacy privacy;
+
+        /**
+         * Sets the name of the group that will be created.
+         *
+         * @param name name of the group
+         * @return the builder
+         */
+        public Builder setName(final String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Sets the description of the group that will be created.
+         *
+         * @param description the description
+         * @return the builder
+         */
+        public Builder setDescription(final String description) {
+            this.description = description;
+            return this;
+        }
+
+        /**
+         * Sets the privacy for the group that will be created
+         *
+         * @param privacy privacy of the group
+         * @return the builder
+         */
+        public Builder setAppGroupPrivacy(final AppGroupPrivacy privacy) {
+            this.privacy = privacy;
+            return this;
+        }
+
+        @Override
+        public AppGroupCreationContent build() {
+            return new AppGroupCreationContent(this);
+        }
+
+
+        @Override
+        public Builder readFrom(final AppGroupCreationContent content) {
+            if (content == null) {
+                return this;
+            }
+            return this
+                    .setName(content.getName())
+                    .setDescription(content.getDescription())
+                    .setAppGroupPrivacy(content.getAppGroupPrivacy());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (AppGroupCreationContent) parcel.readParcelable(
+                            AppGroupCreationContent.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/AppInviteContent.java b/facebook/src/com/facebook/share/model/AppInviteContent.java
new file mode 100644
index 000000000..ef7987250
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/AppInviteContent.java
@@ -0,0 +1,117 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+
+/**
+ * Describes the content that will be displayed by the AppInviteDialog
+ */
+public final class AppInviteContent implements ShareModel {
+    private final String applinkUrl;
+    private final String previewImageUrl;
+
+    private AppInviteContent(final Builder builder) {
+        this.applinkUrl = builder.applinkUrl;
+        this.previewImageUrl = builder.previewImageUrl;
+    }
+
+    AppInviteContent(final Parcel in) {
+        this.applinkUrl = in.readString();
+        this.previewImageUrl = in.readString();
+    }
+
+    /**
+     * Gets the applink url.
+     */
+    public String getApplinkUrl() {
+        return applinkUrl;
+    }
+
+    /**
+     * Gets the preview image url.
+     */
+    public String getPreviewImageUrl() {
+        return previewImageUrl;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeString(this.applinkUrl);
+        out.writeString(this.previewImageUrl);
+    }
+
+    /**
+     * Builder class for a concrete instance of AppInviteContent
+     */
+    public static class Builder
+            implements ShareModelBuilder<AppInviteContent, Builder> {
+        private String applinkUrl;
+        private String previewImageUrl;
+
+        /**
+         * Sets the applink url that will be used for deep-linking
+         *
+         * @param applinkUrl the applink url
+         * @return the builder
+         */
+        public Builder setApplinkUrl(final String applinkUrl) {
+            this.applinkUrl = applinkUrl;
+            return this;
+        }
+
+        /**
+         * Sets the preview image url for this invite. See guidelines for correct dimensions.
+         *
+         * @param previewImageUrl url of the image that is going to be used as a preview for invite
+         * @return the builder
+         */
+        public Builder setPreviewImageUrl(final String previewImageUrl) {
+            this.previewImageUrl = previewImageUrl;
+            return this;
+        }
+
+        @Override
+        public AppInviteContent build() {
+            return new AppInviteContent(this);
+        }
+
+
+        @Override
+        public Builder readFrom(final AppInviteContent content) {
+            if (content == null) {
+                return this;
+            }
+            return this
+                    .setApplinkUrl(content.getApplinkUrl())
+                    .setPreviewImageUrl(content.getPreviewImageUrl());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom((AppInviteContent) parcel
+                    .readParcelable(AppInviteContent.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/GameRequestContent.java b/facebook/src/com/facebook/share/model/GameRequestContent.java
new file mode 100644
index 000000000..ee6e30c15
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/GameRequestContent.java
@@ -0,0 +1,269 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+
+import java.util.ArrayList;
+
+/**
+ * Describes the content that will be displayed by the GameRequestDialog
+ */
+public final class GameRequestContent implements ShareModel {
+    public enum ActionType {
+        SEND,
+        ASKFOR,
+        TURN,
+    }
+
+    public enum Filters {
+        APP_USERS,
+        APP_NON_USERS,
+    }
+
+    private final String message;
+    private final String to;
+    private final String title;
+    private final String data;
+
+    private final ActionType actionType;
+    private final String objectId;
+    private final Filters filters;
+    private final ArrayList<String> suggestions;
+
+    private GameRequestContent(final Builder builder) {
+        this.message = builder.message;
+        this.to = builder.to;
+        this.title = builder.title;
+        this.data = builder.data;
+        this.actionType = builder.actionType;
+        this.objectId = builder.objectId;
+        this.filters = builder.filters;
+        this.suggestions = builder.suggestions;
+    }
+
+    GameRequestContent(final Parcel in) {
+        this.message = in.readString();
+        this.to = in.readString();
+        this.title = in.readString();
+        this.data = in.readString();
+        this.actionType = ActionType.valueOf(in.readString());
+        this.objectId = in.readString();
+        this.filters = Filters.valueOf(in.readString());
+        this.suggestions = new ArrayList<>();
+        in.readStringList(this.suggestions);
+    }
+
+    /**
+     * Gets the message that users receiving the request will see.
+     */
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Gets the user ID or user name the request will be sent to.
+     */
+    public String getTo() {
+        return to;
+    }
+
+    /**
+     * Gets the optional title for the dialog
+     */
+    public String getTitle() {
+        return title;
+    }
+
+    /**
+     * Gets optional data which can be used for tracking
+     */
+    public String getData() {
+        return data;
+    }
+
+    /**
+     * Gets the action type
+     */
+    public ActionType getActionType() {
+        return this.actionType;
+    }
+
+    /**
+     * Gets the open graph id of the object that action type will be performed on
+     */
+    public String getObjectId() {
+        return this.objectId;
+    }
+
+    /**
+     * Get the filters
+     */
+    public Filters getFilters() {
+        return this.filters;
+    }
+
+    /**
+     * Gets a list of suggested user ids
+     */
+    public ArrayList<String> getSuggestions() {
+        return this.suggestions;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeString(this.message);
+        out.writeString(this.to);
+        out.writeString(this.title);
+        out.writeString(this.data);
+        out.writeString(this.getActionType().toString());
+        out.writeString(this.getObjectId());
+        out.writeString(this.getFilters().toString());
+        out.writeStringList(this.getSuggestions());
+    }
+
+    /**
+     * Builder class for a concrete instance of GameRequestContent
+     */
+    public static class Builder
+            implements ShareModelBuilder<GameRequestContent, Builder> {
+        private String message;
+        private String to;
+        private String data;
+        private String title;
+        private ActionType actionType;
+        private String objectId;
+        private Filters filters;
+        private ArrayList<String> suggestions;
+
+        /**
+         * Sets the message users receiving the request will see. The maximum length
+         * is 60 characters.
+         *
+         * @param message the message
+         * @return the builder
+         */
+        public Builder setMessage(final String message) {
+            this.message = message;
+            return this;
+        }
+
+        /**
+         * Sets the user ID or user name the request will be sent to. If this is not
+         * specified, a friend selector will be displayed and the user can select up
+         * to 50 friends.
+         *
+         * @param to the id or user name to send the request to
+         * @return the builder
+         */
+        public Builder setTo(final String to) {
+            this.to = to;
+            return this;
+        }
+
+        /**
+         * Sets optional data which can be used for tracking; maximum length is 255
+         * characters.
+         *
+         * @param data the data
+         * @return the builder
+         */
+        public Builder setData(final String data) {
+            this.data = data;
+            return this;
+        }
+
+        /**
+         * Sets an optional title for the dialog; maximum length is 50 characters.
+         *
+         * @param title the title
+         * @return the builder
+         */
+        public Builder setTitle(final String title) {
+            this.title = title;
+            return this;
+        }
+
+        /**
+         * Sets the action type for this request
+         */
+        public Builder setActionType(ActionType actionType) {
+            this.actionType = actionType;
+            return this;
+        }
+
+        /**
+         * Sets the open graph id of the object that action type will be performed on
+         * Only valid (and required) for ActionTypes SEND, ASKFOR
+         */
+        public Builder setObjectId(String objectId) {
+            this.objectId = objectId;
+            return this;
+        }
+
+        /**
+         * Sets the filters for everybody/app users/non app users
+         */
+        public Builder setFilters(Filters filters) {
+            this.filters = filters;
+            return this;
+        }
+
+        /**
+         * Sets a list of user ids suggested as request receivers
+         */
+        public Builder setSuggestions(ArrayList<String> suggestions) {
+            this.suggestions = suggestions;
+            return this;
+        }
+
+        @Override
+        public GameRequestContent build() {
+            return new GameRequestContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final GameRequestContent content) {
+            if (content == null) {
+                return this;
+            }
+            return this
+                    .setMessage(content.getMessage())
+                    .setTo(content.getTo())
+                    .setTitle(content.getTitle())
+                    .setData(content.getData())
+                    .setActionType(content.getActionType())
+                    .setObjectId(content.getObjectId())
+                    .setFilters(content.getFilters())
+                    .setSuggestions(content.getSuggestions());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (GameRequestContent)parcel.readParcelable(
+                            GameRequestContent.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareContent.java b/facebook/src/com/facebook/share/model/ShareContent.java
new file mode 100644
index 000000000..3d661e167
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareContent.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.net.Uri;
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides the base class for content to be shared. Contains all common methods for
+ * the different types of content.
+ */
+public abstract class ShareContent<P extends ShareContent, E extends ShareContent.Builder>
+        implements ShareModel {
+    private final Uri contentUrl;
+    private final List<String> peopleIds;
+    private final String placeId;
+    private final String ref;
+
+    protected ShareContent(final Builder builder) {
+        super();
+        this.contentUrl = builder.contentUrl;
+        this.peopleIds = builder.peopleIds;
+        this.placeId = builder.placeId;
+        this.ref = builder.ref;
+    }
+
+    ShareContent(final Parcel in) {
+        this.contentUrl = in.readParcelable(Uri.class.getClassLoader());
+        this.peopleIds = readUnmodifiableStringList(in);
+        this.placeId = in.readString();
+        this.ref = in.readString();
+    }
+
+    /**
+     * URL for the content being shared.  This URL will be checked for app link meta tags for
+     * linking in platform specific ways.
+     * <p/>
+     * See documentation for <a href="https://developers.facebook.com/docs/applinks/">App Links</a>.
+     *
+     * @return {@link android.net.Uri} representation of the content link.
+     */
+    @Nullable
+    public Uri getContentUrl() {
+        return this.contentUrl;
+    }
+
+    /**
+     * List of Ids for taggable people to tag with this content.
+     * <p/>
+     * See documentation for
+     * <a href="https://developers.facebook.com/docs/graph-api/reference/user/taggable_friends">
+     * Taggable Friends</a>.
+     *
+     * @return {@link java.util.List} of Ids for people to tag.
+     */
+    @Nullable
+    public List<String> getPeopleIds() {
+        return this.peopleIds;
+    }
+
+    /**
+     * The Id for a place to tag with this content.
+     *
+     * @return The Id for the place to tag.
+     */
+    @Nullable
+    public String getPlaceId() {
+        return this.placeId;
+    }
+
+    /**
+     * A value to be added to the referrer URL when a person follows a link from this shared
+     * content on feed.
+     *
+     * @return The ref for the content.
+     */
+    @Nullable
+    public String getRef() {
+        return this.ref;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeParcelable(this.contentUrl, 0);
+        out.writeStringList(this.peopleIds);
+        out.writeString(this.placeId);
+        out.writeString(this.ref);
+    }
+
+    private List<String> readUnmodifiableStringList(final Parcel in) {
+        final List<String> list = new ArrayList<String>();
+        in.readStringList(list);
+        return (list.size() == 0 ? null : Collections.unmodifiableList(list));
+    }
+
+    /**
+     * Abstract builder for {@link com.facebook.share.model.ShareContent}
+     */
+    public abstract static class Builder<P extends ShareContent, E extends Builder>
+            implements ShareModelBuilder<P, E> {
+        private Uri contentUrl;
+        private List<String> peopleIds;
+        private String placeId;
+        private String ref;
+
+        /**
+         * Set the URL for the content being shared.
+         *
+         * @param contentUrl {@link android.net.Uri} representation of the content link.
+         * @return The builder.
+         */
+        public E setContentUrl(@Nullable final Uri contentUrl) {
+            this.contentUrl = contentUrl;
+            return (E) this;
+        }
+
+        /**
+         * Set the list of Ids for taggable people to tag with this content.
+         *
+         * @param peopleIds {@link java.util.List} of Ids for people to tag.
+         * @return The builder.
+         */
+        public E setPeopleIds(@Nullable final List<String> peopleIds) {
+            this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));
+            return (E) this;
+        }
+
+        /**
+         * Set the Id for a place to tag with this content.
+         *
+         * @param placeId The Id for the place to tag.
+         * @return The builder.
+         */
+        public E setPlaceId(@Nullable final String placeId) {
+            this.placeId = placeId;
+            return (E) this;
+        }
+
+        /**
+         * Set the value to be added to the referrer URL when a person follows a link from this
+         * shared content on feed.
+         *
+         * @param ref The ref for the content.
+         * @return The builder.
+         */
+        public E setRef(@Nullable final String ref) {
+            this.ref = ref;
+            return (E) this;
+        }
+
+        @Override
+        public E readFrom(final P content) {
+            if (content == null) {
+                return (E) this;
+            }
+            return (E) this
+                    .setContentUrl(content.getContentUrl())
+                    .setPeopleIds(content.getPeopleIds())
+                    .setPlaceId(content.getPlaceId())
+                    .setRef(content.getRef());
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareLinkContent.java b/facebook/src/com/facebook/share/model/ShareLinkContent.java
new file mode 100644
index 000000000..1644ff781
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareLinkContent.java
@@ -0,0 +1,170 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.net.Uri;
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+/**
+ * Describes link content to be shared.
+ *
+ * Use {@link ShareLinkContent.Builder} to build instances.
+ *
+ * See documentation for <a href="https://developers.facebook.com/docs/sharing/best-practices">best practices</a>.
+ */
+public final class ShareLinkContent
+        extends ShareContent<ShareLinkContent, ShareLinkContent.Builder> {
+    private final String contentDescription;
+    private final String contentTitle;
+    private final Uri imageUrl;
+
+    private ShareLinkContent(final Builder builder) {
+        super(builder);
+        this.contentDescription = builder.contentDescription;
+        this.contentTitle = builder.contentTitle;
+        this.imageUrl = builder.imageUrl;
+    }
+
+    ShareLinkContent(final Parcel in) {
+        super(in);
+        this.contentDescription = in.readString();
+        this.contentTitle = in.readString();
+        this.imageUrl = in.readParcelable(Uri.class.getClassLoader());
+    }
+
+    /**
+     * The description of the link.  If not specified, this field is automatically populated by
+     * information scraped from the link, typically the title of the page.
+     * @return The description of the link.
+     */
+    public String getContentDescription() {
+        return this.contentDescription;
+    }
+
+    /**
+     * The title to display for this link.
+     * @return The link title.
+     */
+    @Nullable
+    public String getContentTitle() {
+        return this.contentTitle;
+    }
+
+    /**
+     * The URL of a picture to attach to this content.
+     * @return The network URL of an image.
+     */
+    @Nullable
+    public Uri getImageUrl() {
+        return this.imageUrl;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        super.writeToParcel(out, flags);
+        out.writeString(this.contentDescription);
+        out.writeString(this.contentTitle);
+        out.writeParcelable(this.imageUrl, 0);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareLinkContent> CREATOR =
+            new Creator<ShareLinkContent>() {
+        public ShareLinkContent createFromParcel(final Parcel in) {
+            return new ShareLinkContent(in);
+        }
+
+        public ShareLinkContent[] newArray(final int size) {
+            return new ShareLinkContent[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link ShareLinkContent} interface.
+     */
+    public static final class Builder
+            extends ShareContent.Builder<ShareLinkContent, Builder> {
+        private String contentDescription;
+        private String contentTitle;
+        private Uri imageUrl;
+
+        /**
+         * Set the contentDescription of the link.
+         * @param contentDescription The contentDescription of the link.
+         * @return The builder.
+         */
+        public Builder setContentDescription(
+                @Nullable final String contentDescription) {
+            this.contentDescription = contentDescription;
+            return this;
+        }
+
+        /**
+         * Set the contentTitle to display for this link.
+         * @param contentTitle The link contentTitle.
+         * @return The builder.
+         */
+        public Builder setContentTitle(@Nullable final String contentTitle) {
+            this.contentTitle = contentTitle;
+            return this;
+        }
+
+        /**
+         * Set the URL of a picture to attach to this content.
+         * @param imageUrl The network URL of an image.
+         * @return The builder.
+         */
+        public Builder setImageUrl(@Nullable final Uri imageUrl) {
+            this.imageUrl = imageUrl;
+            return this;
+        }
+
+        @Override
+        public ShareLinkContent build() {
+            return new ShareLinkContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final ShareLinkContent model) {
+            if (model == null) {
+                return this;
+            }
+            return super
+                    .readFrom(model)
+                    .setContentDescription(model.getContentDescription())
+                    .setImageUrl(model.getImageUrl())
+                    .setContentTitle(model.getContentTitle())
+                    ;
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (ShareLinkContent) parcel.readParcelable(
+                            ShareLinkContent.class.getClassLoader()));
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareModel.java b/facebook/src/com/facebook/share/model/ShareModel.java
new file mode 100644
index 000000000..31bf11911
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareModel.java
@@ -0,0 +1,29 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcelable;
+
+/**
+ * Base interface for share models.
+ */
+public interface ShareModel extends Parcelable {
+}
diff --git a/facebook/src/com/facebook/share/model/ShareModelBuilder.java b/facebook/src/com/facebook/share/model/ShareModelBuilder.java
new file mode 100644
index 000000000..794f1d5c2
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareModelBuilder.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+
+import com.facebook.share.ShareBuilder;
+
+/**
+ * Interface for builders related to sharing.
+ * @param <P> The model protocol to be built.
+ * @param <E> The concrete builder class.
+ */
+public interface ShareModelBuilder<P extends ShareModel, E extends ShareModelBuilder>
+        extends ShareBuilder<P, E> {
+    /**
+     * Reads the values from a ShareModel into the builder.
+     * @param model The source ShareModel
+     * @return The builder.
+     */
+    public E readFrom(P model);
+
+    /**
+     * Reads the values from a parcel into the builder.  The parcel must have packaged an instance
+     * of the ShareModel that came from the same type of builder.
+     * @param parcel The Parcel that contains the ShareModel.
+     * @return The builder.
+     */
+    public E readFrom(Parcel parcel);
+}
diff --git a/facebook/src/com/facebook/share/model/ShareOpenGraphAction.java b/facebook/src/com/facebook/share/model/ShareOpenGraphAction.java
new file mode 100644
index 000000000..81f5767ed
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareOpenGraphAction.java
@@ -0,0 +1,108 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+/**
+ * Describes an Open Graph action
+ * <p/>
+ * Use {@link ShareOpenGraphAction.Builder} to create instances
+ * <p/>
+ * See the documentation for
+ * <a href="https://developers.facebook.com/docs/opengraph/actions/">Open Graph Actions</a>.
+ */
+public final class ShareOpenGraphAction
+        extends ShareOpenGraphValueContainer<ShareOpenGraphAction, ShareOpenGraphAction.Builder> {
+
+    private ShareOpenGraphAction(final Builder builder) {
+        super(builder);
+    }
+
+    ShareOpenGraphAction(final Parcel in) {
+        super(in);
+    }
+
+    /**
+     * The type for the action.
+     *
+     * @return The type for the action.
+     */
+    @Nullable
+    public String getActionType() {
+        return this.getString(Builder.ACTION_TYPE_KEY);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareOpenGraphAction> CREATOR =
+            new Creator<ShareOpenGraphAction>() {
+                public ShareOpenGraphAction createFromParcel(final Parcel in) {
+                    return new ShareOpenGraphAction(in);
+                }
+
+                public ShareOpenGraphAction[] newArray(final int size) {
+                    return new ShareOpenGraphAction[size];
+                }
+            };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.ShareOpenGraphAction} interface.
+     */
+    public static final class Builder
+            extends ShareOpenGraphValueContainer.Builder<ShareOpenGraphAction, Builder> {
+        private static final String ACTION_TYPE_KEY = "og:type";
+
+        /**
+         * Sets the type for the action.
+         *
+         * @param actionType The type for the action.
+         * @return The builder.
+         */
+        public Builder setActionType(final String actionType) {
+            this.putString(ACTION_TYPE_KEY, actionType);
+            return this;
+        }
+
+        @Override
+        public ShareOpenGraphAction build() {
+            return new ShareOpenGraphAction(this);
+        }
+
+        @Override
+        public Builder readFrom(final ShareOpenGraphAction model) {
+            if (model == null) {
+                return this;
+            }
+            return super
+                    .readFrom(model)
+                    .setActionType(model.getActionType())
+                    ;
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (ShareOpenGraphAction) parcel.readParcelable(
+                            ShareOpenGraphAction.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareOpenGraphContent.java b/facebook/src/com/facebook/share/model/ShareOpenGraphContent.java
new file mode 100644
index 000000000..5806c9c8c
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareOpenGraphContent.java
@@ -0,0 +1,155 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+/**
+ * Describes Open Graph content that is to be shared
+ * <p/>
+ * Use {@link ShareOpenGraphContent.Builder} to create instances
+ * <p/>
+ * See the documentation for <a href="https://developers.facebook.com/docs/opengraph">Open Graph</a>
+ * and for <a href="https://developers.facebook.com/docs/sharing/best-practices">best practices</a>.
+ */
+public final class ShareOpenGraphContent
+        extends ShareContent<ShareOpenGraphContent, ShareOpenGraphContent.Builder> {
+    private final ShareOpenGraphAction action;
+    private final String previewPropertyName;
+
+    private ShareOpenGraphContent(final Builder builder) {
+        super(builder);
+        this.action = builder.action;
+        this.previewPropertyName = builder.previewPropertyName;
+    }
+
+    ShareOpenGraphContent(final Parcel in) {
+        super(in);
+        this.action = new ShareOpenGraphAction.Builder().readFrom(in).build();
+        this.previewPropertyName = in.readString();
+    }
+
+    /**
+     * The Open Graph Action for the content.
+     *
+     * @return {@link ShareOpenGraphAction}
+     */
+    @Nullable
+    public ShareOpenGraphAction getAction() {
+        return this.action;
+    }
+
+    /**
+     * The property name for the primary {@link com.facebook.share.model.ShareOpenGraphObject}
+     * in the action.
+     *
+     * @return The property name for the preview object.
+     */
+    @Nullable
+    public String getPreviewPropertyName() {
+        return this.previewPropertyName;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        super.writeToParcel(out, flags);
+        out.writeParcelable(this.action, 0);
+        out.writeString(this.previewPropertyName);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareOpenGraphContent> CREATOR =
+            new Creator<ShareOpenGraphContent>() {
+                public ShareOpenGraphContent createFromParcel(final Parcel in) {
+                    return new ShareOpenGraphContent(in);
+                }
+
+                public ShareOpenGraphContent[] newArray(final int size) {
+                    return new ShareOpenGraphContent[size];
+                }
+            };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.ShareOpenGraphContent} interface.
+     */
+    public static final class Builder
+            extends ShareContent.Builder<com.facebook.share.model.ShareOpenGraphContent, Builder> {
+        private ShareOpenGraphAction action;
+        private String previewPropertyName;
+
+        /**
+         * Sets the Open Graph Action for the content.
+         *
+         * @param action {@link com.facebook.share.model.ShareOpenGraphAction}
+         * @return The builder.
+         */
+        public Builder setAction(@Nullable final ShareOpenGraphAction action) {
+            this.action =
+                    (action == null
+                            ? null
+                            : new ShareOpenGraphAction.Builder()
+                            .readFrom(action).build());
+            return this;
+        }
+
+        /**
+         * Sets the property name for the primary
+         * {@link com.facebook.share.model.ShareOpenGraphObject} in the action.
+         *
+         * @param previewPropertyName The property name for the preview object.
+         * @return The builder.
+         */
+        public Builder setPreviewPropertyName(
+                @Nullable final String previewPropertyName) {
+            this.previewPropertyName = previewPropertyName;
+            return this;
+        }
+
+        @Override
+        public com.facebook.share.model.ShareOpenGraphContent build() {
+            return new ShareOpenGraphContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final com.facebook.share.model.ShareOpenGraphContent model) {
+            if (model == null) {
+                return this;
+            }
+            return super
+                    .readFrom(model)
+                    .setAction(model.getAction())
+                    .setPreviewPropertyName(model.getPreviewPropertyName())
+                    ;
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (com.facebook.share.model.ShareOpenGraphContent) parcel.readParcelable(
+                            ShareOpenGraphContent.class.getClassLoader()));
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareOpenGraphObject.java b/facebook/src/com/facebook/share/model/ShareOpenGraphObject.java
new file mode 100644
index 000000000..15c10ab69
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareOpenGraphObject.java
@@ -0,0 +1,80 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+
+import com.facebook.internal.NativeProtocol;
+
+/**
+ * Describes an Open Graph Object to be created.
+ * <p/>
+ * Use {@link ShareOpenGraphObject.Builder} to create instances
+ * <p/>
+ * See the documentation for
+ * <a href="https://developers.facebook.com/docs/opengraph/objects/">Open Graph Objects</a>.
+ */
+public final class ShareOpenGraphObject extends
+        ShareOpenGraphValueContainer<ShareOpenGraphObject, ShareOpenGraphObject.Builder> {
+
+    private ShareOpenGraphObject(final Builder builder) {
+        super(builder);
+    }
+
+    ShareOpenGraphObject(final Parcel in) {
+        super(in);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareOpenGraphObject> CREATOR =
+            new Creator<ShareOpenGraphObject>() {
+        public ShareOpenGraphObject createFromParcel(final Parcel in) {
+            return new ShareOpenGraphObject(in);
+        }
+
+        public ShareOpenGraphObject[] newArray(final int size) {
+            return new ShareOpenGraphObject[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.ShareOpenGraphObject} interface.
+     */
+    public static final class Builder
+            extends ShareOpenGraphValueContainer.Builder<ShareOpenGraphObject, Builder> {
+        public Builder() {
+            super();
+            this.putBoolean(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY, true);
+        }
+
+        @Override
+        public ShareOpenGraphObject build() {
+            return new ShareOpenGraphObject(this);
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (ShareOpenGraphObject)parcel.readParcelable(
+                            ShareOpenGraphObject.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareOpenGraphValueContainer.java b/facebook/src/com/facebook/share/model/ShareOpenGraphValueContainer.java
new file mode 100644
index 000000000..789a47b78
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareOpenGraphValueContainer.java
@@ -0,0 +1,418 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.Set;
+
+/**
+ * Provides an abstract class to contain Open Graph values.
+ *
+ * Use {@link ShareOpenGraphValueContainer.Builder} to create instances
+ */
+public abstract class ShareOpenGraphValueContainer
+        <P extends ShareOpenGraphValueContainer, E extends ShareOpenGraphValueContainer.Builder>
+        implements ShareModel {
+    private final Bundle bundle;
+
+    protected ShareOpenGraphValueContainer(
+            final Builder<P, E> builder) {
+        super();
+        this.bundle = (Bundle)builder.bundle.clone();
+    }
+
+    ShareOpenGraphValueContainer(final Parcel in) {
+        this.bundle = in.readBundle(Builder.class.getClassLoader());
+    }
+
+    /**
+     * Gets a value out of the object.
+     * @param key The key for the value.
+     * @return The boolean value.
+     */
+    @Nullable
+    public Object get(String key) {
+        return this.bundle.get(key);
+    }
+
+    /**
+     * Gets a boolean value out of the object.
+     * @param key The key for the value.
+     * @param defaultValue The value to return if no value is found for the specified key.
+     * @return The boolean value.
+     */
+    public boolean getBoolean(final String key, final boolean defaultValue) {
+        return this.bundle.getBoolean(key, defaultValue);
+    }
+
+    /**
+     * Gets an array of boolean values out of the object.
+     * @param key The key for the value.
+     * @return The boolean values.
+     */
+    @Nullable
+    public boolean[] getBooleanArray(final String key) {
+        return this.bundle.getBooleanArray(key);
+    }
+
+    /**
+     * Gets a double value out of the object.
+     * @param key The key for the value.
+     * @param defaultValue The value to return if no value is found for the specified key.
+     * @return The double value.
+     */
+    public double getDouble(final String key, final double defaultValue) {
+        return this.bundle.getDouble(key, defaultValue);
+    }
+
+    /**
+     * Gets an array of double values out of the object.
+     * @param key The key for the value.
+     * @return The double values.
+     */
+    @Nullable
+    public double[] getDoubleArray(final String key) {
+        return this.bundle.getDoubleArray(key);
+    }
+
+    /**
+     * Gets an int value out of the object.
+     * @param key The key for the value.
+     * @param defaultValue The value to return if no value is found for the specified key.
+     * @return The int value.
+     */
+    public int getInt(final String key, final int defaultValue) {
+        return this.bundle.getInt(key, defaultValue);
+    }
+
+    /**
+     * Gets an array of int values out of the object.
+     * @param key The key for the value.
+     * @return The int values.
+     */
+    @Nullable
+    public int[] getIntArray(final String key) {
+        return this.bundle.getIntArray(key);
+    }
+
+    /**
+     * Gets an long value out of the object.
+     * @param key The key for the value.
+     * @param defaultValue The value to return if no value is found for the specified key.
+     * @return The long value.
+     */
+    public long getLong(final String key, final long defaultValue) {
+        return this.bundle.getLong(key, defaultValue);
+    }
+
+    /**
+     * Gets an array of long values out of the object.
+     * @param key The key for the value.
+     * @return The long values.
+     */
+    @Nullable
+    public long[] getLongArray(final String key) {
+        return this.bundle.getLongArray(key);
+    }
+
+    /**
+     * Gets an object value out of the object.
+     * @param key The key for the value.
+     * @return The object value.
+     */
+    public ShareOpenGraphObject getObject(final String key) {
+        final Object value = this.bundle.get(key);
+        return (value instanceof ShareOpenGraphObject ? (ShareOpenGraphObject)value : null);
+    }
+
+    /**
+     * Gets an array of object values out of the object.
+     * @param key The key for the value.
+     * @return The object values.
+     */
+    @Nullable
+    public ArrayList<ShareOpenGraphObject> getObjectArrayList(final String key) {
+        final ArrayList<Parcelable> items = this.bundle.getParcelableArrayList(key);
+        if (items == null) {
+            return null;
+        }
+        final ArrayList<ShareOpenGraphObject> list = new ArrayList<ShareOpenGraphObject>();
+        for (Parcelable item : items) {
+            if (item instanceof ShareOpenGraphObject) {
+                list.add((ShareOpenGraphObject)item);
+            }
+        }
+        return list;
+    }
+
+    /**
+     * Gets a photo value out of the object.
+     * @param key The key for the value.
+     * @return The photo value.
+     */
+    @Nullable
+    public SharePhoto getPhoto(final String key) {
+        final Object value = this.bundle.getParcelable(key);
+        return (value instanceof SharePhoto ? (SharePhoto)value : null);
+    }
+
+    /**
+     * Gets an array of photo values out of the object.
+     * @param key The key for the value.
+     * @return The photo values.
+     */
+    @Nullable
+    public ArrayList<SharePhoto> getPhotoArrayList(final String key) {
+        final ArrayList<Parcelable> items = this.bundle.getParcelableArrayList(key);
+        if (items == null) {
+            return null;
+        }
+        final ArrayList<SharePhoto> list = new ArrayList<SharePhoto>();
+        for (Parcelable item : items) {
+            if (item instanceof SharePhoto) {
+                list.add((SharePhoto)item);
+            }
+        }
+        return list;
+    }
+
+    /**
+     * Gets a string value out of the object.
+     * @param key The key for the value.
+     * @return The string value.
+     */
+    @Nullable
+    public String getString(final String key) {
+        return this.bundle.getString(key);
+    }
+
+    /**
+     * Gets an array of string values out of the object.
+     * @param key The key for the value.
+     * @return The string values.
+     */
+    @Nullable
+    public ArrayList<String> getStringArrayList(final String key) {
+        return this.bundle.getStringArrayList(key);
+    }
+
+    /**
+     * Returns the values in the container packaged in a bundle.
+     * @return A bundle with the values.
+     */
+    public Bundle getBundle() {
+        return (Bundle)this.bundle.clone();
+    }
+
+    /**
+     * Returns a set of the keys contained in this object.
+     * @return A set of the keys.
+     */
+    public Set<String> keySet() {
+        return this.bundle.keySet();
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeBundle(this.bundle);
+    }
+
+    /**
+     * Abstract builder for the {@link com.facebook.share.model.ShareOpenGraphValueContainer} class.
+     */
+    public abstract static class Builder
+            <P extends ShareOpenGraphValueContainer, E extends Builder>
+            implements ShareModelBuilder<P, E> {
+        private Bundle bundle = new Bundle();
+
+        /**
+         * Sets a boolean value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putBoolean(final String key, final boolean value) {
+            this.bundle.putBoolean(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of boolean values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putBooleanArray(final String key, @Nullable final boolean[] value) {
+            this.bundle.putBooleanArray(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets a double value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putDouble(final String key, final double value) {
+            this.bundle.putDouble(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of double values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putDoubleArray(final String key, @Nullable final double[] value) {
+            this.bundle.putDoubleArray(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an int value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putInt(final String key, final int value) {
+            this.bundle.putInt(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of int values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putIntArray(final String key, @Nullable final int[] value) {
+            this.bundle.putIntArray(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets a long value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putLong(final String key, final long value) {
+            this.bundle.putLong(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of long values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putLongArray(final String key, @Nullable final long[] value) {
+            this.bundle.putLongArray(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an object value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putObject(final String key, @Nullable final ShareOpenGraphObject value) {
+            this.bundle.putParcelable(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of object values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putObjectArrayList(
+                final String key,
+                @Nullable final ArrayList<ShareOpenGraphObject> value) {
+            this.bundle.putParcelableArrayList(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets a photo value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putPhoto(final String key, @Nullable final SharePhoto value) {
+            this.bundle.putParcelable(key, value);
+            return (E)this;
+        }
+
+        /**
+         * Sets an array of photo values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putPhotoArrayList(final String key, @Nullable final ArrayList<SharePhoto> value) {
+            this.bundle.putParcelableArrayList(key, value);
+            return (E) this;
+        }
+
+        /**
+         * Sets a string value in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putString(final String key, @Nullable final String value) {
+            this.bundle.putString(key, value);
+            return (E) this;
+        }
+
+        /**
+         * Sets an array of string values in the object.
+         * @param key The key for the value.
+         * @param value The value.
+         * @return The builder.
+         */
+        public E putStringArrayList(final String key, @Nullable final ArrayList<String> value) {
+            this.bundle.putStringArrayList(key, value);
+            return (E) this;
+        }
+
+        @Override
+        public E readFrom(final P model) {
+            if (model != null) {
+                this.bundle.putAll(model.getBundle());
+            }
+            return (E)this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/SharePhoto.java b/facebook/src/com/facebook/share/model/SharePhoto.java
new file mode 100644
index 000000000..fcc111915
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/SharePhoto.java
@@ -0,0 +1,216 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Describes a photo for sharing.
+ *
+ * Use {@link SharePhoto.Builder} to build instances
+ */
+public final class SharePhoto implements ShareModel {
+    private final Bitmap bitmap;
+    private final Uri imageUrl;
+    private final boolean userGenerated;
+    private final String caption;
+
+    private SharePhoto(final Builder builder) {
+        this.bitmap = builder.bitmap;
+        this.imageUrl = builder.imageUrl;
+        this.userGenerated = builder.userGenerated;
+        this.caption = builder.caption;
+    }
+
+    SharePhoto(final Parcel in) {
+        this.bitmap = in.readParcelable(Bitmap.class.getClassLoader());
+        this.imageUrl = in.readParcelable(Uri.class.getClassLoader());
+        this.userGenerated = (in.readByte() != 0);
+        this.caption = in.readString();
+    }
+
+    /**
+     * If the photo is resident in memory, this method supplies the data.
+     * @return {@link android.graphics.Bitmap} representation of the photo.
+     */
+    @Nullable
+    public Bitmap getBitmap() {
+        return this.bitmap;
+    }
+
+    /**
+     * The URL to the photo.
+     * @return {@link android.net.Uri} that points to a network location or the location of the
+     * photo on disk.
+     */
+    @Nullable
+    public Uri getImageUrl() {
+        return this.imageUrl;
+    }
+
+    /**
+     * Specifies whether the photo represented by this object was generated by the user or by the
+     * application.
+     * @return Indication of whether the photo is user-generated.
+     */
+    public boolean getUserGenerated() {
+        return this.userGenerated;
+    }
+
+    /**
+     * Gets the user generated caption. Note that the 'caption' must come from the user, as
+     * pre-filled content is forbidden by the Platform Policies (2.3).
+     * @return The user generated caption.
+     */
+    public String getCaption() {
+        return this.caption;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeParcelable(this.bitmap, 0);
+        out.writeParcelable(this.imageUrl, 0);
+        out.writeByte((byte)(this.userGenerated ? 1 : 0));
+        out.writeString(caption);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<SharePhoto> CREATOR = new Creator<SharePhoto>() {
+        public SharePhoto createFromParcel(final Parcel in) {
+            return new SharePhoto(in);
+        }
+
+        public SharePhoto[] newArray(final int size) {
+            return new SharePhoto[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.SharePhoto} interface.
+     */
+    public static final class Builder implements ShareModelBuilder<SharePhoto, Builder> {
+        private Bitmap bitmap;
+        private Uri imageUrl;
+        private boolean userGenerated;
+        private String caption;
+
+        /**
+         * Sets the bitmap representation of the photo.
+         * @param bitmap {@link android.graphics.Bitmap} representation of the photo.
+         * @return The builder.
+         */
+        public Builder setBitmap(@Nullable final Bitmap bitmap) {
+            this.bitmap = bitmap;
+            return this;
+        }
+
+        /**
+         * Sets the URL to the photo.
+         * @param imageUrl {@link android.net.Uri} that points to a network location or the location
+         *                                        of the photo on disk.
+         * @return The builder.
+         */
+        public Builder setImageUrl(@Nullable final Uri imageUrl) {
+            this.imageUrl = imageUrl;
+            return this;
+        }
+
+        /**
+         * Sets whether the photo represented by this object was generated by the user or by the
+         * application.
+         * @param userGenerated Indication of whether the photo is user-generated.
+         * @return The builder.
+         */
+        public Builder setUserGenerated(final boolean userGenerated) {
+            this.userGenerated = userGenerated;
+            return this;
+        }
+
+        /**
+         * Sets the user generated caption for the photo. Note that the 'caption' must come from
+         * the user, as pre-filled content is forbidden by the Platform Policies (2.3).
+         *
+         * @param caption {@link java.lang.String} of a {@link com.facebook.share.model.SharePhoto}
+         * @return The builder.
+         */
+        public Builder setCaption(@Nullable final String caption) {
+            this.caption = caption;
+            return this;
+        }
+
+        // Accessor that is present only for ShareVideoContent(Parcel) to use
+        Uri getImageUrl() {
+            return imageUrl;
+        }
+
+        // Accessor that is present only for ShareVideoContent(Parcel) to use
+        Bitmap getBitmap() {
+            return bitmap;
+        }
+
+        @Override
+        public SharePhoto build() {
+            return new SharePhoto(this);
+        }
+
+        @Override
+        public Builder readFrom(final SharePhoto model) {
+            if (model == null) {
+                return this;
+            }
+            return this
+                    .setBitmap(model.getBitmap())
+                    .setImageUrl(model.getImageUrl())
+                    .setUserGenerated(model.getUserGenerated())
+                    .setCaption(model.getCaption())
+                    ;
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (SharePhoto)parcel.readParcelable(SharePhoto.class.getClassLoader()));
+        }
+
+        public static void writeListTo(final Parcel out, final List<SharePhoto> photos) {
+            final List<SharePhoto> list = new ArrayList<>();
+            for (SharePhoto photo : photos) {
+                list.add(photo);
+            }
+            out.writeTypedList(list);
+        }
+
+        public static List<SharePhoto> readListFrom(final Parcel in) {
+            final List<SharePhoto> list = new ArrayList<>();
+            in.readTypedList(list, CREATOR);
+            return list;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/SharePhotoContent.java b/facebook/src/com/facebook/share/model/SharePhotoContent.java
new file mode 100644
index 000000000..3cad92e31
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/SharePhotoContent.java
@@ -0,0 +1,146 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+import com.facebook.share.internal.ShareConstants;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Describes photo content to be shared.
+ *
+ * Use {@link SharePhotoContent.Builder} to create instances
+ */
+public final class SharePhotoContent
+        extends ShareContent<SharePhotoContent, SharePhotoContent.Builder> {
+    private final List<SharePhoto> photos;
+
+    private SharePhotoContent(final Builder builder) {
+        super(builder);
+        this.photos = Collections.unmodifiableList(builder.photos);
+    }
+
+    SharePhotoContent(final Parcel in) {
+        super(in);
+        this.photos = Collections.unmodifiableList(SharePhoto.Builder.readListFrom(in));
+    }
+
+    /**
+     * Photos to be shared.
+     * @return {@link java.util.List} of {@link SharePhoto}s.
+     */
+    @Nullable
+    public List<SharePhoto> getPhotos() {
+        return this.photos;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        super.writeToParcel(out, flags);
+        SharePhoto.Builder.writeListTo(out, this.photos);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<SharePhotoContent> CREATOR = new Creator<SharePhotoContent>() {
+        public SharePhotoContent createFromParcel(final Parcel in) {
+            return new SharePhotoContent(in);
+        }
+
+        public SharePhotoContent[] newArray(final int size) {
+            return new SharePhotoContent[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link SharePhotoContent} interface.
+     */
+    public static class Builder extends ShareContent.Builder<SharePhotoContent, Builder> {
+        private final List<SharePhoto> photos = new ArrayList<SharePhoto>();
+
+        /**
+         * Adds a photo to the content.
+         * @param photo {@link com.facebook.share.model.SharePhoto} to add.
+         * @return The builder.
+         */
+        public Builder addPhoto(@Nullable final SharePhoto photo) {
+            if (photo != null) {
+                this.photos.add(new SharePhoto.Builder().readFrom(photo).build());
+            }
+            return this;
+        }
+
+        /**
+         * Adds multiple photos to the content.
+         * @param photos {@link java.util.List} of {@link com.facebook.share.model.SharePhoto}s
+         *                                      to add.
+         * @return The builder.
+         */
+        public Builder addPhotos(@Nullable final List<SharePhoto> photos) {
+            if (photos != null) {
+                for (SharePhoto photo : photos) {
+                    this.addPhoto(photo);
+                }
+            }
+            return this;
+        }
+
+        @Override
+        public SharePhotoContent build() {
+            return new SharePhotoContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final SharePhotoContent model) {
+            if (model == null) {
+                return this;
+            }
+            return super.
+                    readFrom(model)
+                    .addPhotos(model.getPhotos());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (SharePhotoContent) parcel.readParcelable(
+                            SharePhotoContent.class.getClassLoader()));
+        }
+
+        /**
+         * Replaces the photos for the builder.
+         * @param photos {@link java.util.List} of {@link com.facebook.share.model.SharePhoto}s to add.
+         * @return The builder.
+         */
+        public Builder setPhotos(@Nullable final List<SharePhoto> photos) {
+            this.photos.clear();
+            this.addPhotos(photos);
+            return this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareVideo.java b/facebook/src/com/facebook/share/model/ShareVideo.java
new file mode 100644
index 000000000..6cd792788
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareVideo.java
@@ -0,0 +1,106 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.net.Uri;
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+/**
+ * Describes a video for sharing.
+ *
+ * Use {@link ShareVideo.Builder} to create instances
+ */
+public final class ShareVideo implements ShareModel {
+    private final Uri localUrl;
+
+    private ShareVideo(final Builder builder) {
+        this.localUrl = builder.localUrl;
+    }
+
+    ShareVideo(final Parcel in) {
+        this.localUrl = in.readParcelable(Uri.class.getClassLoader());
+    }
+
+    /**
+     * This method supplies the URL to locate the video.
+     * @return {@link android.net.Uri} that points to the location of the video on disk.
+     */
+    @Nullable
+    public Uri getLocalUrl() {
+        return this.localUrl;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        out.writeParcelable(this.localUrl, 0);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareVideo> CREATOR = new Creator<ShareVideo>() {
+        public ShareVideo createFromParcel(final Parcel in) {
+            return new ShareVideo(in);
+        }
+
+        public ShareVideo[] newArray(final int size) {
+            return new ShareVideo[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.ShareVideo} interface.
+     */
+    public static final class Builder implements ShareModelBuilder<ShareVideo, Builder> {
+        private Uri localUrl;
+
+        /**
+         * Sets the URL to locate the video.
+         * @param localUrl {@link android.net.Uri} that points to the location of the video on disk.
+         * @return The builder.
+         */
+        public Builder setLocalUrl(@Nullable final Uri localUrl) {
+            this.localUrl = localUrl;
+            return this;
+        }
+
+        @Override
+        public ShareVideo build() {
+            return new ShareVideo(this);
+        }
+
+        @Override
+        public Builder readFrom(final ShareVideo model) {
+            if (model == null) {
+                return this;
+            }
+            return this.setLocalUrl(model.getLocalUrl());
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom(
+                    (ShareVideo) parcel.readParcelable(ShareVideo.class.getClassLoader()));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/model/ShareVideoContent.java b/facebook/src/com/facebook/share/model/ShareVideoContent.java
new file mode 100644
index 000000000..24b510210
--- /dev/null
+++ b/facebook/src/com/facebook/share/model/ShareVideoContent.java
@@ -0,0 +1,204 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.model;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+
+/**
+ * Provides the interface for video content to be shared.
+ *
+ * A general use builder is available in
+ * {@link ShareVideoContent.Builder}.
+ */
+public final class ShareVideoContent
+        extends ShareContent<ShareVideoContent, ShareVideoContent.Builder>
+        implements ShareModel {
+    private final String contentDescription;
+    private final String contentTitle;
+    private final SharePhoto previewPhoto;
+    private final ShareVideo video;
+
+    private ShareVideoContent(final Builder builder) {
+        super(builder);
+
+        this.contentDescription = builder.contentDescription;
+        this.contentTitle = builder.contentTitle;
+        this.previewPhoto = builder.previewPhoto;
+        this.video = builder.video;
+    }
+
+    ShareVideoContent(final Parcel in) {
+        super(in);
+        this.contentDescription = in.readString();
+        this.contentTitle = in.readString();
+        SharePhoto.Builder previewPhotoBuilder = new SharePhoto.Builder().readFrom(in);
+        if (previewPhotoBuilder.getImageUrl() != null || previewPhotoBuilder.getBitmap() != null) {
+            this.previewPhoto = previewPhotoBuilder.build();
+        } else {
+            this.previewPhoto = null;
+        }
+        this.video = new ShareVideo.Builder().readFrom(in).build();
+    }
+
+    /**
+     * The description of the video.
+     * @return The description of the video.
+     */
+    @Nullable
+    public String getContentDescription() {
+        return this.contentDescription;
+    }
+
+    /**
+     * The title to display for this video.
+     * @return The video title.
+     */
+    @Nullable
+    public String getContentTitle() {
+        return this.contentTitle;
+    }
+
+    /**
+     * Photo to be used as a preview for the video.
+     * @return Preview {@link SharePhoto} for the content.
+     */
+    @Nullable
+    public SharePhoto getPreviewPhoto() {
+        return this.previewPhoto;
+    }
+
+    /**
+     * Video to be shared.
+     * @return {@link ShareVideo}
+     */
+    @Nullable
+    public ShareVideo getVideo() {
+        return this.video;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(final Parcel out, final int flags) {
+        super.writeToParcel(out, flags);
+        out.writeString(this.contentDescription);
+        out.writeString(this.contentTitle);
+        out.writeParcelable(this.previewPhoto, 0);
+        out.writeParcelable(this.video, 0);
+    }
+
+    @SuppressWarnings("unused")
+    public static final Creator<ShareVideoContent> CREATOR = new Creator<ShareVideoContent>() {
+        public ShareVideoContent createFromParcel(final Parcel in) {
+            return new ShareVideoContent(in);
+        }
+
+        public ShareVideoContent[] newArray(final int size) {
+            return new ShareVideoContent[size];
+        }
+    };
+
+    /**
+     * Builder for the {@link com.facebook.share.model.ShareVideoContent} interface.
+     */
+    public static final class Builder extends ShareContent.Builder<ShareVideoContent, Builder> {
+        private String contentDescription;
+        private String contentTitle;
+        private SharePhoto previewPhoto;
+        private ShareVideo video;
+
+        /**
+         * Sets the description of the video.
+         * @param contentDescription The description of the video.
+         * @return The builder.
+         */
+        public Builder setContentDescription(
+                @Nullable final String contentDescription) {
+            this.contentDescription = contentDescription;
+            return this;
+        }
+
+        /**
+         * Sets the title to display for this video.
+         * @param contentTitle The video title.
+         * @return The builder.
+         */
+        public Builder setContentTitle(@Nullable final String contentTitle) {
+            this.contentTitle = contentTitle;
+            return this;
+        }
+
+        /**
+         * Sets the photo to be used as a preview for the video.
+         * @param previewPhoto Preview {@link com.facebook.share.model.SharePhoto} for the content.
+         * @return The builder.
+         */
+        public Builder setPreviewPhoto(@Nullable final SharePhoto previewPhoto) {
+            this.previewPhoto = (
+                    previewPhoto == null ?
+                    null :
+                    new SharePhoto.Builder().readFrom(previewPhoto).build());
+            return this;
+        }
+
+        /**
+         * Sets the video to be shared.
+         * @param video {@link com.facebook.share.model.ShareVideo}
+         * @return The builder.
+         */
+        public Builder setVideo(@Nullable final ShareVideo video) {
+            if (video == null) {
+                return this;
+            }
+
+            this.video = new ShareVideo.Builder().readFrom(video).build();
+            return this;
+        }
+
+        @Override
+        public ShareVideoContent build() {
+            return new ShareVideoContent(this);
+        }
+
+        @Override
+        public Builder readFrom(final ShareVideoContent model) {
+            if (model == null) {
+                return this;
+            }
+            return super
+                    .readFrom(model)
+                    .setContentDescription(model.getContentDescription())
+                    .setContentTitle(model.getContentTitle())
+                    .setPreviewPhoto(model.getPreviewPhoto())
+                    .setVideo(model.getVideo())
+                    ;
+        }
+
+        @Override
+        public Builder readFrom(final Parcel parcel) {
+            return this.readFrom((ShareVideoContent)parcel.readParcelable(
+                    ShareVideoContent.class.getClassLoader()));
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/AppInviteDialog.java b/facebook/src/com/facebook/share/widget/AppInviteDialog.java
new file mode 100644
index 000000000..f901fdc92
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/AppInviteDialog.java
@@ -0,0 +1,250 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+
+import com.facebook.FacebookCallback;
+import com.facebook.internal.*;
+import com.facebook.share.internal.*;
+import com.facebook.share.model.AppInviteContent;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A dialog for inviting users.
+ */
+public class AppInviteDialog
+        extends FacebookDialogBase<AppInviteContent, AppInviteDialog.Result> {
+
+    /**
+     * Helper object for handling the result from an app invites dialog.
+     */
+    public static final class Result {
+        private final Bundle bundle;
+
+        /**
+         * Constructor
+         *
+         * @param bundle the results bundle
+         */
+        public Result(Bundle bundle) {
+            this.bundle = bundle;
+        }
+
+        /**
+         * Returns the results data as a Bundle.
+         *
+         * @return the results bundle
+         */
+        public Bundle getData() {
+            return bundle;
+        }
+    }
+
+    private static final String TAG = "AppInviteDialog";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.AppInvite.toRequestCode();
+
+    /**
+     * Indicates whether the app invite dialog can be shown.
+     *
+     * @return true if the dialog can be shown
+     */
+    public static boolean canShow() {
+        return canShowNativeDialog() || canShowWebFallback();
+    }
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.AppInviteContent} using
+     * the provided Activity. No callback will be invoked.
+     *
+     * @param activity          Activity to use to share the provided content
+     * @param appInviteContent Content of the app invite to send
+     */
+    public static void show(
+            final Activity activity,
+            final AppInviteContent appInviteContent) {
+        new AppInviteDialog(activity)
+                .show(appInviteContent);
+    }
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.AppInviteContent} using
+     * the provided Fragment. No callback will be invoked.
+     *
+     * @param fragment          Fragment to use to share the provided content
+     * @param appInviteContent Content of the app invite to send
+     */
+    public static void show(
+            final Fragment fragment,
+            final AppInviteContent appInviteContent) {
+        new AppInviteDialog(fragment)
+                .show(appInviteContent);
+    }
+
+    private static boolean canShowNativeDialog() {
+        return (Build.VERSION.SDK_INT >= ShareConstants.MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS) &&
+                DialogPresenter.canPresentNativeDialogWithFeature(getFeature());
+    }
+
+    private static boolean canShowWebFallback() {
+        return (Build.VERSION.SDK_INT >= ShareConstants.MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS) &&
+                DialogPresenter.canPresentWebFallbackDialogWithFeature(getFeature());
+    }
+
+    /**
+     * Constructs a new AppInviteDialog.
+     *
+     * @param activity Activity to use to share the provided content.
+     */
+    public AppInviteDialog(final Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a new AppInviteDialog.
+     *
+     * @param fragment Fragment to use to share the provided content.
+     */
+    public AppInviteDialog(final Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+    }
+
+    protected void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        final ResultProcessor resultProcessor = (callback == null)
+                ? null
+                : new ResultProcessor(callback) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle results) {
+                String gesture = ShareInternalUtility.getNativeDialogCompletionGesture(results);
+                if ("cancel".equalsIgnoreCase(gesture)) {
+                    callback.onCancel();
+                } else {
+                    callback.onSuccess(new Result(results));
+                }
+            }
+        };
+
+        CallbackManagerImpl.Callback callbackManagerCallback = new CallbackManagerImpl.Callback() {
+            @Override
+            public boolean onActivityResult(int resultCode, Intent data) {
+                return ShareInternalUtility.handleActivityResult(
+                        getRequestCode(),
+                        resultCode,
+                        data,
+                        resultProcessor);
+            }
+        };
+
+        callbackManager.registerCallback(
+                getRequestCode(),
+                callbackManagerCallback);
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new NativeHandler());
+        handlers.add(new WebFallbackHandler());
+
+        return handlers;
+    }
+
+    private class NativeHandler extends ModeHandler {
+        @Override
+        public boolean canShow(AppInviteContent content) {
+            return AppInviteDialog.canShowNativeDialog();
+        }
+
+        @Override
+        public AppCall createAppCall(final AppInviteContent content) {
+            final AppCall appCall = createBaseAppCall();
+
+            DialogPresenter.setupAppCallForNativeDialog(
+                    appCall,
+                    new DialogPresenter.ParameterProvider() {
+                        @Override
+                        public Bundle getParameters() {
+                            return createParameters(content);
+                        }
+
+                        @Override
+                        public Bundle getLegacyParameters() {
+                            // App Invites are not supported with legacy fb4a devices.
+                            // We should never get here
+                            Log.e(TAG, "Attempting to present the AppInviteDialog with " +
+                                    "an outdated Facebook app on the device");
+                            return new Bundle();
+                        }
+                    },
+                    getFeature());
+
+            return appCall;
+        }
+    }
+
+    private class WebFallbackHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final AppInviteContent content) {
+            return AppInviteDialog.canShowWebFallback();
+        }
+
+        @Override
+        public AppCall createAppCall(final AppInviteContent content) {
+            final AppCall appCall = createBaseAppCall();
+
+            DialogPresenter.setupAppCallForWebFallbackDialog(
+                    appCall,
+                    createParameters(content),
+                    getFeature());
+
+            return appCall;
+        }
+    }
+
+    private static DialogFeature getFeature() {
+        return AppInviteDialogFeature.APP_INVITES_DIALOG;
+    }
+
+    private static Bundle createParameters(final AppInviteContent content) {
+        Bundle params = new Bundle();
+
+        params.putString(ShareConstants.APPLINK_URL, content.getApplinkUrl());
+        params.putString(ShareConstants.PREVIEW_IMAGE_URL, content.getPreviewImageUrl());
+
+        return params;
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/CreateAppGroupDialog.java b/facebook/src/com/facebook/share/widget/CreateAppGroupDialog.java
new file mode 100644
index 000000000..dc0455792
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/CreateAppGroupDialog.java
@@ -0,0 +1,179 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookCallback;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogPresenter;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.share.internal.ResultProcessor;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.internal.WebDialogParameters;
+import com.facebook.share.model.AppGroupCreationContent;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A dialog for creating app groups
+ */
+public class CreateAppGroupDialog
+        extends FacebookDialogBase<AppGroupCreationContent, CreateAppGroupDialog.Result> {
+
+    private static final String GAME_GROUP_CREATION_DIALOG = "game_group_create";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.AppGroupCreate.toRequestCode();
+
+    /**
+     * Helper object for handling the result from a create app group dialog.
+     */
+    public static final class Result {
+        private final String id;
+
+        private Result(String id) {
+            this.id = id;
+        }
+
+        /**
+         * Get the ID of the created group.
+         * @return the id of the group.
+         */
+        public String getId() {
+            return id;
+        }
+    }
+
+    /**
+     * Indicates whether the create app group dialog can be shown.
+     *
+     * @return true if the dialog can be shown
+     */
+    public static boolean canShow() {
+        return true;
+    }
+
+    /**
+     * Shows an {@link CreateAppGroupDialog} to create a group with the passed in content, using
+     * the passed in activity. No callback will be invoked.
+     *
+     * @param activity Activity hosting the dialog
+     * @param appGroupCreationContent Content describing the group to be created
+     */
+    public static void show(
+            final Activity activity,
+            final AppGroupCreationContent appGroupCreationContent) {
+        new CreateAppGroupDialog(activity).show(appGroupCreationContent);
+    }
+
+    /**
+     * Shows an {@link CreateAppGroupDialog} to create a group with the passed in content, using
+     * the passed in fragment. No callback will be invoked.
+     *
+     * @param fragment Fragment hosting the dialog
+     * @param appGroupCreationContent Content describing the group to be created
+     */
+    public static void show(
+            final Fragment fragment,
+            AppGroupCreationContent appGroupCreationContent) {
+        new CreateAppGroupDialog(fragment).show(appGroupCreationContent);
+    }
+
+    /**
+     * Constructs a new CreateAppGroupDialog.
+     * @param activity Activity hosting the dialog.
+     */
+    public CreateAppGroupDialog(final Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a new CreateAppGroupDialog.
+     * @param fragment Fragment hosting the dialog.
+     */
+    public CreateAppGroupDialog(final Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        final ResultProcessor resultProcessor = (callback == null)
+                ? null
+                : new ResultProcessor(callback) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle results) {
+                callback.onSuccess(new Result(results.getString("id")));
+            }
+        };
+
+        CallbackManagerImpl.Callback callbackManagerCallback = new CallbackManagerImpl.Callback() {
+            @Override
+            public boolean onActivityResult(int resultCode, Intent data) {
+                return ShareInternalUtility.handleActivityResult(
+                        getRequestCode(),
+                        resultCode,
+                        data,
+                        resultProcessor);
+            }
+        };
+
+        callbackManager.registerCallback(getRequestCode(), callbackManagerCallback);
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new WebHandler());
+
+        return handlers;
+    }
+
+    private class WebHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final AppGroupCreationContent content) {
+            return true;
+        }
+
+        @Override
+        public AppCall createAppCall(final AppGroupCreationContent content) {
+            AppCall appCall = createBaseAppCall();
+            DialogPresenter.setupAppCallForWebDialog(
+                    appCall,
+                    GAME_GROUP_CREATION_DIALOG,
+                    WebDialogParameters.create(content));
+
+            return appCall;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/GameRequestDialog.java b/facebook/src/com/facebook/share/widget/GameRequestDialog.java
new file mode 100644
index 000000000..875bd6d03
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/GameRequestDialog.java
@@ -0,0 +1,201 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookCallback;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogPresenter;
+import com.facebook.share.internal.GameRequestValidation;
+import com.facebook.share.internal.ResultProcessor;
+import com.facebook.share.internal.ShareConstants;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.internal.WebDialogParameters;
+import com.facebook.share.model.GameRequestContent;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides functionality to send requests in games.
+ * see https://developers.facebook.com/docs/games/requests
+ */
+public class GameRequestDialog
+        extends FacebookDialogBase<GameRequestContent, GameRequestDialog.Result> {
+
+    /**
+     * Helper object for handling the result from a requests dialog
+     */
+    public static final class Result {
+        String requestId;
+        List<String> to;
+
+        private Result(Bundle results) {
+            this.requestId = results.getString(ShareConstants.WEB_DIALOG_RESULT_PARAM_REQUEST_ID);
+            this.to = new ArrayList<String>();
+            while (results.containsKey(String.format(
+                    ShareConstants.WEB_DIALOG_RESULT_PARAM_TO_ARRAY_MEMBER, this.to.size()))) {
+                this.to.add(results.getString(String.format(
+                        ShareConstants.WEB_DIALOG_RESULT_PARAM_TO_ARRAY_MEMBER, this.to.size())));
+            }
+        }
+
+        /**
+         * Returns the request ID.
+         * @return the request ID.
+         */
+        public String getRequestId() {
+            return requestId;
+        }
+
+        /**
+         * Returns request recipients.
+         * @return request recipients
+         */
+        public List<String> getRequestRecipients() {
+            return to;
+        }
+    }
+
+    // The actual value of the string is different since that is what the web dialog is actually
+    // called on the server.
+    private static final String GAME_REQUEST_DIALOG = "apprequests";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.GameRequest.toRequestCode();
+
+    /**
+     * Indicates whether the game request dialog can be shown.
+     *
+     * @return true if the dialog can be shown
+     */
+    public static boolean canShow() {
+        return true;
+    }
+
+    /**
+     * Shows a {@link GameRequestDialog} to send a request, using
+     * the passed in activity. No callback will be invoked.
+     *
+     * @param activity Activity hosting the dialog.
+     * @param gameRequestContent Content of the request.
+     */
+    public static void show(final Activity activity, final GameRequestContent gameRequestContent) {
+        new GameRequestDialog(activity).show(gameRequestContent);
+    }
+
+    /**
+     * Shows a {@link GameRequestDialog} to send a request, using
+     * the passed in activity. No callback will be invoked.
+     *
+     * @param fragment Fragment hosting the dialog.
+     * @param gameRequestContent Content of the request.
+     */
+    public static void show(final Fragment fragment, final GameRequestContent gameRequestContent) {
+        new GameRequestDialog(fragment).show(gameRequestContent);
+    }
+
+    /**
+     * Constructs a new RequestDialog.
+     * @param activity Activity hosting the dialog.
+     */
+    public GameRequestDialog(Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a new RequestDialog.
+     * @param fragment Fragment hosting the dialog.
+     */
+    public GameRequestDialog(Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        final ResultProcessor resultProcessor = (callback == null)
+                ? null
+                : new ResultProcessor(callback) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle results) {
+                if (results != null) {
+                    callback.onSuccess(new Result(results));
+                } else {
+                    onCancel(appCall);
+                }
+            }
+        };
+
+       callbackManager.registerCallback(
+                getRequestCode(),
+                new CallbackManagerImpl.Callback() {
+                    @Override
+                    public boolean onActivityResult(int resultCode, Intent data) {
+                        return ShareInternalUtility.handleActivityResult(
+                                getRequestCode(),
+                                resultCode,
+                                data,
+                                resultProcessor);
+                    }
+                });
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new WebHandler());
+
+        return handlers;
+    }
+
+    private class WebHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final GameRequestContent content) {
+            return true;
+        }
+
+        @Override
+        public AppCall createAppCall(final GameRequestContent content) {
+            GameRequestValidation.validate(content);
+            AppCall appCall = createBaseAppCall();
+            DialogPresenter.setupAppCallForWebDialog(
+                    appCall,
+                    GAME_REQUEST_DIALOG,
+                    WebDialogParameters.create(content));
+
+            return appCall;
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/JoinAppGroupDialog.java b/facebook/src/com/facebook/share/widget/JoinAppGroupDialog.java
new file mode 100644
index 000000000..590a1c9d3
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/JoinAppGroupDialog.java
@@ -0,0 +1,181 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogPresenter;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.share.internal.ResultProcessor;
+import com.facebook.share.internal.ShareConstants;
+import com.facebook.share.internal.ShareInternalUtility;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A dialog for joining app groups
+ */
+public class JoinAppGroupDialog extends FacebookDialogBase<String, JoinAppGroupDialog.Result> {
+
+    private static final String JOIN_GAME_GROUP_DIALOG = "game_group_join";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.AppGroupJoin.toRequestCode();
+
+    /**
+     * Helper object for handling the result from a join app group dialog.
+     */
+    public static final class Result {
+        private final Bundle data;
+
+        private Result(Bundle bundle) {
+            this.data = bundle;
+        }
+
+        /**
+         * Returns the result data from the dialog;
+         * @return the result data.
+         */
+        public Bundle getData() {
+            return data;
+        }
+    }
+
+    /**
+     * Indicates whether the join app group dialog can be shown.
+     *
+     * @return true if the dialog can be shown
+     */
+    public static boolean canShow() {
+        return true;
+    }
+
+    /**
+     * Shows an {@link JoinAppGroupDialog} to join a group with the passed in Id, using
+     * the passed in activity. No callback will be invoked.
+     *
+     * @param activity Activity hosting the dialog
+     * @param groupId Id of the group to join
+     */
+    public static void show(
+            final Activity activity,
+            final String groupId) {
+        new JoinAppGroupDialog(activity).show(groupId);
+    }
+
+    /**
+     * Shows an {@link JoinAppGroupDialog} to join a group with the passed in Id, using
+     * the passed in fragment. No callback will be invoked.
+     *
+     * @param fragment Fragment hosting the dialog
+     * @param groupId Id of the group to join
+     */
+    public static void show(
+            final Fragment fragment,
+            final String groupId) {
+        new JoinAppGroupDialog(fragment).show(groupId);
+    }
+
+    /**
+     * Constructs a JoinAppGroupDialog.
+     * @param activity Activity hosting the dialog.
+     */
+    public JoinAppGroupDialog(final Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a JoinAppGroupDialog.
+     * @param fragment Fragment hosting the dialog.
+     */
+    public JoinAppGroupDialog(final Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected void registerCallbackImpl (
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        final ResultProcessor resultProcessor = (callback == null)
+                ? null
+                : new ResultProcessor(callback) {
+            @Override
+            public void onSuccess(AppCall appCall, Bundle results) {
+                callback.onSuccess(new Result(results));
+            }
+        };
+
+        CallbackManagerImpl.Callback callbackManagerCallback = new CallbackManagerImpl.Callback() {
+            @Override
+            public boolean onActivityResult(int resultCode, Intent data) {
+                return ShareInternalUtility.handleActivityResult(
+                        getRequestCode(),
+                        resultCode,
+                        data,
+                        resultProcessor);
+            }
+        };
+
+        callbackManager.registerCallback(getRequestCode(), callbackManagerCallback);
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new WebHandler());
+
+        return handlers;
+    }
+
+    private class WebHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final String content) {
+            return true;
+        }
+
+        @Override
+        public AppCall createAppCall(final String content) {
+            AppCall appCall = createBaseAppCall();
+            Bundle params = new Bundle();
+            params.putString(ShareConstants.WEB_DIALOG_PARAM_ID, content);
+
+            DialogPresenter.setupAppCallForWebDialog(
+                    appCall,
+                    JOIN_GAME_GROUP_DIALOG,
+                    params);
+
+            return appCall;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/LikeView.java b/facebook/src/com/facebook/share/widget/LikeView.java
new file mode 100644
index 000000000..adc2a4154
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/LikeView.java
@@ -0,0 +1,843 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.facebook.FacebookException;
+import com.facebook.R;
+import com.facebook.internal.*;
+import com.facebook.share.internal.LikeActionController;
+import com.facebook.share.internal.LikeBoxCountView;
+import com.facebook.share.internal.LikeButton;
+
+/**
+ * This class provides the UI for displaying the Facebook Like button and its associated components.
+ */
+public class LikeView extends FrameLayout {
+
+    // ***
+    // Keep all the enum values in sync with attrs.xml
+    // ***
+
+    /**
+     * Encapsulates the valid values for the facebook:object_type attribute for a LikeView
+     */
+    public enum ObjectType {
+        /**
+         * This is the default value
+         */
+        UNKNOWN("unknown", 0),
+
+        /**
+         * Indicates that the object id set on this LikeView is an Open Graph object
+         */
+        OPEN_GRAPH("open_graph", 1),
+
+        /**
+         * Indicates that the object id set on this LikeView is a Page.
+         */
+        PAGE("page", 2);
+
+        public static ObjectType DEFAULT = UNKNOWN;
+
+        public static ObjectType fromInt(int enumValue) {
+            for (ObjectType objectType : values()) {
+                if (objectType.getValue() == enumValue) {
+                    return objectType;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private ObjectType(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        public int getValue() {
+            return intValue;
+        }
+    }
+
+    /**
+     * Encapsulates the valid values for the facebook:style attribute for a LikeView
+     */
+    public enum Style {
+        /**
+         * Setting the attribute to this value will display the button and a sentence near it that
+         * describes the social sentence for the associated object.
+         * <p/>
+         * This is the default value
+         */
+        STANDARD("standard", 0),
+
+        /**
+         * Setting the attribute to this value will display the button by itself, with no other
+         * components
+         */
+        BUTTON("button", 1),
+
+        /**
+         * Setting the attribute to this value will display the button and a box near it with the
+         * number of likes for the associated object
+         */
+        BOX_COUNT("box_count", 2);
+
+        static Style DEFAULT = STANDARD;
+
+        static Style fromInt(int enumValue) {
+            for (Style style : values()) {
+                if (style.getValue() == enumValue) {
+                    return style;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private Style(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    /**
+     * Encapsulates the valid values for the facebook:horizontal_alignment attribute for a LikeView.
+     */
+    public enum HorizontalAlignment {
+        /**
+         * Setting the attribute to this value will center the button and auxiliary view in the
+         * parent view.
+         * <p/>
+         * This is the default value
+         */
+        CENTER("center", 0),
+
+        /**
+         * Setting the attribute to this value will left-justify the button and auxiliary view in
+         * the parent view.
+         */
+        LEFT("left", 1),
+
+        /**
+         * Setting the attribute to this value will right-justify the button and auxiliary view in
+         * the parent view. If the facebook:auxiliary_view_position is set to INLINE, then the
+         * auxiliary view will be on the left of the button
+         */
+        RIGHT("right", 2);
+
+        static HorizontalAlignment DEFAULT = CENTER;
+
+        static HorizontalAlignment fromInt(int enumValue) {
+            for (HorizontalAlignment horizontalAlignment : values()) {
+                if (horizontalAlignment.getValue() == enumValue) {
+                    return horizontalAlignment;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private HorizontalAlignment(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    /**
+     * Encapsulates the valid values for the facebook:auxiliary_view_position attribute for a
+     * LikeView.
+     */
+    public enum AuxiliaryViewPosition {
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count below the
+         * like button. If the facebook:style is set to BUTTON, then this has no effect.
+         * <p/>
+         * This is the default value
+         */
+        BOTTOM("bottom", 0),
+
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count inline with
+         * the like button. The auxiliary view will be to the left of the button if the
+         * facebook:horizontal_alignment is set to RIGHT. In all other cases, it will be to the
+         * right of the button. If the facebook:style is set to BUTTON, then this has no effect.
+         */
+        INLINE("inline", 1),
+
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count above the
+         * like button. If the facebook:style is set to BUTTON, then this has no effect.
+         */
+        TOP("top", 2);
+
+        static AuxiliaryViewPosition DEFAULT = BOTTOM;
+
+        static AuxiliaryViewPosition fromInt(int enumValue) {
+            for (AuxiliaryViewPosition auxViewPosition : values()) {
+                if (auxViewPosition.getValue() == enumValue) {
+                    return auxViewPosition;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private AuxiliaryViewPosition(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    private static final int NO_FOREGROUND_COLOR = -1;
+
+    private String objectId;
+    private ObjectType objectType;
+    private LinearLayout containerView;
+    private LikeButton likeButton;
+    private LikeBoxCountView likeBoxCountView;
+    private TextView socialSentenceView;
+    private LikeActionController likeActionController;
+    private OnErrorListener onErrorListener;
+    private BroadcastReceiver broadcastReceiver;
+    private LikeActionControllerCreationCallback creationCallback;
+
+    private Style likeViewStyle = Style.DEFAULT;
+    private HorizontalAlignment horizontalAlignment = HorizontalAlignment.DEFAULT;
+    private AuxiliaryViewPosition auxiliaryViewPosition = AuxiliaryViewPosition.DEFAULT;
+    private int foregroundColor = NO_FOREGROUND_COLOR;
+
+    private int edgePadding;
+    private int internalPadding;
+
+    private Fragment parentFragment;
+
+    private boolean explicitlyDisabled;
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public LikeView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     * @param attrs   AttributeSet for this View.
+     */
+    public LikeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        parseAttributes(attrs);
+        initialize(context);
+    }
+
+    /**
+     * Sets the associated object ID for this LikeView. Can be changed during runtime.
+     * @param objectId The object ID, this can be a URL or a Facebook ID.
+     */
+    public void setObjectIdAndType(String objectId, ObjectType objectType) {
+        objectId = Utility.coerceValueIfNullOrEmpty(objectId, null);
+        objectType = objectType != null ? objectType : ObjectType.DEFAULT;
+
+        if (!Utility.areObjectsEqual(objectId, this.objectId) || (objectType != this.objectType)) {
+            setObjectIdAndTypeForced(objectId, objectType);
+
+            updateLikeStateAndLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:style for this LikeView. Can be changed during runtime.
+     *
+     * @param likeViewStyle Should be either LikeView.STANDARD, LikeView.BUTTON or
+     *                      LikeView.BOX_COUNT
+     */
+    public void setLikeViewStyle(Style likeViewStyle) {
+        likeViewStyle = likeViewStyle != null ? likeViewStyle : Style.DEFAULT;
+        if (this.likeViewStyle != likeViewStyle) {
+            this.likeViewStyle = likeViewStyle;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:auxiliary_view_position for this LikeView. Can be changed during runtime.
+     *
+     * @param auxiliaryViewPosition Should be either LikeView.TOP, LikeView.INLINE or
+     *                              LikeView.BOTTOM
+     */
+    public void setAuxiliaryViewPosition(AuxiliaryViewPosition auxiliaryViewPosition) {
+        auxiliaryViewPosition = auxiliaryViewPosition != null
+                ? auxiliaryViewPosition : AuxiliaryViewPosition.DEFAULT;
+        if (this.auxiliaryViewPosition != auxiliaryViewPosition) {
+            this.auxiliaryViewPosition = auxiliaryViewPosition;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:horizontal_alignment for this LikeView. Can be changed during runtime.
+     *
+     * @param horizontalAlignment Should be either LikeView.LEFT, LikeView.CENTER or LikeView.RIGHT
+     */
+    public void setHorizontalAlignment(HorizontalAlignment horizontalAlignment) {
+        horizontalAlignment = horizontalAlignment != null
+                ? horizontalAlignment : HorizontalAlignment.DEFAULT;
+        if (this.horizontalAlignment != horizontalAlignment) {
+            this.horizontalAlignment = horizontalAlignment;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:foreground_color for this LikeView. Can be changed during runtime. The
+     * color is only used for the social sentence text.
+     *
+     * @param foregroundColor And valid android.graphics.Color value.
+     */
+    public void setForegroundColor(int foregroundColor) {
+        if (this.foregroundColor != foregroundColor) {
+            socialSentenceView.setTextColor(foregroundColor);
+        }
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of LikeView to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of LikeView.
+     *
+     * @return The OnErrorListener
+     */
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    /**
+     * Sets the parent Fragment which is hosting this LikeView. This allows the LikeView to be
+     * embedded inside a Fragment, and will allow the fragment to receive the
+     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
+     * call rather than the Activity, upon completion of Likes from this view.
+     *
+     * @param fragment Fragment that is hosting the LikeView.
+     */
+    public void setFragment(Fragment fragment) {
+        this.parentFragment = fragment;
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        explicitlyDisabled = !enabled;
+
+        updateLikeStateAndLayout();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        // Disassociate from the object
+        setObjectIdAndType(null, ObjectType.UNKNOWN);
+
+        super.onDetachedFromWindow();
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        if (attrs == null || getContext() == null) {
+            return;
+        }
+
+        TypedArray a = getContext().obtainStyledAttributes(
+                attrs, R.styleable.com_facebook_like_view);
+        if (a == null) {
+            return;
+        }
+
+        objectId = Utility.coerceValueIfNullOrEmpty(
+                a.getString(R.styleable.com_facebook_like_view_com_facebook_object_id), null);
+        objectType = ObjectType.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_com_facebook_object_type,
+                        ObjectType.DEFAULT.getValue()));
+        likeViewStyle = Style.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_com_facebook_style,
+                        Style.DEFAULT.getValue()));
+        if (likeViewStyle == null) {
+            throw new IllegalArgumentException("Unsupported value for LikeView 'style'");
+        }
+
+        auxiliaryViewPosition = AuxiliaryViewPosition.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_com_facebook_auxiliary_view_position,
+                        AuxiliaryViewPosition.DEFAULT.getValue()));
+        if (auxiliaryViewPosition == null) {
+            throw new IllegalArgumentException(
+                    "Unsupported value for LikeView 'auxiliary_view_position'");
+        }
+
+        horizontalAlignment = HorizontalAlignment.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_com_facebook_horizontal_alignment,
+                        HorizontalAlignment.DEFAULT.getValue()));
+        if (horizontalAlignment == null) {
+            throw new IllegalArgumentException(
+                    "Unsupported value for LikeView 'horizontal_alignment'");
+        }
+
+        foregroundColor = a.getColor(
+                R.styleable.com_facebook_like_view_com_facebook_foreground_color, NO_FOREGROUND_COLOR);
+
+        a.recycle();
+    }
+
+    // If attributes were present, parseAttributes MUST be called before initialize() to ensure
+    // proper behavior
+    private void initialize(Context context) {
+        edgePadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeview_edge_padding);
+        internalPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeview_internal_padding);
+        if (foregroundColor == NO_FOREGROUND_COLOR) {
+            foregroundColor = getResources().getColor(R.color.com_facebook_likeview_text_color);
+        }
+
+        setBackgroundColor(Color.TRANSPARENT);
+
+        containerView = new LinearLayout(context);
+        LayoutParams containerViewLayoutParams = new LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.WRAP_CONTENT);
+        containerView.setLayoutParams(containerViewLayoutParams);
+
+        initializeLikeButton(context);
+        initializeSocialSentenceView(context);
+        initializeLikeCountView(context);
+
+        containerView.addView(likeButton);
+        containerView.addView(socialSentenceView);
+        containerView.addView(likeBoxCountView);
+
+        addView(containerView);
+
+        setObjectIdAndTypeForced(this.objectId, this.objectType);
+        updateLikeStateAndLayout();
+    }
+
+    private void initializeLikeButton(Context context) {
+        likeButton = new LikeButton(
+                context,
+                likeActionController != null && likeActionController.isObjectLiked());
+        likeButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                toggleLike();
+            }
+        });
+
+        LinearLayout.LayoutParams buttonLayout = new LinearLayout.LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.WRAP_CONTENT);
+
+        likeButton.setLayoutParams(buttonLayout);
+    }
+
+    private void initializeSocialSentenceView(Context context) {
+        socialSentenceView = new TextView(context);
+        socialSentenceView.setTextSize(
+                TypedValue.COMPLEX_UNIT_PX,
+                getResources().getDimension(R.dimen.com_facebook_likeview_text_size));
+        socialSentenceView.setMaxLines(2);
+        socialSentenceView.setTextColor(foregroundColor);
+        socialSentenceView.setGravity(Gravity.CENTER);
+
+        LinearLayout.LayoutParams socialSentenceViewLayout = new LinearLayout.LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.MATCH_PARENT);
+        socialSentenceView.setLayoutParams(socialSentenceViewLayout);
+    }
+
+    private void initializeLikeCountView(Context context) {
+        likeBoxCountView = new LikeBoxCountView(context);
+
+        LinearLayout.LayoutParams likeCountViewLayout = new LinearLayout.LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+        likeBoxCountView.setLayoutParams(likeCountViewLayout);
+    }
+
+    private void toggleLike() {
+        if (likeActionController != null) {
+            Activity activity = null;
+            if (parentFragment == null) {
+                Context context = getContext();
+                if (context instanceof Activity) {
+                    activity = (Activity) context;
+                } else if (context instanceof ContextWrapper) {
+                    Context baseContext = ((ContextWrapper) context).getBaseContext();
+                    if (baseContext instanceof Activity) {
+                        activity = (Activity) baseContext;
+                    }
+                }
+            }
+
+            likeActionController.toggleLike(
+                    activity,
+                    parentFragment,
+                    getAnalyticsParameters());
+        }
+    }
+
+    private Bundle getAnalyticsParameters() {
+        Bundle params = new Bundle();
+        params.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_STYLE, likeViewStyle.toString());
+        params.putString(
+                AnalyticsEvents.PARAMETER_LIKE_VIEW_AUXILIARY_POSITION,
+                auxiliaryViewPosition.toString());
+        params.putString(
+                AnalyticsEvents.PARAMETER_LIKE_VIEW_HORIZONTAL_ALIGNMENT,
+                horizontalAlignment.toString());
+        params.putString(
+                AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_ID,
+                Utility.coerceValueIfNullOrEmpty(objectId, ""));
+        params.putString(
+                AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_TYPE,
+                objectType.toString());
+
+        return params;
+    }
+
+    private void setObjectIdAndTypeForced(String newObjectId, ObjectType newObjectType) {
+        tearDownObjectAssociations();
+
+        objectId = newObjectId;
+        objectType = newObjectType;
+
+        if (Utility.isNullOrEmpty(newObjectId)) {
+            return;
+        }
+
+        creationCallback = new LikeActionControllerCreationCallback();
+        LikeActionController.getControllerForObjectId(
+                newObjectId,
+                newObjectType,
+                creationCallback);
+    }
+
+    private void associateWithLikeActionController(LikeActionController likeActionController) {
+        this.likeActionController = likeActionController;
+
+        this.broadcastReceiver = new LikeControllerBroadcastReceiver();
+        LocalBroadcastManager localBroadcastManager =
+                LocalBroadcastManager.getInstance(getContext());
+
+        // add the broadcast receiver
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_UPDATED);
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR);
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_RESET);
+
+        localBroadcastManager.registerReceiver(broadcastReceiver, filter);
+    }
+
+    private void tearDownObjectAssociations() {
+        if (broadcastReceiver != null) {
+            LocalBroadcastManager localBroadcastManager =
+                    LocalBroadcastManager.getInstance(getContext());
+            localBroadcastManager.unregisterReceiver(broadcastReceiver);
+
+            broadcastReceiver = null;
+        }
+
+        // If we were already waiting on a controller to be given back, make sure we aren't waiting
+        // anymore. Otherwise when that controller is given back to the callback, it will go and
+        // register a broadcast receiver for it.
+        if (creationCallback != null) {
+            creationCallback.cancel();
+
+            creationCallback = null;
+        }
+
+        likeActionController = null;
+    }
+
+    private void updateLikeStateAndLayout() {
+        boolean enabled = !explicitlyDisabled;
+
+        if (likeActionController == null) {
+            likeButton.setSelected(false);
+            socialSentenceView.setText(null);
+            likeBoxCountView.setText(null);
+        } else {
+            likeButton.setSelected(likeActionController.isObjectLiked());
+            socialSentenceView.setText(likeActionController.getSocialSentence());
+            likeBoxCountView.setText(likeActionController.getLikeCountString());
+
+            enabled &= likeActionController.shouldEnableView();
+        }
+
+        super.setEnabled(enabled);
+        likeButton.setEnabled(enabled);
+
+        updateLayout();
+    }
+
+    private void updateLayout() {
+        // Make sure the container is horizontally aligned according to specifications.
+        LayoutParams containerViewLayoutParams = (LayoutParams)containerView.getLayoutParams();
+        LinearLayout.LayoutParams buttonLayoutParams =
+                (LinearLayout.LayoutParams)likeButton.getLayoutParams();
+        int viewGravity =
+                horizontalAlignment == HorizontalAlignment.LEFT ? Gravity.LEFT :
+                        horizontalAlignment == HorizontalAlignment.CENTER
+                                ? Gravity.CENTER_HORIZONTAL : Gravity.RIGHT;
+
+        containerViewLayoutParams.gravity = viewGravity | Gravity.TOP;
+        buttonLayoutParams.gravity = viewGravity;
+
+        // Choose the right auxiliary view to make visible.
+        socialSentenceView.setVisibility(GONE);
+        likeBoxCountView.setVisibility(GONE);
+
+        View auxView;
+        if (likeViewStyle == Style.STANDARD &&
+                likeActionController != null &&
+                !Utility.isNullOrEmpty(likeActionController.getSocialSentence())) {
+            auxView = socialSentenceView;
+        } else if (likeViewStyle == Style.BOX_COUNT &&
+                likeActionController != null &&
+                !Utility.isNullOrEmpty(likeActionController.getLikeCountString())) {
+            updateBoxCountCaretPosition();
+            auxView = likeBoxCountView;
+        } else {
+            // No more work to be done.
+            return;
+        }
+        auxView.setVisibility(VISIBLE);
+
+        // Now position the auxiliary view properly
+        LinearLayout.LayoutParams auxViewLayoutParams =
+                (LinearLayout.LayoutParams)auxView.getLayoutParams();
+        auxViewLayoutParams.gravity = viewGravity;
+
+        containerView.setOrientation(
+                auxiliaryViewPosition == AuxiliaryViewPosition.INLINE ?
+                        LinearLayout.HORIZONTAL :
+                        LinearLayout.VERTICAL);
+
+        if (auxiliaryViewPosition == AuxiliaryViewPosition.TOP ||
+                (auxiliaryViewPosition == AuxiliaryViewPosition.INLINE &&
+                        horizontalAlignment == HorizontalAlignment.RIGHT)) {
+            // Button comes after the auxiliary view. Make sure it is at the end
+            containerView.removeView(likeButton);
+            containerView.addView(likeButton);
+        } else {
+            // In all other cases, the button comes first
+            containerView.removeView(auxView);
+            containerView.addView(auxView);
+        }
+
+        switch (auxiliaryViewPosition) {
+            case TOP:
+                auxView.setPadding(edgePadding, edgePadding, edgePadding, internalPadding);
+                break;
+            case BOTTOM:
+                auxView.setPadding(edgePadding, internalPadding, edgePadding, edgePadding);
+                break;
+            case INLINE:
+                if (horizontalAlignment == HorizontalAlignment.RIGHT) {
+                    auxView.setPadding(edgePadding, edgePadding, internalPadding, edgePadding);
+                } else {
+                    auxView.setPadding(internalPadding, edgePadding, edgePadding, edgePadding);
+                }
+                break;
+        }
+    }
+
+    private void updateBoxCountCaretPosition() {
+        switch (auxiliaryViewPosition) {
+            case TOP:
+                likeBoxCountView.setCaretPosition(
+                        LikeBoxCountView.LikeBoxCountViewCaretPosition.BOTTOM);
+                break;
+            case BOTTOM:
+                likeBoxCountView.setCaretPosition(
+                        LikeBoxCountView.LikeBoxCountViewCaretPosition.TOP);
+                break;
+            case INLINE:
+                likeBoxCountView.setCaretPosition(
+                        horizontalAlignment == HorizontalAlignment.RIGHT ?
+                                LikeBoxCountView.LikeBoxCountViewCaretPosition.RIGHT :
+                                LikeBoxCountView.LikeBoxCountViewCaretPosition.LEFT);
+                break;
+        }
+    }
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while logging in.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when the share action encounters an error.
+         * @param error The error that occurred
+         */
+        public void onError(FacebookException error);
+    }
+
+    private class LikeControllerBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String intentAction = intent.getAction();
+            Bundle extras = intent.getExtras();
+            boolean shouldRespond = true;
+            if (extras != null) {
+                // See if an Id was set in the broadcast Intent. If it was, treat it as a filter.
+                String broadcastObjectId = extras.getString(
+                        LikeActionController.ACTION_OBJECT_ID_KEY);
+                shouldRespond = Utility.isNullOrEmpty(broadcastObjectId) ||
+                        Utility.areObjectsEqual(objectId, broadcastObjectId);
+            }
+
+            if (!shouldRespond) {
+                return;
+            }
+
+            if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_UPDATED.equals(intentAction)) {
+                updateLikeStateAndLayout();
+            } else if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR.equals(
+                    intentAction)) {
+                if (onErrorListener != null) {
+                    onErrorListener.onError(NativeProtocol.getExceptionFromErrorData(extras));
+                }
+            } else if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_RESET.equals(
+                    intentAction)) {
+                // This will recreate the controller and associated objects
+                setObjectIdAndTypeForced(objectId, objectType);
+                updateLikeStateAndLayout();
+            }
+        }
+    }
+
+    private class LikeActionControllerCreationCallback
+            implements LikeActionController.CreationCallback {
+        private boolean isCancelled;
+
+        public void cancel() {
+            isCancelled = true;
+        }
+
+        @Override
+        public void onComplete(
+                LikeActionController likeActionController,
+                FacebookException error) {
+            if (isCancelled) {
+                return;
+            }
+
+            if (likeActionController != null) {
+                if (!likeActionController.shouldEnableView()) {
+                    error = new FacebookException(
+                            "Cannot use LikeView. The device may not be supported.");
+                }
+
+                // Always associate with the controller, so it can get updates if the view gets
+                // enabled again.
+                associateWithLikeActionController(likeActionController);
+                updateLikeStateAndLayout();
+            }
+
+            if (error != null) {
+                if (onErrorListener != null) {
+                    onErrorListener.onError(error);
+                }
+            }
+
+            LikeView.this.creationCallback = null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/MessageDialog.java b/facebook/src/com/facebook/share/widget/MessageDialog.java
new file mode 100644
index 000000000..a6081cf84
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/MessageDialog.java
@@ -0,0 +1,213 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookCallback;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.DialogPresenter;
+import com.facebook.share.Sharer;
+import com.facebook.share.internal.LegacyNativeDialogParameters;
+import com.facebook.share.internal.MessageDialogFeature;
+import com.facebook.share.internal.NativeDialogParameters;
+import com.facebook.share.internal.OpenGraphMessageDialogFeature;
+import com.facebook.share.internal.ShareContentValidation;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.model.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides functionality to send content via the Facebook Message Dialog
+ */
+public final class MessageDialog
+        extends FacebookDialogBase<ShareContent, Sharer.Result>
+        implements Sharer {
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Message.toRequestCode();
+
+    private boolean shouldFailOnDataError = false;
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.ShareContent} using the provided
+     * Activity. No callback will be invoked.
+     *
+     * @param activity Activity to use to send the provided content
+     * @param shareContent Content to send
+     */
+    public static void show(
+            final Activity activity,
+            final ShareContent shareContent) {
+        new MessageDialog(activity).show(shareContent);
+    }
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.ShareContent} using the provided
+     * Fragment. No callback will be invoked.
+     *
+     * @param fragment Fragment to use to send the provided content
+     * @param shareContent Content to send
+     */
+    public static void show(
+            final Fragment fragment,
+            final ShareContent shareContent) {
+        new MessageDialog(fragment).show(shareContent);
+    }
+
+    /**
+     * Indicates whether it is possible to show the dialog for
+     * {@link com.facebook.share.model.ShareContent} of the specified type.
+     *
+     * @param contentType Class of the intended {@link com.facebook.share.model.ShareContent} to
+     *                    send.
+     * @return True if the specified content type can be shown via the dialog
+     */
+    public static boolean canShow(Class<? extends ShareContent> contentType) {
+        DialogFeature feature = getFeature(contentType);
+
+        return feature != null && DialogPresenter.canPresentNativeDialogWithFeature(feature);
+    }
+
+    /**
+     * Constructs a MessageDialog.
+     * @param activity Activity to use to send the provided content.
+     */
+    public MessageDialog(Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+
+        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a MessageDialog.
+     * @param fragment Fragment to use to send the provided content.
+     */
+    public MessageDialog(Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+
+        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
+    }
+
+    // for SendButton use only
+    MessageDialog(Activity activity, int requestCode) {
+        super(activity, requestCode);
+
+        ShareInternalUtility.registerStaticShareCallback(requestCode);
+    }
+
+    // for SendButton use only
+    MessageDialog(Fragment fragment, int requestCode) {
+        super(fragment, requestCode);
+
+        ShareInternalUtility.registerStaticShareCallback(requestCode);
+    }
+
+    @Override
+    protected void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        ShareInternalUtility.registerSharerCallback(getRequestCode(), callbackManager, callback);
+    }
+
+    @Override
+    public boolean getShouldFailOnDataError() {
+        return this.shouldFailOnDataError;
+    }
+
+    @Override
+    public void setShouldFailOnDataError(boolean shouldFailOnDataError) {
+        this.shouldFailOnDataError = shouldFailOnDataError;
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new NativeHandler());
+
+        return handlers;
+    }
+
+    private class NativeHandler extends ModeHandler {
+        @Override
+        public boolean canShow(final ShareContent shareContent) {
+            return shareContent != null && MessageDialog.canShow(shareContent.getClass());
+        }
+
+        @Override
+        public AppCall createAppCall(final ShareContent content) {
+            ShareContentValidation.validateForMessage(content);
+
+            final AppCall appCall = createBaseAppCall();
+            final boolean shouldFailOnDataError = getShouldFailOnDataError();
+            final Activity activity = getActivityContext();
+
+            DialogPresenter.setupAppCallForNativeDialog(
+                    appCall,
+                    new DialogPresenter.ParameterProvider() {
+                        @Override
+                        public Bundle getParameters() {
+                            return NativeDialogParameters.create(
+                                    appCall.getCallId(),
+                                    content,
+                                    shouldFailOnDataError);
+                        }
+
+                        @Override
+                        public Bundle getLegacyParameters() {
+                            return LegacyNativeDialogParameters.create(
+                                    appCall.getCallId(),
+                                    content,
+                                    shouldFailOnDataError);
+                        }
+                    },
+                    getFeature(content.getClass()));
+
+            return appCall;
+        }
+    }
+
+    private static DialogFeature getFeature(
+            Class<? extends ShareContent> contentType) {
+        if (ShareLinkContent.class.isAssignableFrom(contentType)) {
+            return MessageDialogFeature.MESSAGE_DIALOG;
+        } else if (SharePhotoContent.class.isAssignableFrom(contentType)) {
+            return MessageDialogFeature.PHOTOS;
+        } else if (ShareVideoContent.class.isAssignableFrom(contentType)) {
+            return MessageDialogFeature.VIDEO;
+        } else if (ShareOpenGraphContent.class.isAssignableFrom(contentType)) {
+            return OpenGraphMessageDialogFeature.OG_MESSAGE_DIALOG;
+        }
+        return null;
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/SendButton.java b/facebook/src/com/facebook/share/widget/SendButton.java
new file mode 100644
index 000000000..fb4d51e7b
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/SendButton.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.facebook.R;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.CallbackManagerImpl;
+
+/**
+ * A button to share content through Messenger.
+ * Tapping the receiver will invoke the {@link com.facebook.share.widget.MessageDialog} with the attached shareContent.
+ */
+public final class SendButton extends ShareButtonBase {
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Message.toRequestCode();
+
+    public SendButton(final Context context) {
+        super(context, null, 0, AnalyticsEvents.EVENT_SEND_BUTTON_CREATE, DEFAULT_REQUEST_CODE);
+    }
+
+    public SendButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs, 0, AnalyticsEvents.EVENT_SEND_BUTTON_CREATE, DEFAULT_REQUEST_CODE);
+    }
+
+    public SendButton(final Context context, final AttributeSet attrs, final int defStyleAttr) {
+        super(
+                context,
+                attrs,
+                defStyleAttr,
+                AnalyticsEvents.EVENT_SEND_BUTTON_CREATE,
+                DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected int getDefaultStyleResource() {
+        return R.style.com_facebook_button_send;
+    }
+
+    @Override
+    protected OnClickListener getShareOnClickListener()  {
+        return new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                final MessageDialog dialog;
+                if (SendButton.this.getFragment() != null) {
+                    dialog = new MessageDialog(SendButton.this.getFragment() , getRequestCode());
+                } else {
+                    dialog = new MessageDialog(getActivity(), getRequestCode());
+                }
+                dialog.show(SendButton.this.getShareContent());
+                callExternalOnClickListener(v);
+            }
+        };
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/ShareButton.java b/facebook/src/com/facebook/share/widget/ShareButton.java
new file mode 100644
index 000000000..393ec7582
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/ShareButton.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.facebook.R;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.CallbackManagerImpl;
+
+/**
+ * A button to share content on Facebook.
+ * Tapping the receiver will invoke the {@link com.facebook.share.widget.ShareDialog} with the attached shareContent.
+ */
+public final class ShareButton extends ShareButtonBase {
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Share.toRequestCode();
+
+    public ShareButton(final Context context) {
+        super(context, null, 0, AnalyticsEvents.EVENT_SHARE_BUTTON_CREATE, DEFAULT_REQUEST_CODE);
+    }
+
+    public ShareButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs, 0, AnalyticsEvents.EVENT_SHARE_BUTTON_CREATE, DEFAULT_REQUEST_CODE);
+    }
+
+    public ShareButton(final Context context, final AttributeSet attrs, final int defStyleAttr) {
+        super(
+                context,
+                attrs,
+                defStyleAttr,
+                AnalyticsEvents.EVENT_SHARE_BUTTON_CREATE,
+                DEFAULT_REQUEST_CODE);
+    }
+
+    @Override
+    protected int getDefaultStyleResource() {
+        return R.style.com_facebook_button_share;
+    }
+
+    @Override
+    protected OnClickListener getShareOnClickListener()  {
+        return new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                final ShareDialog dialog;
+                if (ShareButton.this.getFragment() != null) {
+                    dialog = new ShareDialog(ShareButton.this.getFragment() , getRequestCode());
+                } else {
+                    dialog = new ShareDialog(getActivity(), getRequestCode());
+                }
+                dialog.show(ShareButton.this.getShareContent());
+                callExternalOnClickListener(v);
+            }
+        };
+    }
+}
diff --git a/facebook/src/com/facebook/share/widget/ShareButtonBase.java b/facebook/src/com/facebook/share/widget/ShareButtonBase.java
new file mode 100644
index 000000000..8e27530f3
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/ShareButtonBase.java
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.content.Context;
+import android.util.AttributeSet;
+
+import com.facebook.CallbackManager;
+import com.facebook.FacebookButtonBase;
+import com.facebook.FacebookCallback;
+import com.facebook.share.Sharer;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.model.ShareContent;
+
+/**
+ * A base class for sharing buttons.
+ */
+public abstract class ShareButtonBase extends FacebookButtonBase {
+    private ShareContent shareContent;
+
+    protected ShareButtonBase(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final String analyticsButtonCreatedEventName,
+            final int requestCode) {
+        super(
+                context,
+                attrs,
+                defStyleAttr,
+                0,
+                analyticsButtonCreatedEventName,
+                requestCode);
+    }
+
+    /**
+     * Returns the share content from the button.
+     * @return The share content.
+     */
+    public ShareContent getShareContent() {
+        return this.shareContent;
+    }
+
+    /**
+     * Sets the share content on the button.
+     * @param shareContent The share content.
+     */
+    public void setShareContent(final ShareContent shareContent) {
+        this.shareContent = shareContent;
+    }
+
+    /**
+     * Allows registration of a callback for when the share completes. This should be called
+     * in the {@link android.app.Activity#onCreate(android.os.Bundle)} or
+     * {@link android.support.v4.app.Fragment#onCreate(android.os.Bundle)} methods.
+     *
+     * @param callbackManager The {@link com.facebook.CallbackManager} instance that will be
+     *                        handling results that are received via
+     *                        {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
+     * @param callback The callback that should be called to handle dialog completion.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<Sharer.Result> callback) {
+        ShareInternalUtility.registerSharerCallback(getRequestCode(), callbackManager, callback);
+    }
+
+    /**
+     * Allows registration of a callback for when the share completes. This should be called
+     * in the {@link android.app.Activity#onCreate(android.os.Bundle)} or
+     * {@link android.support.v4.app.Fragment#onCreate(android.os.Bundle)} methods.
+     *
+     * @param callbackManager The {@link com.facebook.CallbackManager} instance that will be
+     *                        handling results that are received via
+     *                        {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
+     * @param callback The callback that should be called to handle dialog completion.
+     * @param requestCode  The request code to use, this should be outside of the range of those
+     *                     reserved for the Facebook SDK
+     *                     {@link com.facebook.FacebookSdk#isFacebookRequestCode(int)}.
+     */
+    public void registerCallback(
+            final CallbackManager callbackManager,
+            final FacebookCallback<Sharer.Result> callback,
+            final int requestCode) {
+        setRequestCode(requestCode);
+        registerCallback(callbackManager, callback);
+    }
+
+    @Override
+    protected void configureButton(
+            final Context context,
+            final AttributeSet attrs,
+            final int defStyleAttr,
+            final int defStyleRes) {
+        super.configureButton(context, attrs, defStyleAttr, defStyleRes);
+        setInternalOnClickListener(this.getShareOnClickListener());
+    }
+
+    abstract protected OnClickListener getShareOnClickListener();
+}
diff --git a/facebook/src/com/facebook/share/widget/ShareDialog.java b/facebook/src/com/facebook/share/widget/ShareDialog.java
new file mode 100644
index 000000000..733a14d67
--- /dev/null
+++ b/facebook/src/com/facebook/share/widget/ShareDialog.java
@@ -0,0 +1,413 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.share.widget;
+
+import android.app.Activity;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.internal.AnalyticsEvents;
+import com.facebook.internal.AppCall;
+import com.facebook.internal.CallbackManagerImpl;
+import com.facebook.internal.DialogFeature;
+import com.facebook.internal.DialogPresenter;
+import com.facebook.internal.FacebookDialogBase;
+import com.facebook.internal.Utility;
+import com.facebook.share.Sharer;
+import com.facebook.share.internal.LegacyNativeDialogParameters;
+import com.facebook.share.internal.NativeDialogParameters;
+import com.facebook.share.internal.OpenGraphActionDialogFeature;
+import com.facebook.share.internal.ShareContentValidation;
+import com.facebook.share.internal.ShareDialogFeature;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.internal.WebDialogParameters;
+import com.facebook.share.model.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides functionality to share content via the Facebook Share Dialog
+ */
+public final class ShareDialog
+        extends FacebookDialogBase<ShareContent, Sharer.Result>
+        implements Sharer {
+
+    /**
+     * The mode for the share dialog.
+     */
+    public enum Mode {
+        /**
+         * The mode is determined automatically.
+         */
+        AUTOMATIC,
+        /**
+         * The native dialog is used.
+         */
+        NATIVE,
+        /**
+         * The web dialog is used.
+         */
+        WEB,
+        /**
+         * The feed dialog is used.
+         */
+        FEED
+    }
+
+    private static final String FEED_DIALOG = "feed";
+    private static final String WEB_SHARE_DIALOG = "share";
+    private static final String WEB_OG_SHARE_DIALOG = "share_open_graph";
+
+    private static final int DEFAULT_REQUEST_CODE =
+            CallbackManagerImpl.RequestCodeOffset.Share.toRequestCode();
+
+    private  boolean shouldFailOnDataError = false;
+    // Keep track of Mode overrides for logging purposes.
+    private boolean isAutomaticMode = true;
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.ShareContent} using the provided
+     * Activity. No callback will be invoked.
+     *
+     * @param activity Activity to use to share the provided content
+     * @param shareContent Content to share
+     */
+    public static void show(
+            final Activity activity,
+            final ShareContent shareContent) {
+        new ShareDialog(activity).show(shareContent);
+    }
+
+    /**
+     * Helper to show the provided {@link com.facebook.share.model.ShareContent} using the provided
+     * Fragment. No callback will be invoked.
+     *
+     * @param fragment Fragment to use to share the provided content
+     * @param shareContent Content to share
+     */
+    public static void show(
+            final Fragment fragment,
+            final ShareContent shareContent) {
+        new ShareDialog(fragment).show(shareContent);
+    }
+
+    /**
+     * Indicates whether it is possible to show the dialog for
+     * {@link com.facebook.share.model.ShareContent} of the specified type.
+     *
+     * @param contentType Class of the intended {@link com.facebook.share.model.ShareContent} to
+     *                    share.
+     * @return True if the specified content type can be shown via the dialog
+     */
+    public static boolean canShow(Class<? extends ShareContent> contentType) {
+        return canShowWebTypeCheck(contentType) || canShowNative(contentType);
+    }
+
+    private static boolean canShowNative(Class<? extends ShareContent> contentType) {
+        DialogFeature feature = getFeature(contentType);
+
+        return feature != null && DialogPresenter.canPresentNativeDialogWithFeature(feature);
+    }
+
+    private static boolean canShowWebTypeCheck(Class<? extends ShareContent> contentType) {
+        // If we don't have an instance of a ShareContent, then all we can do is check whether
+        // this is a ShareLinkContent, which can be shared if configured properly.
+        // The instance method version of this check is more accurate and should be used on
+        // ShareDialog instances.
+
+        return ShareLinkContent.class.isAssignableFrom(contentType)
+                || ShareOpenGraphContent.class.isAssignableFrom(contentType);
+    }
+
+    /**
+     * Constructs a new ShareDialog.
+     * @param activity Activity to use to share the provided content.
+     */
+    public ShareDialog(Activity activity) {
+        super(activity, DEFAULT_REQUEST_CODE);
+
+        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
+    }
+
+    /**
+     * Constructs a new ShareDialog.
+     * @param fragment Fragment to use to share the provided content.
+     */
+    public ShareDialog(Fragment fragment) {
+        super(fragment, DEFAULT_REQUEST_CODE);
+
+        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
+    }
+
+    // for ShareDialog use only
+    ShareDialog(Activity activity, int requestCode) {
+        super(activity, requestCode);
+
+        ShareInternalUtility.registerStaticShareCallback(requestCode);
+    }
+
+    // for ShareDialog use only
+    ShareDialog(Fragment fragment, int requestCode) {
+        super(fragment, requestCode);
+
+        ShareInternalUtility.registerStaticShareCallback(requestCode);
+    }
+
+    @Override
+    protected void registerCallbackImpl(
+            final CallbackManagerImpl callbackManager,
+            final FacebookCallback<Result> callback) {
+        ShareInternalUtility.registerSharerCallback(
+                getRequestCode(), callbackManager, callback);
+    }
+
+    @Override
+    public boolean getShouldFailOnDataError() {
+        return this.shouldFailOnDataError;
+    }
+
+    @Override
+    public void setShouldFailOnDataError(boolean shouldFailOnDataError) {
+        this.shouldFailOnDataError = shouldFailOnDataError;
+    }
+
+    /**
+     * Call this to check if the Share Dialog can be shown in a specific mode.
+     *
+     * @param mode Mode of the Share Dialog
+     * @return True if the dialog can be shown in the passed in Mode
+     */
+    public boolean canShow(ShareContent content, Mode mode) {
+        return canShowImpl(content, (mode == Mode.AUTOMATIC) ? BASE_AUTOMATIC_MODE : mode);
+    }
+
+    /**
+     * Call this to show the Share Dialog in a specific mode
+     * @param mode Mode of the Share Dialog
+     */
+    public void show(ShareContent content, Mode mode) {
+        isAutomaticMode = (mode == Mode.AUTOMATIC);
+
+        showImpl(content, isAutomaticMode ? BASE_AUTOMATIC_MODE : mode);
+    }
+
+    @Override
+    protected AppCall createBaseAppCall() {
+        return new AppCall(getRequestCode());
+    }
+
+    @Override
+    protected List<ModeHandler> getOrderedModeHandlers() {
+        ArrayList<ModeHandler> handlers = new ArrayList<>();
+        handlers.add(new NativeHandler());
+        handlers.add(new FeedHandler()); // Feed takes precedence for link-shares for Mode.AUTOMATIC
+        handlers.add(new WebShareHandler());
+
+        return handlers;
+    }
+
+    private class NativeHandler extends ModeHandler {
+        @Override
+        public Object getMode() {
+            return Mode.NATIVE;
+        }
+
+        @Override
+        public boolean canShow(final ShareContent content) {
+            return content != null && ShareDialog.canShowNative(content.getClass());
+        }
+
+        @Override
+        public AppCall createAppCall(final ShareContent content) {
+            logDialogShare(getActivityContext(), content, Mode.NATIVE);
+
+            ShareContentValidation.validateForNativeShare(content);
+
+            final AppCall appCall = createBaseAppCall();
+            final boolean shouldFailOnDataError = getShouldFailOnDataError();
+
+            DialogPresenter.setupAppCallForNativeDialog(
+                    appCall,
+                    new DialogPresenter.ParameterProvider() {
+                        @Override
+                        public Bundle getParameters() {
+                            return NativeDialogParameters.create(
+                                    appCall.getCallId(),
+                                    content,
+                                    shouldFailOnDataError);
+                        }
+
+                        @Override
+                        public Bundle getLegacyParameters() {
+                            return LegacyNativeDialogParameters.create(
+                                    appCall.getCallId(),
+                                    content,
+                                    shouldFailOnDataError);
+                        }
+                    },
+                    getFeature(content.getClass()));
+
+            return appCall;
+        }
+    }
+
+    private class WebShareHandler extends ModeHandler {
+        @Override
+        public Object getMode() {
+            return Mode.WEB;
+        }
+
+        @Override
+        public boolean canShow(final ShareContent content) {
+            return (content != null) && ShareDialog.canShowWebTypeCheck(content.getClass());
+        }
+
+        @Override
+        public AppCall createAppCall(final ShareContent content) {
+            logDialogShare(getActivityContext(), content, Mode.WEB);
+
+            final AppCall appCall = createBaseAppCall();
+
+            ShareContentValidation.validateForWebShare(content);
+
+            Bundle params;
+            if (content instanceof ShareLinkContent) {
+                params = WebDialogParameters.create((ShareLinkContent)content);
+            } else {
+                params = WebDialogParameters.create((ShareOpenGraphContent)content);
+            }
+
+            DialogPresenter.setupAppCallForWebDialog(
+                    appCall,
+                    getActionName(content),
+                    params);
+
+            return appCall;
+        }
+
+        private String getActionName(ShareContent shareContent) {
+            if (shareContent instanceof ShareLinkContent) {
+                return WEB_SHARE_DIALOG;
+            } else if (shareContent instanceof ShareOpenGraphContent) {
+                return WEB_OG_SHARE_DIALOG;
+            }
+
+            return null;
+        }
+    }
+
+    private class FeedHandler extends ModeHandler {
+        @Override
+        public Object getMode() {
+            return Mode.FEED;
+        }
+
+        @Override
+        public boolean canShow(final ShareContent content) {
+            return (content instanceof ShareLinkContent);
+        }
+
+        @Override
+        public AppCall createAppCall(final ShareContent content) {
+            logDialogShare(getActivityContext(), content, Mode.FEED);
+
+            final ShareLinkContent linkContent = (ShareLinkContent)content;
+            final AppCall appCall = createBaseAppCall();
+
+            ShareContentValidation.validateForWebShare(linkContent);
+
+            DialogPresenter.setupAppCallForWebDialog(
+                    appCall,
+                    FEED_DIALOG,
+                    WebDialogParameters.createForFeed(linkContent));
+
+            return appCall;
+        }
+    }
+
+    private static DialogFeature getFeature(
+            Class<? extends ShareContent> contentType) {
+        if (ShareLinkContent.class.isAssignableFrom(contentType)) {
+            return ShareDialogFeature.SHARE_DIALOG;
+        } else if (SharePhotoContent.class.isAssignableFrom(contentType)) {
+            return ShareDialogFeature.PHOTOS;
+        } else if (ShareVideoContent.class.isAssignableFrom(contentType)) {
+            return ShareDialogFeature.VIDEO;
+        } else if (ShareOpenGraphContent.class.isAssignableFrom(contentType)) {
+            return OpenGraphActionDialogFeature.OG_ACTION_DIALOG;
+        }
+        return null;
+    }
+
+    private void logDialogShare(Context context, ShareContent content, Mode mode) {
+        String displayType;
+        if (isAutomaticMode) {
+            mode = Mode.AUTOMATIC;
+        }
+
+        switch (mode) {
+            case AUTOMATIC:
+                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_AUTOMATIC;
+                break;
+            case WEB:
+                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_WEB;
+                break;
+            case NATIVE:
+                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_NATIVE;
+                break;
+            default:
+                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_UNKNOWN;
+                break;
+        }
+
+        String contentType;
+        DialogFeature dialogFeature = getFeature(content.getClass());
+        if (dialogFeature == ShareDialogFeature.SHARE_DIALOG) {
+            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_STATUS;
+        } else if (dialogFeature == ShareDialogFeature.PHOTOS) {
+            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_PHOTO;
+        } else if (dialogFeature == ShareDialogFeature.VIDEO) {
+            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_VIDEO;
+        } else if (dialogFeature == OpenGraphActionDialogFeature.OG_ACTION_DIALOG) {
+            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_OPENGRAPH;
+        } else {
+            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_UNKNOWN;
+        }
+
+        AppEventsLogger logger = AppEventsLogger.newLogger(context);
+        Bundle parameters = new Bundle();
+        parameters.putString(
+                AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW,
+                displayType
+        );
+        parameters.putString(
+                AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_TYPE,
+                contentType
+        );
+        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_DIALOG_SHOW, null, parameters);
+    }
+}
diff --git a/facebook/src/com/facebook/widget/FacebookDialog.java b/facebook/src/com/facebook/widget/FacebookDialog.java
deleted file mode 100644
index 77457b457..000000000
--- a/facebook/src/com/facebook/widget/FacebookDialog.java
+++ /dev/null
@@ -1,1276 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.support.v4.app.Fragment;
-import com.facebook.*;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-import com.facebook.model.*;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.File;
-import java.util.*;
-
-/*
- * Provides an interface for presenting dialogs provided by the Facebook application for Android. This class
- * provides builders that present a strongly-typed interface to generate properly-formed Intents for launching
- * the appropriate Activities provided by the Facebook application.
- */
-public class FacebookDialog {
-
-    public static final String COMPLETION_GESTURE_CANCEL = "cancel";
-
-    private static final String EXTRA_DIALOG_COMPLETE_KEY = "com.facebook.platform.extra.DID_COMPLETE";
-    private static final String EXTRA_DIALOG_COMPLETION_GESTURE_KEY =
-            "com.facebook.platform.extra.COMPLETION_GESTURE";
-    private static final String EXTRA_DIALOG_COMPLETION_ID_KEY = "com.facebook.platform.extra.POST_ID";
-
-    private static NativeAppCallAttachmentStore attachmentStore;
-
-    /**
-     * Defines a callback interface that will be called when the user completes interacting with a Facebook
-     * dialog, or if an error occurs.
-     */
-    public interface Callback {
-        /**
-         * Called when the user completes interacting with a Facebook dialog.
-         *
-         * @param pendingCall a PendingCall containing the call ID and original Intent used to launch the dialog
-         * @param data        a Bundle containing the results of the dialog, whose contents will vary depending on the
-         *                    type of dialog being displayed.
-         */
-        void onComplete(PendingCall pendingCall, Bundle data);
-
-        /**
-         * Called if an error occurred while presenting a Facebook dialog.
-         *
-         * @param pendingCall a PendingCall containing the call ID and original Intent used to launch the dialog
-         * @param error       the error that occurred
-         * @param data        the full set of extras associated with the activity result
-         */
-        void onError(PendingCall pendingCall, Exception error, Bundle data);
-    }
-
-    private interface DialogFeature {
-        String getAction();
-        int getMinVersion();
-    }
-
-    /**
-     * Defines a set of features that may be supported by the native Share dialog exposed by the Facebook application.
-     * As additional features are added, these flags may be passed to
-     * {@link FacebookDialog#canPresentShareDialog(android.content.Context,
-     * com.facebook.widget.FacebookDialog.ShareDialogFeature...)}
-     * to determine whether the version of the Facebook application installed on the user's device is recent
-     * enough to support specific features, which in turn may be used to determine which UI, etc., to present to the
-     * user.
-     */
-    public enum ShareDialogFeature implements DialogFeature {
-        /**
-         * Indicates whether the native Share dialog itself is supported by the installed version of the
-         * Facebook application.
-         */
-        SHARE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618);
-
-        private int minVersion;
-
-        private ShareDialogFeature(int minVersion) {
-            this.minVersion = minVersion;
-        }
-
-        /**
-         * This method is for internal use only.
-         */
-        public String getAction() {
-            return NativeProtocol.ACTION_FEED_DIALOG;
-        }
-
-        /**
-         * This method is for internal use only.
-         */
-        public int getMinVersion() {
-            return minVersion;
-        }
-    }
-
-    /**
-     * Defines a set of features that may be supported by the native Open Graph dialogs exposed by the Facebook
-     * application. As additional features are added, these flags may be passed to
-     * {@link FacebookDialog#canPresentOpenGraphActionDialog(android.content.Context,
-     * com.facebook.widget.FacebookDialog.OpenGraphActionDialogFeature...)}
-     * to determine whether the version of the Facebook application installed on the user's device is recent
-     * enough to support specific features, which in turn may be used to determine which UI, etc., to present to the
-     * user.
-     */
-    public enum OpenGraphActionDialogFeature implements DialogFeature {
-        /**
-         * Indicates whether the native Open Graph action dialog itself is supported by the installed version of the
-         * Facebook application.
-         */
-        OG_ACTION_DIALOG(NativeProtocol.PROTOCOL_VERSION_20130618);
-
-        private int minVersion;
-
-        private OpenGraphActionDialogFeature(int minVersion) {
-            this.minVersion = minVersion;
-        }
-
-        /**
-         * This method is for internal use only.
-         */
-        public String getAction() {
-            return NativeProtocol.ACTION_OGACTIONPUBLISH_DIALOG;
-        }
-
-        /**
-         * This method is for internal use only.
-         */
-        public int getMinVersion() {
-            return minVersion;
-        }
-    }
-
-    interface OnPresentCallback {
-        void onPresent(Context context) throws Exception;
-    }
-
-    /**
-     * Determines whether the native dialog completed normally (without error or exception).
-     *
-     * @param result the bundle passed back to onActivityResult
-     * @return true if the native dialog completed normally
-     */
-    public static boolean getNativeDialogDidComplete(Bundle result) {
-        return result.getBoolean(EXTRA_DIALOG_COMPLETE_KEY, false);
-    }
-
-    /**
-     * Returns the gesture with which the user completed the native dialog. This is only returned if the
-     * user has previously authorized the calling app with basic permissions.
-     *
-     * @param result the bundle passed back to onActivityResult
-     * @return "post" or "cancel" as the completion gesture
-     */
-    public static String getNativeDialogCompletionGesture(Bundle result) {
-        return result.getString(EXTRA_DIALOG_COMPLETION_GESTURE_KEY);
-    }
-
-    /**
-     * Returns the id of the published post. This is only returned if the user has previously given the
-     * app publish permissions.
-     *
-     * @param result the bundle passed back to onActivityResult
-     * @return the id of the published post
-     */
-    public static String getNativeDialogPostId(Bundle result) {
-        return result.getString(EXTRA_DIALOG_COMPLETION_ID_KEY);
-    }
-
-    private Activity activity;
-    private Fragment fragment;
-    private PendingCall appCall;
-    private OnPresentCallback onPresentCallback;
-
-    private FacebookDialog(Activity activity, Fragment fragment, PendingCall appCall,
-            OnPresentCallback onPresentCallback) {
-        this.activity = activity;
-        this.fragment = fragment;
-        this.appCall = appCall;
-        this.onPresentCallback = onPresentCallback;
-    }
-
-    /**
-     * Launches an activity in the Facebook application to present the desired dialog. This method returns a
-     * PendingCall that contains a unique ID associated with this call to the Facebook application. In general,
-     * a calling Activity should use UiLifecycleHelper to handle incoming activity results, in order to ensure
-     * proper processing of the results from this dialog.
-     *
-     * @return a PendingCall containing the unique call ID corresponding to this call to the Facebook application
-     */
-    public PendingCall present() {
-        if (onPresentCallback != null) {
-            try {
-                onPresentCallback.onPresent(activity);
-            } catch (Exception e) {
-                throw new FacebookException(e);
-            }
-        }
-
-        if (fragment != null) {
-            fragment.startActivityForResult(appCall.getRequestIntent(), appCall.getRequestCode());
-        } else {
-            activity.startActivityForResult(appCall.getRequestIntent(), appCall.getRequestCode());
-        }
-        return appCall;
-    }
-
-    /**
-     * Parses the results of a dialog activity and calls the appropriate method on the provided Callback.
-     *
-     * @param context     the Context that is handling the activity result
-     * @param appCall     an PendingCall containing the call ID and original Intent used to launch the dialog
-     * @param requestCode the request code for the activity result
-     * @param data        the result Intent
-     * @param callback    a callback to call after parsing the results
-     * @return true if the activity result was handled, false if not
-     */
-    public static boolean handleActivityResult(Context context, PendingCall appCall, int requestCode, Intent data,
-            Callback callback) {
-        if (requestCode != appCall.getRequestCode()) {
-            return false;
-        }
-
-        if (attachmentStore != null) {
-            attachmentStore.cleanupAttachmentsForCall(context, appCall.getCallId());
-        }
-
-        if (callback != null) {
-            if (NativeProtocol.isErrorResult(data)) {
-                Exception error = NativeProtocol.getErrorFromResult(data);
-                callback.onError(appCall, error, data.getExtras());
-            } else {
-                callback.onComplete(appCall, data.getExtras());
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Determines whether the version of the Facebook application installed on the user's device is recent
-     * enough to support specific features of the native Share dialog, which in turn may be used to determine
-     * which UI, etc., to present to the user.
-     *
-     * @param context  the calling Context
-     * @param features zero or more features to check for; {@link ShareDialogFeature#SHARE_DIALOG} is implicitly checked
-     *                 if not explicitly specified
-     * @return true if all of the specified features are supported by the currently installed version of the
-     *         Facebook application; false if any of the features are not supported
-     */
-    public static boolean canPresentShareDialog(Context context, ShareDialogFeature... features) {
-        return handleCanPresent(context, EnumSet.of(ShareDialogFeature.SHARE_DIALOG, features));
-    }
-
-    /**
-     * Determines whether the version of the Facebook application installed on the user's device is recent
-     * enough to support specific features of the native Open Graph action dialog, which in turn may be used to
-     * determine which UI, etc., to present to the user.
-     *
-     * @param context  the calling Context
-     * @param features zero or more features to check for; {@link OpenGraphActionDialogFeature#OG_ACTION_DIALOG} is implicitly
-     *                 checked if not explicitly specified
-     * @return true if all of the specified features are supported by the currently installed version of the
-     *         Facebook application; false if any of the features are not supported
-     */
-    public static boolean canPresentOpenGraphActionDialog(Context context, OpenGraphActionDialogFeature... features) {
-        return handleCanPresent(context, EnumSet.of(OpenGraphActionDialogFeature.OG_ACTION_DIALOG, features));
-    }
-
-    private static boolean handleCanPresent(Context context, Iterable<? extends DialogFeature> features) {
-        return getProtocolVersionForNativeDialog(context, getActionForFeatures(features), getMinVersionForFeatures(features))
-                != NativeProtocol.NO_PROTOCOL_AVAILABLE;
-    }
-
-    private static int getProtocolVersionForNativeDialog(Context context, String action, int requiredVersion) {
-        return NativeProtocol.getLatestAvailableProtocolVersionForAction(context, action, requiredVersion);
-    }
-
-    private static NativeAppCallAttachmentStore getAttachmentStore() {
-        if (attachmentStore == null) {
-            attachmentStore = new NativeAppCallAttachmentStore();
-        }
-        return attachmentStore;
-    }
-
-    private static int getMinVersionForFeatures(Iterable<? extends DialogFeature> features) {
-        int minVersion = Integer.MIN_VALUE;
-        for (DialogFeature feature : features) {
-            // Minimum version to support all features is the maximum of each feature's minimum version.
-            minVersion = Math.max(minVersion, feature.getMinVersion());
-        }
-        return minVersion;
-    }
-
-    private static String getActionForFeatures(Iterable<? extends DialogFeature> features) {
-        String action = null;
-        for (DialogFeature feature : features) {
-            // All actions in a set of DialogFeatures should have the same action
-            // So we can break after assigning the first one
-            action = feature.getAction();
-            break;
-        }
-        return action;
-    }
-
-    private abstract static class Builder<CONCRETE extends Builder<?>> {
-        final protected Activity activity;
-        final protected String applicationId;
-        final protected PendingCall appCall;
-        protected Fragment fragment;
-        protected String applicationName;
-
-        Builder(Activity activity) {
-            Validate.notNull(activity, "activity");
-
-            this.activity = activity;
-            applicationId = Utility.getMetadataApplicationId(activity);
-            appCall = new PendingCall(NativeProtocol.DIALOG_REQUEST_CODE);
-        }
-
-        /**
-         * Sets the request code that will be passed to handleActivityResult when this activity completes; the
-         * default is NativeProtocol.DIALOG_REQUEST_CODE.
-         *
-         * @param requestCode the request code
-         * @return this instance of the builder
-         */
-        public CONCRETE setRequestCode(int requestCode) {
-            this.appCall.setRequestCode(requestCode);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the name of the application to be displayed in the dialog. If provided, this optimizes the user
-         * experience as a preview of a shared item, etc., can be displayed sooner.
-         *
-         * @param applicationName the name of the Facebook application
-         * @return this instance of the builder
-         */
-        public CONCRETE setApplicationName(String applicationName) {
-            this.applicationName = applicationName;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the fragment that should launch the dialog. This allows the dialog to be
-         * launched from a Fragment, and will allow the fragment to receive the
-         * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
-         * call rather than the Activity.
-         *
-         * @param fragment the fragment that contains this control
-         */
-        public CONCRETE setFragment(Fragment fragment) {
-            this.fragment = fragment;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Constructs a FacebookDialog with an Intent that is correctly populated to present the dialog within
-         * the Facebook application.
-         *
-         * @return a FacebookDialog instance
-         */
-        public FacebookDialog build() {
-            validate();
-
-            Bundle extras = new Bundle();
-            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
-            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_NAME, applicationName);
-            extras = setBundleExtras(extras);
-
-            String action = getActionForFeatures(getDialogFeatures());
-            int protocolVersion = getProtocolVersionForNativeDialog(activity, action,
-                    getMinVersionForFeatures(getDialogFeatures()));
-
-            Intent intent = NativeProtocol.createPlatformActivityIntent(activity, action, protocolVersion, extras);
-            if (intent == null) {
-                throw new FacebookException(
-                        "Unable to create Intent; this likely means the Facebook app is not installed.");
-            }
-            appCall.setRequestIntent(intent);
-
-            return new FacebookDialog(activity, fragment, appCall, getOnPresentCallback());
-        }
-
-        /**
-         * Determines whether the native dialog can be presented (i.e., whether the required version of the
-         * Facebook application is installed on the device, and whether the installed version supports all of
-         * the parameters specified for the dialog).
-         *
-         * @return true if the dialog can be presented; false if not
-         */
-        public boolean canPresent() {
-            return handleCanPresent(activity, getDialogFeatures());
-        }
-
-        void validate() {
-        }
-
-        OnPresentCallback getOnPresentCallback() {
-            return null;
-        }
-
-        abstract Bundle setBundleExtras(Bundle extras);
-
-        void putExtra(Bundle extras, String key, String value) {
-            if (value != null) {
-                extras.putString(key, value);
-            }
-        }
-
-        abstract EnumSet<? extends DialogFeature> getDialogFeatures();
-    }
-
-    private abstract static class ShareDialogBuilderBase<CONCRETE extends ShareDialogBuilderBase<?>> extends Builder<CONCRETE> {
-        private String name;
-        private String caption;
-        private String description;
-        private String link;
-        private String picture;
-        private String place;
-        private ArrayList<String> friends;
-        private String ref;
-        private boolean dataErrorsFatal;
-
-        /**
-         * Constructor.
-         *
-         * @param activity the Activity which is presenting the native Share dialog; must not be null
-         */
-        public ShareDialogBuilderBase(Activity activity) {
-            super(activity);
-        }
-
-        /**
-         * Sets the title of the item to be shared.
-         *
-         * @param name the title
-         * @return this instance of the builder
-         */
-        public CONCRETE setName(String name) {
-            this.name = name;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the subtitle of the item to be shared.
-         *
-         * @param caption the subtitle
-         * @return this instance of the builder
-         */
-        public CONCRETE setCaption(String caption) {
-            this.caption = caption;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the description of the item to be shared.
-         *
-         * @param description the description
-         * @return this instance of the builder
-         */
-        public CONCRETE setDescription(String description) {
-            this.description = description;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the URL of the item to be shared.
-         *
-         * @param link the URL
-         * @return this instance of the builder
-         */
-        public CONCRETE setLink(String link) {
-            this.link = link;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the URL of the image of the item to be shared.
-         *
-         * @param picture the URL of the image
-         * @return this instance of the builder
-         */
-        public CONCRETE setPicture(String picture) {
-            this.picture = picture;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the place for the item to be shared.
-         *
-         * @param place the Facebook ID of the place
-         * @return this instance of the builder
-         */
-        public CONCRETE setPlace(String place) {
-            this.place = place;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the tagged friends for the item to be shared.
-         *
-         * @param friends a list of Facebook IDs of the friends to be tagged in the shared item
-         * @return this instance of the builder
-         */
-        public CONCRETE setFriends(List<String> friends) {
-            this.friends = new ArrayList<String>(friends);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets the 'ref' property of the item to be shared.
-         *
-         * @param ref the 'ref' property
-         * @return this instance of the builder
-         */
-        public CONCRETE setRef(String ref) {
-            this.ref = ref;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * Sets whether errors encountered during previewing the shared item should be considered fatal and
-         * cause the dialog to return an error
-         *
-         * @param dataErrorsFatal true if data errors should be fatal; false if not
-         * @return this instance of the builder
-         */
-        public CONCRETE setDataErrorsFatal(boolean dataErrorsFatal) {
-            this.dataErrorsFatal = dataErrorsFatal;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        @Override
-        Bundle setBundleExtras(Bundle extras) {
-            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
-            putExtra(extras, NativeProtocol.EXTRA_APPLICATION_NAME, applicationName);
-            putExtra(extras, NativeProtocol.EXTRA_TITLE, name);
-            putExtra(extras, NativeProtocol.EXTRA_SUBTITLE, caption);
-            putExtra(extras, NativeProtocol.EXTRA_DESCRIPTION, description);
-            putExtra(extras, NativeProtocol.EXTRA_LINK, link);
-            putExtra(extras, NativeProtocol.EXTRA_IMAGE, picture);
-            putExtra(extras, NativeProtocol.EXTRA_PLACE_TAG, place);
-            putExtra(extras, NativeProtocol.EXTRA_TITLE, name);
-            putExtra(extras, NativeProtocol.EXTRA_REF, ref);
-
-            extras.putBoolean(NativeProtocol.EXTRA_DATA_FAILURES_FATAL, dataErrorsFatal);
-            if (!Utility.isNullOrEmpty(friends)) {
-                extras.putStringArrayList(NativeProtocol.EXTRA_FRIEND_TAGS, friends);
-            }
-            return extras;
-        }
-    }
-
-    /**
-     * Provides a builder which can construct a FacebookDialog instance suitable for presenting the native
-     * Share dialog. This builder will throw an exception if the Facebook application is not installed, so it
-     * should only be used if {@link FacebookDialog#canPresentShareDialog(android.content.Context,
-     * com.facebook.widget.FacebookDialog.ShareDialogFeature...)}  indicates the capability is available.
-     */
-    public static class ShareDialogBuilder extends ShareDialogBuilderBase<ShareDialogBuilder> {
-
-        /**
-         * Constructor.
-         *
-         * @param activity the Activity which is presenting the native Share dialog; must not be null
-         */
-        public ShareDialogBuilder(Activity activity) {
-            super(activity);
-        }
-
-        @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
-            return EnumSet.of(ShareDialogFeature.SHARE_DIALOG);
-        }
-    }
-
-    private static abstract class OpenGraphDialogBuilderBase<CONCRETE extends OpenGraphDialogBuilderBase<?>>
-            extends Builder<CONCRETE> {
-
-        private String previewPropertyName;
-        private OpenGraphAction action;
-        private String actionType;
-        private HashMap<String, Bitmap> imageAttachments;
-        private HashMap<String, File> imageAttachmentFiles;
-        private boolean dataErrorsFatal;
-
-        /**
-         * Constructor.
-         *
-         * @param activity            the Activity which is presenting the native Open Graph action publish dialog;
-         *                            must not be null
-         * @param action              the Open Graph action to be published, which must contain a reference to at least one
-         *                            Open Graph object with the property name specified by setPreviewPropertyName; the action
-         *                            must have had its type specified via the {@link OpenGraphAction#setType(String)} method
-         * @param actionType          the type of the Open Graph action to be published, which should be the namespace-qualified
-         *                            name of the action type (e.g., "myappnamespace:myactiontype"); this will override the type
-         *                            of the action passed in.
-         * @param previewPropertyName the name of a property on the Open Graph action that contains the
-         *                            Open Graph object which will be displayed as a preview to the user
-         */
-        @Deprecated
-        public OpenGraphDialogBuilderBase(Activity activity, OpenGraphAction action, String actionType,
-                String previewPropertyName) {
-            super(activity);
-
-            Validate.notNull(action, "action");
-            Validate.notNullOrEmpty(actionType, "actionType");
-            Validate.notNullOrEmpty(previewPropertyName, "previewPropertyName");
-            if (action.getProperty(previewPropertyName) == null) {
-                throw new IllegalArgumentException(
-                        "A property named \"" + previewPropertyName + "\" was not found on the action.  The name of " +
-                                "the preview property must match the name of an action property.");
-            }
-            String typeOnAction = action.getType();
-            if (!Utility.isNullOrEmpty(typeOnAction) && !typeOnAction.equals(actionType)) {
-                throw new IllegalArgumentException("'actionType' must match the type of 'action' if it is specified. " +
-                        "Consider using OpenGraphDialogBuilderBase(Activity activity, OpenGraphAction action, " +
-                        "String previewPropertyName) instead.");
-            }
-            this.action = action;
-            this.actionType = actionType;
-            this.previewPropertyName = previewPropertyName;
-        }
-
-        /**
-         * Constructor.
-         *
-         * @param activity            the Activity which is presenting the native Open Graph action publish dialog;
-         *                            must not be null
-         * @param action              the Open Graph action to be published, which must contain a reference to at least one
-         *                            Open Graph object with the property name specified by setPreviewPropertyName; the action
-         *                            must have had its type specified via the {@link OpenGraphAction#setType(String)} method
-         * @param previewPropertyName the name of a property on the Open Graph action that contains the
-         *                            Open Graph object which will be displayed as a preview to the user
-         */
-        public OpenGraphDialogBuilderBase(Activity activity, OpenGraphAction action, String previewPropertyName) {
-            super(activity);
-
-            Validate.notNull(action, "action");
-            Validate.notNullOrEmpty(action.getType(), "action.getType()");
-            Validate.notNullOrEmpty(previewPropertyName, "previewPropertyName");
-            if (action.getProperty(previewPropertyName) == null) {
-                throw new IllegalArgumentException(
-                        "A property named \"" + previewPropertyName + "\" was not found on the action.  The name of " +
-                                "the preview property must match the name of an action property.");
-            }
-
-            this.action = action;
-            this.actionType = action.getType();
-            this.previewPropertyName = previewPropertyName;
-        }
-
-        /**
-         * Sets whether errors encountered during previewing the shared item should be considered fatal and
-         * cause the dialog to return an error
-         *
-         * @param dataErrorsFatal true if data errors should be fatal; false if not
-         * @return this instance of the builder
-         */
-        public CONCRETE setDataErrorsFatal(boolean dataErrorsFatal) {
-            this.dataErrorsFatal = dataErrorsFatal;
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * <p>Specifies a list of images for the Open Graph action that should be uploaded prior to publishing the
-         * action. The action must already have been set prior to calling this method. This method will generate unique
-         * names for the image attachments and update the action to refer to these attachments. Note that calling
-         * setAction again after calling this method will not clear the image attachments already set, but the new
-         * action will have no reference to the existing attachments. The images will not be marked as being
-         * user-generated.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param bitmaps a list of Bitmaps to be uploaded and attached to the Open Graph action
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentsForAction(List<Bitmap> bitmaps) {
-            return setImageAttachmentsForAction(bitmaps, false);
-        }
-
-        /**
-         * <p>Specifies a list of images for the Open Graph action that should be uploaded prior to publishing the
-         * action. The action must already have been set prior to calling this method. This method will generate unique
-         * names for the image attachments and update the action to refer to these attachments. Note that calling
-         * setAction again after calling this method will not clear the image attachments already set, but the new
-         * action will have no reference to the existing attachments. The images may be marked as being
-         * user-generated -- refer to
-         * <a href="https://developers.facebook.com/docs/opengraph/howtos/adding-photos-to-stories/">this article</a>
-         * for more information.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param bitmaps         a list of Bitmaps to be uploaded and attached to the Open Graph action
-         * @param isUserGenerated if true, specifies that the user_generated flag should be set for these images
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentsForAction(List<Bitmap> bitmaps,
-                boolean isUserGenerated) {
-            Validate.containsNoNulls(bitmaps, "bitmaps");
-            if (action == null) {
-                throw new FacebookException("Can not set attachments prior to setting action.");
-            }
-
-            List<String> attachmentUrls = addImageAttachments(bitmaps);
-            updateActionAttachmentUrls(attachmentUrls, isUserGenerated);
-
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * <p>Specifies a list of images for the Open Graph action that should be uploaded prior to publishing the
-         * action. The action must already have been set prior to calling this method.  The images will not be marked
-         * as being user-generated. This method will generate unique names for the image attachments and update the
-         * action to refer to these attachments. Note that calling setAction again after calling this method will
-         * not clear the image attachments already set, but the new action will have no reference to the existing
-         * attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param bitmapFiles a list of Files containing bitmaps to be uploaded and attached to the Open Graph action
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentFilesForAction(List<File> bitmapFiles) {
-            return setImageAttachmentFilesForAction(bitmapFiles, false);
-        }
-
-        /**
-         * <p>Specifies a list of images for the Open Graph action that should be uploaded prior to publishing the
-         * action. The action must already have been set prior to calling this method. The images may be marked as being
-         * user-generated -- refer to
-         * <a href="https://developers.facebook.com/docs/opengraph/howtos/adding-photos-to-stories/">this article</a>
-         * for more information. This method will generate unique
-         * names for the image attachments and update the action to refer to these attachments. Note that calling
-         * setAction again after calling this method will not clear the image attachments already set, but the new
-         * action will have no reference to the existing attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param bitmapFiles     a list of Files containing bitmaps to be uploaded and attached to the Open Graph action
-         * @param isUserGenerated if true, specifies that the user_generated flag should be set for these images
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentFilesForAction(List<File> bitmapFiles,
-                boolean isUserGenerated) {
-            Validate.containsNoNulls(bitmapFiles, "bitmapFiles");
-            if (action == null) {
-                throw new FacebookException("Can not set attachments prior to setting action.");
-            }
-
-            List<String> attachmentUrls = addImageAttachmentFiles(bitmapFiles);
-            updateActionAttachmentUrls(attachmentUrls, isUserGenerated);
-
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        private void updateActionAttachmentUrls(List<String> attachmentUrls, boolean isUserGenerated) {
-            List<JSONObject> attachments = action.getImage();
-            if (attachments == null) {
-                attachments = new ArrayList<JSONObject>(attachmentUrls.size());
-            }
-
-            for (String url : attachmentUrls) {
-                JSONObject jsonObject = new JSONObject();
-                try {
-                    jsonObject.put(NativeProtocol.IMAGE_URL_KEY, url);
-                    if (isUserGenerated) {
-                        jsonObject.put(NativeProtocol.IMAGE_USER_GENERATED_KEY, true);
-                    }
-                } catch (JSONException e) {
-                    throw new FacebookException("Unable to attach images", e);
-                }
-                attachments.add(jsonObject);
-            }
-            action.setImage(attachments);
-        }
-
-
-        /**
-         * <p>Specifies a list of images for an Open Graph object referenced by the action that should be uploaded
-         * prior to publishing the action. The images will not be marked as user-generated.
-         * The action must already have been set prior to calling this method, and
-         * the action must have a GraphObject-valued property with the specified property name. This method will
-         * generate unique names for the image attachments and update the graph object to refer to these
-         * attachments. Note that calling setObject again after calling this method, or modifying the value of the
-         * specified property, will not clear the image attachments already set, but the new action (or objects)
-         * will have no reference to the existing attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param objectProperty the name of a property on the action that corresponds to an Open Graph object;
-         *                       the object must be marked as a new object to be created
-         *                       (i.e., {@link com.facebook.model.OpenGraphObject#getCreateObject()} must return
-         *                       true) or an exception will be thrown
-         * @param bitmaps        a list of Files containing bitmaps to be uploaded and attached to the Open Graph object
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentsForObject(String objectProperty, List<Bitmap> bitmaps) {
-            return setImageAttachmentsForObject(objectProperty, bitmaps, false);
-        }
-
-        /**
-         * <p>Specifies a list of images for an Open Graph object referenced by the action that should be uploaded
-         * prior to publishing the action. The images may be marked as being
-         * user-generated -- refer to
-         * <a href="https://developers.facebook.com/docs/opengraph/howtos/adding-photos-to-stories/">this article</a>
-         * for more information.
-         * The action must already have been set prior to calling this method, and
-         * the action must have a GraphObject-valued property with the specified property name. This method will
-         * generate unique names for the image attachments and update the graph object to refer to these
-         * attachments. Note that calling setObject again after calling this method, or modifying the value of the
-         * specified property, will not clear the image attachments already set, but the new action (or objects)
-         * will have no reference to the existing attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param objectProperty  the name of a property on the action that corresponds to an Open Graph object;
-         *                        the object must be marked as a new object to be created
-         *                        (i.e., {@link com.facebook.model.OpenGraphObject#getCreateObject()} must return
-         *                        true) or an exception will be thrown
-         * @param objectProperty  the name of a property on the action that corresponds to an Open Graph object
-         * @param bitmaps         a list of Files containing bitmaps to be uploaded and attached to the Open Graph object
-         * @param isUserGenerated if true, specifies that the user_generated flag should be set for these images
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentsForObject(String objectProperty, List<Bitmap> bitmaps,
-                boolean isUserGenerated) {
-            Validate.notNull(objectProperty, "objectProperty");
-            Validate.containsNoNulls(bitmaps, "bitmaps");
-            if (action == null) {
-                throw new FacebookException("Can not set attachments prior to setting action.");
-            }
-
-            List<String> attachmentUrls = addImageAttachments(bitmaps);
-            updateObjectAttachmentUrls(objectProperty, attachmentUrls, isUserGenerated);
-
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        /**
-         * <p>Specifies a list of images for an Open Graph object referenced by the action that should be uploaded
-         * prior to publishing the action. The images will not be marked as user-generated.
-         * The action must already have been set prior to calling this method, and
-         * the action must have a GraphObject-valued property with the specified property name. This method will
-         * generate unique names for the image attachments and update the graph object to refer to these
-         * attachments. Note that calling setObject again after calling this method, or modifying the value of the
-         * specified property, will not clear the image attachments already set, but the new action (or objects)
-         * will have no reference to the existing attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param objectProperty the name of a property on the action that corresponds to an Open Graph object;
-         *                       the object must be marked as a new object to be created
-         *                       (i.e., {@link com.facebook.model.OpenGraphObject#getCreateObject()} must return
-         *                       true) or an exception will be thrown
-         * @param bitmapFiles    a list of Bitmaps to be uploaded and attached to the Open Graph object
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentFilesForObject(String objectProperty,
-                List<File> bitmapFiles) {
-            return setImageAttachmentFilesForObject(objectProperty, bitmapFiles, false);
-        }
-
-        /**
-         * <p>Specifies a list of images for an Open Graph object referenced by the action that should be uploaded
-         * prior to publishing the action. The images may be marked as being
-         * user-generated -- refer to
-         * <a href="https://developers.facebook.com/docs/opengraph/howtos/adding-photos-to-stories/">this article</a>
-         * for more information.
-         * The action must already have been set prior to calling this method, and
-         * the action must have a GraphObject-valued property with the specified property name. This method will
-         * generate unique names for the image attachments and update the graph object to refer to these
-         * attachments. Note that calling setObject again after calling this method, or modifying the value of the
-         * specified property, will not clear the image attachments already set, but the new action (or objects)
-         * will have no reference to the existing attachments.</p>
-         * <p/>
-         * <p>In order for the images to be provided to the Facebook application as part of the app call, the
-         * NativeAppCallContentProvider must be specified correctly in the application's AndroidManifest.xml.</p>
-         *
-         * @param objectProperty  the name of a property on the action that corresponds to an Open Graph object;
-         *                        the object must be marked as a new object to be created
-         *                        (i.e., {@link com.facebook.model.OpenGraphObject#getCreateObject()} must return
-         *                        true) or an exception will be thrown
-         * @param bitmapFiles     a list of Bitmaps to be uploaded and attached to the Open Graph object
-         * @param isUserGenerated if true, specifies that the user_generated flag should be set for these images
-         * @return this instance of the builder
-         */
-        public CONCRETE setImageAttachmentFilesForObject(String objectProperty,
-                List<File> bitmapFiles, boolean isUserGenerated) {
-            Validate.notNull(objectProperty, "objectProperty");
-            Validate.containsNoNulls(bitmapFiles, "bitmapFiles");
-            if (action == null) {
-                throw new FacebookException("Can not set attachments prior to setting action.");
-            }
-
-            List<String> attachmentUrls = addImageAttachmentFiles(bitmapFiles);
-            updateObjectAttachmentUrls(objectProperty, attachmentUrls, isUserGenerated);
-
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        void updateObjectAttachmentUrls(String objectProperty, List<String> attachmentUrls, boolean isUserGenerated) {
-            final OpenGraphObject object;
-            try {
-                object = action.getPropertyAs(objectProperty, OpenGraphObject.class);
-                if (object == null) {
-                    throw new IllegalArgumentException("Action does not contain a property '" + objectProperty + "'");
-                }
-            } catch (FacebookGraphObjectException exception) {
-                throw new IllegalArgumentException("Property '" + objectProperty + "' is not a graph object");
-            }
-            if (!object.getCreateObject()) {
-                throw new IllegalArgumentException(
-                        "The Open Graph object in '" + objectProperty + "' is not marked for creation");
-            }
-
-            GraphObjectList<GraphObject> attachments = object.getImage();
-            if (attachments == null) {
-                attachments = GraphObject.Factory.createList(GraphObject.class);
-            }
-            for (String url : attachmentUrls) {
-                GraphObject graphObject = GraphObject.Factory.create();
-                graphObject.setProperty(NativeProtocol.IMAGE_URL_KEY, url);
-                if (isUserGenerated) {
-                    graphObject.setProperty(NativeProtocol.IMAGE_USER_GENERATED_KEY, true);
-                }
-                attachments.add(graphObject);
-            }
-            object.setImage(attachments);
-        }
-
-        private List<String> addImageAttachments(List<Bitmap> bitmaps) {
-            ArrayList<String> attachmentUrls = new ArrayList<String>();
-            for (Bitmap bitmap : bitmaps) {
-                String attachmentName = UUID.randomUUID().toString();
-
-                addImageAttachment(attachmentName, bitmap);
-
-                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
-                        attachmentName);
-                attachmentUrls.add(url);
-            }
-
-            return attachmentUrls;
-        }
-
-        private List<String> addImageAttachmentFiles(List<File> bitmapFiles) {
-            ArrayList<String> attachmentUrls = new ArrayList<String>();
-            for (File bitmapFile : bitmapFiles) {
-                String attachmentName = UUID.randomUUID().toString();
-
-                addImageAttachment(attachmentName, bitmapFile);
-
-                String url = NativeAppCallContentProvider.getAttachmentUrl(applicationId, appCall.getCallId(),
-                        attachmentName);
-                attachmentUrls.add(url);
-            }
-
-            return attachmentUrls;
-        }
-
-        List<String> getImageAttachmentNames() {
-            return new ArrayList<String>(imageAttachments.keySet());
-        }
-
-        @Override
-        Bundle setBundleExtras(Bundle extras) {
-            putExtra(extras, NativeProtocol.EXTRA_PREVIEW_PROPERTY_NAME, previewPropertyName);
-            putExtra(extras, NativeProtocol.EXTRA_ACTION_TYPE, actionType);
-            extras.putBoolean(NativeProtocol.EXTRA_DATA_FAILURES_FATAL, dataErrorsFatal);
-
-            JSONObject jsonAction = action.getInnerJSONObject();
-            jsonAction = flattenChildrenOfGraphObject(jsonAction);
-
-            String jsonString = jsonAction.toString();
-            putExtra(extras, NativeProtocol.EXTRA_ACTION, jsonString);
-
-            return extras;
-        }
-
-        @Override
-        OnPresentCallback getOnPresentCallback() {
-            return new OnPresentCallback() {
-                @Override
-                public void onPresent(Context context) throws Exception {
-                    // We're actually being presented, so put our attachments in the content provider.
-                    if (imageAttachments != null && imageAttachments.size() > 0) {
-                        getAttachmentStore().addAttachmentsForCall(context, appCall.getCallId(), imageAttachments);
-                    }
-                    if (imageAttachmentFiles != null && imageAttachmentFiles.size() > 0) {
-                        getAttachmentStore().addAttachmentFilesForCall(context, appCall.getCallId(),
-                                imageAttachmentFiles);
-                    }
-                }
-            };
-        }
-
-        private CONCRETE addImageAttachment(String imageName, Bitmap bitmap) {
-            if (imageAttachments == null) {
-                imageAttachments = new HashMap<String, Bitmap>();
-            }
-            imageAttachments.put(imageName, bitmap);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        private CONCRETE addImageAttachment(String imageName, File attachment) {
-            if (imageAttachmentFiles == null) {
-                imageAttachmentFiles = new HashMap<String, File>();
-            }
-            imageAttachmentFiles.put(imageName, attachment);
-            @SuppressWarnings("unchecked")
-            CONCRETE result = (CONCRETE) this;
-            return result;
-        }
-
-        private JSONObject flattenChildrenOfGraphObject(JSONObject graphObject) {
-            try {
-                // Clone the existing object to avoid modifying it from under the caller.
-                graphObject = new JSONObject(graphObject.toString());
-
-                @SuppressWarnings("unchecked")
-                Iterator<String> keys = graphObject.keys();
-                while (keys.hasNext()) {
-                    String key = keys.next();
-                    // The "image" property should not be flattened
-                    if (!key.equalsIgnoreCase("image")) {
-                        Object object = graphObject.get(key);
-
-                        object = flattenObject(object);
-                        graphObject.put(key, object);
-                    }
-                }
-
-                return graphObject;
-            } catch (JSONException e) {
-                throw new FacebookException(e);
-            }
-        }
-
-        private Object flattenObject(Object object) throws JSONException {
-            if (object == null) {
-                return null;
-            }
-
-            if (object instanceof JSONObject) {
-                JSONObject jsonObject = (JSONObject) object;
-
-                // Don't flatten objects that are marked as create_object.
-                if (jsonObject.optBoolean(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
-                    return object;
-                }
-                if (jsonObject.has("id")) {
-                    return jsonObject.getString("id");
-                } else if (jsonObject.has("url")) {
-                    return jsonObject.getString("url");
-                }
-            } else if (object instanceof JSONArray) {
-                JSONArray jsonArray = (JSONArray) object;
-                JSONArray newArray = new JSONArray();
-                int length = jsonArray.length();
-
-                for (int i = 0; i < length; ++i) {
-                    newArray.put(flattenObject(jsonArray.get(i)));
-                }
-
-                return newArray;
-            }
-
-            return object;
-        }
-    }
-
-    /**
-     * Provides a builder which can construct a FacebookDialog instance suitable for presenting the native
-     * Open Graph action publish dialog. This builder allows the caller to specify binary images for both the
-     * action and any Open Graph objects to be created prior to publishing the action.
-     * This builder will throw an exception if the Facebook application is not installed, so it
-     * should only be used if {@link FacebookDialog#canPresentOpenGraphActionDialog(android.content.Context,
-     * com.facebook.widget.FacebookDialog.OpenGraphActionDialogFeature...)} indicates the capability is available.
-     */
-    public static class OpenGraphActionDialogBuilder extends OpenGraphDialogBuilderBase<OpenGraphActionDialogBuilder> {
-        /**
-         * Constructor.
-         *
-         * @param activity            the Activity which is presenting the native Open Graph action publish dialog;
-         *                            must not be null
-         * @param action              the Open Graph action to be published, which must contain a reference to at least one
-         *                            Open Graph object with the property name specified by setPreviewPropertyName; the action
-         *                            must have had its type specified via the {@link OpenGraphAction#setType(String)} method
-         * @param actionType          the type of the Open Graph action to be published, which should be the namespace-qualified
-         *                            name of the action type (e.g., "myappnamespace:myactiontype"); this will override the type
-         *                            of the action passed in.
-         * @param previewPropertyName the name of a property on the Open Graph action that contains the
-         *                            Open Graph object which will be displayed as a preview to the user
-         */
-        @Deprecated
-        public OpenGraphActionDialogBuilder(Activity activity, OpenGraphAction action, String actionType,
-                String previewPropertyName) {
-            super(activity, action, actionType, previewPropertyName);
-        }
-
-        /**
-         * Constructor.
-         *
-         * @param activity            the Activity which is presenting the native Open Graph action publish dialog;
-         *                            must not be null
-         * @param action              the Open Graph action to be published, which must contain a reference to at least one
-         *                            Open Graph object with the property name specified by setPreviewPropertyName; the action
-         *                            must have had its type specified via the {@link OpenGraphAction#setType(String)} method
-         * @param previewPropertyName the name of a property on the Open Graph action that contains the
-         *                            Open Graph object which will be displayed as a preview to the user
-         */
-        public OpenGraphActionDialogBuilder(Activity activity, OpenGraphAction action, String previewPropertyName) {
-            super(activity, action, previewPropertyName);
-        }
-
-        @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
-            return EnumSet.of(OpenGraphActionDialogFeature.OG_ACTION_DIALOG);
-        }
-    }
-
-    /**
-     * Encapsulates information about a call being made to the Facebook application for Android. A unique String
-     * call ID is used to track calls through their lifecycle.
-     */
-    public static class PendingCall implements Parcelable {
-        private UUID callId;
-        private Intent requestIntent;
-        private int requestCode;
-
-        /**
-         * Constructor.
-         *
-         * @param requestCode the request code for this app call
-         */
-        public PendingCall(int requestCode) {
-            callId = UUID.randomUUID();
-            this.requestCode = requestCode;
-        }
-
-        private PendingCall(Parcel in) {
-            callId = UUID.fromString(in.readString());
-            requestIntent = in.readParcelable(null);
-            requestCode = in.readInt();
-        }
-
-        private void setRequestIntent(Intent requestIntent) {
-            this.requestIntent = requestIntent;
-            this.requestIntent.putExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID, callId.toString());
-        }
-
-        /**
-         * Returns the Intent that was used to initiate this call to the Facebook application.
-         *
-         * @return the Intent
-         */
-        public Intent getRequestIntent() {
-            return requestIntent;
-        }
-
-        /**
-         * Returns the unique ID of this call to the Facebook application.
-         *
-         * @return the unique ID
-         */
-        public UUID getCallId() {
-            return callId;
-        }
-
-        private void setRequestCode(int requestCode) {
-            this.requestCode = requestCode;
-        }
-
-        /**
-         * Gets the request code for this call.
-         *
-         * @return the request code that will be passed to handleActivityResult upon completion.
-         */
-        public int getRequestCode() {
-            return requestCode;
-        }
-
-        @Override
-        public int describeContents() {
-            return 0;
-        }
-
-        @Override
-        public void writeToParcel(Parcel parcel, int i) {
-            parcel.writeString(callId.toString());
-            parcel.writeParcelable(requestIntent, 0);
-            parcel.writeInt(requestCode);
-        }
-
-        public static final Creator<PendingCall> CREATOR
-                = new Creator<PendingCall>() {
-            public PendingCall createFromParcel(Parcel in) {
-                return new PendingCall(in);
-            }
-
-            public PendingCall[] newArray(int size) {
-                return new PendingCall[size];
-            }
-        };
-    }
-}
diff --git a/facebook/src/com/facebook/widget/FacebookFragment.java b/facebook/src/com/facebook/widget/FacebookFragment.java
deleted file mode 100644
index e9849a8ab..000000000
--- a/facebook/src/com/facebook/widget/FacebookFragment.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import com.facebook.Session;
-import com.facebook.SessionLoginBehavior;
-import com.facebook.SessionState;
-import com.facebook.internal.SessionAuthorizationType;
-import com.facebook.internal.SessionTracker;
-
-import java.util.Date;
-import java.util.List;
-
-/**
- * <p>Basic implementation of a Fragment that uses a Session to perform 
- * Single Sign On (SSO). This class is package private, and is not intended
- * to be consumed by external applications.</p>
- * 
- * <p>The method {@link android.support.v4.app.Fragment#onActivityResult} is
- * used to manage the session information, so if you override it in a subclass, 
- * be sure to call {@code super.onActivityResult}.</p>
- * 
- * <p>The methods in this class are not thread-safe.</p>
- */
-class FacebookFragment extends Fragment {
-
-    private SessionTracker sessionTracker;
-
-    @Override
-    public void onActivityCreated(Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        sessionTracker = new SessionTracker(getActivity(), new DefaultSessionStatusCallback());
-    }
-    
-    /**
-     * Called when the activity that was launched exits. This method manages session
-     * information when a session is opened. If this method is overridden in subclasses,
-     * be sure to call {@code super.onActivityResult(...)} first.
-     */
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        sessionTracker.getSession().onActivityResult(this.getActivity(), requestCode, resultCode, data);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        sessionTracker.stopTracking();
-    }
-
-    /**
-     * Use the supplied Session object instead of the active Session.
-     *
-     * @param newSession the Session object to use
-     */
-    public void setSession(Session newSession) {
-        if (sessionTracker != null) {
-            sessionTracker.setSession(newSession);
-        }
-    }
-
-    // METHOD TO BE OVERRIDDEN
-    
-    /**
-     * Called when the session state changes. Override this method to take action
-     * on session state changes.
-     * 
-     * @param state the new state
-     * @param exception any exceptions that occurred during the state change
-     */
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-    }
-
-    // ACCESSORS (CANNOT BE OVERRIDDEN)
-    
-    /**
-     * Gets the current Session.
-     * 
-     * @return the current Session object.
-     */
-    protected final Session getSession() {
-        if (sessionTracker != null) {
-            return sessionTracker.getSession();
-        }
-        return null;
-    }
-
-    /**
-     * Determines whether the current session is open.
-     * 
-     * @return true if the current session is open
-     */
-    protected final boolean isSessionOpen() {
-        if (sessionTracker != null) {
-            return sessionTracker.getOpenSession() != null;
-        }
-        return false;
-    }
-    
-    /**
-     * Gets the current state of the session or null if no session has been created.
-     * 
-     * @return the current state of the session
-     */
-    protected final SessionState getSessionState() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            return (currentSession != null) ? currentSession.getState() : null;
-        }
-        return null;
-    }
-    
-    /**
-     * Gets the access token associated with the current session or null if no 
-     * session has been created.
-     * 
-     * @return the access token
-     */
-    protected final String getAccessToken() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            return (currentSession != null) ? currentSession.getAccessToken() : null;
-        }
-        return null;
-    }
-
-    /**
-     * Gets the date at which the current session will expire or null if no session 
-     * has been created.
-     * 
-     * @return the date at which the current session will expire
-     */
-    protected final Date getExpirationDate() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            return (currentSession != null) ? currentSession.getExpirationDate() : null;
-        }
-        return null;
-    }
-    
-    /**
-     * Closes the current session.
-     */
-    protected final void closeSession() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                currentSession.close();
-            }
-        }
-    }
-    
-    /**
-     * Closes the current session as well as clearing the token cache.
-     */
-    protected final void closeSessionAndClearTokenInformation() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                currentSession.closeAndClearTokenInformation();
-            }
-        }
-    }
-    
-    /**
-     * Gets the permissions associated with the current session or null if no session 
-     * has been created.
-     * 
-     * @return the permissions associated with the current session
-     */
-    protected final List<String> getSessionPermissions() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            return (currentSession != null) ? currentSession.getPermissions() : null;
-        }
-        return null;
-    }
-
-    /**
-     * Opens a new session. This method will use the application id from
-     * the associated meta-data value and an empty list of permissions.
-     */
-    protected final void openSession() {
-        openSessionForRead(null, null);
-    }
-
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions) {
-        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.READ);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If either applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
-        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If either applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.PUBLISH);
-    }
-
-    private void openSession(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode, SessionAuthorizationType authType) {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            if (currentSession == null || currentSession.getState().isClosed()) {
-                Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
-                Session.setActiveSession(session);
-                currentSession = session;
-            }
-            if (!currentSession.isOpened()) {
-                Session.OpenRequest openRequest = new Session.OpenRequest(this).
-                        setPermissions(permissions).
-                        setLoginBehavior(behavior).
-                        setRequestCode(activityCode);
-                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                    currentSession.openForPublish(openRequest);
-                } else {
-                    currentSession.openForRead(openRequest);
-                }
-            }
-        }
-    }
-
-    /**
-     * The default callback implementation for the session.
-     */
-    private class DefaultSessionStatusCallback implements Session.StatusCallback {
-
-        @Override
-        public void call(Session session, 
-                         SessionState state,
-                         Exception exception) {
-            FacebookFragment.this.onSessionStateChange(state, exception);
-        }
-        
-    }
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectCursor.java b/facebook/src/com/facebook/widget/GraphObjectCursor.java
deleted file mode 100644
index 9495535e0..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectCursor.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import com.facebook.model.GraphObject;
-
-interface GraphObjectCursor<T extends GraphObject> {
-    boolean isFromCache();
-
-    boolean areMoreObjectsAvailable();
-
-    int getCount();
-
-    int getPosition();
-
-    boolean move(int offset);
-
-    boolean moveToPosition(int position);
-
-    boolean moveToFirst();
-
-    boolean moveToLast();
-
-    boolean moveToNext();
-
-    boolean moveToPrevious();
-
-    boolean isFirst();
-
-    boolean isLast();
-
-    boolean isBeforeFirst();
-
-    boolean isAfterLast();
-
-    T getGraphObject();
-
-    void close();
-
-    boolean isClosed();
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
deleted file mode 100644
index 26b33c99d..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.os.Handler;
-import android.support.v4.content.Loader;
-import com.facebook.*;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.internal.CacheableRequestBatch;
-
-class GraphObjectPagingLoader<T extends GraphObject> extends Loader<SimpleGraphObjectCursor<T>> {
-    private final Class<T> graphObjectClass;
-    private boolean skipRoundtripIfCached;
-    private Request originalRequest;
-    private Request currentRequest;
-    private Request nextRequest;
-    private OnErrorListener onErrorListener;
-    private SimpleGraphObjectCursor<T> cursor;
-    private boolean appendResults = false;
-    private boolean loading = false;
-
-    public interface OnErrorListener {
-        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader);
-    }
-
-    public GraphObjectPagingLoader(Context context, Class<T> graphObjectClass) {
-        super(context);
-
-        this.graphObjectClass = graphObjectClass;
-    }
-
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    public void setOnErrorListener(OnErrorListener listener) {
-        this.onErrorListener = listener;
-    }
-
-    public SimpleGraphObjectCursor<T> getCursor() {
-        return cursor;
-    }
-
-    public void clearResults() {
-        nextRequest = null;
-        originalRequest = null;
-        currentRequest = null;
-
-        deliverResult(null);
-    }
-
-    public boolean isLoading() {
-        return loading;
-    }
-
-    public void startLoading(Request request, boolean skipRoundtripIfCached) {
-        originalRequest = request;
-        startLoading(request, skipRoundtripIfCached, 0);
-    }
-
-    public void refreshOriginalRequest(long afterDelay) {
-        if (originalRequest == null) {
-            throw new FacebookException(
-                    "refreshOriginalRequest may not be called until after startLoading has been called.");
-        }
-        startLoading(originalRequest, false, afterDelay);
-    }
-
-    public void followNextLink() {
-        if (nextRequest != null) {
-            appendResults = true;
-            currentRequest = nextRequest;
-
-            currentRequest.setCallback(new Request.Callback() {
-                @Override
-                public void onCompleted(Response response) {
-                    requestCompleted(response);
-                }
-            });
-
-            loading = true;
-            CacheableRequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
-            Request.executeBatchAsync(batch);
-        }
-    }
-
-    @Override
-    public void deliverResult(SimpleGraphObjectCursor<T> cursor) {
-        SimpleGraphObjectCursor<T> oldCursor = this.cursor;
-        this.cursor = cursor;
-
-        if (isStarted()) {
-            super.deliverResult(cursor);
-
-            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
-                oldCursor.close();
-            }
-        }
-    }
-
-    @Override
-    protected void onStartLoading() {
-        super.onStartLoading();
-
-        if (cursor != null) {
-            deliverResult(cursor);
-        }
-    }
-
-    private void startLoading(Request request, boolean skipRoundtripIfCached, long afterDelay) {
-        this.skipRoundtripIfCached = skipRoundtripIfCached;
-        appendResults = false;
-        nextRequest = null;
-        currentRequest = request;
-        currentRequest.setCallback(new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                requestCompleted(response);
-            }
-        });
-
-        // We are considered loading even if we have a delay.
-        loading = true;
-
-        final RequestBatch batch = putRequestIntoBatch(request, skipRoundtripIfCached);
-        Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                Request.executeBatchAsync(batch);
-            }
-        };
-        if (afterDelay == 0) {
-            r.run();
-        } else {
-            Handler handler = new Handler();
-            handler.postDelayed(r, afterDelay);
-        }
-    }
-
-    private CacheableRequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
-        // We just use the request URL as the cache key.
-        CacheableRequestBatch batch = new CacheableRequestBatch(request);
-        // We use the default cache key (request URL).
-        batch.setForceRoundTrip(!skipRoundtripIfCached);
-        return batch;
-    }
-
-    private void requestCompleted(Response response) {
-        Request request = response.getRequest();
-        if (request != currentRequest) {
-            return;
-        }
-
-        loading = false;
-        currentRequest = null;
-
-        FacebookRequestError requestError = response.getError();
-        FacebookException exception = (requestError == null) ? null : requestError.getException();
-        if (response.getGraphObject() == null && exception == null) {
-            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
-        }
-
-        if (exception != null) {
-            nextRequest = null;
-
-            if (onErrorListener != null) {
-                onErrorListener.onError(exception, this);
-            }
-        } else {
-            addResults(response);
-        }
-    }
-
-    private void addResults(Response response) {
-        SimpleGraphObjectCursor<T> cursorToModify = (cursor == null || !appendResults) ? new SimpleGraphObjectCursor<T>() :
-                new SimpleGraphObjectCursor<T>(cursor);
-
-        PagedResults result = response.getGraphObjectAs(PagedResults.class);
-        boolean fromCache = response.getIsFromCache();
-
-        GraphObjectList<T> data = result.getData().castToListOf(graphObjectClass);
-        boolean haveData = data.size() > 0;
-
-        if (haveData) {
-            nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
-
-            cursorToModify.addGraphObjects(data, fromCache);
-            cursorToModify.setMoreObjectsAvailable(true);
-        }
-
-        if (!haveData) {
-            cursorToModify.setMoreObjectsAvailable(false);
-            cursorToModify.setFromCache(fromCache);
-
-            nextRequest = null;
-        }
-
-        // Once we get any set of results NOT from the cache, stop trying to get any future ones
-        // from it.
-        if (!fromCache) {
-            skipRoundtripIfCached = false;
-        }
-
-        deliverResult(cursorToModify);
-    }
-
-    interface PagedResults extends GraphObject {
-        GraphObjectList<GraphObject> getData();
-    }
-}
diff --git a/facebook/src/com/facebook/widget/LoginButton.java b/facebook/src/com/facebook/widget/LoginButton.java
deleted file mode 100644
index ce67f6955..000000000
--- a/facebook/src/com/facebook/widget/LoginButton.java
+++ /dev/null
@@ -1,746 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.res.TypedArray;
-import android.graphics.Typeface;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.Button;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphUser;
-import com.facebook.internal.SessionAuthorizationType;
-import com.facebook.internal.SessionTracker;
-import com.facebook.internal.Utility;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Log In/Log Out button that maintains session state and logs
- * in/out for the app.
- * <p/>
- * This control will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class LoginButton extends Button {
-
-    private static final String TAG = LoginButton.class.getName();
-    private String applicationId = null;
-    private SessionTracker sessionTracker;
-    private GraphUser user = null;
-    private Session userInfoSession = null; // the Session used to fetch the current user info
-    private boolean confirmLogout;
-    private boolean fetchUserInfo;
-    private String loginText;
-    private String logoutText;
-    private UserInfoChangedCallback userInfoChangedCallback;
-    private Fragment parentFragment;
-    private LoginButtonProperties properties = new LoginButtonProperties();
-    private String loginLogoutEventName = AnalyticsEvents.EVENT_LOGIN_VIEW_USAGE;
-
-    static class LoginButtonProperties {
-        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
-        private List<String> permissions = Collections.<String>emptyList();
-        private SessionAuthorizationType authorizationType = null;
-        private OnErrorListener onErrorListener;
-        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
-        private Session.StatusCallback sessionStatusCallback;
-
-        public void setOnErrorListener(OnErrorListener onErrorListener) {
-            this.onErrorListener = onErrorListener;
-        }
-
-        public OnErrorListener getOnErrorListener() {
-            return onErrorListener;
-        }
-
-        public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            this.defaultAudience = defaultAudience;
-        }
-
-        public SessionDefaultAudience getDefaultAudience() {
-            return defaultAudience;
-        }
-
-        public void setReadPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.PUBLISH.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setReadPermissions after setPublishPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.READ, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.READ;
-            }
-        }
-
-        public void setPublishPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.READ.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setPublishPermissions after setReadPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.PUBLISH, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.PUBLISH;
-            }
-        }
-
-        private boolean validatePermissions(List<String> permissions,
-                SessionAuthorizationType authType, Session currentSession) {
-            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                if (Utility.isNullOrEmpty(permissions)) {
-                    throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
-                }
-            }
-            if (currentSession != null && currentSession.isOpened()) {
-                if (!Utility.isSubset(permissions, currentSession.getPermissions())) {
-                    Log.e(TAG, "Cannot set additional permissions when session is already open.");
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        List<String> getPermissions() {
-            return permissions;
-        }
-
-        public void clearPermissions() {
-            permissions = null;
-            authorizationType = null;
-        }
-
-        public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            this.loginBehavior = loginBehavior;
-        }
-
-        public SessionLoginBehavior getLoginBehavior() {
-            return loginBehavior;
-        }
-
-        public void setSessionStatusCallback(Session.StatusCallback callback) {
-            this.sessionStatusCallback = callback;
-        }
-
-        public Session.StatusCallback getSessionStatusCallback() {
-            return sessionStatusCallback;
-        }
-    }
-
-    /**
-     * Specifies a callback interface that will be called when the button's notion of the current
-     * user changes (if the fetch_user_info attribute is true for this control).
-     */
-    public interface UserInfoChangedCallback {
-        /**
-         * Called when the current user changes.
-         * @param user  the current user, or null if there is no user
-         */
-        void onUserInfoFetched(GraphUser user);
-    }
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while logging in.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Create the LoginButton.
-     *
-     * @see View#View(Context)
-     */
-    public LoginButton(Context context) {
-        super(context);
-        initializeActiveSessionWithCachedToken(context);
-        // since onFinishInflate won't be called, we need to finish initialization ourselves
-        finishInit();
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML
-     *
-     * @see View#View(Context, AttributeSet)
-     */
-    public LoginButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        if (attrs.getStyleAttribute() == 0) {
-            // apparently there's no method of setting a default style in xml,
-            // so in case the users do not explicitly specify a style, we need
-            // to use sensible defaults.
-            this.setGravity(Gravity.CENTER);
-            this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
-            this.setTextSize(TypedValue.COMPLEX_UNIT_PX,
-                    getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
-            this.setTypeface(Typeface.DEFAULT_BOLD);
-            if (isInEditMode()) {
-                // cannot use a drawable in edit mode, so setting the background color instead
-                // of a background resource.
-                this.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
-                // hardcoding in edit mode as getResources().getString() doesn't seem to work in IntelliJ
-                loginText = "Log in with Facebook";
-            } else {
-                this.setBackgroundResource(R.drawable.com_facebook_button_blue);
-                this.setCompoundDrawablesWithIntrinsicBounds(R.drawable.com_facebook_inverse_icon, 0, 0, 0);
-                this.setCompoundDrawablePadding(
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_compound_drawable_padding));
-                this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
-            }
-        }
-        parseAttributes(attrs);
-        if (!isInEditMode()) {
-            initializeActiveSessionWithCachedToken(context);
-        }        
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML and applying a style.
-     *
-     * @see View#View(Context, AttributeSet, int)
-     */
-    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        parseAttributes(attrs);
-        initializeActiveSessionWithCachedToken(context);
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of LoginButton to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        properties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of LoginButton.
-     *
-     * @return The OnErrorListener
-     */
-    public OnErrorListener getOnErrorListener() {
-        return properties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        properties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return properties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        properties.setReadPermissions(permissions, sessionTracker.getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(String... permissions) {
-        properties.setReadPermissions(Arrays.asList(permissions), sessionTracker.getSession());
-    }
-
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        properties.setPublishPermissions(permissions, sessionTracker.getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(String... permissions) {
-        properties.setPublishPermissions(Arrays.asList(permissions), sessionTracker.getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        properties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        properties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return properties.getLoginBehavior();
-    }
-
-    /**
-     * Set the application ID to be used to open the session.
-     *
-     * @param applicationId the application ID to use
-     */
-    public void setApplicationId(String applicationId) {
-        this.applicationId = applicationId;
-    }
-
-    /**
-     * Gets the callback interface that will be called when the current user changes.
-     * @return the callback interface
-     */
-    public UserInfoChangedCallback getUserInfoChangedCallback() {
-        return userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called when the current user changes.
-     *
-     * @param userInfoChangedCallback   the callback interface
-     */
-    public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCallback) {
-        this.userInfoChangedCallback = userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes. Note that updates will only be sent to the
-     * callback while the LoginButton is actually attached to a window.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        properties.setSessionStatusCallback(callback);
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return properties.getSessionStatusCallback();
-    }
-
-    /**
-     * Provides an implementation for {@link Activity#onActivityResult
-     * onActivityResult} that updates the Session based on information returned
-     * during the authorization flow. The Activity containing this view
-     * should forward the resulting onActivityResult call here to
-     * update the Session state based on the contents of the resultCode and
-     * data.
-     *
-     * @param requestCode
-     *            The requestCode parameter from the forwarded call. When this
-     *            onActivityResult occurs as part of Facebook authorization
-     *            flow, this value is the activityCode passed to open or
-     *            authorize.
-     * @param resultCode
-     *            An int containing the resultCode parameter from the forwarded
-     *            call.
-     * @param data
-     *            The Intent passed as the data parameter from the forwarded
-     *            call.
-     * @return A boolean indicating whether the requestCode matched a pending
-     *         authorization request for this Session.
-     * @see Session#onActivityResult(Activity, int, int, Intent)
-     */
-    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-        Session session = sessionTracker.getSession();
-        if (session != null) {
-            return session.onActivityResult((Activity)getContext(), requestCode,
-                    resultCode, data);
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws FacebookException if errors occur during the loading of user information
-     */
-    public void setSession(Session newSession) {
-        sessionTracker.setSession(newSession);
-        fetchUserInfo();
-        setButtonText();
-    }
-
-    @Override
-    public void onFinishInflate() {
-        super.onFinishInflate();
-        finishInit();
-    }
-
-    private void finishInit() {
-        setOnClickListener(new LoginClickListener());
-        setButtonText();
-        if (!isInEditMode()) {
-            sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
-            fetchUserInfo();
-        }
-    }
-
-    /**
-     * Sets the fragment that contains this control. This allows the LoginButton to be
-     * embedded inside a Fragment, and will allow the fragment to receive the
-     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
-     * call rather than the Activity.
-     *
-     * @param fragment the fragment that contains this control
-     */
-    public void setFragment(Fragment fragment) {
-        parentFragment = fragment;
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (sessionTracker != null && !sessionTracker.isTracking()) {
-            sessionTracker.startTracking();
-            fetchUserInfo();
-            setButtonText();
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        if (sessionTracker != null) {
-            sessionTracker.stopTracking();
-        }
-    }
-
-    // For testing purposes only
-    List<String> getPermissions() {
-        return properties.getPermissions();
-    }
-
-    void setProperties(LoginButtonProperties properties) {
-        this.properties = properties;
-    }
-
-    void setLoginLogoutEventName(String eventName) {
-        loginLogoutEventName = eventName;
-    }
-
-    private void parseAttributes(AttributeSet attrs) {
-        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_login_view);
-        confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_confirm_logout, true);
-        fetchUserInfo = a.getBoolean(R.styleable.com_facebook_login_view_fetch_user_info, true);
-        loginText = a.getString(R.styleable.com_facebook_login_view_login_text);
-        logoutText = a.getString(R.styleable.com_facebook_login_view_logout_text);
-        a.recycle();
-    }
-
-    private void setButtonText() {
-        if (sessionTracker != null && sessionTracker.getOpenSession() != null) {
-            setText((logoutText != null) ? logoutText :
-                    getResources().getString(R.string.com_facebook_loginview_log_out_button));
-        } else {
-            setText((loginText != null) ? loginText :
-                    getResources().getString(R.string.com_facebook_loginview_log_in_button));
-        }
-    }
-
-    private boolean initializeActiveSessionWithCachedToken(Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        Session session = Session.getActiveSession();
-        if (session != null) {
-            return session.isOpened();
-        }
-
-        String applicationId = Utility.getMetadataApplicationId(context);
-        if (applicationId == null) {
-            return false;
-        }
-
-        return Session.openActiveSessionFromCache(context) != null;
-    }
-
-    private void fetchUserInfo() {
-        if (fetchUserInfo) {
-            final Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                if (currentSession != userInfoSession) {
-                    Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                        @Override
-                        public void onCompleted(GraphUser me,  Response response) {
-                            if (currentSession == sessionTracker.getOpenSession()) {
-                                user = me;
-                                if (userInfoChangedCallback != null) {
-                                    userInfoChangedCallback.onUserInfoFetched(user);
-                                }
-                            }
-                            if (response.getError() != null) {
-                                handleError(response.getError().getException());
-                            }
-                        }
-                    });
-                    Request.executeBatchAsync(request);
-                    userInfoSession = currentSession;
-                }
-            } else {
-                user = null;
-                if (userInfoChangedCallback != null) {
-                    userInfoChangedCallback.onUserInfoFetched(user);
-                }
-            }
-        }
-    }
-
-    private class LoginClickListener implements OnClickListener {
-
-        @Override
-        public void onClick(View v) {
-            Context context = getContext();
-            final Session openSession = sessionTracker.getOpenSession();
-
-            if (openSession != null) {
-                // If the Session is currently open, it must mean we need to log out
-                if (confirmLogout) {
-                    // Create a confirmation dialog
-                    String logout = getResources().getString(R.string.com_facebook_loginview_log_out_action);
-                    String cancel = getResources().getString(R.string.com_facebook_loginview_cancel_action);
-                    String message;
-                    if (user != null && user.getName() != null) {
-                        message = String.format(getResources().getString(R.string.com_facebook_loginview_logged_in_as), user.getName());
-                    } else {
-                        message = getResources().getString(R.string.com_facebook_loginview_logged_in_using_facebook);
-                    }
-                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
-                    builder.setMessage(message)
-                           .setCancelable(true)
-                           .setPositiveButton(logout, new DialogInterface.OnClickListener() {
-                               public void onClick(DialogInterface dialog, int which) {
-                                   openSession.closeAndClearTokenInformation();
-                               }
-                           })
-                           .setNegativeButton(cancel, null);
-                    builder.create().show();
-                } else {
-                    openSession.closeAndClearTokenInformation();
-                }
-            } else {
-                Session currentSession = sessionTracker.getSession();
-                if (currentSession == null || currentSession.getState().isClosed()) {
-                    sessionTracker.setSession(null);
-                    Session session = new Session.Builder(context).setApplicationId(applicationId).build();
-                    Session.setActiveSession(session);
-                    currentSession = session;
-                }
-                if (!currentSession.isOpened()) {
-                    Session.OpenRequest openRequest = null;
-                    if (parentFragment != null) {
-                        openRequest = new Session.OpenRequest(parentFragment);
-                    } else if (context instanceof Activity) {
-                        openRequest = new Session.OpenRequest((Activity)context);
-                    }
-
-                    if (openRequest != null) {
-                        openRequest.setDefaultAudience(properties.defaultAudience);
-                        openRequest.setPermissions(properties.permissions);
-                        openRequest.setLoginBehavior(properties.loginBehavior);
-
-                        if (SessionAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
-                            currentSession.openForPublish(openRequest);
-                        } else {
-                            currentSession.openForRead(openRequest);
-                        }
-                    }
-                }
-            }
-
-            AppEventsLogger logger = AppEventsLogger.newLogger(getContext());
-
-            Bundle parameters = new Bundle();
-            parameters.putInt("logging_in", (openSession != null) ? 0 : 1);
-
-            logger.logSdkEvent(loginLogoutEventName, null, parameters);
-        }
-    }
-
-    private class LoginButtonCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state,
-                         Exception exception) {
-            fetchUserInfo();
-            setButtonText();
-
-            // if the client has a status callback registered, call it, otherwise
-            // call the default handleError method, but don't call both
-            if (properties.sessionStatusCallback != null) {
-                properties.sessionStatusCallback.call(session, state, exception);
-            } else if (exception != null) {
-                handleError(exception);
-            }
-        }
-    };
-
-    void handleError(Exception exception) {
-        if (properties.onErrorListener != null) {
-            if (exception instanceof FacebookException) {
-                properties.onErrorListener.onError((FacebookException)exception);
-            } else {
-                properties.onErrorListener.onError(new FacebookException(exception));
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/UserSettingsFragment.java b/facebook/src/com/facebook/widget/UserSettingsFragment.java
deleted file mode 100644
index ed6cc9ceb..000000000
--- a/facebook/src/com/facebook/widget/UserSettingsFragment.java
+++ /dev/null
@@ -1,452 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.internal.ImageDownloader;
-import com.facebook.internal.ImageRequest;
-import com.facebook.internal.ImageResponse;
-import com.facebook.model.GraphUser;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * A Fragment that displays a Login/Logout button as well as the user's
- * profile picture and name when logged in.
- * <p/>
- * This Fragment will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class UserSettingsFragment extends FacebookFragment {
-
-    private static final String NAME = "name";
-    private static final String ID = "id";
-    private static final String PICTURE = "picture";
-    private static final String FIELDS = "fields";
-    
-    private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
-
-    private LoginButton loginButton;
-    private LoginButton.LoginButtonProperties loginButtonProperties = new LoginButton.LoginButtonProperties();
-    private TextView connectedStateLabel;
-    private GraphUser user;
-    private Session userInfoSession; // the Session used to fetch the current user info
-    private Drawable userProfilePic;
-    private String userProfilePicID;
-    private Session.StatusCallback sessionStatusCallback;
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View view = inflater.inflate(R.layout.com_facebook_usersettingsfragment, container, false);
-        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_usersettingsfragment_login_button);
-        loginButton.setProperties(loginButtonProperties);
-        loginButton.setFragment(this);
-        loginButton.setLoginLogoutEventName(AnalyticsEvents.EVENT_USER_SETTINGS_USAGE);
-
-        Session session = getSession();
-        if (session != null && !session.equals(Session.getActiveSession())) {
-            loginButton.setSession(session);
-        }
-        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_usersettingsfragment_profile_name);
-        
-        // if no background is set for some reason, then default to Facebook blue
-        if (view.getBackground() == null) {
-            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
-        } else {
-            view.getBackground().setDither(true);
-        }
-        return view;
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setRetainInstance(true);
-    }
-
-    /**
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void onResume() {
-        super.onResume();
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void setSession(Session newSession) {
-        super.setSession(newSession);
-        if (loginButton != null) {
-            loginButton.setSession(newSession);
-        }
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        loginButtonProperties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return loginButtonProperties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        loginButtonProperties.setReadPermissions(permissions, getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(String... permissions) {
-        loginButtonProperties.setReadPermissions(Arrays.asList(permissions), getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        loginButtonProperties.setPublishPermissions(permissions, getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(String... permissions) {
-        loginButtonProperties.setPublishPermissions(Arrays.asList(permissions), getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        loginButtonProperties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        loginButtonProperties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return loginButtonProperties.getLoginBehavior();
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of UserSettingsFragment to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
-        loginButtonProperties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of UserSettingsFragment.
-     *
-     * @return The OnErrorListener
-     */
-    public LoginButton.OnErrorListener getOnErrorListener() {
-        return loginButtonProperties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        this.sessionStatusCallback = callback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return sessionStatusCallback;
-    }
-
-    @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-        fetchUserInfo();
-        updateUI();
-
-        if (sessionStatusCallback != null) {
-            sessionStatusCallback.call(getSession(), state, exception);
-        }
-    }
-
-    // For Testing Only
-    List<String> getPermissions() {
-        return loginButtonProperties.getPermissions();
-    }
-
-    private void fetchUserInfo() {
-        final Session currentSession = getSession();
-        if (currentSession != null && currentSession.isOpened()) {
-            if (currentSession != userInfoSession) {
-                Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                    @Override
-                    public void onCompleted(GraphUser me, Response response) {
-                        if (currentSession == getSession()) {
-                            user = me;
-                            updateUI();
-                        }
-                        if (response.getError() != null) {
-                            loginButton.handleError(response.getError().getException());
-                        }
-                    }
-                });
-                Bundle parameters = new Bundle();
-                parameters.putString(FIELDS, REQUEST_FIELDS);
-                request.setParameters(parameters);
-                Request.executeBatchAsync(request);
-                userInfoSession = currentSession;
-            }
-        } else {
-            user = null;
-        }
-    }
-    
-    private void updateUI() {
-        if (!isAdded()) {
-            return;
-        }
-        if (isSessionOpen()) {
-            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_text_color));
-            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
-                    getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_shadow_color));
-            
-            if (user != null) {
-                ImageRequest request = getImageRequest();
-                if (request != null) {
-                    URI requestUrl = request.getImageUri();
-                    // Do we already have the right picture? If so, leave it alone.
-                    if (!requestUrl.equals(connectedStateLabel.getTag())) {
-                        if (user.getId().equals(userProfilePicID)) {
-                            connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
-                            connectedStateLabel.setTag(requestUrl);
-                        } else {
-                            ImageDownloader.downloadAsync(request);
-                        }
-                    }
-                }
-                connectedStateLabel.setText(user.getName());
-            } else {
-                connectedStateLabel.setText(getResources().getString(
-                        R.string.com_facebook_usersettingsfragment_logged_in));
-                Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
-                noProfilePic.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
-            }
-        } else {
-            int textColor = getResources().getColor(R.color.com_facebook_usersettingsfragment_not_connected_text_color);
-            connectedStateLabel.setTextColor(textColor);
-            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
-            connectedStateLabel.setText(getResources().getString(
-                    R.string.com_facebook_usersettingsfragment_not_logged_in));
-            connectedStateLabel.setCompoundDrawables(null, null, null, null);
-            connectedStateLabel.setTag(null);
-        }
-    }
-
-    private ImageRequest getImageRequest() {
-        ImageRequest request = null;
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getActivity(),
-                    ImageRequest.getProfilePictureUrl(
-                            user.getId(),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height)));
-
-            request = requestBuilder.setCallerTag(this)
-                    .setCallback(
-                            new ImageRequest.Callback() {
-                                @Override
-                                public void onCompleted(ImageResponse response) {
-                                    processImageResponse(user.getId(), response);
-                                }
-                            })
-                    .build();
-        } catch (URISyntaxException e) {
-        }
-        return request;
-    }
-
-    private void processImageResponse(String id, ImageResponse response) {
-        if (response != null) {
-            Bitmap bitmap = response.getBitmap();
-            if (bitmap != null) {
-                BitmapDrawable drawable = new BitmapDrawable(UserSettingsFragment.this.getResources(), bitmap);
-                drawable.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                userProfilePic = drawable;
-                userProfilePicID = id;
-                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
-                connectedStateLabel.setTag(response.getRequest().getImageUri());
-            }
-        }
-    }
-}
diff --git a/facebook/tests/.classpath b/facebook/tests/.classpath
deleted file mode 100644
index 90ce10bab..000000000
--- a/facebook/tests/.classpath
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/facebook/tests/.project b/facebook/tests/.project
deleted file mode 100644
index 82993b5a8..000000000
--- a/facebook/tests/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SDKTests</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/facebook/tests/AndroidManifest.xml b/facebook/tests/AndroidManifest.xml
index 1509af65d..f7625cff2 100644
--- a/facebook/tests/AndroidManifest.xml
+++ b/facebook/tests/AndroidManifest.xml
@@ -1,24 +1,41 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
 <!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.facebook.sdk.tests"
           android:versionCode="1"
           android:versionName="1.0">
     <uses-permission android:name="android.permission.INTERNET"></uses-permission>
-    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="7"/>
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="19"/>
     <!-- We add an application tag here just so that we can indicate that
          this package needs to link against the android.test library,
          which is needed when building test cases. -->
     <application>
         <uses-library android:name="android.test.runner"/>
         <activity android:name="com.facebook.FacebookTestCase$FacebookTestActivity"/>
-        <activity android:name="com.facebook.widget.FriendPickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.PlacePickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.GraphObjectPagingLoaderTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.UserSettingsFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.LoginActivity" />
+        <activity android:name="com.facebook.FacebookActivity" />
         <activity android:name="com.facebook.FacebookActivityTests$FacebookTestActivity" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+        <meta-data android:name="com.facebook.sdk.ClientToken" android:value="@string/client_token"/>
     </application>
     <!--
     This declares that this application uses the instrumentation test runner targeting
diff --git a/facebook/tests/ant.properties b/facebook/tests/ant.properties
deleted file mode 100644
index 928de2ff9..000000000
--- a/facebook/tests/ant.properties
+++ /dev/null
@@ -1,20 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-# Removed based on advice at code.google.com/p/android/issues/detail?id=21108#c2
-# and the comment that follows.
-# tested.project.dir=../TestApp
diff --git a/facebook/tests/build.gradle b/facebook/tests/build.gradle
index 1a7be02eb..246fc95ba 100644
--- a/facebook/tests/build.gradle
+++ b/facebook/tests/build.gradle
@@ -1,17 +1,23 @@
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':facebook')
-    compile project(':TestApp')
+    compile 'org.mockito:mockito-core:1.10.8'
+    compile 'com.google.dexmaker:dexmaker:1.2'
+    compile 'com.google.dexmaker:dexmaker-mockito:1.2'
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
@@ -19,11 +25,12 @@ android {
             manifest.srcFile 'AndroidManifest.xml'
             java.srcDirs = ['src']
             res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
         }
 
-        instrumentTest {
+        androidTest {
             java.srcDirs = ['src']
-            assets.srcDirs = ['assets']
+            res.srcDirs = ['res']
         }
     }
 }
diff --git a/facebook/tests/build.xml b/facebook/tests/build.xml
deleted file mode 100644
index 34c89faa8..000000000
--- a/facebook/tests/build.xml
+++ /dev/null
@@ -1,101 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="FacebookSdkTests" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-    <!-- SDK Tools r15 workaround -->
-    <property name="tested.manifest.package" value="com.facebook.sdk.tests" />
-
-    <!-- This seems to have no effect.  The value remains android.test.AndroidTestRunner -->
-    <!-- <property name="test.runner" value="android.test.InstrumentationTestRunner" /> -->
-
-    <target name="run-tests">
-      <echo>Running tests...</echo>
-      <exec executable="${adb}" failonerror="true">
-        <arg line="${adb.device.arg}" />
-        <arg value="shell" />
-        <arg value="am" />
-        <arg value="instrument" />
-        <arg value="-w" />
-        <!-- was <arg value="${tested.manifest.package}/${test.runner}" /> -->
-        <arg value="${tested.manifest.package}/android.test.InstrumentationTestRunner" />
-      </exec>
-    </target>
-</project>
diff --git a/facebook/tests/project.properties b/facebook/tests/project.properties
deleted file mode 100644
index 705d57d8d..000000000
--- a/facebook/tests/project.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-test.runner=android.test.AndroidTestRunner
-android.library.reference.1=../../facebook
diff --git a/facebook/tests/res/layout/friend_picker_test_layout_1.xml b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
deleted file mode 100644
index 4cffc58e7..000000000
--- a/facebook/tests/res/layout/friend_picker_test_layout_1.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <fragment
-            android:id="@+id/friend_picker_fragment"
-            android:name="com.facebook.widget.FriendPickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="false"
-            app:multi_select="false"
-            app:extra_fields="middle_name,link"
-            />
-</LinearLayout>
diff --git a/facebook/tests/res/layout/place_picker_test_layout_1.xml b/facebook/tests/res/layout/place_picker_test_layout_1.xml
deleted file mode 100644
index ec77493cb..000000000
--- a/facebook/tests/res/layout/place_picker_test_layout_1.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <fragment
-            android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.widget.PlacePickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="false"
-            app:radius_in_meters="75"
-            app:results_limit="5"
-            app:search_text="coffee"
-            app:extra_fields="checkins,general_info"
-            />
-</LinearLayout>
diff --git a/facebook/tests/res/values/strings.xml b/facebook/tests/res/values/strings.xml
index 05dacbbfd..7d06d60df 100644
--- a/facebook/tests/res/values/strings.xml
+++ b/facebook/tests/res/values/strings.xml
@@ -1,20 +1,25 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
     <string name="app_id">1234567890</string>
+    <string name="client_token">abcdef123456</string>
 </resources>
diff --git a/facebook/tests/src/com/facebook/AccessTokenTests.java b/facebook/tests/src/com/facebook/AccessTokenTests.java
deleted file mode 100644
index 09220b0f9..000000000
--- a/facebook/tests/src/com/facebook/AccessTokenTests.java
+++ /dev/null
@@ -1,280 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-public final class AccessTokenTests extends AndroidTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testEmptyToken() {
-        List<String> permissions = Utility.arrayList();
-        AccessToken token = AccessToken.createEmptyToken(permissions);
-        TestUtils.assertSamePermissions(permissions, token);
-        assertEquals("", token.getToken());
-        assertTrue(token.isInvalid());
-        assertTrue(token.getExpires().before(new Date()));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testEmptyTokenWithPermissions() {
-        List<String> permissions = Utility.arrayList("stream_publish");
-        AccessToken token = AccessToken.createEmptyToken(permissions);
-        TestUtils.assertSamePermissions(permissions, token);
-        assertEquals("", token.getToken());
-        assertTrue(token.isInvalid());
-        assertTrue(token.getExpires().before(new Date()));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromDialog() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Bundle bundle = new Bundle();
-        bundle.putString("access_token", token);
-        bundle.putString("expires_in", "60");
-
-        AccessToken accessToken = AccessToken.createFromWebBundle(permissions, bundle, AccessTokenSource.WEB_VIEW);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.WEB_VIEW, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromSSOWithExpiresString() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Intent intent = new Intent();
-        intent.putExtra("access_token", token);
-        intent.putExtra("expires_in", "60");
-        intent.putExtra("extra_extra", "Something unrelated");
-
-        AccessToken accessToken = AccessToken
-                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromSSOWithExpiresLong() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Intent intent = new Intent();
-        intent.putExtra("access_token", token);
-        intent.putExtra("expires_in", 60L);
-        intent.putExtra("extra_extra", "Something unrelated");
-
-        AccessToken accessToken = AccessToken
-                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromNativeLogin() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        long nowSeconds = new Date().getTime() / 1000;
-        Intent intent = new Intent();
-        intent.putExtra(NativeProtocol.EXTRA_ACCESS_TOKEN, token);
-        intent.putExtra(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, nowSeconds + 60L);
-        intent.putExtra(NativeProtocol.EXTRA_PERMISSIONS, permissions);
-
-        AccessToken accessToken = AccessToken.createFromNativeLogin(
-                intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCacheRoundtrip() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-        Date later = TestUtils.nowPlusSeconds(60);
-        Date earlier = TestUtils.nowPlusSeconds(-60);
-
-        Bundle bundle = new Bundle();
-        TokenCachingStrategy.putToken(bundle, token);
-        TokenCachingStrategy.putExpirationDate(bundle, later);
-        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
-        TokenCachingStrategy.putPermissions(bundle, permissions);
-
-        AccessToken accessToken = AccessToken.createFromCache(bundle);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-
-        Bundle cache = accessToken.toCacheBundle();
-        TestUtils.assertEqualContents(bundle, cache);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCachePutGet() {
-        Bundle bundle = new Bundle();
-
-        for (String token : new String[] { "", "A completely random token value" }) {
-            TokenCachingStrategy.putToken(bundle, token);
-            assertEquals(token, TokenCachingStrategy.getToken(bundle));
-        }
-
-        for (Date date : new Date[] { new Date(42), new Date() }) {
-            TokenCachingStrategy.putExpirationDate(bundle, date);
-            assertEquals(date, TokenCachingStrategy.getExpirationDate(bundle));
-
-            TokenCachingStrategy.putLastRefreshDate(bundle, date);
-            assertEquals(date, TokenCachingStrategy.getLastRefreshDate(bundle));
-        }
-
-        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
-            TokenCachingStrategy.putExpirationMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCachingStrategy.getExpirationMilliseconds(bundle));
-
-            TokenCachingStrategy.putLastRefreshMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCachingStrategy.getLastRefreshMilliseconds(bundle));
-        }
-
-        for (AccessTokenSource source : AccessTokenSource.values()) {
-            TokenCachingStrategy.putSource(bundle, source);
-            assertEquals(source, TokenCachingStrategy.getSource(bundle));
-        }
-
-        List<String> normalList = Arrays.asList("", "Another completely random token value");
-        List<String> emptyList = Arrays.asList();
-        ArrayList<String> normalArrayList = new ArrayList<String>(normalList);
-        ArrayList<String> emptyArrayList = new ArrayList<String>();
-        @SuppressWarnings("unchecked")
-        List<List<String>> permissionLists = Arrays
-                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
-        for (List<String> list : permissionLists) {
-            TokenCachingStrategy.putPermissions(bundle, list);
-            TestUtils.assertSamePermissions(list, TokenCachingStrategy.getPermissions(bundle));
-        }
-        normalArrayList.add(null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testBasicSerialization() throws IOException {
-        AccessToken accessToken = AccessToken.createFromString("a token",
-                Arrays.asList("permission_1", "permission_2"), AccessTokenSource.WEB_VIEW);
-        AccessToken res = TestUtils.serializeAndUnserialize(accessToken);
-        
-        // if one field got serialized most likely all other non transient fields
-        // got serialized correctly.
-        assertEquals(accessToken.getPermissions(), res.getPermissions());
-        assertEquals(accessToken.getToken(), res.getToken());
-        assertEquals(accessToken.getSource(), res.getSource());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testPermissionsAreImmutable() {
-        List<String> permissions = Arrays.asList("go to Jail", "do not pass Go");
-        AccessToken accessToken = new AccessToken("some token", new Date(), permissions,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
-
-        permissions = accessToken.getPermissions();
-
-        try {
-            permissions.add("can't touch this");
-            fail();
-        } catch (UnsupportedOperationException ex) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateFromExistingTokenDefaults() {
-        final String token = "A token of my esteem";
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
-
-        assertEquals(token, accessToken.getToken());
-        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertEquals(0, accessToken.getPermissions().size());
-        // Allow slight variation for test execution time
-        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
-        assertTrue(delta < 1000);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateFromExistingToken() {
-        final String token = "A token of my esteem";
-        final List<String> permissions = Arrays.asList("walk", "chew gum");
-        final Date expires = new Date(2025, 5, 3);
-        final Date lastRefresh = new Date(2023, 8, 15);
-        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
-
-        AccessToken accessToken = AccessToken
-                .createFromExistingAccessToken(token, expires, lastRefresh, source, permissions);
-
-        assertEquals(token, accessToken.getToken());
-        assertEquals(expires, accessToken.getExpires());
-        assertEquals(lastRefresh, accessToken.getLastRefresh());
-        assertEquals(source, accessToken.getSource());
-        assertEquals(permissions, accessToken.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/AppEventsLoggerTests.java b/facebook/tests/src/com/facebook/AppEventsLoggerTests.java
deleted file mode 100644
index e9d99bfc5..000000000
--- a/facebook/tests/src/com/facebook/AppEventsLoggerTests.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.support.v4.content.LocalBroadcastManager;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.util.HashMap;
-import java.util.List;
-
-public class AppEventsLoggerTests extends FacebookTestCase {
-    public void testSimpleCall() throws InterruptedException {
-        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);
-
-        TestSession session1 = TestSession.createSessionWithSharedUser(getActivity(), null);
-        TestSession session2 = TestSession.createSessionWithSharedUser(getActivity(), null, SECOND_TEST_USER_TAG);
-
-        AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), session1);
-        AppEventsLogger logger2 = AppEventsLogger.newLogger(getActivity(), session2);
-
-        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
-        waitForBroadcastReceiver.incrementExpectCount();
-
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        // Need to get notifications on another thread so we can wait for them.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                broadcastManager.registerReceiver(waitForBroadcastReceiver,
-                        new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
-            }
-        }, true);
-
-        logger1.logEvent("an_event");
-        logger2.logEvent("another_event");
-
-        logger1.flush();
-
-        waitForBroadcastReceiver.waitForExpectedCalls();
-
-        closeBlockerAndAssertSuccess();
-
-        broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
-    }
-
-    public void testPersistedEvents() throws IOException, ClassNotFoundException {
-        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);
-
-        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        // Need to get notifications on another thread so we can wait for them.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                broadcastManager.registerReceiver(waitForBroadcastReceiver,
-                        new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
-            }
-        }, true);
-
-        getActivity().getFileStreamPath(AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME).delete();
-
-        TestSession session1 = TestSession.createSessionWithSharedUser(getActivity(), null);
-        AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), session1);
-
-        logger1.logEvent("an_event");
-
-        AppEventsLogger.onContextStop();
-
-        FileInputStream fis = getActivity().openFileInput(AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME);
-        assertNotNull(fis);
-
-        ObjectInputStream ois = new ObjectInputStream(fis);
-        Object obj = ois.readObject();
-        ois.close();
-
-        assertTrue(obj instanceof HashMap);
-
-        logger1.flush();
-
-        logger1.logEvent("another_event");
-
-        waitForBroadcastReceiver.incrementExpectCount();
-        logger1.flush();
-
-        waitForBroadcastReceiver.waitForExpectedCalls();
-        List<Intent> receivedIntents = waitForBroadcastReceiver.getReceivedIntents();
-        assertEquals(1, receivedIntents.size());
-
-        Intent intent = receivedIntents.get(0);
-        assertNotNull(intent);
-
-        assertEquals(2, intent.getIntExtra(AppEventsLogger.APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, 0));
-        broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
-    }
-
-    @SuppressWarnings("deprecation")
-    public void testInsightsLoggerCompatibility() throws InterruptedException {
-        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.AUTO);
-
-        TestSession session1 = TestSession.createSessionWithSharedUser(getActivity(), null);
-
-        InsightsLogger logger1 = InsightsLogger.newLogger(getActivity(), null, null, session1);
-
-        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
-        waitForBroadcastReceiver.incrementExpectCount();
-
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        // Need to get notifications on another thread so we can wait for them.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                broadcastManager.registerReceiver(waitForBroadcastReceiver,
-                        new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
-            }
-        }, true);
-
-        logger1.logConversionPixel("foo", 1.0);
-
-        // For some reason the flush can take an extraordinary amount of time, so increasing
-        // the timeout here to prevent failures.
-        waitForBroadcastReceiver.waitForExpectedCalls(600*1000);
-
-        closeBlockerAndAssertSuccess();
-
-        broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
-    }
-}
diff --git a/facebook/tests/src/com/facebook/AsyncRequestTests.java b/facebook/tests/src/com/facebook/AsyncRequestTests.java
index 07857df61..dc535c559 100644
--- a/facebook/tests/src/com/facebook/AsyncRequestTests.java
+++ b/facebook/tests/src/com/facebook/AsyncRequestTests.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -20,13 +24,14 @@
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
+
+import com.facebook.share.internal.ShareInternalUtility;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
 
 import java.net.HttpURLConnection;
 import java.util.Arrays;
-import java.util.List;
 
 public class AsyncRequestTests extends FacebookTestCase {
 
@@ -34,9 +39,9 @@
     @MediumTest
     @LargeTest
     public void testCanLaunchAsyncRequestFromUiThread() {
-        Request request = Request.newPostRequest(null, "me/feeds", null, null);
+        GraphRequest request = GraphRequest.newPostRequest(null, "me/feeds", null, null);
         try {
-            TestRequestAsyncTask task = createAsyncTaskOnUiThread(request);
+            TestGraphRequestAsyncTask task = createAsyncTaskOnUiThread(request);
             assertNotNull(task);
         } catch (Throwable throwable) {
             assertNull(throwable);
@@ -48,7 +53,7 @@ public void testCanLaunchAsyncRequestFromUiThread() {
     @LargeTest
     public void testExecuteWithNullRequestsThrows() throws Exception {
         try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask((Request[]) null);
+            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask((GraphRequest[]) null);
 
             task.executeOnBlockerThread();
 
@@ -64,7 +69,7 @@ public void testExecuteWithNullRequestsThrows() throws Exception {
     @LargeTest
     public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
         try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] {});
+            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(new GraphRequest[] {});
 
             task.executeOnBlockerThread();
 
@@ -80,7 +85,8 @@ public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
     @LargeTest
     public void testExecuteBatchWithNullRequestThrows() throws Exception {
         try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] { null });
+            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
+                    new GraphRequest[] { null });
 
             task.executeOnBlockerThread();
 
@@ -95,16 +101,18 @@ public void testExecuteBatchWithNullRequestThrows() throws Exception {
     @MediumTest
     @LargeTest
     public void testExecuteSingleGet() {
-        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        GraphRequest request = new GraphRequest(accessToken, "TourEiffel", null, null,
+                new ExpectSuccessCallback() {
             @Override
-            protected void performAsserts(Response response) {
+            protected void performAsserts(GraphResponse response) {
                 assertNotNull(response);
-                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-                assertEquals("Paris", graphPlace.getLocation().getCity());
+                JSONObject graphPlace = response.getJSONObject();
+                assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
             }
         });
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);
 
         task.executeOnBlockerThread();
 
@@ -115,17 +123,19 @@ protected void performAsserts(Response response) {
     @MediumTest
     @LargeTest
     public void testExecuteSingleGetUsingHttpURLConnection() {
-        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        GraphRequest request = new GraphRequest(accessToken, "TourEiffel", null, null,
+                new ExpectSuccessCallback() {
             @Override
-            protected void performAsserts(Response response) {
+            protected void performAsserts(GraphResponse response) {
                 assertNotNull(response);
-                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-                assertEquals("Paris", graphPlace.getLocation().getCity());
+                JSONObject graphPlace = response.getJSONObject();
+                assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
             }
         });
-        HttpURLConnection connection = Request.toHttpConnection(request);
+        HttpURLConnection connection = GraphRequest.toHttpConnection(request);
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(connection, Arrays.asList(new Request[] { request }));
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(connection, Arrays.asList(new GraphRequest[] { request }));
 
         task.executeOnBlockerThread();
 
@@ -136,9 +146,11 @@ protected void performAsserts(Response response) {
     @MediumTest
     @LargeTest
     public void testExecuteSingleGetFailureCase() {
-        Request request = new Request(null, "-1", null, null, new ExpectFailureCallback());
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        GraphRequest request = new GraphRequest(accessToken, "-1", null, null,
+                new ExpectFailureCallback());
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);
 
         task.executeOnBlockerThread();
 
@@ -150,10 +162,10 @@ public void testExecuteSingleGetFailureCase() {
     @MediumTest
     @LargeTest
     public void testBatchWithoutAppIDIsError() throws Throwable {
-        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request1, request2);
 
         task.executeOnBlockerThread();
 
@@ -163,20 +175,22 @@ public void testBatchWithoutAppIDIsError() throws Throwable {
 
     @LargeTest
     public void testMixedSuccessAndFailure() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
         final int NUM_REQUESTS = 8;
-        Request[] requests = new Request[NUM_REQUESTS];
+        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
         for (int i = 0; i < NUM_REQUESTS; ++i) {
             boolean shouldSucceed = (i % 2) == 1;
             if (shouldSucceed) {
-                requests[i] = new Request(session, "me", null, null, new ExpectSuccessCallback());
+                requests[i] = new GraphRequest(accessToken, "me", null, null,
+                        new ExpectSuccessCallback());
             } else {
-                requests[i] = new Request(session, "-1", null, null, new ExpectFailureCallback());
+                requests[i] = new GraphRequest(accessToken, "-1", null, null,
+                        new ExpectFailureCallback());
             }
         }
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requests);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requests);
 
         task.executeOnBlockerThread();
 
@@ -186,16 +200,15 @@ public void testMixedSuccessAndFailure() {
 
     @MediumTest
     @LargeTest
-    @SuppressWarnings("deprecation")
     public void testStaticExecuteMeAsync() {
-        final TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        class MeCallback extends ExpectSuccessCallback implements Request.GraphUserCallback {
+        class MeCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONObjectCallback {
             @Override
-            public void onCompleted(GraphUser me, Response response) {
+            public void onCompleted(JSONObject me, GraphResponse response) {
                 assertNotNull(me);
-                assertEquals(session.getTestUserId(), me.getId());
-                RequestTests.validateMeResponse(session, response);
+                assertEquals(accessToken.getUserId(), me.optString("id"));
+                RequestTests.validateMeResponse(accessToken, response);
                 onCompleted(response);
             }
         }
@@ -203,7 +216,7 @@ public void onCompleted(GraphUser me, Response response) {
         runOnBlockerThread(new Runnable() {
             @Override
             public void run() {
-                Request.executeMeRequestAsync(session, new MeCallback());
+                GraphRequest.newMeRequest(accessToken, new MeCallback()).executeAsync();
             }
         }, false);
         waitAndAssertSuccess(1);
@@ -211,15 +224,14 @@ public void run() {
 
     @MediumTest
     @LargeTest
-    @SuppressWarnings("deprecation")
     public void testStaticExecuteMyFriendsAsync() {
-        final TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        class FriendsCallback extends ExpectSuccessCallback implements Request.GraphUserListCallback {
+        class FriendsCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONArrayCallback {
             @Override
-            public void onCompleted(List<GraphUser> friends, Response response) {
+            public void onCompleted(JSONArray friends, GraphResponse response) {
                 assertNotNull(friends);
-                RequestTests.validateMyFriendsResponse(session, response);
+                RequestTests.validateMyFriendsResponse(response);
                 onCompleted(response);
             }
         }
@@ -227,7 +239,7 @@ public void onCompleted(List<GraphUser> friends, Response response) {
         runOnBlockerThread(new Runnable() {
             @Override
             public void run() {
-                Request.executeMyFriendsRequestAsync(session, new FriendsCallback());
+                GraphRequest.newMyFriendsRequest(accessToken, new FriendsCallback()).executeAsync();
             }
         }, false);
         waitAndAssertSuccess(1);
@@ -235,7 +247,8 @@ public void run() {
 
     @LargeTest
     public void testBatchUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
+                "user_photos", "publish_actions");
 
         final int image1Size = 120;
         final int image2Size = 150;
@@ -243,32 +256,52 @@ public void testBatchUploadPhoto() {
         Bitmap bitmap1 = createTestBitmap(image1Size);
         Bitmap bitmap2 = createTestBitmap(image2Size);
 
-        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        GraphRequest uploadRequest1 = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                bitmap1,
+                null,
+                null);
         uploadRequest1.setBatchEntryName("uploadRequest1");
-        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        GraphRequest uploadRequest2 = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                bitmap2,
+                null,
+                null);
         uploadRequest2.setBatchEntryName("uploadRequest2");
-        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}", null, null,
+        GraphRequest getRequest1 = new GraphRequest(
+                accessToken,
+                "{result=uploadRequest1:$.id}",
+                null,
+                null,
                 new ExpectSuccessCallback() {
                     @Override
-                    protected void performAsserts(Response response) {
+                    protected void performAsserts(GraphResponse response) {
                         assertNotNull(response);
-                        GraphObject retrievedPhoto = response.getGraphObject();
+                        JSONObject retrievedPhoto = response.getJSONObject();
                         assertNotNull(retrievedPhoto);
-                        assertEquals(image1Size, retrievedPhoto.getProperty("width"));
+                        assertEquals(image1Size, retrievedPhoto.optInt("width"));
                     }
                 });
-        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}", null, null,
+        GraphRequest getRequest2 = new GraphRequest(
+                accessToken,
+                "{result=uploadRequest2:$.id}",
+                null,
+                null,
                 new ExpectSuccessCallback() {
                     @Override
-                    protected void performAsserts(Response response) {
+                    protected void performAsserts(GraphResponse response) {
                         assertNotNull(response);
-                        GraphObject retrievedPhoto = response.getGraphObject();
+                        JSONObject retrievedPhoto = response.getJSONObject();
                         assertNotNull(retrievedPhoto);
-                        assertEquals(image2Size, retrievedPhoto.getProperty("width"));
+                        assertEquals(image2Size, retrievedPhoto.optInt("width"));
                     }
                 });
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
+                uploadRequest1,
+                uploadRequest2,
+                getRequest1,
+                getRequest2);
         task.executeOnBlockerThread();
 
         // Wait on 3 signals: getRequest1, getRequest2, and task will all signal.
@@ -278,16 +311,17 @@ protected void performAsserts(Response response) {
     @MediumTest
     @LargeTest
     public void testShortTimeoutCausesFailure() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request = new Request(session, "me/likes", null, null, new ExpectFailureCallback());
+        GraphRequest request = new GraphRequest(accessToken, "me/likes", null, null,
+                new ExpectFailureCallback());
 
-        RequestBatch requestBatch = new RequestBatch(request);
+        GraphRequestBatch requestBatch = new GraphRequestBatch(request);
 
         // 1 millisecond timeout should be too short for response from server.
         requestBatch.setTimeout(1);
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
         task.executeOnBlockerThread();
 
         // Note: plus 1, because the overall async task signals as well.
@@ -296,16 +330,17 @@ public void testShortTimeoutCausesFailure() {
 
     @LargeTest
     public void testLongTimeoutAllowsSuccess() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request = new Request(session, "me", null, null, new ExpectSuccessCallback());
+        GraphRequest request = new GraphRequest(accessToken, "me", null, null,
+                new ExpectSuccessCallback());
 
-        RequestBatch requestBatch = new RequestBatch(request);
+        GraphRequestBatch requestBatch = new GraphRequestBatch(request);
 
         // 10 second timeout should be long enough for successful response from server.
         requestBatch.setTimeout(10000);
 
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
         task.executeOnBlockerThread();
 
         // Note: plus 1, because the overall async task signals as well.
diff --git a/facebook/tests/src/com/facebook/AuthorizationClientTests.java b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
deleted file mode 100644
index 0a96adf35..000000000
--- a/facebook/tests/src/com/facebook/AuthorizationClientTests.java
+++ /dev/null
@@ -1,684 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.model.GraphMultiResult;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.model.GraphUser;
-
-import java.io.*;
-import java.util.*;
-
-public class AuthorizationClientTests extends FacebookTestCase {
-    private static final String ACCESS_TOKEN = "An access token";
-    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
-    private static final ArrayList<String> PERMISSIONS = new ArrayList<String>(
-            Arrays.asList("go outside", "come back in"));
-    private static final String ERROR_MESSAGE = "This is bad!";
-
-    class MockAuthorizationClient extends AuthorizationClient {
-        Result result;
-        boolean triedNextHandler = false;
-
-        MockAuthorizationClient() {
-            setContext(getActivity());
-        }
-
-        AuthorizationClient.AuthorizationRequest getRequest() {
-            return pendingRequest;
-        }
-
-        void setRequest(AuthorizationClient.AuthorizationRequest request) {
-            pendingRequest = request;
-        }
-
-        @Override
-        void complete(Result result) {
-            this.result = result;
-        }
-
-        @Override
-        void tryNextHandler() {
-            triedNextHandler = true;
-        }
-    }
-
-    // WebViewAuthHandler tests
-
-    AuthorizationClient.AuthorizationRequest createRequest() {
-        Session.AuthorizationRequest request = new Session.AuthorizationRequest(getActivity());
-        request.setPermissions(PERMISSIONS);
-        return request.getAuthorizationClientRequest();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putString("access_token", ACCESS_TOKEN);
-        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
-        bundle.putString("code", "Something else");
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, bundle, null);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesCancel() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookOperationCanceledException());
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesError() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewChecksInternetPermission() {
-        MockAuthorizationClient client = new MockAuthorizationClient() {
-            @Override
-            int checkPermission(String permission) {
-                return PackageManager.PERMISSION_DENIED;
-            }
-        };
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    // GetTokenAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesSuccessWithAllPermissions() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.getTokenCompleted(request, bundle);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesSuccessWithSomePermissions() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, new ArrayList<String>(Arrays.asList("go outside")));
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-
-        client.setRequest(request);
-        handler.getTokenCompleted(request, bundle);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-
-        assertEquals(1, request.getPermissions().size());
-        assertTrue(request.getPermissions().contains("come back in"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesNoResult() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-
-        client.setRequest(request);
-        handler.getTokenCompleted(request, null);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-    }
-
-    // KatanaLoginDialogAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesCancel() {
-        Bundle bundle = new Bundle();
-        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_USER_CANCELED);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNull(token);
-        assertNull(client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesError() {
-        Bundle bundle = new Bundle();
-        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, ERROR_MESSAGE);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNull(token);
-        assertNotNull(client.result.errorMessage);
-        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesDisabled() {
-        Bundle bundle = new Bundle();
-        bundle.putInt(NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.PROTOCOL_VERSION_20121101);
-        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_SERVICE_DISABLED);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-    }
-
-    // KatanaProxyAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putLong(AccessToken.EXPIRES_IN_KEY, EXPIRES_IN_DELTA);
-        bundle.putString(AccessToken.ACCESS_TOKEN_KEY, ACCESS_TOKEN);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesCancel() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", ERROR_MESSAGE);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-        assertTrue(client.result.errorMessage.contains(ERROR_MESSAGE));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesCancelErrorMessage() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", "access_denied");
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        assertNull(client.result.token);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesDisabled() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", "service_disabled");
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-    }
-
-    // Reauthorization validation tests
-
-    class MockValidatingAuthorizationClient extends MockAuthorizationClient {
-        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
-        private List<String> permissionsToReport = Arrays.asList();
-        private TestBlocker blocker;
-
-        public MockValidatingAuthorizationClient(TestBlocker blocker) {
-            this.blocker = blocker;
-        }
-
-        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
-            mapAccessTokenToFbid.put(accessToken, fbid);
-        }
-
-        public void addAccessTokenToFbidMapping(AccessToken accessToken, String fbid) {
-            mapAccessTokenToFbid.put(accessToken.getToken(), fbid);
-        }
-
-        public void setPermissionsToReport(List<String> permissionsToReport) {
-            this.permissionsToReport = permissionsToReport;
-        }
-
-        @Override
-        void complete(Result result) {
-            super.complete(result);
-            blocker.signal();
-        }
-
-        @Override
-        Request createGetProfileIdRequest(final String accessToken) {
-            return new MockRequest() {
-                @Override
-                public Response createResponse() {
-                    String fbid = mapAccessTokenToFbid.get(accessToken);
-                    GraphUser user = GraphObject.Factory.create(GraphUser.class);
-                    user.setId(fbid);
-                    return new Response(this, null, user, false);
-                }
-            };
-        }
-
-        @Override
-        Request createGetPermissionsRequest(String accessToken) {
-            final List<String> permissions = permissionsToReport;
-            return new MockRequest() {
-                @Override
-                public Response createResponse() {
-                    GraphObject permissionsObject = GraphObject.Factory.create();
-                    if (permissions != null) {
-                        for (String permission : permissions) {
-                            permissionsObject.setProperty(permission, 1);
-                        }
-                    }
-                    GraphObjectList<GraphObject> data = GraphObject.Factory.createList(GraphObject.class);
-                    data.add(permissionsObject);
-
-                    GraphMultiResult result = GraphObject.Factory.create(GraphMultiResult.class);
-                    result.setProperty("data", data);
-
-                    return new Response(this, null, result, false);
-                }
-            };
-        }
-
-        @Override
-        RequestBatch createReauthValidationBatch(final Result pendingResult) {
-            RequestBatch batch = super.createReauthValidationBatch(pendingResult);
-
-            batch.setCallbackHandler(blocker.getHandler());
-            // Turn it into a MockRequestBatch.
-            return new MockRequestBatch(batch);
-        }
-    }
-
-    static final String USER_1_FBID = "user1";
-    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
-    static final String USER_2_FBID = "user2";
-    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
-
-    AuthorizationClient.AuthorizationRequest createNewPermissionRequest(String accessToken) {
-        Session.NewPermissionsRequest request = new Session.NewPermissionsRequest(getActivity(), PERMISSIONS);
-        request.setValidateSameFbidAsToken(accessToken);
-        return request.getAuthorizationClientRequest();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(PERMISSIONS);
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(request, token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(PERMISSIONS, resultToken.getPermissions());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithFewerPermissionsSucceeds() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(Arrays.asList("go outside"));
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(request, token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(Arrays.asList("go outside"), resultToken.getPermissions());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(PERMISSIONS);
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(request, token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLegacyReauthDoesntValidate() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        request.setIsLegacy(true);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(request, token);
-
-        client.completeAndValidate(result);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_2_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(PERMISSIONS, resultToken.getPermissions());
-    }
-
-    // Serialization tests
-
-    static class DoNothingAuthorizationClient extends AuthorizationClient {
-        // Don't actually do anything.
-        @Override
-        boolean tryCurrentHandler() {
-            return true;
-        }
-    }
-
-    public void testSerialization() throws IOException, ClassNotFoundException {
-        AuthorizationClient client = new DoNothingAuthorizationClient();
-
-        // Call this to set up some state.
-        client.setContext(getActivity());
-        client.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
-            @Override
-            public void onCompleted(AuthorizationClient.Result result) {
-            }
-        });
-        client.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
-            @Override
-            public void onBackgroundProcessingStarted() {
-            }
-
-            @Override
-            public void onBackgroundProcessingStopped() {
-            }
-        });
-        client.authorize(createRequest());
-
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);
-        outputStream.writeObject(client);
-        outputStream.close();
-
-        byte [] byteArray = byteArrayOutputStream.toByteArray();
-
-        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);
-        ObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);
-
-        Object obj = inputStream.readObject();
-        assertNotNull(obj);
-        assertTrue(obj instanceof AuthorizationClient);
-
-        AuthorizationClient resultClient = (AuthorizationClient)obj;
-        assertNull(resultClient.startActivityDelegate);
-        assertNull(resultClient.onCompletedListener);
-        assertNull(resultClient.backgroundProcessingListener);
-        assertNull(resultClient.context);
-        assertNotNull(resultClient.currentHandler);
-        assertTrue(resultClient.currentHandler instanceof AuthorizationClient.GetTokenAuthHandler);
-        assertNotNull(resultClient.handlersToTry);
-        assertTrue(resultClient.handlersToTry.size() > 0);
-        assertNotNull(resultClient.pendingRequest);
-        assertEquals(PERMISSIONS, resultClient.pendingRequest.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/BatchRequestTests.java b/facebook/tests/src/com/facebook/BatchRequestTests.java
index 7a863649f..8c3d656ef 100644
--- a/facebook/tests/src/com/facebook/BatchRequestTests.java
+++ b/facebook/tests/src/com/facebook/BatchRequestTests.java
@@ -1,30 +1,31 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 import android.graphics.Bitmap;
 import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.RequestBatch;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
-import com.facebook.internal.CacheableRequestBatch;
+
+import com.facebook.share.internal.ShareInternalUtility;
+
+import org.json.JSONObject;
 
 import java.io.IOException;
 import java.lang.Override;
@@ -37,109 +38,85 @@ protected void setUp() throws Exception {
         super.setUp();
 
         // Tests that need this set should explicitly set it.
-        Request.setDefaultBatchApplicationId(null);
+        GraphRequest.setDefaultBatchApplicationId(null);
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateEmptyRequestBatch() {
-        CacheableRequestBatch batch = new CacheableRequestBatch();
-
-        Request meRequest = Request.newMeRequest(null, null);
-        assertEquals(0, batch.size());
-        batch.add(meRequest);
-        assertEquals(1, batch.size());
-        assertEquals(meRequest, batch.get(0));
+    protected String[] getDefaultPermissions()
+    {
+        return new String[] { "email", "publish_actions", "read_stream" };
+    };
 
-        String key = "The Key";
-        assertNull(batch.getCacheKeyOverride());
-        batch.setCacheKeyOverride(key);
-        assertEquals(key, batch.getCacheKeyOverride());
-
-        assertTrue(!batch.getForceRoundTrip());
-        batch.setForceRoundTrip(true);
-        assertTrue(batch.getForceRoundTrip());
-    }
-
-    @SmallTest
-    @MediumTest
     @LargeTest
     public void testCreateNonemptyRequestBatch() {
-        Request meRequest = Request.newMeRequest(null, null);
+        GraphRequest meRequest = GraphRequest.newMeRequest(null, null);
 
-        RequestBatch batch = new RequestBatch(new Request[] { meRequest, meRequest });
+        GraphRequestBatch batch = new GraphRequestBatch(new GraphRequest[] { meRequest, meRequest });
         assertEquals(2, batch.size());
         assertEquals(meRequest, batch.get(0));
         assertEquals(meRequest, batch.get(1));
     }
 
-    @SmallTest
-    @MediumTest
     @LargeTest
     public void testBatchWithoutAppIDIsError() {
-        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
-        Request.executeBatchAndWait(request1, request2);
+        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+        GraphRequest.executeBatchAndWait(request1, request2);
     }
 
-    @MediumTest
     @LargeTest
     public void testExecuteBatchRequestsPathEncoding() throws IOException {
         // ensures that paths passed to batch requests are encoded properly before
         // we send it up to the server
 
-        setBatchApplicationIdForTestApp();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = new Request(null, "TourEiffel");
+        GraphRequest request1 = new GraphRequest(accessToken, "TourEiffel");
         request1.setBatchEntryName("eiffel");
         request1.setBatchEntryOmitResultOnSuccess(false);
-        Request request2 = new Request(null, "{result=eiffel:$.id}");
+        GraphRequest request2 = new GraphRequest(accessToken, "{result=eiffel:$.id}");
 
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
         assertEquals(2, responses.size());
         assertTrue(responses.get(0).getError() == null);
         assertTrue(responses.get(1).getError() == null);
 
-        GraphPlace eiffelTower1 = responses.get(0).getGraphObjectAs(GraphPlace.class);
-        GraphPlace eiffelTower2 = responses.get(1).getGraphObjectAs(GraphPlace.class);
+        JSONObject eiffelTower1 = responses.get(0).getJSONObject();
+        JSONObject eiffelTower2 = responses.get(1).getJSONObject();
         assertTrue(eiffelTower1 != null);
         assertTrue(eiffelTower2 != null);
 
-        assertEquals("Paris", eiffelTower1.getLocation().getCity());
-        assertEquals("Paris", eiffelTower2.getLocation().getCity());
+        assertEquals("Paris", eiffelTower1.optJSONObject("location").optString("city"));
+        assertEquals("Paris", eiffelTower2.optJSONObject("location").optString("city"));
     }
 
-    @MediumTest
     @LargeTest
     public void testExecuteBatchedGets() throws IOException {
-        setBatchApplicationIdForTestApp();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = new Request(null, "TourEiffel");
-        Request request2 = new Request(null, "SpaceNeedle");
+        GraphRequest request1 = new GraphRequest(accessToken, "TourEiffel");
+        GraphRequest request2 = new GraphRequest(accessToken, "SpaceNeedle");
 
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
         assertEquals(2, responses.size());
         assertTrue(responses.get(0).getError() == null);
         assertTrue(responses.get(1).getError() == null);
 
-        GraphPlace eiffelTower = responses.get(0).getGraphObjectAs(GraphPlace.class);
-        GraphPlace spaceNeedle = responses.get(1).getGraphObjectAs(GraphPlace.class);
+        JSONObject eiffelTower = responses.get(0).getJSONObject();
+        JSONObject spaceNeedle = responses.get(1).getJSONObject();
         assertTrue(eiffelTower != null);
         assertTrue(spaceNeedle != null);
 
-        assertEquals("Paris", eiffelTower.getLocation().getCity());
-        assertEquals("Seattle", spaceNeedle.getLocation().getCity());
+        assertEquals("Paris", eiffelTower.optJSONObject("location").optString("city"));
+        assertEquals("Seattle", spaceNeedle.optJSONObject("location").optString("city"));
     }
 
-    @MediumTest
     @LargeTest
     public void testFacebookErrorResponsesCreateErrors() {
         setBatchApplicationIdForTestApp();
 
-        Request request1 = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
-        Request request2 = new Request(null, "someotherstringthatshouldneverbeavalidfobjectid");
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        GraphRequest request1 = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
+        GraphRequest request2 = new GraphRequest(null, "someotherstringthatshouldneverbeavalidfobjectid");
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
 
         assertEquals(2, responses.size());
         assertTrue(responses.get(0).getError() != null);
@@ -153,169 +130,131 @@ public void testFacebookErrorResponsesCreateErrors() {
 
     @LargeTest
     public void testBatchPostStatusUpdate() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        GraphObject statusUpdate1 = createStatusUpdate("1");
-        GraphObject statusUpdate2 = createStatusUpdate("2");
+        JSONObject statusUpdate1 = createStatusUpdate("1");
+        JSONObject statusUpdate2 = createStatusUpdate("2");
 
-        Request postRequest1 = Request.newPostRequest(session, "me/feed", statusUpdate1, null);
+        GraphRequest postRequest1 = GraphRequest.newPostRequest(accessToken, "me/feed", statusUpdate1, null);
         postRequest1.setBatchEntryName("postRequest1");
-        Request postRequest2 = Request.newPostRequest(session, "me/feed", statusUpdate2, null);
+        postRequest1.setBatchEntryOmitResultOnSuccess(false);
+        GraphRequest postRequest2 = GraphRequest.newPostRequest(accessToken, "me/feed", statusUpdate2, null);
         postRequest2.setBatchEntryName("postRequest2");
-        Request getRequest1 = new Request(session, "{result=postRequest1:$.id}");
-        Request getRequest2 = new Request(session, "{result=postRequest2:$.id}");
+        postRequest2.setBatchEntryOmitResultOnSuccess(false);
+        GraphRequest getRequest1 = new GraphRequest(accessToken, "{result=postRequest1:$.id}");
+        GraphRequest getRequest2 = new GraphRequest(accessToken, "{result=postRequest2:$.id}");
 
-        List<Response> responses = Request.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
         assertNotNull(responses);
         assertEquals(4, responses.size());
         assertNoErrors(responses);
 
-        GraphObject retrievedStatusUpdate1 = responses.get(2).getGraphObject();
-        GraphObject retrievedStatusUpdate2 = responses.get(3).getGraphObject();
+        JSONObject retrievedStatusUpdate1 = responses.get(2).getJSONObject();
+        JSONObject retrievedStatusUpdate2 = responses.get(3).getJSONObject();
         assertNotNull(retrievedStatusUpdate1);
         assertNotNull(retrievedStatusUpdate2);
 
-        assertEquals(statusUpdate1.getProperty("message"), retrievedStatusUpdate1.getProperty("message"));
-        assertEquals(statusUpdate2.getProperty("message"), retrievedStatusUpdate2.getProperty("message"));
+        assertEquals(statusUpdate1.optString("message"), retrievedStatusUpdate1.optString("message"));
+        assertEquals(statusUpdate2.optString("message"), retrievedStatusUpdate2.optString("message"));
     }
 
     @LargeTest
     public void testTwoDifferentAccessTokens() {
-        TestSession session1 = openTestSessionWithSharedUser();
-        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
+        final AccessToken accessToken1 = getAccessTokenForSharedUser();
+        final AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);
 
-        Request request1 = Request.newMeRequest(session1, null);
-        Request request2 = Request.newMeRequest(session2, null);
+        GraphRequest request1 = GraphRequest.newMeRequest(accessToken1, null);
+        GraphRequest request2 = GraphRequest.newMeRequest(accessToken2, null);
 
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
         assertNotNull(responses);
         assertEquals(2, responses.size());
 
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+        JSONObject user1 = responses.get(0).getJSONObject();
+        JSONObject user2 = responses.get(1).getJSONObject();
 
         assertNotNull(user1);
         assertNotNull(user2);
 
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals(session1.getTestUserId(), user1.getId());
-        assertEquals(session2.getTestUserId(), user2.getId());
+        assertFalse(user1.optString("id").equals(user2.optString("id")));
+        assertEquals(accessToken1.getUserId(), user1.optString("id"));
+        assertEquals(accessToken2.getUserId(), user2.optString("id"));
     }
 
     @LargeTest
     public void testBatchWithValidSessionAndNoSession() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = new Request(session, "me");
-        Request request2 = new Request(null, "zuck");
+        GraphRequest request1 = new GraphRequest(accessToken, "me");
+        GraphRequest request2 = new GraphRequest(null, "me");
 
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
         assertNotNull(responses);
         assertEquals(2, responses.size());
 
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+        JSONObject user1 = responses.get(0).getJSONObject();
+        JSONObject user2 = responses.get(1).getJSONObject();
 
         assertNotNull(user1);
-        assertNotNull(user2);
+        assertNull(user2);
 
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals(session.getTestUserId(), user1.getId());
-        assertEquals("4", user2.getId());
+        assertEquals(accessToken.getUserId(), user1.optString("id"));
     }
 
     @LargeTest
     public void testBatchWithNoSessionAndValidSession() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request1 = new Request(null, "zuck");
-        Request request2 = new Request(session, "me");
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
-
-        assertNotNull(user1);
-        assertNotNull(user2);
-
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals("4", user1.getId());
-        assertEquals(session.getTestUserId(), user2.getId());
-    }
-
-    @LargeTest
-    public void testBatchWithTwoSessionlessRequestsAndDefaultAppID() {
-        TestSession session = getTestSessionWithSharedUser(null);
-        String appId = session.getApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = new Request(null, "zuck");
-        Request request2 = new Request(null, "zuck");
+        GraphRequest request1 = new GraphRequest(null, "me");
+        GraphRequest request2 = new GraphRequest(accessToken, "me");
 
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
         assertNotNull(responses);
         assertEquals(2, responses.size());
 
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+        JSONObject user1 = responses.get(0).getJSONObject();
+        JSONObject user2 = responses.get(1).getJSONObject();
 
-        assertNotNull(user1);
+        assertNull(user1);
         assertNotNull(user2);
 
-        assertEquals("4", user1.getId());
-        assertEquals("4", user2.getId());
+        assertEquals(accessToken.getUserId(), user2.optString("id"));
     }
 
     @LargeTest
     public void testMixedSuccessAndFailure() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
         final int NUM_REQUESTS = 8;
-        Request[] requests = new Request[NUM_REQUESTS];
+        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
         for (int i = 0; i < NUM_REQUESTS; ++i) {
             boolean shouldSucceed = (i % 2) == 1;
-            requests[i] = new Request(session, shouldSucceed ? "me" : "-1");
+            requests[i] = new GraphRequest(accessToken, shouldSucceed ? "me" : "-1");
         }
 
-        List<Response> responses = Request.executeBatchAndWait(requests);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
         assertNotNull(responses);
         assertEquals(NUM_REQUESTS, responses.size());
 
         for (int i = 0; i < NUM_REQUESTS; ++i) {
             boolean shouldSucceed = (i % 2) == 1;
 
-            Response response = responses.get(i);
+            GraphResponse response = responses.get(i);
             assertNotNull(response);
             if (shouldSucceed) {
                 assertNull(response.getError());
-                assertNotNull(response.getGraphObject());
+                assertNotNull(response.getJSONObject());
             } else {
                 assertNotNull(response.getError());
-                assertNull(response.getGraphObject());
+                assertNull(response.getJSONObject());
             }
         }
     }
 
-    @MediumTest
-    @LargeTest
-    public void testClosedSessionDoesntAppendAccessToken() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.close();
-        Request request1 = new Request(session, "me", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(session, "me", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(2);
-    }
-
     @LargeTest
     public void testBatchUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
+                "user_photos", "publish_actions");
 
         final int image1Size = 120;
         final int image2Size = 150;
@@ -323,42 +262,53 @@ public void testBatchUploadPhoto() {
         Bitmap bitmap1 = createTestBitmap(image1Size);
         Bitmap bitmap2 = createTestBitmap(image2Size);
 
-        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        GraphRequest uploadRequest1 = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                bitmap1,
+                null,
+                null);
         uploadRequest1.setBatchEntryName("uploadRequest1");
-        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        GraphRequest uploadRequest2 = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                bitmap2,
+                null,
+                null);
         uploadRequest2.setBatchEntryName("uploadRequest2");
-        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}");
-        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}");
-
-        List<Response> responses = Request.executeBatchAndWait(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        GraphRequest getRequest1 = new GraphRequest(accessToken, "{result=uploadRequest1:$.id}");
+        GraphRequest getRequest2 = new GraphRequest(accessToken, "{result=uploadRequest2:$.id}");
+
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(
+                uploadRequest1,
+                uploadRequest2,
+                getRequest1,
+                getRequest2);
         assertNotNull(responses);
         assertEquals(4, responses.size());
         assertNoErrors(responses);
 
-        GraphObject retrievedPhoto1 = responses.get(2).getGraphObject();
-        GraphObject retrievedPhoto2 = responses.get(3).getGraphObject();
+        JSONObject retrievedPhoto1 = responses.get(2).getJSONObject();
+        JSONObject retrievedPhoto2 = responses.get(3).getJSONObject();
         assertNotNull(retrievedPhoto1);
         assertNotNull(retrievedPhoto2);
 
-        assertEquals(image1Size, retrievedPhoto1.getProperty("width"));
-        assertEquals(image2Size, retrievedPhoto2.getProperty("width"));
+        assertEquals(image1Size, retrievedPhoto1.optInt("width"));
+        assertEquals(image2Size, retrievedPhoto2.optInt("width"));
     }
 
-    @MediumTest
     @LargeTest
     public void testCallbacksAreCalled() {
         setBatchApplicationIdForTestApp();
 
-        ArrayList<Request> requests = new ArrayList<Request>();
+        ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
         final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
 
         final int NUM_REQUESTS = 4;
         for (int i = 0; i < NUM_REQUESTS; ++i) {
-            Request request = new Request(null, "4");
+            GraphRequest request = new GraphRequest(null, "4");
 
-            request.setCallback(new Request.Callback() {
+            request.setCallback(new GraphRequest.Callback() {
                 @Override
-                public void onCompleted(Response response) {
+                public void onCompleted(GraphResponse response) {
                     calledBack.add(true);
                 }
             });
@@ -366,161 +316,64 @@ public void onCompleted(Response response) {
             requests.add(request);
         }
 
-        List<Response> responses = Request.executeBatchAndWait(requests);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
         assertNotNull(responses);
         assertTrue(calledBack.size() == NUM_REQUESTS);
     }
 
-    @MediumTest
-    @LargeTest
-    public void testCacheMyFriendsRequest() throws Exception {
-        TestUtils.clearFileLruCache(Response.getResponseCache());
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = Request.newMyFriendsRequest(session, null);
-
-        CacheableRequestBatch batch = new CacheableRequestBatch(request);
-        batch.setCacheKeyOverride("MyFriends");
-
-        // Running the request with empty cache should hit the server.
-        List<Response> responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        Response response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(!response.getIsFromCache());
 
-        // Running again should hit the cache.
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(response.getIsFromCache());
-
-        // Forcing roundtrip should hit the server again.
-        batch.setForceRoundTrip(true);
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(!response.getIsFromCache());
-
-        TestUtils.clearFileLruCache(Response.getResponseCache());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCacheMeAndMyFriendsRequest() throws Exception {
-        TestUtils.clearFileLruCache(Response.getResponseCache());
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request requestMe = Request.newMeRequest(session, null);
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
-
-        CacheableRequestBatch batch = new CacheableRequestBatch(new Request[] { requestMyFriends, requestMe });
-        batch.setCacheKeyOverride("MyFriends");
-
-        // Running the request with empty cache should hit the server.
-        List<Response> responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(!response.getIsFromCache());
-        }
-
-        // Running again should hit the cache.
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(response.getIsFromCache());
-        }
-
-        // Forcing roundtrip should hit the server again.
-        batch.setForceRoundTrip(true);
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(!response.getIsFromCache());
-        }
-
-        TestUtils.clearFileLruCache(Response.getResponseCache());
-    }
-
-    @MediumTest
     @LargeTest
     public void testExplicitDependencyDefaultsToOmitFirstResponse() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request requestMe = Request.newMeRequest(session, null);
+        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
         requestMe.setBatchEntryName("me_request");
 
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
         requestMyFriends.setBatchEntryDependsOn("me_request");
 
-        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);
 
-        Response meResponse = responses.get(0);
-        Response myFriendsResponse = responses.get(1);
+        GraphResponse meResponse = responses.get(0);
+        GraphResponse myFriendsResponse = responses.get(1);
 
-        assertNull(meResponse.getGraphObject());
-        assertNotNull(myFriendsResponse.getGraphObject());
+        assertNull(meResponse.getJSONObject());
+        assertNotNull(myFriendsResponse.getJSONObject());
     }
 
-    @MediumTest
     @LargeTest
     public void testExplicitDependencyCanIncludeFirstResponse() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request requestMe = Request.newMeRequest(session, null);
+        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
         requestMe.setBatchEntryName("me_request");
         requestMe.setBatchEntryOmitResultOnSuccess(false);
 
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
         requestMyFriends.setBatchEntryDependsOn("me_request");
 
-        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);
 
-        Response meResponse = responses.get(0);
-        Response myFriendsResponse = responses.get(1);
+        GraphResponse meResponse = responses.get(0);
+        GraphResponse myFriendsResponse = responses.get(1);
 
-        assertNotNull(meResponse.getGraphObject());
-        assertNotNull(myFriendsResponse.getGraphObject());
+        assertNotNull(meResponse.getJSONObject());
+        assertNotNull(myFriendsResponse.getJSONObject());
     }
 
-    @SmallTest
-    @MediumTest
     @LargeTest
     public void testAddAndRemoveBatchCallbacks() {
-        RequestBatch batch = new RequestBatch();
+        GraphRequestBatch batch = new GraphRequestBatch();
 
-        RequestBatch.Callback callback1 = new RequestBatch.Callback() {
+        GraphRequestBatch.Callback callback1 = new GraphRequestBatch.Callback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
             }
         };
 
-        RequestBatch.Callback callback2 = new RequestBatch.Callback() {
+        GraphRequestBatch.Callback callback2 = new GraphRequestBatch.Callback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
             }
         };
 
@@ -535,27 +388,26 @@ public void onBatchCompleted(RequestBatch batch) {
         assertEquals(0, batch.getCallbacks().size());
     }
 
-    @MediumTest
     @LargeTest
     public void testBatchCallbackIsCalled() {
         final AtomicInteger count = new AtomicInteger();
-        Request request1 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+        GraphRequest request1 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
                 count.incrementAndGet();
             }
         });
-        Request request2 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
                 count.incrementAndGet();
             }
         });
 
-        RequestBatch batch = new RequestBatch(request1, request2);
-        batch.addCallback(new RequestBatch.Callback() {
+        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
+        batch.addCallback(new GraphRequestBatch.Callback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
                 count.incrementAndGet();
             }
         });
@@ -564,61 +416,58 @@ public void onBatchCompleted(RequestBatch batch) {
         assertEquals(3, count.get());
     }
 
-    @MediumTest
     @LargeTest
     public void testBatchOnProgressCallbackIsCalled() {
         final AtomicInteger count = new AtomicInteger();
 
-        TestSession session = getTestSessionWithSharedUser(null);
-        String appId = session.getApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = Request.newGraphPathRequest(null, "4", null);
-        assertTrue(request1 != null);
+        String appId = getApplicationId();
+        GraphRequest.setDefaultBatchApplicationId(appId);
 
-        Request request2 = Request.newGraphPathRequest(null, "4", null);
-        assertTrue(request2 != null);
+        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
+        assertNotNull(request1);
+        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
+        assertNotNull(request2);
 
-        RequestBatch batch = new RequestBatch(request1, request2);
-        batch.addCallback(new RequestBatch.OnProgressCallback() {
+        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
+        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
             }
 
             @Override
-            public void onBatchProgress(RequestBatch batch, long current, long max) {
+            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                 count.incrementAndGet();
             }
         });
 
         batch.executeAndWait();
-        assertTrue(count.get() > 0);
+        assertEquals(1, count.get());
     }
 
-    @MediumTest
     @LargeTest
     public void testBatchLastOnProgressCallbackIsCalledOnce() {
         final AtomicInteger count = new AtomicInteger();
 
-        TestSession session = getTestSessionWithSharedUser(null);
-        String appId = session.getApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        Request request1 = Request.newGraphPathRequest(null, "4", null);
-        assertTrue(request1 != null);
+        String appId = getApplicationId();
+        GraphRequest.setDefaultBatchApplicationId(appId);
 
-        Request request2 = Request.newGraphPathRequest(null, "4", null);
-        assertTrue(request2 != null);
+        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
+        assertNotNull(request1);
+        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
+        assertNotNull(request2);
 
-
-        RequestBatch batch = new RequestBatch(request1, request2);
-        batch.addCallback(new RequestBatch.OnProgressCallback() {
+        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
+        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
             }
 
             @Override
-            public void onBatchProgress(RequestBatch batch, long current, long max) {
+            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                 if (current == max) {
                     count.incrementAndGet();
                 }
@@ -633,7 +482,6 @@ else if (current > max) {
     }
 
 
-    @MediumTest
     @LargeTest
     public void testMixedBatchCallbacks() {
         final AtomicInteger requestProgressCount = new AtomicInteger();
@@ -641,13 +489,15 @@ public void testMixedBatchCallbacks() {
         final AtomicInteger batchProgressCount = new AtomicInteger();
         final AtomicInteger batchCompletedCount = new AtomicInteger();
 
-        TestSession session = getTestSessionWithSharedUser(null);
-        String appId = session.getApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+
+        String appId = getApplicationId();
+        GraphRequest.setDefaultBatchApplicationId(appId);
 
-        Request request1 = Request.newGraphPathRequest(null, "4", new Request.OnProgressCallback() {
+        GraphRequest request1 = GraphRequest.newGraphPathRequest(
+                null, "4", new GraphRequest.OnProgressCallback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
                 requestCompletedCount.incrementAndGet();
             }
 
@@ -661,20 +511,20 @@ else if (current > max) {
                 }
             }
         });
-        assertTrue(request1 != null);
+        assertNotNull(request1);
 
-        Request request2 = Request.newGraphPathRequest(null, "4", null);
-        assertTrue(request2 != null);
+        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", null);
+        assertNotNull(request2);
 
-        RequestBatch batch = new RequestBatch(request1, request2);
-        batch.addCallback(new RequestBatch.OnProgressCallback() {
+        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
+        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
             @Override
-            public void onBatchCompleted(RequestBatch batch) {
+            public void onBatchCompleted(GraphRequestBatch batch) {
                 batchCompletedCount.incrementAndGet();
             }
 
             @Override
-            public void onBatchProgress(RequestBatch batch, long current, long max) {
+            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                 if (current == max) {
                     batchProgressCount.incrementAndGet();
                 } else if (current > max) {
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
index ad2753abe..17cc7ad83 100644
--- a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
+++ b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -25,14 +29,16 @@
 import android.os.Handler;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
-import com.facebook.model.GraphObject;
 import com.facebook.internal.Utility;
 import junit.framework.AssertionFailedError;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -45,6 +51,8 @@
 
     private static String applicationId;
     private static String applicationSecret;
+    private static String clientToken;
+    private static TestUserManager testUserManager;
 
     public final static String SECOND_TEST_USER_TAG = "Second";
     public final static String THIRD_TEST_USER_TAG = "Third";
@@ -62,56 +70,39 @@ public FacebookActivityTestCase(Class<T> activityClass) {
         super("", activityClass);
     }
 
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithSharedUser() {
-        return getTestSessionWithSharedUser(null);
-    }
-
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithSharedUser(String sessionUniqueUserTag) {
-        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, new ArrayList<String>());
-    }
+    protected String[] getDefaultPermissions() { return null; };
 
-    protected TestSession getTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            List<String> permissions) {
-        return TestSession.createSessionWithSharedUser(getActivity(), permissions, sessionUniqueUserTag);
+    protected AccessToken getAccessTokenForSharedUser() {
+        return getAccessTokenForSharedUser(null);
     }
 
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithPrivateUser(TestBlocker testBlocker) {
-        return TestSession.createSessionWithPrivateUser(getActivity(), null);
+    protected AccessToken getAccessTokenForSharedUser(String sessionUniqueUserTag) {
+        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag,
+                getDefaultPermissions());
     }
 
-    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker) {
-        return openTestSessionWithSharedUser(blocker, null);
+    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
+        List<String> permissions) {
+        return getTestUserManager().getAccessTokenForSharedUser(permissions, sessionUniqueUserTag);
     }
 
-    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker, String sessionUniqueUserTag) {
-        TestSession session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session, blocker);
-        return session;
-    }
-
-    protected TestSession openTestSessionWithSharedUser() {
-        return openTestSessionWithSharedUser((String) null);
-    }
-
-    protected TestSession openTestSessionWithSharedUser(String sessionUniqueUserTag) {
-        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
-    }
-
-    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            String... permissions) {
+    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
+                                                                      String... permissions) {
         List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
-        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissionList);
+        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag, permissionList);
     }
 
-    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            List<String> permissions) {
-        final TestBlocker blocker = getTestBlocker();
-        TestSession session = getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissions);
-        openSession(getActivity(), session, blocker);
-        return session;
+    protected TestUserManager getTestUserManager() {
+        if (testUserManager == null) {
+            synchronized (FacebookActivityTestCase.class) {
+                if (testUserManager == null) {
+                    readApplicationIdAndSecret();
+                    testUserManager = new TestUserManager(applicationSecret, applicationId);
+                }
+            }
+        }
+
+        return testUserManager;
     }
 
     // Turns exceptions from the TestBlocker into JUnit assertions
@@ -151,11 +142,11 @@ public void run() {
 
     protected synchronized void readApplicationIdAndSecret() {
         synchronized (FacebookTestCase.class) {
-            if (applicationId != null && applicationSecret != null) {
+            if (applicationId != null && applicationSecret != null && clientToken != null) {
                 return;
             }
 
-            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            AssetManager assets = getInstrumentation().getTargetContext().getResources().getAssets();
             InputStream stream = null;
             final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
                     + "you have run 'configure_unit_tests.sh'. Error: ";
@@ -172,13 +163,12 @@ protected synchronized void readApplicationIdAndSecret() {
 
                 applicationId = jsonObject.optString("applicationId");
                 applicationSecret = jsonObject.optString("applicationSecret");
+                clientToken = jsonObject.optString("clientToken");
 
-                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret)) {
-                    fail(errorMessage + "one or both config values are missing");
+                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret) ||
+                        Utility.isNullOrEmpty(clientToken)) {
+                    fail(errorMessage + "config values are missing");
                 }
-
-                TestSession.setTestApplicationId(applicationId);
-                TestSession.setTestApplicationSecret(applicationSecret);
             } catch (IOException e) {
                 fail(errorMessage + e.toString());
             } catch (JSONException e) {
@@ -195,47 +185,37 @@ protected synchronized void readApplicationIdAndSecret() {
         }
     }
 
-    protected void openSession(Activity activity, TestSession session) {
-        final TestBlocker blocker = getTestBlocker();
-        openSession(activity, session, blocker);
+    protected static String getApplicationId() {
+        return applicationId;
     }
 
-    protected void openSession(Activity activity, TestSession session, final TestBlocker blocker) {
-        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
-                setCallback(new Session.StatusCallback() {
-                    boolean signaled = false;
-
-                    @Override
-                    public void call(Session session, SessionState state, Exception exception) {
-                        if (exception != null) {
-                            Log.w(TAG,
-                                    "openSession: received an error opening session: " + exception.toString());
-                        }
-                        assertTrue(exception == null);
-                        // Only signal once, or we might screw up the count on the blocker.
-                        if (!signaled) {
-                            blocker.signal();
-                            signaled = true;
-                        }
-                    }
-                });
-
-        session.openForRead(openRequest);
-        waitAndAssertSuccess(blocker, 1);
+    protected static String getApplicationSecret() {
+        return applicationSecret;
     }
 
     protected void setUp() throws Exception {
         super.setUp();
 
+        // Make sure the logging is turned on.
+        FacebookSdk.setIsDebugEnabled(true);
+
         // Make sure we have read application ID and secret.
         readApplicationIdAndSecret();
 
+        FacebookSdk.sdkInitialize(getInstrumentation().getTargetContext());
+        FacebookSdk.setApplicationId(applicationId);
+        FacebookSdk.setClientToken(clientToken);
+
         // These are useful for debugging unit test failures.
-        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+        FacebookSdk.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        FacebookSdk.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
 
         // We want the UI thread to be in StrictMode to catch any violations.
         turnOnStrictModeForUiThread();
+
+        // Needed to bypass a dexmaker bug for mockito
+        System.setProperty("dexmaker.dexcache",
+                getInstrumentation().getTargetContext().getCacheDir().getPath());
     }
 
     protected void tearDown() throws Exception {
@@ -248,97 +228,107 @@ protected void tearDown() throws Exception {
         }
     }
 
-    protected Bundle getNativeLinkingExtras(String token) {
+    protected Bundle getNativeLinkingExtras(String token, String userId) {
+        readApplicationIdAndSecret();
+
         Bundle extras = new Bundle();
         String extraLaunchUriString = String
                 .format("fbrpc://facebook/nativethirdparty?app_id=%s&package_name=com.facebook.sdk.tests&class_name=com.facebook.FacebookActivityTests$FacebookTestActivity&access_token=%s",
-                        TestSession.getTestApplicationId(), token);
+                        applicationId, token);
         extras.putString("extra_launch_uri", extraLaunchUriString);
         extras.putString("expires_in", "3600");
-        extras.putLong("app_id", Long.parseLong(TestSession.getTestApplicationId()));
+        extras.putLong("app_id", Long.parseLong(applicationId));
         extras.putString("access_token", token);
+        if(userId != null && !userId.isEmpty()) {
+            extras.putString("user_id", userId);
+        }
 
         return extras;
     }
 
-    interface GraphObjectPostResult extends GraphObject {
-        String getId();
-    }
-
-    protected GraphObject getAndAssert(Session session, String id) {
-        Request request = new Request(session, id);
-        Response response = request.executeAndWait();
+    protected JSONObject getAndAssert(AccessToken accessToken, String id) {
+        GraphRequest request = new GraphRequest(accessToken, id);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObject result = response.getGraphObject();
+        JSONObject result = response.getJSONObject();
         assertNotNull(result);
 
         return result;
     }
 
-    protected GraphObject postGetAndAssert(Session session, String path, GraphObject graphObject) {
-        Request request = Request.newPostRequest(session, path, graphObject, null);
-        Response response = request.executeAndWait();
+    protected JSONObject postGetAndAssert(AccessToken accessToken, String path,
+                                          JSONObject graphObject) {
+        GraphRequest request = GraphRequest.newPostRequest(accessToken, path, graphObject, null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObjectPostResult result = response.getGraphObjectAs(GraphObjectPostResult.class);
+        JSONObject result = response.getJSONObject();
         assertNotNull(result);
-        assertNotNull(result.getId());
+        assertNotNull(result.optString("id"));
 
-        return getAndAssert(session, result.getId());
+        return getAndAssert(accessToken, result.optString("id"));
     }
 
     protected void setBatchApplicationIdForTestApp() {
-        String appId = TestSession.getTestApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
+        readApplicationIdAndSecret();
+        GraphRequest.setDefaultBatchApplicationId(applicationId);
     }
 
-    protected <U extends GraphObject> U batchCreateAndGet(Session session, String graphPath, GraphObject graphObject,
-            String fields, Class<U> resultClass) {
-        Request create = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
+    protected JSONObject batchCreateAndGet(AccessToken accessToken, String graphPath,
+                                           JSONObject graphObject, String fields) {
+        GraphRequest create = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
+                new ExpectSuccessCallback());
         create.setBatchEntryName("create");
-        Request get = Request.newGraphPathRequest(session, "{result=create:$.id}", new ExpectSuccessCallback());
+        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, "{result=create:$.id}",
+                new ExpectSuccessCallback());
         if (fields != null) {
             Bundle parameters = new Bundle();
             parameters.putString("fields", fields);
             get.setParameters(parameters);
         }
 
-        return batchPostAndGet(create, get, resultClass);
+        return batchPostAndGet(create, get);
     }
 
-    protected <U extends GraphObject> U batchUpdateAndGet(Session session, String graphPath, GraphObject graphObject,
-            String fields, Class<U> resultClass) {
-        Request update = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
-        Request get = Request.newGraphPathRequest(session, graphPath, new ExpectSuccessCallback());
+    protected JSONObject batchUpdateAndGet(AccessToken accessToken, String graphPath,
+                                           JSONObject graphObject, String fields) {
+        GraphRequest update = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
+                new ExpectSuccessCallback());
+        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, graphPath,
+                new ExpectSuccessCallback());
         if (fields != null) {
             Bundle parameters = new Bundle();
             parameters.putString("fields", fields);
             get.setParameters(parameters);
         }
 
-        return batchPostAndGet(update, get, resultClass);
+        return batchPostAndGet(update, get);
     }
 
-    protected <U extends GraphObject> U batchPostAndGet(Request post, Request get, Class<U> resultClass) {
-        List<Response> responses = Request.executeBatchAndWait(post, get);
+    protected JSONObject batchPostAndGet(GraphRequest post, GraphRequest get) {
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(post, get);
         assertEquals(2, responses.size());
 
-        U resultGraphObject = responses.get(1).getGraphObjectAs(resultClass);
+        JSONObject resultGraphObject = responses.get(1).getJSONObject();
         assertNotNull(resultGraphObject);
         return resultGraphObject;
     }
 
-    protected GraphObject createStatusUpdate(String unique) {
-        GraphObject statusUpdate = GraphObject.Factory.create();
+    protected JSONObject createStatusUpdate(String unique) {
+        JSONObject statusUpdate = new JSONObject();
         String message = String.format(
                 "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,%s", new Date(),
                 unique);
-        statusUpdate.setProperty("message", message);
+        try {
+            statusUpdate.put("message", message);
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
         return statusUpdate;
     }
 
@@ -348,20 +338,6 @@ protected Bitmap createTestBitmap(int size) {
         return image;
     }
 
-    protected void issueFriendRequest(TestSession session, String targetUserId) {
-        String graphPath = "me/friends/" + targetUserId;
-        Request request = Request.newPostRequest(session, graphPath, null, null);
-        Response response = request.executeAndWait();
-        // We will get a 400 error if the users are already friends.
-        FacebookRequestError error = response.getError();
-        assertTrue(error == null || error.getRequestStatusCode() == 400);
-    }
-
-    protected void makeTestUsersFriends(TestSession session1, TestSession session2) {
-        issueFriendRequest(session1, session2.getTestUserId());
-        issueFriendRequest(session2, session1.getTestUserId());
-    }
-
     protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
         long delta = Math.abs(expected.getTime() - actual.getTime());
         assertTrue(delta < deltaInMsec);
@@ -372,9 +348,9 @@ protected void assertDateDiffersWithinDelta(Date expected, Date actual, long exp
         assertTrue(delta < deltaInMsec);
     }
 
-    protected void assertNoErrors(List<Response> responses) {
+    protected void assertNoErrors(List<GraphResponse> responses) {
         for (int i = 0; i < responses.size(); ++i) {
-            Response response = responses.get(i);
+            GraphResponse response = responses.get(i);
             assertNotNull(response);
             assertNull(response.getError());
         }
@@ -385,7 +361,7 @@ protected File createTempFileFromAsset(String assetPath) throws IOException {
         FileOutputStream outStream = null;
 
         try {
-            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            AssetManager assets = getActivity().getResources().getAssets();
             inputStream = assets.open(assetPath);
 
             File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
@@ -455,48 +431,47 @@ protected void closeBlockerAndAssertSuccess() {
         }
     }
 
-    protected TestRequestAsyncTask createAsyncTaskOnUiThread(final Request... requests) throws Throwable {
-        final ArrayList<TestRequestAsyncTask> result = new ArrayList<TestRequestAsyncTask>();
+    protected TestGraphRequestAsyncTask createAsyncTaskOnUiThread(final GraphRequest... requests) throws Throwable {
+        final ArrayList<TestGraphRequestAsyncTask> result = new ArrayList<TestGraphRequestAsyncTask>();
         runTestOnUiThread(new Runnable() {
             @Override
             public void run() {
-                result.add(new TestRequestAsyncTask(requests));
+                result.add(new TestGraphRequestAsyncTask(requests));
             }
         });
         return result.isEmpty() ? null : result.get(0);
     }
 
-
     /*
      * Classes and helpers related to asynchronous requests.
      */
 
     // A subclass of RequestAsyncTask that knows how to interact with TestBlocker to ensure that tests can wait
     // on and assert success of async tasks.
-    protected class TestRequestAsyncTask extends RequestAsyncTask {
+    protected class TestGraphRequestAsyncTask extends GraphRequestAsyncTask {
         private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();
 
-        public TestRequestAsyncTask(Request... requests) {
+        public TestGraphRequestAsyncTask(GraphRequest... requests) {
             super(requests);
         }
 
-        public TestRequestAsyncTask(List<Request> requests) {
+        public TestGraphRequestAsyncTask(List<GraphRequest> requests) {
             super(requests);
         }
 
-        public TestRequestAsyncTask(RequestBatch requests) {
+        public TestGraphRequestAsyncTask(GraphRequestBatch requests) {
             super(requests);
         }
 
-        public TestRequestAsyncTask(HttpURLConnection connection, Request... requests) {
+        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequest... requests) {
             super(connection, requests);
         }
 
-        public TestRequestAsyncTask(HttpURLConnection connection, List<Request> requests) {
+        public TestGraphRequestAsyncTask(HttpURLConnection connection, List<GraphRequest> requests) {
             super(connection, requests);
         }
 
-        public TestRequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequestBatch requests) {
             super(connection, requests);
         }
 
@@ -508,7 +483,7 @@ public final Exception getThrowable() {
             return getException();
         }
 
-        protected void onPostExecute(List<Response> result) {
+        protected void onPostExecute(List<GraphResponse> result) {
             try {
                 super.onPostExecute(result);
 
@@ -555,7 +530,7 @@ public void run() {
 
     // Provides an implementation of Request.Callback that will assert either success (no error) or failure (error)
     // of a request, and allow derived classes to perform additional asserts.
-    protected class TestCallback implements Request.Callback {
+    protected class TestCallback implements GraphRequest.Callback {
         private final TestBlocker blocker;
         private final boolean expectSuccess;
 
@@ -569,7 +544,7 @@ public TestCallback(boolean expectSuccess) {
         }
 
         @Override
-        public void onCompleted(Response response) {
+        public void onCompleted(GraphResponse response) {
             try {
                 // We expect to be called on the right thread.
                 if (Thread.currentThread() != blocker) {
@@ -594,7 +569,7 @@ public void onCompleted(Response response) {
             }
         }
 
-        protected void performAsserts(Response response) {
+        protected void performAsserts(GraphResponse response) {
         }
     }
 
@@ -612,31 +587,31 @@ public ExpectFailureCallback() {
         }
     }
 
-    public static abstract class MockRequest extends Request {
-        public abstract Response createResponse();
+    public static abstract class MockGraphRequest extends GraphRequest {
+        public abstract GraphResponse createResponse();
     }
 
-    public static class MockRequestBatch extends RequestBatch {
-        public MockRequestBatch(MockRequest... requests) {
+    public static class MockGraphRequestBatch extends GraphRequestBatch {
+        public MockGraphRequestBatch(MockGraphRequest... requests) {
             super(requests);
         }
 
         // Caller must ensure that all the requests in the batch are, in fact, MockRequests.
-        public MockRequestBatch(RequestBatch requests) {
+        public MockGraphRequestBatch(GraphRequestBatch requests) {
             super(requests);
         }
 
         @Override
-        List<Response> executeAndWaitImpl() {
-            List<Request> requests = getRequests();
+        List<GraphResponse> executeAndWaitImpl() {
+            List<GraphRequest> requests = getRequests();
 
-            List<Response> responses = new ArrayList<Response>();
-            for (Request request : requests) {
-                MockRequest mockRequest = (MockRequest) request;
+            List<GraphResponse> responses = new ArrayList<GraphResponse>();
+            for (GraphRequest request : requests) {
+                MockGraphRequest mockRequest = (MockGraphRequest) request;
                 responses.add(mockRequest.createResponse());
             }
 
-            Request.runCallbacks(this, responses);
+            GraphRequest.runCallbacks(this, responses);
 
             return responses;
         }
@@ -664,22 +639,32 @@ public void run() {
     }
 
     protected void turnOnStrictModeForThisThread() {
-        // We use reflection, because Instrumentation will complain about any references to StrictMode in API versions < 9
-        // when attempting to run the unit tests. No particular effort has been made to make this efficient, since we
-        // expect to call it just once.
+        // We use reflection, because Instrumentation will complain about any references to
+        // StrictMode in API versions < 9 when attempting to run the unit tests. No particular
+        // effort has been made to make this efficient, since we expect to call it just once.
         try {
             ClassLoader loader = Thread.currentThread().getContextClassLoader();
             Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
-            Class<?> threadPolicyClass = Class.forName("android.os.StrictMode$ThreadPolicy", true, loader);
-            Class<?> threadPolicyBuilderClass = Class.forName("android.os.StrictMode$ThreadPolicy$Builder", true,
+            Class<?> threadPolicyClass = Class.forName(
+                    "android.os.StrictMode$ThreadPolicy",
+                    true,
+                    loader);
+            Class<?> threadPolicyBuilderClass = Class.forName(
+                    "android.os.StrictMode$ThreadPolicy$Builder",
+                    true,
                     loader);
 
             Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
-            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(threadPolicyBuilder);
-            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(threadPolicyBuilder);
-
-            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(threadPolicyBuilder);
-            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(strictModeClass, threadPolicy);
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(
+                    threadPolicyBuilder);
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(
+                    threadPolicyBuilder);
+
+            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(
+                    threadPolicyBuilder);
+            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(
+                    strictModeClass,
+                    threadPolicy);
         } catch (Exception ex) {
         }
     }
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTests.java b/facebook/tests/src/com/facebook/FacebookActivityTests.java
index cbb187582..1090c968a 100644
--- a/facebook/tests/src/com/facebook/FacebookActivityTests.java
+++ b/facebook/tests/src/com/facebook/FacebookActivityTests.java
@@ -1,75 +1,174 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 import android.app.Activity;
 import android.content.Intent;
-import android.test.suitebuilder.annotation.LargeTest;
+import android.net.Uri;
+import android.os.Handler;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
 
-public class FacebookActivityTests extends FacebookActivityTestCase<FacebookActivityTests.FacebookTestActivity> {
+import com.facebook.applinks.FacebookAppLinkResolver;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import bolts.Continuation;
+import bolts.Task;
+
+public class FacebookActivityTests
+        extends FacebookActivityTestCase<FacebookActivityTests.FacebookTestActivity> {
     public FacebookActivityTests() {
         super(FacebookActivityTests.FacebookTestActivity.class);
     }
 
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
+    @SmallTest
+    public void testLaunchingWithEmptyIntent() throws Exception {
+        final TestBlocker blocker = getTestBlocker();
+        Runnable runnable = new Runnable() {
+            public void run() {
+                try {
+                    Intent intent = new Intent(Intent.ACTION_MAIN);
+                    setActivityIntent(intent);
+                    FacebookTestActivity activity = getActivity();
 
-        Session activeSession = Session.getActiveSession();
-        if (activeSession != null) {
-            activeSession.closeAndClearTokenInformation();
-        }
+                    AccessToken.createFromNativeLinkingIntent(
+                            activity.getIntent(),
+                            getApplicationId(),
+                            new AccessToken.AccessTokenCreationCallback() {
+                                @Override
+                                public void onSuccess(AccessToken token) {
+                                    fail();
+                                    blocker.signal();
+
+                                }
+
+                                @Override
+                                public void onError(FacebookException error) {
+                                    blocker.signal();
+                                }
+                            });
+                } catch (Exception e) {
+                    fail(e.getMessage());
+                    blocker.signal();
+                }
+            }
+        };
+        RunTestWithBlocker(blocker, runnable);
     }
 
     @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLaunchingWithEmptyIntent() {
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        setActivityIntent(intent);
-        FacebookTestActivity activity = getActivity();
-
-        assertNull(Session.getActiveSession());
-        assertFalse(activity.hasNativeLinkIntentForTesting());
+    public void testLaunchingWithValidNativeLinkingIntent() {
+        final TestBlocker blocker = getTestBlocker();
+        Runnable runnable = new Runnable() {
+            public void run() {
+                try {
+                    final String token = "A token less unique than most";
+                    final String userId = "1000";
+
+                    Intent intent = new Intent(Intent.ACTION_MAIN);
+                    intent.putExtras(getNativeLinkingExtras(token, userId));
+                    setActivityIntent(intent);
+                    FacebookTestActivity activity = getActivity();
+
+                    AccessToken.createFromNativeLinkingIntent(
+                            activity.getIntent(),
+                            getApplicationId(),
+                            new AccessToken.AccessTokenCreationCallback() {
+                                @Override
+                                public void onSuccess(AccessToken token) {
+                                    assertNotNull(token);
+                                    blocker.signal();
+                                }
+
+                                @Override
+                                public void onError(FacebookException error) {
+                                    fail();
+                                    blocker.signal();
+                                }
+                            });
+                } catch (Exception e) {
+                    fail(e.getMessage());
+                    blocker.signal();
+                }
+            }
+        };
+        RunTestWithBlocker(blocker, runnable);
     }
 
-    @SmallTest
     @MediumTest
-    @LargeTest
-    public void testLaunchingWithValidNativeLinkingIntent() {
-        final String token = "A token less unique than most";
+    public void testLaunchingWithValidNativeLinkingNoUserIntent() throws Exception {
+        final TestBlocker blocker = getTestBlocker();
+        Runnable runnable = new Runnable() {
+            public void run() {
+                try {
+                    TestUserManager manager = new TestUserManager(
+                            getApplicationSecret(),
+                            getApplicationId());
+                    AccessToken token = manager.getAccessTokenForSharedUser(null);
 
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-        setActivityIntent(intent);
+                    Intent intent = new Intent(Intent.ACTION_MAIN);
+                    intent.putExtras(getNativeLinkingExtras(token.getToken(), null));
+                    setActivityIntent(intent);
+                    FacebookTestActivity activity = getActivity();
+                    AccessToken.createFromNativeLinkingIntent(
+                            activity.getIntent(),
+                            getApplicationId(),
+                            new AccessToken.AccessTokenCreationCallback() {
+                                @Override
+                                public void onSuccess(AccessToken token) {
+                                    assertNotNull(token);
+                                    blocker.signal();
+                                }
 
-        assertNull(Session.getActiveSession());
+                                @Override
+                                public void onError(FacebookException error) {
+                                    fail();
+                                    blocker.signal();
+                                }
+                            });
+                } catch (Exception e) {
+                    // Get back to the test case if there was an uncaught exception
+                    fail(e.getMessage());
+                    blocker.signal();
+                }
+            }
+        };
 
-        FacebookTestActivity activity = getActivity();
-        Session activeSession = Session.getActiveSession();
-        assertNull(activeSession);
-        assertTrue(activity.hasNativeLinkIntentForTesting());
+        RunTestWithBlocker(blocker, runnable);
     }
 
     public static class FacebookTestActivity extends Activity {
-        public boolean hasNativeLinkIntentForTesting() {
-            return AccessToken.createFromNativeLinkingIntent(getIntent()) != null;
+    }
+
+    private void RunTestWithBlocker(final TestBlocker blocker, Runnable runnable) {
+        try {
+            Handler handler = new Handler(blocker.getLooper());
+            handler.post(runnable);
+
+            blocker.waitForSignals(1);
+        } catch (Exception e) {
+            // Forcing the test to fail with details
+            assertNull(e);
         }
     }
 }
diff --git a/facebook/tests/src/com/facebook/FacebookAppLinkResolverTests.java b/facebook/tests/src/com/facebook/FacebookAppLinkResolverTests.java
new file mode 100644
index 000000000..3042f889d
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookAppLinkResolverTests.java
@@ -0,0 +1,211 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.net.Uri;
+import android.os.Handler;
+
+import com.facebook.applinks.FacebookAppLinkResolver;
+
+import bolts.AppLink;
+import bolts.Continuation;
+import bolts.Task;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class FacebookAppLinkResolverTests extends FacebookTestCase {
+    private Task resolveTask;
+
+    public void testSingleUrl() {
+        String testUrlString = "https://fb.me/732873156764191";
+        Uri testUrl = Uri.parse(testUrlString);
+        Uri testWebUri = Uri.parse("http://www.facebook.com/");
+        ArrayList<AppLink.Target> testTargets = new ArrayList<AppLink.Target>();
+        testTargets.add(new AppLink.Target(
+                "com.myapp",
+                null,
+                Uri.parse("myapp://3"),
+                "my app"));
+        testTargets.add(new AppLink.Target(
+                "com.myapp-test",
+                null,
+                Uri.parse("myapp-test://4"),
+                "my test app"));
+        try {
+            executeResolverOnBlockerThread(new FacebookAppLinkResolver(), testUrl);
+
+            getTestBlocker().waitForSignals(1);
+
+            assertNotNull(resolveTask);
+
+            Task<AppLink> singleUrlResolveTask = (Task<AppLink>)resolveTask;
+
+            assertTrue(singleUrlResolveTask.isCompleted() &&
+                    !singleUrlResolveTask.isCancelled() &&
+                    !singleUrlResolveTask.isFaulted());
+
+            AppLink appLink = singleUrlResolveTask.getResult();
+
+            assertEquals(appLink.getSourceUrl(), testUrl);
+            assertEquals(appLink.getWebUrl(), testWebUri);
+            assertTrue(targetListsAreEqual(appLink.getTargets(), testTargets));
+        } catch (Exception e) {
+            // Forcing the test to fail with details
+            assertNull(e);
+        }
+    }
+
+    public void testUrlWithNoAppLinkData() {
+        String testNoAppLinkUrlString = "https://fb.me/732873156764191_no_app_link";
+        Uri testNoAppLinkUrl = Uri.parse(testNoAppLinkUrlString);
+        try {
+            executeResolverOnBlockerThread(new FacebookAppLinkResolver(), testNoAppLinkUrl);
+
+            getTestBlocker().waitForSignals(1);
+
+            assertNotNull(resolveTask);
+
+            Task<AppLink> singleUrlResolveTask = (Task<AppLink>)resolveTask;
+
+            assertTrue(singleUrlResolveTask.isCompleted() &&
+                    !singleUrlResolveTask.isCancelled() &&
+                    !singleUrlResolveTask.isFaulted());
+
+            AppLink appLink = singleUrlResolveTask.getResult();
+            assertNull(appLink);
+        } catch (Exception e) {
+            // Forcing the test to fail with details
+            assertNull(e);
+        }
+    }
+
+    public void testCachedAppLinkData() {
+        String testUrlString = "https://fb.me/732873156764191";
+        Uri testUrl = Uri.parse(testUrlString);
+        Uri testWebUri = Uri.parse("http://www.facebook.com/");
+        ArrayList<AppLink.Target> testTargets = new ArrayList<AppLink.Target>();
+        testTargets.add(new AppLink.Target(
+                "com.myapp",
+                null,
+                Uri.parse("myapp://3"),
+                "my app"));
+        testTargets.add(new AppLink.Target(
+                "com.myapp-test",
+                null,
+                Uri.parse("myapp-test://4"),
+                "my test app"));
+
+        try {
+            FacebookAppLinkResolver resolver = new FacebookAppLinkResolver();
+
+            // This will prefetch the app link
+            executeResolverOnBlockerThread(resolver, testUrl);
+            getTestBlocker().waitForSignals(1);
+            assertNotNull(resolveTask);
+
+            // Now let's fetch it again. This should complete the task synchronously.
+            Task<AppLink> cachedUrlResolveTask = resolver.getAppLinkFromUrlInBackground(testUrl);
+
+            assertTrue(cachedUrlResolveTask.isCompleted() &&
+                    !cachedUrlResolveTask.isCancelled() &&
+                    !cachedUrlResolveTask.isFaulted());
+
+            AppLink appLink = cachedUrlResolveTask.getResult();
+
+            assertEquals(appLink.getSourceUrl(), testUrl);
+            assertEquals(appLink.getWebUrl(), testWebUri);
+            assertTrue(targetListsAreEqual(appLink.getTargets(), testTargets));
+        } catch (Exception e) {
+            // Forcing the test to fail with details
+            assertNull(e);
+        }
+    }
+
+    public void executeResolverOnBlockerThread(final FacebookAppLinkResolver resolver, final Uri testUrl) {
+        final TestBlocker blocker = getTestBlocker();
+        Runnable runnable = new Runnable() {
+            public void run() {
+                try {
+                    resolveTask = resolver.getAppLinkFromUrlInBackground(testUrl);
+                    resolveTask.continueWith(new Continuation() {
+                        @Override
+                        public Object then(Task task) throws Exception {
+                            // Once the task is complete, unblock the test thread, so it can inspect for errors/results.
+                            blocker.signal();
+                            return null;
+                        }
+                    });
+                } catch (Exception e) {
+                    // Get back to the test case if there was an uncaught exception
+                    blocker.signal();
+                }
+            }
+        };
+
+        Handler handler = new Handler(blocker.getLooper());
+        handler.post(runnable);
+    }
+
+    private static boolean targetListsAreEqual(List<AppLink.Target> list1, List<AppLink.Target> list2) {
+        if (list1 == null) {
+            return list2 == null;
+        } else if (list2 == null || list1.size() != list2.size()) {
+            return false;
+        }
+
+        ArrayList<AppLink.Target> list2Copy = new ArrayList<AppLink.Target>(list2);
+
+        for(int i = 0; i < list1.size(); i++) {
+            int j;
+            for (j = 0; j < list2Copy.size(); j++) {
+                if (targetsAreEqual(list1.get(i), list2Copy.get(j))) {
+                    break;
+                }
+            }
+
+            if (j < list2Copy.size()) {
+                // Found a match. Remove from the copy to make sure the same target isn't matched twice.
+                list2Copy.remove(j);
+            } else {
+                // Match not found
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private static boolean targetsAreEqual(AppLink.Target target1, AppLink.Target target2) {
+        boolean isEqual =
+                objectsAreEqual(target1.getPackageName(), target2.getPackageName()) &&
+                objectsAreEqual(target1.getClassName(), target2.getClassName()) &&
+                objectsAreEqual(target1.getAppName(), target2.getAppName()) &&
+                objectsAreEqual(target1.getUrl(), target2.getUrl()) ;
+
+        return isEqual;
+    }
+
+    private static boolean objectsAreEqual(Object s1, Object s2) {
+        return s1 == null
+                ? s2 == null
+                : s1.equals(s2);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookTestCase.java b/facebook/tests/src/com/facebook/FacebookTestCase.java
index 37f892f05..8c70686a6 100644
--- a/facebook/tests/src/com/facebook/FacebookTestCase.java
+++ b/facebook/tests/src/com/facebook/FacebookTestCase.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -21,8 +25,8 @@
 public class FacebookTestCase extends FacebookActivityTestCase<FacebookTestCase.FacebookTestActivity> {
     public FacebookTestCase() {
         super(FacebookTestCase.FacebookTestActivity.class);
-        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_RAW_RESPONSES);
+        FacebookSdk.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        FacebookSdk.addLoggingBehavior(LoggingBehavior.INCLUDE_RAW_RESPONSES);
     }
 
     public static class FacebookTestActivity extends Activity {
diff --git a/facebook/tests/src/com/facebook/widget/FragmentTestCase.java b/facebook/tests/src/com/facebook/FragmentTestCase.java
similarity index 69%
rename from facebook/tests/src/com/facebook/widget/FragmentTestCase.java
rename to facebook/tests/src/com/facebook/FragmentTestCase.java
index 2fbdfa08f..b421196ee 100644
--- a/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
+++ b/facebook/tests/src/com/facebook/FragmentTestCase.java
@@ -1,26 +1,29 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook;
 
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.widget.LinearLayout;
-import com.facebook.FacebookActivityTestCase;
 
 public class FragmentTestCase<T extends FragmentTestCase.TestFragmentActivity<?>> extends FacebookActivityTestCase<T> {
     public FragmentTestCase(Class<T> activityClass) {
diff --git a/facebook/tests/src/com/facebook/GraphRequestBatchBridge.java b/facebook/tests/src/com/facebook/GraphRequestBatchBridge.java
new file mode 100644
index 000000000..0ffa3b495
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphRequestBatchBridge.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.os.Handler;
+
+public final class GraphRequestBatchBridge {
+
+    public static void setCallbackHandler(GraphRequestBatch batch, Handler callbackHandler) {
+        batch.setCallbackHandler(callbackHandler);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/GraphRequestTests.java b/facebook/tests/src/com/facebook/GraphRequestTests.java
index 5ff2a975d..64bffef2c 100644
--- a/facebook/tests/src/com/facebook/GraphRequestTests.java
+++ b/facebook/tests/src/com/facebook/GraphRequestTests.java
@@ -1,23 +1,28 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 import android.test.suitebuilder.annotation.LargeTest;
-import com.facebook.model.GraphObject;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 import java.util.Date;
 
@@ -25,66 +30,42 @@
 // to the underlying request/batch plumbing.
 public class GraphRequestTests extends FacebookTestCase {
 
+    protected String[] getDefaultPermissions()
+    {
+        return new String[] { "email", "publish_actions", "read_stream" };
+    };
+
     @LargeTest
-    public void testCommentRoundTrip() {
-        TestSession session = openTestSessionWithSharedUser();
+    public void testCommentRoundTrip() throws JSONException {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
 
-        GraphObject status = createStatusUpdate("");
-        GraphObject createdStatus = batchCreateAndGet(session, "me/feed", status, null, GraphObject.class);
-        String statusID = (String) createdStatus.getProperty("id");
+        JSONObject status = createStatusUpdate("");
+        JSONObject createdStatus = batchCreateAndGet(accessToken, "me/feed", status, null);
+        String statusID = createdStatus.optString("id");
 
-        GraphObject comment = GraphObject.Factory.create();
+        JSONObject comment = new JSONObject();
         final String commentMessage = "It truly is a wonderful status update.";
-        comment.setProperty("message", commentMessage);
+        comment.put("message", commentMessage);
 
-        GraphObject createdComment1 = batchCreateAndGet(session, statusID + "/comments", comment, null,
-                GraphObject.class);
+        JSONObject createdComment1 = batchCreateAndGet(accessToken, statusID + "/comments", comment, null);
         assertNotNull(createdComment1);
 
-        String comment1ID = (String) createdComment1.getProperty("id");
-        String comment1Message = (String) createdComment1.getProperty("message");
+        String comment1ID = createdComment1.optString("id");
+        String comment1Message = createdComment1.optString("message");
         assertNotNull(comment1ID);
         assertNotNull(comment1Message);
         assertEquals(commentMessage, comment1Message);
 
         // Try posting the same comment to the same status update. We need to clear its ID first.
-        createdComment1.removeProperty("id");
-        GraphObject createdComment2 = batchCreateAndGet(session, statusID + "/comments", createdComment1, null,
-                GraphObject.class);
+        createdComment1.remove("id");
+        JSONObject createdComment2 = batchCreateAndGet(accessToken, statusID + "/comments", createdComment1, null);
         assertNotNull(createdComment2);
 
-        String comment2ID = (String) createdComment2.getProperty("id");
-        String comment2Message = (String) createdComment2.getProperty("message");
+        String comment2ID = createdComment2.optString("id");
+        String comment2Message = createdComment2.optString("message");
         assertNotNull(comment2ID);
         assertFalse(comment1ID.equals(comment2ID));
         assertNotNull(comment2Message);
         assertEquals(commentMessage, comment2Message);
     }
-
-    @LargeTest
-    public void testEventRoundTrip() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "create_event");
-
-        GraphObject event = GraphObject.Factory.create();
-        // Android emulators tend to not have the right date/time. To avoid issues with posting events in the past
-        // or too far in the future, we use a constant year. This test will break in 2030, angering our robot overlords.
-        Date startTime = new Date(130, 2, 17, 12, 34, 56);
-        event.setProperty("name", "My awesome St. Patrick's Day party on " + startTime.toString());
-        final String eventDescription = "This is a great event. You should all come.";
-        event.setProperty("description", eventDescription);
-        Date endTime = new Date(startTime.getTime() + 3600 * 1000);
-        event.setProperty("start_time", startTime);
-        event.setProperty("end_time", endTime);
-        event.setProperty("location", "My house");
-
-        GraphObject event1 = batchCreateAndGet(session, "me/events", event, null, GraphObject.class);
-        assertNotNull(event1);
-        assertEquals(eventDescription, event1.getProperty("description"));
-
-        event1.removeProperty("id");
-        GraphObject event2 = batchCreateAndGet(session, "me/events", event1, null, GraphObject.class);
-        assertNotNull(event2);
-        assertEquals(eventDescription, event2.getProperty("description"));
-    }
-
 }
diff --git a/facebook/tests/src/com/facebook/GraphResponseBridge.java b/facebook/tests/src/com/facebook/GraphResponseBridge.java
new file mode 100644
index 000000000..c0bfd59d6
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphResponseBridge.java
@@ -0,0 +1,36 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import org.json.JSONObject;
+
+import java.net.HttpURLConnection;
+
+public class GraphResponseBridge {
+    public static GraphResponse createGraphResponse(
+            GraphRequest request,
+            HttpURLConnection connection,
+            String rawResponse,
+            JSONObject graphObject) {
+        return new GraphResponse(request, connection, rawResponse, graphObject, null, null);
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/GraphUtilTests.java b/facebook/tests/src/com/facebook/GraphUtilTests.java
new file mode 100644
index 000000000..568bc04a7
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphUtilTests.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import com.facebook.internal.GraphUtil;
+import com.facebook.internal.NativeProtocol;
+
+import org.json.JSONObject;
+
+import static org.mockito.Mockito.*;
+
+public class GraphUtilTests extends FacebookTestCase {
+
+    public void testIsOpenGraphObjectForPost() {
+        JSONObject jsonObject = mock(JSONObject.class);
+        when(jsonObject.optBoolean(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)).thenReturn(true);
+        assertTrue(GraphUtil.isOpenGraphObjectForPost(jsonObject));
+    }
+}
diff --git a/facebook/tests/src/com/facebook/NativeAppCallAttachmentStoreTest.java b/facebook/tests/src/com/facebook/NativeAppCallAttachmentStoreTest.java
deleted file mode 100644
index 01314889e..000000000
--- a/facebook/tests/src/com/facebook/NativeAppCallAttachmentStoreTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package com.facebook;
-
-import android.graphics.Bitmap;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-
-public class NativeAppCallAttachmentStoreTest extends FacebookTestCase {
-    private static final UUID CALL_ID = UUID.randomUUID();
-    private static final String ATTACHMENT_NAME = "hello";
-
-    private NativeAppCallAttachmentStore storeUnderTest;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        storeUnderTest = new NativeAppCallAttachmentStore();
-    }
-
-    private Bitmap createBitmap() {
-        Bitmap bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ALPHA_8);
-        return bitmap;
-    }
-
-    private Map<String, Bitmap> createValidAttachment() {
-        String attachmentId = UUID.randomUUID().toString();
-        Bitmap bitmap = createBitmap();
-
-        Map<String, Bitmap> bitmaps = new HashMap<String, Bitmap>();
-        bitmaps.put(attachmentId, bitmap);
-
-        return bitmaps;
-    }
-
-    public void testAddAttachmentsForCallWithNullContext() throws Exception {
-        try {
-            Map<String, Bitmap> attachments = createValidAttachment();
-            storeUnderTest.addAttachmentsForCall(null, CALL_ID, attachments);
-            fail("expected exception");
-        } catch (NullPointerException ex) {
-            assertTrue(ex.getMessage().contains("context"));
-        }
-    }
-
-    public void testAddAttachmentsForCallWithNullCallId() throws Exception {
-        try {
-            Map<String, Bitmap> attachments = createValidAttachment();
-            storeUnderTest.addAttachmentsForCall(getActivity(), null, attachments);
-            fail("expected exception");
-        } catch (NullPointerException ex) {
-            assertTrue(ex.getMessage().contains("callId"));
-        }
-    }
-
-    public void testAddAttachmentsForCallWithNullBitmap() throws Exception {
-        try {
-            Map<String, Bitmap> attachments = new HashMap<String, Bitmap>();
-            attachments.put(ATTACHMENT_NAME, null);
-
-            storeUnderTest.addAttachmentsForCall(getActivity(), CALL_ID, attachments);
-            fail("expected exception");
-        } catch (NullPointerException ex) {
-            assertTrue(ex.getMessage().contains("imageAttachments"));
-        }
-    }
-
-    public void testAddAttachmentsForCallWithEmptyAttachmentName() throws Exception {
-        try {
-            Map<String, Bitmap> attachments = new HashMap<String, Bitmap>();
-            attachments.put("", createBitmap());
-
-            storeUnderTest.addAttachmentsForCall(getActivity(), CALL_ID, attachments);
-            fail("expected exception");
-        } catch (IllegalArgumentException ex) {
-            assertTrue(ex.getMessage().contains("imageAttachments"));
-        }
-    }
-
-    public void testAddAttachmentsForCall() throws Exception {
-
-    }
-
-    public void testCleanupAttachmentsForCall() throws Exception {
-
-    }
-
-    public void testGetAttachmentsDirectory() throws Exception {
-        File dir = NativeAppCallAttachmentStore.getAttachmentsDirectory(getActivity());
-        assertNotNull(dir);
-        assertTrue(dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
-    }
-
-    public void testGetAttachmentsDirectoryForCall() throws Exception {
-        storeUnderTest.ensureAttachmentsDirectoryExists(getActivity());
-        File dir = storeUnderTest.getAttachmentsDirectoryForCall(CALL_ID, false);
-        assertNotNull(dir);
-        assertTrue(dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
-        assertTrue(dir.getAbsolutePath().contains(CALL_ID.toString()));
-    }
-
-    public void testGetAttachmentFile() throws Exception {
-        storeUnderTest.ensureAttachmentsDirectoryExists(getActivity());
-        File dir = storeUnderTest.getAttachmentFile(CALL_ID, ATTACHMENT_NAME, false);
-        assertNotNull(dir);
-        assertTrue(dir.getAbsolutePath().contains(NativeAppCallAttachmentStore.ATTACHMENTS_DIR_NAME));
-        assertTrue(dir.getAbsolutePath().contains(CALL_ID.toString()));
-        assertTrue(dir.getAbsolutePath().contains(ATTACHMENT_NAME.toString()));
-    }
-}
diff --git a/facebook/tests/src/com/facebook/NativeAppCallContentProviderTest.java b/facebook/tests/src/com/facebook/NativeAppCallContentProviderTest.java
deleted file mode 100644
index a2aa79a05..000000000
--- a/facebook/tests/src/com/facebook/NativeAppCallContentProviderTest.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-import android.util.Pair;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-
-public class NativeAppCallContentProviderTest extends FacebookTestCase {
-    private static final String APP_ID = "12345";
-    private static final UUID CALL_ID = UUID.randomUUID();
-
-    private NativeAppCallContentProvider providerUnderTest;
-    private StubAttachmentStore stubAttachmentStore;
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        stubAttachmentStore = new StubAttachmentStore();
-        providerUnderTest = new NativeAppCallContentProvider(stubAttachmentStore);
-    }
-
-    public void testGetAttachmentUrl() {
-        String url = NativeAppCallContentProvider.getAttachmentUrl(APP_ID, CALL_ID, "foo");
-        assertEquals("content://com.facebook.app.NativeAppCallContentProvider" + APP_ID + "/" + CALL_ID + "/foo", url);
-    }
-
-    public void testOnCreate() throws Exception {
-        assertTrue(providerUnderTest.onCreate());
-    }
-
-    public void testQuery() throws Exception {
-        assertNull(providerUnderTest.query(null, null, null, null, null));
-    }
-
-    public void testGetType() throws Exception {
-        assertNull(providerUnderTest.getType(null));
-    }
-
-    public void testInsert() throws Exception {
-        assertNull(providerUnderTest.insert(null, null));
-    }
-
-    public void testDelete() throws Exception {
-        assertEquals(0, providerUnderTest.delete(null, null, null));
-    }
-
-    public void testUpdate() throws Exception {
-        assertEquals(0, providerUnderTest.update(null, null, null, null));
-    }
-
-    @SuppressWarnings("unused")
-    public void testOpenFileWithNullUri() throws Exception {
-        try {
-            ParcelFileDescriptor pfd = providerUnderTest.openFile(null, "r");
-            fail("expected FileNotFoundException");
-        } catch (FileNotFoundException e) {
-        }
-    }
-
-    @SuppressWarnings("unused")
-    public void testOpenFileWithBadPath() throws Exception {
-        try {
-            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/"), "r");
-            fail("expected FileNotFoundException");
-        } catch (FileNotFoundException e) {
-        }
-    }
-
-    @SuppressWarnings("unused")
-    public void testOpenFileWithoutCallIdAndAttachment() throws Exception {
-        try {
-            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo"), "r");
-            fail("expected FileNotFoundException");
-        } catch (FileNotFoundException e) {
-        }
-    }
-
-    @SuppressWarnings("unused")
-    public void testOpenFileWithBadCallID() throws Exception {
-        try {
-            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo/bar"), "r");
-            fail("expected FileNotFoundException");
-        } catch (FileNotFoundException e) {
-        }
-    }
-
-    public void testOpenFileWithUnknownUri() throws Exception {
-        try {
-            String callId = UUID.randomUUID().toString();
-            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/" + callId + "/bar"), "r");
-            fail("expected FileNotFoundException");
-        } catch (FileNotFoundException e) {
-        }
-    }
-
-    public void testOpenFileWithKnownUri() throws Exception {
-        String attachmentName = "hi";
-
-        stubAttachmentStore.addAttachment(CALL_ID, attachmentName);
-        Uri uri = Uri.parse(NativeAppCallContentProvider.getAttachmentUrl(APP_ID, CALL_ID, attachmentName));
-
-        ParcelFileDescriptor pfd = providerUnderTest.openFile(uri, "r");
-
-        assertNotNull(pfd);
-        pfd.close();
-    }
-
-    class StubAttachmentStore implements NativeAppCallContentProvider.AttachmentDataSource {
-        private List<Pair<UUID, String>> attachments = new ArrayList<Pair<UUID, String>>();
-        private static final String DUMMY_FILE_NAME = "dummyfile";
-
-        public void addAttachment(UUID callId, String attachmentName) {
-            attachments.add(new Pair<UUID, String>(callId, attachmentName));
-        }
-
-        @Override
-        public File openAttachment(UUID callId, String attachmentName) throws FileNotFoundException {
-            if (attachments.contains(new Pair<UUID, String>(callId, attachmentName))) {
-                File cacheDir = getActivity().getCacheDir();
-                File dummyFile = new File(cacheDir, DUMMY_FILE_NAME);
-                if (!dummyFile.exists()) {
-                    try {
-                        dummyFile.createNewFile();
-                    } catch (IOException e) {
-                    }
-                }
-
-                return dummyFile;
-            }
-            throw new FileNotFoundException();
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/ProfileManagerTest.java b/facebook/tests/src/com/facebook/ProfileManagerTest.java
new file mode 100644
index 000000000..53c3386df
--- /dev/null
+++ b/facebook/tests/src/com/facebook/ProfileManagerTest.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+
+public class ProfileManagerTest extends FacebookTestCase {
+
+    @LargeTest
+    public void testExecuteSingleGet() throws Throwable {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        AccessToken.setCurrentAccessToken(accessToken);
+        Profile.setCurrentProfile(null);
+        ProfileTracker tracker = null;
+        try {
+            tracker = new ProfileTracker() {
+                @Override
+                protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
+                    getTestBlocker().signal();
+                }
+            };
+            assertNull(Profile.getCurrentProfile());
+            runAndBlockOnUiThread(1, new Runnable() {
+                @Override
+                public void run() {
+                    Profile.fetchProfileForCurrentAccessToken();
+                }
+            });
+        } catch(Exception e) {
+            fail();
+        } finally {
+            if (tracker != null) {
+                tracker.stopTracking();
+            }
+        }
+        Profile profile = Profile.getCurrentProfile();
+        assertNotNull(profile);
+        assertEquals("Shared", profile.getFirstName());
+        assertEquals("Testuser", profile.getLastName());
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/ProgressNoopOutputStreamTests.java b/facebook/tests/src/com/facebook/ProgressNoopOutputStreamTests.java
deleted file mode 100644
index b65b9851f..000000000
--- a/facebook/tests/src/com/facebook/ProgressNoopOutputStreamTests.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.test.AndroidTestCase;
-import static android.test.MoreAsserts.*;
-
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.ProgressNoopOutputStream;
-
-import java.lang.Exception;
-import java.lang.Override;
-
-public class ProgressNoopOutputStreamTests extends AndroidTestCase {
-    private ProgressNoopOutputStream stream;
-
-    @Override
-    protected void setUp() throws Exception {
-        stream = new ProgressNoopOutputStream(null);
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        stream.close();
-    }
-
-    @SmallTest
-    public void testSetup() {
-        assertEquals(0, stream.getMaxProgress());
-        assertEmpty(stream.getProgressMap());
-    }
-
-    @SmallTest
-    public void testWriting() {
-        assertEquals(0, stream.getMaxProgress());
-
-        stream.write(0);
-        assertEquals(1, stream.getMaxProgress());
-
-        final byte[] buf = new byte[8];
-
-        stream.write(buf);
-        assertEquals(9, stream.getMaxProgress());
-
-        stream.write(buf, 2, 2);
-        assertEquals(11, stream.getMaxProgress());
-
-        stream.addProgress(16);
-        assertEquals(27, stream.getMaxProgress());
-    }
-}
\ No newline at end of file
diff --git a/facebook/tests/src/com/facebook/RequestTests.java b/facebook/tests/src/com/facebook/RequestTests.java
index bdb34a78b..6e8e80291 100644
--- a/facebook/tests/src/com/facebook/RequestTests.java
+++ b/facebook/tests/src/com/facebook/RequestTests.java
@@ -1,29 +1,35 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
 import android.graphics.Bitmap;
 import android.location.Location;
-import android.net.Uri;
 import android.os.Bundle;
 import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.*;
+
+import com.facebook.share.internal.ShareInternalUtility;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -37,366 +43,77 @@
 public class RequestTests extends FacebookTestCase {
     private final static String TEST_OG_TYPE = "facebooksdktests:test";
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateRequest() {
-        Request request = new Request();
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePostRequest() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        Request request = Request.newPostRequest(null, "me/statuses", graphObject, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.POST, request.getHttpMethod());
-        assertEquals("me/statuses", request.getGraphPath());
-        assertEquals(graphObject, request.getGraphObject());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateMeRequest() {
-        Request request = Request.newMeRequest(null, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("me", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateMyFriendsRequest() {
-        Request request = Request.newMyFriendsRequest(null, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("me/friends", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateUploadPhotoRequest() {
-        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
-
-        Request request = Request.newUploadPhotoRequest(null, image, null);
-        assertTrue(request != null);
-
-        Bundle parameters = request.getParameters();
-        assertTrue(parameters != null);
-
-        assertTrue(parameters.containsKey("picture"));
-        assertEquals(image, parameters.getParcelable("picture"));
-        assertEquals("me/photos", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestWithLocation() {
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        Request request = Request.newPlacesSearchRequest(null, location, 1000, 50, null, null);
-
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("search", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestWithSearchText() {
-        Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);
-
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("search", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
-        try {
-            Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequestRequiresObject() {
-        try {
-            Request.newPostOpenGraphObjectRequest(null, null, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequestRequiresObjectType() {
-        try {
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost(null);
-            Request.newPostOpenGraphObjectRequest(null, object, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyObjectType() {
-        try {
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost("");
-            object.setTitle("bar");
-            Request.newPostOpenGraphObjectRequest(null, object, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequestRequiresTitle() {
-        try {
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost("foo");
-            Request.newPostOpenGraphObjectRequest(null, object, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyTitle() {
-        try {
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost("foo");
-            object.setTitle("");
-            Request.newPostOpenGraphObjectRequest(null, object, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphObjectRequest() {
-        OpenGraphObject object = OpenGraphObject.Factory.createForPost("foo");
-        object.setTitle("bar");
-        Request request = Request.newPostOpenGraphObjectRequest(null, object, null);
-        assertNotNull(request);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphActionRequestRequiresAction() {
-        try {
-            Request.newPostOpenGraphActionRequest(null, null, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphActionRequestRequiresActionType() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost(null);
-            Request.newPostOpenGraphActionRequest(null, action, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphActionRequestRequiresNonEmptyActionType() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("");
-            Request.newPostOpenGraphActionRequest(null, action, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNewPostOpenGraphActionRequest() {
-        OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-        Request request = Request.newPostOpenGraphActionRequest(null, action, null);
-        assertNotNull(request);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetHttpMethodToNilGivesDefault() {
-        Request request = new Request();
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-
-        request.setHttpMethod(null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithNullRequestsThrows() {
-        try {
-            Request.executeBatchAndWait((Request[]) null);
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithZeroRequestsThrows() {
-        try {
-            Request.executeBatchAndWait(new Request[]{});
-            fail("expected IllegalArgumentException");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
+    protected String[] getDefaultPermissions()
+    {
+        return new String[] { "email", "publish_actions", "read_stream" };
+    };
 
-    @SmallTest
-    @MediumTest
     @LargeTest
-    public void testExecuteBatchWithNullRequestThrows() {
-        try {
-            Request.executeBatchAndWait(new Request[]{null});
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
+    public void testExecuteSingleGet() {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        GraphRequest request = new GraphRequest(accessToken, "TourEiffel");
+        GraphResponse response = request.executeAndWait();
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testToHttpConnectionWithNullRequestsThrows() {
-        try {
-            Request.toHttpConnection((Request[]) null);
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
+        assertTrue(response != null);
+        assertTrue(response.getError() == null);
+        assertNotNull(response.getJSONObject());
+        assertNotNull(response.getRawResponse());
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testToHttpConnectionWithZeroRequestsThrows() {
-        try {
-            Request.toHttpConnection(new Request[]{});
-            fail("expected IllegalArgumentException");
-        } catch (IllegalArgumentException exception) {
-        }
+        JSONObject graphPlace = response.getJSONObject();
+        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
     }
 
-    @SmallTest
-    @MediumTest
     @LargeTest
-    public void testToHttpConnectionWithNullRequestThrows() {
-        try {
-            Request.toHttpConnection(new Request[]{null});
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
+    public void testBuildsUploadPhotoHttpURLConnection() throws Exception {
+        final AccessToken accessToken = getAccessTokenForSharedUser();
+        Bitmap image = createTestBitmap(128);
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSingleGetToHttpRequest() throws Exception {
-        Request requestMe = new Request(null, "TourEiffel");
-        HttpURLConnection connection = Request.toHttpConnection(requestMe);
+        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                image,
+                "Test photo messsage",
+                null);
+        HttpURLConnection connection = GraphRequest.toHttpConnection(request);
 
         assertTrue(connection != null);
-
-        assertEquals("GET", connection.getRequestMethod());
-        assertEquals("/TourEiffel", connection.getURL().getPath());
-
-        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));
-
-        Uri uri = Uri.parse(connection.getURL().toString());
-        assertEquals("android", uri.getQueryParameter("sdk"));
-        assertEquals("json", uri.getQueryParameter("format"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGet() {
-        Request request = new Request(null, "TourEiffel");
-        Response response = request.executeAndWait();
-
-        assertTrue(response != null);
-        assertTrue(response.getError() == null);
-        assertTrue(response.getGraphObject() != null);
-
-        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-        assertEquals("Paris", graphPlace.getLocation().getCity());
+        assertNotSame("gzip", connection.getRequestProperty("Content-Encoding"));
+        assertNotSame("application/x-www-form-urlencoded", connection.getRequestProperty("Content-Type"));
     }
 
-    @MediumTest
     @LargeTest
     public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
-        Request request = new Request(null, "TourEiffel");
-        HttpURLConnection connection = Request.toHttpConnection(request);
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
+        GraphRequest request = new GraphRequest(accessToken, "TourEiffel");
+        HttpURLConnection connection = GraphRequest.toHttpConnection(request);
+
+        assertEquals("gzip", connection.getRequestProperty("Content-Encoding"));
+        assertEquals("application/x-www-form-urlencoded", connection.getRequestProperty("Content-Type"));
 
-        List<Response> responses = Request.executeConnectionAndWait(connection, Arrays.asList(new Request[]{request}));
+        List<GraphResponse> responses = GraphRequest.executeConnectionAndWait(connection, Arrays.asList(new GraphRequest[]{request}));
         assertNotNull(responses);
         assertEquals(1, responses.size());
 
-        Response response = responses.get(0);
+        GraphResponse response = responses.get(0);
 
         assertTrue(response != null);
         assertTrue(response.getError() == null);
-        assertTrue(response.getGraphObject() != null);
+        assertNotNull(response.getJSONObject());
+        assertNotNull(response.getRawResponse());
 
-        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-        assertEquals("Paris", graphPlace.getLocation().getCity());
+        JSONObject graphPlace = response.getJSONObject();
+        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
 
         // Make sure calling code can still access HTTP headers and call disconnect themselves.
         int code = connection.getResponseCode();
         assertEquals(200, code);
-        assertTrue(connection.getHeaderFields().keySet().contains("Content-Length"));
+        assertTrue(connection.getHeaderFields().keySet().contains("Content-Type"));
         connection.disconnect();
     }
 
-    @MediumTest
     @LargeTest
     public void testFacebookErrorResponseCreatesError() {
-        Request request = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
-        Response response = request.executeAndWait();
+        GraphRequest request = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
+        GraphResponse response = request.executeAndWait();
 
         assertTrue(response != null);
 
@@ -412,158 +129,152 @@ public void testFacebookErrorResponseCreatesError() {
     }
 
     @LargeTest
-    public void testFacebookSuccessResponseWithErrorCodeCreatesError() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = Request.newRestRequest(session, "auth.extendSSOAccessToken", null, null);
-        assertNotNull(request);
-
-        // Because TestSession access tokens were not created via SSO, we expect to get an error from the service,
-        // but with a 200 (success) code.
-        Response response = request.executeAndWait();
-
-        assertTrue(response != null);
-
-        FacebookRequestError error = response.getError();
-        assertNotNull(error);
-
-        assertTrue(error.getException() instanceof FacebookServiceException);
-        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
-        assertNotNull(error.getRequestResultBody());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testRequestWithUnopenedSessionFails() {
-        TestSession session = getTestSessionWithSharedUser(null);
-        Request request = new Request(session, "me");
-        Response response = request.executeAndWait();
+    public void testRequestWithNoTokenFails() {
+        GraphRequest request = new GraphRequest(null, "me");
+        GraphResponse response = request.executeAndWait();
 
         assertNotNull(response.getError());
     }
 
-    @MediumTest
     @LargeTest
     public void testExecuteRequestMe() {
-        TestSession session = openTestSessionWithSharedUser();
-        Request request = Request.newMeRequest(session, null);
-        Response response = request.executeAndWait();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
+        GraphRequest request = GraphRequest.newMeRequest(accessToken, null);
+        GraphResponse response = request.executeAndWait();
 
-        validateMeResponse(session, response);
+        validateMeResponse(accessToken, response);
     }
 
-    static void validateMeResponse(TestSession session, Response response) {
+    static void validateMeResponse(AccessToken accessToken, GraphResponse response) {
         assertNull(response.getError());
 
-        GraphUser me = response.getGraphObjectAs(GraphUser.class);
+        JSONObject me = response.getJSONObject();
         assertNotNull(me);
-        assertEquals(session.getTestUserId(), me.getId());
+        assertEquals(accessToken.getUserId(), me.optString("id"));
+        assertNotNull(response.getRawResponse());
     }
 
-    @MediumTest
     @LargeTest
     public void testExecuteMyFriendsRequest() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
-        Request request = Request.newMyFriendsRequest(session, null);
-        Response response = request.executeAndWait();
+        GraphRequest request = GraphRequest.newMyFriendsRequest(accessToken, null);
+        GraphResponse response = request.executeAndWait();
 
-        validateMyFriendsResponse(session, response);
+        validateMyFriendsResponse(response);
     }
 
-    static void validateMyFriendsResponse(TestSession session, Response response) {
+    static void validateMyFriendsResponse(GraphResponse response) {
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        JSONObject graphResult = response.getJSONObject();
         assertNotNull(graphResult);
 
-        List<GraphObject> results = graphResult.getData();
+        JSONArray results = graphResult.optJSONArray("data");
         assertNotNull(results);
+
+        assertNotNull(response.getRawResponse());
     }
 
-    @MediumTest
     @LargeTest
     public void testExecutePlaceRequestWithLocation() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
         Location location = new Location("");
         location.setLatitude(47.6204);
         location.setLongitude(-122.3491);
 
-        Request request = Request.newPlacesSearchRequest(session, location, 5, 5, null, null);
-        Response response = request.executeAndWait();
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, location, 5, 5, null, null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        JSONObject graphResult = response.getJSONObject();
         assertNotNull(graphResult);
 
-        List<GraphObject> results = graphResult.getData();
+        JSONArray results = graphResult.optJSONArray("data");
         assertNotNull(results);
+
+        assertNotNull(response.getRawResponse());
     }
 
-    @MediumTest
     @LargeTest
     public void testExecutePlaceRequestWithSearchText() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
         // Pass a distance without a location to ensure it is correctly ignored.
-        Request request = Request.newPlacesSearchRequest(session, null, 1000, 5, "Starbucks", null);
-        Response response = request.executeAndWait();
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, null, 1000, 5, "Starbucks", null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        JSONObject graphResult = response.getJSONObject();
         assertNotNull(graphResult);
 
-        List<GraphObject> results = graphResult.getData();
+        JSONArray results = graphResult.optJSONArray("data");
         assertNotNull(results);
+
+        assertNotNull(response.getRawResponse());
     }
 
-    @MediumTest
     @LargeTest
     public void testExecutePlaceRequestWithLocationAndSearchText() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
         Location location = new Location("");
         location.setLatitude(47.6204);
         location.setLongitude(-122.3491);
 
-        Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, "Starbucks", null);
-        Response response = request.executeAndWait();
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, location, 1000, 5, "Starbucks", null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        JSONObject graphResult = response.getJSONObject();
         assertNotNull(graphResult);
 
-        List<GraphObject> results = graphResult.getData();
+        JSONArray results = graphResult.optJSONArray("data");
         assertNotNull(results);
+
+        assertNotNull(response.getRawResponse());
     }
 
     private String executePostOpenGraphRequest() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
-        GraphObject data = GraphObject.Factory.create();
-        data.setProperty("a_property", "hello");
+        JSONObject data = new JSONObject();
+        try {
+            data.put("a_property", "hello");
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
 
-        Request request = Request.newPostOpenGraphObjectRequest(session, TEST_OG_TYPE, "a title",
-                "http://www.facebook.com", "http://www.facebook.com/zzzzzzzzzzzzzzzzzzz", "a description", data, null);
-        Response response = request.executeAndWait();
+        GraphRequest request = ShareInternalUtility.newPostOpenGraphObjectRequest(
+                accessToken,
+                TEST_OG_TYPE,
+                "a title",
+                "http://www.facebook.com",
+                "http://www.facebook.com/zzzzzzzzzzzzzzzzzzz",
+                "a description",
+                data,
+                null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObject graphResult = response.getGraphObject();
+        JSONObject graphResult = response.getJSONObject();
         assertNotNull(graphResult);
-        assertNotNull(graphResult.getProperty("id"));
+        assertNotNull(graphResult.optString("id"));
+
+        assertNotNull(response.getRawResponse());
 
-        return (String) graphResult.getProperty("id");
+        return (String) graphResult.optString("id");
     }
 
     @LargeTest
@@ -575,51 +286,59 @@ public void testExecutePostOpenGraphRequest() {
     public void testDeleteObjectRequest() {
         String id = executePostOpenGraphRequest();
 
-        TestSession session = openTestSessionWithSharedUser();
-        Request request = Request.newDeleteObjectRequest(session, id, null);
-        Response response = request.executeAndWait();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
+        GraphRequest request = GraphRequest.newDeleteObjectRequest(accessToken, id, null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObject result = response.getGraphObject();
+        JSONObject result = response.getJSONObject();
         assertNotNull(result);
 
-        assertTrue((Boolean) result.getProperty(Response.NON_JSON_RESPONSE_PROPERTY));
+        assertTrue(result.optBoolean(GraphResponse.SUCCESS_KEY));
+        assertNotNull(response.getRawResponse());
     }
 
     @LargeTest
-    public void testUpdateOpenGraphObjectRequest() {
+    public void testUpdateOpenGraphObjectRequest() throws JSONException {
         String id = executePostOpenGraphRequest();
 
-        GraphObject data = GraphObject.Factory.create();
-        data.setProperty("a_property", "goodbye");
+        JSONObject data = new JSONObject();
+        data.put("a_property", "goodbye");
 
-        TestSession session = openTestSessionWithSharedUser();
-        Request request = Request.newUpdateOpenGraphObjectRequest(session, id, "another title", null,
-                "http://www.facebook.com/aaaaaaaaaaaaaaaaa", "another description", data, null);
-        Response response = request.executeAndWait();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
+        GraphRequest request = ShareInternalUtility.newUpdateOpenGraphObjectRequest(accessToken, id,
+                "another title", null, "http://www.facebook.com/aaaaaaaaaaaaaaaaa",
+                "another description", data, null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObject result = response.getGraphObject();
+        JSONObject result = response.getJSONObject();
         assertNotNull(result);
+        assertNotNull(response.getRawResponse());
     }
 
     @LargeTest
     public void testExecuteUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
         Bitmap image = createTestBitmap(128);
 
-        Request request = Request.newUploadPhotoRequest(session, image, null);
-        Response response = request.executeAndWait();
+        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
+                accessToken,
+                image,
+                "Test photo message",
+                null);
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
 
         assertNull(response.getError());
 
-        GraphObject result = response.getGraphObject();
+        JSONObject result = response.getJSONObject();
         assertNotNull(result);
+        assertNotNull(response.getRawResponse());
     }
 
     @LargeTest
@@ -628,7 +347,7 @@ public void testExecuteUploadPhotoViaFile() throws IOException {
         FileOutputStream outStream = null;
 
         try {
-            TestSession session = openTestSessionWithSharedUser();
+            final AccessToken accessToken = getAccessTokenForSharedUser(); 
             Bitmap image = createTestBitmap(128);
 
             File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
@@ -639,14 +358,19 @@ public void testExecuteUploadPhotoViaFile() throws IOException {
             outStream.close();
             outStream = null;
 
-            Request request = Request.newUploadPhotoRequest(session, outputFile, null);
-            Response response = request.executeAndWait();
+            GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
+                    accessToken,
+                    outputFile,
+                    "Test photo message",
+                    null);
+            GraphResponse response = request.executeAndWait();
             assertNotNull(response);
 
             assertNull(response.getError());
 
-            GraphObject result = response.getGraphObject();
+            JSONObject result = response.getJSONObject();
             assertNotNull(result);
+            assertNotNull(response.getRawResponse());
         } finally {
             if (outStream != null) {
                 outStream.close();
@@ -657,93 +381,78 @@ public void testExecuteUploadPhotoViaFile() throws IOException {
         }
     }
 
-    @LargeTest
-    public void testUploadVideoFile() throws IOException, URISyntaxException {
-        File tempFile = null;
-        try {
-            TestSession session = openTestSessionWithSharedUser();
-            tempFile = createTempFileFromAsset("DarkScreen.mov");
-
-            Request request = Request.newUploadVideoRequest(session, tempFile, null);
-            Response response = request.executeAndWait();
-            assertNotNull(response);
-
-            assertNull(response.getError());
-
-            GraphObject result = response.getGraphObject();
-            assertNotNull(result);
-        } catch (Exception ex) {
-            return;
-        } finally {
-            if (tempFile != null) {
-                tempFile.delete();
-            }
-        }
-    }
+//    RE-ENABLE WITH ShareApi ONCE VIDEOS TEAM FIXES ENDPOINT
+//
+//    @LargeTest
+//    public void testUploadVideoFile() throws IOException, URISyntaxException {
+//        File tempFile = null;
+//        try {
+//            final AccessToken accessToken = getAccessTokenForSharedUser();
+//            tempFile = createTempFileFromAsset("DarkScreen.mov");
+//
+//            GraphRequest request = ShareInternalUtility.newUploadVideoRequest(accessToken, tempFile,
+//                    null);
+//            GraphResponse response = request.executeAndWait();
+//            assertNotNull(response);
+//
+//            assertNull(response.getError());
+//
+//            JSONObject result = response.getJSONObject();
+//            assertNotNull(result);
+//            assertNotNull(response.getRawResponse());
+//        } catch (Exception ex) {
+//            return;
+//        } finally {
+//            if (tempFile != null) {
+//                tempFile.delete();
+//            }
+//        }
+//    }
 
     @LargeTest
     public void testPostStatusUpdate() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        GraphObject statusUpdate = createStatusUpdate("");
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
-        GraphObject retrievedStatusUpdate = postGetAndAssert(session, "me/feed", statusUpdate);
+        JSONObject statusUpdate = createStatusUpdate("");
 
-        assertEquals(statusUpdate.getProperty("message"), retrievedStatusUpdate.getProperty("message"));
-    }
-
-    @LargeTest
-    public void testRestMethodGetUser() {
-        TestSession session = openTestSessionWithSharedUser();
-        String testUserId = session.getTestUserId();
-
-        Bundle parameters = new Bundle();
-        parameters.putString("uids", testUserId);
-        parameters.putString("fields", "uid,name");
-
-        Request request = Request.newRestRequest(session, "users.getInfo", parameters, null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        GraphObjectList<GraphObject> graphObjects = response.getGraphObjectList();
-        assertNotNull(graphObjects);
-        assertEquals(1, graphObjects.size());
+        JSONObject retrievedStatusUpdate = postGetAndAssert(accessToken, "me/feed",
+                statusUpdate);
 
-        GraphObject user = graphObjects.get(0);
-        assertNotNull(user);
-        assertEquals(testUserId, user.getProperty("uid").toString());
+        assertEquals(statusUpdate.optString("message"), retrievedStatusUpdate.optString("message"));
     }
 
-    @MediumTest
     @LargeTest
     public void testCallbackIsCalled() {
-        Request request = new Request(null, "4");
+        GraphRequest request = new GraphRequest(null, "4");
 
         final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
-        request.setCallback(new Request.Callback() {
+        request.setCallback(new GraphRequest.Callback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
                 calledBack.add(true);
             }
         });
 
-        Response response = request.executeAndWait();
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
         assertTrue(calledBack.size() == 1);
     }
 
-    @MediumTest
     @LargeTest
     public void testOnProgressCallbackIsCalled() {
         Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
 
-        Request request = Request.newUploadPhotoRequest(null, image, null);
+        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
+                null,
+                image,
+                null,
+                null);
         assertTrue(request != null);
 
         final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
-        request.setCallback(new Request.OnProgressCallback() {
+        request.setCallback(new GraphRequest.OnProgressCallback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
             }
 
             @Override
@@ -752,23 +461,26 @@ public void onProgress(long current, long max) {
             }
         });
 
-        Response response = request.executeAndWait();
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
         assertFalse(calledBack.isEmpty());
     }
 
-    @MediumTest
     @LargeTest
     public void testLastOnProgressCallbackIsCalledOnce() {
         Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
 
-        Request request = Request.newUploadPhotoRequest(null, image, null);
+        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
+                null,
+                image,
+                null,
+                null);
         assertTrue(request != null);
 
         final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
-        request.setCallback(new Request.OnProgressCallback() {
+        request.setCallback(new GraphRequest.OnProgressCallback() {
             @Override
-            public void onCompleted(Response response) {
+            public void onCompleted(GraphResponse response) {
             }
 
             @Override
@@ -778,76 +490,47 @@ public void onProgress(long current, long max) {
             }
         });
 
-        Response response = request.executeAndWait();
+        GraphResponse response = request.executeAndWait();
         assertNotNull(response);
         assertEquals(1, calledBack.size());
     }
 
-    @MediumTest
     @LargeTest
     public void testBatchTimeoutIsApplied() {
-        Request request = new Request(null, "me");
-        RequestBatch batch = new RequestBatch(request);
+        GraphRequest request = new GraphRequest(null, "me");
+        GraphRequestBatch batch = new GraphRequestBatch(request);
 
         // We assume 1 ms is short enough to fail
         batch.setTimeout(1);
 
-        List<Response> responses = Request.executeBatchAndWait(batch);
+        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(batch);
         assertNotNull(responses);
         assertTrue(responses.size() == 1);
-        Response response = responses.get(0);
+        GraphResponse response = responses.get(0);
         assertNotNull(response);
         assertNotNull(response.getError());
     }
 
-    @MediumTest
     @LargeTest
     public void testBatchTimeoutCantBeNegative() {
         try {
-            RequestBatch batch = new RequestBatch();
+            GraphRequestBatch batch = new GraphRequestBatch();
             batch.setTimeout(-1);
             fail();
         } catch (IllegalArgumentException ex) {
         }
     }
 
-    @MediumTest
-    @LargeTest
-    public void testCantSetBothGraphPathAndRestMethod() {
-        Request request = new Request();
-        request.setGraphPath("me");
-        request.setRestMethod("amethod");
-        request.setCallback(new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testClosedSessionDoesntAppendAccessToken() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.close();
-        Request request = new Request(session, "me", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(1);
-    }
-
-    @MediumTest
     @LargeTest
     public void testCantUseComplexParameterInGetRequest() {
-        TestSession session = openTestSessionWithSharedUser();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
 
         Bundle parameters = new Bundle();
         parameters.putShortArray("foo", new short[1]);
 
-        Request request = new Request(session, "me", parameters, HttpMethod.GET, new ExpectFailureCallback());
-        Response response = request.executeAndWait();
+        GraphRequest request = new GraphRequest(accessToken, "me", parameters, HttpMethod.GET,
+                new ExpectFailureCallback());
+        GraphResponse response = request.executeAndWait();
 
         FacebookRequestError error = response.getError();
         assertNotNull(error);
@@ -865,56 +548,49 @@ public void testCantUseComplexParameterInGetRequest() {
 
     @LargeTest
     public void testPaging() {
-        TestSession session = openTestSessionWithSharedUser();
-        final List<GraphPlace> returnedPlaces = new ArrayList<GraphPlace>();
-        Request request = Request
-                .newPlacesSearchRequest(session, SEATTLE_LOCATION, 1000, 5, null, new Request.GraphPlaceListCallback() {
-                    @Override
-                    public void onCompleted(List<GraphPlace> places, Response response) {
-                        returnedPlaces.addAll(places);
-                    }
-                });
-        Response response = request.executeAndWait();
+        final AccessToken accessToken = getAccessTokenForSharedUser(); 
+        final List<JSONObject> returnedPlaces = new ArrayList<JSONObject>();
+        GraphRequest request = GraphRequest
+                .newPlacesSearchRequest(accessToken, SEATTLE_LOCATION, 1000, 3, null,
+                        new GraphRequest.GraphJSONArrayCallback() {
+                            @Override
+                            public void onCompleted(JSONArray places, GraphResponse response) {
+                                if (places == null) {
+                                    assertNotNull(places);
+                                }
+                                for (int i = 0; i < places.length(); ++i) {
+                                    returnedPlaces.add(places.optJSONObject(i));
+                                }
+                            }
+                        });
+        GraphResponse response = request.executeAndWait();
 
         assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
+        assertNotNull(response.getJSONObject());
         assertNotSame(0, returnedPlaces.size());
 
         returnedPlaces.clear();
 
-        Request nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
+        GraphRequest nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
         assertNotNull(nextRequest);
 
         nextRequest.setCallback(request.getCallback());
         response = nextRequest.executeAndWait();
 
         assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
+        assertNotNull(response.getJSONObject());
         assertNotSame(0, returnedPlaces.size());
 
         returnedPlaces.clear();
 
-        Request previousRequest = response.getRequestForPagedResults(Response.PagingDirection.PREVIOUS);
+        GraphRequest previousRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.PREVIOUS);
         assertNotNull(previousRequest);
 
         previousRequest.setCallback(request.getCallback());
         response = previousRequest.executeAndWait();
 
         assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
+        assertNotNull(response.getJSONObject());
         assertNotSame(0, returnedPlaces.size());
     }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestWithClosedSessionThrowsException() {
-        TestSession session = getTestSessionWithSharedUser();
-        assertFalse(session.isOpened());
-
-        Request request = new Request(session, "4");
-        Response response = request.executeAndWait();
-
-        assertNotNull(response.getError());
-    }
 }
diff --git a/facebook/tests/src/com/facebook/SessionTests.java b/facebook/tests/src/com/facebook/SessionTests.java
deleted file mode 100644
index 3f5a9f6a6..000000000
--- a/facebook/tests/src/com/facebook/SessionTests.java
+++ /dev/null
@@ -1,815 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.support.v4.content.LocalBroadcastManager;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-public class SessionTests extends SessionTestsBase {
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFailNullArguments() {
-        try {
-            new Session(null);
-
-            // Should not get here
-            assertFalse(true);
-        } catch (NullPointerException e) {
-            // got expected exception
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testActiveSessionChangeRegistration() {
-        final WaitForBroadcastReceiver receiver0 = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiver1 = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiver2 = new WaitForBroadcastReceiver();
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        try {
-            // Register these on the blocker thread so they will send
-            // notifications there as well. The notifications need to be on a
-            // different thread than the progress.
-            Runnable initialize0 = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiver0, getActiveSessionAllFilter());
-
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-
-                    broadcastManager.registerReceiver(receiver2,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver2,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-                }
-            };
-            runOnBlockerThread(initialize0, true);
-
-            // Verify all actions show up where they are expected
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1);
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-            receiver0.waitForExpectedCalls();
-
-            // Remove receiver1 and verify actions continue to show up where
-            // expected
-            broadcastManager.unregisterReceiver(receiver1);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            receiver0.waitForExpectedCalls();
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-            receiver0.waitForExpectedCalls();
-
-            // Remove receiver0 and register receiver1 multiple times for one
-            // action
-            broadcastManager.unregisterReceiver(receiver0);
-
-            Runnable initialize1 = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                }
-            };
-            runOnBlockerThread(initialize1, true);
-
-            receiver1.incrementExpectCount(3);
-            receiver2.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            receiver1.waitForExpectedCalls();
-            receiver2.waitForExpectedCalls();
-
-            receiver2.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            receiver2.waitForExpectedCalls();
-
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-
-            closeBlockerAndAssertSuccess();
-        } finally {
-            broadcastManager.unregisterReceiver(receiver0);
-            broadcastManager.unregisterReceiver(receiver1);
-            broadcastManager.unregisterReceiver(receiver2);
-            Session.setActiveSession(null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetActiveSession() {
-        Session.setActiveSession(null);
-
-        final WaitForBroadcastReceiver receiverOpened = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverClosed = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver();
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        try {
-            Runnable initializeOnBlockerThread = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiverOpened,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiverClosed,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-                    broadcastManager.registerReceiver(receiverSet,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
-                    broadcastManager.registerReceiver(receiverUnset,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_UNSET));
-                }
-            };
-            runOnBlockerThread(initializeOnBlockerThread, true);
-
-            // null -> null should not fire events
-            assertEquals(null, Session.getActiveSession());
-            Session.setActiveSession(null);
-            assertEquals(null, Session.getActiveSession());
-
-            Session session0 = new Session.Builder(getActivity()).
-                    setApplicationId("FakeAppId").
-                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
-                    build();
-            assertEquals(SessionState.CREATED_TOKEN_LOADED, session0.getState());
-
-            // For unopened session, we should only see the Set event.
-            receiverSet.incrementExpectCount();
-            Session.setActiveSession(session0);
-            assertEquals(session0, Session.getActiveSession());
-            receiverSet.waitForExpectedCalls();
-
-            // When we open it, then we should see the Opened event.
-            receiverOpened.incrementExpectCount();
-            session0.openForRead(null);
-            receiverOpened.waitForExpectedCalls();
-
-            // Setting to itself should not fire events
-            Session.setActiveSession(session0);
-            assertEquals(session0, Session.getActiveSession());
-
-            // Setting from one opened session to another should deliver a full
-            // cycle of events
-            WaitForBroadcastReceiver.incrementExpectCounts(receiverClosed, receiverUnset, receiverSet, receiverOpened);
-            Session session1 = new Session.Builder(getActivity()).
-                    setApplicationId("FakeAppId").
-                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
-                    build();
-            assertEquals(SessionState.CREATED_TOKEN_LOADED, session1.getState());
-            session1.openForRead(null);
-            assertEquals(SessionState.OPENED, session1.getState());
-            Session.setActiveSession(session1);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiverClosed, receiverUnset, receiverSet, receiverOpened);
-            assertEquals(SessionState.CLOSED, session0.getState());
-            assertEquals(session1, Session.getActiveSession());
-
-            closeBlockerAndAssertSuccess();
-        } finally {
-            broadcastManager.unregisterReceiver(receiverOpened);
-            broadcastManager.unregisterReceiver(receiverClosed);
-            broadcastManager.unregisterReceiver(receiverSet);
-            broadcastManager.unregisterReceiver(receiverUnset);
-            Session.setActiveSession(null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForPublishSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[]{
-                        "publish_something",
-                        "manage_something",
-                        "ads_management",
-                        "create_event",
-                        "rsvp_event"
-                })));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForPublishSuccessWithReadPermissions() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[]{
-                        "publish_something",
-                        "manage_something",
-                        "ads_management",
-                        "create_event",
-                        "rsvp_event",
-                        "read_something"
-                })));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenFromTokenCache() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        String token = "A token less unique than most";
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(token, DEFAULT_TIMEOUT_MILLISECONDS);
-        ScriptedSession session = createScriptedSessionOnBlockerThread("app-id", cache);
-
-        // Verify state when we have a token in cache.
-        assertEquals(SessionState.CREATED_TOKEN_LOADED, session.getState());
-
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-
-        // Verify we open with no authorize call.
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify no token information is saved.
-        assertTrue(cache.getSavedState() == null);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenActiveFromEmptyTokenCache() {
-        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
-
-        assertNull(Session.openActiveSessionFromCache(getActivity()));
-    }
-
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenFailure() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        Exception openException = new Exception();
-
-        session.addAuthorizeResult(openException);
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-
-        // Verify we get the expected exception and no saved state.
-        statusRecorder.waitForCall(session, SessionState.CLOSED_LOGIN_FAILED, openException);
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForReadFailure() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        try {
-            session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                    setPermissions(Arrays.asList(new String[]{"publish_something"})));
-            fail("should not reach here without an exception");
-        } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
-        } finally {
-            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-            statusRecorder.close();
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestNewReadPermissionsSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Session.open
-        final AccessToken openToken = AccessToken
-                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("play_outside");
-
-        session.addAuthorizeResult(openToken, "play_outside");
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Successful Session.reauthorize with new permissions
-        final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and eating ice cream", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("eat_ice_cream");
-
-        session.addAuthorizeResult(reauthorizeToken, "play_outside", "eat_ice_cream");
-        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
-
-        verifySessionHasToken(session, reauthorizeToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Failing reauthorization with new permissions
-        final Exception reauthorizeException = new Exception("Don't run with scissors");
-        permissions.add("run_with_scissors");
-
-        session.addAuthorizeResult(reauthorizeException);
-        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, reauthorizeException);
-
-        // Verify we do not overwrite cache if reauthorize fails
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorders.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestNewPublishPermissionsSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Session.open
-        final AccessToken openToken = AccessToken
-                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("play_outside");
-
-        session.addAuthorizeResult(openToken, "play_outside");
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Successful Session.reauthorize with new permissions
-        final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and publish eating ice cream", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("publish_eat_ice_cream");
-
-        session.addAuthorizeResult(reauthorizeToken, "play_outside", "publish_eat_ice_cream");
-        session.requestNewPublishPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
-
-        verifySessionHasToken(session, reauthorizeToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Failing reauthorization with publish permissions on a read request
-        permissions.add("publish_run_with_scissors");
-
-        try {
-            session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-            fail("Should not reach here without an exception");
-        } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
-        } finally {
-            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-            statusRecorder.close();
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenWithAccessToken() {
-        String token = "This is a fake token.";
-        Date expirationDate = new Date(new Date().getTime() + 3600 * 1000);
-        Date lastRefreshDate = new Date();
-        List<String> permissions = Arrays.asList(new String[]{"email", "publish_stream"});
-
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, expirationDate, lastRefreshDate,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, permissions);
-        session.open(accessToken, statusRecorder);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        AccessToken expectedToken = new AccessToken(token, expirationDate, permissions,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, lastRefreshDate);
-        verifySessionHasToken(session, expectedToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(expectedToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenWithAccessTokenWithDefaults() {
-        String token = "This is a fake token.";
-
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
-        session.open(accessToken, statusRecorder);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertEquals(token, session.getAccessToken());
-        assertEquals(new Date(Long.MAX_VALUE), session.getExpirationDate());
-        assertEquals(0, session.getPermissions().size());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSessionWillExtendTokenIfNeeded() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.forceExtendAccessToken(true);
-
-        Request request = Request.newMeRequest(session, null);
-        request.executeAndWait();
-
-        assertTrue(session.getWasAskedToExtendAccessToken());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSessionWillNotExtendTokenIfCurrentlyAttempting() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.forceExtendAccessToken(true);
-        session.fakeTokenRefreshAttempt();
-
-        Request request = Request.newMeRequest(session, null);
-        request.executeAndWait();
-        assertFalse(session.getWasAskedToExtendAccessToken());
-    }
-
-
-    @LargeTest
-    public void testBasicSerialization() throws IOException, ClassNotFoundException {
-        // Try to test the happy path, that there are no unserializable fields
-        // in the session.
-        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").build();
-        Session session1 = TestUtils.serializeAndUnserialize(session0);
-
-        // do some basic assertions
-        assertNotNull(session0.getAccessToken());
-        assertEquals(session0, session1);
-
-        Session.AuthorizationRequest authRequest0 =
-                new Session.OpenRequest(getActivity()).
-                        setRequestCode(123).
-                        setLoginBehavior(SessionLoginBehavior.SSO_ONLY);
-        Session.AuthorizationRequest authRequest1 = TestUtils.serializeAndUnserialize(authRequest0);
-
-        assertEquals(authRequest0.getLoginBehavior(), authRequest1.getLoginBehavior());
-        assertEquals(authRequest0.getRequestCode(), authRequest1.getRequestCode());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenSessionWithNativeLinkingIntent() {
-        String token = "A token less unique than most";
-
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, DEFAULT_TIMEOUT_MILLISECONDS);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
-        assertNotNull(accessToken);
-        session.open(accessToken, statusRecorder);
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertEquals(token, session.getAccessToken());
-        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
-        long delta = session.getExpirationDate().getTime() - new Date().getTime();
-        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
-        assertEquals(0, session.getPermissions().size());
-        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        assertFalse(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenActiveSessionWithNativeLinkingIntent() {
-        Session activeSession = Session.getActiveSession();
-        if (activeSession != null) {
-            activeSession.closeAndClearTokenInformation();
-        }
-
-        SharedPreferencesTokenCachingStrategy tokenCache = new SharedPreferencesTokenCachingStrategy(getActivity());
-        assertEquals(0, tokenCache.load().size());
-
-        String token = "A token less unique than most";
-
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-
-        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
-        assertNotNull(accessToken);
-        Session session = Session.openActiveSessionWithAccessToken(getActivity(), accessToken, statusRecorder);
-        assertEquals(session, Session.getActiveSession());
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertNotSame(0, tokenCache.load().size());
-
-        assertEquals(token, session.getAccessToken());
-        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
-        long delta = session.getExpirationDate().getTime() - new Date().getTime();
-        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
-        assertEquals(0, session.getPermissions().size());
-        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpeningSessionWithPendingRequestResultsInExceptionCallback() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-        session.addPendingAuthorizeResult();
-
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENING, new UnsupportedOperationException());
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    static IntentFilter getActiveSessionFilter(String... actions) {
-        IntentFilter filter = new IntentFilter();
-
-        for (String action : actions) {
-            filter.addAction(action);
-        }
-
-        return filter;
-    }
-
-    static IntentFilter getActiveSessionAllFilter() {
-        return getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED, Session.ACTION_ACTIVE_SESSION_OPENED,
-                Session.ACTION_ACTIVE_SESSION_SET, Session.ACTION_ACTIVE_SESSION_UNSET);
-    }
-
-    private void verifySessionHasToken(Session session, AccessToken token) {
-        assertEquals(token.getToken(), session.getAccessToken());
-        assertEquals(token.getExpires(), session.getExpirationDate());
-        TestUtils.assertAtLeastExpectedPermissions(token.getPermissions(), session.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/SessionTestsBase.java b/facebook/tests/src/com/facebook/SessionTestsBase.java
deleted file mode 100644
index abbb6d2c3..000000000
--- a/facebook/tests/src/com/facebook/SessionTestsBase.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.os.Looper;
-import com.facebook.internal.Utility;
-
-import java.util.*;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-
-public class SessionTestsBase extends FacebookTestCase {
-    public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
-    static final int SIMULATED_WORKING_MILLISECONDS = 20;
-    public static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
-
-    public ScriptedSession createScriptedSessionOnBlockerThread(TokenCachingStrategy cachingStrategy) {
-        return createScriptedSessionOnBlockerThread(Utility.getMetadataApplicationId(getActivity()), cachingStrategy);
-    }
-
-    ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
-            final TokenCachingStrategy cachingStrategy) {
-        class MutableState {
-            ScriptedSession session;
-        }
-        ;
-        final MutableState mutable = new MutableState();
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                mutable.session = new ScriptedSession(getActivity(), applicationId, cachingStrategy);
-            }
-        }, true);
-
-        return mutable.session;
-    }
-
-    public static void stall(int stallMsec) {
-        try {
-            Thread.sleep(stallMsec);
-        } catch (InterruptedException e) {
-            fail("InterruptedException while stalling");
-        }
-    }
-
-    public class ScriptedSession extends Session {
-        private static final long serialVersionUID = 1L;
-        private final LinkedList<AuthorizeResult> pendingAuthorizations = new LinkedList<AuthorizeResult>();
-        private AuthorizationRequest lastRequest;
-        private AuthorizeResult currentAuthorization = null;
-
-        public ScriptedSession(Context currentContext, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
-            super(currentContext, applicationId, tokenCachingStrategy);
-        }
-
-        public void addAuthorizeResult(String token, List<String> permissions, AccessTokenSource source) {
-            addAuthorizeResult(AccessToken.createFromString(token, permissions, source));
-        }
-
-        public void addAuthorizeResult(AccessToken token) {
-            pendingAuthorizations.add(new AuthorizeResult(token));
-        }
-
-        public void addAuthorizeResult(AccessToken token, List<String> permissions) {
-            pendingAuthorizations.add(new AuthorizeResult(token, permissions));
-        }
-
-        public void addAuthorizeResult(AccessToken token, String... permissions) {
-            pendingAuthorizations.add(new AuthorizeResult(token, Arrays.asList(permissions)));
-        }
-
-        public void addAuthorizeResult(Exception exception) {
-            pendingAuthorizations.add(new AuthorizeResult(exception));
-        }
-
-        public void addPendingAuthorizeResult() {
-            pendingAuthorizations.add(new AuthorizeResult());
-        }
-
-        public AuthorizationRequest getLastRequest() {
-            return lastRequest;
-        }
-
-        public SessionDefaultAudience getLastRequestAudience() {
-            return lastRequest.getDefaultAudience();
-        }
-
-        // Overrides authorize to return the next AuthorizeResult we added.
-        @Override
-        void authorize(final AuthorizationRequest request) {
-            lastRequest = request;
-            getActivity().runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    stall(SIMULATED_WORKING_MILLISECONDS);
-                    currentAuthorization = pendingAuthorizations.poll();
-
-                    if (currentAuthorization == null) {
-                        fail("Missing call to addScriptedAuthorization");
-                    }
-                    if (!currentAuthorization.leaveAsPending) {
-                        finishAuthOrReauth(currentAuthorization.token, currentAuthorization.exception);
-                    }
-                }
-            });
-        }
-
-        private class AuthorizeResult {
-            final AccessToken token;
-            final Exception exception;
-            final List<String> resultingPermissions;
-            final boolean leaveAsPending;
-
-            private AuthorizeResult(AccessToken token, Exception exception, List<String> permissions) {
-                this.token = token;
-                this.exception = exception;
-                this.resultingPermissions = permissions;
-                this.leaveAsPending = false;
-            }
-
-            private AuthorizeResult() {
-                this.token = null;
-                this.exception = null;
-                this.resultingPermissions = null;
-                this.leaveAsPending = true;
-            }
-
-            AuthorizeResult(AccessToken token, List<String> permissions) {
-                this(token, null, permissions);
-            }
-
-            AuthorizeResult(AccessToken token) {
-                this(token, null, null);
-            }
-
-            AuthorizeResult(Exception exception) {
-                this(null, exception, null);
-            }
-        }
-    }
-
-    public static class SessionStatusCallbackRecorder implements Session.StatusCallback {
-        private final BlockingQueue<Call> calls = new LinkedBlockingQueue<Call>();
-        volatile boolean isClosed = false;
-
-        public void waitForCall(Session session, SessionState state, Exception exception) {
-            Call call = null;
-
-            try {
-                call = calls.poll(DEFAULT_TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
-                if (call == null) {
-                    fail("Did not get a status callback within timeout.");
-                }
-            } catch (InterruptedException e) {
-                fail("InterruptedException while waiting for status callback: " + e);
-            }
-
-            assertEquals(session, call.session);
-            assertEquals(state, call.state);
-            if (exception != null && call.exception != null) {
-                assertEquals(exception.getClass(), call.exception.getClass());
-            } else {
-                // They should both be null if either of them is.
-                assertTrue(exception == call.exception);
-            }
-        }
-
-        public void close() {
-            isClosed = true;
-            assertEquals(0, calls.size());
-        }
-
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            Call call = new Call(session, state, exception);
-            if (!calls.offer(call)) {
-                fail("Test Error: Blocking queue ran out of capacity");
-            }
-            if (isClosed) {
-                fail("Reauthorize callback called after closed");
-            }
-            assertEquals("Callback should run on main UI thread", Thread.currentThread(),
-                    Looper.getMainLooper().getThread());
-        }
-
-        private static class Call {
-            final Session session;
-            final SessionState state;
-            final Exception exception;
-
-            Call(Session session, SessionState state, Exception exception) {
-                this.session = session;
-                this.state = state;
-                this.exception = exception;
-            }
-        }
-
-    }
-
-    public static class MockTokenCachingStrategy extends TokenCachingStrategy {
-        private final String token;
-        private final long expires_in;
-        private Bundle saved;
-
-        MockTokenCachingStrategy() {
-            this("FakeToken", DEFAULT_TIMEOUT_MILLISECONDS);
-        }
-
-        public MockTokenCachingStrategy(String token, long expires_in) {
-            this.token = token;
-            this.expires_in = expires_in;
-            this.saved = null;
-        }
-
-        public Bundle getSavedState() {
-            return saved;
-        }
-
-        @Override
-        public Bundle load() {
-            Bundle bundle = null;
-
-            if (token != null) {
-                bundle = new Bundle();
-
-                TokenCachingStrategy.putToken(bundle, token);
-                TokenCachingStrategy.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
-            }
-
-            return bundle;
-        }
-
-        @Override
-        public void save(Bundle bundle) {
-            this.saved = bundle;
-        }
-
-        @Override
-        public void clear() {
-            this.saved = null;
-        }
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/SettingsTests.java b/facebook/tests/src/com/facebook/SettingsTests.java
deleted file mode 100644
index 435de6d40..000000000
--- a/facebook/tests/src/com/facebook/SettingsTests.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.ConditionVariable;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.ServerProtocol;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.concurrent.Executor;
-
-public final class SettingsTests extends AndroidTestCase {
-
-    @SmallTest @MediumTest @LargeTest
-    public void testGetExecutor() {
-        final ConditionVariable condition = new ConditionVariable();
-
-        Settings.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                condition.open();
-            }
-        });
-
-        boolean success = condition.block(5000);
-        assertTrue(success);
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testSetExecutor() {
-        final ConditionVariable condition = new ConditionVariable();
-
-        final Runnable runnable = new Runnable() {
-            @Override
-            public void run() { }
-        };
-
-        final Executor executor = new Executor() {
-            @Override
-            public void execute(Runnable command) {
-                assertEquals(runnable, command);
-                command.run();
-
-                condition.open();
-            }
-        };
-
-        Executor original = Settings.getExecutor();
-        try {
-            Settings.setExecutor(executor);
-            Settings.getExecutor().execute(runnable);
-
-            boolean success = condition.block(5000);
-            assertTrue(success);
-        } finally {
-            Settings.setExecutor(original);
-        }
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testLogdException() {
-        try {
-            throw new IOException("Simulated error");
-        } catch (IOException e) {
-            Utility.logd("SettingsTest", e);
-        }
-
-        try {
-            throw new IOException((String)null);
-        } catch (IOException e) {
-            Utility.logd("SettingsTest", e);
-        }
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testFacebookDomain() {
-        Settings.setFacebookDomain("beta.facebook.com");
-
-        String graphUrlBase = ServerProtocol.getGraphUrlBase();
-        assertEquals("https://graph.beta.facebook.com", graphUrlBase);
-
-        Settings.setFacebookDomain("facebook.com");
-    }
-}
diff --git a/facebook/tests/src/com/facebook/TestBlocker.java b/facebook/tests/src/com/facebook/TestBlocker.java
index 93801de3c..5e61e05e4 100644
--- a/facebook/tests/src/com/facebook/TestBlocker.java
+++ b/facebook/tests/src/com/facebook/TestBlocker.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
diff --git a/facebook/tests/src/com/facebook/TestSessionTests.java b/facebook/tests/src/com/facebook/TestSessionTests.java
deleted file mode 100644
index 8c72f4567..000000000
--- a/facebook/tests/src/com/facebook/TestSessionTests.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONArray;
-
-// Because TestSession is the component under test here, be careful in calling methods on FacebookTestCase that
-// assume TestSession works correctly.
-public class TestSessionTests extends FacebookTestCase {
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCreateWithPrivateUser() {
-        TestSession session = TestSession.createSessionWithPrivateUser(getActivity(), null);
-        assertTrue(session != null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCreateWithSharedUser() {
-        TestSession session = TestSession.createSessionWithSharedUser(getActivity(), null);
-        assertTrue(session != null);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanOpenWithSharedUser() throws Throwable {
-        final TestBlocker blocker = getTestBlocker();
-        TestSession session = getTestSessionWithSharedUser();
-
-        Session.OpenRequest openRequest = new Session.OpenRequest(getActivity()).
-                setCallback(
-                        new Session.StatusCallback() {
-                            @Override
-                            public void call(Session session, SessionState state, Exception exception) {
-                                assertTrue(exception == null);
-                                blocker.signal();
-                            }
-                        });
-        session.openForRead(openRequest);
-
-        waitAndAssertSuccess(blocker, 1);
-
-        assertTrue(session.getState().isOpened());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSharedUserDoesntCreateUnnecessaryUsers() throws Throwable {
-        TestSession session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session);
-
-        // Note that this test is somewhat brittle in that the count of test users could change for
-        // external reasons while the test is running. For that reason it may not be appropriate for an
-        // automated test suite, and could be run only when testing changes to TestSession.
-        int startingUserCount = countTestUsers();
-
-        session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session);
-
-        int endingUserCount = countTestUsers();
-
-        assertEquals(startingUserCount, endingUserCount);
-    }
-
-    // This test is currently unreliable, I believe due to timing/replication issues that cause the
-    // counts to occasionally be off. Taking out of test runs for now until a more robust test can be added.
-    @LargeTest
-    public void failing_testPrivateUserIsDeletedOnSessionClose() throws Throwable {
-        final TestBlocker blocker = getTestBlocker();
-
-        // See comment above regarding test user count.
-        int startingUserCount = countTestUsers();
-
-        TestSession session = getTestSessionWithPrivateUser(blocker);
-        openSession(getActivity(), session);
-
-        int sessionOpenUserCount = countTestUsers();
-
-        assertEquals(startingUserCount + 1, sessionOpenUserCount);
-
-        session.close();
-
-        int endingUserCount = countTestUsers();
-
-        assertEquals(startingUserCount, endingUserCount);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotChangeTestApplicationIdOnceSet() {
-        try {
-            TestSession.setTestApplicationId("hello");
-            TestSession.setTestApplicationId("world");
-            fail("expected exception");
-        } catch (FacebookException e) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotChangeTestApplicationSecretOnceSet() {
-        try {
-            TestSession.setTestApplicationSecret("hello");
-            TestSession.setTestApplicationSecret("world");
-            fail("expected exception");
-        } catch (FacebookException e) {
-        }
-    }
-
-    private int countTestUsers() {
-        TestSession session = getTestSessionWithSharedUser(null);
-
-        String appAccessToken = TestSession.getAppAccessToken();
-        assertNotNull(appAccessToken);
-        String applicationId = session.getApplicationId();
-        assertNotNull(applicationId);
-
-        String fqlQuery = String.format("SELECT id FROM test_account WHERE app_id = %s", applicationId);
-        Bundle parameters = new Bundle();
-        parameters.putString("q", fqlQuery);
-        parameters.putString("access_token", appAccessToken);
-
-        Request request = new Request(null, "fql", parameters, null);
-        Response response = request.executeAndWait();
-
-        JSONArray data = (JSONArray) response.getGraphObject().getProperty("data");
-        return data.length();
-    }
-}
diff --git a/facebook/tests/src/com/facebook/TestUserManagerTests.java b/facebook/tests/src/com/facebook/TestUserManagerTests.java
new file mode 100644
index 000000000..de86d03ad
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestUserManagerTests.java
@@ -0,0 +1,91 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import org.json.JSONArray;
+
+// Because TestUserManager is the component under test here, be careful in calling methods on
+// FacebookTestCase that assume TestUserManager works correctly.
+public class TestUserManagerTests extends FacebookTestCase {
+
+    private TestUserManager createTestUserManager() {
+        return new TestUserManager(getApplicationSecret(), getApplicationId());
+    }
+
+    @LargeTest
+    public void testCanGetAccessTokenForPrivateUser() {
+        TestUserManager testUserManager = createTestUserManager();
+        AccessToken accessToken = testUserManager.getAccessTokenForPrivateUser(null);
+        assertNotNull(accessToken);
+    }
+
+    @LargeTest
+    public void testCanGetAccessTokenForSharedUser() {
+        TestUserManager testUserManager = createTestUserManager();
+        AccessToken accessToken = testUserManager.getAccessTokenForSharedUser(null);
+        assertNotNull(accessToken);
+    }
+
+    @LargeTest
+    public void testSharedUserDoesntCreateUnnecessaryUsers() throws Throwable {
+
+        TestUserManager testUserManager = createTestUserManager();
+        AccessToken accessToken = testUserManager.getAccessTokenForSharedUser(null);
+        assertNotNull(accessToken);
+
+        // Note that this test is somewhat brittle in that the count of test users could change for
+        // external reasons while the test is running. For that reason it may not be appropriate for
+        // an automated test suite, and could be run only when testing changes to TestSession.
+        int startingUserCount = countTestUsers();
+
+        accessToken = testUserManager.getAccessTokenForSharedUser(null);
+        assertNotNull(accessToken);
+
+        int endingUserCount = countTestUsers();
+
+        assertEquals(startingUserCount, endingUserCount);
+    }
+
+    private int countTestUsers() {
+        TestUserManager testUserManager = createTestUserManager();
+
+        String appAccessToken = testUserManager.getAppAccessToken();
+        assertNotNull(appAccessToken);
+
+        Bundle parameters = new Bundle();
+
+        parameters.putString("access_token", appAccessToken);
+        parameters.putString("fields", "id");
+
+        GraphRequest requestTestUsers =
+                new GraphRequest(null, "app/accounts/test-users", parameters, null);
+
+        GraphResponse response = requestTestUsers.executeAndWait();
+
+        JSONArray data = response.getJSONObject().optJSONArray("data");
+        return data.length();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestUtils.java b/facebook/tests/src/com/facebook/TestUtils.java
index 4a67e9d4a..c0d89c49b 100644
--- a/facebook/tests/src/com/facebook/TestUtils.java
+++ b/facebook/tests/src/com/facebook/TestUtils.java
@@ -1,33 +1,44 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
 
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.AssetManager;
 import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
 import com.facebook.internal.FileLruCache;
+import com.facebook.internal.Utility;
 import junit.framework.Assert;
+import org.json.JSONArray;
+import org.json.JSONObject;
 
 import java.io.*;
-import java.util.Date;
-import java.util.List;
+import java.util.*;
 
 public class TestUtils {
     private static long CACHE_CLEAR_TIMEOUT = 3000;
 
-    public static <T extends Serializable> T serializeAndUnserialize(T t) {
+    public static <T extends Serializable> T serializeAndUnserialize(final T t) {
         try {
             ByteArrayOutputStream os = new ByteArrayOutputStream();
             new ObjectOutputStream(os).writeObject(t);
@@ -44,11 +55,26 @@
         }
     }
 
-    static Date nowPlusSeconds(long offset) {
+    public static <E extends Parcelable> E parcelAndUnparcel(final E object) {
+        final Parcel writeParcel = Parcel.obtain();
+        final Parcel readParcel = Parcel.obtain();
+        try {
+            writeParcel.writeParcelable(object, 0);
+            final byte[] bytes = writeParcel.marshall();
+            readParcel.unmarshall(bytes, 0, bytes.length);
+            readParcel.setDataPosition(0);
+            return readParcel.readParcelable(object.getClass().getClassLoader());
+        } finally {
+            writeParcel.recycle();
+            readParcel.recycle();
+        }
+    }
+
+    public static Date nowPlusSeconds(final long offset) {
         return new Date(new Date().getTime() + (offset * 1000L));
     }
 
-    static void assertSamePermissions(List<String> expected, AccessToken actual) {
+    public static void assertSamePermissions(final Collection<String> expected, final AccessToken actual) {
         if (expected == null) {
             Assert.assertEquals(null, actual.getPermissions());
         } else {
@@ -61,7 +87,7 @@ static void assertSamePermissions(List<String> expected, AccessToken actual) {
         }
     }
 
-    static void assertSamePermissions(List<String> expected, List<String> actual) {
+    public static void assertSamePermissions(final Collection<String> expected, final Collection<String> actual) {
         if (expected == null) {
             Assert.assertEquals(null, actual);
         } else {
@@ -74,7 +100,7 @@ static void assertSamePermissions(List<String> expected, List<String> actual) {
         }
     }
 
-    static void assertAtLeastExpectedPermissions(List<String> expected, List<String> actual) {
+    public static void assertAtLeastExpectedPermissions(final Collection<String> expected, final Collection<String> actual) {
         if (expected != null) {
             for (String p : expected) {
                 Assert.assertTrue(actual.contains(p));
@@ -82,7 +108,7 @@ static void assertAtLeastExpectedPermissions(List<String> expected, List<String>
         }
     }
 
-    static void assertEqualContents(Bundle a, Bundle b) {
+    public static void assertEqualContents(final Bundle a, final Bundle b) {
         for (String key : a.keySet()) {
             if (!b.containsKey(key)) {
                 Assert.fail("bundle does not include key " + key);
@@ -96,12 +122,94 @@ static void assertEqualContents(Bundle a, Bundle b) {
         }
     }
 
+    @TargetApi(16)
+    public static void assertEquals(final JSONObject expected, final JSONObject actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (areEqual(expected, actual)) {
+            return;
+        }
+        Assert.failNotEquals("", expected, actual);
+    }
+
+    @TargetApi(16)
+    public static void assertEquals(final JSONArray expected, final JSONArray actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (areEqual(expected, actual)) {
+            return;
+        }
+        Assert.failNotEquals("", expected, actual);
+    }
+
+    private static boolean areEqual(final JSONObject expected, final JSONObject actual) {
+        // JSONObject.equals does not do an order-independent comparison, so let's roll our own  :(
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+
+        final Iterator<String> expectedKeysIterator = expected.keys();
+        final HashSet<String> expectedKeys = new HashSet<String>();
+        while (expectedKeysIterator.hasNext()) {
+            expectedKeys.add(expectedKeysIterator.next());
+        }
+
+        final Iterator<String> actualKeysIterator = actual.keys();
+        while (actualKeysIterator.hasNext()) {
+            final String key = actualKeysIterator.next();
+            if (!areEqual(expected.opt(key), actual.opt(key))) {
+                return false;
+            }
+            expectedKeys.remove(key);
+        }
+        return expectedKeys.size() == 0;
+    }
+
+    private static boolean areEqual(final JSONArray expected, final JSONArray actual) {
+        // JSONObject.equals does not do an order-independent comparison, so we need to check values that are JSONObject
+        // manually
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+        if (expected.length() != actual.length()) {
+            return false;
+        }
+
+        final int length = expected.length();
+        for (int i = 0; i < length; ++i) {
+            if (!areEqual(expected.opt(i), actual.opt(i))) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private static boolean areEqual(final Object expected, final Object actual) {
+        if (expected == actual) {
+            return true;
+        }
+        if ((expected == null) || (actual == null)) {
+            return false;
+        }
+        if ((expected instanceof JSONObject) && (actual instanceof JSONObject)) {
+            return areEqual((JSONObject)expected, (JSONObject)actual);
+        }
+        if ((expected instanceof JSONArray) && (actual instanceof JSONArray)) {
+            return areEqual((JSONArray)expected, (JSONArray)actual);
+        }
+        return expected.equals(actual);
+    }
+
     public static void clearFileLruCache(final FileLruCache cache) throws InterruptedException {
         // since the cache clearing happens in a separate thread, we need to wait until
         // the clear is complete before we can check for the existence of the old files
         synchronized (cache) {
             cache.clearCache();
-            Settings.getExecutor().execute(new Runnable() {
+            FacebookSdk.getExecutor().execute(new Runnable() {
                 @Override
                 public void run() {
                     synchronized (cache) {
@@ -114,4 +222,23 @@ public void run() {
         // sleep a little more just to make sure all the files are deleted.
         Thread.sleep(CACHE_CLEAR_TIMEOUT);
     }
+
+    public static String getAssetFileStringContents(final Context context, final String assetPath) throws IOException {
+        InputStream inputStream = null;
+        BufferedReader reader = null;
+        try {
+            final AssetManager assets = context.getResources().getAssets();
+            inputStream = assets.open(assetPath);
+            reader = new BufferedReader(new InputStreamReader(inputStream));
+            final StringBuilder sb = new StringBuilder();
+            String line;
+            while ((line = reader.readLine()) != null) {
+                sb.append(line).append("\n");
+            }
+            return sb.toString();
+        } finally {
+            Utility.closeQuietly(inputStream);
+            Utility.closeQuietly(reader);
+        }
+    }
 }
diff --git a/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java b/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
index 412917b8b..b2f0da775 100644
--- a/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
+++ b/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook;
@@ -21,12 +25,15 @@
 import android.content.Intent;
 import android.os.ConditionVariable;
 import android.os.Looper;
+
 import junit.framework.Assert;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-class WaitForBroadcastReceiver extends BroadcastReceiver {
+public final class WaitForBroadcastReceiver extends BroadcastReceiver {
+    static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
     static int idGenerator = 0;
     final int id = idGenerator++;
 
@@ -34,6 +41,15 @@
     int expectCount;
     int actualCount;
     List<Intent> receivedIntents = new ArrayList<Intent>();
+    List<String> expectedActions = new ArrayList<String>();
+    List<Intent> unexpectedIntents = new ArrayList<Intent>();
+
+    public WaitForBroadcastReceiver() {
+    }
+
+    public WaitForBroadcastReceiver(String... expectedActions) {
+        this.expectedActions = Arrays.asList(expectedActions);
+    }
 
     public void incrementExpectCount() {
         incrementExpectCount(1);
@@ -47,7 +63,7 @@ public void incrementExpectCount(int n) {
     }
 
     public void waitForExpectedCalls() {
-        this.waitForExpectedCalls(SessionTestsBase.DEFAULT_TIMEOUT_MILLISECONDS);
+        this.waitForExpectedCalls(DEFAULT_TIMEOUT_MILLISECONDS);
     }
 
     public void waitForExpectedCalls(long timeoutMillis) {
@@ -60,6 +76,10 @@ public void waitForExpectedCalls(long timeoutMillis) {
         return receivedIntents;
     }
 
+    public List<Intent> getUnexpectedIntents() {
+        return unexpectedIntents;
+    }
+
     public static void incrementExpectCounts(WaitForBroadcastReceiver... receivers) {
         for (WaitForBroadcastReceiver receiver : receivers) {
             receiver.incrementExpectCount();
@@ -74,11 +94,22 @@ public static void waitForExpectedCalls(WaitForBroadcastReceiver... receivers) {
 
     @Override
     public void onReceive(Context context, Intent intent) {
+        receivedIntents.add(intent);
+
+        if (!expectedActions.isEmpty()) {
+            String action = intent.getAction();
+            if (!expectedActions.contains(action)) {
+                unexpectedIntents.add(intent);
+                return;
+            }
+        }
+
         if (++actualCount == expectCount) {
             condition.open();
         }
-        receivedIntents.add(intent);
-        Assert.assertTrue("expecting " + expectCount + "broadcasts, but received " + actualCount,                actualCount <= expectCount);
+
+        Assert.assertTrue("expecting " + expectCount + "broadcasts, but received " + actualCount,
+                actualCount <= expectCount);
         Assert.assertEquals("BroadcastReceiver should receive on main UI thread",
                 Thread.currentThread(), Looper.getMainLooper().getThread());
     }
diff --git a/facebook/tests/src/com/facebook/appevents/AppEventsLoggerTests.java b/facebook/tests/src/com/facebook/appevents/AppEventsLoggerTests.java
new file mode 100644
index 000000000..2b427bdfe
--- /dev/null
+++ b/facebook/tests/src/com/facebook/appevents/AppEventsLoggerTests.java
@@ -0,0 +1,143 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookTestCase;
+import com.facebook.WaitForBroadcastReceiver;
+import com.facebook.appevents.AppEventsLogger;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.util.HashMap;
+import java.util.List;
+
+public class AppEventsLoggerTests extends FacebookTestCase {
+    public void testSimpleCall() throws InterruptedException {
+        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);
+
+        AccessToken accessToken1 = getAccessTokenForSharedUser();
+        AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);
+
+        AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), accessToken1);
+        AppEventsLogger logger2 = AppEventsLogger.newLogger(getActivity(), accessToken2);
+
+        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
+        waitForBroadcastReceiver.incrementExpectCount();
+
+        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
+
+        try {
+            // Need to get notifications on another thread so we can wait for them.
+            runOnBlockerThread(new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(waitForBroadcastReceiver,
+                            new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
+                }
+            }, true);
+
+            logger1.logEvent("an_event");
+            logger2.logEvent("another_event");
+
+            // test illegal event name and event key, should not crash in non-debug environment.
+            logger1.logEvent("$illegal_event_name");
+            Bundle params = new Bundle();
+            params.putString("illegal%key", "good_value");
+            logger1.logEvent("legal_event_name", params);
+            char[] val = {'b', 'a', 'd'};
+            params.putCharArray("legal_key", val);
+            logger1.logEvent("legal_event",params);
+
+            logger1.flush();
+
+            waitForBroadcastReceiver.waitForExpectedCalls();
+
+            closeBlockerAndAssertSuccess();
+        } finally {
+            broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
+        }
+    }
+
+    public void testPersistedEvents() throws IOException, ClassNotFoundException {
+        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);
+
+        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
+        final LocalBroadcastManager broadcastManager =
+                LocalBroadcastManager.getInstance(getActivity());
+
+        try {
+            broadcastManager.registerReceiver(waitForBroadcastReceiver,
+                    new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
+
+            getActivity().getFileStreamPath(
+                    AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME).delete();
+
+            AccessToken accessToken = getAccessTokenForSharedUser();
+            AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), accessToken);
+
+            logger1.logEvent("an_event");
+
+            AppEventsLogger.onContextStop();
+
+            FileInputStream fis = getActivity().openFileInput(
+                    AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME);
+            assertNotNull(fis);
+
+            ObjectInputStream ois = new ObjectInputStream(fis);
+            Object obj = ois.readObject();
+            ois.close();
+
+            assertTrue(obj instanceof HashMap);
+
+            logger1.logEvent("another_event");
+
+            waitForBroadcastReceiver.incrementExpectCount();
+
+            // Events are added async if we flush right away the event might not have made it to the
+            // queue to be flushed. As a workaround give the other thread time to add it.
+            try {
+                Thread.sleep(100l);
+            } catch (Exception ex) {
+                // Ignore
+            }
+            logger1.flush();
+
+            waitForBroadcastReceiver.waitForExpectedCalls();
+            List<Intent> receivedIntents = waitForBroadcastReceiver.getReceivedIntents();
+            assertEquals(1, receivedIntents.size());
+
+            Intent intent = receivedIntents.get(0);
+            assertNotNull(intent);
+
+            assertEquals(2, intent.getIntExtra(
+                    AppEventsLogger.APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, 0));
+        } finally {
+            broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
deleted file mode 100644
index d4e24b052..000000000
--- a/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
+++ /dev/null
@@ -1,392 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.TestUtils;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Random;
-
-public final class FileLruCacheTests extends AndroidTestCase {
-    private static final Random random = new Random();
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheOutputStream() throws Exception {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheOutputStream", limitCacheSize(2*dataSize));
-
-        put(cache, key, data);
-        checkValue(cache, key, data);
-        TestUtils.clearFileLruCache(cache);
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheInputStream() throws Exception {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-        InputStream stream = new ByteArrayInputStream(data);
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheInputStream", limitCacheSize(2*dataSize));
-        TestUtils.clearFileLruCache(cache);
-
-        InputStream wrapped = cache.interceptAndPut(key, stream);
-        consumeAndClose(wrapped);
-        checkValue(cache, key, data);
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheClear() throws Exception {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
-        TestUtils.clearFileLruCache(cache);
-
-        put(cache, key, data);
-        checkValue(cache, key, data);
-
-        TestUtils.clearFileLruCache(cache);
-        assertEquals(false, hasValue(cache, key));
-        assertEquals(0, cache.sizeInBytesForTest());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheClearMidBuffer() throws Exception {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-        String key2 = "b";
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
-        TestUtils.clearFileLruCache(cache);
-
-        put(cache, key, data);
-        checkValue(cache, key, data);
-        OutputStream stream = cache.openPutStream(key2);
-        Thread.sleep(1000);
-
-        TestUtils.clearFileLruCache(cache);
-
-        stream.write(data);
-        stream.close();
-
-        assertEquals(false, hasValue(cache, key));
-        assertEquals(false, hasValue(cache, key2));
-        assertEquals(0, cache.sizeInBytesForTest());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testSizeInBytes() throws Exception {
-        int count = 17;
-        int dataSize = 53;
-        int cacheSize = count * dataSize;
-        byte[] data = generateBytes(dataSize);
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testSizeInBytes", limitCacheSize(2*cacheSize));
-        TestUtils.clearFileLruCache(cache);
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-
-            // The size reported by sizeInBytes includes a version/size token as well
-            // as a JSON blob that records the name.  Verify that the cache size is larger
-            // than the data content but not more than twice as large.  This guarantees
-            // that sizeInBytes is doing at least approximately the right thing.
-            int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytesForTest() > totalDataSize);
-            assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
-        }
-        for (int i = 0; i < count; i++) {
-            String key = Integer.valueOf(i).toString();
-            checkValue(cache, key, data);
-        }
-    }
-
-    @MediumTest @LargeTest
-    public void testCacheSizeLimit() throws Exception {
-        int count = 64;
-        int dataSize = 32;
-        int cacheSize = count * dataSize / 2;
-        byte[] data = generateBytes(dataSize);
-
-        // Here we do not set the limit to 2x to make sure we hit the limit well before we have
-        // added all the data.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheSizeLimit", limitCacheSize(cacheSize));
-        TestUtils.clearFileLruCache(cache);
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-
-            // See comment in testSizeInBytes for why this is not an exact calculation.
-            //
-            // This changes verification such that the final cache size lands somewhere
-            // between half and full quota.
-            int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize/2));
-            assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
-        }
-
-        // sleep for a bit to make sure the trim finishes
-        Thread.sleep(5000);
-
-        // Verify that some keys exist and others do not
-        boolean hasValueExists = false;
-        boolean hasNoValueExists = false;
-
-        for (int i = 0; i < count; i++) {
-            String key = Integer.valueOf(i).toString();
-            if (hasValue(cache, key)) {
-                hasValueExists = true;
-                checkValue(cache, key, data);
-            } else {
-                hasNoValueExists = true;
-            }
-        }
-
-        assertEquals(true, hasValueExists);
-        assertEquals(true, hasNoValueExists);
-    }
-
-    @MediumTest @LargeTest
-    public void testCacheCountLimit() throws Exception {
-        int count = 64;
-        int dataSize = 32;
-        int cacheCount = count / 2;
-        byte[] data = generateBytes(dataSize);
-
-        // Here we only limit by count, and we allow half of the entries.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheCountLimit", limitCacheCount(cacheCount));
-        TestUtils.clearFileLruCache(cache);
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-        }
-
-        // sleep for a bit to make sure the trim finishes
-        Thread.sleep(5000);
-
-        // Verify that some keys exist and others do not
-        boolean hasValueExists = false;
-        boolean hasNoValueExists = false;
-
-        for (int i = 0; i < count; i++) {
-            if (hasValue(cache, i)) {
-                hasValueExists = true;
-                checkValue(cache, i, data);
-            } else {
-                hasNoValueExists = true;
-            }
-        }
-
-        assertEquals(true, hasValueExists);
-        assertEquals(true, hasNoValueExists);
-    }
-
-    @LargeTest
-    public void testCacheLru() throws IOException, InterruptedException {
-        int keepCount = 10;
-        int otherCount = 5;
-        int dataSize = 64;
-        byte[] data = generateBytes(dataSize);
-
-        // Limit by count, and allow all the keep keys plus one other.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheLru", limitCacheCount(keepCount + 1));
-        TestUtils.clearFileLruCache(cache);
-
-        for (int i = 0; i < keepCount; i++) {
-            put(cache, i, data);
-        }
-
-        // Make sure operations are separated by enough time that the file timestamps are all different.
-        // On the test device, it looks like lastModified has 1-second resolution, so we have to wait at
-        // least a second to guarantee that updated timestamps will come later.
-        Thread.sleep(1000);
-        for (int i = 0; i < otherCount; i++) {
-            put(cache, keepCount + i, data);
-            Thread.sleep(1000);
-
-            // By verifying all the keep keys, they should be LRU and survive while the others do not.
-            for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
-                checkValue(cache, keepIndex, data);
-            }
-            Thread.sleep(1000);
-        }
-
-        // All but the last other key should have been pushed out
-        for (int i = 0; i < (otherCount - 1); i++) {
-            String key = Integer.valueOf(keepCount + i).toString();
-            assertEquals(false, hasValue(cache, key));
-        }
-    }
-
-    @LargeTest
-    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
-        final int count = 5;
-        final int dataSize = 81;
-        final int threadCount = 31;
-        final int iterationCount = 10;
-        final byte[] data = generateBytes(dataSize);
-
-        final FileLruCache cache = new FileLruCache(
-                getContext(), "testConcurrentWritesToSameKey", limitCacheCount(count+1));
-        TestUtils.clearFileLruCache(cache);
-
-        Runnable run = new Runnable() {
-            @Override
-            public void run() {
-                for (int iterations = 0; iterations < iterationCount; iterations++) {
-                    for (int i = 0; i < count; i++) {
-                        put(cache, i, data);
-                    }
-                }
-            }
-        };
-
-        // Create a bunch of threads to write a set of keys repeatedly
-        Thread[] threads = new Thread[threadCount];
-        for (int i = 0; i < threads.length; i++) {
-            threads[i] = new Thread(run);
-        }
-
-        for (Thread thread : threads) {
-            thread.start();
-        }
-
-        for (Thread thread : threads) {
-            thread.join(10 * 1000, 0);
-        }
-
-        // Verify that the file state ended up consistent in the end
-        for (int i = 0; i < count; i++) {
-            checkValue(cache, i, data);
-        }
-    }
-
-    byte[] generateBytes(int n) {
-        byte[] bytes = new byte[n];
-        random.nextBytes(bytes);
-        return bytes;
-    }
-
-    FileLruCache.Limits limitCacheSize(int n) {
-        FileLruCache.Limits limits = new FileLruCache.Limits();
-        limits.setByteCount(n);
-        return limits;
-    }
-
-    FileLruCache.Limits limitCacheCount(int n) {
-        FileLruCache.Limits limits = new FileLruCache.Limits();
-        limits.setFileCount(n);
-        return limits;
-    }
-
-    void put(FileLruCache cache, int i, byte[] data) {
-        put(cache, Integer.valueOf(i).toString(), data);
-    }
-
-    void put(FileLruCache cache, String key, byte[] data) {
-        try {
-            OutputStream stream = cache.openPutStream(key);
-            assertNotNull(stream);
-
-            stream.write(data);
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    void checkValue(FileLruCache cache, int i, byte[] expected) {
-        checkValue(cache, Integer.valueOf(i).toString(), expected);
-    }
-
-    void checkValue(FileLruCache cache, String key, byte[] expected) {
-        try {
-            InputStream stream = cache.get(key);
-            assertNotNull(stream);
-
-            checkInputStream(expected, stream);
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    boolean hasValue(FileLruCache cache, int i) {
-        return hasValue(cache, Integer.valueOf(i).toString());
-    }
-
-    boolean hasValue(FileLruCache cache, String key) {
-        InputStream stream = null;
-
-        try {
-            stream = cache.get(key);
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-
-        return stream != null;
-    }
-
-    void checkInputStream(byte[] expected, InputStream actual) {
-        try {
-            for (int i = 0; i < expected.length; i++) {
-                int b = actual.read();
-                assertEquals(((int)expected[i]) & 0xff, b);
-            }
-
-            int eof = actual.read();
-            assertEquals(-1, eof);
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    void consumeAndClose(InputStream stream) {
-        try {
-            byte[] buffer = new byte[1024];
-            while (stream.read(buffer) > -1) {
-                // these bytes intentionally ignored
-            }
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/internal/ImageResponseCacheTests.java b/facebook/tests/src/com/facebook/internal/ImageResponseCacheTest.java
similarity index 61%
rename from facebook/tests/src/com/facebook/internal/ImageResponseCacheTests.java
rename to facebook/tests/src/com/facebook/internal/ImageResponseCacheTest.java
index 6cd705cf2..ae67aead5 100644
--- a/facebook/tests/src/com/facebook/internal/ImageResponseCacheTests.java
+++ b/facebook/tests/src/com/facebook/internal/ImageResponseCacheTest.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.internal;
@@ -19,39 +23,38 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.net.Uri;
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
 import com.facebook.TestUtils;
-import com.facebook.internal.Utility;
-import com.facebook.internal.ImageResponseCache;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.URI;
+import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
-public final class ImageResponseCacheTests extends AndroidTestCase {
+public final class ImageResponseCacheTest extends AndroidTestCase {
 
-    @MediumTest @LargeTest
+    @LargeTest
     public void testImageCaching() throws Exception {
         // In unit test, since we need verify first access the image is not in cache
         // we need clear the cache first
         TestUtils.clearFileLruCache(ImageResponseCache.getCache(safeGetContext()));
         String imgUrl = "http://profile.ak.fbcdn.net/hprofile-ak-frc1/369438_100003049100322_615834658_n.jpg";
-        
+
         Bitmap bmp1 = readImage(imgUrl, false);
         Bitmap bmp2 = readImage(imgUrl, true);
         compareImages(bmp1, bmp2);
     }
-    
-    @MediumTest @LargeTest
+
+    @LargeTest
     public void testImageNotCaching() throws IOException {
-        
-        String imgUrl = "http://graph.facebook.com/ryanseacrest/picture?type=large";
-        
+
+        String imgUrl = "https://graph.facebook.com/ryanseacrest/picture?type=large";
+
         Bitmap bmp1 = readImage(imgUrl, false);
         Bitmap bmp2 = readImage(imgUrl, false);
         compareImages(bmp1, bmp2);
@@ -62,27 +65,32 @@ private Bitmap readImage(String uri, boolean expectedFromCache) {
         InputStream istream = null;
         try
         {
-            URI url = new URI(uri);
+            Uri url = Uri.parse(uri);
             // Check if the cache contains value for this url
-            boolean isInCache = (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
+            boolean isInCache =
+                    (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
             assertTrue(isInCache == expectedFromCache);
             // Read the image
             istream = ImageResponseCache.getCachedImageStream(url, safeGetContext());
             if (istream == null) {
-                HttpURLConnection connection = (HttpURLConnection)url.toURL().openConnection();
-                istream = ImageResponseCache.interceptAndCacheImageStream(safeGetContext(), connection);
+                HttpURLConnection connection =
+                        (HttpURLConnection) (new URL(uri)).openConnection();
+                istream = ImageResponseCache.interceptAndCacheImageStream(
+                        safeGetContext(),
+                        connection);
             }
+
             assertTrue(istream != null);
             bmp = BitmapFactory.decodeStream(istream);
             assertTrue(bmp != null);
         } catch (Exception e) {
-             assertNull(e);
+            assertNull(e);
         } finally {
             Utility.closeQuietly(istream);
         }
         return bmp;
     }
-    
+
     private static void compareImages(Bitmap bmp1, Bitmap bmp2) {
         assertTrue(bmp1.getHeight() == bmp2.getHeight());
         assertTrue(bmp1.getWidth() == bmp1.getWidth());
diff --git a/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
deleted file mode 100644
index 1646009f3..000000000
--- a/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.*;
-import com.facebook.internal.SessionTracker;
-
-import java.util.Collections;
-
-public class SessionTrackerTests extends SessionTestsBase {
-
-    private static final String TOKEN_STR = "A token of thanks";
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking the active session
-    public void testDelegateWithActiveSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder =
-                new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session =
-                createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking a passed in session from the constructor
-    public void testDelegateWithSessionInConstructor() throws Exception {
-        final SessionStatusCallbackRecorder statusRecorder =
-                new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session =
-                createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking the active session and then a new session
-    public void testDelegateWithActiveSessionThenNewSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        tracker.setSession(newSession);
-        assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
-        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking a new session and then an active session
-    public void testDelegateWithSessionThenActiveSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        // need to run on the blocker thread so that when we register the 
-        // BroadcastReceivers, the handler gets run on the right thread
-        runOnBlockerThread(new Runnable() {
-            public void run() {
-                tracker.setSession(null);
-                Session.setActiveSession(newSession);
-            }
-        }, true);
-
-        assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
-        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-}
diff --git a/facebook/tests/src/com/facebook/internal/UtilityTest.java b/facebook/tests/src/com/facebook/internal/UtilityTest.java
new file mode 100644
index 000000000..464531a21
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/UtilityTest.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.internal;
+
+import android.test.suitebuilder.annotation.LargeTest;
+
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookTestCase;
+
+public class UtilityTest extends FacebookTestCase {
+
+    @LargeTest
+    public void testFetchedAppSettingsErrorClassification() throws Exception {
+        Utility.FetchedAppSettings fetchedAppSettings =
+                Utility.queryAppSettings(getApplicationId(), false);
+        FacebookRequestErrorClassification errorClassification = fetchedAppSettings
+                .getErrorClassification();
+        assertNotNull(errorClassification);
+
+        assertNull(errorClassification.getRecoveryMessage(FacebookRequestError.Category.OTHER));
+        assertNull(errorClassification.getRecoveryMessage(FacebookRequestError.Category.TRANSIENT));
+        assertNotNull(errorClassification.getRecoveryMessage(
+                FacebookRequestError.Category.LOGIN_RECOVERABLE));
+
+        assertNull(errorClassification.getOtherErrors());
+        assertEquals(2, errorClassification.getLoginRecoverableErrors().size());
+        assertNull(errorClassification.getTransientErrors());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/login/LoginClientTests.java b/facebook/tests/src/com/facebook/login/LoginClientTests.java
new file mode 100644
index 000000000..1b873f7d6
--- /dev/null
+++ b/facebook/tests/src/com/facebook/login/LoginClientTests.java
@@ -0,0 +1,209 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.support.v4.app.Fragment;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookTestCase;
+import com.facebook.GraphRequest;
+import com.facebook.GraphRequestBatch;
+import com.facebook.GraphRequestBatchBridge;
+import com.facebook.GraphResponse;
+import com.facebook.GraphResponseBridge;
+import com.facebook.TestBlocker;
+import com.facebook.TestUtils;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.util.*;
+
+public class LoginClientTests extends FacebookTestCase {
+    private static final Set<String> PERMISSIONS = new HashSet<String>(
+            Arrays.asList("go outside", "come back in"));
+
+    class MockLoginClient extends LoginClient {
+        Result result;
+        boolean triedNextHandler = false;
+
+        MockLoginClient(Fragment fragment) {
+            super(fragment);
+        }
+
+        Request getRequest() {
+            return pendingRequest;
+        }
+
+        void setRequest(Request request) {
+            pendingRequest = request;
+        }
+
+        @Override
+        void complete(Result result) {
+            this.result = result;
+        }
+
+        @Override
+        void tryNextHandler() {
+            triedNextHandler = true;
+        }
+    }
+
+    LoginClient.Request createRequest() {
+        return new LoginClient.Request(
+                LoginBehavior.SSO_WITH_FALLBACK,
+                PERMISSIONS,
+                DefaultAudience.FRIENDS,
+                "1234",
+                null
+        );
+    }
+
+    class MockValidatingLoginClient extends MockLoginClient {
+        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
+        private Set<String> permissionsToReport = new HashSet<String>();
+        private TestBlocker blocker;
+
+        public MockValidatingLoginClient(Fragment fragment, TestBlocker blocker) {
+            super(fragment);
+            this.blocker = blocker;
+        }
+
+        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
+            mapAccessTokenToFbid.put(accessToken, fbid);
+        }
+
+        public void setPermissionsToReport(Set<String> permissionsToReport) {
+            this.permissionsToReport = permissionsToReport;
+        }
+
+        @Override
+        void complete(Result result) {
+            super.complete(result);
+            blocker.signal();
+        }
+    }
+
+    static final String USER_1_FBID = "user1";
+    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
+    static final String USER_2_FBID = "user2";
+    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
+    static final String APP_ID = "1234";
+
+    LoginClient.Request createNewPermissionRequest() {
+        return new LoginClient.Request(
+                LoginBehavior.SSO_WITH_FALLBACK,
+                PERMISSIONS,
+                DefaultAudience.FRIENDS,
+                "1234",
+                null
+        );
+    }
+
+    @LargeTest
+    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        LoginClient.Request request = createNewPermissionRequest();
+        client.setRequest(request);
+
+        AccessToken token = new AccessToken(
+                USER_1_ACCESS_TOKEN,
+                APP_ID,
+                USER_1_FBID,
+                PERMISSIONS,
+                null,
+                null,
+                null,
+                null);
+        AccessToken.setCurrentAccessToken(token);
+        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
+
+        // We don't care about ordering.
+        assertEquals(new HashSet<String>(PERMISSIONS), new HashSet<String>(resultToken.getPermissions()));
+    }
+
+    @LargeTest
+    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        LoginClient.Request request = createNewPermissionRequest();
+        client.setRequest(request);
+
+        AccessToken userOneToken = new AccessToken(
+                USER_1_ACCESS_TOKEN,
+                APP_ID,
+                USER_1_FBID,
+                PERMISSIONS,
+                null,
+                null,
+                null,
+                null);
+        AccessToken.setCurrentAccessToken(userOneToken);
+
+        AccessToken userTwoToken = new AccessToken(
+                USER_2_ACCESS_TOKEN,
+                APP_ID,
+                USER_2_FBID,
+                PERMISSIONS,
+                null,
+                null,
+                null,
+                null);
+        LoginClient.Result result = LoginClient.Result.createTokenResult(request, userTwoToken);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(LoginClient.Result.Code.ERROR, client.result.code);
+
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
deleted file mode 100644
index 8b069b7ce..000000000
--- a/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
+++ /dev/null
@@ -1,1368 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.FacebookGraphObjectException;
-import junit.framework.Assert;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.*;
-import java.util.Map.Entry;
-
-public final class GraphObjectFactoryTests extends AndroidTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateEmptyGraphObject() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        assertTrue(graphObject != null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsMap() {
-        GraphObject graphObject = GraphObject.Factory.create();
-
-        graphObject.setProperty("hello", "world");
-        assertEquals("world", (String) graphObject.asMap().get("hello"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsGraphPlace() {
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-
-        graphPlace.setName("hello");
-        assertEquals("hello", graphPlace.getName());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsGraphUser() {
-        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
-
-        graphUser.setFirstName("Michael");
-        assertEquals("Michael", graphUser.getFirstName());
-        assertEquals("Michael", graphUser.getProperty("first_name"));
-        assertEquals("Michael", graphUser.asMap().get("first_name"));
-
-        graphUser.setProperty("last_name", "Scott");
-        assertEquals("Scott", graphUser.getProperty("last_name"));
-        assertEquals("Scott", graphUser.getLastName());
-        assertEquals("Scott", graphUser.asMap().get("last_name"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCastBetweenGraphObjectTypes() {
-        GraphObject graphObject = GraphObject.Factory.create();
-
-        graphObject.setProperty("first_name", "Mickey");
-
-        GraphUser graphUser = graphObject.cast(GraphUser.class);
-        assertTrue(graphUser != null);
-        // Should see the name we set earlier as a GraphObject.
-        assertEquals("Mickey", graphUser.getFirstName());
-
-        // Changes to GraphUser should be reflected in GraphObject version.
-        graphUser.setLastName("Mouse");
-        assertEquals("Mouse", graphObject.getProperty("last_name"));
-    }
-
-    interface Base extends GraphObject {
-    }
-
-    interface Derived extends Base {
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingToSameTypeGivesSameObject() {
-        Base base = GraphObject.Factory.create(Base.class);
-
-        Base cast = base.cast(Base.class);
-
-        assertTrue(base == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingToBaseTypeGivesSameObject() {
-        Derived derived = GraphObject.Factory.create(Derived.class);
-
-        Base cast = derived.cast(Base.class);
-        assertTrue(derived == cast);
-
-        cast = cast.cast(Derived.class);
-        assertTrue(derived == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetComplexTypes() {
-        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
-        graphLocation.setCity("Seattle");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-        graphPlace.setLocation(graphLocation);
-
-        assertEquals(graphLocation, graphPlace.getLocation());
-        assertEquals("Seattle", graphPlace.getLocation().getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertFromJSON() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Paris");
-        jsonLocation.put("country", "France");
-
-        JSONObject jsonPlace = new JSONObject();
-        jsonPlace.put("location", jsonLocation);
-        jsonPlace.put("name", "Eiffel Tower");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
-        GraphLocation graphLocation = graphPlace.getLocation();
-        assertEquals("Paris", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertFromGraphObject() throws JSONException {
-        GraphObject graphObject = GraphObject.Factory.create();
-        graphObject.setProperty("city", "Paris");
-        graphObject.setProperty("country", "France");
-
-        JSONObject jsonPlace = new JSONObject();
-        jsonPlace.put("location", graphObject);
-        jsonPlace.put("name", "Eiffel Tower");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
-        GraphLocation graphLocation = graphPlace.getLocation();
-        assertEquals("Paris", graphLocation.getCity());
-    }
-
-    private abstract class GraphObjectClass implements GraphObject {
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertNumbers() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("double_as_string", 3.14159);
-        jsonObject.put("int_as_string", 42);
-
-        GraphMetric metric = GraphObject.Factory.create(jsonObject, GraphMetric.class);
-        assertEquals("42", metric.getIntAsString());
-        assertNotNull(metric.getDoubleAsString());
-        assertTrue(metric.getDoubleAsString().startsWith("3.14159"));
-    }
-
-    private interface GraphMetric extends GraphObject {
-        String getIntAsString();
-        String getDoubleAsString();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapNonInterface() {
-        try {
-            GraphObject.Factory.create(GraphObjectClass.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadNoParameterMethodNameGraphObject extends GraphObject {
-        Object floppityFlee();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadZeroParameterMethodName() {
-        try {
-            GraphObject.Factory.create(BadNoParameterMethodNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSingleParameterMethodNameGraphObject extends GraphObject {
-        void floppityFlee(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSingleParameterMethodName() {
-        try {
-            GraphObject.Factory.create(BadSingleParameterMethodNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterNameGraphObject extends GraphObject {
-        void get();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterName() {
-        try {
-            GraphObject.Factory.create(BadGetterNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterParamsGraphObject extends GraphObject {
-        Object getFoo(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterParams() {
-        try {
-            GraphObject.Factory.create(BadGetterParamsGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterReturnTypeGraphObject extends GraphObject {
-        void getFoo();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterReturnType() {
-        try {
-            GraphObject.Factory.create(BadGetterReturnTypeGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterNameGraphObject extends GraphObject {
-        void set();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterName() {
-        try {
-            GraphObject.Factory.create(BadSetterNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterParamsGraphObject extends GraphObject {
-        void setFoo();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterParams() {
-        try {
-            GraphObject.Factory.create(BadSetterParamsGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterReturnTypeGraphObject extends GraphObject {
-        Object setFoo(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterReturnType() {
-        try {
-            GraphObject.Factory.create(BadSetterReturnTypeGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadBaseInterfaceGraphObject extends BadSetterReturnTypeGraphObject {
-        void setBar(Object obj);
-
-        Object getBar();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadBaseInterface() {
-        try {
-            GraphObject.Factory.create(BadBaseInterfaceGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface GoodPropertyOverrideInterfaceGraphObject extends GraphObject {
-        void setDefaultName(String s);
-
-        // No annotation to ensure that the right property is being set.
-        String getAnotherDefaultName();
-
-        @PropertyName("another_default_name")
-        void putSomething(String s);
-
-        @PropertyName("default_name")
-        String retrieveSomething();
-
-        @PropertyName("MixedCase")
-        void setMixedCase(String s);
-
-        @PropertyName("MixedCase")
-        String getMixedCase();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanOverrideGraphPropertyNames() {
-        GoodPropertyOverrideInterfaceGraphObject graphObject =
-                GraphObject.Factory.create(GoodPropertyOverrideInterfaceGraphObject.class);
-
-        String testValue = "flu-blah";
-        graphObject.setDefaultName(testValue);
-        Assert.assertEquals(testValue, graphObject.retrieveSomething());
-
-        testValue = testValue + "1";
-        graphObject.putSomething(testValue);
-        Assert.assertEquals(testValue, graphObject.getAnotherDefaultName());
-
-        testValue = testValue + "2";
-        graphObject.setMixedCase(testValue);
-        Assert.assertEquals(testValue, graphObject.getMixedCase());
-    }
-
-    private interface BadPropertyOverrideInterfaceGraphObject extends GraphObject {
-        @PropertyName("")
-        void setMissingProperty(Object value);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadPropertyNameOverrides() {
-        try {
-            GraphObject.Factory.create(BadPropertyOverrideInterfaceGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectEquals() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        graphObject.setProperty("aKey", "aValue");
-
-        assertTrue(graphObject.equals(graphObject));
-
-        GraphPlace graphPlace = graphObject.cast(GraphPlace.class);
-        assertTrue(graphObject.equals(graphPlace));
-        assertTrue(graphPlace.equals(graphObject));
-
-        GraphObject aDifferentGraphObject = GraphObject.Factory.create();
-        aDifferentGraphObject.setProperty("aKey", "aDifferentValue");
-        assertFalse(graphObject.equals(aDifferentGraphObject));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertEquals("world", graphObject.getProperty("hello"));
-        assertTrue(graphObject.getProperty("fred") == null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("don't imagine", "purple elephants");
-
-        assertEquals("world", jsonObject.getString("hello"));
-        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetPropertyWithGraphObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        GraphObject nestedObject = GraphObject.Factory.create();
-        graphObject.setProperty("foo", nestedObject);
-
-        JSONObject nestedJsonObject = jsonObject.getJSONObject("foo");
-        assertNotNull(nestedJsonObject);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetPropertyWithGraphObjectList() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        GraphObjectList<GraphObject> nestedList = GraphObject.Factory.createList(GraphObject.class);
-        graphObject.setProperty("foo", nestedList);
-
-        JSONArray nestedJsonArray = jsonObject.getJSONArray("foo");
-        assertNotNull(nestedJsonArray);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetPropertyWithList() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        List<GraphObject> nestedList = new ArrayList<GraphObject>();
-        graphObject.setProperty("foo", nestedList);
-
-        JSONArray nestedJsonArray = jsonObject.getJSONArray("foo");
-        assertNotNull(nestedJsonArray);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRemoveProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("whirled", "peas");
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("don't imagine", "purple elephants");
-
-        assertEquals("world", jsonObject.getString("hello"));
-        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapClear() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(1, jsonObject.length());
-
-        graphObject.asMap().clear();
-
-        assertEquals(0, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapContainsKey() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertTrue(graphObject.asMap().containsKey("hello"));
-        assertFalse(graphObject.asMap().containsKey("hocus"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapContainsValue() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertTrue(graphObject.asMap().containsValue("world"));
-        assertFalse(graphObject.asMap().containsValue("pocus"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapEntrySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Set<Entry<String, Object>> entrySet = graphObject.asMap().entrySet();
-        assertEquals(2, entrySet.size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapGet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertEquals("world", graphObject.asMap().get("hello"));
-        assertTrue(graphObject.getProperty("fred") == null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapGetReturnsNullForMissingProperty() throws JSONException {
-        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
-        assertNull(graphUser.getBirthday());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapIsEmpty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertTrue(graphObject.asMap().isEmpty());
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-        assertFalse(graphObject.asMap().isEmpty());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapKeySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Set<String> keySet = graphObject.asMap().keySet();
-        assertEquals(2, keySet.size());
-        assertTrue(keySet.contains("hello"));
-        assertTrue(keySet.contains("hocus"));
-        assertFalse(keySet.contains("world"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPut() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        assertEquals("pocus", jsonObject.get("hocus"));
-        assertEquals(2, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        GraphObject parentObject = GraphObject.Factory.create();
-        parentObject.setProperty("key", graphObject);
-
-        JSONObject jsonParent = parentObject.getInnerJSONObject();
-        Object obj = jsonParent.opt("key");
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutOfWrapperPutsJSONArray() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<String> graphObjectList = GraphObject.Factory
-                .createList(jsonArray, String.class);
-        graphObjectList.add("hello");
-        graphObjectList.add("world");
-
-        GraphObject parentObject = GraphObject.Factory.create();
-        parentObject.setProperty("key", graphObjectList);
-
-        JSONObject jsonParent = parentObject.getInnerJSONObject();
-        Object obj = jsonParent.opt("key");
-
-        assertNotNull(obj);
-        assertEquals(jsonArray, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutAll() throws JSONException {
-        HashMap<String, Object> map = new HashMap<String, Object>();
-        map.put("hello", "world");
-        map.put("hocus", "pocus");
-
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.asMap().putAll(map);
-        assertEquals("pocus", jsonObject.get("hocus"));
-        assertEquals(2, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapRemove() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.removeProperty("hello");
-
-        assertEquals(1, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapSize() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(2, graphObject.asMap().size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapValues() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Collection<Object> values = graphObject.asMap().values();
-
-        assertEquals(2, values.size());
-        assertTrue(values.contains("world"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetInnerJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(jsonObject, graphObject.getInnerJSONObject());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
-
-        graphPlace.setLocation(graphLocation);
-
-        assertEquals(graphLocation.getInnerJSONObject(), graphPlace.getInnerJSONObject().get("location"));
-
-    }
-
-    private interface DateGraphObject extends GraphObject {
-        Date getDate1();
-
-        Date getDate2();
-
-        Date getDate3();
-
-        Date getDate4();
-        void setDate4(Date date);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetStringsAsDates() {
-        DateGraphObject dates = GraphObject.Factory.create(DateGraphObject.class);
-        dates.setProperty("date1", "2012-07-04");
-        dates.setProperty("date2", "2012-07-04T19:30:50");
-        dates.setProperty("date3", "2012-07-04T19:20:40-0400");
-
-        // Dates without a time zone should be assumed to be in the current timezone.
-        Calendar cal = new GregorianCalendar();
-        cal.set(Calendar.MILLISECOND, 0);
-
-        cal.set(2012, 6, 4, 0, 0, 0);
-        Date expectedDate1 = cal.getTime();
-        Date date1 = dates.getDate1();
-        assertEquals(expectedDate1, date1);
-
-        cal.set(2012, 6, 4, 19, 30, 50);
-        Date expectedDate2 = cal.getTime();
-        Date date2 = dates.getDate2();
-        assertEquals(expectedDate2, date2);
-
-        // Dates with an explicit time zone should take that timezone into account.
-        cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-        cal.set(Calendar.MILLISECOND, 0);
-        cal.set(2012, 6, 4, 23, 20, 40);
-
-        Date expectedDate3 = cal.getTime();
-        Date date3 = dates.getDate3();
-        assertEquals(expectedDate3, date3);
-
-        cal.set(2012, 9, 28, 9, 53, 0);
-        Date expectedDate4 = cal.getTime();
-        dates.setDate4(expectedDate4);
-        Date date4 = dates.getDate4();
-        assertEquals(expectedDate4, date4);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionAdd() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        collection.add(5);
-
-        assertTrue(array.length() == 1);
-        assertTrue(array.optInt(0) == 5);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionAddAll() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collectionToAdd = Arrays.asList(5, -1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        collection.addAll(collectionToAdd);
-
-        assertTrue(array.length() == 2);
-        assertTrue(array.optInt(0) == 5);
-        assertTrue(array.optInt(1) == -1);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionContains() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.contains(5));
-        assertFalse(collection.contains(6));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionContainsAll() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-        array.put(-1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.containsAll(Arrays.asList(5)));
-        assertTrue(collection.containsAll(Arrays.asList(5, -1)));
-        assertFalse(collection.containsAll(Arrays.asList(5, -1, 2)));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIsEmpty() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.isEmpty());
-
-        array.put(5);
-        assertFalse(collection.isEmpty());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIterator() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-        array.put(-1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        Iterator<Integer> iter = collection.iterator();
-        assertTrue(iter.hasNext());
-        assertTrue(iter.next() == 5);
-        assertTrue(iter.hasNext());
-        assertTrue(iter.next() == -1);
-        assertFalse(iter.hasNext());
-
-        for (Integer i : collection) {
-            assertNotSame(0, i);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIteratorOfGraphObject() throws JSONException {
-        Collection<GraphLocation> collection = GraphObject.Factory.createList(GraphLocation.class);
-
-        GraphLocation seattle = GraphObject.Factory.create(GraphLocation.class);
-        seattle.setCity("Seattle");
-        collection.add(seattle);
-        GraphLocation paris = GraphObject.Factory.create(GraphLocation.class);
-        paris.setCity("Paris");
-        collection.add(paris);
-
-        Iterator<GraphLocation> iter = collection.iterator();
-        assertTrue(iter.hasNext());
-        assertEquals(seattle, iter.next());
-        assertTrue(iter.hasNext());
-        assertEquals(paris, iter.next());
-        assertFalse(iter.hasNext());
-
-        for (GraphLocation location : collection) {
-            assertTrue(location != null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionSize() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertEquals(0, collection.size());
-
-        array.put(5);
-        assertEquals(1, collection.size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionClearThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.clear();
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRemoveThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.remove(5);
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRemoveAllThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.removeAll(Arrays.asList());
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRetainAllThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.retainAll(Arrays.asList());
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    private interface Locations extends GraphObject {
-        Collection<GraphLocation> getLocations();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectWrapsJSONCollection() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonLocation);
-
-        JSONObject jsonLocations = new JSONObject();
-        jsonLocations.put("locations", jsonArray);
-
-        Locations locations = GraphObject.Factory.create(jsonLocations, Locations.class);
-        Collection<GraphLocation> locationsGraphObjectCollection = locations.getLocations();
-        assertTrue(locationsGraphObjectCollection != null);
-
-        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
-        assertTrue(graphLocation != null);
-        assertEquals("Seattle", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectWrapsIterable() throws JSONException {
-        GraphUser user = GraphObject.Factory.create(GraphUser.class);
-        user.setFirstName("Foo");
-        user.setLastName("Bar");
-
-        List<GraphUser> users = new ArrayList<GraphUser>();
-        users.add(user);
-
-        OpenGraphAction action = GraphObject.Factory.create(OpenGraphAction.class);
-        action.setTags(users);
-
-        String json = action.getInnerJSONObject().toString();
-
-        assertTrue("JSON string should contain last_name", json.contains("last_name"));
-
-        Object tags = action.getInnerJSONObject().get("tags");
-        assertNotNull("tags should not be null", tags);
-        assertTrue("tags should be JSONArray", tags instanceof JSONArray);
-
-        List<GraphObject> retrievedUsers = action.getTags();
-        assertEquals("Size should be 1", 1, retrievedUsers.size());
-        GraphUser retrievedUser = retrievedUsers.get(0).cast(GraphUser.class);
-        assertEquals("First name should be Foo", "Foo", retrievedUser.getFirstName());
-        assertEquals("Last name should be Bar", "Bar", retrievedUser.getLastName());
-
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionWrapsJSONObject() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonLocation);
-        Collection<GraphLocation> locationsGraphObjectCollection = GraphObject.Factory
-                .createList(jsonArray,
-                        GraphLocation.class);
-        assertTrue(locationsGraphObjectCollection != null);
-
-        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
-        assertTrue(graphLocation != null);
-        assertEquals("Seattle", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotCastCollectionOfNonGraphObjects() throws JSONException {
-        try {
-            GraphObjectList<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.castToListOf(GraphLocation.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCastCollectionOfGraphObjects() throws JSONException {
-        JSONObject jsonSeattle = new JSONObject();
-        jsonSeattle.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonSeattle);
-
-        GraphObjectList<GraphObject> collection = GraphObject.Factory
-                .createList(jsonArray, GraphObject.class);
-
-        GraphObjectList<GraphLocation> locationCollection = collection.castToListOf(GraphLocation.class);
-        assertTrue(locationCollection != null);
-
-        GraphLocation seattle = locationCollection.iterator().next();
-        assertTrue(seattle != null);
-        assertEquals("Seattle", seattle.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingCollectionToSameTypeGivesSameObject() {
-        GraphObjectList<Base> base = GraphObject.Factory.createList(Base.class);
-
-        GraphObjectList<Base> cast = base.castToListOf(Base.class);
-
-        assertTrue(base == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingCollectionToBaseTypeGivesSameObject() {
-        GraphObjectList<Derived> derived = GraphObject.Factory.createList(Derived.class);
-
-        GraphObjectList<Base> cast = derived.castToListOf(Base.class);
-
-        assertTrue((GraphObjectList<?>)derived == (GraphObjectList<?>)cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanGetInnerJSONArray() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<GraphObject> collection = GraphObject.Factory
-                .createList(jsonArray, GraphObject.class);
-
-        assertEquals(jsonArray, collection.getInnerJSONArray());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanGetRandomAccess() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put("Seattle");
-        jsonArray.put("Menlo Park");
-
-        GraphObjectList<String> collection = GraphObject.Factory
-                .createList(jsonArray, String.class);
-
-        assertEquals("Menlo Park", collection.get(1));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetRandomAccess() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<String> collection = GraphObject.Factory
-                .createList(jsonArray, String.class);
-
-        collection.add("Seattle");
-        collection.add("Menlo Park");
-
-        collection.set(1, "Ann Arbor");
-        assertEquals("Ann Arbor", collection.get(1));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        GraphObjectList<GraphObject> parentList = GraphObject.Factory
-                .createList(GraphObject.class);
-        parentList.add(graphObject);
-
-        JSONArray jsonArray = parentList.getInnerJSONArray();
-
-        Object obj = jsonArray.opt(0);
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-
-        parentList.set(0, graphObject);
-
-        obj = jsonArray.opt(0);
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCamelCaseToLowercase() {
-        assertEquals("hello_world", GraphObject.Factory
-                .convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
-        assertEquals("hello_world", GraphObject.Factory
-                .convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
-    }
-
-    interface NestedObject extends GraphObject {
-        String getId();
-        void setId(String id);
-
-        String getUrl();
-        void setUrl(String url);
-    }
-
-    interface ObjectWithNestedObject extends GraphObject {
-        // Single-object version
-        NestedObject getNestedObject();
-        void setNestedObject(NestedObject nestedObject);
-
-        @PropertyName("nested_object")
-        @CreateGraphObject("id")
-        void setNestedObjectById(String id);
-        @PropertyName("nested_object")
-        @CreateGraphObject("url")
-        void setNestedObjectByUrl(String url);
-
-        // Test overloaded name
-        @CreateGraphObject("id")
-        void setNestedObject(String id);
-
-        // List version
-        GraphObjectList<NestedObject> getNestedObjects();
-        void setNestedObjects(List<NestedObject> nestedObjects);
-
-        @PropertyName("nested_objects")
-        @CreateGraphObject("id")
-        void setNestedObjectsById(List<String> id);
-        @PropertyName("nested_objects")
-        @CreateGraphObject("url")
-        void setNestedObjectsByUrl(List<String> url);
-
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetPropertyAs() throws JSONException {
-        JSONObject nestedObject = new JSONObject();
-        nestedObject.put("id", "55");
-
-        GraphObject containingObject = GraphObject.Factory.create();
-        containingObject.setProperty("nested", nestedObject);
-
-        NestedObject nestedGraphObject = containingObject.getPropertyAs("nested", NestedObject.class);
-        assertNotNull(nestedGraphObject);
-        assertEquals("55", nestedGraphObject.getId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetPropertyAsList() throws JSONException {
-        JSONObject nestedObject = new JSONObject();
-        nestedObject.put("id", "55");
-
-        JSONArray nestedArray = new JSONArray(Arrays.asList(new JSONObject[]{nestedObject}));
-        GraphObject containingObject = GraphObject.Factory.create();
-        containingObject.setProperty("nested", nestedArray);
-
-        GraphObjectList<NestedObject> nestedGraphObjects = containingObject.getPropertyAsList("nested",
-                NestedObject.class);
-        assertNotNull(nestedGraphObjects);
-        assertEquals("55", nestedGraphObjects.get(0).getId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetNestedObject() {
-        ObjectWithNestedObject object = GraphObject.Factory.create(ObjectWithNestedObject.class);
-        object.setNestedObjectById("77");
-
-        NestedObject nestedObject = object.getNestedObject();
-        assertNotNull(nestedObject);
-        assertEquals("77", nestedObject.getId());
-
-        object.setNestedObjectByUrl("http://www.example.com");
-
-        nestedObject = object.getNestedObject();
-        assertNotNull(nestedObject);
-        assertEquals("http://www.example.com", nestedObject.getUrl());
-
-        // Overloaded method
-        object.setNestedObject("77");
-
-        nestedObject = object.getNestedObject();
-        assertNotNull(nestedObject);
-        assertEquals("77", nestedObject.getId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetNestedObjects() {
-        ObjectWithNestedObject object = GraphObject.Factory.create(ObjectWithNestedObject.class);
-        object.setNestedObjectsById(Arrays.asList("77", "88"));
-
-        GraphObjectList<NestedObject> nestedObjects = object.getNestedObjects();
-        assertNotNull(nestedObjects);
-        assertEquals("77", nestedObjects.get(0).getId());
-        assertEquals("88", nestedObjects.get(1).getId());
-
-        object.setNestedObjectsByUrl(Arrays.asList("http://www.example.com/1", "http://www.example.com/2"));
-
-        nestedObjects = object.getNestedObjects();
-        assertNotNull(nestedObjects);
-        assertEquals("http://www.example.com/1", nestedObjects.get(0).getUrl());
-        assertEquals("http://www.example.com/2", nestedObjects.get(1).getUrl());
-    }
-
-    interface GraphObjectWithPrimitives extends GraphObject {
-        boolean getBoolean();
-        void setBoolean(boolean value);
-
-        int getInt();
-        void setInt(int value);
-
-        char getChar();
-        void setChar(char value);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetBooleanProperty() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        graphObject.setBoolean(true);
-        assertEquals(true, graphObject.getBoolean());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testBooleanPropertyDefaultsToFalse() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        assertEquals(false, graphObject.getBoolean());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetNumericProperty() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        graphObject.setInt(5);
-        assertEquals(5, graphObject.getInt());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testNumericPropertyDefaultsToZero() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        assertEquals(0, graphObject.getInt());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetCharProperty() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        graphObject.setChar('z');
-        assertEquals('z', graphObject.getChar());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCharPropertyDefaultsToZero() {
-        GraphObjectWithPrimitives graphObject = GraphObject.Factory.create(GraphObjectWithPrimitives.class);
-
-        assertEquals(0, graphObject.getChar());
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/model/OpenGraphActionTests.java b/facebook/tests/src/com/facebook/model/OpenGraphActionTests.java
deleted file mode 100644
index 4ba0daee9..000000000
--- a/facebook/tests/src/com/facebook/model/OpenGraphActionTests.java
+++ /dev/null
@@ -1,264 +0,0 @@
-package com.facebook.model;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-public class OpenGraphActionTests extends AndroidTestCase {
-    private static String ACTION_JSON = "{" +
-            "  \"id\": \"99\", " +
-            "  \"from\": {" +
-            "    \"name\": \"A User\", " +
-            "    \"id\": \"42\"" +
-            "  }, " +
-            "  \"start_time\": \"2013-04-11T02:05:17+0000\", " +
-            "  \"end_time\": \"2013-04-11T03:05:17+0000\", " +
-            "  \"publish_time\": \"2013-04-11T02:05:17+0000\", " +
-            "  \"ref\": \"hello!\", " +
-            "  \"message\": \"a message!\", " +
-            "  \"place\": {" +
-            "    \"id\": \"9999\", " +
-            "    \"name\": \"Some Place\", " +
-            "    \"location\": {" +
-            "      \"latitude\": 37.786130951058, " +
-            "      \"longitude\": -122.40886171765, " +
-            "      \"city\": \"San Francisco\", " +
-            "      \"country\": \"United States\", " +
-            "      \"id\": \"2421836\", " +
-            "      \"zip\": \"94102-2118\", " +
-            "      \"address\": \"5 Any Street\", " +
-            "      \"region\": \"CA\"" +
-            "    } " +
-            "  }, " +
-            "  \"tags\": [" +
-            "    {" +
-            "      \"id\": \"4321\", " +
-            "      \"name\": \"Jim Bob\"" +
-            "    }" +
-            "  ], " +
-            "  \"application\": {" +
-            "    \"name\": \"Awesome App\", " +
-            "    \"namespace\": \"awesome\", " +
-            "    \"id\": \"55\"" +
-            "  }, " +
-            "  \"data\": {" +
-            "    \"thing\": {" +
-            "      \"id\": \"509\", " +
-            "      \"url\": \"http://www.example.com/100\", " +
-            "      \"type\": \"awesome:thing\", " +
-            "      \"title\": \"A thing!\"" +
-            "    }" +
-            "  }, " +
-            "  \"type\": \"awesome:action\", " +
-            "  \"likes\": {" +
-            "    \"count\": 7, " +
-            "    \"can_like\": true, " +
-            "    \"user_likes\": false" +
-            "  }, " +
-            "  \"comments\": {" +
-            "    \"data\": [" +
-            "      {" +
-            "        \"id\": \"2_3\", " +
-            "        \"from\": {" +
-            "          \"name\": \"A Yooser\", " +
-            "          \"id\": \"1001\"" +
-            "        }, " +
-            "        \"message\": \"Here's a comment.\", " +
-            "        \"can_remove\": true, " +
-            "        \"created_time\": \"2013-04-26T23:38:19+0000\", " +
-            "        \"like_count\": 3, " +
-            "        \"user_likes\": false" +
-            "      }" +
-            "    ], " +
-            "    \"paging\": {" +
-            "      \"cursors\": {" +
-            "        \"after\": \"x\", " +
-            "        \"before\": \"x\"" +
-            "      }" +
-            "    }, " +
-            "    \"count\": 1, " +
-            "    \"can_comment\": true, " +
-            "    \"comment_order\": \"chronological\"" +
-            "  }," +
-            "  \"likes\": {" +
-            "    \"data\": [" +
-            "      {" +
-            "        \"id\": \"422\", " +
-            "        \"name\": \"Another User\"" +
-            "      }" +
-            "    ], " +
-            "    \"paging\": {" +
-            "      \"next\": \"https://graph.facebook.com/blah\"" +
-            "    }, " +
-            "    \"count\": 1, " +
-            "    \"can_like\": true, " +
-            "    \"user_likes\": true" +
-            "  }" +
-            "}";
-
-    interface TestOpenGraphActionData extends GraphObject {
-        GraphObject getThing();
-    }
-
-    interface TestOpenGraphAction extends OpenGraphAction {
-        TestOpenGraphActionData getData();
-    }
-
-    private OpenGraphAction parsedAction;
-
-    public void setUp() throws JSONException {
-        JSONObject jsonObject = new JSONObject(ACTION_JSON);
-        parsedAction = GraphObject.Factory.create(jsonObject, OpenGraphAction.class);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedId() {
-        assertEquals("99", parsedAction.getId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedType() {
-        assertEquals("awesome:action", parsedAction.getType());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedDates() {
-        assertEquals(new Date(1365645917000L), parsedAction.getStartTime());
-        assertEquals(new Date(1365649517000L), parsedAction.getEndTime());
-        assertEquals(new Date(1365645917000L), parsedAction.getPublishTime());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedRef() {
-        assertEquals("hello!", parsedAction.getRef());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedMessage() {
-        assertEquals("a message!", parsedAction.getMessage());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedPlace() {
-        GraphPlace place = parsedAction.getPlace();
-        assertEquals("9999", place.getId());
-        assertEquals("94102-2118", place.getLocation().getZip());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedTags() {
-        List<GraphObject> tags = parsedAction.getTags();
-        assertEquals(1, tags.size());
-        GraphUser tag = tags.get(0).cast(GraphUser.class);
-        assertEquals("4321", tag.getId());
-        assertEquals("Jim Bob", tag.getName());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedFrom() {
-        GraphUser from = parsedAction.getFrom();
-        assertEquals("42", from.getId());
-        assertEquals("A User", from.getName());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedLikes() {
-        JSONObject likes = parsedAction.getLikes();
-        assertEquals(1, likes.optInt("count"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedApplication() {
-        GraphObject application = parsedAction.getApplication();
-        assertEquals("Awesome App", application.getProperty("name"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedComments() {
-        JSONObject comments = parsedAction.getComments();
-        assertEquals(1, comments.optInt("count"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedData() {
-        GraphObject data = parsedAction.getData();
-        assertNotNull(data);
-
-        GraphObject thing = data.getPropertyAs("thing", GraphObject.class);
-        assertNotNull(thing);
-        assertEquals("509", thing.getProperty("id"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedTypedData() {
-        TestOpenGraphActionData data = parsedAction.getPropertyAs("data", TestOpenGraphActionData.class);
-        assertNotNull(data);
-
-        GraphObject thing = data.getThing();
-        assertNotNull(thing);
-        assertEquals("509", thing.getProperty("id"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedDataWithTypedAction() {
-        TestOpenGraphAction typedAction = parsedAction.cast(TestOpenGraphAction.class);
-        TestOpenGraphActionData data = typedAction.getData();
-        assertNotNull(data);
-
-        GraphObject thing = data.getThing();
-        assertNotNull(thing);
-        assertEquals("509", thing.getProperty("id"));
-    }
-
-    public void testSetGetTags() {
-        OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-
-        GraphObject tag = GraphObject.Factory.create();
-        tag.setProperty("id", "123");
-
-        List<GraphObject> tags = new ArrayList<GraphObject>();
-        tags.add(tag);
-
-        action.setTags(tags);
-
-        GraphObjectList<GraphObject> retrievedTags = action.getTags();
-        assertNotNull(retrievedTags);
-        assertEquals(1, retrievedTags.size());
-        assertEquals("123", retrievedTags.get(0).getProperty("id"));
-    }
-}
diff --git a/facebook/tests/src/com/facebook/model/OpenGraphObjectTests.java b/facebook/tests/src/com/facebook/model/OpenGraphObjectTests.java
deleted file mode 100644
index 42882cb5d..000000000
--- a/facebook/tests/src/com/facebook/model/OpenGraphObjectTests.java
+++ /dev/null
@@ -1,217 +0,0 @@
-package com.facebook.model;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.Arrays;
-import java.util.Date;
-
-public final class OpenGraphObjectTests extends AndroidTestCase {
-    private static String OBJECT_JSON = "{" +
-            "  \"id\": \"509\"," +
-            "  \"url\": \"http://www.example.com/100\"," +
-            "  \"type\": \"awesome:thing\"," +
-            "  \"title\": \"awesome title\"," +
-            "  \"data\": {" +
-            "    \"color\": \"blue\"" +
-            "  }," +
-            "  \"image\": [" +
-            "    {" +
-            "      \"url\": \"http://www.example.com/images/81\"" +
-            "    }" +
-            "  ]," +
-            "  \"video\": [" +
-            "    {" +
-            "      \"url\": \"http://www.example.com/videos/18\"" +
-            "    }" +
-            "  ]," +
-            "  \"audio\": [" +
-            "    {" +
-            "      \"url\": \"http://www.example.com/audio/98\"" +
-            "    }" +
-            "  ]," +
-            "  \"description\": \"a description\"," +
-            "  \"see_also\": [" +
-            "    \"http://www.example.com/101\"" +
-            "  ]," +
-            "  \"site_name\": \"Awesome Site\"," +
-            "  \"updated_time\": \"2013-04-30T18:18:17+0000\"," +
-            "  \"created_time\": \"2013-04-30T18:18:17+0000\"," +
-            "  \"application\": {" +
-            "    \"id\": \"55\"," +
-            "    \"name\": \"Awesome App\"," +
-            "    \"url\": \"https://www.facebook.com/apps/application.php?id=55\"" +
-            "  }," +
-            "  \"is_scraped\": false," +
-            "  \"post_action_id\": \"1234\"" +
-            "}";
-
-    interface TestOpenGraphObjectData extends GraphObject {
-        String getColor();
-    }
-
-    interface TestOpenGraphObject extends GraphObject {
-        TestOpenGraphObjectData getData();
-    }
-
-    public OpenGraphObject getParsedObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject(OBJECT_JSON);
-        return GraphObject.Factory.create(jsonObject, OpenGraphObject.class);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedId() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("509", parsedObject.getId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedType() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("awesome:thing", parsedObject.getType());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedUrl() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("http://www.example.com/100", parsedObject.getUrl());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedTitle() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("awesome title", parsedObject.getTitle());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedDescription() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("a description", parsedObject.getDescription());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedImage() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        GraphObjectList<GraphObject> images = parsedObject.getImage();
-        assertEquals("http://www.example.com/images/81", images.get(0).getProperty("url"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedVideo() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        GraphObjectList<GraphObject> videos = parsedObject.getVideo();
-        assertEquals("http://www.example.com/videos/18", videos.get(0).getProperty("url"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedAudio() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        GraphObjectList<GraphObject> audios = parsedObject.getAudio();
-        assertEquals("http://www.example.com/audio/98", audios.get(0).getProperty("url"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedSeeAlso() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("http://www.example.com/101", parsedObject.getSeeAlso().get(0));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedSiteName() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("Awesome Site", parsedObject.getSiteName());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedTimes() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals(new Date(1367345897000L), parsedObject.getCreatedTime());
-        assertEquals(new Date(1367345897000L), parsedObject.getUpdatedTime());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedApplication() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        GraphObject application = parsedObject.getApplication();
-        assertEquals("Awesome App", application.getProperty("name"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedIsScraped() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals(false, parsedObject.getIsScraped());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedPostActionId() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        assertEquals("1234", parsedObject.getPostActionId());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedData() throws JSONException {
-        OpenGraphObject parsedObject = getParsedObject();
-        GraphObject data = parsedObject.getData();
-
-        assertEquals("blue", data.getProperty("color"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testParsedDataWithTypedObject() throws JSONException {
-        TestOpenGraphObject parsedObject = getParsedObject().cast(TestOpenGraphObject.class);
-        TestOpenGraphObjectData data = parsedObject.getData();
-
-        assertEquals("blue", data.getColor());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetImagesByUrl() throws JSONException {
-        OpenGraphObject object = GraphObject.Factory.create(OpenGraphObject.class);
-
-        object.setImageUrls(Arrays.asList("http://www.example.com/1", "http://www.example.com/2"));
-
-        GraphObjectList<GraphObject> images = object.getImage();
-        assertNotNull(images);
-        assertEquals(2, images.size());
-        assertEquals("http://www.example.com/1", images.get(0).getProperty("url"));
-        assertEquals("http://www.example.com/2", images.get(1).getProperty("url"));
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java b/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
index a00e90083..03e137fc1 100644
--- a/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
+++ b/facebook/tests/src/com/facebook/widget/FacebookDialogTests.java
@@ -1,32 +1,29 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.widget;
 
-import android.graphics.Bitmap;
 import com.facebook.FacebookTestCase;
-import com.facebook.model.GraphObject;
-import com.facebook.model.OpenGraphAction;
-import com.facebook.model.OpenGraphObject;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.widget.ShareDialog;
 
 public class FacebookDialogTests extends FacebookTestCase {
 
@@ -35,225 +32,56 @@ private String getAttachmentNameFromContentUri(String contentUri) {
         return contentUri.substring(lastSlash + 1);
     }
 
-    public void testCantSetAttachmentsWithNullBitmaps() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-            action.setProperty("foo", "bar");
-
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-            builder.setImageAttachmentsForAction(Arrays.asList((Bitmap)null));
-            fail("expected exception");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    public void testOpenGraphActionImageAttachments() throws JSONException {
-        OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-        action.setProperty("foo", "bar");
-
-        FacebookDialog.OpenGraphActionDialogBuilder builder =
-                new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-        Bitmap bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ALPHA_8);
-
-        builder.setImageAttachmentsForAction(Arrays.asList(bitmap));
-
-        List<JSONObject> images = action.getImage();
-        assertNotNull(images);
-        assertTrue(images.size() == 1);
-
-        List<String> attachmentNames = builder.getImageAttachmentNames();
-        assertNotNull(attachmentNames);
-        assertTrue(attachmentNames.size() == 1);
-
-        String attachmentName = getAttachmentNameFromContentUri(images.get(0).getString("url"));
-        assertEquals(attachmentNames.get(0), attachmentName);
-    }
-
-    public void testCantSetObjectAttachmentsWithoutAction() {
-        try {
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), null, "foo");
-            builder.setImageAttachmentsForObject("foo", new ArrayList<Bitmap>());
-            fail("expected exception");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    public void testCantSetObjectAttachmentsWithoutObjectProperty() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-            builder.setImageAttachmentsForObject("foo", new ArrayList<Bitmap>());
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    public void testCantSetObjectAttachmentsWithNonGraphObjectProperty() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-            action.setProperty("foo", "bar");
-
-            builder.setImageAttachmentsForObject("foo", new ArrayList<Bitmap>());
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    public void testCantSetObjectAttachmentsWithNullBitmaps() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-            action.setProperty("foo", OpenGraphObject.Factory.createForPost("bar"));
-
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-            builder.setImageAttachmentsForObject("foo", Arrays.asList((Bitmap)null));
-            fail("expected exception");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    public void testOpenGraphObjectImageAttachments() throws JSONException {
-        OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-        OpenGraphObject object = OpenGraphObject.Factory.createForPost("bar");
-        action.setProperty("foo", object);
-
-        FacebookDialog.OpenGraphActionDialogBuilder builder =
-                new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-        Bitmap bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ALPHA_8);
-
-        builder.setImageAttachmentsForObject("foo", Arrays.asList(bitmap));
-
-        List<GraphObject> images = object.getImage();
-        assertNotNull(images);
-        assertTrue(images.size() == 1);
-
-        List<String> attachmentNames = builder.getImageAttachmentNames();
-        assertNotNull(attachmentNames);
-        assertTrue(attachmentNames.size() == 1);
-
-        String attachmentName = getAttachmentNameFromContentUri((String) images.get(0).getProperty("url"));
-        assertEquals(attachmentNames.get(0), attachmentName);
-    }
-
-    public void testOpenGraphActionAndObjectImageAttachments() throws JSONException {
-        OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-        OpenGraphObject object = OpenGraphObject.Factory.createForPost("bar");
-        action.setProperty("foo", object);
-
-        FacebookDialog.OpenGraphActionDialogBuilder builder =
-                new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "foo");
-
-        Bitmap bitmap = Bitmap.createBitmap(20, 20, Bitmap.Config.ALPHA_8);
-
-        builder.setImageAttachmentsForAction(Arrays.asList(bitmap));
-        builder.setImageAttachmentsForObject("foo", Arrays.asList(bitmap));
-
-        List<String> attachmentNames = builder.getImageAttachmentNames();
-        assertNotNull(attachmentNames);
-        assertTrue(attachmentNames.size() == 2);
-
-        List<GraphObject> objectImages = object.getImage();
-        assertNotNull(objectImages);
-        assertTrue(objectImages.size() == 1);
-
-        String attachmentName = getAttachmentNameFromContentUri((String) objectImages.get(0).getProperty("url"));
-        assertTrue(attachmentNames.contains(attachmentName));
-
-        List<JSONObject> actionImages = action.getImage();
-        assertNotNull(actionImages);
-        assertTrue(actionImages.size() == 1);
-
-        attachmentName = getAttachmentNameFromContentUri((String) actionImages.get(0).getString("url"));
-        assertTrue(attachmentNames.contains(attachmentName));
-    }
-
-    public void testOpenGraphDialogBuilderRequiresAction() {
-        try {
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), null, "foo");
-
-            builder.build();
-            fail("expected exception");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    public void testOpenGraphDialogBuilderRequiresActionType() {
-        try {
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(),
-                            OpenGraphAction.Factory.createForPost(null), "foo");
-
-            builder.build();
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    public void testOpenGraphDialogBuilderRequiresPreviewPropertyName() {
-        try {
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(),
-                            OpenGraphAction.Factory.createForPost("foo"), null);
-
-            builder.build();
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    public void testOpenGraphDialogBuilderRequiresPreviewPropertyToExist() {
-        try {
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(),
-                            OpenGraphAction.Factory.createForPost("foo"), "nosuchproperty");
-
-            builder.build();
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    @SuppressWarnings("deprecation")
-    public void testOpenGraphDialogBuilderDeprecatedConstructorRequiresActionType() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost();
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost("bar");
-            action.setProperty("object", object);
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "", "object");
-
-            builder.build();
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-
-    }
-
-    @SuppressWarnings("deprecation")
-    public void testOpenGraphDialogBuilderDeprecatedConstructorRequiresActionTypeMatches() {
-        try {
-            OpenGraphAction action = OpenGraphAction.Factory.createForPost("foo");
-            OpenGraphObject object = OpenGraphObject.Factory.createForPost("bar");
-            action.setProperty("object", object);
-            FacebookDialog.OpenGraphActionDialogBuilder builder =
-                    new FacebookDialog.OpenGraphActionDialogBuilder(getActivity(), action, "notfoo", "object");
-
-            builder.build();
-            fail("expected exception");
-        } catch (IllegalArgumentException exception) {
-        }
-
-    }
+    //
+    // TODO(v4) - Fix and uncomment these
+    //
+//    public void testCantSetAttachmentsWithNullBitmaps() throws JSONException {
+//        try {
+//            ArrayList<SharePhoto> photos = new ArrayList<>();
+//            photos.add(new SharePhotoBuilder().setBitmap(null).build());
+//
+//            ShareOpenGraphContent ogContent = new ShareOpenGraphContentBuilder()
+//                    .setAction(
+//                            new ShareOpenGraphActionBuilder()
+//                                    .setActionType("foo")
+//                                    .putString("foo", "bar")
+//                                    .putPhotoArrayList("image", photos)
+//                                    .build())
+//                    .setPreviewPropertyName("foo")
+//                    .build();
+//
+//            ShareDialog.share(getActivity(), ogContent);
+//
+//            fail("expected exception");
+//        } catch (NullPointerException exception) {
+//        }
+//    }
+//
+//    public void testCantSetObjectAttachmentsWithNullBitmaps() throws JSONException {
+//        try {
+//            ArrayList<SharePhoto> photos = new ArrayList<>();
+//            photos.add(new SharePhotoBuilder().setBitmap(null).build());
+//
+//            ShareOpenGraphObject ogObject = new ShareOpenGraphObjectBuilder()
+//                    .putString("type", "bar")
+//                    .putPhotoArrayList("image", photos)
+//                    .build();
+//
+//            ShareOpenGraphContent ogContent = new ShareOpenGraphContentBuilder()
+//                    .setAction(
+//                            new ShareOpenGraphActionBuilder()
+//                                    .setActionType("foo")
+//                                    .putObject("foo", ogObject)
+//                                    .build())
+//                    .setPreviewPropertyName("foo")
+//                    .build();
+//
+//            ShareDialog.share(getActivity(), ogContent);
+//
+//            fail("expected exception");
+//        } catch (NullPointerException exception) {
+//        }
+//    }
+
+    // TODO(v4) - Add tests for ShareContentValidation.
 }
diff --git a/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
deleted file mode 100644
index aa3c0a57d..000000000
--- a/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.os.Bundle;
-import android.test.TouchUtils;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.view.View;
-import android.widget.CheckBox;
-import android.widget.ListView;
-import com.facebook.TestBlocker;
-import com.facebook.TestSession;
-import com.facebook.sdk.tests.R;
-
-import java.util.Arrays;
-import java.util.Collection;
-
-public class FriendPickerFragmentTests extends FragmentTestCase<FriendPickerFragmentTests.TestActivity> {
-    public FriendPickerFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersProgrammatically() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                Bundle bundle = new Bundle();
-                // We deliberately set these to non-defaults to ensure they are set correctly.
-                bundle.putString(FriendPickerFragment.USER_ID_BUNDLE_KEY, "4");
-                bundle.putBoolean(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, false);
-                bundle.putBoolean(FriendPickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
-                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "middle_name,link");
-                FriendPickerFragment fragment = new FriendPickerFragment(bundle);
-                getActivity().setContentToFragment(fragment);
-            }
-        });
-
-        // We don't just test the fragment we created directly above, because we want it to go through the
-        // activity lifecycle and ensure the settings are still correct.
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals("4", fragment.getUserId());
-        assertEquals(false, fragment.getMultiSelect());
-        assertEquals(false, fragment.getShowPictures());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("middle_name"));
-        assertTrue(extraFields.contains("link"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToLayout(R.layout.friend_picker_test_layout_1, R.id.friend_picker_fragment);
-            }
-        });
-
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(false, fragment.getMultiSelect());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("middle_name"));
-        assertTrue(extraFields.contains("link"));
-        // It doesn't make sense to specify user id via layout, so we don't support it.
-    }
-
-    @LargeTest
-    public void testFriendsLoad() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        // Ensure our test user has at least one friend.
-        final TestSession session1 = openTestSessionWithSharedUser();
-        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
-        makeTestUsersFriends(session1, session2);
-
-        // Trigger a data load (on the UI thread).
-        final TestBlocker blocker = getTestBlocker();
-        // We expect to get called twice -- once with results, once to indicate we are done paging.
-        runAndBlockOnUiThread(2, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session1);
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker.signal();
-                    }
-                });
-                fragment.setExtraFields(Arrays.asList("first_name"));
-                fragment.loadData(true);
-            }
-        });
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        CheckBox checkBox = (CheckBox)listView.findViewById(R.id.com_facebook_picker_checkbox);
-        assertNotNull(checkBox);
-        assertFalse(checkBox.isChecked());
-        assertEquals(0, fragment.getSelection().size());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection (it might not be the user we made a friend up above, if the
-        // test user has more than one friend).
-        assertEquals(1, fragment.getSelection().size());
-
-        // We should have gotten the extra field we wanted.
-        assertNotNull(fragment.getSelection().iterator().next().getFirstName());
-
-        // And the checkbox should be checked.
-        assertTrue(checkBox.isChecked());
-
-        // Touch the item again. We should go back to no selection.
-        TouchUtils.clickView(this, firstChild);
-        assertEquals(0, fragment.getSelection().size());
-        assertFalse(checkBox.isChecked());
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<FriendPickerFragment> {
-        public TestActivity() {
-            super(FriendPickerFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
deleted file mode 100644
index 1ac0a3f69..000000000
--- a/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.location.Location;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import com.facebook.*;
-import com.facebook.model.GraphPlace;
-
-public class GraphObjectPagingLoaderTests extends FragmentTestCase<GraphObjectPagingLoaderTests.TestActivity> {
-    public GraphObjectPagingLoaderTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLoaderLoadsAndFollowsNextLinks() throws Exception {
-        CountingCallback callback = new CountingCallback();
-        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
-                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
-
-        TestSession session = openTestSessionWithSharedUser();
-
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        final Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, null, null);
-
-        // Need to run this on blocker thread so callbacks are made there.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.startLoading(request, false);
-            }
-        }, false);
-
-        getTestBlocker().waitForSignals(1);
-        assertEquals(1, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-        // We might not get back the exact number we requested because of privacy or other rules on
-        // the service side.
-        assertNotNull(callback.results);
-        assertTrue(callback.results.getCount() > 0);
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.followNextLink();
-            }
-        }, false);
-        getTestBlocker().waitForSignals(1);
-        assertEquals(2, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLoaderFinishesImmediatelyOnNoResults() throws Exception {
-        CountingCallback callback = new CountingCallback();
-        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
-                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
-
-        TestSession session = openTestSessionWithSharedUser();
-
-        // Unlikely to ever be a Place here.
-        Location location = new Location("");
-        location.setLatitude(-1.0);
-        location.setLongitude(-1.0);
-
-        final Request request = Request.newPlacesSearchRequest(session, location, 10, 5, null, null);
-
-        // Need to run this on blocker thread so callbacks are made there.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.startLoading(request, false);
-            }
-        }, false);
-
-        getTestBlocker().waitForSignals(1);
-        assertEquals(1, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-        assertNotNull(callback.results);
-        assertEquals(0, callback.results.getCount());
-    }
-
-    private class CountingCallback implements
-            GraphObjectPagingLoader.OnErrorListener, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<GraphPlace>> {
-        public int onLoadFinishedCount;
-        public int onLoadResetCount;
-        public int onErrorCount;
-        public SimpleGraphObjectCursor<GraphPlace> results;
-
-        private TestBlocker testBlocker = getTestBlocker();
-
-        @Override
-        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
-            ++onErrorCount;
-            testBlocker.signal();
-        }
-
-        @Override
-        public Loader<SimpleGraphObjectCursor<GraphPlace>> onCreateLoader(int id, Bundle args) {
-            GraphObjectPagingLoader<GraphPlace> loader = new GraphObjectPagingLoader<GraphPlace>(getActivity(),
-                    GraphPlace.class);
-            loader.setOnErrorListener(this);
-            return loader;
-        }
-
-        @Override
-        public void onLoadFinished(Loader<SimpleGraphObjectCursor<GraphPlace>> loader,
-                SimpleGraphObjectCursor<GraphPlace> data) {
-            results = data;
-            ++onLoadFinishedCount;
-            testBlocker.signal();
-        }
-
-        @Override
-        public void onLoaderReset(Loader<SimpleGraphObjectCursor<GraphPlace>> loader) {
-            ++onLoadResetCount;
-            testBlocker.signal();
-        }
-    }
-
-    public static class DummyFragment extends Fragment  {
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<DummyFragment> {
-        public TestActivity() {
-            super(DummyFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/LoginButtonTest.java b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
deleted file mode 100644
index 11f8f6033..000000000
--- a/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
+++ /dev/null
@@ -1,369 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.*;
-import com.facebook.widget.LoginButton;
-import junit.framework.Assert;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class LoginButtonTest extends SessionTestsBase {
-
-    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginButton() throws Throwable {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        // Verify state with no token in cache
-        Assert.assertEquals(SessionState.CREATED, session.getState());
-
-        // Add another status recorder to ensure that the callback we hand to LoginButton
-        // also gets called as expected. We expect to get the same order of calls as statusRecorder does.
-        final SessionStatusCallbackRecorder loginButtonStatusRecorder = new SessionStatusCallbackRecorder();
-
-        // Create the button. To get session status updates, we need to actually attach the
-        // button to a window, which must be done on the UI thread.
-        final LoginButton button = new LoginButton(getActivity());
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentView(button);
-                button.setSession(session);
-                button.setSessionStatusCallback(loginButtonStatusRecorder);
-                button.performClick();
-            }
-        });
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENING, null);
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests that the onErrorListener gets called if there's an error
-    public void testLoginFail() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        final Exception openException = new Exception("Open failed!");
-        final AtomicBoolean clicked = new AtomicBoolean(false);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        LoginButton.OnErrorListener listener = new LoginButton.OnErrorListener() {
-            @Override
-            public void onError(FacebookException exception) {
-                synchronized (this) {
-                    assertEquals(exception.getCause().getMessage(), openException.getMessage());
-                    clicked.set(true);
-                    this.notifyAll();
-                }
-            }
-        };
-        button.setOnErrorListener(listener);
-        button.setSession(session);
-        session.addAuthorizeResult(openException);
-
-        button.onAttachedToWindow();
-        button.performClick();
-
-        try {
-            synchronized (listener) {
-                listener.wait(DEFAULT_TIMEOUT_MILLISECONDS);
-            }
-        } catch (InterruptedException e) {
-            fail("Interrupted during open");
-        }
-
-        if (!clicked.get()) {
-            fail("Did not get exception");
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests that the onErrorListener does NOT get called if there's a callback set.
-    public void testLoginFail2() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        final Exception openException = new Exception("Open failed!");
-        final AtomicBoolean clicked = new AtomicBoolean(false);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        Session.StatusCallback callback = new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                if (exception != null) {
-                    synchronized (this) {
-                        assertEquals(exception.getMessage(), openException.getMessage());
-                        clicked.set(true);
-                        this.notifyAll();
-                    }
-                }
-            }
-        };
-        button.setSessionStatusCallback(callback);
-        button.setOnErrorListener(new LoginButton.OnErrorListener() {
-            @Override
-            public void onError(FacebookException exception) {
-                synchronized (this) {
-                    fail("Should not be in here");
-                    this.notifyAll();
-                }
-            }
-        });
-        button.setSession(session);
-        session.addAuthorizeResult(openException);
-
-        button.onAttachedToWindow();
-        button.performClick();
-
-        try {
-            synchronized (callback) {
-                callback.wait(DEFAULT_TIMEOUT_MILLISECONDS);
-            }
-        } catch (InterruptedException e) {
-            fail("Interrupted during open");
-        }
-
-        if (!clicked.get()) {
-            fail("Did not get exception");
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddReadPermissions() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setReadPermissions("read_permission", "read_another");
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddPublishPermissions() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setPublishPermissions("publish_permission", "publish_another");
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddReadThenPublishPermissions() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setReadPermissions("read_permission", "read_another");
-        try {
-            button.setPublishPermissions("read_permission", "read_a_third");
-            fail("Should not be able to reach here");
-        } catch (Exception e) {
-            assertTrue(e instanceof UnsupportedOperationException);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddPublishThenReadPermissions() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setPublishPermissions("publish_permission", "publish_another");
-        try {
-            button.setReadPermissions("publish_permission", "publish_a_third");
-            fail("Should not be able to reach here");
-        } catch (Exception e) {
-            assertTrue(e instanceof UnsupportedOperationException);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddReadThenPublishPermissionsWithClear() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setReadPermissions("read_permission", "read_another");
-        button.clearPermissions();
-        button.setPublishPermissions("publish_permission", "publish_another");
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddMorePermissionsToOpenSession() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        session.addAuthorizeResult("A token of thanks",
-                Arrays.asList(new String[] {"read_permission", "read_another"}), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // this should be fine
-        button.setReadPermissions("read_permission", "read_another");
-
-        button.setReadPermissions("read_permission", "read_a_third");
-        List<String> permissions = button.getPermissions();
-        assertTrue(permissions.contains("read_permission"));
-        assertTrue(permissions.contains("read_another"));
-        assertFalse(permissions.contains("read_a_third"));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetDefaultAudience() {
-        SessionTestsBase.MockTokenCachingStrategy cache = new SessionTestsBase.MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setPublishPermissions("publish_permission", "publish_another");
-        button.setDefaultAudience(SessionDefaultAudience.FRIENDS);
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertNotNull(session.getLastRequest());
-        assertEquals(SessionDefaultAudience.FRIENDS, session.getLastRequestAudience());
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
deleted file mode 100644
index f8cc79a74..000000000
--- a/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.location.Location;
-import android.os.Bundle;
-import android.test.TouchUtils;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.view.View;
-import android.widget.ListView;
-import com.facebook.*;
-import com.facebook.sdk.tests.R;
-
-import java.util.Collection;
-
-public class PlacePickerFragmentTests extends FragmentTestCase<PlacePickerFragmentTests.TestActivity> {
-    public PlacePickerFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersProgrammatically() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        final Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                Bundle bundle = new Bundle();
-                // We deliberately set these to non-defaults to ensure they are set correctly.
-                bundle.putBoolean(PlacePickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
-                bundle.putInt(PlacePickerFragment.RADIUS_IN_METERS_BUNDLE_KEY, 75);
-                bundle.putInt(PlacePickerFragment.RESULTS_LIMIT_BUNDLE_KEY, 5);
-                bundle.putString(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, "coffee");
-                bundle.putParcelable(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
-                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "checkins,general_info");
-
-                PlacePickerFragment fragment = new PlacePickerFragment(bundle);
-                getActivity().setContentToFragment(fragment);
-            }
-        });
-
-        // We don't just test the fragment we created directly above, because we want it to go through the
-        // activity lifecycle and ensure the settings are still correct.
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(75, fragment.getRadiusInMeters());
-        assertEquals(5, fragment.getResultsLimit());
-        assertEquals("coffee", fragment.getSearchText());
-        assertEquals(location, fragment.getLocation());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("checkins"));
-        assertTrue(extraFields.contains("general_info"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToLayout(R.layout.place_picker_test_layout_1, R.id.place_picker_fragment);
-            }
-        });
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(75, fragment.getRadiusInMeters());
-        assertEquals(5, fragment.getResultsLimit());
-        assertEquals("coffee", fragment.getSearchText());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("checkins"));
-        assertTrue(extraFields.contains("general_info"));
-        // It doesn't make sense to specify location via layout, so we don't support it.
-    }
-
-    @LargeTest
-    public void testPlacesLoad() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-        getInstrumentation().waitForIdleSync();
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        final TestSession session = openTestSessionWithSharedUser();
-
-        // Trigger a data load (on the UI thread).
-        final TestBlocker blocker = getTestBlocker();
-        runAndBlockOnUiThread(1, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session);
-
-                Location location = new Location("");
-                location.setLatitude(47.6204);
-                location.setLongitude(-122.3491);
-                fragment.setLocation(location);
-
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker.signal();
-                    }
-                });
-                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-                    @Override
-                    public void onError(PickerFragment<?> fragment, FacebookException error) {
-                        fail("Got unexpected error: " + error.toString());
-                    }
-                });
-                fragment.loadData(true);
-            }
-        });
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        assertNull(fragment.getSelection());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection.
-        assertNotNull(fragment.getSelection());
-
-        // Touch the item again. We should go back to no selection.
-        TouchUtils.clickView(this, firstChild);
-        assertNull(fragment.getSelection());
-    }
-
-    @LargeTest
-    public void testClearsResultsWhenSessionClosed() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-        getInstrumentation().waitForIdleSync();
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        final TestSession session = openTestSessionWithSharedUser();
-
-        // Trigger a data load (on the UI thread).
-        // We use multiple test blockers to keep the counts from getting confused if other events
-        // cause our listeners to fire.
-        final TestBlocker blocker1 = TestBlocker.createTestBlocker();
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session);
-
-                Location location = new Location("");
-                location.setLatitude(47.6204);
-                location.setLongitude(-122.3491);
-                fragment.setLocation(location);
-
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker1.signal();
-                    }
-                });
-                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-                    @Override
-                    public void onError(PickerFragment<?> fragment, FacebookException error) {
-                        fail("Got unexpected error: " + error.getMessage());
-                    }
-                });
-                fragment.loadData(true);
-            }
-        });
-        blocker1.waitForSignals(1);
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-
-        Thread.sleep(500);
-
-        int lastPosition = listView.getLastVisiblePosition();
-        assertTrue(lastPosition > -1);
-
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        assertNull(fragment.getSelection());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection.
-        assertNotNull(fragment.getSelection());
-
-        // To validate the behavior, we need to wait until the session state notifications have been processed.
-        // We run this on the UI thread but don't wait on the blocker until we've closed the session.
-        final TestBlocker blocker2 = TestBlocker.createTestBlocker();
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                session.addCallback(new Session.StatusCallback() {
-                    @Override
-                    public void call(Session session, SessionState state, Exception exception) {
-                        blocker2.signal();
-                    }
-                });
-            }
-        });
-        session.close();
-        // Wait for the notification and for any UI activity to stop.
-        blocker2.waitForSignals(1);
-        getInstrumentation().waitForIdleSync();
-
-        Thread.sleep(500);
-        // The list and the selection should have been cleared.
-        lastPosition = listView.getLastVisiblePosition();
-        assertTrue(lastPosition == -1);
-        assertNull(fragment.getSelection());
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<PlacePickerFragment> {
-        public TestActivity() {
-            super(PlacePickerFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-
-        protected PlacePickerFragment createFragment() throws InstantiationException, IllegalAccessException {
-            Bundle bundle = new Bundle();
-            bundle.putBoolean(PlacePickerFragment.SHOW_SEARCH_BOX_BUNDLE_KEY, false);
-
-            return new PlacePickerFragment(bundle);
-        }
-
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
deleted file mode 100644
index 185caa0b8..000000000
--- a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import com.facebook.SessionDefaultAudience;
-import com.facebook.SessionLoginBehavior;
-
-import java.util.List;
-
-public class UserSettingsFragmentTests extends FragmentTestCase<UserSettingsFragmentTests.TestActivity> {
-
-    public UserSettingsFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        final UserSettingsFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(SessionLoginBehavior.SUPPRESS_SSO, fragment.getLoginBehavior());
-        assertEquals(SessionDefaultAudience.EVERYONE, fragment.getDefaultAudience());
-        List<String> permissions = fragment.getPermissions();
-        assertEquals(2, permissions.size());
-        assertEquals("read_1", permissions.get(0));
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<UserSettingsFragment> {
-        public TestActivity() {
-            super(UserSettingsFragment.class);
-        }
-
-        @Override
-        public void onCreate(Bundle savedInstanceState) {
-            super.onCreate(savedInstanceState);
-            getSupportFragmentManager().executePendingTransactions();
-            UserSettingsFragment fragment = getFragment();
-            fragment.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
-            fragment.setReadPermissions("read_1", "read_2");
-            fragment.setDefaultAudience(SessionDefaultAudience.EVERYONE);
-        }
-    }
-}
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 000000000..6acd9c358
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,4 @@
+ANDROID_BUILD_MIN_SDK_VERSION=9
+ANDROID_BUILD_TARGET_SDK_VERSION=21
+ANDROID_BUILD_TOOLS_VERSION=21.1.2
+ANDROID_BUILD_SDK_VERSION=21
diff --git a/gradle/gradle/wrapper/gradle-wrapper.jar b/gradle/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 667288ad6..000000000
Binary files a/gradle/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/gradle/gradle/wrapper/gradle-wrapper.properties b/gradle/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 221ce08bc..000000000
--- a/gradle/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Mon Nov 04 15:03:41 PST 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip
diff --git a/gradle/gradlew b/gradle/gradlew
deleted file mode 100755
index 91a7e269e..000000000
--- a/gradle/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradle/gradlew.bat b/gradle/gradlew.bat
deleted file mode 100644
index aec99730b..000000000
--- a/gradle/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 75b72d4da..5fc9ea490 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Feb 05 10:18:08 PST 2014
+#Tue Dec 30 15:37:06 PST 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.9-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/keystores/BUCK b/keystores/BUCK
new file mode 100644
index 000000000..15da20e6b
--- /dev/null
+++ b/keystores/BUCK
@@ -0,0 +1,8 @@
+keystore(
+  name = 'debug',
+  store = 'debug.keystore',
+  properties = 'debug.keystore.properties',
+  visibility = [
+    'PUBLIC',
+  ],
+)
diff --git a/keystores/debug.keystore b/keystores/debug.keystore
new file mode 100644
index 000000000..364e105ed
Binary files /dev/null and b/keystores/debug.keystore differ
diff --git a/keystores/debug.keystore.properties b/keystores/debug.keystore.properties
new file mode 100644
index 000000000..121bfb49f
--- /dev/null
+++ b/keystores/debug.keystore.properties
@@ -0,0 +1,4 @@
+key.store=debug.keystore
+key.alias=androiddebugkey
+key.store.password=android
+key.alias.password=android
diff --git a/libs/BUCK b/libs/BUCK
new file mode 100644
index 000000000..1a2a7548a
--- /dev/null
+++ b/libs/BUCK
@@ -0,0 +1,15 @@
+prebuilt_jar(
+  name = 'android-support-v4',
+  binary_jar = 'android-support-v4.jar',
+  visibility = [
+    'PUBLIC',
+  ],
+)
+
+prebuilt_jar(
+  name = 'bolts',
+  binary_jar = 'bolts.jar',
+  visibility = [
+    'PUBLIC',
+  ],
+)
diff --git a/libs/android-support-v4.jar b/libs/android-support-v4.jar
index 9056828a0..c31cede47 100644
Binary files a/libs/android-support-v4.jar and b/libs/android-support-v4.jar differ
diff --git a/libs/bolts-android-1.1.2.jar b/libs/bolts-android-1.1.2.jar
new file mode 100644
index 000000000..88a01a30b
Binary files /dev/null and b/libs/bolts-android-1.1.2.jar differ
diff --git a/samples/FriendPickerSample/.classpath b/samples/FriendPickerSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/FriendPickerSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/FriendPickerSample/.project b/samples/FriendPickerSample/.project
deleted file mode 100644
index eb8d8732f..000000000
--- a/samples/FriendPickerSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>FriendPickerSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/FriendPickerSample/AndroidManifest.xml b/samples/FriendPickerSample/AndroidManifest.xml
deleted file mode 100644
index d8f1911cd..000000000
--- a/samples/FriendPickerSample/AndroidManifest.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.facebook.samples.friendpicker"
-          android:versionCode="1"
-          android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
-    <uses-permission android:name="android.permission.INTERNET"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-    <application android:label="@string/app_name"
-                 android:icon="@drawable/icon"
-                 android:theme="@android:style/Theme.NoTitleBar"
-                 android:name=".FriendPickerApplication"
-            >
-        <activity android:name="FriendPickerSampleActivity"
-                  android:label="@string/app_name"
-                  android:windowSoftInputMode="adjustResize">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
-            </intent-filter>
-        </activity>
-        <activity android:name="PickFriendsActivity"
-                  android:label="Pick Friends">
-        </activity>
-        <activity android:name="com.facebook.LoginActivity"
-                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
-                  android:label="@string/app_name" />
-        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
-    </application>
-</manifest>
diff --git a/samples/FriendPickerSample/ant.properties b/samples/FriendPickerSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/FriendPickerSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/FriendPickerSample/build.gradle b/samples/FriendPickerSample/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/samples/FriendPickerSample/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/samples/FriendPickerSample/build.xml b/samples/FriendPickerSample/build.xml
deleted file mode 100644
index 92f485560..000000000
--- a/samples/FriendPickerSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="FriendPickerSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/FriendPickerSample/project.properties b/samples/FriendPickerSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/FriendPickerSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/FriendPickerSample/res/drawable-hdpi/icon.png b/samples/FriendPickerSample/res/drawable-hdpi/icon.png
deleted file mode 100644
index 6a930c6c6..000000000
Binary files a/samples/FriendPickerSample/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/samples/FriendPickerSample/res/drawable-mdpi/icon.png b/samples/FriendPickerSample/res/drawable-mdpi/icon.png
deleted file mode 100644
index 33b418b7a..000000000
Binary files a/samples/FriendPickerSample/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/samples/FriendPickerSample/res/drawable-xhdpi/icon.png b/samples/FriendPickerSample/res/drawable-xhdpi/icon.png
deleted file mode 100644
index 494e37a8d..000000000
Binary files a/samples/FriendPickerSample/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/samples/FriendPickerSample/res/drawable/icon.png b/samples/FriendPickerSample/res/drawable/icon.png
deleted file mode 100644
index 33b418b7a..000000000
Binary files a/samples/FriendPickerSample/res/drawable/icon.png and /dev/null differ
diff --git a/samples/FriendPickerSample/res/layout/main.xml b/samples/FriendPickerSample/res/layout/main.xml
deleted file mode 100644
index 88d6f01df..000000000
--- a/samples/FriendPickerSample/res/layout/main.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <Button
-            android:id="@+id/pickFriendsButton"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:text="Pick Friends"
-            />
-    <TextView
-            android:id="@+id/resultsTextView"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:textColor="#FFFFFF"
-            />
-
-</LinearLayout>
-
diff --git a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
deleted file mode 100644
index b995978da..000000000
--- a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <FrameLayout
-            android:id="@+id/friend_picker_fragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            />
-</LinearLayout>
-
diff --git a/samples/FriendPickerSample/res/values/strings.xml b/samples/FriendPickerSample/res/values/strings.xml
deleted file mode 100644
index 747f98078..000000000
--- a/samples/FriendPickerSample/res/values/strings.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_name">FriendPickerSample</string>
-    <string name="app_id">370546396320150</string>
-    <string name="exception">Exception: %1$s</string>
-    <string name="ok_button">OK</string>
-</resources>
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
deleted file mode 100644
index 9d901ca84..000000000
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.friendpicker;
-
-import android.app.Application;
-import com.facebook.model.GraphUser;
-
-import java.util.List;
-
-// We use a custom Application class to store our minimal state data (which users have been selected).
-// A real-world application will likely require a more robust data model.
-public class FriendPickerApplication extends Application {
-    private List<GraphUser> selectedUsers;
-
-    public List<GraphUser> getSelectedUsers() {
-        return selectedUsers;
-    }
-
-    public void setSelectedUsers(List<GraphUser> selectedUsers) {
-        this.selectedUsers = selectedUsers;
-    }
-}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
deleted file mode 100644
index 1c8ec2b62..000000000
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.friendpicker;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.text.TextUtils;
-import android.view.View;
-import android.widget.Button;
-import android.widget.TextView;
-import com.facebook.AppEventsLogger;
-import com.facebook.SessionState;
-import com.facebook.UiLifecycleHelper;
-import com.facebook.model.GraphUser;
-import com.facebook.Session;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-public class FriendPickerSampleActivity extends FragmentActivity {
-    private static final int PICK_FRIENDS_ACTIVITY = 1;
-    private Button pickFriendsButton;
-    private TextView resultsTextView;
-    private UiLifecycleHelper lifecycleHelper;
-    boolean pickFriendsWhenSessionOpened;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
-        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
-        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickPickFriends();
-            }
-        });
-
-        lifecycleHelper = new UiLifecycleHelper(this, new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                onSessionStateChanged(session, state, exception);
-            }
-        });
-        lifecycleHelper.onCreate(savedInstanceState);
-
-        ensureOpenSession();
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-
-        // Update the display every time we are started.
-        displaySelectedFriends(RESULT_OK);
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
-        AppEventsLogger.activateApp(this);
-    }
-
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        switch (requestCode) {
-            case PICK_FRIENDS_ACTIVITY:
-                displaySelectedFriends(resultCode);
-                break;
-            default:
-                Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
-                break;
-        }
-    }
-
-    private boolean ensureOpenSession() {
-        if (Session.getActiveSession() == null ||
-                !Session.getActiveSession().isOpened()) {
-            Session.openActiveSession(this, true, new Session.StatusCallback() {
-                @Override
-                public void call(Session session, SessionState state, Exception exception) {
-                    onSessionStateChanged(session, state, exception);
-                }
-            });
-            return false;
-        }
-        return true;
-    }
-
-    private void onSessionStateChanged(Session session, SessionState state, Exception exception) {
-        if (pickFriendsWhenSessionOpened && state.isOpened()) {
-            pickFriendsWhenSessionOpened = false;
-
-            startPickFriendsActivity();
-        }
-    }
-
-    private void displaySelectedFriends(int resultCode) {
-        String results = "";
-        FriendPickerApplication application = (FriendPickerApplication) getApplication();
-
-        Collection<GraphUser> selection = application.getSelectedUsers();
-        if (selection != null && selection.size() > 0) {
-            ArrayList<String> names = new ArrayList<String>();
-            for (GraphUser user : selection) {
-                names.add(user.getName());
-            }
-            results = TextUtils.join(", ", names);
-        } else {
-            results = "<No friends selected>";
-        }
-
-        resultsTextView.setText(results);
-    }
-
-    private void onClickPickFriends() {
-        startPickFriendsActivity();
-    }
-
-    private void startPickFriendsActivity() {
-        if (ensureOpenSession()) {
-            Intent intent = new Intent(this, PickFriendsActivity.class);
-            // Note: The following line is optional, as multi-select behavior is the default for
-            // FriendPickerFragment. It is here to demonstrate how parameters could be passed to the
-            // friend picker if single-select functionality was desired, or if a different user ID was
-            // desired (for instance, to see friends of a friend).
-            PickFriendsActivity.populateParameters(intent, null, true, true);
-            startActivityForResult(intent, PICK_FRIENDS_ACTIVITY);
-        } else {
-            pickFriendsWhenSessionOpened = true;
-        }
-    }
-}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
deleted file mode 100644
index 879cd62bd..000000000
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.friendpicker;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.widget.Toast;
-import com.facebook.FacebookException;
-import com.facebook.model.GraphUser;
-import com.facebook.widget.FriendPickerFragment;
-import com.facebook.widget.PickerFragment;
-
-import java.util.List;
-
-// This class provides an example of an Activity that uses FriendPickerFragment to display a list of
-// the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
-// desired parameters -- see PickPlaceActivity in the PlacePickerSample project for an example of an
-// Activity creating a fragment (in this case a PlacePickerFragment) via XML layout rather than
-// programmatically.
-public class PickFriendsActivity extends FragmentActivity {
-    FriendPickerFragment friendPickerFragment;
-
-    // A helper to simplify life for callers who want to populate a Bundle with the necessary
-    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
-    // are simple, so we just populate what we want to pass to the FriendPickerFragment.
-    public static void populateParameters(Intent intent, String userId, boolean multiSelect, boolean showTitleBar) {
-        intent.putExtra(FriendPickerFragment.USER_ID_BUNDLE_KEY, userId);
-        intent.putExtra(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, multiSelect);
-        intent.putExtra(FriendPickerFragment.SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.pick_friends_activity);
-
-        FragmentManager fm = getSupportFragmentManager();
-
-        if (savedInstanceState == null) {
-            // First time through, we create our fragment programmatically.
-            final Bundle args = getIntent().getExtras();
-            friendPickerFragment = new FriendPickerFragment(args);
-            fm.beginTransaction()
-                    .add(R.id.friend_picker_fragment, friendPickerFragment)
-                    .commit();
-        } else {
-            // Subsequent times, our fragment is recreated by the framework and already has saved and
-            // restored its state, so we don't need to specify args again. (In fact, this might be
-            // incorrect if the fragment was modified programmatically since it was created.)
-            friendPickerFragment = (FriendPickerFragment) fm.findFragmentById(R.id.friend_picker_fragment);
-        }
-
-        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(PickerFragment<?> fragment, FacebookException error) {
-                PickFriendsActivity.this.onError(error);
-            }
-        });
-
-        friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked(PickerFragment<?> fragment) {
-                // We just store our selection in the Application for other activities to look at.
-                FriendPickerApplication application = (FriendPickerApplication) getApplication();
-                application.setSelectedUsers(friendPickerFragment.getSelection());
-
-                setResult(RESULT_OK, null);
-                finish();
-            }
-        });
-    }
-
-    private void onError(Exception error) {
-        String text = getString(R.string.exception, error.getMessage());
-        Toast toast = Toast.makeText(this, text, Toast.LENGTH_SHORT);
-        toast.show();
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        try {
-            FriendPickerApplication application = (FriendPickerApplication) getApplication();
-            List<GraphUser> selectedUsers = application.getSelectedUsers();
-            if (selectedUsers != null && !selectedUsers.isEmpty()) {
-                friendPickerFragment.setSelection(selectedUsers);
-            }
-            // Load data, unless a query has already taken place.
-            friendPickerFragment.loadData(false);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-}
diff --git a/samples/GraphApiSample/.classpath b/samples/GraphApiSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/GraphApiSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/GraphApiSample/.project b/samples/GraphApiSample/.project
deleted file mode 100644
index ff735cf87..000000000
--- a/samples/GraphApiSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>GraphApiSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/GraphApiSample/AndroidManifest.xml b/samples/GraphApiSample/AndroidManifest.xml
deleted file mode 100644
index 3647ce9a0..000000000
--- a/samples/GraphApiSample/AndroidManifest.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.samples.graphapi"
-    android:versionCode="1"
-    android:versionName="1.0" >
-
-    <uses-sdk android:minSdkVersion="8" />
-    <uses-permission android:name="android.permission.INTERNET"/>
-
-    <application
-        android:icon="@drawable/icon"
-        android:label="@string/app_name" >
-        <activity
-            android:name=".GraphApiSampleActivity"
-            android:label="@string/app_name"
-            android:windowSoftInputMode="adjustResize">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <activity android:name="com.facebook.LoginActivity"
-                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
-                  android:label="@string/app_name" />
-    </application>
-
-</manifest>
diff --git a/samples/GraphApiSample/ant.properties b/samples/GraphApiSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/GraphApiSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/GraphApiSample/build.gradle b/samples/GraphApiSample/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/samples/GraphApiSample/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/samples/GraphApiSample/build.xml b/samples/GraphApiSample/build.xml
deleted file mode 100644
index b2456a58c..000000000
--- a/samples/GraphApiSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="GraphApiSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env" />
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME" />
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/samples/GraphApiSample/proguard-project.txt b/samples/GraphApiSample/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/samples/GraphApiSample/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/GraphApiSample/project.properties b/samples/GraphApiSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/GraphApiSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/GraphApiSample/res/drawable-hdpi/icon.png b/samples/GraphApiSample/res/drawable-hdpi/icon.png
deleted file mode 100644
index a888af1c6..000000000
Binary files a/samples/GraphApiSample/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/samples/GraphApiSample/res/drawable-mdpi/icon.png b/samples/GraphApiSample/res/drawable-mdpi/icon.png
deleted file mode 100644
index 2275c8571..000000000
Binary files a/samples/GraphApiSample/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/samples/GraphApiSample/res/drawable-xhdpi/icon.png b/samples/GraphApiSample/res/drawable-xhdpi/icon.png
deleted file mode 100644
index 31201f160..000000000
Binary files a/samples/GraphApiSample/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/samples/GraphApiSample/res/drawable/icon.png b/samples/GraphApiSample/res/drawable/icon.png
deleted file mode 100644
index 2275c8571..000000000
Binary files a/samples/GraphApiSample/res/drawable/icon.png and /dev/null differ
diff --git a/samples/GraphApiSample/res/layout/main.xml b/samples/GraphApiSample/res/layout/main.xml
deleted file mode 100644
index 8ebf7e229..000000000
--- a/samples/GraphApiSample/res/layout/main.xml
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:orientation="vertical" >
-
-    <EditText
-        android:id="@+id/editRequests"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:ems="10" >
-
-        <requestFocus />
-    </EditText>
-
-    <Button
-        android:id="@+id/buttonRequest"
-        android:layout_width="122dp"
-        android:layout_height="wrap_content"
-        android:text="@string/request" />
-
-    <TextView
-        android:id="@+id/textViewResults"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:textAppearance="?android:attr/textAppearanceLarge" />
-
-</LinearLayout>
diff --git a/samples/GraphApiSample/res/values/strings.xml b/samples/GraphApiSample/res/values/strings.xml
deleted file mode 100644
index 025d17499..000000000
--- a/samples/GraphApiSample/res/values/strings.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-
-    <string name="hello">Hello World, GraphApiSampleActivity!</string>
-    <string name="app_name">GraphApiSample</string>
-    <string name="request">Request</string>
-    <string name="instructions">Login to create a link to fetch account data</string>
-    <string name="logout">Log out</string>
-    <string name="login_failed_dialog_title">Login failed</string>
-    <string name="ok_button">OK</string>
-
-</resources>
diff --git a/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java b/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
deleted file mode 100644
index 444926c02..000000000
--- a/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.graphapi;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.TextView;
-import com.facebook.*;
-import com.facebook.Session.StatusCallback;
-import com.facebook.model.GraphObject;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class GraphApiSampleActivity extends Activity {
-    static final String APP_ID = "307234779396415";
-    static final String PENDING_REQUEST_BUNDLE_KEY = "com.facebook.samples.graphapi:PendingRequest";
-
-    Button buttonRequest;
-    EditText editRequests;
-    TextView textViewResults;
-    Session session;
-    boolean pendingRequest;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-        this.buttonRequest = (Button) findViewById(R.id.buttonRequest);
-        this.buttonRequest.setOnClickListener(new OnClickListener() {
-            public void onClick(View view) {
-                onClickRequest();
-            }
-        });
-        this.editRequests = (EditText) findViewById(R.id.editRequests);
-        this.textViewResults = (TextView) findViewById(R.id.textViewResults);
-
-        this.session = createSession();
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
-    }
-
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (this.session.onActivityResult(this, requestCode, resultCode, data) &&
-                pendingRequest &&
-                this.session.getState().isOpened()) {
-            sendRequests();
-        }
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
-        AppEventsLogger.activateApp(this, APP_ID);
-    }
-
-    @Override
-    protected void onRestoreInstanceState(Bundle savedInstanceState) {
-        super.onRestoreInstanceState(savedInstanceState);
-
-        pendingRequest = savedInstanceState.getBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        outState.putBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
-    }
-
-    private void onClickRequest() {
-        if (this.session.isOpened()) {
-            sendRequests();
-        } else {
-            StatusCallback callback = new StatusCallback() {
-                public void call(Session session, SessionState state, Exception exception) {
-                    if (exception != null) {
-                        new AlertDialog.Builder(GraphApiSampleActivity.this)
-                                .setTitle(R.string.login_failed_dialog_title)
-                                .setMessage(exception.getMessage())
-                                .setPositiveButton(R.string.ok_button, null)
-                                .show();
-                        GraphApiSampleActivity.this.session = createSession();
-                    }
-                }
-            };
-            pendingRequest = true;
-            this.session.openForRead(new Session.OpenRequest(this).setCallback(callback));
-        }
-    }
-
-    private void sendRequests() {
-        textViewResults.setText("");
-
-        String requestIdsText = editRequests.getText().toString();
-        String[] requestIds = requestIdsText.split(",");
-
-        List<Request> requests = new ArrayList<Request>();
-        for (final String requestId : requestIds) {
-            requests.add(new Request(session, requestId, null, null, new Request.Callback() {
-                public void onCompleted(Response response) {
-                    GraphObject graphObject = response.getGraphObject();
-                    FacebookRequestError error = response.getError();
-                    String s = textViewResults.getText().toString();
-                    if (graphObject != null) {
-                        if (graphObject.getProperty("id") != null) {
-                            s = s + String.format("%s: %s\n", graphObject.getProperty("id"), graphObject.getProperty(
-                                    "name"));
-                        } else {
-                            s = s + String.format("%s: <no such id>\n", requestId);
-                        }
-                    } else if (error != null) {
-                        s = s + String.format("Error: %s", error.getErrorMessage());
-                    }
-                    textViewResults.setText(s);
-                }
-            }));
-        }
-        pendingRequest = false;
-        Request.executeBatchAsync(requests);
-    }
-
-    private Session createSession() {
-        Session activeSession = Session.getActiveSession();
-        if (activeSession == null || activeSession.getState().isClosed()) {
-            activeSession = new Session.Builder(this).setApplicationId(APP_ID).build();
-            Session.setActiveSession(activeSession);
-        }
-        return activeSession;
-    }
-}
diff --git a/samples/HelloFacebookSample/.classpath b/samples/HelloFacebookSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/HelloFacebookSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/HelloFacebookSample/.project b/samples/HelloFacebookSample/.project
deleted file mode 100644
index d2609b030..000000000
--- a/samples/HelloFacebookSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>HelloFacebookSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
index 246d0de24..053b3593e 100644
--- a/samples/HelloFacebookSample/AndroidManifest.xml
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -1,9 +1,29 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.facebook.samples.hellofacebook"
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
+    <uses-sdk android:minSdkVersion="9"/>
     <uses-permission android:name="android.permission.INTERNET"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <application android:label="@string/app_name"
@@ -18,9 +38,20 @@
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name="com.facebook.LoginActivity"
+        <activity android:name="com.facebook.FacebookActivity"
+                  android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
                   android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+        <meta-data android:name="com.facebook.sdk.ApplicationName"
+                   android:value="@string/facebook_app_name" />
+        <provider android:authorities="com.facebook.app.FacebookContentProvider355198514515820"
+                  android:name="com.facebook.FacebookContentProvider"
+                  android:exported="true"/>
+        <receiver android:name="com.facebook.samples.hellofacebook.HelloFacebookBroadcastReceiver">
+            <intent-filter>
+                <action android:name="com.facebook.platform.AppCallResultBroadcast" />
+            </intent-filter>
+        </receiver>
     </application>
 </manifest>
diff --git a/samples/HelloFacebookSample/BUCK b/samples/HelloFacebookSample/BUCK
new file mode 100644
index 000000000..27198e91c
--- /dev/null
+++ b/samples/HelloFacebookSample/BUCK
@@ -0,0 +1,31 @@
+android_resource(
+  name = 'res',
+  res = 'res',
+  package = 'com.facebook',
+  deps = [
+    '//facebook:android-sdk',
+  ],
+)
+
+android_library(
+  name = 'lib',
+  srcs = glob(['src/**/*.java']),
+  deps = [
+    ':res',
+    '//facebook:android-sdk',
+    '//libs:android-support-v4',
+  ],
+)
+
+android_binary(
+  name = 'app',
+  manifest = 'AndroidManifest.xml',
+  target = 'android-16',
+  keystore = '//keystores:debug',
+  package_type = 'debug',
+  deps = [
+    ':lib',
+    '//facebook:android-sdk',
+    '//libs:android-support-v4',
+  ],
+)
diff --git a/samples/HelloFacebookSample/ant.properties b/samples/HelloFacebookSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/HelloFacebookSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/HelloFacebookSample/build.gradle b/samples/HelloFacebookSample/build.gradle
index a2cda0280..41125c44d 100644
--- a/samples/HelloFacebookSample/build.gradle
+++ b/samples/HelloFacebookSample/build.gradle
@@ -1,16 +1,20 @@
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':facebook')
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
diff --git a/samples/HelloFacebookSample/build.xml b/samples/HelloFacebookSample/build.xml
deleted file mode 100644
index 3c65e4a79..000000000
--- a/samples/HelloFacebookSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="HelloFacebookSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/HelloFacebookSample/project.properties b/samples/HelloFacebookSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/HelloFacebookSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/HelloFacebookSample/res/drawable-hdpi/icon.png b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png
index e603120e1..0a0d7cc73 100644
Binary files a/samples/HelloFacebookSample/res/drawable-hdpi/icon.png and b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-mdpi/icon.png b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png
index f2fc84fb6..b4507c0e7 100644
Binary files a/samples/HelloFacebookSample/res/drawable-mdpi/icon.png and b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png
index 143a69f21..6e8424602 100644
Binary files a/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png and b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable/icon.png b/samples/HelloFacebookSample/res/drawable/icon.png
index f2fc84fb6..b4507c0e7 100644
Binary files a/samples/HelloFacebookSample/res/drawable/icon.png and b/samples/HelloFacebookSample/res/drawable/icon.png differ
diff --git a/samples/HelloFacebookSample/res/layout/main.xml b/samples/HelloFacebookSample/res/layout/main.xml
index eec36fcb0..eadcdc7f0 100644
--- a/samples/HelloFacebookSample/res/layout/main.xml
+++ b/samples/HelloFacebookSample/res/layout/main.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
@@ -27,20 +31,21 @@
                   android:layout_height="fill_parent"
                   android:background="#FFF"
                   android:id="@+id/main_ui_container">
-        <com.facebook.widget.LoginButton
-                android:id="@+id/login_button"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_marginTop="5dp"
-                facebook:confirm_logout="false"
-                facebook:fetch_user_info="true"
-                />
+        <com.facebook.login.widget.LoginButton
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="5dp"
+            android:layout_gravity="center_horizontal"
+            facebook:com_facebook_confirm_logout="false"
+            facebook:com_facebook_tooltip_mode="never_display"
+            />
         <LinearLayout
                 android:layout_width="150dp"
                 android:layout_height="wrap_content"
                 android:layout_gravity="center_horizontal"
                 android:gravity="center_horizontal"
-                android:orientation="vertical">
+                android:orientation="vertical"
+            >
             <TextView
                     android:id="@+id/greeting"
                     android:layout_width="wrap_content"
@@ -49,13 +54,13 @@
                     android:layout_gravity="center"
                     android:textColor="#333"
                     android:textSize="18sp"/>
-            <com.facebook.widget.ProfilePictureView
+            <com.facebook.login.widget.ProfilePictureView
                     android:id="@+id/profilePicture"
                     android:layout_height="wrap_content"
                     android:layout_width="wrap_content"
                     android:gravity="center_horizontal"
                     android:layout_marginBottom="10dp"
-                    facebook:preset_size="normal"/>
+                    facebook:com_facebook_preset_size="normal"/>
             <Button
                     android:id="@+id/postStatusUpdateButton"
                     android:layout_width="fill_parent"
@@ -68,24 +73,9 @@
                     android:layout_height="wrap_content"
                     android:text="Post Photo"
                     />
-            <Button
-                    android:id="@+id/pickFriendsButton"
-                    android:layout_width="fill_parent"
-                    android:layout_height="wrap_content"
-                    android:text="Pick Some Friends"
-                    />
-            <Button
-                    android:id="@+id/pickPlaceButton"
-                    android:layout_width="fill_parent"
-                    android:layout_height="wrap_content"
-                    android:text="Pick Place"
-                    />
+
         </LinearLayout>
     </LinearLayout>
-    <FrameLayout
-            android:id="@+id/fragment_container"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"/>
 
 </LinearLayout>
 
diff --git a/samples/HelloFacebookSample/res/values/strings.xml b/samples/HelloFacebookSample/res/values/strings.xml
index ccacbf600..c199e5873 100644
--- a/samples/HelloFacebookSample/res/values/strings.xml
+++ b/samples/HelloFacebookSample/res/values/strings.xml
@@ -1,28 +1,33 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
     <string name="app_name">HelloFacebookSample</string>
+    <string name="facebook_app_name">HelloFBSample</string>
     <string name="cancelled">Cancelled</string>
     <string name="permission_not_granted">Unable to perform selected action because permissions were not granted.</string>
     <string name="ok">OK</string>
     <string name="hello_user">Hello %1$s!</string>
     <string name="success">Success</string>
-    <string name="successfully_posted_post">Successfully posted \'%1$s\'.\nPost ID: %2$s</string>
+    <string name="successfully_posted_post">Post ID: %1$s</string>
     <string name="error">Error</string>
     <string name="status_update">Updating status for %1$s at %2$s</string>
     <string name="photo_post">Photo Post</string>
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java
new file mode 100644
index 000000000..d3f926d9d
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookBroadcastReceiver.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.os.Bundle;
+import android.util.Log;
+import com.facebook.FacebookBroadcastReceiver;
+
+/**
+ * This is a simple example to demonstrate how an app could extend FacebookBroadcastReceiver to handle
+ * notifications that long-running operations such as photo uploads have finished.
+ */
+public class HelloFacebookBroadcastReceiver extends FacebookBroadcastReceiver {
+
+    @Override
+    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
+        // A real app could update UI or notify the user that their photo was uploaded.
+        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " succeeded."));
+    }
+
+    @Override
+    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
+        // A real app could update UI or notify the user that their photo was not uploaded.
+        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " failed."));
+    }
+}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
index bf374a95c..ac9c97e1b 100644
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.hellofacebook;
@@ -21,24 +25,32 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.location.Location;
+import android.net.Uri;
 import android.os.Bundle;
-import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.text.TextUtils;
 import android.util.Log;
 import android.view.View;
-import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.TextView;
-import android.widget.Toast;
-import com.facebook.*;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
-import com.facebook.widget.*;
 
-import java.util.*;
+import com.facebook.*;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.login.LoginManager;
+import com.facebook.login.LoginResult;
+import com.facebook.login.widget.ProfilePictureView;
+import com.facebook.share.ShareApi;
+import com.facebook.share.Sharer;
+import com.facebook.share.internal.ShareInternalUtility;
+import com.facebook.share.model.SharePhoto;
+import com.facebook.share.model.SharePhotoContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.widget.ShareDialog;
+
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
 
 public class HelloFacebookSampleActivity extends FragmentActivity {
 
@@ -50,53 +62,106 @@
         }
     };
 
-    private final String PENDING_ACTION_BUNDLE_KEY = "com.facebook.samples.hellofacebook:PendingAction";
+    private final String PENDING_ACTION_BUNDLE_KEY =
+            "com.facebook.samples.hellofacebook:PendingAction";
 
     private Button postStatusUpdateButton;
     private Button postPhotoButton;
-    private Button pickFriendsButton;
-    private Button pickPlaceButton;
-    private LoginButton loginButton;
     private ProfilePictureView profilePictureView;
     private TextView greeting;
     private PendingAction pendingAction = PendingAction.NONE;
-    private ViewGroup controlsContainer;
-    private GraphUser user;
-    private GraphPlace place;
-    private List<GraphUser> tags;
     private boolean canPresentShareDialog;
-
-    private enum PendingAction {
-        NONE,
-        POST_PHOTO,
-        POST_STATUS_UPDATE
-    }
-    private UiLifecycleHelper uiHelper;
-
-    private Session.StatusCallback callback = new Session.StatusCallback() {
+    private boolean canPresentShareDialogWithPhotos;
+    private CallbackManager callbackManager;
+    private ProfileTracker profileTracker;
+    private ShareDialog shareDialog;
+    private FacebookCallback<Sharer.Result> shareCallback = new FacebookCallback<Sharer.Result>() {
         @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            onSessionStateChange(session, state, exception);
+        public void onCancel() {
+            Log.d("HelloFacebook", "Canceled");
         }
-    };
 
-    private FacebookDialog.Callback dialogCallback = new FacebookDialog.Callback() {
         @Override
-        public void onError(FacebookDialog.PendingCall pendingCall, Exception error, Bundle data) {
+        public void onError(FacebookException error) {
             Log.d("HelloFacebook", String.format("Error: %s", error.toString()));
+            String title = getString(R.string.error);
+            String alertMessage = error.getMessage();
+            showResult(title, alertMessage);
         }
 
         @Override
-        public void onComplete(FacebookDialog.PendingCall pendingCall, Bundle data) {
+        public void onSuccess(Sharer.Result result) {
             Log.d("HelloFacebook", "Success!");
+            if (result.getPostId() != null) {
+                String title = getString(R.string.success);
+                String id = result.getPostId();
+                String alertMessage = getString(R.string.successfully_posted_post, id);
+                showResult(title, alertMessage);
+            }
+        }
+
+        private void showResult(String title, String alertMessage) {
+            new AlertDialog.Builder(HelloFacebookSampleActivity.this)
+                    .setTitle(title)
+                    .setMessage(alertMessage)
+                    .setPositiveButton(R.string.ok, null)
+                    .show();
         }
     };
 
+    private enum PendingAction {
+        NONE,
+        POST_PHOTO,
+        POST_STATUS_UPDATE
+    }
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        uiHelper = new UiLifecycleHelper(this, callback);
-        uiHelper.onCreate(savedInstanceState);
+        FacebookSdk.sdkInitialize(this.getApplicationContext());
+
+        callbackManager = CallbackManager.Factory.create();
+
+        LoginManager.getInstance().registerCallback(callbackManager,
+                new FacebookCallback<LoginResult>() {
+                    @Override
+                    public void onSuccess(LoginResult loginResult) {
+                        handlePendingAction();
+                        updateUI();
+                    }
+
+                    @Override
+                    public void onCancel() {
+                        if (pendingAction != PendingAction.NONE) {
+                            showAlert();
+                            pendingAction = PendingAction.NONE;
+                        }
+                        updateUI();
+                    }
+
+                    @Override
+                    public void onError(FacebookException exception) {
+                        if (pendingAction != PendingAction.NONE
+                                && exception instanceof FacebookAuthorizationException) {
+                            showAlert();
+                            pendingAction = PendingAction.NONE;
+                        }
+                        updateUI();
+                    }
+
+                    private void showAlert() {
+                        new AlertDialog.Builder(HelloFacebookSampleActivity.this)
+                                .setTitle(R.string.cancelled)
+                                .setMessage(R.string.permission_not_granted)
+                                .setPositiveButton(R.string.ok, null)
+                                .show();
+                    }
+                });
+
+        shareDialog = new ShareDialog(this);
+        shareDialog.registerCallback(
+                callbackManager,
+                shareCallback);
 
         if (savedInstanceState != null) {
             String name = savedInstanceState.getString(PENDING_ACTION_BUNDLE_KEY);
@@ -105,17 +170,15 @@ public void onCreate(Bundle savedInstanceState) {
 
         setContentView(R.layout.main);
 
-        loginButton = (LoginButton) findViewById(R.id.login_button);
-        loginButton.setUserInfoChangedCallback(new LoginButton.UserInfoChangedCallback() {
+        profileTracker = new ProfileTracker() {
             @Override
-            public void onUserInfoFetched(GraphUser user) {
-                HelloFacebookSampleActivity.this.user = user;
+            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                 updateUI();
-                // It's possible that we were waiting for this.user to be populated in order to post a
-                // status update.
+                // It's possible that we were waiting for Profile to be populated in order to
+                // post a status update.
                 handlePendingAction();
             }
-        });
+        };
 
         profilePictureView = (ProfilePictureView) findViewById(R.id.profilePicture);
         greeting = (TextView) findViewById(R.id.greeting);
@@ -134,58 +197,22 @@ public void onClick(View view) {
             }
         });
 
-        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
-        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickPickFriends();
-            }
-        });
+        // Can we present the share dialog for regular links?
+        canPresentShareDialog = ShareDialog.canShow(
+                ShareLinkContent.class);
 
-        pickPlaceButton = (Button) findViewById(R.id.pickPlaceButton);
-        pickPlaceButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickPickPlace();
-            }
-        });
-
-        controlsContainer = (ViewGroup) findViewById(R.id.main_ui_container);
-
-        final FragmentManager fm = getSupportFragmentManager();
-        Fragment fragment = fm.findFragmentById(R.id.fragment_container);
-        if (fragment != null) {
-            // If we're being re-created and have a fragment, we need to a) hide the main UI controls and
-            // b) hook up its listeners again.
-            controlsContainer.setVisibility(View.GONE);
-            if (fragment instanceof FriendPickerFragment) {
-                setFriendPickerListeners((FriendPickerFragment) fragment);
-            } else if (fragment instanceof PlacePickerFragment) {
-                setPlacePickerListeners((PlacePickerFragment) fragment);
-            }
-        }
-
-        // Listen for changes in the back stack so we know if a fragment got popped off because the user
-        // clicked the back button.
-        fm.addOnBackStackChangedListener(new FragmentManager.OnBackStackChangedListener() {
-            @Override
-            public void onBackStackChanged() {
-                if (fm.getBackStackEntryCount() == 0) {
-                    // We need to re-show our UI.
-                    controlsContainer.setVisibility(View.VISIBLE);
-                }
-            }
-        });
-
-        canPresentShareDialog = FacebookDialog.canPresentShareDialog(this,
-                FacebookDialog.ShareDialogFeature.SHARE_DIALOG);
+        // Can we present the share dialog for photos?
+        canPresentShareDialogWithPhotos = ShareDialog.canShow(
+                SharePhotoContent.class);
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        uiHelper.onResume();
 
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
+        // Call the 'activateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onResume methods of the primary Activities that an app may be
+        // launched into.
         AppEventsLogger.activateApp(this);
 
         updateUI();
@@ -194,7 +221,6 @@ protected void onResume() {
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-        uiHelper.onSaveInstanceState(outState);
 
         outState.putString(PENDING_ACTION_BUNDLE_KEY, pendingAction.name());
     }
@@ -202,56 +228,41 @@ protected void onSaveInstanceState(Bundle outState) {
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
-        uiHelper.onActivityResult(requestCode, resultCode, data, dialogCallback);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        uiHelper.onPause();
+
+        // Call the 'deactivateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onPause methods of the primary Activities that an app may be
+        // launched into.
+        AppEventsLogger.deactivateApp(this);
     }
 
     @Override
-    public void onDestroy() {
+    protected void onDestroy() {
         super.onDestroy();
-        uiHelper.onDestroy();
-    }
-
-    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
-        if (pendingAction != PendingAction.NONE &&
-                (exception instanceof FacebookOperationCanceledException ||
-                exception instanceof FacebookAuthorizationException)) {
-                new AlertDialog.Builder(HelloFacebookSampleActivity.this)
-                    .setTitle(R.string.cancelled)
-                    .setMessage(R.string.permission_not_granted)
-                    .setPositiveButton(R.string.ok, null)
-                    .show();
-            pendingAction = PendingAction.NONE;
-        } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
-            handlePendingAction();
-        }
-        updateUI();
+        profileTracker.stopTracking();
     }
 
     private void updateUI() {
-        Session session = Session.getActiveSession();
-        boolean enableButtons = (session != null && session.isOpened());
+        boolean enableButtons = AccessToken.getCurrentAccessToken() != null;
 
         postStatusUpdateButton.setEnabled(enableButtons || canPresentShareDialog);
-        postPhotoButton.setEnabled(enableButtons);
-        pickFriendsButton.setEnabled(enableButtons);
-        pickPlaceButton.setEnabled(enableButtons);
+        postPhotoButton.setEnabled(enableButtons || canPresentShareDialogWithPhotos);
 
-        if (enableButtons && user != null) {
-            profilePictureView.setProfileId(user.getId());
-            greeting.setText(getString(R.string.hello_user, user.getFirstName()));
+        Profile profile = Profile.getCurrentProfile();
+        if (enableButtons && profile != null) {
+            profilePictureView.setProfileId(profile.getId());
+            greeting.setText(getString(R.string.hello_user, profile.getFirstName()));
         } else {
             profilePictureView.setProfileId(null);
             greeting.setText(null);
         }
     }
 
-    @SuppressWarnings("incomplete-switch")
     private void handlePendingAction() {
         PendingAction previouslyPendingAction = pendingAction;
         // These actions may re-set pendingAction if they are still pending, but we assume they
@@ -259,6 +270,8 @@ private void handlePendingAction() {
         pendingAction = PendingAction.NONE;
 
         switch (previouslyPendingAction) {
+            case NONE:
+                break;
             case POST_PHOTO:
                 postPhoto();
                 break;
@@ -268,214 +281,71 @@ private void handlePendingAction() {
         }
     }
 
-    private interface GraphObjectWithId extends GraphObject {
-        String getId();
-    }
-
-    private void showPublishResult(String message, GraphObject result, FacebookRequestError error) {
-        String title = null;
-        String alertMessage = null;
-        if (error == null) {
-            title = getString(R.string.success);
-            String id = result.cast(GraphObjectWithId.class).getId();
-            alertMessage = getString(R.string.successfully_posted_post, message, id);
-        } else {
-            title = getString(R.string.error);
-            alertMessage = error.getErrorMessage();
-        }
-
-        new AlertDialog.Builder(this)
-                .setTitle(title)
-                .setMessage(alertMessage)
-                .setPositiveButton(R.string.ok, null)
-                .show();
-    }
-
     private void onClickPostStatusUpdate() {
         performPublish(PendingAction.POST_STATUS_UPDATE, canPresentShareDialog);
     }
 
-    private FacebookDialog.ShareDialogBuilder createShareDialogBuilder() {
-        return new FacebookDialog.ShareDialogBuilder(this)
-                .setName("Hello Facebook")
-                .setDescription("The 'Hello Facebook' sample application showcases simple Facebook integration")
-                .setLink("http://developers.facebook.com/android");
-    }
-
     private void postStatusUpdate() {
+        Profile profile = Profile.getCurrentProfile();
+        ShareLinkContent linkContent = new ShareLinkContent.Builder()
+                .setContentTitle("Hello Facebook")
+                .setContentDescription(
+                        "The 'Hello Facebook' sample  showcases simple Facebook integration")
+                .setContentUrl(Uri.parse("http://developers.facebook.com/docs/android"))
+                .build();
         if (canPresentShareDialog) {
-            FacebookDialog shareDialog = createShareDialogBuilder().build();
-            uiHelper.trackPendingDialogCall(shareDialog.present());
-        } else if (user != null && hasPublishPermission()) {
-            final String message = getString(R.string.status_update, user.getFirstName(), (new Date().toString()));
-            Request request = Request
-                    .newStatusUpdateRequest(Session.getActiveSession(), message, place, tags, new Request.Callback() {
-                        @Override
-                        public void onCompleted(Response response) {
-                            showPublishResult(message, response.getGraphObject(), response.getError());
-                        }
-                    });
-            request.executeAsync();
+            shareDialog.show(linkContent);
+        } else if (profile != null && hasPublishPermission()) {
+            ShareApi.share(linkContent, shareCallback);
         } else {
             pendingAction = PendingAction.POST_STATUS_UPDATE;
         }
     }
 
     private void onClickPostPhoto() {
-        performPublish(PendingAction.POST_PHOTO, false);
+        performPublish(PendingAction.POST_PHOTO, canPresentShareDialogWithPhotos);
     }
 
     private void postPhoto() {
-        if (hasPublishPermission()) {
-            Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
-            Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
-                @Override
-                public void onCompleted(Response response) {
-                    showPublishResult(getString(R.string.photo_post), response.getGraphObject(), response.getError());
-                }
-            });
-            request.executeAsync();
+        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+        SharePhoto sharePhoto = new SharePhoto.Builder().setBitmap(image).build();
+        ArrayList<SharePhoto> photos = new ArrayList<>();
+        photos.add(sharePhoto);
+
+        SharePhotoContent sharePhotoContent =
+                new SharePhotoContent.Builder().setPhotos(photos).build();
+        if (canPresentShareDialogWithPhotos) {
+            shareDialog.show(sharePhotoContent);
+        } else if (hasPublishPermission()) {
+            ShareApi.share(sharePhotoContent, shareCallback);
         } else {
             pendingAction = PendingAction.POST_PHOTO;
         }
     }
 
-    private void showPickerFragment(PickerFragment<?> fragment) {
-        fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(PickerFragment<?> pickerFragment, FacebookException error) {
-                String text = getString(R.string.exception, error.getMessage());
-                Toast toast = Toast.makeText(HelloFacebookSampleActivity.this, text, Toast.LENGTH_SHORT);
-                toast.show();
-            }
-        });
-
-        FragmentManager fm = getSupportFragmentManager();
-        fm.beginTransaction()
-                .replace(R.id.fragment_container, fragment)
-                .addToBackStack(null)
-                .commit();
-
-        controlsContainer.setVisibility(View.GONE);
-
-        // We want the fragment fully created so we can use it immediately.
-        fm.executePendingTransactions();
-
-        fragment.loadData(false);
-    }
-
-    private void onClickPickFriends() {
-        final FriendPickerFragment fragment = new FriendPickerFragment();
-
-        setFriendPickerListeners(fragment);
-
-        showPickerFragment(fragment);
-    }
-
-    private void setFriendPickerListeners(final FriendPickerFragment fragment) {
-        fragment.setOnDoneButtonClickedListener(new FriendPickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
-                onFriendPickerDone(fragment);
-            }
-        });
-    }
-
-    private void onFriendPickerDone(FriendPickerFragment fragment) {
-        FragmentManager fm = getSupportFragmentManager();
-        fm.popBackStack();
-
-        String results = "";
-
-        List<GraphUser> selection = fragment.getSelection();
-        tags = selection;
-        if (selection != null && selection.size() > 0) {
-            ArrayList<String> names = new ArrayList<String>();
-            for (GraphUser user : selection) {
-                names.add(user.getName());
-            }
-            results = TextUtils.join(", ", names);
-        } else {
-            results = getString(R.string.no_friends_selected);
-        }
-
-        showAlert(getString(R.string.you_picked), results);
-    }
-
-    private void onPlacePickerDone(PlacePickerFragment fragment) {
-        FragmentManager fm = getSupportFragmentManager();
-        fm.popBackStack();
-
-        String result = "";
-
-        GraphPlace selection = fragment.getSelection();
-        if (selection != null) {
-            result = selection.getName();
-        } else {
-            result = getString(R.string.no_place_selected);
-        }
-
-        place = selection;
-
-        showAlert(getString(R.string.you_picked), result);
-    }
-
-    private void onClickPickPlace() {
-        final PlacePickerFragment fragment = new PlacePickerFragment();
-        fragment.setLocation(SEATTLE_LOCATION);
-        fragment.setTitleText(getString(R.string.pick_seattle_place));
-
-        setPlacePickerListeners(fragment);
-
-        showPickerFragment(fragment);
-    }
-
-    private void setPlacePickerListeners(final PlacePickerFragment fragment) {
-        fragment.setOnDoneButtonClickedListener(new PlacePickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
-                onPlacePickerDone(fragment);
-            }
-        });
-        fragment.setOnSelectionChangedListener(new PlacePickerFragment.OnSelectionChangedListener() {
-            @Override
-            public void onSelectionChanged(PickerFragment<?> pickerFragment) {
-                if (fragment.getSelection() != null) {
-                    onPlacePickerDone(fragment);
-                }
-            }
-        });
-    }
-
-    private void showAlert(String title, String message) {
-        new AlertDialog.Builder(this)
-                .setTitle(title)
-                .setMessage(message)
-                .setPositiveButton(R.string.ok, null)
-                .show();
-    }
-
     private boolean hasPublishPermission() {
-        Session session = Session.getActiveSession();
-        return session != null && session.getPermissions().contains("publish_actions");
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        return accessToken != null && accessToken.getPermissions().contains("publish_actions");
     }
 
-    private void performPublish(PendingAction action, boolean allowNoSession) {
-        Session session = Session.getActiveSession();
-        if (session != null) {
+    private void performPublish(PendingAction action, boolean allowNoToken) {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
             pendingAction = action;
             if (hasPublishPermission()) {
                 // We can do the action right away.
                 handlePendingAction();
                 return;
-            } else if (session.isOpened()) {
+            } else {
                 // We need to get new permissions, then complete the action when we get called back.
-                session.requestNewPublishPermissions(new Session.NewPermissionsRequest(this, PERMISSION));
+                LoginManager.getInstance().logInWithPublishPermissions(
+                        this,
+                        Arrays.asList(PERMISSION));
                 return;
             }
         }
 
-        if (allowNoSession) {
+        if (allowNoToken) {
             pendingAction = action;
             handlePendingAction();
         }
diff --git a/samples/MessengerSendSample/build.gradle b/samples/MessengerSendSample/build.gradle
new file mode 100644
index 000000000..20d919b53
--- /dev/null
+++ b/samples/MessengerSendSample/build.gradle
@@ -0,0 +1,45 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
+
+    defaultConfig {
+        applicationId "com.facebook.samples.messenger.send"
+        minSdkVersion 14
+        targetSdkVersion 21
+        versionCode 1
+        versionName "0.1"
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'src/main/AndroidManifest.xml'
+            java.srcDirs = ['src/main/java']
+        }
+    }
+
+    packagingOptions {
+        exclude 'LICENSE'
+        exclude 'LICENSE.txt'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/LICENSE.txt'
+        exclude 'META-INF/NOTICE'
+        exclude 'META-INF/NOTICE.txt'    
+    }
+
+    signingConfigs {
+        debug {
+            storeFile file("../../keystores/debug.keystore")
+            storePassword "android"
+            keyAlias "androiddebugkey"
+            keyPassword "android"
+        }
+    }
+}
+
+dependencies {
+    compile project(':facebook')
+    compile('com.android.support:appcompat-v7:21.0.3')
+    compile 'com.parse.bolts:bolts-android:1.1.4'
+}
diff --git a/samples/MessengerSendSample/src/main/AndroidManifest.xml b/samples/MessengerSendSample/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..06e34e0ef
--- /dev/null
+++ b/samples/MessengerSendSample/src/main/AndroidManifest.xml
@@ -0,0 +1,62 @@
+<?xml version='1.0' encoding='utf-8'?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<manifest xmlns:android='http://schemas.android.com/apk/res/android'
+          package='com.facebook.samples.messenger.send'
+          >
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+  <uses-permission android:name="android.permission.INTERNET" />
+
+  <application
+      android:name='MessengerSendSampleApplication'
+      android:icon='@null'
+      android:label='@string/app_name'
+      android:theme='@style/Theme.AppCompat.NoActionBar'>
+
+    <meta-data
+        android:name="com.facebook.sdk.ApplicationId"
+        android:value="@string/facebook_app_id"/>
+
+    <activity
+        android:name='.MainActivity'>
+      <intent-filter>
+        <action android:name='android.intent.action.MAIN' />
+        <category android:name='android.intent.category.LAUNCHER' />
+      </intent-filter>
+
+      <!-- Intent filter used for Messenger protocol version 20150311 -->
+      <intent-filter>
+        <action android:name="android.intent.action.PICK" />
+        <category android:name="android.intent.category.DEFAULT"/>
+        <category android:name="com.facebook.orca.category.PLATFORM_THREAD_20150311"/>
+      </intent-filter>
+
+      <!-- Intent filter used for Messenger protocol version 20150314 -->
+      <intent-filter>
+        <action android:name="android.intent.action.PICK" />
+        <category android:name="android.intent.category.DEFAULT"/>
+        <category android:name="com.facebook.orca.category.PLATFORM_THREAD_20150314"/>
+      </intent-filter>
+
+    </activity>
+
+  </application>
+</manifest>
diff --git a/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MainActivity.java b/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MainActivity.java
new file mode 100644
index 000000000..40192b5e5
--- /dev/null
+++ b/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MainActivity.java
@@ -0,0 +1,104 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.messenger.send;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v7.widget.Toolbar;
+import android.view.View;
+
+import com.facebook.messenger.MessengerThreadParams;
+import com.facebook.messenger.MessengerUtils;
+import com.facebook.messenger.ShareToMessengerParams;
+
+/**
+ * Main Activity for sample.
+ */
+public class MainActivity extends Activity {
+
+  // This is the request code that the SDK uses for startActivityForResult. See the code below
+  // that references it. Messenger currently doesn't return any data back to the calling
+  // application.
+  private static final int REQUEST_CODE_SHARE_TO_MESSENGER = 1;
+
+  private Toolbar mToolbar;
+  private View mMessengerButton;
+  private MessengerThreadParams mThreadParams;
+  private boolean mPicking;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    setContentView(R.layout.main_activity);
+    mToolbar = (Toolbar) findViewById(R.id.toolbar);
+    mMessengerButton = findViewById(R.id.messenger_send_button);
+
+    mToolbar.setTitle(R.string.app_name);
+
+    // If we received Intent.ACTION_PICK from Messenger, we were launched from a composer shortcut
+    // or the reply flow.
+    Intent intent = getIntent();
+    if (Intent.ACTION_PICK.equals(intent.getAction())) {
+      mThreadParams = MessengerUtils.getMessengerThreadParamsForIntent(intent);
+      mPicking = true;
+
+      // Note, if mThreadParams is non-null, it means the activity was launched from Messenger.
+      // It will contain the metadata associated with the original content, if there was content.
+    }
+
+    mMessengerButton.setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        onMessengerButtonClicked();
+      }
+    });
+  }
+
+  private void onMessengerButtonClicked() {
+    // The URI can reference a file://, content://, or android.resource. Here we use
+    // android.resource for sample purposes.
+    Uri uri =
+        Uri.parse("android.resource://com.facebook.samples.messenger.send/" + R.drawable.tree);
+
+    // Create the parameters for what we want to send to Messenger.
+    ShareToMessengerParams shareToMessengerParams =
+        ShareToMessengerParams.newBuilder(uri, "image/jpeg")
+            .setMetaData("{ \"image\" : \"tree\" }")
+            .build();
+
+    if (mPicking) {
+      // If we were launched from Messenger, we call MessengerUtils.finishShareToMessenger to return
+      // the content to Messenger.
+      MessengerUtils.finishShareToMessenger(this, shareToMessengerParams);
+    } else {
+      // Otherwise, we were launched directly (for example, user clicked the launcher icon). We
+      // initiate the broadcast flow in Messenger. If Messenger is not installed or Messenger needs
+      // to be upgraded, this will direct the user to the play store.
+      MessengerUtils.shareToMessenger(
+          this,
+          REQUEST_CODE_SHARE_TO_MESSENGER,
+          shareToMessengerParams);
+    }
+  }
+}
diff --git a/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MessengerSendSampleApplication.java b/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MessengerSendSampleApplication.java
new file mode 100644
index 000000000..ce475fdd1
--- /dev/null
+++ b/samples/MessengerSendSample/src/main/java/com/facebook/samples/messenger/send/MessengerSendSampleApplication.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.messenger.send;
+
+import android.app.Application;
+
+import com.facebook.FacebookSdk;
+
+/**
+ * Application object for sample app.
+ */
+public class MessengerSendSampleApplication extends Application {
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    FacebookSdk.sdkInitialize(this);
+  }
+}
diff --git a/samples/MessengerSendSample/src/main/res/drawable-xhdpi/tree.jpg b/samples/MessengerSendSample/src/main/res/drawable-xhdpi/tree.jpg
new file mode 100644
index 000000000..a02aec467
Binary files /dev/null and b/samples/MessengerSendSample/src/main/res/drawable-xhdpi/tree.jpg differ
diff --git a/samples/MessengerSendSample/src/main/res/layout/main_activity.xml b/samples/MessengerSendSample/src/main/res/layout/main_activity.xml
new file mode 100644
index 000000000..6ce6ea440
--- /dev/null
+++ b/samples/MessengerSendSample/src/main/res/layout/main_activity.xml
@@ -0,0 +1,54 @@
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:background="#fff"
+    >
+
+  <android.support.v7.widget.Toolbar
+      android:id="@+id/toolbar"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:minHeight="?attr/actionBarSize"
+      android:background="?attr/colorPrimary"
+      />
+
+
+  <ImageView
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      android:src="@drawable/tree"
+      android:scaleType="fitCenter"
+      />
+
+  <include
+      layout="@layout/messenger_button_send_blue_large"
+      android:layout_width="match_parent"
+      android:layout_height="40dp"
+      android:layout_margin="10dp"
+      />
+
+</LinearLayout>
diff --git a/samples/MessengerSendSample/src/main/res/values/strings.xml b/samples/MessengerSendSample/src/main/res/values/strings.xml
new file mode 100644
index 000000000..8fef5a16f
--- /dev/null
+++ b/samples/MessengerSendSample/src/main/res/values/strings.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+  <string name='app_name'>Messenger SDK Sample</string>
+  <string name="facebook_app_id">434629220047124</string>
+</resources>
diff --git a/samples/PlacePickerSample/.classpath b/samples/PlacePickerSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/PlacePickerSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/PlacePickerSample/.project b/samples/PlacePickerSample/.project
deleted file mode 100644
index 06b88d35e..000000000
--- a/samples/PlacePickerSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>PlacePickerSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/PlacePickerSample/AndroidManifest.xml b/samples/PlacePickerSample/AndroidManifest.xml
deleted file mode 100644
index b0697ff65..000000000
--- a/samples/PlacePickerSample/AndroidManifest.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.facebook.samples.placepicker"
-          android:versionCode="1"
-          android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
-    <uses-permission android:name="android.permission.INTERNET"/>
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-    <application android:label="@string/app_name"
-                 android:icon="@drawable/icon"
-                 android:theme="@android:style/Theme.Black"
-                 android:name=".PlacePickerApplication"
-            >
-        <activity android:name="PlacePickerSampleActivity"
-                  android:label="@string/app_name"
-                  android:windowSoftInputMode="adjustResize">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
-            </intent-filter>
-        </activity>
-        <activity android:name="PickPlaceActivity"
-                  android:label="Pick Place">
-        </activity>
-        <activity android:name="com.facebook.LoginActivity"
-                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
-                  android:label="@string/app_name" />
-        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
-    </application>
-</manifest> 
diff --git a/samples/PlacePickerSample/ant.properties b/samples/PlacePickerSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/PlacePickerSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/PlacePickerSample/build.gradle b/samples/PlacePickerSample/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/samples/PlacePickerSample/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/samples/PlacePickerSample/build.xml b/samples/PlacePickerSample/build.xml
deleted file mode 100644
index a80f395cd..000000000
--- a/samples/PlacePickerSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="PlacePickerSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/PlacePickerSample/proguard-project.txt b/samples/PlacePickerSample/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/samples/PlacePickerSample/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/PlacePickerSample/project.properties b/samples/PlacePickerSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/PlacePickerSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/PlacePickerSample/res/drawable-hdpi/icon.png b/samples/PlacePickerSample/res/drawable-hdpi/icon.png
deleted file mode 100644
index 4059334b5..000000000
Binary files a/samples/PlacePickerSample/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/samples/PlacePickerSample/res/drawable-mdpi/icon.png b/samples/PlacePickerSample/res/drawable-mdpi/icon.png
deleted file mode 100644
index 1fa3834d0..000000000
Binary files a/samples/PlacePickerSample/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/samples/PlacePickerSample/res/drawable-xhdpi/icon.png b/samples/PlacePickerSample/res/drawable-xhdpi/icon.png
deleted file mode 100644
index 2b3083d44..000000000
Binary files a/samples/PlacePickerSample/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/samples/PlacePickerSample/res/drawable/icon.png b/samples/PlacePickerSample/res/drawable/icon.png
deleted file mode 100644
index 1fa3834d0..000000000
Binary files a/samples/PlacePickerSample/res/drawable/icon.png and /dev/null differ
diff --git a/samples/PlacePickerSample/res/layout/main.xml b/samples/PlacePickerSample/res/layout/main.xml
deleted file mode 100644
index a6a270f91..000000000
--- a/samples/PlacePickerSample/res/layout/main.xml
+++ /dev/null
@@ -1,56 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <LinearLayout android:layout_width="fill_parent"
-                  android:layout_height="wrap_content"
-                  android:orientation="horizontal"
-            >
-        <Button
-                android:id="@+id/seattleButton"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="Seattle"
-                android:layout_weight="1"
-                />
-        <Button
-                android:id="@+id/sanFranciscoButton"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="San Francisco"
-                android:layout_weight="1"
-                />
-        <Button
-                android:id="@+id/gpsButton"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="GPS"
-                android:layout_weight="1"
-                />
-    </LinearLayout>
-    <TextView
-            android:id="@+id/resultsTextView"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:textColor="#FFFFFF"
-            />
-</LinearLayout>
-
diff --git a/samples/PlacePickerSample/res/layout/pick_place_activity.xml b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
deleted file mode 100644
index 357bf5a99..000000000
--- a/samples/PlacePickerSample/res/layout/pick_place_activity.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <fragment
-            android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.widget.PlacePickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="true"
-            app:show_title_bar="true"
-            app:show_search_box="true"
-            />
-</LinearLayout>
-
diff --git a/samples/PlacePickerSample/res/values/strings.xml b/samples/PlacePickerSample/res/values/strings.xml
deleted file mode 100644
index 8cb17be6b..000000000
--- a/samples/PlacePickerSample/res/values/strings.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_name">PlacePickerSample</string>
-    <string name="app_id">378281678861098</string>
-    <string name="exception">Exception: %1$s</string>
-    <string name="ok_button">OK</string>
-    <string name="no_location">Could not obtain your current location.</string>
-</resources>
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
deleted file mode 100644
index 4e1f2ed18..000000000
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.placepicker;
-
-import android.content.Intent;
-import android.location.Location;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.widget.Toast;
-import com.facebook.FacebookException;
-import com.facebook.widget.PickerFragment;
-import com.facebook.widget.PlacePickerFragment;
-
-// This class provides an example of an Activity that uses PlacePickerFragment to display a list of
-// the places. It takes a layout-based approach to creating the PlacePickerFragment with the
-// desired parameters -- see PickFriendActivity in the FriendPickerSample project for an example of an
-// Activity creating a fragment (in this case a FriendPickerFragment) programmatically rather than
-// via XML layout.
-public class PickPlaceActivity extends FragmentActivity {
-    PlacePickerFragment placePickerFragment;
-
-    // A helper to simplify life for callers who want to populate a Bundle with the necessary
-    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
-    // are simple, so we just populate what we want to pass to the PlacePickerFragment.
-    public static void populateParameters(Intent intent, Location location, String searchText) {
-        intent.putExtra(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
-        intent.putExtra(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, searchText);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.pick_place_activity);
-
-        FragmentManager fm = getSupportFragmentManager();
-        placePickerFragment = (PlacePickerFragment) fm.findFragmentById(R.id.place_picker_fragment);
-        if (savedInstanceState == null) {
-            // If this is the first time we have created the fragment, update its properties based on
-            // any parameters we received via our Intent.
-            placePickerFragment.setSettingsFromBundle(getIntent().getExtras());
-        }
-
-        placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(PickerFragment<?> fragment, FacebookException error) {
-                PickPlaceActivity.this.onError(error);
-            }
-        });
-
-        // We finish the activity when either the Done button is pressed or when a place is
-        // selected (since only a single place can be selected).
-        placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
-            @Override
-            public void onSelectionChanged(PickerFragment<?> fragment) {
-                if (placePickerFragment.getSelection() != null) {
-                    finishActivity();
-                }
-            }
-        });
-        placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked(PickerFragment<?> fragment) {
-                finishActivity();
-            }
-        });
-    }
-
-    private void finishActivity() {
-        // We just store our selection in the Application for other activities to look at.
-        PlacePickerApplication application = (PlacePickerApplication) getApplication();
-        application.setSelectedPlace(placePickerFragment.getSelection());
-
-        setResult(RESULT_OK, null);
-        finish();
-    }
-
-    private void onError(Exception error) {
-        String text = getString(R.string.exception, error.getMessage());
-        Toast toast = Toast.makeText(this, text, Toast.LENGTH_SHORT);
-        toast.show();
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        try {
-            // Load data, unless a query has already taken place.
-            placePickerFragment.loadData(false);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
deleted file mode 100644
index bf3d3514a..000000000
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.placepicker;
-
-import android.app.Application;
-import com.facebook.model.GraphPlace;
-
-// We use a custom Application class to store our minimal state data (which users have been selected).
-// A real-world application will likely require a more robust data model.
-public class PlacePickerApplication extends Application {
-    public GraphPlace getSelectedPlace() {
-        return selectedPlace;
-    }
-
-    public void setSelectedPlace(GraphPlace selectedPlace) {
-        this.selectedPlace = selectedPlace;
-    }
-
-    private GraphPlace selectedPlace;
-
-}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
deleted file mode 100644
index ce8008f8b..000000000
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.placepicker;
-
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.Intent;
-import android.location.Criteria;
-import android.location.Location;
-import android.location.LocationListener;
-import android.location.LocationManager;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.view.View;
-import android.widget.Button;
-import android.widget.TextView;
-import com.facebook.AppEventsLogger;
-import com.facebook.SessionState;
-import com.facebook.UiLifecycleHelper;
-import com.facebook.model.GraphLocation;
-import com.facebook.model.GraphPlace;
-import com.facebook.Session;
-
-public class PlacePickerSampleActivity extends FragmentActivity implements LocationListener {
-    private static final int PLACE_ACTIVITY = 1;
-    private static final Location SEATTLE_LOCATION = new Location("") {
-        {
-            setLatitude(47.6097);
-            setLongitude(-122.3331);
-        }
-    };
-    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {
-        {
-            setLatitude(37.7750);
-            setLongitude(-122.4183);
-        }
-    };
-    private static final Location PARIS_LOCATION = new Location("") {
-        {
-            setLatitude(48.857875);
-            setLongitude(2.294635);
-        }
-    };
-
-    private TextView resultsTextView;
-    private LocationManager locationManager;
-    private Location lastKnownLocation;
-    private UiLifecycleHelper lifecycleHelper;
-    private Location pickPlaceForLocationWhenSessionOpened = null;
-
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
-        Button button = (Button) findViewById(R.id.seattleButton);
-        button.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickSeattle();
-            }
-        });
-
-        button = (Button) findViewById(R.id.sanFranciscoButton);
-        button.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickSanFrancisco();
-            }
-        });
-
-        button = (Button) findViewById(R.id.gpsButton);
-        button.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                onClickGPS();
-            }
-        });
-
-        lifecycleHelper = new UiLifecycleHelper(this, new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                onSessionStateChanged(session, state, exception);
-            }
-        });
-        lifecycleHelper.onCreate(savedInstanceState);
-
-        ensureOpenSession();
-
-        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
-    }
-
-    private boolean ensureOpenSession() {
-        if (Session.getActiveSession() == null ||
-                !Session.getActiveSession().isOpened()) {
-            Session.openActiveSession(this, true, new Session.StatusCallback() {
-                @Override
-                public void call(Session session, SessionState state, Exception exception) {
-                    onSessionStateChanged(session, state, exception);
-                }
-            });
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-
-        // Update the display every time we are started (this will be "no place selected" on first
-        // run, or possibly details of a place if the activity is being re-created).
-        displaySelectedPlace(RESULT_OK);
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        lifecycleHelper.onDestroy();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        lifecycleHelper.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        lifecycleHelper.onResume();
-
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
-        AppEventsLogger.activateApp(this);
-    }
-
-    private void onError(Exception exception) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(exception.getMessage()).setPositiveButton("OK", null);
-        builder.show();
-    }
-
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        lifecycleHelper.onActivityResult(requestCode, resultCode, data);
-
-        switch (requestCode) {
-            case PLACE_ACTIVITY:
-                displaySelectedPlace(resultCode);
-                break;
-            default:
-                break;
-        }
-    }
-
-    private void onSessionStateChanged(Session session, SessionState state, Exception exception) {
-        if (pickPlaceForLocationWhenSessionOpened != null && state.isOpened()) {
-            Location location = pickPlaceForLocationWhenSessionOpened;
-            pickPlaceForLocationWhenSessionOpened = null;
-            startPickPlaceActivity(location);
-        }
-    }
-
-    private void displaySelectedPlace(int resultCode) {
-        String results = "";
-        PlacePickerApplication application = (PlacePickerApplication) getApplication();
-
-        GraphPlace selection = application.getSelectedPlace();
-        if (selection != null) {
-            GraphLocation location = selection.getLocation();
-
-            results = String.format("Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s",
-                    selection.getName(), selection.getCategory(),
-                    location.getLatitude(), location.getLongitude(),
-                    location.getStreet(), location.getCity(), location.getState(), location.getZip(),
-                    location.getCountry());
-        } else {
-            results = "<No place selected>";
-        }
-
-        resultsTextView.setText(results);
-    }
-
-    public void onLocationChanged(Location location) {
-        lastKnownLocation = location;
-    }
-
-    @Override
-    public void onStatusChanged(String provider, int status, Bundle extras) {
-    }
-
-    @Override
-    public void onProviderEnabled(String provider) {
-    }
-
-    @Override
-    public void onProviderDisabled(String provider) {
-    }
-
-    private void startPickPlaceActivity(Location location) {
-        if (ensureOpenSession()) {
-            PlacePickerApplication application = (PlacePickerApplication) getApplication();
-            application.setSelectedPlace(null);
-
-            Intent intent = new Intent(this, PickPlaceActivity.class);
-            PickPlaceActivity.populateParameters(intent, location, null);
-
-            startActivityForResult(intent, PLACE_ACTIVITY);
-        } else {
-            pickPlaceForLocationWhenSessionOpened = location;
-        }
-    }
-
-    private void onClickSeattle() {
-        try {
-            startPickPlaceActivity(SEATTLE_LOCATION);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-
-    private void onClickSanFrancisco() {
-        try {
-            startPickPlaceActivity(SAN_FRANCISCO_LOCATION);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-
-    private void onClickGPS() {
-        try {
-            if (lastKnownLocation == null) {
-                Criteria criteria = new Criteria();
-                String bestProvider = locationManager.getBestProvider(criteria, false);
-                if (bestProvider != null) {
-                    lastKnownLocation = locationManager.getLastKnownLocation(bestProvider);
-                }
-            }
-            if (lastKnownLocation == null) {
-                String model = android.os.Build.MODEL;
-                if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
-                    // Looks like they are on an emulator, pretend we're in Paris if we don't have a
-                    // location set.
-                    lastKnownLocation = PARIS_LOCATION;
-                } else {
-                    onError(new Exception(getString(R.string.no_location)));
-                    return;
-                }
-            }
-            startPickPlaceActivity(lastKnownLocation);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-
-}
diff --git a/samples/ProfilePictureSample/.classpath b/samples/ProfilePictureSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/ProfilePictureSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/ProfilePictureSample/.project b/samples/ProfilePictureSample/.project
deleted file mode 100644
index 2b2339321..000000000
--- a/samples/ProfilePictureSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>ProfilePictureSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/ProfilePictureSample/AndroidManifest.xml b/samples/ProfilePictureSample/AndroidManifest.xml
deleted file mode 100644
index 907d05754..000000000
--- a/samples/ProfilePictureSample/AndroidManifest.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.facebook.samples.profilepicture"
-          android:versionCode="1"
-          android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
-    <uses-permission android:name="android.permission.INTERNET"/>
-    <application android:label="@string/app_name"
-                 android:icon="@drawable/icon" >
-        <activity
-                android:name=".ProfilePictureSampleActivity"
-                android:label="@string/app_name"
-                android:windowSoftInputMode="adjustResize">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest> 
diff --git a/samples/ProfilePictureSample/ant.properties b/samples/ProfilePictureSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/ProfilePictureSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/ProfilePictureSample/build.gradle b/samples/ProfilePictureSample/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/samples/ProfilePictureSample/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/samples/ProfilePictureSample/build.xml b/samples/ProfilePictureSample/build.xml
deleted file mode 100644
index 3454adc93..000000000
--- a/samples/ProfilePictureSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="ProfilePictureSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/ProfilePictureSample/proguard-project.txt b/samples/ProfilePictureSample/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/samples/ProfilePictureSample/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/ProfilePictureSample/project.properties b/samples/ProfilePictureSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/ProfilePictureSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/ProfilePictureSample/res/drawable-hdpi/icon.png b/samples/ProfilePictureSample/res/drawable-hdpi/icon.png
deleted file mode 100644
index 1bc72b1bf..000000000
Binary files a/samples/ProfilePictureSample/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/samples/ProfilePictureSample/res/drawable-mdpi/icon.png b/samples/ProfilePictureSample/res/drawable-mdpi/icon.png
deleted file mode 100644
index e0de1a4ba..000000000
Binary files a/samples/ProfilePictureSample/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png b/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png
deleted file mode 100644
index 1bc4b231d..000000000
Binary files a/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/samples/ProfilePictureSample/res/drawable/icon.png b/samples/ProfilePictureSample/res/drawable/icon.png
deleted file mode 100644
index e0de1a4ba..000000000
Binary files a/samples/ProfilePictureSample/res/drawable/icon.png and /dev/null differ
diff --git a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
deleted file mode 100644
index 8797e28be..000000000
--- a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<fragment xmlns:android="http://schemas.android.com/apk/res/android"
-          android:id="@+id/profilePictureSampleFragment"
-          android:layout_width="match_parent"
-          android:layout_height="match_parent"
-          android:name="com.facebook.samples.profilepicture.ProfilePictureSampleFragment"
-        />
diff --git a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
deleted file mode 100644
index 8bb4921c5..000000000
--- a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
+++ /dev/null
@@ -1,152 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-            xmlns:app="http://schemas.android.com/apk/res-auto"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        >
-<LinearLayout
-              android:orientation="vertical"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent"
-        >
-    <TextView
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:text="@string/description"
-            android:layout_marginBottom="15dp"
-            />
-    <LinearLayout
-            android:layout_height="wrap_content"
-            android:layout_width="match_parent"
-            android:layout_marginBottom="15dp"
-            android:orientation="horizontal">
-        <LinearLayout
-                android:id="@+id/presetSizeView"
-                android:layout_height="wrap_content"
-                android:layout_width="0dp"
-                android:layout_weight="1"
-                android:orientation="horizontal"
-                >
-            <Button
-                    android:id="@+id/smallerButton"
-                    android:layout_height="40dp"
-                    android:layout_width="40dp"
-                    android:layout_weight="0"
-                    android:text="@string/smaller_button_text"
-                    android:textSize="18dp"
-                    />
-            <Button
-                    android:id="@+id/largerButton"
-                    android:layout_height="40dp"
-                    android:layout_width="40dp"
-                    android:layout_weight="0"
-                    android:text="@string/larger_button_text"
-                    android:textSize="18dp"
-                    android:enabled="false"
-                    />
-            <TextView
-                    android:id="@+id/sizeLabel"
-                    android:layout_height="40dp"
-                    android:layout_width="0dp"
-                    android:layout_weight="1"
-                    android:paddingLeft="10dp"
-                    android:text="@string/large_image_size"
-                    android:textSize="18dp"
-                    />
-        </LinearLayout>
-        <SeekBar
-                android:id="@+id/customSizeView"
-                android:layout_height="wrap_content"
-                android:layout_width="0dp"
-                android:layout_weight="1"
-                android:orientation="horizontal"
-                android:visibility="gone"
-                />
-        <Button
-                android:id="@+id/sizeToggle"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_marginLeft="10dp"
-                android:text="@string/custom_size_button_text"
-                />
-    </LinearLayout>
-    <LinearLayout
-            android:orientation="horizontal"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="10dp"
-            android:layout_marginBottom="10dp"
-            >
-        <com.facebook.widget.ProfilePictureView
-                android:id="@+id/profilepic"
-                android:layout_height="wrap_content"
-                android:layout_width="0dp"
-                android:layout_weight="1"
-                app:preset_size="large"
-                app:is_cropped="true"
-                />
-        <LinearLayout
-                android:id="@+id/userbuttoncontainer"
-                android:orientation="vertical"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="right"
-                >
-            <Button
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:text="@string/user_chris_name"
-                    android:tag="chris.lang.92123"
-                    />
-            <Button
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:text="@string/user_ming_name"
-                    android:tag="mingfli"
-                    />
-            <Button
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:text="@string/user_karthik_name"
-                    android:tag="ksubraman"
-                    />
-            <Button
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:text="@string/user_random_name"
-                    />
-
-            <Button
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:text="@string/user_none_name"
-                    android:tag=""
-                    />
-        </LinearLayout>
-    </LinearLayout>
-
-    <CheckBox
-            android:id="@+id/squareCropToggle"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/cropping_label"
-            android:checked="true"
-            />
-</LinearLayout>
-</ScrollView>
diff --git a/samples/ProfilePictureSample/res/values/strings.xml b/samples/ProfilePictureSample/res/values/strings.xml
deleted file mode 100644
index bde7903ad..000000000
--- a/samples/ProfilePictureSample/res/values/strings.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_name">ProfilePictureSample</string>
-    <string name="description">Sample app demonstrating the use of ProfilePictureView</string>
-    <string name="cropping_label">Show cropped version</string>
-    <string name="crop_original_button_text">Original</string>
-    <string name="crop_square_button_text">Square</string>
-    <string name="user_chris_name">Chris</string>
-    <string name="user_ming_name">Ming</string>
-    <string name="user_karthik_name">Karthik</string>
-    <string name="user_random_name">Random</string>
-    <string name="user_none_name">None</string>
-    <string name="smaller_button_text">-</string>
-    <string name="larger_button_text">+</string>
-    <string name="large_image_size">Large</string>
-    <string name="normal_image_size">Normal</string>
-    <string name="small_image_size">Small</string>
-    <string name="preset_size_button_text">Use preset size</string>
-    <string name="custom_size_button_text">Use custom size</string>
-</resources>
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
deleted file mode 100644
index dc2b12efa..000000000
--- a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.profilepicture;
-
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-
-public class ProfilePictureSampleActivity extends FragmentActivity {
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_profile_picture_sample);
-    }
-}
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
deleted file mode 100644
index b80ca2eff..000000000
--- a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
+++ /dev/null
@@ -1,314 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.profilepicture;
-
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.*;
-import com.facebook.widget.ProfilePictureView;
-
-import java.util.Date;
-import java.util.Random;
-
-public class ProfilePictureSampleFragment extends Fragment {
-
-    // Keeping the number of custom sizes low to prevent excessive network chatter.
-    private static final int MAX_CUSTOM_SIZES = 6;
-    private static final int DEFAULT_SIZE_INCREMENT = MAX_CUSTOM_SIZES / 2;
-    private static final String PICTURE_SIZE_TYPE_KEY = "PictureSizeType";
-
-    private static final String[] INTERESTING_IDS = {
-        "zuck",
-        // Recent Presidents and nominees
-        "barackobama",
-        "mittromney",
-        "johnmccain",
-        "johnkerry",
-        "georgewbush",
-        "algore",
-        // Places too!
-        "Disneyland",
-        "SpaceNeedle",
-        "TourEiffel",
-        "sydneyoperahouse",
-        // A selection of 1986 Mets
-        "166020963458360",
-        "108084865880237",
-        "140447466087679",
-        "111825495501392",
-        // The cast of Saved by the Bell
-        "108168249210849",
-        "TiffaniThiessen",
-        "108126672542534",
-        "112886105391693",
-        "MarioLopezExtra",
-        "108504145837165",
-        "dennishaskins",
-        // Eighties bands that have been to Moscow
-        "7220821999",
-        "31938132882",
-        "108023262558391",
-        "209263392372",
-        "104132506290482",
-        "9721897972",
-        "5461947317",
-        "57084011597",
-        // Three people that have never been in my kitchen
-        "24408579964",
-        "111980872152571",
-        "112427772106500",
-        // Trusted anchormen
-        "113415525338717",
-        "105628452803615",
-        "105533779480538",
-    };
-
-    private int pictureSizeType = ProfilePictureView.CUSTOM;
-    private String firstUserId;
-    private Random randomGenerator;
-
-    private ProfilePictureView profilePic;
-    private Button smallerButton;
-    private Button largerButton;
-    private TextView sizeLabel;
-    private View presetSizeView;
-    private SeekBar customSizeView;
-    private CheckBox cropToggle;
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
-        View fragmentView = inflater.inflate(R.layout.fragment_profile_picture_sample, parent, false);
-
-        randomGenerator = new Random((new Date()).getTime());
-
-        profilePic = (ProfilePictureView) fragmentView.findViewById(R.id.profilepic);
-        smallerButton = (Button) fragmentView.findViewById(R.id.smallerButton);
-        largerButton = (Button) fragmentView.findViewById(R.id.largerButton);
-        sizeLabel = (TextView) fragmentView.findViewById(R.id.sizeLabel);
-        presetSizeView = fragmentView.findViewById(R.id.presetSizeView);
-        customSizeView = (SeekBar) fragmentView.findViewById(R.id.customSizeView);
-        cropToggle = (CheckBox) fragmentView.findViewById(R.id.squareCropToggle);
-
-        LinearLayout container = (LinearLayout) fragmentView.findViewById(R.id.userbuttoncontainer);
-        int numChildren = container.getChildCount();
-        for (int i = 0; i < numChildren; i++) {
-            View childView = container.getChildAt(i);
-            Object tag = childView.getTag();
-            if (childView instanceof Button) {
-                setupUserButton((Button)childView);
-                if (i == 0) {
-                    // Initialize the image to the first user
-                    firstUserId = tag.toString();
-                }
-            }
-        }
-
-        cropToggle.setOnCheckedChangeListener(new CheckBox.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
-                profilePic.setCropped(checked);
-            }
-        });
-
-        final Button sizeToggle = (Button) fragmentView.findViewById(R.id.sizeToggle);
-        sizeToggle.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                if (pictureSizeType != ProfilePictureView.CUSTOM) {
-                    sizeToggle.setText(R.string.preset_size_button_text);
-                    switchToCustomSize();
-                } else {
-                    sizeToggle.setText(R.string.custom_size_button_text);
-                    switchToPresetSize(ProfilePictureView.LARGE);
-                }
-            }
-        });
-
-        smallerButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                switch(profilePic.getPresetSize()) {
-                    case ProfilePictureView.LARGE:
-                        switchToPresetSize(ProfilePictureView.NORMAL);
-                        break;
-                    case ProfilePictureView.NORMAL:
-                        switchToPresetSize(ProfilePictureView.SMALL);
-                        break;
-                }
-            }
-        });
-
-        largerButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                switch(profilePic.getPresetSize()) {
-                    case ProfilePictureView.NORMAL:
-                        switchToPresetSize(ProfilePictureView.LARGE);
-                        break;
-                    case ProfilePictureView.SMALL:
-                        switchToPresetSize(ProfilePictureView.NORMAL);
-                        break;
-                }
-            }
-        });
-
-        // We will fetch a new image for each change in the SeekBar. So keeping the count low
-        // to prevent too much network chatter. SeekBar reports 0-max, so we will get max+1
-        // notifications of change.
-        customSizeView.setMax(MAX_CUSTOM_SIZES);
-        customSizeView.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {
-                updateProfilePicForCustomSizeIncrement(i);
-            }
-
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-                // NO-OP
-            }
-
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-                // NO-OP
-            }
-        });
-
-        restoreState(savedInstanceState);
-
-        return fragmentView;
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        // Store the size type since we will use that to switch the Fragment's UI
-        // between CUSTOM & PRESET modes
-        // Other state (userId & isCropped) will be saved/restored directly by
-        // ProfilePictureView
-        outState.putInt(PICTURE_SIZE_TYPE_KEY, pictureSizeType);
-    }
-
-    private void restoreState(Bundle savedInstanceState) {
-        if (savedInstanceState != null) {
-            // Is we have saved state, restore the Fragment to it.
-            // UserId & isCropped will be restored directly by ProfilePictureView
-            pictureSizeType = savedInstanceState.getInt(
-                    PICTURE_SIZE_TYPE_KEY, ProfilePictureView.LARGE);
-
-            if (pictureSizeType == ProfilePictureView.CUSTOM) {
-                switchToCustomSize();
-            } else {
-                switchToPresetSize(pictureSizeType);
-            }
-        } else {
-            // No saved state. Let's go to a default state
-            switchToPresetSize(ProfilePictureView.LARGE);
-            profilePic.setCropped(cropToggle.isChecked());
-
-            // Setting userId last so that only one network request is sent
-            profilePic.setProfileId(firstUserId);
-        }
-    }
-
-    private void setupUserButton(Button b) {
-        b.setOnClickListener(new Button.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Object tag = v.getTag();
-                String userId = null;
-                if (tag != null) {
-                    userId = tag.toString();
-                } else {
-                    // Random id.
-                    userId = INTERESTING_IDS[randomGenerator.nextInt(INTERESTING_IDS.length)];
-                }
-                profilePic.setProfileId(userId);
-            }
-        });
-    }
-
-    private void switchToCustomSize() {
-        pictureSizeType = ProfilePictureView.CUSTOM;
-        presetSizeView.setVisibility(View.GONE);
-        customSizeView.setVisibility(View.VISIBLE);
-
-        profilePic.setPresetSize(pictureSizeType);
-
-        customSizeView.setProgress(DEFAULT_SIZE_INCREMENT);
-        updateProfilePicForCustomSizeIncrement(DEFAULT_SIZE_INCREMENT);
-    }
-
-    private void switchToPresetSize(int sizeType) {
-        customSizeView.setVisibility(View.GONE);
-        presetSizeView.setVisibility(View.VISIBLE);
-
-        switch(sizeType) {
-            case ProfilePictureView.SMALL:
-                largerButton.setEnabled(true);
-                smallerButton.setEnabled(false);
-                sizeLabel.setText(R.string.small_image_size);
-                pictureSizeType = sizeType;
-                break;
-            case ProfilePictureView.NORMAL:
-                largerButton.setEnabled(true);
-                smallerButton.setEnabled(true);
-                sizeLabel.setText(R.string.normal_image_size);
-                pictureSizeType = sizeType;
-                break;
-            case ProfilePictureView.LARGE:
-            default:
-                largerButton.setEnabled(false);
-                smallerButton.setEnabled(true);
-                sizeLabel.setText(R.string.large_image_size);
-                pictureSizeType = ProfilePictureView.LARGE;
-                break;
-        }
-
-        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
-                0,
-                ViewGroup.LayoutParams.WRAP_CONTENT,
-                1
-        );
-
-        profilePic.setLayoutParams(params);
-        profilePic.setPresetSize(pictureSizeType);
-    }
-
-    private void updateProfilePicForCustomSizeIncrement(int i) {
-        if (pictureSizeType != ProfilePictureView.CUSTOM) {
-            return;
-        }
-
-        // This will ensure a minimum size of 51x68 and will scale the image at
-        // a ratio of 3:4 (w:h) as the SeekBar is moved.
-        //
-        // Completely arbitrary
-        //
-        // NOTE: The numbers are in dips.
-        float width = (i * 21) + 51;
-        float height = (i * 28) + 68;
-
-        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
-                (int)(width * getResources().getDisplayMetrics().density),
-                (int)(height * getResources().getDisplayMetrics().density));
-        profilePic.setLayoutParams(params);
-    }
-}
diff --git a/samples/RPSSample/.classpath b/samples/RPSSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/RPSSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/RPSSample/.project b/samples/RPSSample/.project
deleted file mode 100644
index 48ef59ca8..000000000
--- a/samples/RPSSample/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>RPSSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/samples/RPSSample/AndroidManifest.xml b/samples/RPSSample/AndroidManifest.xml
index ed5066d49..1abdc0eee 100644
--- a/samples/RPSSample/AndroidManifest.xml
+++ b/samples/RPSSample/AndroidManifest.xml
@@ -1,9 +1,29 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.facebook.samples.rps"
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
+    <uses-sdk android:minSdkVersion="9"/>
     <uses-permission android:name="android.permission.INTERNET"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <application android:label="@string/app_name"
@@ -18,14 +38,22 @@
                 <action android:name="android.intent.action.MAIN"/>
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <data android:host="fb.me" android:scheme="https" />
+            </intent-filter>
         </activity>
-        <activity android:name="FriendActivity"
-                  android:label="@string/app_name" />
-        <activity android:name="com.facebook.LoginActivity"
+        <activity android:name="com.facebook.FacebookActivity"
+                  android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
                   android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
-        <provider android:authorities="com.facebook.app.NativeAppCallContentProvider157578437735213"
-                  android:name="com.facebook.NativeAppCallContentProvider" />
+        <meta-data android:name="com.facebook.sdk.ApplicationName"
+                   android:value="@string/facebook_app_name" />
+        <provider android:authorities="com.facebook.app.FacebookContentProvider157578437735213"
+                  android:name="com.facebook.FacebookContentProvider"
+                  android:exported="true" />
     </application>
 </manifest>
diff --git a/samples/RPSSample/ant.properties b/samples/RPSSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/RPSSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/RPSSample/build.gradle b/samples/RPSSample/build.gradle
index a2cda0280..41125c44d 100644
--- a/samples/RPSSample/build.gradle
+++ b/samples/RPSSample/build.gradle
@@ -1,16 +1,20 @@
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':facebook')
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
diff --git a/samples/RPSSample/build.xml b/samples/RPSSample/build.xml
deleted file mode 100644
index ce90427bf..000000000
--- a/samples/RPSSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="RPSSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/RPSSample/post_app_objects.sh b/samples/RPSSample/post_app_objects.sh
index bda156e45..ba4533438 100755
--- a/samples/RPSSample/post_app_objects.sh
+++ b/samples/RPSSample/post_app_objects.sh
@@ -56,27 +56,59 @@ echo "  rock=$ROCK_IMAGE_URI"
 echo "  paper=$PAPER_IMAGE_URI"
 echo "  scissors=$SCISSORS_IMAGE_URI"
 
+# step 3 - create facebook hosted applink page for the app:
+# For mobile only app, facebook provide applink host service to generate a page: https://developers.facebook.com/docs/graph-api/reference/v2.0/app/app_link_hosts
+
+echo "creating facebook host applink page for mobile-only app:"
+
+FB_APPLINK_HOST_ID=` \
+curl https://graph.facebook.com/app/app_link_hosts -F access_token="$APPID|$APPSECRET" -F pretty=true -F name="RPSSample" \
+-F ios='[
+    {
+      "url" : "rps-sample-applink-example://",
+      "app_store_id" : 794163692,
+      "app_name" : "RPS Sample",
+    },
+  ]' \
+-F android=' [
+    {
+      "package" : "com.facebook.samples.rps",
+      "app_name" : "RPS Sample",
+    },
+  ]' \
+-F web=' {
+    "should_fallback" : false,
+  }' \
+| perl -ne '/"id":\s*"(.*)"/ && print $1'`
+
+FB_APPLINK_HOST_URL=` \
+curl -X GET https://graph.facebook.com/v2.0/$FB_APPLINK_HOST_ID?access_token="$APPID|$APPSECRET" \
+| perl -ne '/"canonical_url":\s*"(.*)"/ && print $1' `
+
+echo "  applink host url id: $FB_APPLINK_HOST_ID"
+echo "  applink host url: $FB_APPLINK_HOST_URL"
+
 #
-# step 3 - create objects and capture their IDs in variables
+# step 4 - create objects and capture their IDs in variables
 #
 
 # rock
 ROCK_OBJID=` \
-  curl -s -X POST -F "object={\"title\":\"Rock\",\"description\":\"Breaks scissors, alas is covered by paper.\",\"image\":\"$ROCK_IMAGE_URI\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
+  curl -s -X POST -F "object={\"title\":\"Rock\",\"description\":\"Breaks scissors, alas is covered by paper.\",\"image\":\"$ROCK_IMAGE_URI\",\"url\":\"$FB_APPLINK_HOST_URL?gesture=rock\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
   | perl -ne '/"id":"(.*)"}/ && print $1' `
 
 # paper
 PAPER_OBJID=` \
-  curl -s -X POST -F "object={\"title\":\"Paper\",\"description\":\"Covers rock, sadly scissors cut it.\",\"image\":\"$PAPER_IMAGE_URI\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
+  curl -s -X POST -F "object={\"title\":\"Paper\",\"description\":\"Covers rock, sadly scissors cut it.\",\"image\":\"$PAPER_IMAGE_URI\",\"url\":\"$FB_APPLINK_HOST_URL?gesture=paper\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
   | perl -ne '/"id":"(.*)"}/ && print $1' `
 
 # scissors
 SCISSORS_OBJID=` \
-  curl -s -X POST -F "object={\"title\":\"Scissors\",\"description\":\"Cuts paper, broken by rock -- bother.\",\"image\":\"$SCISSORS_IMAGE_URI\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
+  curl -s -X POST -F "object={\"title\":\"Scissors\",\"description\":\"Cuts paper, broken by rock -- bother.\",\"image\":\"$SCISSORS_IMAGE_URI\",\"url\":\"$FB_APPLINK_HOST_URL?gesture=scissors\"}" "https://graph.facebook.com/$APPID/objects/fb_sample_rps:gesture?access_token=$APPID|$APPSECRET" \
   | perl -ne '/"id":"(.*)"}/ && print $1' `
 
 #
-# step 4 - echo progress
+# step 5 - echo progress
 #
 
 echo "created application objects..."
@@ -85,7 +117,7 @@ echo "  paper=$PAPER_OBJID"
 echo "  scissors=$SCISSORS_OBJID"
 
 #
-# step 5 - write .java file for common objects
+# step 6 - write .java file for common objects
 #
 
 MFILE=src/com/facebook/samples/rps/CommonObjects.java
diff --git a/samples/RPSSample/project.properties b/samples/RPSSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/RPSSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/RPSSample/res/drawable-hdpi/icon.png b/samples/RPSSample/res/drawable-hdpi/icon.png
index 5bc5b2cea..9e70a87f3 100644
Binary files a/samples/RPSSample/res/drawable-hdpi/icon.png and b/samples/RPSSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/RPSSample/res/drawable-mdpi/icon.png b/samples/RPSSample/res/drawable-mdpi/icon.png
index f621e908c..f8ac7a2db 100644
Binary files a/samples/RPSSample/res/drawable-mdpi/icon.png and b/samples/RPSSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/RPSSample/res/drawable-xhdpi/icon.png b/samples/RPSSample/res/drawable-xhdpi/icon.png
index 1adb6bfa3..ea8da121a 100644
Binary files a/samples/RPSSample/res/drawable-xhdpi/icon.png and b/samples/RPSSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/RPSSample/res/drawable/app_background.xml b/samples/RPSSample/res/drawable/app_background.xml
index af7a20a63..cb65d561d 100644
--- a/samples/RPSSample/res/drawable/app_background.xml
+++ b/samples/RPSSample/res/drawable/app_background.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
@@ -27,4 +31,4 @@ limitations under the License.
             <solid android:color="#999" />
         </shape>
     </item>
-</layer-list>
\ No newline at end of file
+</layer-list>
diff --git a/samples/RPSSample/res/drawable/fb_logo.png b/samples/RPSSample/res/drawable/fb_logo.png
index b4b29948c..42c619123 100755
Binary files a/samples/RPSSample/res/drawable/fb_logo.png and b/samples/RPSSample/res/drawable/fb_logo.png differ
diff --git a/samples/RPSSample/res/drawable/icon.png b/samples/RPSSample/res/drawable/icon.png
index f621e908c..f8ac7a2db 100644
Binary files a/samples/RPSSample/res/drawable/icon.png and b/samples/RPSSample/res/drawable/icon.png differ
diff --git a/samples/RPSSample/res/drawable/icon_border.xml b/samples/RPSSample/res/drawable/icon_border.xml
index 89eedd647..07c7ac547 100644
--- a/samples/RPSSample/res/drawable/icon_border.xml
+++ b/samples/RPSSample/res/drawable/icon_border.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
@@ -20,4 +24,4 @@
     <corners android:radius="10dp" />
     <padding android:bottom="2dp" android:left="2dp" android:right="2dp" android:top="2dp" />
     <stroke android:width="2px" android:color="@color/text_color" />
-</shape>
\ No newline at end of file
+</shape>
diff --git a/samples/RPSSample/res/drawable/left_paper.png b/samples/RPSSample/res/drawable/left_paper.png
index 7336fd246..813e925da 100755
Binary files a/samples/RPSSample/res/drawable/left_paper.png and b/samples/RPSSample/res/drawable/left_paper.png differ
diff --git a/samples/RPSSample/res/drawable/left_rock.png b/samples/RPSSample/res/drawable/left_rock.png
index bee7abe89..4226ab074 100755
Binary files a/samples/RPSSample/res/drawable/left_rock.png and b/samples/RPSSample/res/drawable/left_rock.png differ
diff --git a/samples/RPSSample/res/drawable/left_scissors.png b/samples/RPSSample/res/drawable/left_scissors.png
index dac525200..0ed1b1c16 100755
Binary files a/samples/RPSSample/res/drawable/left_scissors.png and b/samples/RPSSample/res/drawable/left_scissors.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_default_icon.png b/samples/RPSSample/res/drawable/profile_default_icon.png
similarity index 100%
rename from facebook/res/drawable/com_facebook_profile_default_icon.png
rename to samples/RPSSample/res/drawable/profile_default_icon.png
diff --git a/samples/RPSSample/res/drawable/right_paper.png b/samples/RPSSample/res/drawable/right_paper.png
index d243567a9..54431fe6a 100755
Binary files a/samples/RPSSample/res/drawable/right_paper.png and b/samples/RPSSample/res/drawable/right_paper.png differ
diff --git a/samples/RPSSample/res/drawable/right_rock.png b/samples/RPSSample/res/drawable/right_rock.png
index 9168b4b74..51203c4bc 100755
Binary files a/samples/RPSSample/res/drawable/right_rock.png and b/samples/RPSSample/res/drawable/right_rock.png differ
diff --git a/samples/RPSSample/res/drawable/right_scissors.png b/samples/RPSSample/res/drawable/right_scissors.png
index 083c47590..7c55471e6 100755
Binary files a/samples/RPSSample/res/drawable/right_scissors.png and b/samples/RPSSample/res/drawable/right_scissors.png differ
diff --git a/samples/RPSSample/res/drawable/usersettings_facebook_logo.png b/samples/RPSSample/res/drawable/usersettings_facebook_logo.png
new file mode 100644
index 000000000..161bef08b
Binary files /dev/null and b/samples/RPSSample/res/drawable/usersettings_facebook_logo.png differ
diff --git a/samples/RPSSample/res/drawable/usersettings_fragment_background_gradient.xml b/samples/RPSSample/res/drawable/usersettings_fragment_background_gradient.xml
new file mode 100644
index 000000000..0a504ea55
--- /dev/null
+++ b/samples/RPSSample/res/drawable/usersettings_fragment_background_gradient.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+    <gradient
+      android:startColor="#5774B5"
+      android:endColor="#2C4988"
+      android:gradientRadius="495"
+      android:type="radial"/>
+</shape>    
diff --git a/samples/RPSSample/res/layout/content_fragment.xml b/samples/RPSSample/res/layout/content_fragment.xml
index 43e8e3662..b613cc47f 100644
--- a/samples/RPSSample/res/layout/content_fragment.xml
+++ b/samples/RPSSample/res/layout/content_fragment.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
diff --git a/samples/RPSSample/res/layout/friend_activity_row.xml b/samples/RPSSample/res/layout/friend_activity_row.xml
deleted file mode 100644
index 26b3b2daa..000000000
--- a/samples/RPSSample/res/layout/friend_activity_row.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent"
-              android:orientation="horizontal"
-              android:background="#fff">
-
-    <TextView android:id="@+id/friend_action_date"
-              android:layout_height="wrap_content"
-              android:layout_width="match_parent"
-              android:layout_weight="1"
-              android:textSize="12sp"
-              android:textColor="#000"/>
-
-    <TextView android:id="@+id/friend_game_result"
-              android:layout_height="wrap_content"
-              android:layout_width="match_parent"
-              android:layout_weight="1"
-              android:textSize="12sp"
-              android:textColor="#000"/>
-
-</LinearLayout>
diff --git a/samples/RPSSample/res/layout/friends_activity.xml b/samples/RPSSample/res/layout/friends_activity.xml
deleted file mode 100644
index 5efcb34f9..000000000
--- a/samples/RPSSample/res/layout/friends_activity.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:id="@+id/friends_group"
-              android:layout_height="match_parent"
-              android:layout_width="match_parent"
-              android:background="#FFF"
-              android:orientation="vertical">
-
-    <TextView android:layout_height="wrap_content"
-              android:layout_width="match_parent"
-              android:textColor="#000"
-              android:textSize="20sp"
-              android:text="@string/friends_using_rps"/>
-
-    <View android:id="@+id/friend_separator"
-          android:layout_width="match_parent"
-          android:layout_height="1dp"
-          android:background="#000"/>
-
-    <fragment android:name="com.facebook.widget.FriendPickerFragment"
-              android:id="@+id/friend_fragment"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent"
-              android:layout_weight="1"/>
-
-    <TextView android:layout_height="wrap_content"
-              android:layout_width="match_parent"
-              android:textColor="#000"
-              android:textSize="20sp"
-              android:text="@string/friend_activity"/>
-
-    <View android:id="@+id/friend_activity_separator"
-          android:layout_width="match_parent"
-          android:layout_height="1dp"
-          android:background="#000"/>
-
-    <FrameLayout android:layout_height="match_parent"
-                 android:layout_width="match_parent"
-                 android:layout_weight="1">
-
-        <ListView android:id="@+id/friend_activity_list"
-                  android:layout_height="match_parent"
-                  android:layout_width="match_parent"/>
-
-        <ProgressBar android:id="@+id/friend_activity_progress_bar"
-                     android:layout_width="wrap_content"
-                     android:layout_height="wrap_content"
-                     android:layout_gravity="center"
-                     android:indeterminate="true"
-                     style="@android:style/Widget.ProgressBar"
-                     android:layout_centerInParent="true"
-                     android:visibility="gone"/>
-
-    </FrameLayout>
-
-    <Button android:id="@+id/invite_button"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:padding="10dp"
-            android:layout_margin="20dp"
-            android:text="@string/invite_friends"
-            android:background="@drawable/icon_border" />
-
-
-</LinearLayout>
diff --git a/samples/RPSSample/res/layout/main.xml b/samples/RPSSample/res/layout/main.xml
index 475b06051..980d6217a 100644
--- a/samples/RPSSample/res/layout/main.xml
+++ b/samples/RPSSample/res/layout/main.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout
@@ -25,7 +29,7 @@
               android:id="@+id/rps_fragment"
               android:layout_width="match_parent"
               android:layout_height="match_parent" />
-    <fragment android:name="com.facebook.widget.UserSettingsFragment"
+    <fragment android:name="com.facebook.samples.rps.usersettings.UserSettingsFragment"
               android:id="@+id/settings_fragment"
               android:layout_width="match_parent"
               android:layout_height="match_parent" />
diff --git a/samples/RPSSample/res/layout/rps_fragment.xml b/samples/RPSSample/res/layout/rps_fragment.xml
index 0142f6baa..42bde19b6 100644
--- a/samples/RPSSample/res/layout/rps_fragment.xml
+++ b/samples/RPSSample/res/layout/rps_fragment.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
diff --git a/samples/RPSSample/res/layout/usersettings_fragment.xml b/samples/RPSSample/res/layout/usersettings_fragment.xml
new file mode 100644
index 000000000..3e9bd7cd4
--- /dev/null
+++ b/samples/RPSSample/res/layout/usersettings_fragment.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:loginView="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@drawable/usersettings_fragment_background_gradient" >
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/usersettings_fragment_logo_image"
+            android:layout_width="193dp"
+            android:layout_height="44dp"
+            android:layout_gravity="center_horizontal"
+            android:src="@drawable/usersettings_facebook_logo"
+            android:layout_marginTop="35dp"
+            android:contentDescription="@string/usersettings_fragment_logo_content_description"/>
+
+        <TextView
+            android:id="@+id/usersettings_fragment_profile_name"
+            android:layout_width="match_parent"
+            android:layout_height="100dp"
+            android:lines="1"
+            android:textSize="16sp"
+            android:textStyle="bold"
+            android:layout_marginTop="35dp"
+            android:gravity="center"/>
+    
+        <com.facebook.login.widget.LoginButton
+            android:id="@+id/usersettings_fragment_login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="35dp"
+            android:layout_marginBottom="35dp"
+            loginView:com_facebook_login_text="@string/usersettings_fragment_log_in_button"
+            style="@style/com_facebook_loginview_silver_style" />
+    
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/RPSSample/res/values/strings.xml b/samples/RPSSample/res/values/strings.xml
index 42fb88e64..5cb1193a6 100644
--- a/samples/RPSSample/res/values/strings.xml
+++ b/samples/RPSSample/res/values/strings.xml
@@ -1,22 +1,27 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
     <string name="app_name">RPSSample</string>
+    <string name="facebook_app_name">Rock Paper Scissors SDK Sample</string>
     <string name="app_id">157578437735213</string>
     <string name="rock">Rock</string>
     <string name="paper">Paper</string>
@@ -31,13 +36,14 @@
     <string name="result_lost">lost</string>
     <string name="result_tied">tied</string>
     <string name="share_on_facebook">Share on Facebook</string>
-    <string name="see_friends">See Friends</string>
+    <string name="send_with_messenger">Send with Messenger</string>
     <string name="check_settings">Check Facebook Settings</string>
     <string name="friends_using_rps">Friends Rockin\' RPS</string>
     <string name="friend_activity">Friend\'s Activity</string>
     <string name="invite_friends">Invite Friends</string>
-    <string name="invite_dialog_title">Invite a Friend</string>
-    <string name="invite_dialog_message">Please come play RPS with me!</string>
+    <string name="challenge_friends">Challenge Friends</string>
+    <string name="challenge_dialog_title">Challenge a Friend</string>
+    <string name="challenge_dialog_message">Please come play RPS with me!</string>
     <string name="stats_format">W = %1$d  L = %2$d  T = %3$d</string>
     <string name="action_display_format">%1$s vs %2$s</string>
     <string name="feature_requires_login_title">Social Features Disabled</string>
@@ -50,6 +56,13 @@
     <string name="share_with_friends_yes">Yes</string>
     <string name="share_with_friends_no">Maybe Later</string>
     <string name="error_ok_button">OK</string>
+    <string name="native_share_error">Native sharing requires the Facebook for Android
+        application.</string>
+    <string name="appinvite_error">Cannot present App Invite Dialog.</string>
     <string name="error_dialog_title">Error!</string>
     <string name="login_error">An error occurred during login. Please try again.</string>
+    <string name="usersettings_fragment_log_in_button">Log in&#8230;</string>
+    <string name="usersettings_fragment_logged_in">Logged in</string>
+    <string name="usersettings_fragment_not_logged_in">Not logged in</string>
+    <string name="usersettings_fragment_logo_content_description">Facebook Logo</string>
 </resources>
diff --git a/samples/RPSSample/res/values/styles.xml b/samples/RPSSample/res/values/styles.xml
index e43c8a696..278bc4ae6 100644
--- a/samples/RPSSample/res/values/styles.xml
+++ b/samples/RPSSample/res/values/styles.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android">
@@ -30,9 +34,15 @@
     <style name="again_button_style" parent="@android:style/Widget.Button">
         <item name="android:width">200dp</item>
         <item name="android:height">75dp</item>
-        <item name="android:background">@drawable/com_facebook_loginbutton_silver</item>
         <item name="android:textSize">@dimen/text_size</item>
         <item name="android:textColor">@color/text_color</item>
         <item name="android:gravity">center</item>
     </style>
+
+    <color name="usersettings_fragment_connected_text_color">#FFFFFF</color>
+    <color name="usersettings_fragment_connected_shadow_color">#000000</color>
+    <color name="usersettings_fragment_not_connected_text_color">#A6AED7</color>
+    <dimen name="usersettings_fragment_profile_picture_width">64dp</dimen>
+    <dimen name="usersettings_fragment_profile_picture_height">64dp</dimen>
+
 </resources>
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/CommonObjects.java b/samples/RPSSample/src/com/facebook/samples/rps/CommonObjects.java
index 3551eaff2..d1f1fe965 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/CommonObjects.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/CommonObjects.java
@@ -1,25 +1,31 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+
 package com.facebook.samples.rps;
 
 public class CommonObjects {
     public static final String BUILT_IN_OPEN_GRAPH_OBJECTS[] = {
-            "349677488467004", // rock
-            "231845580291424", // paper
-            "120373648159839"  // scissors
+            "672839339475385", // rock
+            "296430467206197", // paper
+            "524651207660361"  // scissors
     };
 }
+
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/ContentFragment.java b/samples/RPSSample/src/com/facebook/samples/rps/ContentFragment.java
index f31e24f20..d923efe82 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/ContentFragment.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/ContentFragment.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.rps;
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/FriendActivity.java b/samples/RPSSample/src/com/facebook/samples/rps/FriendActivity.java
deleted file mode 100644
index 0a14d072b..000000000
--- a/samples/RPSSample/src/com/facebook/samples/rps/FriendActivity.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.rps;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.database.MatrixCursor;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.util.Log;
-import android.view.View;
-import android.widget.Button;
-import android.widget.ListView;
-import android.widget.ProgressBar;
-import android.widget.SimpleCursorAdapter;
-import com.facebook.*;
-import com.facebook.model.GraphMultiResult;
-import com.facebook.model.GraphUser;
-import static com.facebook.samples.rps.OpenGraphUtils.*;
-import com.facebook.widget.FriendPickerFragment;
-import com.facebook.widget.PickerFragment;
-import com.facebook.widget.WebDialog;
-
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-public class FriendActivity extends FragmentActivity {
-    private static final String TAG = FriendActivity.class.getName();
-    private static final String INSTALLED = "installed";
-
-    private FriendPickerFragment friendPickerFragment;
-    private SimpleCursorAdapter friendActivityAdapter;
-    private ProgressBar friendActivityProgressBar;
-    private List<ActionRow> friendActionList;
-    private Request pendingRequest;
-    private String friendId;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.friends_activity);
-
-        FragmentManager fragmentManager = getSupportFragmentManager();
-        friendPickerFragment = (FriendPickerFragment) fragmentManager.findFragmentById(R.id.friend_fragment);
-        friendPickerFragment.setShowTitleBar(false);
-
-        ListView friendActivityList = (ListView) findViewById(R.id.friend_activity_list);
-        String[] mapColumnNames = {"date", "action"};
-        int[] mapViewIds = {R.id.friend_action_date, R.id.friend_game_result};
-        friendActivityAdapter = new SimpleCursorAdapter(this, R.layout.friend_activity_row,
-                createEmptyCursor(), mapColumnNames, mapViewIds);
-        friendActivityList.setAdapter(friendActivityAdapter);
-        friendActivityProgressBar = (ProgressBar) findViewById(R.id.friend_activity_progress_bar);
-
-        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(PickerFragment<?> fragment, FacebookException error) {
-                FriendActivity.this.onError(error);
-            }
-        });
-        friendPickerFragment.setUserId("me");
-        friendPickerFragment.setMultiSelect(false);
-        friendPickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
-            @Override
-            public void onSelectionChanged(PickerFragment<?> fragment) {
-                FriendActivity.this.onFriendSelectionChanged();
-            }
-        });
-        friendPickerFragment.setExtraFields(Arrays.asList(INSTALLED));
-        friendPickerFragment.setFilter(new PickerFragment.GraphObjectFilter<GraphUser>() {
-            @Override
-            public boolean includeItem(GraphUser graphObject) {
-                Boolean installed = graphObject.cast(GraphUserWithInstalled.class).getInstalled();
-                return (installed != null) && installed.booleanValue();
-            }
-        });
-
-        Button inviteButton = (Button) findViewById(R.id.invite_button);
-        inviteButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                WebDialog.RequestsDialogBuilder builder =
-                        new WebDialog.RequestsDialogBuilder(FriendActivity.this, Session.getActiveSession())
-                                .setTitle(getString(R.string.invite_dialog_title))
-                                .setMessage(getString(R.string.invite_dialog_message))
-                                .setOnCompleteListener(new WebDialog.OnCompleteListener() {
-                                    @Override
-                                    public void onComplete(Bundle values, FacebookException error) {
-                                        if (error != null) {
-                                            Log.w(TAG, "Web dialog encountered an error.", error);
-                                        } else {
-                                            Log.i(TAG, "Web dialog complete: " + values);
-                                        }
-                                    }
-                                });
-                if (friendId != null) {
-                    builder.setTo(friendId);
-                }
-                builder.build().show();
-            }
-        });
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        Session activeSession = Session.getActiveSession();
-        if (activeSession == null || !activeSession.isOpened()) {
-            new AlertDialog.Builder(this)
-                    .setTitle(R.string.feature_requires_login_title)
-                    .setMessage(R.string.feature_requires_login_message)
-                    .setPositiveButton(R.string.error_ok_button, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            finish();
-                        }
-                    })
-                    .show();
-        } else {
-            friendPickerFragment.loadData(false);
-        }
-    }
-
-    private void onError(Exception error) {
-        new AlertDialog.Builder(this)
-                .setTitle(R.string.error_dialog_title)
-                .setMessage(error.getLocalizedMessage())
-                .setPositiveButton(R.string.error_ok_button, null)
-                .show();
-    }
-
-    private <T> T chooseOne(List<T> ts) {
-        for (T t : ts) {
-            return t;
-        }
-
-        return null;
-    }
-
-    private void onFriendSelectionChanged() {
-        GraphUser user = chooseOne(friendPickerFragment.getSelection());
-        if (user != null) {
-            friendId = user.getId();
-            onChooseFriend();
-        } else {
-            friendActivityAdapter.changeCursor(createEmptyCursor());
-        }
-    }
-
-    private void onChooseFriend() {
-        friendActivityProgressBar.setVisibility(View.VISIBLE);
-
-        String throwPath = String.format("%s/%s", friendId, ThrowAction.TYPE);
-        pendingRequest = new Request(Session.getActiveSession(),
-                throwPath,
-                null,
-                HttpMethod.GET,
-                new Request.Callback() {
-                    @Override
-                    public void onCompleted(Response response) {
-                        if (response.getRequest().equals(pendingRequest)) {
-                            FriendActivity.this.onPostExecute(response);
-                        }
-                    }
-                });
-        pendingRequest.executeAsync();
-    }
-
-    private void onPostExecute(Response response) {
-        friendActivityProgressBar.setVisibility(View.GONE);
-
-        friendActionList = createActionRows(response);
-        updateCursor(friendActionList);
-    }
-
-    private List<ActionRow> createActionRows(Response response) {
-        ArrayList<ActionRow> publishedItems = new ArrayList<ActionRow>();
-
-        if (response.getError() != null) {
-            return Collections.emptyList();
-        }
-
-        GraphMultiResult list = response.getGraphObjectAs(GraphMultiResult.class);
-        List<PublishedThrowAction> listData = list.getData().castToListOf(PublishedThrowAction.class);
-
-        for (PublishedThrowAction action : listData) {
-            publishedItems.add(createActionRow(action));
-        }
-
-        Collections.sort(publishedItems);
-        return publishedItems;
-    }
-
-    private void updateCursor(Iterable<ActionRow> publishedItems) {
-        MatrixCursor cursor = createEmptyCursor();
-        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
-
-        int id = 0;
-        for (ActionRow item : publishedItems) {
-            Object[] row = new Object[3];
-            row[0] = id++;
-            row[1] = dateFormat.format(item.publishDate);
-            row[2] = item.actionText;
-            cursor.addRow(row);
-        }
-
-        friendActivityAdapter.changeCursor(cursor);
-        friendActivityAdapter.notifyDataSetChanged();
-    }
-
-    private MatrixCursor createEmptyCursor() {
-        String[] cursorColumns = {"_ID", "date", "action"};
-        return new MatrixCursor(cursorColumns);
-    }
-
-    private ActionRow createActionRow(PublishedThrowAction action) {
-        String actionText = getActionText(action);
-        Date publishDate = action.getPublishTime();
-
-        return new ActionRow(actionText, publishDate);
-    }
-
-    private String getActionText(PublishedThrowAction action) {
-        ThrowAction actionData = action.getData();
-        if (actionData == null) {
-            return "";
-        }
-
-        GestureGraphObject playerGesture = actionData.getGesture();
-        GestureGraphObject opponentGesture = actionData.getOpposingGesture();
-
-        if ((playerGesture == null) || (opponentGesture == null)) {
-            return "";
-        }
-
-        String format = getString(R.string.action_display_format);
-        return String.format(format, playerGesture.getTitle(), opponentGesture.getTitle());
-    }
-
-    private static class ActionRow implements Comparable<ActionRow>, Parcelable {
-        final String actionText;
-        final Date publishDate;
-
-        ActionRow(String actionText, Date publishDate) {
-            this.actionText = actionText;
-            this.publishDate = publishDate;
-        }
-
-        @Override
-        public int compareTo(ActionRow other) {
-            if (other == null) {
-                return 1;
-            } else {
-                return publishDate.compareTo(other.publishDate);
-            }
-        }
-
-        @Override
-        public int describeContents() {
-            return 0;
-        }
-
-        @Override
-        public void writeToParcel(Parcel parcel, int flags) {
-            parcel.writeString(actionText);
-            parcel.writeLong(publishDate.getTime());
-        }
-
-        @SuppressWarnings("unused")
-        public final Creator<ActionRow> CREATOR = new Creator<ActionRow>() {
-            @Override
-            public ActionRow createFromParcel(Parcel parcel) {
-                String actionText = parcel.readString();
-                Date publishDate = new Date(parcel.readLong());
-                return new ActionRow(actionText, publishDate);
-            }
-
-            @Override
-            public ActionRow[] newArray(int size) {
-                return new ActionRow[size];
-            }
-        };
-    }
-
-
-}
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java b/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
index 1740ecd2e..50a08fef8 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.rps;
@@ -23,17 +27,21 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
+import android.util.Log;
 import android.view.Menu;
 import android.view.MenuItem;
-import android.widget.Toast;
-import com.facebook.*;
 
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import bolts.AppLinks;
+import com.facebook.*;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.share.model.GameRequestContent;
+import com.facebook.share.widget.GameRequestDialog;
 
-import static com.facebook.samples.rps.RpsGameUtils.*;
+import static com.facebook.samples.rps.RpsGameUtils.INVALID_CHOICE;
 
 public class MainActivity extends FragmentActivity {
+    private static final String TAG = "MainActivity";
+
     static final int RPS = 0;
     static final int SETTINGS = 1;
     static final int CONTENT = 2;
@@ -41,27 +49,34 @@
 
     private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
     private MenuItem settings;
-    private MenuItem friends;
+    private MenuItem challenge;
     private MenuItem share;
+    private MenuItem message;
+    private MenuItem invite;
     private boolean isResumed = false;
-    private UiLifecycleHelper uiHelper;
-    private Session.StatusCallback callback = new Session.StatusCallback() {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            onSessionStateChange(session, state, exception);
-        }
-    };
     private boolean hasNativeLink = false;
+    private CallbackManager callbackManager;
+    private GameRequestDialog gameRequestDialog;
 
-    // the deep link url should be of the form http://some.path?fb_object_id=xxxxxxxxxx
-    private Pattern deepLinkPattern = Pattern.compile(".*fb_object_id=(\\d*)");
+    private AccessTokenTracker accessTokenTracker;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        uiHelper = new UiLifecycleHelper(this, callback);
-        uiHelper.onCreate(savedInstanceState);
+        FacebookSdk.sdkInitialize(this.getApplicationContext());
+
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                if (isResumed) {
+                    if (currentAccessToken == null) {
+                        showFragment(RPS, false);
+                    }
+                }
+            }
+        };
 
         setContentView(R.layout.main);
 
@@ -77,12 +92,37 @@ public void onCreate(Bundle savedInstanceState) {
         transaction.commit();
 
         hasNativeLink = handleNativeLink();
+
+        gameRequestDialog = new GameRequestDialog(this);
+        callbackManager = CallbackManager.Factory.create();
+        gameRequestDialog.registerCallback(
+                callbackManager,
+                new FacebookCallback<GameRequestDialog.Result>() {
+                    @Override
+                    public void onCancel() {
+                        Log.d(TAG, "Canceled");
+                    }
+
+                    @Override
+                    public void onError(FacebookException error) {
+                        Log.d(TAG, String.format("Error: %s", error.toString()));
+                    }
+
+                    @Override
+                    public void onSuccess(GameRequestDialog.Result result) {
+                        Log.d(TAG, "Success!");
+                        Log.d(TAG, "Request id: " + result.getRequestId());
+                        Log.d(TAG, "Recipients:");
+                        for (String recipient : result.getRequestRecipients()) {
+                            Log.d(TAG, recipient);
+                        }
+                    }
+                });
     }
 
     @Override
     public void onResume() {
         super.onResume();
-        uiHelper.onResume();
         isResumed = true;
 
         // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
@@ -93,26 +133,23 @@ public void onResume() {
     @Override
     public void onPause() {
         super.onPause();
-        uiHelper.onPause();
         isResumed = false;
+
+        // Call the 'deactivateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onPause methods of the primary Activities that an app may be launched into.
+        AppEventsLogger.deactivateApp(this);
     }
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        callbackManager.onActivityResult(requestCode, resultCode, data);
         super.onActivityResult(requestCode, resultCode, data);
-        uiHelper.onActivityResult(requestCode, resultCode, data);
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        uiHelper.onDestroy();
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        uiHelper.onSaveInstanceState(outState);
+        accessTokenTracker.stopTracking();
     }
 
     @Override
@@ -133,8 +170,10 @@ public boolean onPrepareOptionsMenu(Menu menu) {
         if (fragments[RPS].isVisible()) {
             if (menu.size() == 0) {
                 share = menu.add(R.string.share_on_facebook);
-                friends = menu.add(R.string.see_friends);
+                message = menu.add(R.string.send_with_messenger);
+                challenge = menu.add(R.string.challenge_friends);
                 settings = menu.add(R.string.check_settings);
+                invite = menu.add(R.string.invite_friends);
             }
             return true;
         } else {
@@ -149,72 +188,73 @@ public boolean onOptionsItemSelected(MenuItem item) {
         if (item.equals(settings)) {
             showFragment(SETTINGS, true);
             return true;
-        } else if (item.equals(friends)) {
-            Intent intent = new Intent();
-            intent.setClass(this, FriendActivity.class);
-            startActivity(intent);
+        } else if (item.equals(challenge)) {
+            GameRequestContent newGameRequestContent = new GameRequestContent.Builder()
+                    .setTitle(getString(R.string.challenge_dialog_title))
+                    .setMessage(getString(R.string.challenge_dialog_message))
+                    .build();
+
+            gameRequestDialog.show(this, newGameRequestContent);
+
             return true;
         } else if (item.equals(share)) {
             RpsFragment fragment = (RpsFragment) fragments[RPS];
             fragment.shareUsingNativeDialog();
             return true;
+        } else if (item.equals(message)) {
+            RpsFragment fragment = (RpsFragment) fragments[RPS];
+            fragment.shareUsingMessengerDialog();
+            return true;
+        } else if (item.equals(invite)) {
+            RpsFragment fragment = (RpsFragment) fragments[RPS];
+            fragment.presentAppInviteDialog();
         }
         return false;
     }
 
     private boolean handleNativeLink() {
-        Session existingSession = Session.getActiveSession();
-        // If we have a valid existing session, we'll use it; if not, open one using the provided Intent
-        // but do not cache the token (we don't want to use the same user identity the next time the
-        // app is run).
-        if (existingSession == null || !existingSession.isOpened()) {
-            AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(getIntent());
-            if (accessToken != null) {
-                Session newSession = new Session.Builder(this).setTokenCachingStrategy(new NonCachingTokenCachingStrategy())
-                        .build();
-                newSession.open(accessToken, null);
-
-                Session.setActiveSession(newSession);
-            }
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken == null) {
+            AccessToken.createFromNativeLinkingIntent(getIntent(),
+                    FacebookSdk.getApplicationId(), new AccessToken.AccessTokenCreationCallback(){
+
+                        @Override
+                        public void onSuccess(AccessToken token) {
+                            AccessToken.setCurrentAccessToken(token);
+                        }
+
+                        @Override
+                        public void onError(FacebookException error) {
+
+                        }
+                    });
         }
         // See if we have a deep link in addition.
-        int deepLinkContent = getDeepLinkContent(getIntent().getData());
-        if (deepLinkContent != INVALID_CHOICE) {
+        int appLinkGesture = getAppLinkGesture(getIntent());
+        if (appLinkGesture != INVALID_CHOICE) {
             ContentFragment fragment = (ContentFragment) fragments[CONTENT];
-            fragment.setContentIndex(deepLinkContent);
+            fragment.setContentIndex(appLinkGesture);
             return true;
         }
         return false;
     }
 
-    private int getDeepLinkContent(Uri deepLinkUri) {
-        if (deepLinkUri != null) {
-            String deepLink = deepLinkUri.toString();
-
-            Matcher matcher = deepLinkPattern.matcher(deepLink);
-            if (matcher.matches()) {
-                String objectId = matcher.group(1);
-                for (int i = 0; i < CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS.length; i++) {
-                    if (CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[i].equals(objectId)) {
-                        return i;
-                    }
-                }
-            }
-        }
+    private int getAppLinkGesture(Intent intent) {
+      Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
+      if (targetURI == null) {
         return INVALID_CHOICE;
-    }
-
-    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
-        if (isResumed) {
-            if (exception != null && !(exception instanceof FacebookOperationCanceledException)) {
-                Toast.makeText(this, R.string.login_error, Toast.LENGTH_SHORT).show();
-                return;
-            }
-
-            if (session.isClosed()) {
-                showFragment(RPS, false);
-            }
-        }
+      }
+      String gesture = targetURI.getQueryParameter("gesture");
+      if (gesture != null) {
+          if (gesture.equalsIgnoreCase(getString(R.string.rock))) {
+              return RpsGameUtils.ROCK;
+          } else if (gesture.equalsIgnoreCase(getString(R.string.paper))) {
+              return RpsGameUtils.PAPER;
+          } else if (gesture.equalsIgnoreCase(getString(R.string.scissors))) {
+              return RpsGameUtils.SCISSORS;
+          }
+      }
+      return INVALID_CHOICE;
     }
 
     void showFragment(int fragmentIndex, boolean addToBackStack) {
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphConsts.java b/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphConsts.java
new file mode 100644
index 000000000..ac8914151
--- /dev/null
+++ b/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphConsts.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.rps;
+
+public class OpenGraphConsts {
+    public static final String THROW_ACTION_TYPE = "fb_sample_rps:throw";
+    public static final String THROW_ACTION_PREVIEW_PROPERTY_NAME = "fb_sample_rps:gesture";
+
+    public static final String GAME_OBJECT_TYPE = "fb_sample_rps:game";
+
+    public static final String PLAY_ACTION_TYPE = "fb_sample_rps:play";
+}
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphUtils.java b/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphUtils.java
deleted file mode 100644
index ff030d4b7..000000000
--- a/samples/RPSSample/src/com/facebook/samples/rps/OpenGraphUtils.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.facebook.samples.rps;
-
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphUser;
-import com.facebook.model.OpenGraphAction;
-import com.facebook.model.OpenGraphObject;
-
-public class OpenGraphUtils {
-
-    /**
-     * Used to consume GraphUser objects with an installed field
-     */
-    public interface GraphUserWithInstalled extends GraphUser {
-        Boolean getInstalled();
-    }
-
-    /**
-     * Used to create and consume Gesture open graph objects
-     */
-    public interface GestureGraphObject extends OpenGraphObject {
-        String getTitle();
-    }
-
-    /**
-     * Used to create and consume Game open graph objects.
-     */
-    public interface GameGraphObject extends OpenGraphObject {
-        public static final String TYPE = "fb_sample_rps:game";
-
-        GestureGraphObject getPlayerGesture();
-        void setPlayerGesture(GestureGraphObject gesture);
-
-        GestureGraphObject getOpponentGesture();
-        void setOpponentGesture(GestureGraphObject gesture);
-
-        String getResult();
-        void setResult(String result);
-    }
-
-    /**
-     * Used to create and consume Play open graph actions
-     */
-    public interface PlayAction extends OpenGraphAction {
-        public static final String TYPE = "fb_sample_rps:play";
-        public static final String PATH = "me/" + TYPE;
-        public static final String PREVIEW_PROPERTY_NAME = "game";
-
-        GameGraphObject getGame();
-
-        void setGame(GameGraphObject game);
-    }
-
-    /**
-     * Used to create and consume Throw open graph actions
-     */
-    public interface ThrowAction extends OpenGraphAction {
-        public static final String TYPE = "fb_sample_rps:throw";
-        public static final String PREVIEW_PROPERTY_NAME = "gesture";
-
-        GestureGraphObject getGesture();
-        void setGesture(GestureGraphObject playerGesture);
-
-        GestureGraphObject getOpposingGesture();
-        void setOpposingGesture(GestureGraphObject opposingGesture);
-    }
-
-    /**
-     * Used to consume published Play open graph actions.
-     */
-    public interface PublishedPlayAction extends OpenGraphAction {
-        PlayAction getData();
-
-        String getType();
-    }
-
-    /**
-     * Used to consume published Throw open graph actions.
-     */
-    public interface PublishedThrowAction extends OpenGraphAction {
-        ThrowAction getData();
-
-        String getType();
-    }
-
-    /**
-     * Used to inspect the response from posting an action
-     */
-    public interface PostResponse extends GraphObject {
-        String getId();
-    }
-}
\ No newline at end of file
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/RpsFragment.java b/samples/RPSSample/src/com/facebook/samples/rps/RpsFragment.java
index 5627902e7..ad903d6e8 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/RpsFragment.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/RpsFragment.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.rps;
@@ -22,6 +26,7 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
@@ -31,23 +36,36 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.*;
-import com.facebook.*;
-import com.facebook.model.GraphObject;
-import static com.facebook.samples.rps.OpenGraphUtils.*;
-import static com.facebook.samples.rps.RpsGameUtils.*;
-
-import com.facebook.model.OpenGraphAction;
-import com.facebook.model.OpenGraphObject;
-import com.facebook.widget.FacebookDialog;
 
+import com.facebook.*;
+import com.facebook.login.DefaultAudience;
+import com.facebook.login.LoginManager;
+import com.facebook.login.LoginResult;
+import com.facebook.share.ShareApi;
+import com.facebook.share.Sharer;
+import com.facebook.share.model.ShareContent;
+import com.facebook.share.model.ShareLinkContent;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.ShareOpenGraphObject;
+import com.facebook.share.model.SharePhoto;
+import com.facebook.share.model.AppInviteContent;
+import com.facebook.share.widget.AppInviteDialog;
+import com.facebook.share.widget.MessageDialog;
+import com.facebook.share.widget.ShareDialog;
+
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Random;
 
+import static com.facebook.samples.rps.RpsGameUtils.*;
+
 public class RpsFragment extends Fragment {
 
-    private static final String SHARE_GAME_LINK = "https://developers.facebook.com/android";
+    private static final String SHARE_GAME_LINK = "https://developers.facebook.com/docs/android";
     private static final String SHARE_GAME_NAME = "Rock, Papers, Scissors Sample Application";
-    private static final String DEFAULT_GAME_OBJECT_TITLE = "an awesome game of Rock, Paper, Scissors";
+    private static final String DEFAULT_GAME_OBJECT_TITLE =
+            "an awesome game of Rock, Paper, Scissors";
     private static final String WIN_KEY = "wins";
     private static final String LOSS_KEY = "losses";
     private static final String TIE_KEY = "ties";
@@ -58,17 +76,13 @@
     private static final String PENDING_PUBLISH_KEY = "pending_publish";
     private static final String IMPLICIT_PUBLISH_KEY = "implicitly_publish";
     private static final String ADDITIONAL_PERMISSIONS = "publish_actions";
-    private static final String PHOTO_REQUEST_NAME = "photorequest";
-    private static final String PHOTO_REQUEST_RESULT = "{result=photorequest:$.uri}";
-    private static final String GAME_REQUEST_NAME = "gamerequest";
-    private static final String GAME_REQUEST_RESULT = "{result=gamerequest:$.id}";
     private static final int INITIAL_DELAY_MILLIS = 500;
     private static final int DEFAULT_DELAY_MILLIS = 1000;
     private static final String TAG = RpsFragment.class.getName();
 
-    private static String[] PHOTO_URIS = { null, null, null };
+    private static String[] PHOTO_URIS = {null, null, null};
 
-    private TextView [] gestureTextViews = new TextView[3];
+    private TextView[] gestureTextViews = new TextView[3];
     private TextView shootTextView;
     private ImageView playerChoiceView;
     private ImageView computerChoiceView;
@@ -77,7 +91,7 @@
     private ViewGroup resultGroup;
     private ViewGroup playerChoiceGroup;
     private Button againButton;
-    private ImageButton [] gestureImages = new ImageButton[3];
+    private ImageButton[] gestureImages = new ImageButton[3];
     private ImageButton fbButton;
     private TextView statsTextView;
     private ViewFlipper rpsFlipper;
@@ -93,36 +107,24 @@
     private Random random = new Random(System.currentTimeMillis());
     private boolean pendingPublish;
     private boolean shouldImplicitlyPublish = true;
-
-    private Session.StatusCallback newPermissionsCallback = new Session.StatusCallback() {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            if (exception != null ||
-                    !session.isOpened() ||
-                    !session.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
-                // this means the user did not grant us write permissions, so
-                // we don't do implicit publishes
-                shouldImplicitlyPublish = false;
-                pendingPublish = false;
-            } else {
-                publishResult();
-            }
-        }
-    };
+    private CallbackManager callbackManager;
+    private ShareDialog shareDialog;
+    private MessageDialog messageDialog;
+    private AppInviteDialog appInviteDialog;
 
     private DialogInterface.OnClickListener canPublishClickListener = new DialogInterface.OnClickListener() {
         @Override
         public void onClick(DialogInterface dialogInterface, int i) {
-            final Session session = Session.getActiveSession();
-            if (session != null && session.isOpened()) {
+            if (AccessToken.getCurrentAccessToken() != null) {
                 // if they choose to publish, then we request for publish permissions
                 shouldImplicitlyPublish = true;
                 pendingPublish = true;
-                Session.NewPermissionsRequest newPermissionsRequest =
-                        new Session.NewPermissionsRequest(RpsFragment.this, ADDITIONAL_PERMISSIONS)
-                                .setDefaultAudience(SessionDefaultAudience.FRIENDS)
-                                .setCallback(newPermissionsCallback);
-                session.requestNewPublishPermissions(newPermissionsRequest);
+
+                LoginManager.getInstance()
+                        .setDefaultAudience(DefaultAudience.FRIENDS)
+                        .logInWithPublishPermissions(
+                                RpsFragment.this,
+                                Arrays.asList(ADDITIONAL_PERMISSIONS));
             }
         }
     };
@@ -223,19 +225,19 @@ private void switchState(RpsState newState, boolean isOnResume) {
         currentState = newState;
     }
 
-    private void hideViews(View ... views) {
+    private void hideViews(View... views) {
         for (View view : views) {
             view.setVisibility(View.INVISIBLE);
         }
     }
 
-    private void showViews(View ... views) {
+    private void showViews(View... views) {
         for (View view : views) {
             view.setVisibility(View.VISIBLE);
         }
     }
 
-    private void enableViews(boolean enabled, View ... views) {
+    private void enableViews(boolean enabled, View... views) {
         for (View view : views) {
             view.setEnabled(enabled);
         }
@@ -267,9 +269,9 @@ private int getComputerChoice() {
     }
 
     private boolean canPublish() {
-        final Session session = Session.getActiveSession();
-        if (session != null && session.isOpened()) {
-            if (session.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
+        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
+            if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
                 // if we already have publish permissions, then go ahead and publish
                 return true;
             } else {
@@ -286,137 +288,171 @@ private boolean canPublish() {
         return false;
     }
 
-    private Request publishPlayerPhoto(final int choice) {
-        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), DRAWABLES_HUMAN[choice]);
-        Request request = Request.newUploadStagingResourceWithImageRequest(
-                Session.getActiveSession(),
-                bitmap,
-                new Request.Callback() {
-                    @Override
-                    public void onCompleted(Response response) {
-                        if (response.getError() != null) {
-                            Log.e(TAG, "photo staging upload failed: " + response.getError());
-                        } else {
-                            PHOTO_URIS[choice] = response.getGraphObject().getProperty("uri").toString();
-                        }
-                    }
-                });
-        request.setBatchEntryName(PHOTO_REQUEST_NAME);
-        request.setBatchEntryOmitResultOnSuccess(false);
-        return request;
+    private void showError(int messageId) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+        builder.setTitle(R.string.error_dialog_title).
+                setMessage(messageId).
+                setPositiveButton(R.string.error_ok_button, null);
+        builder.show();
     }
 
     private void publishResult() {
         if (shouldImplicitlyPublish && canPublish()) {
-            RequestBatch batch = new RequestBatch();
             String photoUri = PHOTO_URIS[playerChoice];
+            SharePhoto.Builder sharePhotoBuilder = new SharePhoto.Builder();
             if (photoUri == null) {
-                batch.add(publishPlayerPhoto(playerChoice));
-                photoUri = PHOTO_REQUEST_RESULT;
+                Bitmap bitmap = BitmapFactory.decodeResource(
+                        getResources(),
+                        DRAWABLES_HUMAN[playerChoice]);
+                sharePhotoBuilder.setBitmap(bitmap);
+            } else {
+                sharePhotoBuilder.setImageUrl(Uri.parse(photoUri));
             }
+            sharePhotoBuilder.setUserGenerated(false);
+            final SharePhoto gesturePhoto = sharePhotoBuilder.build();
+
+            ShareOpenGraphObject gameObject = createGameObject(gesturePhoto);
+            ShareOpenGraphAction playAction = createPlayActionWithGame(gameObject);
+            ShareOpenGraphContent content = new ShareOpenGraphContent.Builder()
+                    .setAction(playAction)
+                    .setPreviewPropertyName("game")
+                    .build();
+
+            ShareApi.share(content, new FacebookCallback<Sharer.Result>() {
+                @Override
+                public void onSuccess(Sharer.Result result) {
+                    Log.i(TAG, "Posted OG Action with id: " +
+                            result.getPostId());
+                }
 
-            GameGraphObject gameObject = createGameObject();
-            gameObject.setImageUrls(Arrays.asList(photoUri));
-
-            Request gameRequest = Request.newPostOpenGraphObjectRequest(Session.getActiveSession(), gameObject,
-                    new Request.Callback() {
-                        @Override
-                        public void onCompleted(Response response) {
-                            if (response.getError() != null) {
-                                Log.e(TAG, "game object creation failed: " + response.getError());
-                            }
-                        }
-                    });
-            gameRequest.setBatchEntryName(GAME_REQUEST_NAME);
-
-            batch.add(gameRequest);
-
-            PlayAction playAction = createPlayActionWithGame(GAME_REQUEST_RESULT);
-            Request playRequest = Request.newPostOpenGraphActionRequest(Session.getActiveSession(),
-                    playAction,
-                    new Request.Callback() {
-                        @Override
-                        public void onCompleted(Response response) {
-                            if (response.getError() != null) {
-                                Log.e(TAG, "Play action creation failed: " + response.getError());
-                            } else {
-                                PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
-                                Log.i(TAG, "Posted OG Action with id: " + postResponse.getId());
-                            }
-                        }
-                    });
+                @Override
+                public void onCancel() {
+                    // This should not happen
+                }
 
-            batch.add(playRequest);
-            batch.executeAsync();
+                @Override
+                public void onError(FacebookException error) {
+                    Log.e(TAG, "Play action creation failed: " + error.getMessage());
+                }
+            });
         }
     }
 
-    private GameGraphObject createGameObject() {
-        GameGraphObject gameGraphObject =
-                OpenGraphObject.Factory.createForPost(GameGraphObject.class, GameGraphObject.TYPE);
-        gameGraphObject.setTitle(DEFAULT_GAME_OBJECT_TITLE);
-        GraphObject dataObject = GraphObject.Factory.create();
-        dataObject.setProperty("player_gesture", CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[playerChoice]);
-        dataObject.setProperty("opponent_gesture", CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[computerChoice]);
-        dataObject.setProperty("result", getString(result.getResultStringId()));
-        gameGraphObject.setData(dataObject);
-        return gameGraphObject;
+    private ShareOpenGraphObject createGameObject(final SharePhoto gesturePhoto) {
+        return new ShareOpenGraphObject.Builder()
+                .putString("og:title", DEFAULT_GAME_OBJECT_TITLE)
+                .putString("og:type", "fb_sample_rps:game")
+                .putString("fb_sample_rps:player_gesture",
+                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[playerChoice])
+                .putString("fb_sample_rps:opponent_gesture",
+                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[computerChoice])
+                .putString("fb_sample_rps:result", getString(result.getResultStringId()))
+                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
+                    add(gesturePhoto);
+                }})
+                .build();
     }
 
-    private PlayAction createPlayActionWithGame(String game) {
-        PlayAction playAction = OpenGraphAction.Factory.createForPost(PlayAction.class, PlayAction.TYPE);
-        playAction.setProperty("game", game);
-        return playAction;
+    private ShareOpenGraphAction createPlayActionWithGame(ShareOpenGraphObject game) {
+        return new ShareOpenGraphAction.Builder()
+                .setActionType(OpenGraphConsts.PLAY_ACTION_TYPE)
+                .putObject("game", game).build();
     }
 
-    private GestureGraphObject getBuiltInGesture(int choice) {
+    private String getBuiltInGesture(int choice) {
         if (choice < 0 || choice >= CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS.length) {
             throw new IllegalArgumentException("Invalid choice");
         }
-        GestureGraphObject gesture =
-                GraphObject.Factory.create(GestureGraphObject.class);
-        gesture.setId(CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[choice]);
-        return gesture;
+
+        return CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[choice];
+    }
+
+    private ShareOpenGraphAction getThrowAction() {
+        // The OG objects have their own bitmaps we could rely on, but in order to demonstrate
+        // attaching an in-memory bitmap (e.g., a game screencap) we'll send the bitmap explicitly
+        // ourselves.
+        ImageButton view = gestureImages[playerChoice];
+        BitmapDrawable drawable = (BitmapDrawable) view.getBackground();
+        final Bitmap bitmap = drawable.getBitmap();
+
+        return new ShareOpenGraphAction.Builder()
+                .setActionType(OpenGraphConsts.THROW_ACTION_TYPE)
+                .putString("fb_sample_rps:gesture", getBuiltInGesture(playerChoice))
+                .putString("fb_sample_rps:opposing_gesture", getBuiltInGesture(computerChoice))
+                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
+                    add(new SharePhoto.Builder().setBitmap(bitmap).build());
+                }})
+                .build();
+    }
+
+    private ShareOpenGraphContent getThrowActionContent() {
+        return new ShareOpenGraphContent.Builder()
+                .setAction(getThrowAction())
+                .setPreviewPropertyName(OpenGraphConsts.THROW_ACTION_PREVIEW_PROPERTY_NAME)
+                .build();
+    }
+
+    private ShareLinkContent getLinkContent() {
+        return new ShareLinkContent.Builder()
+                .setContentTitle(SHARE_GAME_NAME)
+                .setContentUrl(Uri.parse(SHARE_GAME_LINK))
+                .build();
     }
 
     public void shareUsingNativeDialog() {
         if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
-            FacebookDialog.ShareDialogBuilder builder = new FacebookDialog.ShareDialogBuilder(getActivity())
-                    .setLink(SHARE_GAME_LINK)
-                    .setName(SHARE_GAME_NAME)
-                    .setFragment(this);
+            ShareContent content = getLinkContent();
+
+            // share the app
+            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
+                shareDialog.show(content, ShareDialog.Mode.NATIVE);
+            } else {
+                showError(R.string.native_share_error);
+            }
+        } else {
+            ShareContent content = getThrowActionContent();
+
+            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
+                shareDialog.show(content, ShareDialog.Mode.NATIVE);
+            } else {
+                showError(R.string.native_share_error);
+            }
+        }
+    }
+
+    public void shareUsingMessengerDialog() {
+        if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
+            ShareContent content = getLinkContent();
+
             // share the app
-            if (builder.canPresent()) {
-                builder.build().present();
+            if (messageDialog.canShow(content)) {
+                messageDialog.show(content);
             }
         } else {
-            ThrowAction throwAction = OpenGraphAction.Factory.createForPost(ThrowAction.class, ThrowAction.TYPE);
-            throwAction.setGesture(getBuiltInGesture(playerChoice));
-            throwAction.setOpposingGesture(getBuiltInGesture(computerChoice));
-
-            // The OG objects have their own bitmaps we could rely on, but in order to demonstrate attaching
-            // an in-memory bitmap (e.g., a game screencap) we'll send the bitmap explicitly ourselves.
-            ImageButton view = gestureImages[playerChoice];
-            BitmapDrawable drawable = (BitmapDrawable) view.getBackground();
-            Bitmap bitmap = drawable.getBitmap();
-
-            FacebookDialog.OpenGraphActionDialogBuilder builder = new FacebookDialog.OpenGraphActionDialogBuilder(
-                    getActivity(),
-                    throwAction,
-                    ThrowAction.PREVIEW_PROPERTY_NAME)
-                    .setFragment(this)
-                    .setImageAttachmentsForAction(Arrays.asList(bitmap));
-
-            // share the game play
-            if (builder.canPresent()) {
-                builder.build().present();
+            ShareContent content = getThrowActionContent();
+
+            if (messageDialog.canShow(content)) {
+                messageDialog.show(content);
             }
         }
     }
 
+    public void presentAppInviteDialog() {
+        AppInviteContent content = new AppInviteContent.Builder()
+                .setApplinkUrl("http://hosting-rps.parseapp.com/applink.html")
+                .setPreviewImageUrl("http://hosting-rps.parseapp.com/rps-preview-image.png")
+                .build();
+        if (AppInviteDialog.canShow()) {
+            appInviteDialog.show(this, content);
+        } else {
+            showError(R.string.appinvite_error);
+        }
+    }
 
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    public View onCreateView(LayoutInflater inflater,
+                             ViewGroup container,
+                             Bundle savedInstanceState) {
         super.onCreateView(inflater, container, savedInstanceState);
         View view = inflater.inflate(R.layout.rps_fragment, container, false);
 
@@ -490,13 +526,85 @@ public void onCreate(Bundle savedInstanceState) {
             pendingPublish = savedInstanceState.getBoolean(PENDING_PUBLISH_KEY);
             shouldImplicitlyPublish = savedInstanceState.getBoolean(IMPLICIT_PUBLISH_KEY);
         }
+        callbackManager = CallbackManager.Factory.create();
+        LoginManager.getInstance().registerCallback(
+                callbackManager,
+                new FacebookCallback<LoginResult>() {
+                    @Override
+                    public void onSuccess(LoginResult loginResult) {
+                        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+                        if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
+                            publishResult();
+                        } else {
+                            handleError();
+                        }
+                    }
+
+                    @Override
+                    public void onCancel() {
+                        handleError();
+                    }
+
+                    @Override
+                    public void onError(FacebookException exception) {
+                        handleError();
+                    }
+
+                    private void handleError() {
+                        // this means the user did not grant us write permissions, so
+                        // we don't do implicit publishes
+                        shouldImplicitlyPublish = false;
+                        pendingPublish = false;
+                    }
+                }
+        );
+
+        FacebookCallback<Sharer.Result> callback =
+                new FacebookCallback<Sharer.Result>() {
+                    @Override
+                    public void onCancel() {
+                        Log.d(TAG, "Canceled");
+                    }
+
+                    @Override
+                    public void onError(FacebookException error) {
+                        Log.d(TAG, String.format("Error: %s", error.toString()));
+                    }
+
+                    @Override
+                    public void onSuccess(Sharer.Result result) {
+                        Log.d(TAG, "Success!");
+                    }
+                };
+        shareDialog = new ShareDialog(this);
+        shareDialog.registerCallback(callbackManager, callback);
+        messageDialog = new MessageDialog(this);
+        messageDialog.registerCallback(callbackManager, callback);
+
+        FacebookCallback<AppInviteDialog.Result> appInviteCallback =
+                new FacebookCallback<AppInviteDialog.Result>() {
+                    @Override
+                    public void onSuccess(AppInviteDialog.Result result) {
+                        Log.d(TAG, "Success!");
+                    }
+
+                    @Override
+                    public void onCancel() {
+                        Log.d(TAG, "Canceled");
+                    }
+
+                    @Override
+                    public void onError(FacebookException error) {
+                        Log.d(TAG, String.format("Error: %s", error.toString()));
+                    }
+                };
+        appInviteDialog = new AppInviteDialog(this);
+        appInviteDialog.registerCallback(callbackManager, appInviteCallback);
     }
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (Session.getActiveSession() != null) {
-            Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
-        }
+        callbackManager.onActivityResult(requestCode, resultCode, data);
     }
 
     @Override
@@ -518,5 +626,4 @@ public void onSaveInstanceState(Bundle bundle) {
         bundle.putBoolean(PENDING_PUBLISH_KEY, pendingPublish);
         bundle.putBoolean(IMPLICIT_PUBLISH_KEY, shouldImplicitlyPublish);
     }
-
 }
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/RpsGameUtils.java b/samples/RPSSample/src/com/facebook/samples/rps/RpsGameUtils.java
index 5cf35dac6..b7f07f6c8 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/RpsGameUtils.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/RpsGameUtils.java
@@ -1,3 +1,23 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
 package com.facebook.samples.rps;
 
 public class RpsGameUtils {
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/usersettings/UserSettingsFragment.java b/samples/RPSSample/src/com/facebook/samples/rps/usersettings/UserSettingsFragment.java
new file mode 100644
index 000000000..a15c6181b
--- /dev/null
+++ b/samples/RPSSample/src/com/facebook/samples/rps/usersettings/UserSettingsFragment.java
@@ -0,0 +1,245 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.rps.usersettings;
+
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.CallbackManager;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.internal.ImageDownloader;
+import com.facebook.internal.ImageRequest;
+import com.facebook.internal.ImageResponse;
+import com.facebook.samples.rps.R;
+import com.facebook.login.widget.LoginButton;
+
+import org.json.JSONObject;
+
+/**
+ * A Fragment that displays a Login/Logout button as well as the user's
+ * profile picture and name when logged in.
+ */
+public final class UserSettingsFragment extends Fragment {
+
+    private static final String NAME = "name";
+    private static final String ID = "id";
+    private static final String PICTURE = "picture";
+    private static final String FIELDS = "fields";
+
+    private static final String REQUEST_FIELDS =
+            TextUtils.join(",", new String[] {ID, NAME, PICTURE});
+
+    private AccessTokenTracker accessTokenTracker;
+    private CallbackManager callbackManager;
+
+    private LoginButton loginButton;
+    private TextView connectedStateLabel;
+    private JSONObject user;
+    private Drawable userProfilePic;
+    private String userProfilePicID;
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                fetchUserInfo();
+                updateUI();
+
+            }
+        };
+        callbackManager = CallbackManager.Factory.create();
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        accessTokenTracker.stopTracking();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
+        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
+        loginButton.setFragment(this);
+
+        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);
+
+        // if no background is set for some reason, then default to Facebook blue
+        if (view.getBackground() == null) {
+            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+        } else {
+            view.getBackground().setDither(true);
+        }
+        return view;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    /**
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void onResume() {
+        super.onResume();
+        fetchUserInfo();
+        updateUI();
+    }
+
+    private void fetchUserInfo() {
+        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
+            GraphRequest request = GraphRequest.newMeRequest(
+                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
+                        @Override
+                        public void onCompleted(JSONObject me, GraphResponse response) {
+                            user = me;
+                            updateUI();
+                        }
+                    });
+            Bundle parameters = new Bundle();
+            parameters.putString(FIELDS, REQUEST_FIELDS);
+            request.setParameters(parameters);
+            GraphRequest.executeBatchAsync(request);
+        } else {
+            user = null;
+        }
+    }
+
+    private void updateUI() {
+        if (!isAdded()) {
+            return;
+        }
+        if (AccessToken.getCurrentAccessToken() != null) {
+            connectedStateLabel.setTextColor(getResources().getColor(
+                    R.color.usersettings_fragment_connected_text_color));
+            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
+                    getResources().getColor(
+                            R.color.usersettings_fragment_connected_shadow_color));
+
+            if (user != null) {
+                ImageRequest request = getImageRequest();
+                if (request != null) {
+                    Uri requestUri = request.getImageUri();
+                    // Do we already have the right picture? If so, leave it alone.
+                    if (!requestUri.equals(connectedStateLabel.getTag())) {
+                        if (user.optString("id").equals(userProfilePicID)) {
+                            connectedStateLabel.setCompoundDrawables(
+                                    null, userProfilePic, null, null);
+                            connectedStateLabel.setTag(requestUri);
+                        } else {
+                            ImageDownloader.downloadAsync(request);
+                        }
+                    }
+                }
+                connectedStateLabel.setText(user.optString("name"));
+            } else {
+                connectedStateLabel.setText(getResources().getString(
+                        R.string.usersettings_fragment_logged_in));
+                Drawable noProfilePic = getResources().getDrawable(
+                        R.drawable.profile_default_icon);
+                noProfilePic.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height));
+                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
+            }
+        } else {
+            int textColor = getResources().getColor(
+                    R.color.usersettings_fragment_not_connected_text_color);
+            connectedStateLabel.setTextColor(textColor);
+            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
+            connectedStateLabel.setText(getResources().getString(
+                    R.string.usersettings_fragment_not_logged_in));
+            connectedStateLabel.setCompoundDrawables(null, null, null, null);
+            connectedStateLabel.setTag(null);
+        }
+    }
+
+    private ImageRequest getImageRequest() {
+        ImageRequest request = null;
+        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                getActivity(),
+                ImageRequest.getProfilePictureUri(
+                        user.optString("id"),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height)));
+
+        request = requestBuilder.setCallerTag(this)
+                .setCallback(
+                        new ImageRequest.Callback() {
+                            @Override
+                            public void onCompleted(ImageResponse response) {
+                                processImageResponse(user.optString("id"), response);
+                            }
+                        })
+                .build();
+        return request;
+    }
+
+    private void processImageResponse(String id, ImageResponse response) {
+        if (response != null) {
+            Bitmap bitmap = response.getBitmap();
+            if (bitmap != null) {
+                BitmapDrawable drawable = new BitmapDrawable(
+                        UserSettingsFragment.this.getResources(), bitmap);
+                drawable.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height));
+                userProfilePic = drawable;
+                userProfilePicID = id;
+                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
+                connectedStateLabel.setTag(response.getRequest().getImageUri());
+            }
+        }
+    }
+}
diff --git a/samples/Scrumptious/.classpath b/samples/Scrumptious/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/Scrumptious/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/Scrumptious/.project b/samples/Scrumptious/.project
deleted file mode 100644
index a8c700a8a..000000000
--- a/samples/Scrumptious/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Scrumptious</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/Scrumptious/AndroidManifest.xml b/samples/Scrumptious/AndroidManifest.xml
index c4365dd21..9d014f8e2 100644
--- a/samples/Scrumptious/AndroidManifest.xml
+++ b/samples/Scrumptious/AndroidManifest.xml
@@ -1,9 +1,29 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.facebook.scrumptious"
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
+    <uses-sdk android:minSdkVersion="9"/>
     <uses-permission android:name="android.permission.INTERNET"/>
     <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
     <uses-permission android:name="android.permission.CAMERA"/>
@@ -11,10 +31,11 @@
     <uses-feature android:name="android.hardware.camera"/>
     <uses-feature android:name="android.hardware.camera.autofocus"/>
     <application android:label="@string/app_name"
-                 android:icon="@drawable/icon"
+                 android:icon="@drawable/add_food"
                  android:name=".ScrumptiousApplication">
         <activity android:name="MainActivity"
                   android:label="@string/app_name"
+                  android:theme="@style/Theme.Scrumptious"
                   android:windowSoftInputMode="adjustResize">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN"/>
@@ -23,11 +44,14 @@
         </activity>
         <activity android:name="PickerActivity"
                   android:label="@string/app_name" />
-        <activity android:name="com.facebook.LoginActivity"
+        <activity android:name="com.facebook.FacebookActivity"
                   android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
-        <provider android:authorities="com.facebook.app.NativeAppCallContentProvider233936543368280"
-                  android:name="com.facebook.NativeAppCallContentProvider" />
+        <meta-data android:name="com.facebook.sdk.ApplicationName" android:value="@string/app_name" />
+        <provider android:authorities="com.facebook.app.FacebookContentProvider233936543368280"
+                  android:name="com.facebook.FacebookContentProvider"
+                  android:exported="true" />
     </application>
 </manifest> 
diff --git a/samples/Scrumptious/ant.properties b/samples/Scrumptious/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/Scrumptious/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/Scrumptious/build.gradle b/samples/Scrumptious/build.gradle
index a2cda0280..41125c44d 100644
--- a/samples/Scrumptious/build.gradle
+++ b/samples/Scrumptious/build.gradle
@@ -1,16 +1,20 @@
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':facebook')
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
diff --git a/samples/Scrumptious/build.xml b/samples/Scrumptious/build.xml
deleted file mode 100644
index 7f943468f..000000000
--- a/samples/Scrumptious/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="Scrumptious" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/Scrumptious/project.properties b/samples/Scrumptious/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/Scrumptious/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/Scrumptious/res/drawable-hdpi/icon.png b/samples/Scrumptious/res/drawable-hdpi/icon.png
index 0320aeb54..383503ce9 100644
Binary files a/samples/Scrumptious/res/drawable-hdpi/icon.png and b/samples/Scrumptious/res/drawable-hdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-hdpi/picker_magnifier.png b/samples/Scrumptious/res/drawable-hdpi/picker_magnifier.png
new file mode 100644
index 000000000..0dcd013d6
Binary files /dev/null and b/samples/Scrumptious/res/drawable-hdpi/picker_magnifier.png differ
diff --git a/samples/Scrumptious/res/drawable-hdpi/placeholder_image.png b/samples/Scrumptious/res/drawable-hdpi/placeholder_image.png
new file mode 100644
index 000000000..7dec9eaf1
Binary files /dev/null and b/samples/Scrumptious/res/drawable-hdpi/placeholder_image.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/icon.png b/samples/Scrumptious/res/drawable-mdpi/icon.png
index 5c4b0095f..b14f00b4d 100644
Binary files a/samples/Scrumptious/res/drawable-mdpi/icon.png and b/samples/Scrumptious/res/drawable-mdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/logo.png b/samples/Scrumptious/res/drawable-mdpi/logo.png
new file mode 100644
index 000000000..a6f07865e
Binary files /dev/null and b/samples/Scrumptious/res/drawable-mdpi/logo.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/picker_magnifier.png b/samples/Scrumptious/res/drawable-mdpi/picker_magnifier.png
new file mode 100644
index 000000000..3013a5519
Binary files /dev/null and b/samples/Scrumptious/res/drawable-mdpi/picker_magnifier.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/placeholder_image.png b/samples/Scrumptious/res/drawable-mdpi/placeholder_image.png
new file mode 100644
index 000000000..79f4cb430
Binary files /dev/null and b/samples/Scrumptious/res/drawable-mdpi/placeholder_image.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/icon.png b/samples/Scrumptious/res/drawable-xhdpi/icon.png
index 796e14ec2..c86c5f0f3 100644
Binary files a/samples/Scrumptious/res/drawable-xhdpi/icon.png and b/samples/Scrumptious/res/drawable-xhdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/logo.png b/samples/Scrumptious/res/drawable-xhdpi/logo.png
new file mode 100644
index 000000000..aea4d819e
Binary files /dev/null and b/samples/Scrumptious/res/drawable-xhdpi/logo.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/picker_magnifier.png b/samples/Scrumptious/res/drawable-xhdpi/picker_magnifier.png
new file mode 100644
index 000000000..a5eb056a1
Binary files /dev/null and b/samples/Scrumptious/res/drawable-xhdpi/picker_magnifier.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/placeholder_image.png b/samples/Scrumptious/res/drawable-xhdpi/placeholder_image.png
new file mode 100644
index 000000000..b3ce31c10
Binary files /dev/null and b/samples/Scrumptious/res/drawable-xhdpi/placeholder_image.png differ
diff --git a/samples/Scrumptious/res/drawable/action_eating.png b/samples/Scrumptious/res/drawable/action_eating.png
deleted file mode 100644
index 7b951edf0..000000000
Binary files a/samples/Scrumptious/res/drawable/action_eating.png and /dev/null differ
diff --git a/samples/Scrumptious/res/drawable/action_location.png b/samples/Scrumptious/res/drawable/action_location.png
deleted file mode 100644
index 13dfe86ff..000000000
Binary files a/samples/Scrumptious/res/drawable/action_location.png and /dev/null differ
diff --git a/samples/Scrumptious/res/drawable/action_people.png b/samples/Scrumptious/res/drawable/action_people.png
deleted file mode 100644
index 19546267c..000000000
Binary files a/samples/Scrumptious/res/drawable/action_people.png and /dev/null differ
diff --git a/samples/Scrumptious/res/drawable/action_photo.png b/samples/Scrumptious/res/drawable/action_photo.png
deleted file mode 100644
index 46533cc70..000000000
Binary files a/samples/Scrumptious/res/drawable/action_photo.png and /dev/null differ
diff --git a/samples/Scrumptious/res/drawable/add_food.png b/samples/Scrumptious/res/drawable/add_food.png
new file mode 100644
index 000000000..aeb1ae315
Binary files /dev/null and b/samples/Scrumptious/res/drawable/add_food.png differ
diff --git a/samples/Scrumptious/res/drawable/add_friends.png b/samples/Scrumptious/res/drawable/add_friends.png
new file mode 100644
index 000000000..b728ebfd9
Binary files /dev/null and b/samples/Scrumptious/res/drawable/add_friends.png differ
diff --git a/samples/Scrumptious/res/drawable/add_location.png b/samples/Scrumptious/res/drawable/add_location.png
new file mode 100644
index 000000000..45a30b3e5
Binary files /dev/null and b/samples/Scrumptious/res/drawable/add_location.png differ
diff --git a/samples/Scrumptious/res/drawable/add_photo.png b/samples/Scrumptious/res/drawable/add_photo.png
new file mode 100644
index 000000000..f48ea0680
Binary files /dev/null and b/samples/Scrumptious/res/drawable/add_photo.png differ
diff --git a/samples/Scrumptious/res/drawable/button_border.xml b/samples/Scrumptious/res/drawable/button_border.xml
index 7d05c1fe2..64ea0ceb3 100644
--- a/samples/Scrumptious/res/drawable/button_border.xml
+++ b/samples/Scrumptious/res/drawable/button_border.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <shape xmlns:android="http://schemas.android.com/apk/res/android"
diff --git a/samples/Scrumptious/res/drawable/button_text_color.xml b/samples/Scrumptious/res/drawable/button_text_color.xml
new file mode 100644
index 000000000..84751a1ba
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/button_text_color.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+	<item 
+		android:state_enabled="false"
+		android:color="@color/disabled_button_color"/>
+    <item
+    	android:color="@color/scrumptious_main_orange"/>
+</selector>
diff --git a/samples/Scrumptious/res/drawable/facebook.png b/samples/Scrumptious/res/drawable/facebook.png
index daf8097b1..88c2ed6a8 100755
Binary files a/samples/Scrumptious/res/drawable/facebook.png and b/samples/Scrumptious/res/drawable/facebook.png differ
diff --git a/samples/Scrumptious/res/drawable/icon.png b/samples/Scrumptious/res/drawable/icon.png
index 5c4b0095f..739392fc0 100644
Binary files a/samples/Scrumptious/res/drawable/icon.png and b/samples/Scrumptious/res/drawable/icon.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_button_check.xml b/samples/Scrumptious/res/drawable/picker_button_check.xml
new file mode 100644
index 000000000..6f3d22950
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_button_check.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_checked="true" android:drawable="@drawable/picker_button_check_on" />
+  <item android:drawable="@drawable/picker_button_check_off" />
+</selector>
diff --git a/samples/Scrumptious/res/drawable/picker_button_check_off.png b/samples/Scrumptious/res/drawable/picker_button_check_off.png
new file mode 100644
index 000000000..c25695d53
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_button_check_off.png differ
diff --git a/facebook/res/drawable/com_facebook_button_check_on.png b/samples/Scrumptious/res/drawable/picker_button_check_on.png
similarity index 100%
rename from facebook/res/drawable/com_facebook_button_check_on.png
rename to samples/Scrumptious/res/drawable/picker_button_check_on.png
diff --git a/samples/Scrumptious/res/drawable/picker_item_background.xml b/samples/Scrumptious/res/drawable/picker_item_background.xml
new file mode 100644
index 000000000..e52cd305d
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_item_background.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. -->
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/picker_list_focused" />
+    <item                                                                                          android:drawable="@android:color/transparent" />
+</selector>
diff --git a/samples/Scrumptious/res/drawable/picker_list_divider.9.png b/samples/Scrumptious/res/drawable/picker_list_divider.9.png
new file mode 100644
index 000000000..4c0df0768
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_divider.9.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_list_focused.9.png b/samples/Scrumptious/res/drawable/picker_list_focused.9.png
new file mode 100644
index 000000000..3efadc352
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_focused.9.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_list_longpressed.9.png b/samples/Scrumptious/res/drawable/picker_list_longpressed.9.png
new file mode 100644
index 000000000..5fcd5b207
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_longpressed.9.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_list_pressed.9.png b/samples/Scrumptious/res/drawable/picker_list_pressed.9.png
new file mode 100644
index 000000000..0e557469e
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_pressed.9.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_list_section_header_background.9.png b/samples/Scrumptious/res/drawable/picker_list_section_header_background.9.png
new file mode 100644
index 000000000..0ee16ffb6
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_section_header_background.9.png differ
diff --git a/samples/Scrumptious/res/drawable/picker_list_selector.xml b/samples/Scrumptious/res/drawable/picker_list_selector.xml
new file mode 100644
index 000000000..ceb4f87de
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_list_selector.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
+
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/picker_list_focused" />
+
+</selector>
diff --git a/samples/Scrumptious/res/drawable/picker_list_selector_background_transition.xml b/samples/Scrumptious/res/drawable/picker_list_selector_background_transition.xml
new file mode 100644
index 000000000..935189b31
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_list_selector_background_transition.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<transition xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/picker_list_pressed"  />
+    <item android:drawable="@drawable/picker_list_longpressed"  />
+</transition>
diff --git a/samples/Scrumptious/res/drawable/picker_list_selector_disabled.9.png b/samples/Scrumptious/res/drawable/picker_list_selector_disabled.9.png
new file mode 100644
index 000000000..10851f6c8
Binary files /dev/null and b/samples/Scrumptious/res/drawable/picker_list_selector_disabled.9.png differ
diff --git a/facebook/res/drawable/com_facebook_place_default_icon.png b/samples/Scrumptious/res/drawable/picker_place_default_icon.png
similarity index 100%
rename from facebook/res/drawable/com_facebook_place_default_icon.png
rename to samples/Scrumptious/res/drawable/picker_place_default_icon.png
diff --git a/samples/Scrumptious/res/drawable/picker_selector_top_button.xml b/samples/Scrumptious/res/drawable/picker_selector_top_button.xml
new file mode 100644
index 000000000..6aed2827c
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_selector_top_button.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true"
+          android:drawable="@drawable/picker_top_button" />
+    <item android:state_focused="true"
+          android:drawable="@drawable/picker_top_button" />
+    <item android:state_selected="true"
+          android:drawable="@drawable/picker_top_button" />
+    <item
+            android:drawable="@drawable/picker_top_background" />
+</selector>
diff --git a/samples/Scrumptious/res/drawable/picker_top_background.xml b/samples/Scrumptious/res/drawable/picker_top_background.xml
new file mode 100644
index 000000000..49649c05b
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_top_background.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <gradient
+      android:startColor="#FF5975b0"
+      android:endColor="#FF47639e"
+      android:angle="270"/>
+</shape>
diff --git a/samples/Scrumptious/res/drawable/picker_top_button.xml b/samples/Scrumptious/res/drawable/picker_top_button.xml
new file mode 100644
index 000000000..098883e70
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/picker_top_button.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <gradient
+            android:startColor="#3f5b96"
+            android:endColor="#2d4984"
+            android:angle="270"/>
+</shape>
diff --git a/samples/Scrumptious/res/drawable/placeholder_image.png b/samples/Scrumptious/res/drawable/placeholder_image.png
new file mode 100644
index 000000000..c8948a1ce
Binary files /dev/null and b/samples/Scrumptious/res/drawable/placeholder_image.png differ
diff --git a/samples/Scrumptious/res/drawable/profile_default_icon.png b/samples/Scrumptious/res/drawable/profile_default_icon.png
new file mode 100644
index 000000000..15864ccdb
Binary files /dev/null and b/samples/Scrumptious/res/drawable/profile_default_icon.png differ
diff --git a/samples/Scrumptious/res/drawable/title_bar_logo.png b/samples/Scrumptious/res/drawable/title_bar_logo.png
new file mode 100644
index 000000000..3fe6e8b97
Binary files /dev/null and b/samples/Scrumptious/res/drawable/title_bar_logo.png differ
diff --git a/samples/Scrumptious/res/drawable/usersettings_facebook_logo.png b/samples/Scrumptious/res/drawable/usersettings_facebook_logo.png
new file mode 100644
index 000000000..161bef08b
Binary files /dev/null and b/samples/Scrumptious/res/drawable/usersettings_facebook_logo.png differ
diff --git a/samples/Scrumptious/res/drawable/usersettings_fragment_background_gradient.xml b/samples/Scrumptious/res/drawable/usersettings_fragment_background_gradient.xml
new file mode 100644
index 000000000..0a504ea55
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/usersettings_fragment_background_gradient.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+    <gradient
+      android:startColor="#5774B5"
+      android:endColor="#2C4988"
+      android:gradientRadius="495"
+      android:type="radial"/>
+</shape>    
diff --git a/samples/Scrumptious/res/layout-land/selection.xml b/samples/Scrumptious/res/layout-land/selection.xml
new file mode 100644
index 000000000..447bc9b6f
--- /dev/null
+++ b/samples/Scrumptious/res/layout-land/selection.xml
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <include layout="@layout/title_bar" />
+
+    <ScrollView
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:background="#FFF"
+        android:fillViewport="true">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <com.facebook.scrumptious.FullListView
+                android:id="@+id/selection_list"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_margin="20dp"
+                android:layout_weight="2"
+                android:divider="#00000000"
+                android:dividerHeight="@dimen/item_list_padding" />
+
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_margin="20dp"
+                android:layout_weight="1"
+                android:orientation="vertical">
+
+                <ImageView
+                    android:id="@+id/selected_image"
+                    android:layout_width="175dp"
+                    android:layout_height="175dp"
+                    android:layout_gravity="center_horizontal"
+                    android:layout_margin="5dp"
+                    android:contentDescription="@string/food_image_content_description"
+                    android:scaleType="fitCenter"
+                    android:src="@drawable/placeholder_image" />
+
+
+                <LinearLayout
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_horizontal"
+                    android:layout_margin="5dp"
+                    android:orientation="horizontal">
+
+                    <Button
+                        android:id="@+id/announce_text"
+                        style="@style/com_facebook_button"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_margin="5dp"
+                        android:text="@string/announce" />
+
+
+                    <com.facebook.share.widget.ShareButton
+                        android:id="@+id/share_button"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_margin="5dp" />
+
+
+                    <com.facebook.share.widget.SendButton
+                        android:id="@+id/message_button"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_margin="5dp" />
+                </LinearLayout>
+            </LinearLayout>
+        </LinearLayout>
+    </ScrollView>
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/listitem.xml b/samples/Scrumptious/res/layout/listitem.xml
index 293ef0c7e..9f12d7154 100644
--- a/samples/Scrumptious/res/layout/listitem.xml
+++ b/samples/Scrumptious/res/layout/listitem.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
@@ -23,9 +27,8 @@
 
     <ImageView
             android:id="@+id/icon"
-            android:src="@drawable/action_eating"
-            android:layout_width="60dp"
-            android:layout_height="60dp" />
+            android:layout_width="50dp"
+            android:layout_height="50dp" />
     <LinearLayout
             android:orientation="vertical"
             android:layout_gravity="center_vertical"
@@ -35,16 +38,16 @@
         <TextView
                 android:id="@+id/text1"
                 android:text="test"
-                android:textColor="#333"
+                android:textColor="#FB5820"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:textSize="18sp" />
+                android:textSize="16sp" />
         <TextView
                 android:id="@+id/text2"
                 android:text="test2"
-                android:textColor="#6699CC"
+                android:textColor="#E4C897"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:textSize="14sp" />
+                android:textSize="12sp" />
     </LinearLayout>
 </LinearLayout>
diff --git a/samples/Scrumptious/res/layout/main.xml b/samples/Scrumptious/res/layout/main.xml
index 9e4f89cfd..511aacf58 100644
--- a/samples/Scrumptious/res/layout/main.xml
+++ b/samples/Scrumptious/res/layout/main.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout
@@ -29,7 +33,7 @@
               android:id="@+id/splashFragment"
               android:layout_width="match_parent"
               android:layout_height="match_parent" />
-    <fragment android:name="com.facebook.widget.UserSettingsFragment"
+    <fragment android:name="com.facebook.scrumptious.usersettings.UserSettingsFragment"
               android:id="@+id/userSettingsFragment"
               android:layout_width="match_parent"
               android:layout_height="match_parent" />
diff --git a/samples/Scrumptious/res/layout/picker_activity_circle_row.xml b/samples/Scrumptious/res/layout/picker_activity_circle_row.xml
new file mode 100644
index 000000000..ceb3d92e2
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_activity_circle_row.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<RelativeLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="50dip"
+        android:layout_width="match_parent"
+        >
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_picker_row_activity_circle"
+                 style="@android:style/Widget.ProgressBar.Small"
+                 android:layout_centerInParent="true"
+                 android:visibility="visible"
+                 android:indeterminateOnly="true"
+            />
+</RelativeLayout>
diff --git a/samples/Scrumptious/res/layout/picker_checkbox.xml b/samples/Scrumptious/res/layout/picker_checkbox.xml
new file mode 100644
index 000000000..c2b2a6e5f
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_checkbox.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<CheckBox
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_checkbox"
+    android:layout_width="23dip"
+    android:layout_height="23dip"
+    android:focusable="false"
+    android:clickable="false"
+    android:button="@drawable/picker_button_check" />
diff --git a/samples/Scrumptious/res/layout/picker_friendpickerfragment.xml b/samples/Scrumptious/res/layout/picker_friendpickerfragment.xml
new file mode 100644
index 000000000..abdd3941c
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_friendpickerfragment.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:background="#FFFFFF">
+
+    <include layout="@layout/picker_title_bar_stub"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:divider="@drawable/picker_list_divider"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/samples/Scrumptious/res/layout/picker_image.xml b/samples/Scrumptious/res/layout/picker_image.xml
new file mode 100644
index 000000000..9cbb41bbb
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_image.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<ImageView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_image"
+    android:layout_width="50dip"
+    android:layout_height="50dip"
+    android:layout_gravity="center_vertical"
+    android:src="@drawable/profile_default_icon" />
diff --git a/samples/Scrumptious/res/layout/picker_list_row.xml b/samples/Scrumptious/res/layout/picker_list_row.xml
new file mode 100644
index 000000000..4e87484b0
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_list_row.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="wrap_content"
+        android:layout_width="match_parent"
+        >
+    <ViewStub
+            android:id="@+id/com_facebook_picker_profile_pic_stub"
+            android:inflatedId="@+id/com_facebook_picker_image"
+            android:layout="@layout/picker_image"
+            android:layout_width="50dip"
+            android:layout_height="50dip" />
+    <TextView
+            android:id="@+id/com_facebook_picker_title"
+            android:layout_width="100dip"
+            android:layout_height="50dip"
+            android:layout_weight="1.0"
+            android:paddingLeft="5dip"
+            android:textStyle="bold"
+            android:textColor="#000000"
+            android:singleLine="true"
+            android:ellipsize="end"
+            android:textSize="18sp"
+            android:gravity="left|center_vertical"/>
+    <ViewStub
+            android:id="@+id/com_facebook_picker_checkbox_stub"
+            android:inflatedId="@+id/com_facebook_picker_checkbox"
+            android:layout="@layout/picker_checkbox"
+            android:layout_width="23dip"
+            android:layout_height="23dip"
+            android:layout_marginRight="10dip"/>
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/picker_list_section_header.xml b/samples/Scrumptious/res/layout/picker_list_section_header.xml
new file mode 100644
index 000000000..ea3a4bba0
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_list_section_header.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_list_section_header"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:textStyle="bold"
+    android:background="@drawable/picker_list_section_header_background"
+    android:orientation="horizontal"
+    android:gravity="left|center_vertical"
+    android:textColor="#68768a"
+    android:textSize="17sp"
+    android:paddingLeft="8dip"
+    android:paddingBottom="0px"
+    android:shadowDx="1"
+    android:shadowDy="1"
+    android:shadowRadius="1"
+    android:shadowColor="#BFFFFFFF" />
diff --git a/samples/Scrumptious/res/layout/picker_placepickerfragment.xml b/samples/Scrumptious/res/layout/picker_placepickerfragment.xml
new file mode 100644
index 000000000..12a069d6d
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_placepickerfragment.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:background="#FFFFFF"
+              android:descendantFocusability="beforeDescendants"
+              android:focusableInTouchMode="true">
+
+    <include layout="@layout/picker_title_bar_stub"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:layout_alignParentTop="true"
+            android:divider="@null"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml b/samples/Scrumptious/res/layout/picker_placepickerfragment_list_row.xml
similarity index 67%
rename from facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
rename to samples/Scrumptious/res/layout/picker_placepickerfragment_list_row.xml
index 09de356e8..d20989c37 100644
--- a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
+++ b/samples/Scrumptious/res/layout/picker_placepickerfragment_list_row.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <RelativeLayout
@@ -33,10 +37,10 @@
             <ViewStub
                     android:id="@+id/com_facebook_picker_profile_pic_stub"
                     android:inflatedId="@+id/com_facebook_picker_image"
-                    android:layout="@layout/com_facebook_picker_image"
+                    android:layout="@layout/picker_image"
                     android:layout_gravity="left|center_vertical"
-                    android:layout_width="@dimen/com_facebook_picker_place_image_size"
-                    android:layout_height="@dimen/com_facebook_picker_place_image_size" />
+                    android:layout_width="@dimen/picker_place_image_size"
+                    android:layout_height="@dimen/picker_place_image_size" />
         </FrameLayout>
         <LinearLayout
                 android:orientation="vertical"
@@ -81,10 +85,10 @@
     </LinearLayout>
     <View
             android:layout_width="0dp"
-            android:layout_height="@dimen/com_facebook_picker_divider_width"
+            android:layout_height="@dimen/picker_divider_width"
             android:layout_alignParentLeft="true"
             android:layout_alignParentRight="true"
             android:layout_alignParentBottom="true"
-            android:background="@drawable/com_facebook_picker_default_separator_color"
+            android:background="@drawable/picker_default_separator_color"
             />
 </RelativeLayout>
diff --git a/samples/Scrumptious/res/layout/picker_search_bar_layout.xml b/samples/Scrumptious/res/layout/picker_search_bar_layout.xml
new file mode 100644
index 000000000..9846507de
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_search_bar_layout.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:id="@+id/com_facebook_search_bar_view"
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingTop="0dp"
+        android:paddingBottom="0dp"
+        android:paddingLeft="5dp"
+        android:paddingRight="5dp"
+        android:background="@color/picker_search_bar_background"
+        >
+    <EditText
+            android:id="@+id/com_facebook_picker_search_text"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_marginLeft="5dp"
+            android:singleLine="true"
+            android:layout_gravity="center"
+            android:gravity="center_vertical"
+            android:textSize="16sp"
+            android:textColor="@android:color/black"
+            android:textColorHint="@color/picker_search_bar_text"
+            android:background="@color/picker_search_bar_background"
+            android:drawableLeft="@drawable/picker_magnifier"
+            android:drawablePadding="5dp"
+            android:imeOptions="actionDone"
+            />
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/picker_search_box.xml b/samples/Scrumptious/res/layout/picker_search_box.xml
new file mode 100644
index 000000000..8f21217f4
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_search_box.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:orientation="vertical"
+        >
+    <include layout="@layout/picker_search_bar_layout" />
+    <View
+            android:layout_width="match_parent"
+            android:layout_height="@dimen/picker_divider_width"
+            android:background="@drawable/picker_default_separator_color"
+            />
+</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar.xml b/samples/Scrumptious/res/layout/picker_title_bar.xml
similarity index 52%
rename from facebook/res/layout/com_facebook_picker_title_bar.xml
rename to samples/Scrumptious/res/layout/picker_title_bar.xml
index ecadecac9..fe6b9e533 100644
--- a/facebook/res/layout/com_facebook_picker_title_bar.xml
+++ b/samples/Scrumptious/res/layout/picker_title_bar.xml
@@ -1,32 +1,36 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                 android:id="@+id/com_facebook_picker_top_bar"
-                android:layout_width="fill_parent"
+                android:layout_width="match_parent"
                 android:layout_height="48dp"
-                android:background="@drawable/com_facebook_top_background"
+                android:background="@drawable/picker_top_background"
                 android:gravity="right">
     <Button
             android:id="@+id/com_facebook_picker_done_button"
             android:layout_width="wrap_content"
             android:minWidth="55dp"
             android:layout_height="48dp"
-            android:background="@drawable/com_facebook_top_button"
+            android:background="@drawable/picker_selector_top_button"
             android:paddingLeft="5dip"
             android:paddingRight="5dip"
             android:textColor="#ffffff"
@@ -40,13 +44,15 @@
     <LinearLayout
             android:id="@+id/com_facebook_picker_divider"
             android:layout_width="1dp"
-            android:layout_height="fill_parent"
+            android:layout_height="match_parent"
             android:background="#40000000"
-            android:layout_alignLeft="@id/com_facebook_picker_done_button"/>
+            android:layout_alignLeft="@id/com_facebook_picker_done_button"
+            android:layout_alignStart="@id/com_facebook_picker_done_button"
+            android:orientation="horizontal"/>
     <TextView
             android:id="@+id/com_facebook_picker_title"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
             android:textSize="22sp"
             android:textColor="#FFFFFF"
             android:gravity="left|center_vertical"
diff --git a/samples/Scrumptious/res/layout/picker_title_bar_stub.xml b/samples/Scrumptious/res/layout/picker_title_bar_stub.xml
new file mode 100644
index 000000000..76fbf9b41
--- /dev/null
+++ b/samples/Scrumptious/res/layout/picker_title_bar_stub.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <ViewStub android:id="@+id/com_facebook_picker_title_bar_stub"
+              android:inflatedId="@+id/com_facebook_picker_title_bar"
+              android:layout="@layout/picker_title_bar"
+              android:layout_height="48dip"
+              android:layout_width="match_parent"/>
+
+</merge>
diff --git a/samples/Scrumptious/res/layout/pickers.xml b/samples/Scrumptious/res/layout/pickers.xml
index ef5a12619..fc6f506b2 100644
--- a/samples/Scrumptious/res/layout/pickers.xml
+++ b/samples/Scrumptious/res/layout/pickers.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
diff --git a/samples/Scrumptious/res/layout/selection.xml b/samples/Scrumptious/res/layout/selection.xml
index 3367e4840..57333d479 100644
--- a/samples/Scrumptious/res/layout/selection.xml
+++ b/samples/Scrumptious/res/layout/selection.xml
@@ -1,71 +1,93 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
 
-<ScrollView
-        xmlns:android="http://schemas.android.com/apk/res/android"
-        xmlns:facebook="http://schemas.android.com/apk/res-auto"
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
-        android:background="#FFF">
-    <LinearLayout
+    <include layout="@layout/title_bar"/>
+
+    <ScrollView
         android:layout_width="fill_parent"
         android:layout_height="fill_parent"
-        android:orientation="vertical">
+        android:background="#FFF"
+        android:fillViewport="true">
 
         <LinearLayout
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:layout_marginTop="20dp"
-            android:gravity="center_horizontal"
-            android:orientation="horizontal" >
-            <com.facebook.widget.ProfilePictureView
-                android:id="@+id/selection_profile_pic"
-                android:layout_height="wrap_content"
-                android:layout_width="wrap_content"
-                android:layout_gravity="center"
-                android:gravity="center_horizontal"
-                facebook:preset_size="small" />
-            <TextView
-                android:id="@+id/selection_user_name"
-                android:layout_width="wrap_content"
+            android:orientation="vertical">
+
+            <com.facebook.scrumptious.FullListView
+                android:id="@+id/selection_list"
+                android:layout_width="fill_parent"
                 android:layout_height="wrap_content"
-                android:layout_marginLeft="10dp"
-                android:layout_gravity="center"
-                android:textColor="#333"
-                android:textSize="18sp" />
-        </LinearLayout>
+                android:layout_margin="20dp"
+                android:divider="#00000000"
+                android:dividerHeight="@dimen/item_list_padding" />
 
-        <com.facebook.scrumptious.FullListView
-            android:id="@+id/selection_list"
+        <LinearLayout
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
-            android:layout_margin="20dp"
-            android:background="@drawable/button_border"/>
+            android:orientation="horizontal">
+            <ImageView
+                android:id="@+id/selected_image"
+                android:src="@drawable/placeholder_image"
+                android:layout_width="fill_parent"
+                android:layout_height="200dp"
+                android:layout_marginLeft="10dp"
+                android:layout_marginRight="10dp"
+                android:layout_weight="1"
+                android:scaleType="fitCenter"
+                android:contentDescription="@string/food_image_content_description"/>
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical"
+                android:gravity="end"
+                android:layout_weight="2">
+                <Button
+                    android:id="@+id/announce_text"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center"
+                    android:layout_margin="5dp"
+                    android:text="@string/announce"
+                    style="@style/com_facebook_button"/>
+                <com.facebook.share.widget.ShareButton
+                    android:id="@+id/share_button"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_margin="5dp"
+                    android:layout_gravity="center"/>
+                <com.facebook.share.widget.SendButton
+                    android:id="@+id/message_button"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center"
+                    android:layout_margin="5dp"/>
+                </LinearLayout>
+        </LinearLayout>
+        </LinearLayout>
+    </ScrollView>
+</LinearLayout>
 
-        <Button
-            android:id="@+id/announce_button"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center"
-            android:textStyle="bold"
-            android:background="@drawable/button_border"
-            android:layout_marginBottom="20dp"
-            android:text="@string/announce"
-            android:gravity="center" />
 
-    </LinearLayout>
-</ScrollView>
diff --git a/samples/Scrumptious/res/layout/splash.xml b/samples/Scrumptious/res/layout/splash.xml
index b84d8e58f..058c7a97e 100644
--- a/samples/Scrumptious/res/layout/splash.xml
+++ b/samples/Scrumptious/res/layout/splash.xml
@@ -1,70 +1,45 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <ScrollView
     xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="#303040" >
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true"
+    android:background="#FB5820" >
 
     <LinearLayout
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
         android:orientation="vertical">
 
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="30dp"
-            android:gravity="center_horizontal"
-            android:orientation="horizontal" >
-            <ImageView
-                android:id="@+id/splash_icon"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center"
-                android:layout_marginRight="10dp"
-                android:gravity="center"
-                android:src="@drawable/icon" />
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center"
-                android:gravity="center"
-                android:textColor="#AFDEFE"
-                android:textSize="28sp"
-                android:typeface="serif"
-                android:textStyle="italic"
-                android:text="@string/app_name" />
-        </LinearLayout>
-
+    	<ImageView 
+    		android:layout_width="match_parent"
+    		android:layout_height="0dp"
+    		android:layout_weight="1"
+    		android:layout_gravity="center"
+    		android:padding="50dp"
+    		android:src="@drawable/logo"/>
 
-        <TextView
-            android:id="@+id/profile_name"
-            android:layout_width="174dp"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="35dp"
-            android:lines="2"
-            android:textSize="17sp"
-            android:text="@string/get_started"
-            android:layout_gravity="center_horizontal"
-            android:gravity="center_horizontal"/>
-
-        <com.facebook.widget.LoginButton
+        <com.facebook.login.widget.LoginButton
             android:id="@+id/login_button"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
@@ -72,18 +47,16 @@
             android:layout_marginTop="30dp"
             android:layout_marginBottom="30dp" />
 
-        <Button
+        <TextView
             android:id="@+id/skip_login_button"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:layout_gravity="center_horizontal"
             android:text="@string/skip_login"
-            android:background="@drawable/com_facebook_loginbutton_silver"
-            android:textSize="@dimen/com_facebook_loginview_text_size"
-            android:textColor="@color/com_facebook_blue"
+            android:textSize="12sp"
+            android:textColor="#EAFEA7"
             android:paddingLeft="20dp"
             android:paddingRight="20dp"
-            android:layout_marginTop="30dp"
             android:layout_marginBottom="30dp" />
 
     </LinearLayout>
diff --git a/samples/Scrumptious/res/layout/title_bar.xml b/samples/Scrumptious/res/layout/title_bar.xml
new file mode 100644
index 000000000..e7ef3699d
--- /dev/null
+++ b/samples/Scrumptious/res/layout/title_bar.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:facebook="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="60dp"
+    android:background="@color/scrumptious_main_orange">
+
+    <ImageView
+        android:id="@+id/image_title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:layout_margin="16dp"
+        android:scaleType="fitCenter"
+        android:src="@drawable/title_bar_logo"
+        android:contentDescription="@string/logo_content_description"/>
+
+    <com.facebook.login.widget.ProfilePictureView
+        android:id="@+id/selection_profile_pic"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentEnd="true"
+        android:layout_centerVertical="true"
+        android:layout_margin="10dp"
+        android:gravity="end|center_vertical"
+        facebook:com_facebook_preset_size="small" />
+
+</RelativeLayout>
diff --git a/samples/Scrumptious/res/layout/usersettings_fragment.xml b/samples/Scrumptious/res/layout/usersettings_fragment.xml
new file mode 100644
index 000000000..3e9bd7cd4
--- /dev/null
+++ b/samples/Scrumptious/res/layout/usersettings_fragment.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:loginView="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@drawable/usersettings_fragment_background_gradient" >
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/usersettings_fragment_logo_image"
+            android:layout_width="193dp"
+            android:layout_height="44dp"
+            android:layout_gravity="center_horizontal"
+            android:src="@drawable/usersettings_facebook_logo"
+            android:layout_marginTop="35dp"
+            android:contentDescription="@string/usersettings_fragment_logo_content_description"/>
+
+        <TextView
+            android:id="@+id/usersettings_fragment_profile_name"
+            android:layout_width="match_parent"
+            android:layout_height="100dp"
+            android:lines="1"
+            android:textSize="16sp"
+            android:textStyle="bold"
+            android:layout_marginTop="35dp"
+            android:gravity="center"/>
+    
+        <com.facebook.login.widget.LoginButton
+            android:id="@+id/usersettings_fragment_login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="35dp"
+            android:layout_marginBottom="35dp"
+            loginView:com_facebook_login_text="@string/usersettings_fragment_log_in_button"
+            style="@style/com_facebook_loginview_silver_style" />
+    
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/Scrumptious/res/values-hdpi/dimens.xml b/samples/Scrumptious/res/values-hdpi/dimens.xml
new file mode 100644
index 000000000..2cbb2f58d
--- /dev/null
+++ b/samples/Scrumptious/res/values-hdpi/dimens.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <dimen name="picker_divider_width">1px</dimen>
+</resources>
diff --git a/samples/Scrumptious/res/values-ldpi/dimens.xml b/samples/Scrumptious/res/values-ldpi/dimens.xml
new file mode 100644
index 000000000..2cbb2f58d
--- /dev/null
+++ b/samples/Scrumptious/res/values-ldpi/dimens.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <dimen name="picker_divider_width">1px</dimen>
+</resources>
diff --git a/samples/Scrumptious/res/values-mdpi/dimens.xml b/samples/Scrumptious/res/values-mdpi/dimens.xml
new file mode 100644
index 000000000..2cbb2f58d
--- /dev/null
+++ b/samples/Scrumptious/res/values-mdpi/dimens.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <dimen name="picker_divider_width">1px</dimen>
+</resources>
diff --git a/samples/Scrumptious/res/values-xhdpi/dimens.xml b/samples/Scrumptious/res/values-xhdpi/dimens.xml
new file mode 100644
index 000000000..9d344308d
--- /dev/null
+++ b/samples/Scrumptious/res/values-xhdpi/dimens.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <dimen name="picker_divider_width">2px</dimen>
+</resources>
diff --git a/samples/Scrumptious/res/values/attrs.xml b/samples/Scrumptious/res/values/attrs.xml
new file mode 100644
index 000000000..0ab60ae6f
--- /dev/null
+++ b/samples/Scrumptious/res/values/attrs.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <declare-styleable name="picker_fragment">
+        <attr name="show_pictures" format="boolean"/>
+        <attr name="extra_fields" format="string"/>
+        <attr name="show_title_bar" format="boolean" />
+        <attr name="title_text" format="string" />
+        <attr name="done_button_text" format="string" />
+        <attr name="title_bar_background" format="reference" />
+        <attr name="done_button_background" format="reference" />
+    </declare-styleable>
+    <declare-styleable name="picker_friend_picker_fragment">
+        <attr name="multi_select" format="boolean"/>
+    </declare-styleable>
+    <declare-styleable name="picker_place_picker_fragment">
+        <attr name="radius_in_meters" format="integer"/>
+        <attr name="results_limit" format="integer"/>
+        <attr name="search_text" format="string"/>
+        <attr name="show_search_box" format="boolean" />
+    </declare-styleable>
+</resources>
diff --git a/samples/Scrumptious/res/values/colors.xml b/samples/Scrumptious/res/values/colors.xml
new file mode 100644
index 000000000..1ce7251ba
--- /dev/null
+++ b/samples/Scrumptious/res/values/colors.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <dimen name="picker_place_image_size">64dp</dimen>
+    <color name="picker_search_bar_background">#f5f5f7</color>
+    <color name="picker_search_bar_text">#bcbdc2</color>
+	<color name="scrumptious_main_orange">#FFFD5720</color>
+    <color name="disabled_button_color">#FFB7B7B7</color>
+</resources>
diff --git a/samples/Scrumptious/res/values/dimens.xml b/samples/Scrumptious/res/values/dimens.xml
new file mode 100644
index 000000000..c6db724a3
--- /dev/null
+++ b/samples/Scrumptious/res/values/dimens.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+	<dimen name="item_list_padding">14dp</dimen>
+</resources>
diff --git a/samples/Scrumptious/res/values/drawables.xml b/samples/Scrumptious/res/values/drawables.xml
new file mode 100644
index 000000000..cdb56f864
--- /dev/null
+++ b/samples/Scrumptious/res/values/drawables.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+    <drawable name="picker_default_separator_color">#33464c59</drawable>
+</resources>
diff --git a/samples/Scrumptious/res/values/strings.xml b/samples/Scrumptious/res/values/strings.xml
index c28e8df63..b7dd0cb88 100644
--- a/samples/Scrumptious/res/values/strings.xml
+++ b/samples/Scrumptious/res/values/strings.xml
@@ -1,29 +1,33 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
     <string name="app_name">Scrumptious</string>
     <string name="app_id">233936543368280</string>
     <string name="get_started">To get started, login using Facebook</string>
-    <string name="skip_login">Skip Login</string>
-    <string name="action_eating">What are you eating?</string>
-    <string name="action_location">Where are you?</string>
-    <string name="action_people">With whom?</string>
-    <string name="action_photo">Got a picture?</string>
+    <string name="skip_login">continue as a guest</string>
+    <string name="action_eating">Pick Meal</string>
+    <string name="action_location">Pick Location</string>
+    <string name="action_people">Pick Friends</string>
+    <string name="action_photo">Pick Photo</string>
     <string name="action_eating_default">Select a meal</string>
     <string name="action_location_default">Select a place</string>
     <string name="action_people_default">Select friends</string>
@@ -32,6 +36,11 @@
     <string name="action_photo_camera">Take Photo</string>
     <string name="action_photo_gallery">Choose Existing</string>
     <string name="announce">Announce</string>
+    <string name="picker_placepicker_subtitle_format">%1$s â€¢ %2$,d were here</string>
+    <string name="picker_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="picker_placepicker_subtitle_were_here_only_format">%1$,d were here</string>
+    <string name="picker_picker_done_button_text">Done</string>
+    <string name="message">Send with Messenger</string>
     <string name="login">Login</string>
     <string name="settings">Settings</string>
     <string name="select_meal">Select a meal</string>
@@ -48,17 +57,21 @@
     <string name="error_dialog_title">Something Went Wrong</string>
     <string name="error_dialog_button_text">OK</string>
     <string name="error_dialog_default_text">No response from server.</string>
-    <string name="no_location_error">Could not obtain your current location</string>
     <string name="select_picture">Select Picture</string>
-    <string name="error_authentication_retry">An error occurred that requires your attention. %1$s</string>
-    <string name="error_authentication_reopen">An error occurred, please re-login.</string>
-    <string name="error_permission">Please allow us to post on your behalf.</string>
-    <string name="error_server">The server is busy, please retry later.</string>
-    <string name="error_bad_request">An error occurred, please contact the developer with the following message: %1$s</string>
+    <string name="rejected_publish_permission">Publish permission rejected, canceling.</string>
+    <string name="error_transient">A temporary error occurred, please try again later.</string>
     <string name="error_unknown">An unknown error occurred, please contact the developer with the following message: %1$s</string>
     <string name="exception">Exception: %1$s</string>
     <string name="ok">OK</string>
     <string name="cancel">Cancel</string>
+    <string name="usersettings_fragment_log_in_button">Log in&#8230;</string>
+    <string name="usersettings_fragment_logged_in">Logged in</string>
+    <string name="usersettings_fragment_not_logged_in">Not logged in</string>
+    <string name="usersettings_fragment_logo_content_description">Facebook Logo</string>
+    <string name="logo_content_description">logo</string>
+    <string name="food_image_content_description">Food image</string>
+    <string name="choose_friends">Choose Friends</string>
+    <string name="nearby">Nearby</string>
 
     <string-array name="food_types">
         <item>Cheeseburger</item>
@@ -73,14 +86,14 @@
     </string-array>
 
     <string-array name="food_og_urls">
-        <item>http://samples.ogp.me/314483151980285</item> <!-- Cheeseburger -->
-        <item>http://samples.ogp.me/314483221980278</item> <!-- Pizza -->
-        <item>http://samples.ogp.me/314483265313607</item> <!-- Hotdog -->
-        <item>http://samples.ogp.me/314483348646932</item> <!-- Italian -->
-        <item>http://samples.ogp.me/314483375313596</item> <!-- French -->
-        <item>http://samples.ogp.me/314483421980258</item> <!-- Chinese -->
-        <item>http://samples.ogp.me/314483451980255</item> <!-- Thai -->
-        <item>http://samples.ogp.me/314483491980251</item> <!-- Indian -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/cheeseburger/</item> <!-- Cheeseburger -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/pizza/</item> <!-- Pizza -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/hotdog/</item> <!-- Hotdog -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/italian/</item> <!-- Italian -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/french/</item> <!-- French -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/chinese/</item> <!-- Chinese -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/thai/</item> <!-- Thai -->
+        <item>https://scrumptious-facebook.parseapp.com/meals/indian/</item> <!-- Indian -->
         <item></item>
     </string-array>
 </resources>
diff --git a/samples/Scrumptious/res/values/styles.xml b/samples/Scrumptious/res/values/styles.xml
new file mode 100644
index 000000000..2f4dfe586
--- /dev/null
+++ b/samples/Scrumptious/res/values/styles.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
+
+<resources>
+	<style name="Theme.Scrumptious" parent="android:Theme">
+        <item name="android:windowNoTitle">true</item>
+    </style>
+    <color name="usersettings_fragment_connected_text_color">#FFFFFF</color>
+    <color name="usersettings_fragment_connected_shadow_color">#000000</color>
+    <color name="usersettings_fragment_not_connected_text_color">#A6AED7</color>
+    <dimen name="usersettings_fragment_profile_picture_width">64dp</dimen>
+    <dimen name="usersettings_fragment_profile_picture_height">64dp</dimen>
+</resources>
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
index 735d73976..bc7b60612 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
@@ -21,7 +25,10 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.BaseAdapter;
-import com.facebook.model.OpenGraphAction;
+
+import com.facebook.share.model.ShareOpenGraphAction;
+
+import org.json.JSONObject;
 
 /**
  * Base class for a list element in the Scrumptious main display, consisting of an
@@ -130,9 +137,9 @@ public void setText2(String text2) {
     /**
      * Populate an OpenGraphAction with the results of this list element.
      *
-     * @param action the action to populate with data
+     * @param actionBuilder the builder to populate with data
      */
-    protected abstract void populateOGAction(OpenGraphAction action);
+    protected abstract void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder);
 
     /**
      * Callback if the OnClickListener happens to launch a new Activity.
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
index 66c1f83b9..354309716 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
@@ -1,23 +1,26 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
 
 import android.content.Context;
-import android.graphics.Rect;
 import android.util.AttributeSet;
 import android.view.View;
 import android.widget.ListAdapter;
@@ -54,9 +57,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
             height += childView.getMeasuredHeight();
         }
-        Rect bgPadding = new Rect();
-        getBackground().getPadding(bgPadding);
-        height += (count - 1) * getDividerHeight() + bgPadding.top + bgPadding.bottom;
+        height += getDividerHeight() * (count-1);
         setMeasuredDimension(width, height);
     }
 }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
index b1fcc58da..973b0a65e 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
@@ -22,12 +26,12 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
-import android.view.Menu;
-import android.view.MenuItem;
-import com.facebook.AppEventsLogger;
-import com.facebook.Session;
-import com.facebook.SessionState;
-import com.facebook.UiLifecycleHelper;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.FacebookSdk;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.CallbackManager;
 
 public class MainActivity extends FragmentActivity {
 
@@ -39,16 +43,10 @@
     private static final int FRAGMENT_COUNT = SETTINGS +1;
 
     private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
-    private MenuItem settings;
     private boolean isResumed = false;
     private boolean userSkippedLogin = false;
-    private UiLifecycleHelper uiHelper;
-    private Session.StatusCallback callback = new Session.StatusCallback() {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            onSessionStateChange(session, state, exception);
-        }
-    };
+    private AccessTokenTracker accessTokenTracker;
+    private CallbackManager callbackManager;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -57,8 +55,26 @@ public void onCreate(Bundle savedInstanceState) {
         if (savedInstanceState != null) {
             userSkippedLogin = savedInstanceState.getBoolean(USER_SKIPPED_LOGIN_KEY);
         }
-        uiHelper = new UiLifecycleHelper(this, callback);
-        uiHelper.onCreate(savedInstanceState);
+        callbackManager = CallbackManager.Factory.create();
+
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                if (isResumed) {
+                    FragmentManager manager = getSupportFragmentManager();
+                    int backStackSize = manager.getBackStackEntryCount();
+                    for (int i = 0; i < backStackSize; i++) {
+                        manager.popBackStack();
+                    }
+                    if (currentAccessToken != null) {
+                        showFragment(SELECTION, false);
+                    } else {
+                        showFragment(SPLASH, false);
+                    }
+                }
+            }
+        };
 
         setContentView(R.layout.main);
 
@@ -86,37 +102,40 @@ public void onSkipLoginPressed() {
     @Override
     public void onResume() {
         super.onResume();
-        uiHelper.onResume();
         isResumed = true;
 
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
+        // Call the 'activateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onResume methods of the primary Activities that an app may be
+        // launched into.
         AppEventsLogger.activateApp(this);
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        uiHelper.onPause();
         isResumed = false;
+
+        // Call the 'deactivateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onPause methods of the primary Activities that an app may be
+        // launched into.
+        AppEventsLogger.deactivateApp(this);
     }
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
-        uiHelper.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        uiHelper.onDestroy();
+        accessTokenTracker.stopTracking();
     }
 
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-        uiHelper.onSaveInstanceState(outState);
 
         outState.putBoolean(USER_SKIPPED_LOGIN_KEY, userSkippedLogin);
     }
@@ -124,65 +143,29 @@ protected void onSaveInstanceState(Bundle outState) {
     @Override
     protected void onResumeFragments() {
         super.onResumeFragments();
-        Session session = Session.getActiveSession();
 
-        if (session != null && session.isOpened()) {
-            // if the session is already open, try to show the selection fragment
+        if (AccessToken.getCurrentAccessToken() != null) {
+            // if the user already logged in, try to show the selection fragment
             showFragment(SELECTION, false);
             userSkippedLogin = false;
         } else if (userSkippedLogin) {
             showFragment(SELECTION, false);
         } else {
-            // otherwise present the splash screen and ask the user to login, unless the user explicitly skipped.
+            // otherwise present the splash screen and ask the user to login,
+            // unless the user explicitly skipped.
             showFragment(SPLASH, false);
         }
     }
 
-    @Override
-    public boolean onPrepareOptionsMenu(Menu menu) {
-        // only add the menu when the selection fragment is showing
-        if (fragments[SELECTION].isVisible()) {
-            if (menu.size() == 0) {
-                settings = menu.add(R.string.settings);
-            }
-            return true;
-        } else {
-            menu.clear();
-            settings = null;
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        if (item.equals(settings)) {
-            showSettingsFragment();
-            return true;
-        }
-        return false;
-    }
-
     public void showSettingsFragment() {
         showFragment(SETTINGS, true);
     }
 
-    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
-        if (isResumed) {
-            FragmentManager manager = getSupportFragmentManager();
-            int backStackSize = manager.getBackStackEntryCount();
-            for (int i = 0; i < backStackSize; i++) {
-                manager.popBackStack();
-            }
-            // check for the OPENED state instead of session.isOpened() since for the
-            // OPENED_TOKEN_UPDATED state, the selection fragment should already be showing.
-            if (state.equals(SessionState.OPENED)) {
-                showFragment(SELECTION, false);
-            } else if (state.isClosed()) {
-                showFragment(SPLASH, false);
-            }
-        }
+    public void showSplashFragment() {
+        showFragment(SPLASH, true);
     }
 
+
     private void showFragment(int fragmentIndex, boolean addToBackStack) {
         FragmentManager fm = getSupportFragmentManager();
         FragmentTransaction transaction = fm.beginTransaction();
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
index f4e2d48d4..b03592757 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
@@ -32,9 +36,9 @@
 import android.support.v4.app.FragmentManager;
 import android.widget.Toast;
 import com.facebook.FacebookException;
-import com.facebook.widget.FriendPickerFragment;
-import com.facebook.widget.PickerFragment;
-import com.facebook.widget.PlacePickerFragment;
+import com.facebook.scrumptious.picker.FriendPickerFragment;
+import com.facebook.scrumptious.picker.PickerFragment;
+import com.facebook.scrumptious.picker.PlacePickerFragment;
 
 /**
  * The PickerActivity enhances the Friend or Place Picker by adding a title
@@ -50,11 +54,6 @@
     private static final String SEARCH_TEXT = "Restaurant";
     private static final int LOCATION_CHANGE_THRESHOLD = 50; // meters
 
-    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {{
-            setLatitude(37.7750);
-            setLongitude(-122.4183);
-    }};
-
     private FriendPickerFragment friendPickerFragment;
     private PlacePickerFragment placePickerFragment;
     private LocationListener locationListener;
@@ -71,20 +70,22 @@ public void onCreate(Bundle savedInstanceState) {
 
         if (FRIEND_PICKER.equals(intentUri)) {
             if (savedInstanceState == null) {
-                friendPickerFragment = new FriendPickerFragment(args);
+                friendPickerFragment = new FriendPickerFragment();
+                friendPickerFragment.setSettingsFromBundle(args);
+                friendPickerFragment.setFriendPickerType(FriendPickerFragment.FriendPickerType.TAGGABLE_FRIENDS);
             } else {
                 friendPickerFragment = (FriendPickerFragment) manager.findFragmentById(R.id.picker_fragment);;
             }
 
             friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                 @Override
-                public void onError(PickerFragment<?> fragment, FacebookException error) {
+                public void onError(PickerFragment fragment, FacebookException error) {
                     PickerActivity.this.onError(error);
                 }
             });
             friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                 @Override
-                public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                public void onDoneButtonClicked(PickerFragment fragment) {
                     finishActivity();
                 }
             });
@@ -92,25 +93,26 @@ public void onDoneButtonClicked(PickerFragment<?> fragment) {
 
         } else if (PLACE_PICKER.equals(intentUri)) {
             if (savedInstanceState == null) {
-                placePickerFragment = new PlacePickerFragment(args);
+                placePickerFragment = new PlacePickerFragment();
+                placePickerFragment.setSettingsFromBundle(args);
             } else {
                 placePickerFragment = (PlacePickerFragment) manager.findFragmentById(R.id.picker_fragment);
             }
             placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
                 @Override
-                public void onSelectionChanged(PickerFragment<?> fragment) {
+                public void onSelectionChanged(PickerFragment fragment) {
                     finishActivity(); // call finish since you can only pick one place
                 }
             });
             placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                 @Override
-                public void onError(PickerFragment<?> fragment, FacebookException error) {
+                public void onError(PickerFragment fragment, FacebookException error) {
                     PickerActivity.this.onError(error);
                 }
             });
             placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                 @Override
-                public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                public void onDoneButtonClicked(PickerFragment fragment) {
                     finishActivity();
                 }
             });
@@ -146,8 +148,12 @@ protected void onStart() {
                         locationListener = new LocationListener() {
                             @Override
                             public void onLocationChanged(Location location) {
-                                float distance = location.distanceTo(placePickerFragment.getLocation());
-                                if (distance >= LOCATION_CHANGE_THRESHOLD) {
+                                boolean updateLocation = true;
+                                Location prevLocation = placePickerFragment.getLocation();
+                                if (prevLocation != null) {
+                                    updateLocation = location.distanceTo(prevLocation) >= LOCATION_CHANGE_THRESHOLD;
+                                }
+                                if (updateLocation) {
                                     placePickerFragment.setLocation(location);
                                     placePickerFragment.loadData(true);
                                 }
@@ -166,21 +172,12 @@ public void onProviderDisabled(String s) {
                                 locationListener, Looper.getMainLooper());
                     }
                 }
-                if (location == null) {
-                    String model = Build.MODEL;
-                    if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
-                        // this may be the emulator, pretend we're in an exotic place
-                        location = SAN_FRANCISCO_LOCATION;
-                    }
-                }
                 if (location != null) {
                     placePickerFragment.setLocation(location);
                     placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
                     placePickerFragment.setSearchText(SEARCH_TEXT);
                     placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
                     placePickerFragment.loadData(false);
-                } else {
-                    onError(getResources().getString(R.string.no_location_error), true);
                 }
             } catch (Exception ex) {
                 onError(ex);
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
index ee4a4dd3e..18d0bfcab 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
@@ -1,24 +1,30 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
 
 import android.app.Application;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
+
+import com.facebook.FacebookSdk;
+
+import org.json.JSONObject;
 
 import java.util.List;
 
@@ -27,22 +33,28 @@
  */
 public class ScrumptiousApplication extends Application {
 
-    private List<GraphUser> selectedUsers;
-    private GraphPlace selectedPlace;
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        FacebookSdk.sdkInitialize(getApplicationContext());
+    }
+
+    private List<JSONObject> selectedUsers;
+    private JSONObject selectedPlace;
 
-    public List<GraphUser> getSelectedUsers() {
+    public List<JSONObject> getSelectedUsers() {
         return selectedUsers;
     }
 
-    public void setSelectedUsers(List<GraphUser> users) {
+    public void setSelectedUsers(List<JSONObject> users) {
         selectedUsers = users;
     }
 
-    public GraphPlace getSelectedPlace() {
+    public JSONObject getSelectedPlace() {
         return selectedPlace;
     }
 
-    public void setSelectedPlace(GraphPlace place) {
+    public void setSelectedPlace(JSONObject place) {
         this.selectedPlace = place;
     }
 }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
index 86265a074..a264fcbdf 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
@@ -1,17 +1,21 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
@@ -22,8 +26,10 @@
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
-import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
@@ -37,18 +43,33 @@
 import android.view.ViewGroup;
 import android.view.WindowManager;
 import android.widget.*;
+
 import com.facebook.*;
 import com.facebook.internal.Utility;
-import com.facebook.model.*;
-import com.facebook.widget.FacebookDialog;
-import com.facebook.widget.ProfilePictureView;
+import com.facebook.login.DefaultAudience;
+import com.facebook.login.LoginManager;
+import com.facebook.share.ShareApi;
+import com.facebook.share.Sharer;
+import com.facebook.share.model.ShareContent;
+import com.facebook.share.model.ShareOpenGraphContent;
+import com.facebook.share.model.ShareOpenGraphObject;
+import com.facebook.share.model.SharePhoto;
+import com.facebook.share.model.ShareOpenGraphAction;
+import com.facebook.share.widget.MessageDialog;
+import com.facebook.share.widget.SendButton;
+import com.facebook.share.widget.ShareButton;
+import com.facebook.login.widget.ProfilePictureView;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.io.*;
+import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Set;
+import java.util.UUID;
 
 /**
  * Fragment that represents the main selection screen for Scrumptious.
@@ -58,75 +79,79 @@
     private static final String TAG = "SelectionFragment";
     private static final String MEAL_OBJECT_TYPE = "fb_sample_scrumps:meal";
     private static final String EAT_ACTION_TYPE = "fb_sample_scrumps:eat";
-    private static final String DEFAULT_ACTION_IMAGE_URL =
-            "http://facebooksampleapp.com/scrumptious/static/images/logo.png";
 
     private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
-    private static final Uri M_FACEBOOK_URL = Uri.parse("http://m.facebook.com");
     private static final int USER_GENERATED_MIN_SIZE = 480;
+    private static final float MAX_TEXTURE_SIZE = 1024f;
 
-    private static final int REAUTH_ACTIVITY_CODE = 100;
     private static final String PERMISSION = "publish_actions";
 
-    private Button announceButton;
+    private TextView announceButton;
+    private ShareButton shareButton;
+    private SendButton messageButton;
     private ListView listView;
-    private ProgressDialog progressDialog;
     private List<BaseListElement> listElements;
     private ProfilePictureView profilePictureView;
-    private TextView userNameView;
     private boolean pendingAnnounce;
     private MainActivity activity;
+    private ProgressDialog announceProgressDialog;
+
     private Uri photoUri;
+    private ImageView photoThumbnail;
+    private ScaleAndSetImageTask runningImageTask;
 
-    private UiLifecycleHelper uiHelper;
-    private Session.StatusCallback sessionCallback = new Session.StatusCallback() {
-        @Override
-        public void call(final Session session, final SessionState state, final Exception exception) {
-            onSessionStateChange(session, state, exception);
-        }
-    };
-    private FacebookDialog.Callback nativeDialogCallback = new FacebookDialog.Callback() {
-        @Override
-        public void onComplete(FacebookDialog.PendingCall pendingCall, Bundle data) {
-            boolean resetSelections = true;
-            if (FacebookDialog.getNativeDialogDidComplete(data)) {
-                if (FacebookDialog.COMPLETION_GESTURE_CANCEL
-                        .equals(FacebookDialog.getNativeDialogCompletionGesture(data))) {
-                    // Leave selections alone if user canceled.
-                    resetSelections = false;
-                    showCancelResponse();
-                } else {
-                    showSuccessResponse(FacebookDialog.getNativeDialogPostId(data));
+    private CallbackManager callbackManager;
+    private AccessTokenTracker accessTokenTracker;
+    private FacebookCallback<Sharer.Result> shareCallback =
+            new FacebookCallback<Sharer.Result>() {
+                @Override
+                public void onCancel() {
+                    processDialogResults(null, true);
                 }
-            }
 
-            if (resetSelections) {
-                init(null);
-            }
-        }
+                @Override
+                public void onError(FacebookException error) {
+                    if (error instanceof FacebookGraphResponseException) {
+                        FacebookGraphResponseException graphError =
+                                (FacebookGraphResponseException) error;
+                        if (graphError.getGraphResponse() != null) {
+                            handleError(graphError.getGraphResponse());
+                            return;
+                        }
+                    }
+                    processDialogError(error);
+                }
 
-        @Override
-        public void onError(FacebookDialog.PendingCall pendingCall, Exception error, Bundle data) {
-            new AlertDialog.Builder(getActivity())
-                    .setPositiveButton(R.string.error_dialog_button_text, null)
-                    .setTitle(R.string.error_dialog_title)
-                    .setMessage(error.getLocalizedMessage())
-                    .show();
-        }
-    };
+                @Override
+                public void onSuccess(Sharer.Result result) {
+                    processDialogResults(result.getPostId(), false);
+                }
+            };
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         activity = (MainActivity) getActivity();
-        uiHelper = new UiLifecycleHelper(getActivity(), sessionCallback);
-        uiHelper.onCreate(savedInstanceState);
+        callbackManager = CallbackManager.Factory.create();
+
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                updateWithToken(currentAccessToken);
+            }
+        };
     }
 
-    @Override
-    public void onResume() {
-        super.onResume();
-        uiHelper.onResume();
+    private void updateWithToken(AccessToken currentAccessToken) {
+        if (currentAccessToken != null) {
+            tokenUpdated(currentAccessToken);
+            profilePictureView.setProfileId(currentAccessToken.getUserId());
+            announceButton.setVisibility(View.VISIBLE);
+        } else {
+            profilePictureView.setProfileId(null);
+            announceButton.setVisibility(View.GONE);
+        }
     }
 
     @Override
@@ -136,9 +161,18 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
 
         profilePictureView = (ProfilePictureView) view.findViewById(R.id.selection_profile_pic);
         profilePictureView.setCropped(true);
-        userNameView = (TextView) view.findViewById(R.id.selection_user_name);
-        announceButton = (Button) view.findViewById(R.id.announce_button);
+        announceButton = (TextView) view.findViewById(R.id.announce_text);
+        shareButton = (ShareButton) view.findViewById(R.id.share_button);
+        messageButton = (SendButton) view.findViewById(R.id.message_button);
         listView = (ListView) view.findViewById(R.id.selection_list);
+        photoThumbnail = (ImageView) view.findViewById(R.id.selected_image);
+
+        announceProgressDialog = new ProgressDialog(getActivity());
+        announceProgressDialog.setMessage(getString(R.string.progress_dialog_text));
+
+        if (MessageDialog.canShow(ShareOpenGraphContent.class)) {
+            messageButton.setVisibility(View.VISIBLE);
+        }
 
         announceButton.setOnClickListener(new View.OnClickListener() {
             @Override
@@ -147,7 +181,24 @@ public void onClick(View view) {
             }
         });
 
+        messageButton.registerCallback(callbackManager, shareCallback);
+        messageButton.setFragment(this);
+        shareButton.registerCallback(callbackManager, shareCallback);
+        shareButton.setFragment(this);
+
+        profilePictureView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (AccessToken.getCurrentAccessToken() != null) {
+                    activity.showSettingsFragment();
+                } else {
+                    activity.showSplashFragment();
+                }
+            }
+        });
+
         init(savedInstanceState);
+        updateWithToken(AccessToken.getCurrentAccessToken());
 
         return view;
     }
@@ -158,7 +209,7 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {
         if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
             listElements.get(requestCode).onActivityResult(data);
         } else {
-            uiHelper.onActivityResult(requestCode, resultCode, data, nativeDialogCallback);
+            callbackManager.onActivityResult(requestCode, resultCode, data);
         }
     }
 
@@ -169,68 +220,99 @@ public void onSaveInstanceState(Bundle bundle) {
             listElement.onSaveInstanceState(bundle);
         }
         bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
-        uiHelper.onSaveInstanceState(bundle);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        uiHelper.onPause();
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        uiHelper.onDestroy();
+        accessTokenTracker.stopTracking();
         activity = null;
     }
 
+    private void processDialogError(FacebookException error) {
+        enableButtons();
+        announceProgressDialog.dismiss();
+
+        if (error != null) {
+            new AlertDialog.Builder(getActivity())
+                    .setPositiveButton(R.string.error_dialog_button_text, null)
+                    .setTitle(R.string.error_dialog_title)
+                    .setMessage(error.getLocalizedMessage())
+                    .show();
+        }
+    }
+
+    private void processDialogResults(String postId, boolean isCanceled) {
+        enableButtons();
+        announceProgressDialog.dismiss();
+
+        boolean resetSelections = true;
+        if (isCanceled) {
+            // Leave selections alone if user canceled.
+            resetSelections = false;
+            showCancelResponse();
+        } else {
+            showSuccessResponse(postId);
+        }
+
+        if (resetSelections) {
+            init(null);
+        }
+    }
+
+    private void showRejectedPermissionError() {
+        new AlertDialog.Builder(getActivity())
+                .setPositiveButton(R.string.error_dialog_button_text, null)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(R.string.rejected_publish_permission)
+                .show();
+    }
+
     /**
-     * Notifies that the session token has been updated.
+     * Notifies that the token has been updated.
      */
-    private void tokenUpdated() {
+    private void tokenUpdated(AccessToken currentAccessToken) {
         if (pendingAnnounce) {
+            Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
+            if (currentAccessToken == null
+                    || !currentAccessToken.getPermissions().contains(PERMISSION)) {
+                pendingAnnounce = false;
+                showRejectedPermissionError();
+                return;
+            }
             handleAnnounce();
         }
     }
 
-    private void onSessionStateChange(final Session session, SessionState state, Exception exception) {
-        if (session != null && session.isOpened()) {
-            if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {
-                tokenUpdated();
-            } else {
-                makeMeRequest(session);
-            }
+    private void updateShareContent() {
+        ShareContent content = createOpenGraphContent();
+        if (content != null) {
+            enableButtons();
         } else {
-            profilePictureView.setProfileId(null);
-            userNameView.setText("");
+            disableButtons();
         }
+
+        shareButton.setShareContent(content);
+        messageButton.setShareContent(content);
     }
 
-    private void makeMeRequest(final Session session) {
-        Request request = Request.newMeRequest(session, new Request.GraphUserCallback() {
-            @Override
-            public void onCompleted(GraphUser user, Response response) {
-                if (session == Session.getActiveSession()) {
-                    if (user != null) {
-                        profilePictureView.setProfileId(user.getId());
-                        userNameView.setText(user.getName());
-                    }
-                }
-                if (response.getError() != null) {
-                    handleError(response.getError());
-                }
-            }
-        });
-        request.executeAsync();
+    private void disableButtons() {
+        announceButton.setEnabled(false);
+        shareButton.setEnabled(false);
+        messageButton.setEnabled(false);
+    }
 
+    private void enableButtons() {
+        announceButton.setEnabled(true);
+        shareButton.setEnabled(true);
+        messageButton.setEnabled(true);
     }
 
     /**
      * Resets the view to the initial defaults.
      */
     private void init(Bundle savedInstanceState) {
-        announceButton.setEnabled(false);
+        disableButtons();
 
         listElements = new ArrayList<BaseListElement>();
 
@@ -245,141 +327,72 @@ private void init(Bundle savedInstanceState) {
             }
             pendingAnnounce = savedInstanceState.getBoolean(PENDING_ANNOUNCE_KEY, false);
         }
+        ActionListAdapter listAdapter = new ActionListAdapter(
+                getActivity(),
+                R.id.selection_list,
+                listElements);
+        listAdapter.registerDataSetObserver(new DataSetObserver() {
+            @Override
+            public void onChanged() {
+                updateShareContent();
+            }
+        });
+        listView.setAdapter(listAdapter);
 
-        listView.setAdapter(new ActionListAdapter(getActivity(), R.id.selection_list, listElements));
-
-        Session session = Session.getActiveSession();
-        if (session != null && session.isOpened()) {
-            makeMeRequest(session);
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
+            profilePictureView.setProfileId(accessToken.getUserId());
         }
-    }
 
-    private void handleAnnounce() {
-        pendingAnnounce = false;
-        Session session = Session.getActiveSession();
-
-        // if we have a session, then use the graph API to directly publish, otherwise use
-        // the native open graph share dialog.
-        if (session != null && session.isOpened()) {
-            handleGraphApiAnnounce();
-        } else {
-            handleNativeShareAnnounce();
-        }
+        updateShareContent();
     }
 
-    private void handleGraphApiAnnounce() {
-        Session session = Session.getActiveSession();
-
-        List<String> permissions = session.getPermissions();
+    private void handleAnnounce() {
+        Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
         if (!permissions.contains(PERMISSION)) {
             pendingAnnounce = true;
-            requestPublishPermissions(session);
+            requestPublishPermissions();
             return;
-        }
-
-        // Show a progress dialog because sometimes the requests can take a while.
-        progressDialog = ProgressDialog.show(getActivity(), "",
-                getActivity().getResources().getString(R.string.progress_dialog_text), true);
-
-        // Run this in a background thread so we can process the list of responses and extract errors.
-        AsyncTask<Void, Void, List<Response>> task = new AsyncTask<Void, Void, List<Response>>() {
-
-            @Override
-            protected List<Response> doInBackground(Void... voids) {
-                EatAction eatAction = createEatAction();
-
-                RequestBatch requestBatch = new RequestBatch();
-
-                String photoStagingUri = null;
-
-                if (photoUri != null) {
-                    try {
-                        Pair<File, Integer> fileAndMinDimemsion = getImageFileAndMinDimension();
-                        if (fileAndMinDimemsion != null) {
-                            Request photoStagingRequest =
-                                    Request.newUploadStagingResourceWithImageRequest(Session.getActiveSession(),
-                                            fileAndMinDimemsion.first, null);
-                            photoStagingRequest.setBatchEntryName("photoStaging");
-                            requestBatch.add(photoStagingRequest);
-                            // Facebook SDK * pro-tip *
-                            // We can use the result from one request in the batch as the input to another request.
-                            // In this case, the result from the staging upload is "uri", which we will use as the
-                            // input into the "url" field for images on the open graph action below.
-                            photoStagingUri = "{result=photoStaging:$.uri}";
-                            eatAction.setImage(getImageListForAction(photoStagingUri,
-                                    fileAndMinDimemsion.second >= USER_GENERATED_MIN_SIZE));
-                        }
-                    } catch (FileNotFoundException e) {
-                        // NOOP - if we can't upload the image, just skip it for now
-                    }
-                }
-                MealGraphObject meal = eatAction.getMeal();
-                if (meal.getCreateObject()) {
-                    Request createObjectRequest =
-                            Request.newPostOpenGraphObjectRequest(Session.getActiveSession(), meal, null);
-                    createObjectRequest.setBatchEntryName("createObject");
-                    requestBatch.add(createObjectRequest);
-                    eatAction.setProperty("meal", "{result=createObject:$.id}");
-                }
-
-                Request request = Request.newPostOpenGraphActionRequest(Session.getActiveSession(), eatAction, null);
-                requestBatch.add(request);
-
-                return requestBatch.executeAndWait();
-            }
-
-            @Override
-            protected void onPostExecute(List<Response> responses) {
-                // We only care about the last response, or the first one with an error.
-                Response finalResponse = null;
-                for (Response response : responses) {
-                    finalResponse = response;
-                    if (response != null && response.getError() != null) {
-                        break;
-                    }
-                }
-                onPostActionResponse(finalResponse);
-            }
-        };
-
-        task.execute();
-    }
-
-    private void handleNativeShareAnnounce() {
-        FacebookDialog.OpenGraphActionDialogBuilder builder = createDialogBuilder();
-        if (builder.canPresent()) {
-            uiHelper.trackPendingDialogCall(builder.build().present());
         } else {
-            // If we can't show the native open graph share dialog because the Facebook app
-            // does not support it, then show then settings fragment so the user can log in.
-            activity.showSettingsFragment();
+            pendingAnnounce = false;
         }
+
+        disableButtons();
+        announceProgressDialog.show();
+        ShareApi.share(createOpenGraphContent(), shareCallback);
     }
 
-    private FacebookDialog.OpenGraphActionDialogBuilder createDialogBuilder() {
-        EatAction eatAction = createEatAction();
+    private ShareOpenGraphContent createOpenGraphContent() {
+        ShareOpenGraphAction.Builder actionBuilder = createEatActionBuilder();
 
         boolean userGenerated = false;
         if (photoUri != null) {
             String photoUriString = photoUri.toString();
-            Pair<File, Integer> fileAndMinDimemsion = getImageFileAndMinDimension();
-            userGenerated = fileAndMinDimemsion.second >= USER_GENERATED_MIN_SIZE;
-
-            // If we have a content: URI, we can just use that URI, otherwise we'll need to add it as an attachment.
-            if (fileAndMinDimemsion != null && photoUri.getScheme().startsWith("content")) {
-                eatAction.setImage(getImageListForAction(photoUriString, userGenerated));
+            Pair<File, Integer> fileAndMinDimension = getImageFileAndMinDimension();
+            userGenerated = fileAndMinDimension.second >= USER_GENERATED_MIN_SIZE;
+
+            if (fileAndMinDimension != null) {
+                final SharePhoto actionPhoto = new SharePhoto.Builder()
+                        .setImageUrl(Uri.parse(photoUriString))
+                        .setUserGenerated(userGenerated)
+                        .build();
+                actionBuilder.putPhotoArrayList("image", new ArrayList<SharePhoto>() {{
+                    add(actionPhoto);
+                }});
             }
         }
 
-        FacebookDialog.OpenGraphActionDialogBuilder builder = new FacebookDialog.OpenGraphActionDialogBuilder(
-                getActivity(), eatAction, "meal")
-                .setFragment(SelectionFragment.this);
+        return new ShareOpenGraphContent.Builder()
+                .setAction(actionBuilder.build())
+                .setPreviewPropertyName("meal")
+                .build();
+    }
 
-        if (photoUri != null && !photoUri.getScheme().startsWith("content")) {
-            builder.setImageAttachmentFilesForAction(Arrays.asList(new File(photoUri.getPath())), userGenerated);
-        }
+    private File getTempPhotoStagingDirectory() {
+        File photoDir = new File(getActivity().getCacheDir(), "photoFiles");
+        photoDir.mkdirs();
 
-        return builder;
+        return photoDir;
     }
 
     private Pair<File, Integer> getImageFileAndMinDimension() {
@@ -388,15 +401,40 @@ private void handleNativeShareAnnounce() {
         if (photoUriString.startsWith("file://")) {
             photoFile = new File(photoUri.getPath());
         } else if (photoUriString.startsWith("content://")) {
-            String [] filePath = { MediaStore.Images.Media.DATA };
-            Cursor cursor = getActivity().getContentResolver().query(photoUri, filePath, null, null, null);
-            if (cursor != null) {
-                cursor.moveToFirst();
-                int columnIndex = cursor.getColumnIndex(filePath[0]);
-                String filename = cursor.getString(columnIndex);
-                cursor.close();
-
-                photoFile = new File(filename);
+            FileOutputStream photoOutputStream = null;
+            InputStream contentInputStream = null;
+            try {
+                Uri photoUri = Uri.parse(photoUriString);
+                photoFile = new File(
+                        getTempPhotoStagingDirectory(),
+                        URLEncoder.encode(UUID.randomUUID().toString(), "UTF-8"));
+
+                photoOutputStream = new FileOutputStream(photoFile);
+                contentInputStream = getActivity()
+                        .getContentResolver().openInputStream(photoUri);
+
+                byte[] buffer = new byte[1024];
+                int len;
+                while ((len = contentInputStream.read(buffer)) > 0) {
+                    photoOutputStream.write(buffer, 0, len);
+                }
+            } catch (FileNotFoundException fnfe) {
+                Log.e(TAG, "photo not found", fnfe);
+            } catch (UnsupportedEncodingException uee) {
+                Log.e(TAG, "bad photo name", uee);
+            } catch (IOException ioe) {
+                Log.e(TAG, "can't copy photo", ioe);
+            } finally {
+                try {
+                    if (photoOutputStream != null) {
+                        photoOutputStream.close();
+                    }
+                    if (contentInputStream != null) {
+                        contentInputStream.close();
+                    }
+                } catch (IOException ioe) {
+                    Log.e(TAG, "can't close streams");
+                }
             }
         }
 
@@ -410,7 +448,8 @@ private void handleNativeShareAnnounce() {
                 options.inJustDecodeBounds = true;
                 BitmapFactory.decodeStream(is, null, options);
 
-                return new Pair<File, Integer>(photoFile, Math.min(options.outWidth, options.outHeight));
+                return new Pair<>(
+                        photoFile, Math.min(options.outWidth, options.outHeight));
             } catch (Exception e) {
                 return null;
             } finally {
@@ -420,67 +459,20 @@ private void handleNativeShareAnnounce() {
         return null;
     }
 
-    /**
-     * Creates a GraphObject with the following format:
-     * {
-     *     url: ${uri},
-     *     user_generated: true
-     * }
-     */
-    private GraphObject getImageObject(String uri, boolean userGenerated) {
-        GraphObject imageObject = GraphObject.Factory.create();
-        imageObject.setProperty("url", uri);
-        if (userGenerated) {
-            imageObject.setProperty("user_generated", "true");
-        }
-        return imageObject;
-    }
-
-    private List<JSONObject> getImageListForAction(String uri, boolean userGenerated) {
-        return Arrays.asList(getImageObject(uri, userGenerated).getInnerJSONObject());
-    }
-
-    private EatAction createEatAction() {
-        EatAction eatAction = OpenGraphAction.Factory.createForPost(EatAction.class, EAT_ACTION_TYPE);
+    private ShareOpenGraphAction.Builder createEatActionBuilder() {
+        ShareOpenGraphAction.Builder builder = new ShareOpenGraphAction.Builder()
+                .setActionType(EAT_ACTION_TYPE);
         for (BaseListElement element : listElements) {
-            element.populateOGAction(eatAction);
+            element.populateOpenGraphAction(builder);
         }
-        return eatAction;
-    }
 
-    private void requestPublishPermissions(Session session) {
-        if (session != null) {
-            Session.NewPermissionsRequest newPermissionsRequest = new Session.NewPermissionsRequest(this, PERMISSION)
-                    // demonstrate how to set an audience for the publish permissions,
-                    // if none are set, this defaults to FRIENDS
-                    .setDefaultAudience(SessionDefaultAudience.FRIENDS)
-                    .setRequestCode(REAUTH_ACTIVITY_CODE);
-            session.requestNewPublishPermissions(newPermissionsRequest);
-        }
+        return builder;
     }
 
-    private void onPostActionResponse(Response response) {
-        if (progressDialog != null) {
-            progressDialog.dismiss();
-            progressDialog = null;
-        }
-        if (getActivity() == null) {
-            // if the user removes the app from the website, then a request will
-            // have caused the session to close (since the token is no longer valid),
-            // which means the splash fragment will be shown rather than this one,
-            // causing activity to be null. If the activity is null, then we cannot
-            // show any dialogs, so we return.
-            return;
-        }
-
-        PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
-
-        if (postResponse != null && postResponse.getId() != null) {
-            showSuccessResponse(postResponse.getId());
-            init(null);
-        } else {
-            handleError(response.getError());
-        }
+    private void requestPublishPermissions() {
+        LoginManager.getInstance()
+                .setDefaultAudience(DefaultAudience.FRIENDS)
+                .logInWithPublishPermissions(this, Arrays.asList(PERMISSION));
     }
 
     private void showSuccessResponse(String postId) {
@@ -505,7 +497,8 @@ private void showResultDialog(String dialogBody) {
                 .show();
     }
 
-    private void handleError(FacebookRequestError error) {
+    private void handleError(GraphResponse response) {
+        FacebookRequestError error = response.getError();
         DialogInterface.OnClickListener listener = null;
         String dialogBody = null;
 
@@ -513,61 +506,16 @@ private void handleError(FacebookRequestError error) {
             dialogBody = getString(R.string.error_dialog_default_text);
         } else {
             switch (error.getCategory()) {
-                case AUTHENTICATION_RETRY:
-                    // tell the user what happened by getting the message id, and
-                    // retry the operation later
-                    String userAction = (error.shouldNotifyUser()) ? "" :
-                            getString(error.getUserActionMessageId());
-                    dialogBody = getString(R.string.error_authentication_retry, userAction);
-                    listener = new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            Intent intent = new Intent(Intent.ACTION_VIEW, M_FACEBOOK_URL);
-                            startActivity(intent);
-                        }
-                    };
-                    break;
+                case LOGIN_RECOVERABLE:
+                    // There is a login issue that can be resolved by the LoginManager.
+                    LoginManager.getInstance().resolveError(this, response);
+                    return;
 
-                case AUTHENTICATION_REOPEN_SESSION:
-                    // close the session and reopen it.
-                    dialogBody = getString(R.string.error_authentication_reopen);
-                    listener = new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            Session session = Session.getActiveSession();
-                            if (session != null && !session.isClosed()) {
-                                session.closeAndClearTokenInformation();
-                            }
-                        }
-                    };
-                    break;
-
-                case PERMISSION:
-                    // request the publish permission
-                    dialogBody = getString(R.string.error_permission);
-                    listener = new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            pendingAnnounce = true;
-                            requestPublishPermissions(Session.getActiveSession());
-                        }
-                    };
-                    break;
-
-                case SERVER:
-                case THROTTLING:
-                    // this is usually temporary, don't clear the fields, and
-                    // ask the user to try again
-                    dialogBody = getString(R.string.error_server);
-                    break;
-
-                case BAD_REQUEST:
-                    // this is likely a coding error, ask the user to file a bug
-                    dialogBody = getString(R.string.error_bad_request, error.getErrorMessage());
+                case TRANSIENT:
+                    dialogBody = getString(R.string.error_transient);
                     break;
 
                 case OTHER:
-                case CLIENT:
                 default:
                     // an unknown issue occurred, this could be a code error, or
                     // a server side issue, log the issue, and either ask the
@@ -577,10 +525,19 @@ public void onClick(DialogInterface dialogInterface, int i) {
             }
         }
 
+        String title = error.getErrorUserTitle();
+        String message = error.getErrorUserMessage();
+        if (message == null) {
+            message = dialogBody;
+        }
+        if (title == null) {
+            title = getResources().getString(R.string.error_dialog_title);
+        }
+
         new AlertDialog.Builder(getActivity())
                 .setPositiveButton(R.string.error_dialog_button_text, listener)
-                .setTitle(R.string.error_dialog_title)
-                .setMessage(dialogBody)
+                .setTitle(title)
+                .setMessage(message)
                 .show();
     }
 
@@ -591,32 +548,6 @@ private void startPickerActivity(Uri data, int requestCode) {
         startActivityForResult(intent, requestCode);
     }
 
-    /**
-     * Interface representing the Meal Open Graph object.
-     */
-    private interface MealGraphObject extends OpenGraphObject {
-        public String getUrl();
-        public void setUrl(String url);
-
-        public String getId();
-        public void setId(String id);
-    }
-
-    /**
-     * Interface representing the Eat action.
-     */
-    private interface EatAction extends OpenGraphAction {
-        public MealGraphObject getMeal();
-        public void setMeal(MealGraphObject meal);
-    }
-
-    /**
-     * Used to inspect the response from posting an action
-     */
-    private interface PostResponse extends GraphObject {
-        String getId();
-    }
-
     private class EatListElement extends BaseListElement {
 
         private static final String FOOD_KEY = "food";
@@ -628,9 +559,9 @@ private void startPickerActivity(Uri data, int requestCode) {
         private String foodChoice = null;
 
         public EatListElement(int requestCode) {
-            super(getActivity().getResources().getDrawable(R.drawable.action_eating),
+            super(getActivity().getResources().getDrawable(R.drawable.add_food),
                     getActivity().getResources().getString(R.string.action_eating),
-                    getActivity().getResources().getString(R.string.action_eating_default),
+                    null,
                     requestCode);
             foodChoices = getActivity().getResources().getStringArray(R.array.food_types);
             foodUrls = getActivity().getResources().getStringArray(R.array.food_og_urls);
@@ -647,19 +578,16 @@ public void onClick(View view) {
         }
 
         @Override
-        protected void populateOGAction(OpenGraphAction action) {
+        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
             if (foodChoice != null && foodChoice.length() > 0) {
-                EatAction eatAction = action.cast(EatAction.class);
-                eatAction.setImageUrls(Arrays.asList(DEFAULT_ACTION_IMAGE_URL));
                 if (foodChoiceUrl != null && foodChoiceUrl.length() > 0) {
-                    MealGraphObject meal = GraphObject.Factory.create(MealGraphObject.class);
-                    meal.setUrl(foodChoiceUrl);
-                    eatAction.setMeal(meal);
+                    actionBuilder.putString("meal", foodChoiceUrl);
                 } else {
-                    MealGraphObject meal = OpenGraphObject.Factory.createForPost(MealGraphObject.class,
-                            MEAL_OBJECT_TYPE);
-                    meal.setTitle(foodChoice);
-                    eatAction.setMeal(meal);
+                    ShareOpenGraphObject mealObject = new ShareOpenGraphObject.Builder()
+                            .putString("og:type", MEAL_OBJECT_TYPE)
+                            .putString("og:title", foodChoice)
+                            .build();
+                    actionBuilder.putObject("meal", mealObject);
                 }
             }
         }
@@ -729,17 +657,18 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     });
             AlertDialog dialog = builder.create();
             // always popup the keyboard when the alert dialog shows
-            dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+            dialog.getWindow().setSoftInputMode(
+                    WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
             dialog.show();
         }
 
         private void setFoodText() {
             if (foodChoice != null && foodChoice.length() > 0) {
                 setText2(foodChoice);
-                announceButton.setEnabled(true);
+                enableButtons();
             } else {
                 setText2(getActivity().getResources().getString(R.string.action_eating_default));
-                announceButton.setEnabled(false);
+                disableButtons();
             }
         }
     }
@@ -748,12 +677,12 @@ private void setFoodText() {
 
         private static final String FRIENDS_KEY = "friends";
 
-        private List<GraphUser> selectedUsers;
+        private List<JSONObject> selectedUsers;
 
         public PeopleListElement(int requestCode) {
-            super(getActivity().getResources().getDrawable(R.drawable.action_people),
+            super(getActivity().getResources().getDrawable(R.drawable.add_friends),
                     getActivity().getResources().getString(R.string.action_people),
-                    getActivity().getResources().getString(R.string.action_people_default),
+                    null,
                     requestCode);
         }
 
@@ -762,11 +691,10 @@ public PeopleListElement(int requestCode) {
             return new View.OnClickListener() {
                 @Override
                 public void onClick(View view) {
-                    if (Session.getActiveSession() != null &&
-                            Session.getActiveSession().isOpened()) {
+                    if (AccessToken.getCurrentAccessToken() != null) {
                         startPickerActivity(PickerActivity.FRIEND_PICKER, getRequestCode());
                     } else {
-                        activity.showSettingsFragment();
+                        activity.showSplashFragment();
                     }
                 }
             };
@@ -774,15 +702,21 @@ public void onClick(View view) {
 
         @Override
         protected void onActivityResult(Intent data) {
-            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedUsers();
+            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication())
+                    .getSelectedUsers();
             setUsersText();
             notifyDataChanged();
         }
 
         @Override
-        protected void populateOGAction(OpenGraphAction action) {
-            if (selectedUsers != null) {
-                action.setTags(selectedUsers);
+        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
+            if (selectedUsers != null && !selectedUsers.isEmpty()) {
+                String tags = "";
+                for (JSONObject user : selectedUsers) {
+                    tags += "," + user.optString("id");
+                }
+                tags = tags.substring(1);
+                actionBuilder.putString("tags", tags);
             }
         }
 
@@ -809,13 +743,14 @@ private void setUsersText() {
             if (selectedUsers != null) {
                 if (selectedUsers.size() == 1) {
                     text = String.format(getResources().getString(R.string.single_user_selected),
-                            selectedUsers.get(0).getName());
+                            selectedUsers.get(0).optString("name"));
                 } else if (selectedUsers.size() == 2) {
                     text = String.format(getResources().getString(R.string.two_users_selected),
-                            selectedUsers.get(0).getName(), selectedUsers.get(1).getName());
+                            selectedUsers.get(0).optString("name"),
+                            selectedUsers.get(1).optString("name"));
                 } else if (selectedUsers.size() > 2) {
                     text = String.format(getResources().getString(R.string.multiple_users_selected),
-                            selectedUsers.get(0).getName(), (selectedUsers.size() - 1));
+                            selectedUsers.get(0).optString("name"), (selectedUsers.size() - 1));
                 }
             }
             if (text == null) {
@@ -824,13 +759,13 @@ private void setUsersText() {
             setText2(text);
         }
 
-        private byte[] getByteArray(List<GraphUser> users) {
+        private byte[] getByteArray(List<JSONObject> users) {
             // convert the list of GraphUsers to a list of String where each element is
             // the JSON representation of the GraphUser so it can be stored in a Bundle
             List<String> usersAsString = new ArrayList<String>(users.size());
 
-            for (GraphUser user : users) {
-                usersAsString.add(user.getInnerJSONObject().toString());
+            for (JSONObject user : users) {
+                usersAsString.add(user.toString());
             }
             try {
                 ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
@@ -842,17 +777,16 @@ private void setUsersText() {
             return null;
         }
 
-        private List<GraphUser> restoreByteArray(byte[] bytes) {
+        private List<JSONObject> restoreByteArray(byte[] bytes) {
             try {
                 @SuppressWarnings("unchecked")
                 List<String> usersAsString =
-                        (List<String>) (new ObjectInputStream(new ByteArrayInputStream(bytes))).readObject();
+                        (List<String>) (new ObjectInputStream(
+                                new ByteArrayInputStream(bytes))).readObject();
                 if (usersAsString != null) {
-                    List<GraphUser> users = new ArrayList<GraphUser>(usersAsString.size());
+                    List<JSONObject> users = new ArrayList<JSONObject>(usersAsString.size());
                     for (String user : usersAsString) {
-                        GraphUser graphUser = GraphObject.Factory
-                                .create(new JSONObject(user), GraphUser.class);
-                        users.add(graphUser);
+                        users.add(new JSONObject(user));
                     }
                     return users;
                 }
@@ -868,15 +802,14 @@ private void setUsersText() {
     }
 
     private class LocationListElement extends BaseListElement {
-
         private static final String PLACE_KEY = "place";
 
-        private GraphPlace selectedPlace = null;
+        private JSONObject selectedPlace = null;
 
         public LocationListElement(int requestCode) {
-            super(getActivity().getResources().getDrawable(R.drawable.action_location),
+            super(getActivity().getResources().getDrawable(R.drawable.add_location),
                     getActivity().getResources().getString(R.string.action_location),
-                    getActivity().getResources().getString(R.string.action_location_default),
+                    null,
                     requestCode);
         }
 
@@ -885,11 +818,10 @@ public LocationListElement(int requestCode) {
             return new View.OnClickListener() {
                 @Override
                 public void onClick(View view) {
-                    if (Session.getActiveSession() != null &&
-                            Session.getActiveSession().isOpened()) {
+                    if (AccessToken.getCurrentAccessToken() != null) {
                         startPickerActivity(PickerActivity.PLACE_PICKER, getRequestCode());
                     } else {
-                        activity.showSettingsFragment();
+                        activity.showSplashFragment();
                     }
                 }
             };
@@ -897,22 +829,23 @@ public void onClick(View view) {
 
         @Override
         protected void onActivityResult(Intent data) {
-            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedPlace();
+            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication())
+                    .getSelectedPlace();
             setPlaceText();
             notifyDataChanged();
         }
 
         @Override
-        protected void populateOGAction(OpenGraphAction action) {
+        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
             if (selectedPlace != null) {
-                action.setPlace(selectedPlace);
+                actionBuilder.putString("place", selectedPlace.optString("id"));
             }
         }
 
         @Override
         protected void onSaveInstanceState(Bundle bundle) {
             if (selectedPlace != null) {
-                bundle.putString(PLACE_KEY, selectedPlace.getInnerJSONObject().toString());
+                bundle.putString(PLACE_KEY, selectedPlace.toString());
             }
         }
 
@@ -921,8 +854,7 @@ protected boolean restoreState(Bundle savedState) {
             String place = savedState.getString(PLACE_KEY);
             if (place != null) {
                 try {
-                    selectedPlace = GraphObject.Factory
-                            .create(new JSONObject(place), GraphPlace.class);
+                    selectedPlace = new JSONObject(place);
                     setPlaceText();
                     return true;
                 } catch (JSONException e) {
@@ -933,10 +865,7 @@ protected boolean restoreState(Bundle savedState) {
         }
 
         private void setPlaceText() {
-            String text = null;
-            if (selectedPlace != null) {
-                text = selectedPlace.getName();
-            }
+            String text = selectedPlace != null ? selectedPlace.optString("name") : null;
             if (text == null) {
                 text = getResources().getString(R.string.action_location_default);
             }
@@ -956,11 +885,19 @@ private void setPlaceText() {
         private Uri tempUri = null;
 
         public PhotoListElement(int requestCode) {
-            super(getActivity().getResources().getDrawable(R.drawable.action_photo),
+            super(getActivity().getResources().getDrawable(R.drawable.add_photo),
                     getActivity().getResources().getString(R.string.action_photo),
-                    getActivity().getResources().getString(R.string.action_photo_default),
+                    null,
                     requestCode);
             photoUri = null;
+            photoThumbnail.setImageDrawable(
+                    getActivity().getResources().getDrawable(R.drawable.placeholder_image));
+            photoThumbnail.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    showPhotoChoice();
+                }
+            });
         }
 
         @Override
@@ -980,11 +917,12 @@ protected void onActivityResult(Intent data) {
             } else if (data != null) {
                 photoUri = data.getData();
             }
+            setPhotoThumbnail();
             setPhotoText();
         }
 
         @Override
-        protected void populateOGAction(OpenGraphAction action) {
+        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
         }
 
         @Override
@@ -1010,16 +948,17 @@ private void showPhotoChoice() {
             CharSequence camera = getResources().getString(R.string.action_photo_camera);
             CharSequence gallery = getResources().getString(R.string.action_photo_gallery);
             builder.setCancelable(true).
-                    setItems(new CharSequence[] {camera, gallery}, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            if (i == CAMERA) {
-                                startCameraActivity();
-                            } else if (i == GALLERY) {
-                                startGalleryActivity();
-                            }
-                        }
-                    });
+                    setItems(new CharSequence[]{camera, gallery},
+                            new DialogInterface.OnClickListener() {
+                                @Override
+                                public void onClick(DialogInterface dialogInterface, int i) {
+                                    if (i == CAMERA) {
+                                        startCameraActivity();
+                                    } else if (i == GALLERY) {
+                                        startGalleryActivity();
+                                    }
+                                }
+                            });
             builder.show();
         }
 
@@ -1031,6 +970,17 @@ private void setPhotoText() {
             }
         }
 
+        private void setPhotoThumbnail() {
+            // The selected image may be too big so scale here
+            if (runningImageTask != null &&
+                    runningImageTask.getStatus() != AsyncTask.Status.FINISHED) {
+                runningImageTask.cancel(true);
+            }
+
+            runningImageTask = new ScaleAndSetImageTask(photoUri);
+            runningImageTask.execute();
+        }
+
         private void startCameraActivity() {
             Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
             tempUri = getTempUri();
@@ -1051,11 +1001,13 @@ private void startGalleryActivity() {
         private Uri getTempUri() {
             String imgFileName = FILE_PREFIX + System.currentTimeMillis() + FILE_SUFFIX;
 
-            // Note: on an emulator, you might need to create the "Pictures" directory in /mnt/sdcard first
+            // Note: on an emulator, you might need to create the "Pictures" directory in
+            //         /mnt/sdcard first
             //       % adb shell
             //       % mkdir /mnt/sdcard/Pictures
             File image = new File(
-                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), imgFileName);
+                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
+                    imgFileName);
             return Uri.fromFile(image);
         }
     }
@@ -1063,7 +1015,8 @@ private Uri getTempUri() {
     private class ActionListAdapter extends ArrayAdapter<BaseListElement> {
         private List<BaseListElement> listElements;
 
-        public ActionListAdapter(Context context, int resourceId, List<BaseListElement> listElements) {
+        public ActionListAdapter(
+                Context context, int resourceId, List<BaseListElement> listElements) {
             super(context, resourceId, listElements);
             this.listElements = listElements;
             for (int i = 0; i < listElements.size(); i++) {
@@ -1076,7 +1029,8 @@ public View getView(int position, View convertView, ViewGroup parent) {
             View view = convertView;
             if (view == null) {
                 LayoutInflater inflater =
-                        (LayoutInflater) getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        (LayoutInflater) getActivity().getSystemService(
+                                Context.LAYOUT_INFLATER_SERVICE);
                 view = inflater.inflate(R.layout.listitem, null);
             }
 
@@ -1093,11 +1047,59 @@ public View getView(int position, View convertView, ViewGroup parent) {
                     text1.setText(listElement.getText1());
                 }
                 if (text2 != null) {
-                    text2.setText(listElement.getText2());
+                    if (listElement.getText2() != null) {
+                        text2.setVisibility(View.VISIBLE);
+                        text2.setText(listElement.getText2());
+                    } else {
+                        text2.setVisibility(View.GONE);
+                    }
                 }
             }
             return view;
         }
+    }
+
+    private class ScaleAndSetImageTask extends AsyncTask<Void, Void, Bitmap> {
+        private final Uri uri;
+
+        public ScaleAndSetImageTask(Uri uri) {
+            this.uri = uri;
+        }
 
+        @Override
+        protected Bitmap doInBackground(Void... params) {
+            try {
+                Bitmap bitmap = MediaStore.Images.Media.getBitmap(
+                        FacebookSdk.getApplicationContext().getContentResolver(), uri);
+                if (bitmap.getHeight() > MAX_TEXTURE_SIZE || bitmap.getWidth() > MAX_TEXTURE_SIZE) {
+                    // We need to scale the image
+                    float scale = Math.min(
+                            MAX_TEXTURE_SIZE / bitmap.getHeight(),
+                            MAX_TEXTURE_SIZE / bitmap.getWidth());
+                    Matrix matrix = new Matrix();
+                    matrix.postScale(scale, scale);
+                    bitmap = Bitmap.createBitmap(
+                            bitmap,
+                            0,
+                            0,
+                            bitmap.getWidth(),
+                            bitmap.getHeight(),
+                            matrix,
+                            false);
+                }
+                return bitmap;
+            } catch (Exception ex) {
+                return null;
+            }
+        }
+
+        protected void onPostExecute(Bitmap result) {
+            if (result != null) {
+                photoThumbnail.setImageBitmap(result);
+            } else {
+                // If we fail just try to set the image from the uri
+                photoThumbnail.setImageURI(photoUri);
+            }
+        }
     }
 }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
index f85fb29df..839bcaa89 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
@@ -1,43 +1,77 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.scrumptious;
 
+import android.content.Intent;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.Button;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.facebook.CallbackManager;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.login.LoginResult;
+import com.facebook.login.widget.LoginButton;
 
 public class SplashFragment extends Fragment {
 
-    private Button skipLoginButton;
+    private LoginButton loginButton;
+    private TextView skipLoginButton;
     private SkipLoginCallback skipLoginCallback;
+    private CallbackManager callbackManager;
 
     public interface SkipLoginCallback {
         void onSkipLoginPressed();
     }
 
-
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View view = inflater.inflate(R.layout.splash, container, false);
 
-        skipLoginButton = (Button) view.findViewById(R.id.skip_login_button);
+        callbackManager = CallbackManager.Factory.create();
+        loginButton = (LoginButton) view.findViewById(R.id.login_button);
+        loginButton.setReadPermissions("user_friends");
+        loginButton.setFragment(this);
+        loginButton.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
+            @Override
+            public void onSuccess(LoginResult loginResult) {
+                Toast.makeText(getActivity(), "Login successful", Toast.LENGTH_SHORT).show();
+            }
+
+            @Override
+            public void onCancel() {
+                Toast.makeText(getActivity(), "Login canceled", Toast.LENGTH_SHORT).show();
+            }
+
+            @Override
+            public void onError(FacebookException exception) {
+                Toast.makeText(getActivity(), "Login error", Toast.LENGTH_SHORT).show();
+            }
+        });
+
+        skipLoginButton = (TextView) view.findViewById(R.id.skip_login_button);
         skipLoginButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -50,7 +84,15 @@ public void onClick(View view) {
         return view;
     }
 
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
+    }
+
     public void setSkipLoginCallback(SkipLoginCallback callback) {
         skipLoginCallback = callback;
     }
+
 }
+
diff --git a/facebook/src/com/facebook/widget/FriendPickerFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/FriendPickerFragment.java
similarity index 64%
rename from facebook/src/com/facebook/widget/FriendPickerFragment.java
rename to samples/Scrumptious/src/com/facebook/scrumptious/picker/FriendPickerFragment.java
index b657ec567..4bba11572 100644
--- a/facebook/src/com/facebook/widget/FriendPickerFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/FriendPickerFragment.java
@@ -1,34 +1,40 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.scrumptious.picker;
 
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.res.TypedArray;
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.AttributeSet;
-import com.facebook.AppEventsLogger;
+
+import com.facebook.AccessToken;
+import com.facebook.GraphRequest;
+import com.facebook.appevents.AppEventsLogger;
 import com.facebook.FacebookException;
-import com.facebook.Request;
-import com.facebook.Session;
-import com.facebook.android.R;
+import com.facebook.scrumptious.R;
 import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphUser;
+import com.facebook.internal.Validate;
+
+import org.json.JSONObject;
 
 import java.util.*;
 
@@ -36,17 +42,38 @@
  * Provides a Fragment that displays a list of a user's friends and allows one or more of the
  * friends to be selected.
  */
-public class FriendPickerFragment extends PickerFragment<GraphUser> {
+public class FriendPickerFragment extends PickerFragment {
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate what user's
      * friends should be shown. The default is to display the currently authenticated user's friends.
      */
-    public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId";
+    public static final String USER_ID_BUNDLE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.UserId";
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
      * picker should allow more than one friend to be selected or not.
      */
-    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect";
+    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.MultiSelect";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the type of friend picker to use.
+     * This value is case sensitive, and must match the enum @{link FriendPickerType}
+     */
+    public static final String FRIEND_PICKER_TYPE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.FriendPickerType";
+
+    public enum FriendPickerType {
+        FRIENDS("/friends"),
+        TAGGABLE_FRIENDS("/taggable_friends"),
+        INVITABLE_FRIENDS("/invitable_friends");
+
+        private final String requestPath;
+
+        FriendPickerType(String path) {
+            this.requestPath = path;
+        }
+
+        String getRequestPath() {
+            return requestPath;
+        }
+    }
 
     private static final String ID = "id";
     private static final String NAME = "name";
@@ -55,24 +82,16 @@
 
     private boolean multiSelect = true;
 
+    // default to Friends for backwards compatibility
+    private FriendPickerType friendPickerType = FriendPickerType.FRIENDS;
+
     private List<String> preSelectedFriendIds = new ArrayList<String>();
 
     /**
      * Default constructor. Creates a Fragment with all default properties.
      */
     public FriendPickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     * @param args  a Bundle that optionally contains one or more values containing additional
-     *              configuration information for the Fragment.
-     */
-    @SuppressLint("ValidFragment")
-    public FriendPickerFragment(Bundle args) {
-        super(GraphUser.class, R.layout.com_facebook_friendpickerfragment, args);
-        setFriendPickerSettingsFromBundle(args);
+        super(R.layout.picker_friendpickerfragment);
     }
 
     /**
@@ -112,6 +131,14 @@ public void setMultiSelect(boolean multiSelect) {
         }
     }
 
+    /**
+     * Sets the friend picker type for this fragment.
+     * @param type the type of friend picker to use.
+     */
+    public void setFriendPickerType(FriendPickerType type) {
+        this.friendPickerType = type;
+    }
+
     /**
      * Sets the list of friends for pre selection. These friends will be selected by default.
      * @param userIds list of friends as ids
@@ -132,7 +159,7 @@ public void setSelectionByIds(String... userIds) {
      * Sets the list of friends for pre selection. These friends will be selected by default.
      * @param graphUsers list of friends as GraphUsers
      */
-    public void setSelection(GraphUser... graphUsers) {
+    public void setSelection(JSONObject... graphUsers) {
         setSelection(Arrays.asList(graphUsers));
     }
 
@@ -140,10 +167,12 @@ public void setSelection(GraphUser... graphUsers) {
      * Sets the list of friends for pre selection. These friends will be selected by default.
      * @param graphUsers list of friends as GraphUsers
      */
-    public void setSelection(List<GraphUser> graphUsers) {
+    public void setSelection(List<JSONObject> graphUsers) {
         List<String> userIds = new ArrayList<String>();
-        for(GraphUser graphUser: graphUsers) {
-            userIds.add(graphUser.getId());
+        for(JSONObject graphUser: graphUsers) {
+            String id = graphUser.optString("id");
+            Validate.notNullOrEmpty(id, "id");
+            userIds.add(id);
         }
         setSelectionByIds(userIds);
     }
@@ -152,23 +181,36 @@ public void setSelection(List<GraphUser> graphUsers) {
      * Gets the currently-selected list of users.
      * @return the currently-selected list of users
      */
-    public List<GraphUser> getSelection() {
+    public List<JSONObject> getSelection() {
         return getSelectedGraphObjects();
     }
 
     @Override
     public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
         super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_friend_picker_fragment);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_friend_picker_fragment);
 
-        setMultiSelect(a.getBoolean(R.styleable.com_facebook_friend_picker_fragment_multi_select, multiSelect));
+        setMultiSelect(a.getBoolean(R.styleable.picker_friend_picker_fragment_multi_select, multiSelect));
 
         a.recycle();
     }
 
+    @Override
     public void setSettingsFromBundle(Bundle inState) {
         super.setSettingsFromBundle(inState);
-        setFriendPickerSettingsFromBundle(inState);
+        if (inState != null) {
+            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
+                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
+            }
+            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
+            if (inState.containsKey(FRIEND_PICKER_TYPE_KEY)) {
+                try {
+                    friendPickerType = FriendPickerType.valueOf(inState.getString(FRIEND_PICKER_TYPE_KEY));
+                } catch (Exception e) {
+                    // NOOP
+                }
+            }
+        }
     }
 
     void saveSettingsToBundle(Bundle outState) {
@@ -179,18 +221,16 @@ void saveSettingsToBundle(Bundle outState) {
     }
 
     @Override
-    PickerFragmentAdapter<GraphUser> createAdapter() {
-        PickerFragmentAdapter<GraphUser> adapter = new PickerFragmentAdapter<GraphUser>(
-                this.getActivity()) {
-
+    PickerFragmentAdapter createAdapter() {
+        PickerFragmentAdapter adapter = new PickerFragmentAdapter(this.getActivity()) {
             @Override
-            protected int getGraphObjectRowLayoutId(GraphUser graphObject) {
-                return R.layout.com_facebook_picker_list_row;
+            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
+                return R.layout.picker_list_row;
             }
 
             @Override
             protected int getDefaultPicture() {
-                return R.drawable.com_facebook_profile_default_icon;
+                return R.drawable.profile_default_icon;
             }
 
         };
@@ -213,23 +253,24 @@ SelectionStrategy createSelectionStrategy() {
     }
 
     @Override
-    Request getRequestForLoadData(Session session) {
+    GraphRequest getRequestForLoadData() {
         if (adapter == null) {
             throw new FacebookException("Can't issue requests until Fragment has been created.");
         }
 
         String userToFetch = (userId != null) ? userId : "me";
-        return createRequest(userToFetch, extraFields, session);
+        return createRequest(userToFetch, extraFields);
     }
 
     @Override
     String getDefaultTitleText() {
-        return getString(R.string.com_facebook_choose_friends);
+        return getResources().getString(R.string.choose_friends);
     }
 
     @Override
     void logAppEvents(boolean doneButtonClicked) {
-        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(), getSession());
+        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
+                AccessToken.getCurrentAccessToken().getToken());
         Bundle parameters = new Bundle();
 
         // If Done was clicked, we know this completed successfully. If not, we don't know (caller might have
@@ -249,8 +290,10 @@ public void loadData(boolean forceReload) {
         setSelectedGraphObjects(preSelectedFriendIds);
     }
 
-    private Request createRequest(String userID, Set<String> extraFields, Session session) {
-        Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
+    private GraphRequest createRequest(String userID, Set<String> extraFields) {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        GraphRequest request = GraphRequest.newGraphPathRequest(
+                accessToken, userID + friendPickerType.getRequestPath(), null);
 
         Set<String> fields = new HashSet<String>(extraFields);
         String[] requiredFields = new String[]{
@@ -271,20 +314,9 @@ private Request createRequest(String userID, Set<String> extraFields, Session se
         return request;
     }
 
-    private void setFriendPickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
-                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
-            }
-            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
-        }
-    }
-
     private class ImmediateLoadingStrategy extends LoadingStrategy {
         @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
-                SimpleGraphObjectCursor<GraphUser> data) {
+        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
             super.onLoadFinished(loader, data);
 
             // We could be called in this state if we are clearing data or if we are being re-attached
@@ -299,12 +331,6 @@ protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
             } else {
                 // We finished loading results.
                 hideActivityCircle();
-
-                // If this was from the cache, schedule a delayed refresh query (unless we got no results
-                // at all, in which case refresh immediately.
-                if (data.isFromCache()) {
-                    loader.refreshOriginalRequest(data.getCount() == 0 ? CACHED_RESULT_REFRESH_DELAY : 0);
-                }
             }
         }
 
diff --git a/facebook/src/com/facebook/widget/GraphObjectAdapter.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectAdapter.java
similarity index 78%
rename from facebook/src/com/facebook/widget/GraphObjectAdapter.java
rename to samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectAdapter.java
index 3686cb8b2..d79ce65e9 100644
--- a/facebook/src/com/facebook/widget/GraphObjectAdapter.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectAdapter.java
@@ -1,34 +1,40 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.scrumptious.picker;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.net.Uri;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
 import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
+import com.facebook.FacebookException;
+import com.facebook.scrumptious.R;
 import com.facebook.internal.ImageDownloader;
 import com.facebook.internal.ImageRequest;
 import com.facebook.internal.ImageResponse;
-import com.facebook.model.GraphObject;
+import com.facebook.internal.Utility;
+
 import org.json.JSONObject;
 
 import java.net.URI;
@@ -36,7 +42,7 @@
 import java.text.Collator;
 import java.util.*;
 
-class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
+class GraphObjectAdapter extends BaseAdapter implements SectionIndexer {
     private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
     private static final int HEADER_VIEW_TYPE = 0;
     private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
@@ -50,16 +56,16 @@
     private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
     private final LayoutInflater inflater;
     private List<String> sectionKeys = new ArrayList<String>();
-    private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-    private Map<String, T> graphObjectsById = new HashMap<String, T>();
+    private Map<String, ArrayList<JSONObject>> graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
+    private Map<String, JSONObject> graphObjectsById = new HashMap<String, JSONObject>();
     private boolean displaySections;
     private List<String> sortFields;
     private String groupByField;
     private boolean showPicture;
     private boolean showCheckbox;
-    private Filter<T> filter;
+    private Filter filter;
     private DataNeededListener dataNeededListener;
-    private GraphObjectCursor<T> cursor;
+    private GraphObjectCursor cursor;
     private Context context;
     private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
     private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
@@ -70,12 +76,12 @@
     }
 
     public interface OnErrorListener {
-        void onError(GraphObjectAdapter<?> adapter, FacebookException error);
+        void onError(GraphObjectAdapter adapter, FacebookException error);
     }
 
-    public static class SectionAndItem<T extends GraphObject> {
+    public static class SectionAndItem {
         public String sectionKey;
-        public T graphObject;
+        public JSONObject graphObject;
 
         public enum Type {
             GRAPH_OBJECT,
@@ -83,7 +89,7 @@
             ACTIVITY_CIRCLE
         }
 
-        public SectionAndItem(String sectionKey, T graphObject) {
+        public SectionAndItem(String sectionKey, JSONObject graphObject) {
             this.sectionKey = sectionKey;
             this.graphObject = graphObject;
         }
@@ -99,8 +105,8 @@ public Type getType() {
         }
     }
 
-    interface Filter<T> {
-        boolean includeItem(T graphObject);
+    interface Filter {
+        boolean includeItem(JSONObject graphObject);
     }
 
     public GraphObjectAdapter(Context context) {
@@ -156,11 +162,11 @@ public void setOnErrorListener(OnErrorListener onErrorListener) {
         this.onErrorListener = onErrorListener;
     }
 
-    public GraphObjectCursor<T> getCursor() {
+    public GraphObjectCursor getCursor() {
         return cursor;
     }
 
-    public boolean changeCursor(GraphObjectCursor<T> cursor) {
+    public boolean changeCursor(GraphObjectCursor cursor) {
         if (this.cursor == cursor) {
             return false;
         }
@@ -194,7 +200,7 @@ public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int p
         // the front of the queue, so all else being equal, the list will appear to populate from
         // the top down.
         for (int i = lastVisibleItem; i >= 0; i--) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            SectionAndItem sectionAndItem = getSectionAndItem(i);
             if (sectionAndItem.graphObject != null) {
                 String id = getIdOfGraphObject(sectionAndItem.graphObject);
                 ImageRequest request = pendingRequests.get(id);
@@ -208,22 +214,22 @@ public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int p
         // fetch those items and store them in a small in-memory cache of bitmaps.
         int start = Math.max(0, firstVisibleItem - prefetchBuffer);
         int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
-        ArrayList<T> graphObjectsToPrefetchPicturesFor = new ArrayList<T>();
+        ArrayList<JSONObject> graphObjectsToPrefetchPicturesFor = new ArrayList<JSONObject>();
         // Add the IDs before and after the visible range.
         for (int i = start; i < firstVisibleItem; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            SectionAndItem sectionAndItem = getSectionAndItem(i);
             if (sectionAndItem.graphObject != null) {
                 graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
             }
         }
         for (int i = lastVisibleItem + 1; i <= end; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            SectionAndItem sectionAndItem = getSectionAndItem(i);
             if (sectionAndItem.graphObject != null) {
                 graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
             }
         }
-        for (T graphObject : graphObjectsToPrefetchPicturesFor) {
-            URI uri = getPictureUriOfGraphObject(graphObject);
+        for (JSONObject graphObject : graphObjectsToPrefetchPicturesFor) {
+            Uri uri = getPictureUriOfGraphObject(graphObject);
             final String id = getIdOfGraphObject(graphObject);
 
             // This URL already have been requested for pre-fetching, but we want to act in an LRU manner, so move
@@ -238,11 +244,11 @@ public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int p
         }
     }
 
-    protected String getSectionKeyOfGraphObject(T graphObject) {
+    protected String getSectionKeyOfGraphObject(JSONObject graphObject) {
         String result = null;
 
         if (groupByField != null) {
-            result = (String) graphObject.getProperty(groupByField);
+            result = graphObject.optString(groupByField);
             if (result != null && result.length() > 0) {
                 result = result.substring(0, 1).toUpperCase();
             }
@@ -251,32 +257,26 @@ protected String getSectionKeyOfGraphObject(T graphObject) {
         return (result != null) ? result : "";
     }
 
-    protected CharSequence getTitleOfGraphObject(T graphObject) {
-        return (String) graphObject.getProperty(NAME);
+    protected CharSequence getTitleOfGraphObject(JSONObject graphObject) {
+        return graphObject.optString(NAME);
     }
 
-    protected CharSequence getSubTitleOfGraphObject(T graphObject) {
+    protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
         return null;
     }
 
-    protected URI getPictureUriOfGraphObject(T graphObject) {
+    protected Uri getPictureUriOfGraphObject(JSONObject graphObject) {
         String uri = null;
-        Object o = graphObject.getProperty(PICTURE);
+        Object o = graphObject.opt(PICTURE);
         if (o instanceof String) {
             uri = (String) o;
         } else if (o instanceof JSONObject) {
-            ItemPicture itemPicture = GraphObject.Factory.create((JSONObject) o).cast(ItemPicture.class);
-            ItemPictureData data = itemPicture.getData();
-            if (data != null) {
-                uri = data.getUrl();
-            }
+            JSONObject data = ((JSONObject) o).optJSONObject("data");
+            uri = data != null ? data.optString("url") : null;
         }
 
         if (uri != null) {
-            try {
-                return new URI(uri);
-            } catch (URISyntaxException e) {
-            }
+            return Uri.parse(uri);
         }
         return null;
     }
@@ -285,7 +285,7 @@ protected View getSectionHeaderView(String sectionHeader, View convertView, View
         TextView result = (TextView) convertView;
 
         if (result == null) {
-            result = (TextView) inflater.inflate(R.layout.com_facebook_picker_list_section_header, null);
+            result = (TextView) inflater.inflate(R.layout.picker_list_section_header, null);
         }
 
         result.setText(sectionHeader);
@@ -293,7 +293,7 @@ protected View getSectionHeaderView(String sectionHeader, View convertView, View
         return result;
     }
 
-    protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
+    protected View getGraphObjectView(JSONObject graphObject, View convertView, ViewGroup parent) {
         View result = convertView;
 
         if (result == null) {
@@ -308,7 +308,7 @@ private View getActivityCircleView(View convertView, ViewGroup parent) {
         View result = convertView;
 
         if (result == null) {
-            result = inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
+            result = inflater.inflate(R.layout.picker_activity_circle_row, null);
         }
         ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
         activityCircle.setVisibility(View.VISIBLE);
@@ -316,15 +316,15 @@ private View getActivityCircleView(View convertView, ViewGroup parent) {
         return result;
     }
 
-    protected int getGraphObjectRowLayoutId(T graphObject) {
-        return R.layout.com_facebook_picker_list_row;
+    protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
+        return R.layout.picker_list_row;
     }
 
     protected int getDefaultPicture() {
-        return R.drawable.com_facebook_profile_default_icon;
+        return R.drawable.profile_default_icon;
     }
 
-    protected View createGraphObjectView(T graphObject) {
+    protected View createGraphObjectView(JSONObject graphObject) {
         View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);
 
         ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
@@ -348,7 +348,7 @@ protected View createGraphObjectView(T graphObject) {
         return result;
     }
 
-    protected void populateGraphObjectView(View view, T graphObject) {
+    protected void populateGraphObjectView(View view, JSONObject graphObject) {
         String id = getIdOfGraphObject(graphObject);
         view.setTag(id);
 
@@ -375,7 +375,7 @@ protected void populateGraphObjectView(View view, T graphObject) {
         }
 
         if (getShowPicture()) {
-            URI pictureURI = getPictureUriOfGraphObject(graphObject);
+            Uri pictureURI = getPictureUriOfGraphObject(graphObject);
 
             if (pictureURI != null) {
                 ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
@@ -395,25 +395,23 @@ protected void populateGraphObjectView(View view, T graphObject) {
     /**
      * @throws FacebookException if the GraphObject doesn't have an ID.
      */
-    String getIdOfGraphObject(T graphObject) {
-        if (graphObject.asMap().containsKey(ID)) {
-            Object obj = graphObject.getProperty(ID);
-            if (obj instanceof String) {
-                return (String) obj;
-            }
+    String getIdOfGraphObject(JSONObject graphObject) {
+        String id = graphObject.optString(ID);
+        if (id != null) {
+            return id;
         }
         throw new FacebookException("Received an object without an ID.");
     }
 
-    boolean filterIncludesItem(T graphObject) {
+    boolean filterIncludesItem(JSONObject graphObject) {
         return filter == null || filter.includeItem(graphObject);
     }
 
-    Filter<T> getFilter() {
+    Filter getFilter() {
         return filter;
     }
 
-    void setFilter(Filter<T> filter) {
+    void setFilter(Filter filter) {
         this.filter = filter;
     }
 
@@ -435,7 +433,7 @@ String getPictureFieldSpecifier() {
 
         // Note: these dimensions are in pixels, not dips
         ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
-        return String.format("picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
+        return String.format(Locale.US, "picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
     }
 
 
@@ -447,8 +445,8 @@ private boolean shouldShowActivityCircleCell() {
 
     private void rebuildSections() {
         sectionKeys = new ArrayList<String>();
-        graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-        graphObjectsById = new HashMap<String, T>();
+        graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
+        graphObjectsById = new HashMap<String, JSONObject>();
         displaySections = false;
 
         if (cursor == null || cursor.getCount() == 0) {
@@ -458,7 +456,7 @@ private void rebuildSections() {
         int objectsAdded = 0;
         cursor.moveToFirst();
         do {
-            T graphObject = cursor.getGraphObject();
+            JSONObject graphObject = cursor.getGraphObject();
 
             if (!filterIncludesItem(graphObject)) {
                 continue;
@@ -469,9 +467,9 @@ private void rebuildSections() {
             String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
             if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
                 sectionKeys.add(sectionKeyOfItem);
-                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<T>());
+                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<JSONObject>());
             }
-            List<T> section = graphObjectsBySection.get(sectionKeyOfItem);
+            List<JSONObject> section = graphObjectsBySection.get(sectionKeyOfItem);
             section.add(graphObject);
 
             graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
@@ -479,10 +477,10 @@ private void rebuildSections() {
 
         if (sortFields != null) {
             final Collator collator = Collator.getInstance();
-            for (List<T> section : graphObjectsBySection.values()) {
-                Collections.sort(section, new Comparator<GraphObject>() {
+            for (List<JSONObject> section : graphObjectsBySection.values()) {
+                Collections.sort(section, new Comparator<JSONObject>() {
                     @Override
-                    public int compare(GraphObject a, GraphObject b) {
+                    public int compare(JSONObject a, JSONObject b) {
                         return compareGraphObjects(a, b, sortFields, collator);
                     }
                 });
@@ -494,23 +492,23 @@ public int compare(GraphObject a, GraphObject b) {
         displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
     }
 
-    SectionAndItem<T> getSectionAndItem(int position) {
+    SectionAndItem getSectionAndItem(int position) {
         if (sectionKeys.size() == 0) {
             return null;
         }
         String sectionKey = null;
-        T graphObject = null;
+        JSONObject graphObject = null;
 
         if (!displaySections) {
             sectionKey = sectionKeys.get(0);
-            List<T> section = graphObjectsBySection.get(sectionKey);
+            List<JSONObject> section = graphObjectsBySection.get(sectionKey);
             if (position >= 0 && position < section.size()) {
                 graphObject = graphObjectsBySection.get(sectionKey).get(position);
             } else {
                 // We are off the end; we must be adding an activity circle to indicate more data is coming.
                 assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
                 // We return null for both to indicate this.
-                return new SectionAndItem<T>(null, null);
+                return new SectionAndItem(null, null);
             }
         } else {
             // Count through the sections; the "0" position in each section is the header. We decrement
@@ -522,7 +520,7 @@ public int compare(GraphObject a, GraphObject b) {
                     break;
                 }
 
-                List<T> section = graphObjectsBySection.get(key);
+                List<JSONObject> section = graphObjectsBySection.get(key);
                 if (position < section.size()) {
                     // The position is somewhere in this section. Get the corresponding graph object.
                     sectionKey = key;
@@ -535,13 +533,13 @@ public int compare(GraphObject a, GraphObject b) {
         }
         if (sectionKey != null) {
             // Note: graphObject will be null if this represents a section header.
-            return new SectionAndItem<T>(sectionKey, graphObject);
+            return new SectionAndItem(sectionKey, graphObject);
         } else {
             throw new IndexOutOfBoundsException("position");
         }
     }
 
-    int getPosition(String sectionKey, T graphObject) {
+    int getPosition(String sectionKey, JSONObject graphObject) {
         int position = 0;
         boolean found = false;
 
@@ -568,8 +566,8 @@ int getPosition(String sectionKey, T graphObject) {
         }
 
         // Now find index of this item within that section.
-        for (T t : graphObjectsBySection.get(sectionKey)) {
-            if (GraphObject.Factory.hasSameId(t, graphObject)) {
+        for (JSONObject t : graphObjectsBySection.get(sectionKey)) {
+            if (Utility.hasSameId(t, graphObject)) {
                 return position;
             }
             position++;
@@ -592,7 +590,7 @@ public int getCount() {
         // If we are not displaying sections, we don't display a header; otherwise, we have one header per item in
         // addition to the actual items.
         int count = (displaySections) ? sectionKeys.size() : 0;
-        for (List<T> section : graphObjectsBySection.values()) {
+        for (List<JSONObject> section : graphObjectsBySection.values()) {
             count += section.size();
         }
 
@@ -616,13 +614,13 @@ public boolean hasStableIds() {
 
     @Override
     public boolean isEnabled(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
         return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
     }
 
     @Override
     public Object getItem(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
         return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
     }
 
@@ -631,11 +629,15 @@ public long getItemId(int position) {
         // We assume IDs that can be converted to longs. If this is not the case for certain types of
         // GraphObjects, subclasses should override this to return, e.g., position, and override hasStableIds
         // to return false.
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
         if (sectionAndItem != null && sectionAndItem.graphObject != null) {
             String id = getIdOfGraphObject(sectionAndItem.graphObject);
             if (id != null) {
-                return Long.parseLong(id);
+                try {
+                    return Long.parseLong(id);
+                } catch (NumberFormatException e) {
+                    // NOOP
+                }
             }
         }
         return 0;
@@ -648,7 +650,7 @@ public int getViewTypeCount() {
 
     @Override
     public int getItemViewType(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
         switch (sectionAndItem.getType()) {
             case SECTION_HEADER:
                 return HEADER_VIEW_TYPE;
@@ -663,7 +665,7 @@ public int getItemViewType(int position) {
 
     @Override
     public View getView(int position, View convertView, ViewGroup parent) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
 
         switch (sectionAndItem.getType()) {
             case SECTION_HEADER:
@@ -702,7 +704,7 @@ public int getPositionForSection(int section) {
 
     @Override
     public int getSectionForPosition(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        SectionAndItem sectionAndItem = getSectionAndItem(position);
         if (sectionAndItem != null &&
                 sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
             return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
@@ -710,13 +712,13 @@ public int getSectionForPosition(int position) {
         return 0;
     }
 
-    public List<T> getGraphObjectsById(Collection<String> ids) {
+    public List<JSONObject> getGraphObjectsById(Collection<String> ids) {
         Set<String> idSet = new HashSet<String>();
         idSet.addAll(ids);
 
-        ArrayList<T> result = new ArrayList<T>(idSet.size());
+        ArrayList<JSONObject> result = new ArrayList<JSONObject>(idSet.size());
         for (String id : idSet) {
-            T graphObject = graphObjectsById.get(id);
+            JSONObject graphObject = graphObjectsById.get(id);
             if (graphObject != null) {
                 result.add(graphObject);
             }
@@ -725,8 +727,11 @@ public int getSectionForPosition(int position) {
         return result;
     }
 
-    private void downloadProfilePicture(final String profileId, URI pictureURI, final ImageView imageView) {
-        if (pictureURI == null) {
+    private void downloadProfilePicture(
+            final String profileId,
+            Uri pictureUri,
+            final ImageView imageView) {
+        if (pictureUri == null) {
             return;
         }
 
@@ -735,7 +740,7 @@ private void downloadProfilePicture(final String profileId, URI pictureURI, fina
         // only want to queue a download if the view's tag isn't already set to the URL (which would mean
         // it's already got the correct picture).
         boolean prefetching = imageView == null;
-        if (prefetching || !pictureURI.equals(imageView.getTag())) {
+        if (prefetching || !pictureUri.equals(imageView.getTag())) {
             if (!prefetching) {
                 // Setting the tag to the profile ID indicates that we're currently downloading the
                 // picture for this profile; we'll set it to the actual picture URL when complete.
@@ -743,7 +748,9 @@ private void downloadProfilePicture(final String profileId, URI pictureURI, fina
                 imageView.setImageResource(getDefaultPicture());
             }
 
-            ImageRequest.Builder builder = new ImageRequest.Builder(context.getApplicationContext(), pictureURI)
+            ImageRequest.Builder builder = new ImageRequest.Builder(
+                    context.getApplicationContext(),
+                    pictureUri)
                     .setCallerTag(this)
                     .setCallback(
                             new ImageRequest.Callback() {
@@ -796,11 +803,11 @@ private void processImageResponse(ImageResponse response, String graphObjectId,
         }
     }
 
-    private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
+    private static int compareGraphObjects(JSONObject a, JSONObject b, Collection<String> sortFields,
             Collator collator) {
         for (String sortField : sortFields) {
-            String sa = (String) a.getProperty(sortField);
-            String sb = (String) b.getProperty(sortField);
+            String sa = a.optString(sortField);
+            String sb = b.optString(sortField);
 
             if (sa != null && sb != null) {
                 int result = collator.compare(sa, sb);
@@ -813,15 +820,4 @@ private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<
         }
         return 0;
     }
-
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPicture extends GraphObject {
-        ItemPictureData getData();
-    }
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPictureData extends GraphObject {
-        String getUrl();
-    }
 }
diff --git a/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectCursor.java
similarity index 57%
rename from facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
rename to samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectCursor.java
index 04c98ba6d..2ec4a73d1 100644
--- a/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectCursor.java
@@ -1,59 +1,54 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.scrumptious.picker;
 
 import android.database.CursorIndexOutOfBoundsException;
-import com.facebook.model.GraphObject;
+import org.json.JSONArray;
+import org.json.JSONObject;
 
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.List;
 
-class SimpleGraphObjectCursor<T extends GraphObject> implements GraphObjectCursor<T> {
+class GraphObjectCursor {
     private int pos = -1;
     private boolean closed = false;
-    private ArrayList<T> graphObjects = new ArrayList<T>();
+    private List<JSONObject> graphObjects = new ArrayList<JSONObject>();
     private boolean moreObjectsAvailable = false;
-    private boolean fromCache = false;
 
-    SimpleGraphObjectCursor() {
+    GraphObjectCursor() {
     }
 
-    SimpleGraphObjectCursor(SimpleGraphObjectCursor<T> other) {
+    GraphObjectCursor(GraphObjectCursor other) {
         pos = other.pos;
         closed = other.closed;
-        graphObjects = new ArrayList<T>();
+        graphObjects = new ArrayList<JSONObject>();
         graphObjects.addAll(other.graphObjects);
-        fromCache = other.fromCache;
 
         // We do not copy observers.
     }
 
-    public void addGraphObjects(Collection<T> graphObjects, boolean fromCache) {
-        this.graphObjects.addAll(graphObjects);
-        // We consider this cached if ANY results were from the cache.
-        this.fromCache |= fromCache;
-    }
-
-    public boolean isFromCache() {
-        return fromCache;
-    }
-
-    public void setFromCache(boolean fromCache) {
-        this.fromCache = fromCache;
+    public void addGraphObjects(JSONArray graphObjects) {
+        for (int i = 0; i < graphObjects.length(); ++i) {
+            this.graphObjects.add(graphObjects.optJSONObject(i));
+        }
     }
 
     public boolean areMoreObjectsAvailable() {
@@ -64,22 +59,18 @@ public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
         this.moreObjectsAvailable = moreObjectsAvailable;
     }
 
-    @Override
     public int getCount() {
         return graphObjects.size();
     }
 
-    @Override
     public int getPosition() {
         return pos;
     }
 
-    @Override
     public boolean move(int offset) {
         return moveToPosition(pos + offset);
     }
 
-    @Override
     public boolean moveToPosition(int position) {
         final int count = getCount();
         if (position >= count) {
@@ -96,50 +87,41 @@ public boolean moveToPosition(int position) {
         return true;
     }
 
-    @Override
     public boolean moveToFirst() {
         return moveToPosition(0);
     }
 
-    @Override
     public boolean moveToLast() {
         return moveToPosition(getCount() - 1);
     }
 
-    @Override
     public boolean moveToNext() {
         return moveToPosition(pos + 1);
     }
 
-    @Override
     public boolean moveToPrevious() {
         return moveToPosition(pos - 1);
     }
 
-    @Override
     public boolean isFirst() {
         return (pos == 0) && (getCount() != 0);
     }
 
-    @Override
     public boolean isLast() {
         final int count = getCount();
         return (pos == (count - 1)) && (count != 0);
     }
 
-    @Override
     public boolean isBeforeFirst() {
         return (getCount() == 0) || (pos == -1);
     }
 
-    @Override
     public boolean isAfterLast() {
         final int count = getCount();
         return (count == 0) || (pos == count);
     }
 
-    @Override
-    public T getGraphObject() {
+    public JSONObject getGraphObject() {
         if (pos < 0) {
             throw new CursorIndexOutOfBoundsException("Before first object.");
         }
@@ -149,12 +131,10 @@ public T getGraphObject() {
         return graphObjects.get(pos);
     }
 
-    @Override
     public void close() {
         closed = true;
     }
 
-    @Override
     public boolean isClosed() {
         return closed;
     }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectPagingLoader.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectPagingLoader.java
new file mode 100644
index 000000000..10640a257
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/GraphObjectPagingLoader.java
@@ -0,0 +1,169 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.scrumptious.picker;
+
+import android.content.Context;
+import android.support.v4.content.Loader;
+import com.facebook.*;
+import org.json.JSONArray;
+
+class GraphObjectPagingLoader extends Loader<GraphObjectCursor> {
+    private GraphRequest originalRequest;
+    private GraphRequest currentRequest;
+    private GraphRequest nextRequest;
+    private OnErrorListener onErrorListener;
+    private GraphObjectCursor cursor;
+    private boolean appendResults = false;
+    private boolean loading = false;
+
+    public interface OnErrorListener {
+        public void onError(FacebookException error, GraphObjectPagingLoader loader);
+    }
+
+    public GraphObjectPagingLoader(Context context) {
+        super(context);
+    }
+
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    public void setOnErrorListener(OnErrorListener listener) {
+        this.onErrorListener = listener;
+    }
+
+    public GraphObjectCursor getCursor() {
+        return cursor;
+    }
+
+    public void clearResults() {
+        nextRequest = null;
+        originalRequest = null;
+        currentRequest = null;
+
+        deliverResult(null);
+    }
+
+    public boolean isLoading() {
+        return loading;
+    }
+
+    public void startLoading(GraphRequest request) {
+        appendResults = false;
+        nextRequest = null;
+        currentRequest = request;
+        currentRequest.setCallback(new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                requestCompleted(response);
+            }
+        });
+
+        loading = true;
+        final GraphRequestBatch batch = new GraphRequestBatch(request);
+        GraphRequest.executeBatchAsync(batch);
+    }
+
+    public void followNextLink() {
+        if (nextRequest != null) {
+            appendResults = true;
+            currentRequest = nextRequest;
+
+            currentRequest.setCallback(new GraphRequest.Callback() {
+                @Override
+                public void onCompleted(GraphResponse response) {
+                    requestCompleted(response);
+                }
+            });
+
+            loading = true;
+            GraphRequest.executeBatchAsync(new GraphRequestBatch(currentRequest));
+        }
+    }
+
+    @Override
+    public void deliverResult(GraphObjectCursor cursor) {
+        GraphObjectCursor oldCursor = this.cursor;
+        this.cursor = cursor;
+
+        if (isStarted()) {
+            super.deliverResult(cursor);
+
+            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
+                oldCursor.close();
+            }
+        }
+    }
+
+    @Override
+    protected void onStartLoading() {
+        super.onStartLoading();
+
+        if (cursor != null) {
+            deliverResult(cursor);
+        }
+    }
+
+    private void requestCompleted(GraphResponse response) {
+        GraphRequest request = response.getRequest();
+        if (request != currentRequest) {
+            return;
+        }
+
+        loading = false;
+        currentRequest = null;
+
+        FacebookRequestError requestError = response.getError();
+        FacebookException exception = (requestError == null) ? null : requestError.getException();
+        if (response.getJSONObject() == null && exception == null) {
+            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
+        }
+
+        if (exception != null) {
+            nextRequest = null;
+
+            if (onErrorListener != null) {
+                onErrorListener.onError(exception, this);
+            }
+        } else {
+            addResults(response);
+        }
+    }
+
+    private void addResults(GraphResponse response) {
+        GraphObjectCursor cursorToModify = (cursor == null || !appendResults) ? new GraphObjectCursor() :
+                new GraphObjectCursor(cursor);
+
+        JSONArray data = response.getJSONObject().optJSONArray("data");
+
+        boolean haveData = data.length() > 0;
+
+        if (haveData) {
+            nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
+            cursorToModify.addGraphObjects(data);
+        } else {
+            nextRequest = null;
+        }
+        cursorToModify.setMoreObjectsAvailable(nextRequest != null);
+
+        deliverResult(cursorToModify);
+    }
+}
diff --git a/facebook/src/com/facebook/widget/PickerFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/PickerFragment.java
similarity index 82%
rename from facebook/src/com/facebook/widget/PickerFragment.java
rename to samples/Scrumptious/src/com/facebook/scrumptious/picker/PickerFragment.java
index 7718a0c26..5214b5e92 100644
--- a/facebook/src/com/facebook/widget/PickerFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/PickerFragment.java
@@ -1,20 +1,24 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.scrumptious.picker;
 
 import android.app.Activity;
 import android.content.Context;
@@ -32,10 +36,14 @@
 import android.view.ViewStub;
 import android.view.animation.AlphaAnimation;
 import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.SessionTracker;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.FacebookException;
+import com.facebook.GraphRequest;
+import com.facebook.scrumptious.R;
+
+import org.json.JSONObject;
 
 import java.util.*;
 
@@ -49,32 +57,32 @@
  * PickerFragments support callbacks that will be called in the event of an error, when the
  * underlying data has been changed, or when the set of selected graph objects changes.
  */
-public abstract class PickerFragment<T extends GraphObject> extends Fragment {
+public abstract class PickerFragment extends Fragment {
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
      * picker should show pictures (if available) for the graph objects.
      */
-    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures";
+    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ShowPictures";
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
      * beyond the default fields should be retrieved for any graph objects in the results.
      */
-    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields";
+    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ExtraFields";
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
      * picker should display a title bar with a Done button.
      */
-    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar";
+    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ShowTitleBar";
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate the text to
      * display in the title bar.
      */
-    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText";
+    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.TitleText";
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the Done btuton.
+     * display in the Done button.
      */
-    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText";
+    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.DoneButtonText";
 
     private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
     private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
@@ -85,17 +93,17 @@
     private OnDataChangedListener onDataChangedListener;
     private OnSelectionChangedListener onSelectionChangedListener;
     private OnDoneButtonClickedListener onDoneButtonClickedListener;
-    private GraphObjectFilter<T> filter;
+    private GraphObjectFilter filter;
     private boolean showPictures = true;
     private boolean showTitleBar = true;
     private ListView listView;
     HashSet<String> extraFields = new HashSet<String>();
-    GraphObjectAdapter<T> adapter;
-    private final Class<T> graphObjectClass;
+    GraphObjectAdapter adapter;
     private LoadingStrategy loadingStrategy;
     private SelectionStrategy selectionStrategy;
+    private Set<String> selectionHint;
     private ProgressBar activityCircle;
-    private SessionTracker sessionTracker;
+    private AccessTokenTracker accessTokenTracker;
     private String titleText;
     private String doneButtonText;
     private TextView titleTextView;
@@ -104,11 +112,8 @@
     private Drawable doneButtonBackground;
     private boolean appEventsLogged;
 
-    PickerFragment(Class<T> graphObjectClass, int layout, Bundle args) {
-        this.graphObjectClass = graphObjectClass;
+    protected PickerFragment(int layout) {
         this.layout = layout;
-
-        setPickerFragmentSettingsFromBundle(args);
     }
 
     @Override
@@ -116,9 +121,9 @@ public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
         adapter = createAdapter();
-        adapter.setFilter(new GraphObjectAdapter.Filter<T>() {
+        adapter.setFilter(new GraphObjectAdapter.Filter() {
             @Override
-            public boolean includeItem(T graphObject) {
+            public boolean includeItem(JSONObject graphObject) {
                 return filterIncludesItem(graphObject);
             }
         });
@@ -127,20 +132,20 @@ public boolean includeItem(T graphObject) {
     @Override
     public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
         super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_picker_fragment);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_fragment);
 
-        setShowPictures(a.getBoolean(R.styleable.com_facebook_picker_fragment_show_pictures, showPictures));
-        String extraFieldsString = a.getString(R.styleable.com_facebook_picker_fragment_extra_fields);
+        setShowPictures(a.getBoolean(R.styleable.picker_fragment_show_pictures, showPictures));
+        String extraFieldsString = a.getString(R.styleable.picker_fragment_extra_fields);
         if (extraFieldsString != null) {
             String[] strings = extraFieldsString.split(",");
             setExtraFields(Arrays.asList(strings));
         }
 
-        showTitleBar = a.getBoolean(R.styleable.com_facebook_picker_fragment_show_title_bar, showTitleBar);
-        titleText = a.getString(R.styleable.com_facebook_picker_fragment_title_text);
-        doneButtonText = a.getString(R.styleable.com_facebook_picker_fragment_done_button_text);
-        titleBarBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_title_bar_background);
-        doneButtonBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_done_button_background);
+        showTitleBar = a.getBoolean(R.styleable.picker_fragment_show_title_bar, showTitleBar);
+        titleText = a.getString(R.styleable.picker_fragment_title_text);
+        doneButtonText = a.getString(R.styleable.picker_fragment_done_button_text);
+        titleBarBackground = a.getDrawable(R.styleable.picker_fragment_title_bar_background);
+        doneButtonBackground = a.getDrawable(R.styleable.picker_fragment_done_button_background);
 
         a.recycle();
     }
@@ -180,15 +185,13 @@ public boolean onLongClick(View v) {
     public void onActivityCreated(final Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
 
-        sessionTracker = new SessionTracker(getActivity(), new Session.StatusCallback() {
+        accessTokenTracker = new AccessTokenTracker() {
             @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                if (!session.isOpened()) {
-                    // When a session is closed, we want to clear out our data so it is not visible to subsequent users
-                    clearResults();
-                }
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                clearResults();
             }
-        });
+        };
 
         setSettingsFromBundle(savedInstanceState);
 
@@ -222,7 +225,7 @@ public void onDetach() {
         listView.setAdapter(null);
 
         loadingStrategy.detach();
-        sessionTracker.stopTracking();
+        accessTokenTracker.stopTracking();
     }
 
     @Override
@@ -339,7 +342,7 @@ public void setOnErrorListener(OnErrorListener onErrorListener) {
      *
      * @return the GraphObjectFilter, or null if there is none
      */
-    public GraphObjectFilter<T> getFilter() {
+    public GraphObjectFilter getFilter() {
         return filter;
     }
 
@@ -350,29 +353,10 @@ public void setOnErrorListener(OnErrorListener onErrorListener) {
      *
      * @param filter the GraphObjectFilter, or null if there is none
      */
-    public void setFilter(GraphObjectFilter<T> filter) {
+    public void setFilter(GraphObjectFilter filter) {
         this.filter = filter;
     }
 
-    /**
-     * Gets the Session to use for any Facebook requests this fragment will make.
-     *
-     * @return the Session that will be used for any Facebook requests, or null if there is none
-     */
-    public Session getSession() {
-        return sessionTracker.getSession();
-    }
-
-    /**
-     * Sets the Session to use for any Facebook requests this fragment will make. If the
-     * parameter is null, the fragment will use the current active session, if any.
-     *
-     * @param session the Session to use for Facebook requests, or null to use the active session
-     */
-    public void setSession(Session session) {
-        sessionTracker.setSession(session);
-    }
-
     /**
      * Gets whether to display pictures, if available, for displayed graph objects.
      *
@@ -484,10 +468,28 @@ public String getDoneButtonText() {
      *                    if false, data will not be re-loaded if it is already displayed (or loading)
      */
     public void loadData(boolean forceReload) {
+        loadData(forceReload, null);
+    }
+
+    /**
+     * Causes the picker to load data from the service and display it to the user.
+     *
+     * @param forceReload if true, data will be loaded even if there is already data being displayed (or loading);
+     *                    if false, data will not be re-loaded if it is already displayed (or loading)
+     * @param selectIds ids to select, if they are present in the loaded data
+     */
+    public void loadData(boolean forceReload, Set<String> selectIds) {
         if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
             return;
         }
-        loadDataSkippingRoundTripIfCached();
+        selectionHint = selectIds;
+        clearResults();
+
+        GraphRequest request = getRequestForLoadData();
+        if (request != null) {
+            onLoadingData();
+            loadingStrategy.startLoading(request);
+        }
     }
 
     /**
@@ -498,20 +500,43 @@ public void loadData(boolean forceReload) {
      * @param inState a Bundle containing keys corresponding to properties of the PickerFragment
      */
     public void setSettingsFromBundle(Bundle inState) {
-        setPickerFragmentSettingsFromBundle(inState);
+        if (inState != null) {
+            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
+            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
+            if (extraFieldsString != null) {
+                String[] strings = extraFieldsString.split(",");
+                setExtraFields(Arrays.asList(strings));
+            }
+            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
+            if (titleTextString != null) {
+                titleText = titleTextString;
+                if (titleTextView != null) {
+                    titleTextView.setText(titleText);
+                }
+            }
+            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
+            if (doneButtonTextString != null) {
+                doneButtonText = doneButtonTextString;
+                if (doneButton != null) {
+                    doneButton.setText(doneButtonText);
+                }
+            }
+        }
+
     }
 
     void setupViews(ViewGroup view) {
     }
 
-    boolean filterIncludesItem(T graphObject) {
+    boolean filterIncludesItem(JSONObject graphObject) {
         if (filter != null) {
             return filter.includeItem(graphObject);
         }
         return true;
     }
 
-    List<T> getSelectedGraphObjects() {
+    List<JSONObject> getSelectedGraphObjects() {
         return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
     }
 
@@ -533,9 +558,9 @@ void saveSettingsToBundle(Bundle outState) {
         outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
     }
 
-    abstract Request getRequestForLoadData(Session session);
+    abstract GraphRequest getRequestForLoadData();
 
-    abstract PickerFragmentAdapter<T> createAdapter();
+    abstract PickerFragmentAdapter createAdapter();
 
     abstract LoadingStrategy createLoadingStrategy();
 
@@ -549,7 +574,7 @@ String getDefaultTitleText() {
     }
 
     String getDefaultDoneButtonText() {
-        return getString(R.string.com_facebook_picker_done_button_text);
+        return getString(R.string.picker_picker_done_button_text);
     }
 
     void displayActivityCircle() {
@@ -595,34 +620,6 @@ private static void setAlpha(View view, float alpha) {
         view.startAnimation(alphaAnimation);
     }
 
-
-    private void setPickerFragmentSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
-            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
-            if (extraFieldsString != null) {
-                String[] strings = extraFieldsString.split(",");
-                setExtraFields(Arrays.asList(strings));
-            }
-            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
-            if (titleTextString != null) {
-                titleText = titleTextString;
-                if (titleTextView != null) {
-                    titleTextView.setText(titleText);
-                }
-            }
-            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
-            if (doneButtonTextString != null) {
-                doneButtonText = doneButtonTextString;
-                if (doneButton != null) {
-                    doneButton.setText(doneButtonText);
-                }
-            }
-        }
-    }
-
     private void inflateTitleBar(ViewGroup view) {
         ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
         if (stub != null) {
@@ -672,7 +669,7 @@ public void onClick(View v) {
 
     private void onListItemClick(ListView listView, View v, int position) {
         @SuppressWarnings("unchecked")
-        T graphObject = (T) listView.getItemAtPosition(position);
+        JSONObject graphObject = (JSONObject) listView.getItemAtPosition(position);
         String id = adapter.getIdOfGraphObject(graphObject);
         selectionStrategy.toggleSelection(id);
         adapter.notifyDataSetChanged();
@@ -682,16 +679,6 @@ private void onListItemClick(ListView listView, View v, int position) {
         }
     }
 
-    private void loadDataSkippingRoundTripIfCached() {
-        clearResults();
-
-        Request request = getRequestForLoadData(getSession());
-        if (request != null) {
-            onLoadingData();
-            loadingStrategy.startLoading(request);
-        }
-    }
-
     private void clearResults() {
         if (adapter != null) {
             boolean wasSelection = !selectionStrategy.isEmpty();
@@ -711,7 +698,7 @@ private void clearResults() {
         }
     }
 
-    void updateAdapter(SimpleGraphObjectCursor<T> data) {
+    void updateAdapter(GraphObjectCursor data) {
         if (adapter != null) {
             // As we fetch additional results and add them to the table, we do not
             // want the items displayed jumping around seemingly at random, frustrating the user's
@@ -729,7 +716,7 @@ void updateAdapter(SimpleGraphObjectCursor<T> data) {
             if (anchorPosition > 0) {
                 anchorPosition++;
             }
-            GraphObjectAdapter.SectionAndItem<T> anchorItem = adapter.getSectionAndItem(anchorPosition);
+            GraphObjectAdapter.SectionAndItem anchorItem = adapter.getSectionAndItem(anchorPosition);
             final int top = (view != null &&
                     anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
                     view.getTop() : 0;
@@ -748,6 +735,28 @@ void updateAdapter(SimpleGraphObjectCursor<T> data) {
             if (dataChanged && onDataChangedListener != null) {
                 onDataChangedListener.onDataChanged(PickerFragment.this);
             }
+            if (selectionHint != null && !selectionHint.isEmpty() && data != null) {
+                data.moveToFirst();
+                boolean changed = false;
+                for (int i = 0; i < data.getCount(); i++) {
+                    data.moveToPosition(i);
+                    String id = data.getGraphObject().optString("id");
+                    if (id == null) {
+                        continue;
+                    }
+                    if (selectionHint.contains(id)) {
+                        selectionStrategy.toggleSelection(id);
+                        selectionHint.remove(id);
+                        changed = true;
+                    }
+                    if (selectionHint.isEmpty()) {
+                        break;
+                    }
+                }
+                if (onSelectionChangedListener != null && changed) {
+                    onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
+                }
+            }
         }
     }
 
@@ -780,7 +789,7 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
          *
          * @param error a FacebookException representing the error that was encountered.
          */
-        void onError(PickerFragment<?> fragment, FacebookException error);
+        void onError(PickerFragment fragment, FacebookException error);
     }
 
     /**
@@ -791,7 +800,7 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
         /**
          * Called when the set of data being displayed in the picker has changed.
          */
-        void onDataChanged(PickerFragment<?> fragment);
+        void onDataChanged(PickerFragment fragment);
     }
 
     /**
@@ -802,7 +811,7 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
         /**
          * Called when the user selects or unselects graph objects in the picker.
          */
-        void onSelectionChanged(PickerFragment<?> fragment);
+        void onSelectionChanged(PickerFragment fragment);
     }
 
     /**
@@ -813,59 +822,57 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
         /**
          * Called when the user clicks the Done button.
          */
-        void onDoneButtonClicked(PickerFragment<?> fragment);
+        void onDoneButtonClicked(PickerFragment fragment);
     }
 
     /**
      * Callback interface that will be called to determine if a graph object should be displayed.
-     *
-     * @param <T>
      */
-    public interface GraphObjectFilter<T> {
+    public interface GraphObjectFilter {
         /**
          * Called to determine if a graph object should be displayed.
          *
          * @param graphObject the graph object
          * @return true to display the graph object, false to hide it
          */
-        boolean includeItem(T graphObject);
+        boolean includeItem(JSONObject graphObject);
     }
 
     abstract class LoadingStrategy {
         protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
 
-        protected GraphObjectPagingLoader<T> loader;
-        protected GraphObjectAdapter<T> adapter;
+        protected GraphObjectPagingLoader loader;
+        protected GraphObjectAdapter adapter;
 
-        public void attach(GraphObjectAdapter<T> adapter) {
-            loader = (GraphObjectPagingLoader<T>) getLoaderManager().initLoader(0, null,
-                    new LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>>() {
+        public void attach(GraphObjectAdapter adapter) {
+            loader = (GraphObjectPagingLoader) getLoaderManager().initLoader(0, null,
+                    new LoaderManager.LoaderCallbacks<GraphObjectCursor>() {
                         @Override
-                        public Loader<SimpleGraphObjectCursor<T>> onCreateLoader(int id, Bundle args) {
+                        public Loader<GraphObjectCursor> onCreateLoader(int id, Bundle args) {
                             return LoadingStrategy.this.onCreateLoader();
                         }
 
                         @Override
-                        public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader,
-                                SimpleGraphObjectCursor<T> data) {
+                        public void onLoadFinished(Loader<GraphObjectCursor> loader,
+                                GraphObjectCursor data) {
                             if (loader != LoadingStrategy.this.loader) {
                                 throw new FacebookException("Received callback for unknown loader.");
                             }
-                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader<T>) loader, data);
+                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader) loader, data);
                         }
 
                         @Override
-                        public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
+                        public void onLoaderReset(Loader<GraphObjectCursor> loader) {
                             if (loader != LoadingStrategy.this.loader) {
                                 throw new FacebookException("Received callback for unknown loader.");
                             }
-                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader<T>) loader);
+                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader) loader);
                         }
                     });
 
             loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
                 @Override
-                public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
+                public void onError(FacebookException error, GraphObjectPagingLoader loader) {
                     hideActivityCircle();
                     if (onErrorListener != null) {
                         onErrorListener.onError(PickerFragment.this, error);
@@ -878,7 +885,7 @@ public void onError(FacebookException error, GraphObjectPagingLoader<?> loader)
             this.adapter.changeCursor(loader.getCursor());
             this.adapter.setOnErrorListener(new GraphObjectAdapter.OnErrorListener() {
                 @Override
-                public void onError(GraphObjectAdapter<?> adapter, FacebookException error) {
+                public void onError(GraphObjectAdapter adapter, FacebookException error) {
                     if (onErrorListener != null) {
                         onErrorListener.onError(PickerFragment.this, error);
                     }
@@ -901,9 +908,9 @@ public void clearResults() {
             }
         }
 
-        public void startLoading(Request request) {
+        public void startLoading(GraphRequest request) {
             if (loader != null) {
-                loader.startLoading(request, true);
+                loader.startLoading(request);
                 onStartLoading(loader, request);
             }
         }
@@ -912,19 +919,19 @@ public boolean isDataPresentOrLoading() {
             return !adapter.isEmpty() || loader.isLoading();
         }
 
-        protected GraphObjectPagingLoader<T> onCreateLoader() {
-            return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
+        protected GraphObjectPagingLoader onCreateLoader() {
+            return new GraphObjectPagingLoader(getActivity());
         }
 
-        protected void onStartLoading(GraphObjectPagingLoader<T> loader, Request request) {
+        protected void onStartLoading(GraphObjectPagingLoader loader, GraphRequest request) {
             displayActivityCircle();
         }
 
-        protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
+        protected void onLoadReset(GraphObjectPagingLoader loader) {
             adapter.changeCursor(null);
         }
 
-        protected void onLoadFinished(GraphObjectPagingLoader<T> loader, SimpleGraphObjectCursor<T> data) {
+        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
             updateAdapter(data);
         }
     }
@@ -1057,7 +1064,7 @@ boolean shouldShowCheckBoxIfUnselected() {
         }
     }
 
-    abstract class PickerFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
+    abstract class PickerFragmentAdapter extends GraphObjectAdapter {
         public PickerFragmentAdapter(Context context) {
             super(context);
         }
@@ -1070,8 +1077,8 @@ boolean isGraphObjectSelected(String graphObjectId) {
         @Override
         void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
             checkBox.setChecked(graphObjectSelected);
-            int visible = (graphObjectSelected || selectionStrategy
-                    .shouldShowCheckBoxIfUnselected()) ? View.VISIBLE : View.GONE;
+            int visible = (graphObjectSelected || selectionStrategy.shouldShowCheckBoxIfUnselected())
+                    ? View.VISIBLE : View.GONE;
             checkBox.setVisibility(visible);
         }
     }
diff --git a/facebook/src/com/facebook/widget/PlacePickerFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/picker/PlacePickerFragment.java
similarity index 76%
rename from facebook/src/com/facebook/widget/PlacePickerFragment.java
rename to samples/Scrumptious/src/com/facebook/scrumptious/picker/PlacePickerFragment.java
index 58b277583..5e196f8a1 100644
--- a/facebook/src/com/facebook/widget/PlacePickerFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/picker/PlacePickerFragment.java
@@ -1,20 +1,24 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-package com.facebook.widget;
+package com.facebook.scrumptious.picker;
 
 import android.app.Activity;
 import android.content.Context;
@@ -33,40 +37,42 @@
 import android.widget.EditText;
 import android.widget.ListView;
 import com.facebook.*;
-import com.facebook.android.R;
+import com.facebook.appevents.AppEventsLogger;
+import com.facebook.scrumptious.R;
 import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphPlace;
 import com.facebook.internal.Logger;
 import com.facebook.internal.Utility;
 
+import org.json.JSONObject;
+
 import java.util.*;
 
-public class PlacePickerFragment extends PickerFragment<GraphPlace> {
+public class PlacePickerFragment extends PickerFragment {
     /**
      * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
      * the center point to search. The default is 1000 meters.
      */
-    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters";
+    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.RadiusInMeters";
     /**
      * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
      * return at a time. The default is 100 results.
      */
-    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit";
+    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.ResultsLimit";
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
      * be sent to the service. The default is to have no search text.
      */
-    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText";
+    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.SearchText";
     /**
      * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
      * location should be the center of the search.
      */
-    public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location";
+    public static final String LOCATION_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.Location";
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
      * should display a search box and automatically update the search text as it changes.
      */
-    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox";
+    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.ShowSearchBox";
 
     /**
      * The default radius around the center point to search.
@@ -99,18 +105,7 @@
      * Default constructor. Creates a Fragment with all default properties.
      */
     public PlacePickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param args a Bundle that optionally contains one or more values containing additional
-     *             configuration information for the Fragment.
-     */
-    public PlacePickerFragment(Bundle args) {
-        super(GraphPlace.class, R.layout.com_facebook_placepickerfragment, args);
-        setPlacePickerSettingsFromBundle(args);
+        super(R.layout.picker_placepickerfragment);
     }
 
     /**
@@ -231,27 +226,39 @@ public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIf
      *
      * @return the currently-selected place, or null if there is none
      */
-    public GraphPlace getSelection() {
-        Collection<GraphPlace> selection = getSelectedGraphObjects();
+    public JSONObject getSelection() {
+        Collection<JSONObject> selection = getSelectedGraphObjects();
         return (selection != null && !selection.isEmpty()) ? selection.iterator().next() : null;
     }
 
+    @Override
     public void setSettingsFromBundle(Bundle inState) {
         super.setSettingsFromBundle(inState);
-        setPlacePickerSettingsFromBundle(inState);
+        if (inState != null) {
+            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
+            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
+            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
+                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
+            }
+            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
+                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
+                setLocation(location);
+            }
+            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
+        }
     }
 
     @Override
     public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
         super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_place_picker_fragment);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_place_picker_fragment);
 
-        setRadiusInMeters(a.getInt(R.styleable.com_facebook_place_picker_fragment_radius_in_meters, radiusInMeters));
-        setResultsLimit(a.getInt(R.styleable.com_facebook_place_picker_fragment_results_limit, resultsLimit));
-        if (a.hasValue(R.styleable.com_facebook_place_picker_fragment_results_limit)) {
-            setSearchText(a.getString(R.styleable.com_facebook_place_picker_fragment_search_text));
+        setRadiusInMeters(a.getInt(R.styleable.picker_place_picker_fragment_radius_in_meters, radiusInMeters));
+        setResultsLimit(a.getInt(R.styleable.picker_place_picker_fragment_results_limit, resultsLimit));
+        if (a.hasValue(R.styleable.picker_place_picker_fragment_results_limit)) {
+            setSearchText(a.getString(R.styleable.picker_place_picker_fragment_search_text));
         }
-        showSearchBox = a.getBoolean(R.styleable.com_facebook_place_picker_fragment_show_search_box, showSearchBox);
+        showSearchBox = a.getBoolean(R.styleable.picker_place_picker_fragment_show_search_box, showSearchBox);
 
         a.recycle();
     }
@@ -262,7 +269,7 @@ void setupViews(ViewGroup view) {
             ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
 
             View searchHeaderView = getActivity().getLayoutInflater().inflate(
-                    R.layout.com_facebook_picker_search_box, listView, false);
+                    R.layout.picker_search_box, listView, false);
 
             listView.addHeaderView(searchHeaderView, null, false);
 
@@ -311,18 +318,19 @@ void onLoadingData() {
     }
 
     @Override
-    Request getRequestForLoadData(Session session) {
-        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields, session);
+    GraphRequest getRequestForLoadData() {
+        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields);
     }
 
     @Override
     String getDefaultTitleText() {
-        return getString(R.string.com_facebook_nearby);
+        return getResources().getString(R.string.nearby);
     }
 
     @Override
     void logAppEvents(boolean doneButtonClicked) {
-        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(), getSession());
+        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
+                AccessToken.getCurrentAccessToken().getToken());
         Bundle parameters = new Bundle();
 
         // If Done was clicked, we know this completed successfully. If not, we don't know (caller might have
@@ -337,33 +345,33 @@ void logAppEvents(boolean doneButtonClicked) {
     }
 
     @Override
-    PickerFragmentAdapter<GraphPlace> createAdapter() {
-        PickerFragmentAdapter<GraphPlace> adapter = new PickerFragmentAdapter<GraphPlace>(
+    PickerFragmentAdapter createAdapter() {
+        PickerFragmentAdapter adapter = new PickerFragmentAdapter(
                 this.getActivity()) {
             @Override
-            protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
-                String category = graphObject.getCategory();
-                Integer wereHereCount = (Integer) graphObject.getProperty(WERE_HERE_COUNT);
+            protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
+                String category = graphObject.optString(CATEGORY);
+                int wereHereCount = graphObject.optInt(WERE_HERE_COUNT);
 
                 String result = null;
-                if (category != null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_format, category, wereHereCount);
-                } else if (category == null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_were_here_only_format, wereHereCount);
-                } else if (category != null && wereHereCount == null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_catetory_only_format, category);
+                if (category != null && wereHereCount != 0) {
+                    result = getString(R.string.picker_placepicker_subtitle_format, category, wereHereCount);
+                } else if (category == null && wereHereCount != 0) {
+                    result = getString(R.string.picker_placepicker_subtitle_were_here_only_format, wereHereCount);
+                } else if (category != null && wereHereCount == 0) {
+                    result = getString(R.string.picker_placepicker_subtitle_catetory_only_format, category);
                 }
                 return result;
             }
 
             @Override
-            protected int getGraphObjectRowLayoutId(GraphPlace graphObject) {
-                return R.layout.com_facebook_placepickerfragment_list_row;
+            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
+                return R.layout.picker_placepickerfragment_list_row;
             }
 
             @Override
             protected int getDefaultPicture() {
-                return R.drawable.com_facebook_place_default_icon;
+                return R.drawable.picker_place_default_icon;
             }
 
         };
@@ -382,11 +390,11 @@ SelectionStrategy createSelectionStrategy() {
         return new SingleSelectionStrategy();
     }
 
-    private Request createRequest(Location location, int radiusInMeters, int resultsLimit, String searchText,
-            Set<String> extraFields,
-            Session session) {
-        Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
-                null);
+    private GraphRequest createRequest(Location location, int radiusInMeters, int resultsLimit,
+                                  String searchText, Set<String> extraFields) {
+        AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, location, radiusInMeters,
+                resultsLimit, searchText, null);
 
         Set<String> fields = new HashSet<String>(extraFields);
         String[] requiredFields = new String[]{
@@ -410,22 +418,6 @@ private Request createRequest(Location location, int radiusInMeters, int results
         return request;
     }
 
-    private void setPlacePickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
-            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
-            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
-                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
-            }
-            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
-                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
-                setLocation(location);
-            }
-            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
-        }
-    }
-
     private Timer createSearchTextTimer() {
         Timer timer = new Timer();
         timer.schedule(new TimerTask() {
@@ -473,14 +465,14 @@ public void run() {
 
     private class AsNeededLoadingStrategy extends LoadingStrategy {
         @Override
-        public void attach(GraphObjectAdapter<GraphPlace> adapter) {
+        public void attach(GraphObjectAdapter adapter) {
             super.attach(adapter);
 
             this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
                 @Override
                 public void onDataNeeded() {
-                    // Do nothing if we are currently loading data . We will get notified again when that load finishes if the adapter still
-                    // needs more data. Otherwise, follow the next link.
+                    // Do nothing if we are currently loading data . We will get notified again when that load finishes
+                    // if the adapter still needs more data. Otherwise, follow the next link.
                     if (!loader.isLoading()) {
                         loader.followNextLink();
                     }
@@ -489,8 +481,7 @@ public void onDataNeeded() {
         }
 
         @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
-                SimpleGraphObjectCursor<GraphPlace> data) {
+        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
             super.onLoadFinished(loader, data);
 
             // We could be called in this state if we are clearing data or if we are being re-attached
@@ -500,13 +491,6 @@ protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
             }
 
             hideActivityCircle();
-
-            if (data.isFromCache()) {
-                // Only the first page can be cached, since all subsequent pages will be round-tripped. Force
-                // a refresh of the first page before we allow paging to begin. If the first page produced
-                // no data, launch the refresh immediately, otherwise schedule it for later.
-                loader.refreshOriginalRequest(data.areMoreObjectsAvailable() ? CACHED_RESULT_REFRESH_DELAY : 0);
-            }
         }
     }
 
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/usersettings/UserSettingsFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/usersettings/UserSettingsFragment.java
new file mode 100644
index 000000000..097fbd010
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/usersettings/UserSettingsFragment.java
@@ -0,0 +1,245 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.scrumptious.usersettings;
+
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.CallbackManager;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.internal.ImageDownloader;
+import com.facebook.internal.ImageRequest;
+import com.facebook.internal.ImageResponse;
+import com.facebook.scrumptious.R;
+import com.facebook.login.widget.LoginButton;
+
+import org.json.JSONObject;
+
+/**
+ * A Fragment that displays a Login/Logout button as well as the user's
+ * profile picture and name when logged in.
+ */
+public final class UserSettingsFragment extends Fragment {
+
+    private static final String NAME = "name";
+    private static final String ID = "id";
+    private static final String PICTURE = "picture";
+    private static final String FIELDS = "fields";
+    
+    private static final String REQUEST_FIELDS =
+            TextUtils.join(",", new String[] {ID, NAME, PICTURE});
+
+    private AccessTokenTracker accessTokenTracker;
+    private CallbackManager callbackManager;
+
+    private LoginButton loginButton;
+    private TextView connectedStateLabel;
+    private JSONObject user;
+    private Drawable userProfilePic;
+    private String userProfilePicID;
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
+                                                       AccessToken currentAccessToken) {
+                fetchUserInfo();
+                updateUI();
+
+            }
+        };
+        callbackManager = CallbackManager.Factory.create();
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        accessTokenTracker.stopTracking();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
+        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
+        loginButton.setFragment(this);
+
+        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);
+        
+        // if no background is set for some reason, then default to Facebook blue
+        if (view.getBackground() == null) {
+            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+        } else {
+            view.getBackground().setDither(true);
+        }
+        return view;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    /**
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void onResume() {
+        super.onResume();
+        fetchUserInfo();
+        updateUI();
+    }
+
+    private void fetchUserInfo() {
+        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
+        if (accessToken != null) {
+            GraphRequest request = GraphRequest.newMeRequest(
+                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
+                        @Override
+                        public void onCompleted(JSONObject me, GraphResponse response) {
+                            user = me;
+                            updateUI();
+                        }
+                    });
+            Bundle parameters = new Bundle();
+            parameters.putString(FIELDS, REQUEST_FIELDS);
+            request.setParameters(parameters);
+            GraphRequest.executeBatchAsync(request);
+        } else {
+            user = null;
+        }
+    }
+    
+    private void updateUI() {
+        if (!isAdded()) {
+            return;
+        }
+        if (AccessToken.getCurrentAccessToken() != null) {
+            connectedStateLabel.setTextColor(getResources().getColor(
+                    R.color.usersettings_fragment_connected_text_color));
+            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
+                    getResources().getColor(
+                            R.color.usersettings_fragment_connected_shadow_color));
+            
+            if (user != null) {
+                ImageRequest request = getImageRequest();
+                if (request != null) {
+                    Uri requestUri = request.getImageUri();
+                    // Do we already have the right picture? If so, leave it alone.
+                    if (!requestUri.equals(connectedStateLabel.getTag())) {
+                        if (user.optString("id").equals(userProfilePicID)) {
+                            connectedStateLabel.setCompoundDrawables(
+                                    null, userProfilePic, null, null);
+                            connectedStateLabel.setTag(requestUri);
+                        } else {
+                            ImageDownloader.downloadAsync(request);
+                        }
+                    }
+                }
+                connectedStateLabel.setText(user.optString("name"));
+            } else {
+                connectedStateLabel.setText(getResources().getString(
+                        R.string.usersettings_fragment_logged_in));
+                Drawable noProfilePic = getResources().getDrawable(
+                        R.drawable.profile_default_icon);
+                noProfilePic.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height));
+                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
+            }
+        } else {
+            int textColor = getResources().getColor(
+                    R.color.usersettings_fragment_not_connected_text_color);
+            connectedStateLabel.setTextColor(textColor);
+            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
+            connectedStateLabel.setText(getResources().getString(
+                    R.string.usersettings_fragment_not_logged_in));
+            connectedStateLabel.setCompoundDrawables(null, null, null, null);
+            connectedStateLabel.setTag(null);
+        }
+    }
+
+    private ImageRequest getImageRequest() {
+        ImageRequest request = null;
+        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                getActivity(),
+                ImageRequest.getProfilePictureUri(
+                        user.optString("id"),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height)));
+
+        request = requestBuilder.setCallerTag(this)
+                .setCallback(
+                        new ImageRequest.Callback() {
+                            @Override
+                            public void onCompleted(ImageResponse response) {
+                                processImageResponse(user.optString("id"), response);
+                            }
+                        })
+                .build();
+        return request;
+    }
+
+    private void processImageResponse(String id, ImageResponse response) {
+        if (response != null) {
+            Bitmap bitmap = response.getBitmap();
+            if (bitmap != null) {
+                BitmapDrawable drawable = new BitmapDrawable(
+                        UserSettingsFragment.this.getResources(), bitmap);
+                drawable.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(
+                                R.dimen.usersettings_fragment_profile_picture_height));
+                userProfilePic = drawable;
+                userProfilePicID = id;
+                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
+                connectedStateLabel.setTag(response.getRequest().getImageUri());
+            }
+        }
+    }
+}
diff --git a/samples/SessionLoginSample/.classpath b/samples/SessionLoginSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/SessionLoginSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/SessionLoginSample/.project b/samples/SessionLoginSample/.project
deleted file mode 100644
index a6c125972..000000000
--- a/samples/SessionLoginSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SessionLoginSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/SessionLoginSample/AndroidManifest.xml b/samples/SessionLoginSample/AndroidManifest.xml
deleted file mode 100644
index be2beb9be..000000000
--- a/samples/SessionLoginSample/AndroidManifest.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.samples.sessionlogin"
-    android:versionCode="1"
-    android:versionName="1.0" >
-
-    <uses-sdk android:minSdkVersion="8" />
-    <uses-permission android:name="android.permission.INTERNET"/>
-
-    <application
-        android:icon="@drawable/icon"
-        android:label="@string/app_name" >
-        <activity
-            android:name=".SessionLoginSampleActivity"
-            android:label="@string/app_name"
-            android:windowSoftInputMode="adjustResize">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <activity
-                android:name=".LoginUsingActivityActivity">
-        </activity>
-        <activity
-                android:name=".LoginUsingCustomFragmentActivity">
-        </activity>
-        <activity android:name="com.facebook.LoginActivity"
-                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
-                  android:label="@string/app_name" />
-        <activity android:name=".LoginUsingLoginFragmentActivity"/>
-        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id" />
-    </application>
-
-</manifest>
diff --git a/samples/SessionLoginSample/ant.properties b/samples/SessionLoginSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/SessionLoginSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/SessionLoginSample/build.gradle b/samples/SessionLoginSample/build.gradle
deleted file mode 100644
index a2cda0280..000000000
--- a/samples/SessionLoginSample/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'android'
-
-dependencies {
-    compile project(':facebook')
-}
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
-
-    defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
-        }
-    }
-}
diff --git a/samples/SessionLoginSample/build.xml b/samples/SessionLoginSample/build.xml
deleted file mode 100644
index 4f044bbee..000000000
--- a/samples/SessionLoginSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="SessionLoginSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env" />
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME" />
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/samples/SessionLoginSample/proguard-project.txt b/samples/SessionLoginSample/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/samples/SessionLoginSample/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/SessionLoginSample/project.properties b/samples/SessionLoginSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/SessionLoginSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/SessionLoginSample/res/drawable-hdpi/icon.png b/samples/SessionLoginSample/res/drawable-hdpi/icon.png
deleted file mode 100644
index 78d41ad5f..000000000
Binary files a/samples/SessionLoginSample/res/drawable-hdpi/icon.png and /dev/null differ
diff --git a/samples/SessionLoginSample/res/drawable-mdpi/icon.png b/samples/SessionLoginSample/res/drawable-mdpi/icon.png
deleted file mode 100644
index 22598aa33..000000000
Binary files a/samples/SessionLoginSample/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/samples/SessionLoginSample/res/drawable-xhdpi/icon.png b/samples/SessionLoginSample/res/drawable-xhdpi/icon.png
deleted file mode 100644
index a2c3cb4b2..000000000
Binary files a/samples/SessionLoginSample/res/drawable-xhdpi/icon.png and /dev/null differ
diff --git a/samples/SessionLoginSample/res/drawable/icon.png b/samples/SessionLoginSample/res/drawable/icon.png
deleted file mode 100644
index 22598aa33..000000000
Binary files a/samples/SessionLoginSample/res/drawable/icon.png and /dev/null differ
diff --git a/samples/SessionLoginSample/res/layout/activity.xml b/samples/SessionLoginSample/res/layout/activity.xml
deleted file mode 100644
index 52ca3daf9..000000000
--- a/samples/SessionLoginSample/res/layout/activity.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:orientation="vertical" >
-
-    <TextView
-        android:id="@+id/instructionsOrLink"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:text="@string/instructions"
-        android:autoLink="web"
-        android:linksClickable="true"
-        android:textAppearance="?android:attr/textAppearanceMedium" />
-
-    <Button
-        android:id="@+id/buttonLoginLogout"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:text="@string/login" />
-
-</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml b/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
deleted file mode 100644
index 09e8eb440..000000000
--- a/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:orientation="vertical" >
-
-    <fragment android:layout_height="fill_parent"
-              android:layout_width="fill_parent"
-              android:id="@+id/fragment"
-              android:name="com.facebook.samples.sessionlogin.SessionLoginFragment" />
-
-</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/fragment.xml b/samples/SessionLoginSample/res/layout/fragment.xml
deleted file mode 100644
index 8b3bbf7db..000000000
--- a/samples/SessionLoginSample/res/layout/fragment.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-              android:orientation="vertical">
-
-<TextView
-            android:id="@+id/instructionsOrLink"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:text="@string/instructions"
-            android:autoLink="web"
-            android:linksClickable="true"
-            android:textAppearance="?android:attr/textAppearanceMedium" />
-
-    <Button
-            android:id="@+id/buttonLoginLogout"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:text="@string/login" />
-
-</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/login_fragment_activity.xml b/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
deleted file mode 100644
index 8ad44a93c..000000000
--- a/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <fragment android:layout_height="fill_parent"
-              android:layout_width="fill_parent"
-              android:id="@+id/login_fragment"
-              android:name="com.facebook.widget.UserSettingsFragment" />
-
-</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/main.xml b/samples/SessionLoginSample/res/layout/main.xml
deleted file mode 100644
index a8042a2c1..000000000
--- a/samples/SessionLoginSample/res/layout/main.xml
+++ /dev/null
@@ -1,41 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:orientation="vertical" >
-
-    <Button
-        android:id="@+id/buttonLoginActivity"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:text="@string/login_using_activity" />
-
-    <Button
-            android:id="@+id/buttonLoginCustomFragment"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:text="@string/login_using_custom_fragment" />
-
-    <Button
-            android:id="@+id/buttonLoginFragment"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:text="@string/login_using_usersettingsfragment" />
-
-</LinearLayout>
diff --git a/samples/SessionLoginSample/res/values/strings.xml b/samples/SessionLoginSample/res/values/strings.xml
deleted file mode 100644
index bcece0ad1..000000000
--- a/samples/SessionLoginSample/res/values/strings.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-
-    <string name="login_using_activity">Login using Activity</string>
-    <string name="login_using_custom_fragment">Login using Custom Fragment</string>
-    <string name="login_using_usersettingsfragment">Login using UserSettingsFragment</string>
-    <string name="hello">Hello World, SessionLoginSampleActivity!</string>
-    <string name="app_name">SessionLoginSample</string>
-    <string name="login">Login</string>
-    <string name="instructions">Login to create a link to fetch account data</string>
-    <string name="logout">Log out</string>
-    <string name="app_id">380615018626574</string>
-
-</resources>
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
deleted file mode 100644
index df4049f65..000000000
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.sessionlogin;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.TextView;
-import com.facebook.LoggingBehavior;
-import com.facebook.Session;
-import com.facebook.SessionState;
-import com.facebook.Settings;
-
-public class LoginUsingActivityActivity extends Activity {
-    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
-
-    private TextView textInstructionsOrLink;
-    private Button buttonLoginLogout;
-    private Session.StatusCallback statusCallback = new SessionStatusCallback();
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity);
-        buttonLoginLogout = (Button)findViewById(R.id.buttonLoginLogout);
-        textInstructionsOrLink = (TextView)findViewById(R.id.instructionsOrLink);
-
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
-
-        Session session = Session.getActiveSession();
-        if (session == null) {
-            if (savedInstanceState != null) {
-                session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
-            }
-            if (session == null) {
-                session = new Session(this);
-            }
-            Session.setActiveSession(session);
-            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
-                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
-            }
-        }
-
-        updateView();
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        Session.getActiveSession().addCallback(statusCallback);
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        Session.getActiveSession().removeCallback(statusCallback);
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        Session session = Session.getActiveSession();
-        Session.saveSession(session, outState);
-    }
-
-    private void updateView() {
-        Session session = Session.getActiveSession();
-        if (session.isOpened()) {
-            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
-            buttonLoginLogout.setText(R.string.logout);
-            buttonLoginLogout.setOnClickListener(new OnClickListener() {
-                public void onClick(View view) { onClickLogout(); }
-            });
-        } else {
-            textInstructionsOrLink.setText(R.string.instructions);
-            buttonLoginLogout.setText(R.string.login);
-            buttonLoginLogout.setOnClickListener(new OnClickListener() {
-                public void onClick(View view) { onClickLogin(); }
-            });
-        }
-    }
-
-    private void onClickLogin() {
-        Session session = Session.getActiveSession();
-        if (!session.isOpened() && !session.isClosed()) {
-            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
-        } else {
-            Session.openActiveSession(this, true, statusCallback);
-        }
-    }
-
-    private void onClickLogout() {
-        Session session = Session.getActiveSession();
-        if (!session.isClosed()) {
-            session.closeAndClearTokenInformation();
-        }
-    }
-
-    private class SessionStatusCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            updateView();
-        }
-    }
-}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
deleted file mode 100644
index 1e06f6999..000000000
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.sessionlogin;
-
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-
-public class LoginUsingCustomFragmentActivity extends FragmentActivity {
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.custom_fragment_activity);
-    }
-}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
deleted file mode 100644
index 59f54c603..000000000
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.sessionlogin;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.util.Log;
-import com.facebook.Session;
-import com.facebook.SessionState;
-import com.facebook.widget.UserSettingsFragment;
-
-public class LoginUsingLoginFragmentActivity extends FragmentActivity {
-    private UserSettingsFragment userSettingsFragment;
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setContentView(R.layout.login_fragment_activity);
-
-        FragmentManager fragmentManager = getSupportFragmentManager();
-        userSettingsFragment = (UserSettingsFragment) fragmentManager.findFragmentById(R.id.login_fragment);
-        userSettingsFragment.setSessionStatusCallback(new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                Log.d("LoginUsingLoginFragmentActivity", String.format("New session state: %s", state.toString()));
-            }
-        });
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        userSettingsFragment.onActivityResult(requestCode, resultCode, data);
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
deleted file mode 100644
index 18ec1b098..000000000
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.sessionlogin;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.TextView;
-import com.facebook.LoggingBehavior;
-import com.facebook.Session;
-import com.facebook.SessionState;
-import com.facebook.Settings;
-
-public class SessionLoginFragment extends Fragment {
-    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
-
-    private TextView textInstructionsOrLink;
-    private Button buttonLoginLogout;
-    private Session.StatusCallback statusCallback = new SessionStatusCallback();
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View view = inflater.inflate(R.layout.fragment, container, false);
-
-        buttonLoginLogout = (Button) view.findViewById(R.id.buttonLoginLogout);
-        textInstructionsOrLink = (TextView) view.findViewById(R.id.instructionsOrLink);
-
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
-
-        Session session = Session.getActiveSession();
-        if (session == null) {
-            if (savedInstanceState != null) {
-                session = Session.restoreSession(getActivity(), null, statusCallback, savedInstanceState);
-            }
-            if (session == null) {
-                session = new Session(getActivity());
-            }
-            Session.setActiveSession(session);
-            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
-                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
-            }
-        }
-
-        updateView();
-
-        return view;
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        Session.getActiveSession().addCallback(statusCallback);
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        Session.getActiveSession().removeCallback(statusCallback);
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        Session session = Session.getActiveSession();
-        Session.saveSession(session, outState);
-    }
-
-    private void updateView() {
-        Session session = Session.getActiveSession();
-        if (session.isOpened()) {
-            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
-            buttonLoginLogout.setText(R.string.logout);
-            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
-                public void onClick(View view) { onClickLogout(); }
-            });
-        } else {
-            textInstructionsOrLink.setText(R.string.instructions);
-            buttonLoginLogout.setText(R.string.login);
-            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
-                public void onClick(View view) { onClickLogin(); }
-            });
-        }
-    }
-
-    private void onClickLogin() {
-        Session session = Session.getActiveSession();
-        if (!session.isOpened() && !session.isClosed()) {
-            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
-        } else {
-            Session.openActiveSession(getActivity(), this, true, statusCallback);
-        }
-    }
-
-    private void onClickLogout() {
-        Session session = Session.getActiveSession();
-        if (!session.isClosed()) {
-            session.closeAndClearTokenInformation();
-        }
-    }
-
-    private class SessionStatusCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            updateView();
-        }
-    }
-}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
deleted file mode 100644
index 9c64116da..000000000
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.sessionlogin;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.Button;
-import com.facebook.AppEventsLogger;
-
-public class SessionLoginSampleActivity extends Activity {
-
-    private Button buttonLoginActivity;
-    private Button buttonCustomFragment;
-    private Button buttonLoginFragment;
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setContentView(R.layout.main);
-
-        // We demonstrate three different ways of managing session login/logout behavior:
-        // 1) LoginUsingActivityActivity implements an Activity that handles all of its own
-        //    session management.
-        // 2) LoginUsingCustomFragmentActivity uses a Fragment that handles session management;
-        //    this Fragment could be composed as part of a more complex Activity, although in this
-        //    case it is the only UI that the Activity displays.
-        // 3) LoginUsingLoginFragmentActivity is similar to LoginUsingCustomFragmentActivity, but
-        //    uses the UserSettingsFragment class provided by the SDK to handle session management. As
-        //    in (2), this Fragment could be composed as part of a more complex Activity in a real app.
-        buttonLoginActivity = (Button) findViewById(R.id.buttonLoginActivity);
-        buttonLoginActivity.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingActivityActivity.class);
-                startActivity(intent);
-            }
-        });
-
-        buttonCustomFragment = (Button) findViewById(R.id.buttonLoginCustomFragment);
-        buttonCustomFragment.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingCustomFragmentActivity.class);
-                startActivity(intent);
-            }
-        });
-
-        buttonLoginFragment = (Button) findViewById(R.id.buttonLoginFragment);
-        buttonLoginFragment.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingLoginFragmentActivity.class);
-                startActivity(intent);
-            }
-        });
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
-        AppEventsLogger.activateApp(this);
-    }
-}
diff --git a/samples/SwitchUserSample/.classpath b/samples/SwitchUserSample/.classpath
deleted file mode 100644
index 6ef980d36..000000000
--- a/samples/SwitchUserSample/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/samples/SwitchUserSample/.project b/samples/SwitchUserSample/.project
deleted file mode 100644
index 9dc13d0d4..000000000
--- a/samples/SwitchUserSample/.project
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SwitchUserSample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-        <linkedResources>
-                <link>
-                        <name>libs</name>
-                        <type>2</type>
-                        <locationURI>PARENT-2-PROJECT_LOC/libs</locationURI>
-                </link>
-        </linkedResources>
-</projectDescription>
diff --git a/samples/SwitchUserSample/AndroidManifest.xml b/samples/SwitchUserSample/AndroidManifest.xml
index 8107b8d41..4ee5fb18e 100644
--- a/samples/SwitchUserSample/AndroidManifest.xml
+++ b/samples/SwitchUserSample/AndroidManifest.xml
@@ -1,23 +1,48 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+-->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.facebook.samples.switchuser"
-          android:versionCode="1"
-          android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8"/>
-    <uses-permission android:name="android.permission.INTERNET"/>
-    <application android:label="@string/app_name"
-                 android:icon="@drawable/icon" >
-        <activity android:name=".MainActivity"
-                  android:label="@string/app_name"
-                  android:windowSoftInputMode="adjustResize">
+    package="com.facebook.samples.switchuser"
+    android:versionCode="1"
+    android:versionName="1.0">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <application
+        android:allowBackup="false"
+        android:icon="@drawable/icon"
+        android:label="@string/app_name">
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name"
+            android:theme="@style/Theme.AppCompat"
+            android:windowSoftInputMode="adjustResize">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
-        <activity android:name="com.facebook.LoginActivity"
+        <activity android:name="com.facebook.FacebookActivity"
+                  android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
                   android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+        <meta-data android:name="com.facebook.sdk.ApplicationName" android:value="@string/app_name" />
     </application>
 </manifest> 
diff --git a/samples/SwitchUserSample/ant.properties b/samples/SwitchUserSample/ant.properties
deleted file mode 100644
index 939105d52..000000000
--- a/samples/SwitchUserSample/ant.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-java.compilerargs=-Xlint -Werror
diff --git a/samples/SwitchUserSample/build.gradle b/samples/SwitchUserSample/build.gradle
index a2cda0280..1085e758b 100644
--- a/samples/SwitchUserSample/build.gradle
+++ b/samples/SwitchUserSample/build.gradle
@@ -1,16 +1,21 @@
-apply plugin: 'android'
+apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':facebook')
+    compile 'com.android.support:appcompat-v7:21.0.3'
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "19"
+    compileSdkVersion Integer.parseInt(project.ANDROID_BUILD_SDK_VERSION)
+    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
 
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 19
+        minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+    }
+
+    lintOptions {
+        abortOnError false
     }
 
     sourceSets {
diff --git a/samples/SwitchUserSample/build.xml b/samples/SwitchUserSample/build.xml
deleted file mode 100644
index ee88101d7..000000000
--- a/samples/SwitchUserSample/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="SwitchUserSample" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true"/>
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-</project>
diff --git a/samples/SwitchUserSample/project.properties b/samples/SwitchUserSample/project.properties
deleted file mode 100644
index cee0509c6..000000000
--- a/samples/SwitchUserSample/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-android.library.reference.1=../../facebook
diff --git a/samples/SwitchUserSample/res/drawable-hdpi/ic_action_discard.png b/samples/SwitchUserSample/res/drawable-hdpi/ic_action_discard.png
new file mode 100644
index 000000000..703b31f80
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-hdpi/ic_action_discard.png differ
diff --git a/samples/SwitchUserSample/res/drawable-hdpi/ic_action_settings.png b/samples/SwitchUserSample/res/drawable-hdpi/ic_action_settings.png
new file mode 100644
index 000000000..54eecded3
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-hdpi/ic_action_settings.png differ
diff --git a/samples/SwitchUserSample/res/drawable-hdpi/icon.png b/samples/SwitchUserSample/res/drawable-hdpi/icon.png
index cda826b7f..8e4f7040c 100644
Binary files a/samples/SwitchUserSample/res/drawable-hdpi/icon.png and b/samples/SwitchUserSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-mdpi/ic_action_discard.png b/samples/SwitchUserSample/res/drawable-mdpi/ic_action_discard.png
new file mode 100644
index 000000000..248fb09cd
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-mdpi/ic_action_discard.png differ
diff --git a/samples/SwitchUserSample/res/drawable-mdpi/ic_action_settings.png b/samples/SwitchUserSample/res/drawable-mdpi/ic_action_settings.png
new file mode 100644
index 000000000..25c36db42
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-mdpi/ic_action_settings.png differ
diff --git a/samples/SwitchUserSample/res/drawable-mdpi/icon.png b/samples/SwitchUserSample/res/drawable-mdpi/icon.png
index ffd35f432..e193802b2 100644
Binary files a/samples/SwitchUserSample/res/drawable-mdpi/icon.png and b/samples/SwitchUserSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_discard.png b/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_discard.png
new file mode 100644
index 000000000..9eeeed124
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_discard.png differ
diff --git a/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_settings.png b/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_settings.png
new file mode 100644
index 000000000..425a8bc8d
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-xhdpi/ic_action_settings.png differ
diff --git a/samples/SwitchUserSample/res/drawable-xhdpi/icon.png b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png
index be63ade0b..e49838d03 100644
Binary files a/samples/SwitchUserSample/res/drawable-xhdpi/icon.png and b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable/icon.png b/samples/SwitchUserSample/res/drawable/icon.png
index ffd35f432..e193802b2 100644
Binary files a/samples/SwitchUserSample/res/drawable/icon.png and b/samples/SwitchUserSample/res/drawable/icon.png differ
diff --git a/samples/SwitchUserSample/res/layout/fragment_profile.xml b/samples/SwitchUserSample/res/layout/fragment_profile.xml
index 58fd5b4b6..2f7359311 100644
--- a/samples/SwitchUserSample/res/layout/fragment_profile.xml
+++ b/samples/SwitchUserSample/res/layout/fragment_profile.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
@@ -29,11 +33,11 @@
             android:text="@string/greeting_no_user"
             android:freezesText="true"
             />
-    <com.facebook.widget.ProfilePictureView
+    <com.facebook.login.widget.ProfilePictureView
             android:id="@+id/profilePic"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
-            app:preset_size="large"
+            app:com_facebook_preset_size="large"
             />
 </LinearLayout>
 
diff --git a/samples/SwitchUserSample/res/layout/list_item_user.xml b/samples/SwitchUserSample/res/layout/list_item_user.xml
index 9ae2b333d..1c7bb99a3 100644
--- a/samples/SwitchUserSample/res/layout/list_item_user.xml
+++ b/samples/SwitchUserSample/res/layout/list_item_user.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
+
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <LinearLayout
@@ -21,15 +25,16 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="horizontal"
+        android:id="@+id/slot"
         >
 
-    <com.facebook.widget.ProfilePictureView
+    <com.facebook.login.widget.ProfilePictureView
             android:id="@+id/slotPic"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:layout_weight="0"
             android:layout_margin="10dp"
-            app:preset_size="small"
+            app:com_facebook_preset_size="small"
             />
 
     <TextView
diff --git a/samples/SwitchUserSample/res/layout/main.xml b/samples/SwitchUserSample/res/layout/main.xml
index 25bca4440..88e3eea2b 100644
--- a/samples/SwitchUserSample/res/layout/main.xml
+++ b/samples/SwitchUserSample/res/layout/main.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
diff --git a/samples/SwitchUserSample/res/menu/context_settings.xml b/samples/SwitchUserSample/res/menu/context_settings.xml
index e10fdc7ba..6ceb4bdf9 100644
--- a/samples/SwitchUserSample/res/menu/context_settings.xml
+++ b/samples/SwitchUserSample/res/menu/context_settings.xml
@@ -1,22 +1,29 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
-<menu xmlns:android="http://schemas.android.com/apk/res/android">
+<menu
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
     <item android:id="@+id/menu_item_clear_slot"
+          android:icon="@drawable/ic_action_discard"
           android:title="@string/menu_item_clear_slot"
-          />
+          app:showAsAction="always" />
 </menu>
diff --git a/samples/SwitchUserSample/res/menu/options_profile.xml b/samples/SwitchUserSample/res/menu/options_profile.xml
index 972e131bf..04d4bca7a 100644
--- a/samples/SwitchUserSample/res/menu/options_profile.xml
+++ b/samples/SwitchUserSample/res/menu/options_profile.xml
@@ -1,23 +1,30 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
-<menu xmlns:android="http://schemas.android.com/apk/res/android">
+<menu
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
     <item
+            android:icon="@drawable/ic_action_settings"
             android:id="@+id/menu_item_switch"
             android:title="@string/menu_item_switch_user"
-            />
+            app:showAsAction="always"/>
 </menu>
diff --git a/samples/SwitchUserSample/res/values/strings.xml b/samples/SwitchUserSample/res/values/strings.xml
index ab1edfefa..61c1ec908 100644
--- a/samples/SwitchUserSample/res/values/strings.xml
+++ b/samples/SwitchUserSample/res/values/strings.xml
@@ -1,18 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-    Copyright 2010-present Facebook.
+    Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+    You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+    copy, modify, and distribute this software in source code or binary form for use
+    in connection with the web services and APIs provided by Facebook.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+    As with any software that integrates with the Facebook platform, your use of
+    this software is subject to the Facebook Developer Principles and Policies
+    [http://developers.facebook.com/policy/]. This copyright notice shall be
+    included in all copies or substantial portions of the software.
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
 
 <resources>
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
index b7ddd6adb..f0a5c9134 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
@@ -1,71 +1,57 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.switchuser;
 
-import android.content.Intent;
 import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
+import android.support.v7.app.ActionBarActivity;
 import android.view.MenuItem;
+
 import com.facebook.*;
-import com.facebook.model.GraphUser;
+import com.facebook.appevents.AppEventsLogger;
 
-public class MainActivity extends FragmentActivity {
+public class MainActivity extends ActionBarActivity {
 
     private static final String SHOWING_SETTINGS_KEY = "Showing settings";
-    private static final String TOKEN_CACHE_NAME_KEY = "TokenCacheName";
 
     private ProfileFragment profileFragment;
     private SettingsFragment settingsFragment;
     private boolean isShowingSettings;
-    private Slot currentSlot;
-    private Session currentSession;
-    private Session.StatusCallback sessionStatusCallback;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        FacebookSdk.sdkInitialize(getApplicationContext());
+
         setContentView(R.layout.main);
 
         restoreFragments(savedInstanceState);
 
-        sessionStatusCallback = new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                onSessionStateChange(session, state, exception);
-            }
-        };
-
         if (savedInstanceState != null) {
             if (savedInstanceState.getBoolean(SHOWING_SETTINGS_KEY)) {
                 showSettings();
             } else {
                 showProfile();
             }
-
-            SharedPreferencesTokenCachingStrategy restoredCache = new SharedPreferencesTokenCachingStrategy(
-                    this,
-                    savedInstanceState.getString(TOKEN_CACHE_NAME_KEY));
-            currentSession = Session.restoreSession(
-                    this,
-                    restoredCache,
-                    sessionStatusCallback,
-                    savedInstanceState);
         } else {
             showProfile();
         }
@@ -87,28 +73,16 @@ public void onBackPressed() {
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
         outState.putBoolean(SHOWING_SETTINGS_KEY, isShowingSettings());
-        if (currentSlot != null) {
-            outState.putString(TOKEN_CACHE_NAME_KEY, currentSlot.getTokenCacheName());
-        }
 
         FragmentManager manager = getSupportFragmentManager();
         manager.putFragment(outState, SettingsFragment.TAG, settingsFragment);
         manager.putFragment(outState, ProfileFragment.TAG, profileFragment);
-
-        Session.saveSession(currentSession, outState);
     }
 
     @Override
     protected void onResume() {
         super.onResume();
 
-        settingsFragment.setSlotChangedListener(new SettingsFragment.OnSlotChangedListener() {
-            @Override
-            public void onSlotChanged(Slot newSlot) {
-                handleSlotChange(newSlot);
-            }
-        });
-
         profileFragment.setOnOptionsItemSelectedListener(new ProfileFragment.OnOptionsItemSelectedListener() {
             @Override
             public boolean onOptionsItemSelected(MenuItem item) {
@@ -116,12 +90,9 @@ public boolean onOptionsItemSelected(MenuItem item) {
             }
         });
 
-        if (currentSession != null) {
-            currentSession.addCallback(sessionStatusCallback);
-        }
-
-        // Call the 'activateApp' method to log an app event for use in analytics and advertising reporting.  Do so in
-        // the onResume methods of the primary Activities that an app may be launched into.
+        // Call the 'activateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onResume methods of the primary Activities that an app may be
+        // launched into.
         AppEventsLogger.activateApp(this);
     }
 
@@ -129,35 +100,12 @@ public boolean onOptionsItemSelected(MenuItem item) {
     protected void onPause() {
         super.onPause();
 
-        settingsFragment.setSlotChangedListener(null);
         profileFragment.setOnOptionsItemSelectedListener(null);
 
-        if (currentSession != null) {
-            currentSession.removeCallback(sessionStatusCallback);
-        }
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        if (currentSession != null) {
-            currentSession.onActivityResult(this, requestCode, resultCode, data);
-        }
-    }
-
-    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
-        if (session != currentSession) {
-            return;
-        }
-
-        if (state.isOpened()) {
-            // Log in just happened.
-            fetchUserInfo();
-            showProfile();
-        } else if (state.isClosed()) {
-            // Log out just happened. Update the UI.
-            updateFragments(null);
-        }
+        // Call the 'deactivateApp' method to log an app event for use in analytics and advertising
+        // reporting.  Do so in the onPause methods of the primary Activities that an app may be
+        // launched into.
+        AppEventsLogger.deactivateApp(this);
     }
 
     private void restoreFragments(Bundle savedInstanceState) {
@@ -165,8 +113,10 @@ private void restoreFragments(Bundle savedInstanceState) {
         FragmentTransaction transaction = manager.beginTransaction();
 
         if (savedInstanceState != null) {
-            profileFragment = (ProfileFragment)manager.getFragment(savedInstanceState, ProfileFragment.TAG);
-            settingsFragment = (SettingsFragment)manager.getFragment(savedInstanceState, SettingsFragment.TAG);
+            profileFragment = (ProfileFragment) manager.getFragment(savedInstanceState,
+                    ProfileFragment.TAG);
+            settingsFragment = (SettingsFragment) manager.getFragment(savedInstanceState,
+                    SettingsFragment.TAG);
         }
 
         if (profileFragment == null) {
@@ -204,40 +154,6 @@ private void showProfile() {
                 .commit();
     }
 
-    private void fetchUserInfo() {
-        if (currentSession != null && currentSession.isOpened()) {
-            Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                @Override
-                public void onCompleted(GraphUser me, Response response) {
-                    if (response.getRequest().getSession() == currentSession) {
-                        updateFragments(me);
-                    }
-                }
-            });
-            request.executeAsync();
-        }
-    }
-
-    private void handleSlotChange(Slot newSlot) {
-        if (currentSession != null) {
-            currentSession.close();
-            currentSession = null;
-        }
-
-        if (newSlot != null) {
-            currentSlot = newSlot;
-            currentSession = new Session.Builder(this)
-                    .setTokenCachingStrategy(currentSlot.getTokenCache())
-                    .build();
-            currentSession.addCallback(sessionStatusCallback);
-
-            Session.OpenRequest openRequest = new Session.OpenRequest(this);
-            openRequest.setLoginBehavior(newSlot.getLoginBehavior());
-            openRequest.setRequestCode(Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-            currentSession.openForRead(openRequest);
-        }
-    }
-
     private boolean handleOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
             case R.id.menu_item_switch:
@@ -247,9 +163,4 @@ private boolean handleOptionsItemSelected(MenuItem item) {
                 return false;
         }
     }
-
-    private void updateFragments(GraphUser user) {
-        settingsFragment.updateViewForUser(user);
-        profileFragment.updateViewForUser(user);
-    }
 }
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
index 7dde4de74..a3b55ba39 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
@@ -1,27 +1,37 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.switchuser;
 
+import android.content.Intent;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.view.*;
 import android.widget.TextView;
-import com.facebook.model.GraphUser;
-import com.facebook.widget.ProfilePictureView;
+
+import com.facebook.AccessToken;
+import com.facebook.AccessTokenTracker;
+import com.facebook.CallbackManager;
+import com.facebook.Profile;
+import com.facebook.ProfileTracker;
+import com.facebook.login.widget.ProfilePictureView;
 
 public class ProfileFragment extends Fragment {
 
@@ -31,12 +41,37 @@
     private ProfilePictureView profilePictureView;
     private OnOptionsItemSelectedListener onOptionsItemSelectedListener;
 
-    private GraphUser pendingUpdateForUser;
+    private Profile pendingUpdateForUser;
+    private CallbackManager callbackManager;
+    private ProfileTracker profileTracker;
+    private AccessTokenTracker accessTokenTracker;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setHasOptionsMenu(true);
+        callbackManager = CallbackManager.Factory.create();
+        profileTracker = new ProfileTracker() {
+            @Override
+            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
+                setProfile(currentProfile);
+            }
+        };
+
+        accessTokenTracker = new AccessTokenTracker() {
+            @Override
+            protected void onCurrentAccessTokenChanged(
+                    AccessToken oldAccessToken,
+                    AccessToken currentAccessToken) {
+                // On AccessToken changes fetch the new profile which fires the event on
+                // the ProfileTracker if the profile is different
+                Profile.fetchProfileForCurrentAccessToken();
+            }
+        };
+
+        // Ensure that our profile is up to date
+        Profile.fetchProfileForCurrentAccessToken();
+        setProfile(Profile.getCurrentProfile());
     }
 
     @Override
@@ -64,36 +99,49 @@ public boolean onOptionsItemSelected(MenuItem item) {
     public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
         View v = inflater.inflate(R.layout.fragment_profile, parent, false);
 
-        userNameView = (TextView)v.findViewById(R.id.profileUserName);
-        profilePictureView = (ProfilePictureView)v.findViewById(R.id.profilePic);
+        userNameView = (TextView) v.findViewById(R.id.profileUserName);
+        profilePictureView = (ProfilePictureView) v.findViewById(R.id.profilePic);
 
         if (pendingUpdateForUser != null) {
-            updateViewForUser(pendingUpdateForUser);
+            setProfile(pendingUpdateForUser);
             pendingUpdateForUser = null;
         }
 
         return v;
     }
 
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        profileTracker.stopTracking();
+        accessTokenTracker.startTracking();
+    }
+
     public void setOnOptionsItemSelectedListener(OnOptionsItemSelectedListener listener) {
         this.onOptionsItemSelectedListener = listener;
     }
 
-    public void updateViewForUser(GraphUser user) {
+    private void setProfile(Profile profile) {
         if (userNameView == null || profilePictureView == null || !isAdded()) {
             // Fragment not yet added to the view. So let's store which user was intended
             // for display.
-            pendingUpdateForUser = user;
+            pendingUpdateForUser = profile;
             return;
         }
 
-        if (user == null) {
+        if (profile == null) {
             profilePictureView.setProfileId(null);
             userNameView.setText(R.string.greeting_no_user);
         } else {
-            profilePictureView.setProfileId(user.getId());
-            userNameView.setText(
-                    String.format(getString(R.string.greeting_format), user.getFirstName()));
+            profilePictureView.setProfileId(profile.getId());
+            userNameView.setText(String.format(getString(R.string.greeting_format),
+                    profile.getName()));
         }
     }
 
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
index dd1b1bc77..51299ac9b 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
@@ -1,30 +1,45 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.switchuser;
 
 import android.content.Context;
+import android.content.Intent;
 import android.content.SharedPreferences;
+import android.graphics.Color;
 import android.os.Bundle;
 import android.support.v4.app.ListFragment;
 import android.view.*;
 import android.widget.*;
-import com.facebook.model.GraphUser;
-import com.facebook.widget.ProfilePictureView;
-import com.facebook.SessionLoginBehavior;
+
+import com.facebook.AccessToken;
+import com.facebook.CallbackManager;
+import com.facebook.FacebookCallback;
+import com.facebook.FacebookException;
+import com.facebook.FacebookSdk;
+import com.facebook.Profile;
+import com.facebook.ProfileTracker;
+import com.facebook.login.LoginBehavior;
+import com.facebook.login.LoginManager;
+import com.facebook.login.LoginResult;
+import com.facebook.login.widget.ProfilePictureView;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -32,12 +47,12 @@
 public class SettingsFragment extends ListFragment {
 
     public static final String TAG = "SettingsFragment";
-
     private static final String CURRENT_SLOT_KEY = "CurrentSlot";
 
     private SlotManager slotManager;
-    private OnSlotChangedListener slotChangedListener;
-    private boolean hasPendingNotifySlotChanged;
+    private Menu optionsMenu;
+    private CallbackManager callbackManager;
+    private ProfileTracker profileTracker;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -51,46 +66,90 @@ public void onCreate(Bundle savedInstanceState) {
         ArrayList<Slot> slotList = new ArrayList<Slot>(
                 Arrays.asList(slotManager.getAllSlots()));
 
+        Slot currentSlot = slotManager.getSelectedSlot();
+        if (currentSlot != null && currentSlot.getAccessToken() != null) {
+            AccessToken.setCurrentAccessToken(currentSlot.getAccessToken());
+        }
+
         setListAdapter(new SlotAdapter(slotList));
+        setHasOptionsMenu(true);
+        setUpCallbacks();
+        currentUserChanged();
     }
 
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
-        View view = super.onCreateView(inflater, parent, savedInstanceState);
-        registerForContextMenu(view.findViewById(android.R.id.list));
-
-        return view;
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+        inflater.inflate(R.menu.context_settings, menu);
+        optionsMenu = menu;
+        updateMenuVisibility();
     }
 
-    @Override
-    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
-        super.onCreateContextMenu(menu, view, menuInfo);
-        getActivity().getMenuInflater().inflate(R.menu.context_settings, menu);
+    private void setUpCallbacks() {
+        callbackManager = CallbackManager.Factory.create();
+        LoginManager manager = LoginManager.getInstance();
+        manager.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
+            @Override
+            public void onSuccess(LoginResult loginResult) {
+                Profile.fetchProfileForCurrentAccessToken();
+            }
+
+            @Override
+            public void onError(FacebookException exception) {
+                AccessToken.setCurrentAccessToken(null);
+                currentUserChanged();
+            }
+
+            @Override
+            public void onCancel() {
+                AccessToken.setCurrentAccessToken(null);
+                currentUserChanged();
+            }
+        });
+
+        profileTracker = new ProfileTracker() {
+            @Override
+            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
+                Slot currentSlot = slotManager.getSelectedSlot();
+                AccessToken currentAccessToken = AccessToken.getCurrentAccessToken();
+                if(currentSlot != null && currentAccessToken != null && currentProfile != null) {
+                    currentSlot.setUserInfo(
+                            new UserInfo(currentProfile.getName(), currentAccessToken));
+                    currentUserChanged();
+                }
+            }
+        };
     }
 
     @Override
     public void onListItemClick(ListView l, View view, int position, long id) {
-        slotManager.toggleSlot(position);
+        slotManager.setCurrentUserSlot(position);
+        Slot newSlot = slotManager.getSelectedSlot();
+        if (newSlot.getAccessToken() == null) {
+            final LoginManager manager = LoginManager.getInstance();
+            manager.setLoginBehavior(newSlot.getLoginBehavior());
+            manager.logInWithReadPermissions(this, null);
+        } else {
+            AccessToken.setCurrentAccessToken(newSlot.getAccessToken());
+        }
     }
 
     @Override
-    public boolean onContextItemSelected(MenuItem item) {
-        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
-        SlotAdapter adapter = (SlotAdapter) getListAdapter();
-        Slot slot = adapter.getItem(info.position);
+    public boolean onOptionsItemSelected(MenuItem item) {
+        Slot slot = slotManager.getSelectedSlot();
 
         switch (item.getItemId()) {
             case R.id.menu_item_clear_slot:
                 if (slot.getUserId() != null) {
                     // Clear out data that this app stored in the cache
-                    // Not calling Session.closeAndClearTokenInformation() because we have additional
-                    // data stored in the cache.
+                    // Not calling Session.closeAndClearTokenInformation() because we have
+                    // additional data stored in the cache.
                     slot.clear();
                     if (slot == slotManager.getSelectedSlot()) {
-                        slotManager.toggleSlot(info.position);
+                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                     }
 
-                    updateListView();
+                    currentUserChanged();
                 }
                 return true;
         }
@@ -101,93 +160,51 @@ public boolean onContextItemSelected(MenuItem item) {
     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-
         outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
     }
 
-    public void setSlotChangedListener(OnSlotChangedListener listener) {
-        slotChangedListener = listener;
-        if (listener != null && hasPendingNotifySlotChanged) {
-            notifySlotChanged();
-            hasPendingNotifySlotChanged = false;
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        callbackManager.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        profileTracker.stopTracking();
+    }
+
+    private void updateMenuVisibility() {
+        if (optionsMenu != null) {
+            if (slotManager.getSelectedSlot() == null) {
+                optionsMenu.setGroupVisible(0, false);
+            } else if (optionsMenu != null) {
+                optionsMenu.setGroupVisible(0, true);
+            }
         }
     }
 
-    public void updateViewForUser(GraphUser user) {
+    private void currentUserChanged() {
         if (slotManager == null) {
             // Fragment has not had onCreate called yet.
             return;
         }
 
-        if (user != null) {
-            Slot s = slotManager.getSelectedSlot();
-            if (s != null) {
-                s.update(user);
-            }
-        } else {
-            // If the user is null, then there isn't an actively selected
-            // user. This can happen if the user cancelled a login. So make sure that
-            // SlotManager is updated properly.
-            slotManager.setSelectedSlotNumber(SlotManager.NO_SLOT);
-        }
-
+        updateMenuVisibility();
         updateListView();
-    }
-
-    private void notifySlotChanged() {
-        OnSlotChangedListener listener = slotChangedListener;
-        if (listener != null) {
-            Slot newSlot = slotManager.getSelectedSlot();
-            listener.onSlotChanged(newSlot);
-        } else {
-            hasPendingNotifySlotChanged = true;
-        }
+        Slot currentSlot = slotManager.getSelectedSlot();
+        AccessToken currentToken = (currentSlot != null) ? currentSlot.getAccessToken() : null;
+        AccessToken.setCurrentAccessToken(currentToken);
     }
 
     private void updateListView() {
         SlotAdapter adapter = (SlotAdapter) getListAdapter();
-        adapter.notifyDataSetChanged();
-    }
-
-    public interface OnSlotChangedListener {
-        void onSlotChanged(Slot newSlot);
-    }
-
-    private class SlotAdapter extends ArrayAdapter<Slot> {
 
-        public SlotAdapter(ArrayList<Slot> slots) {
-            super(getActivity(), android.R.layout.simple_list_item_1, slots);
+        // Adapter will be null if the list is not shown
+        if (adapter != null) {
+            adapter.notifyDataSetChanged();
         }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            if (null == convertView) {
-                convertView = getActivity().getLayoutInflater()
-                        .inflate(R.layout.list_item_user, null);
-            }
-
-            Slot slot = getItem(position);
-            String userName = slot.getUserName();
-            if (userName == null) {
-                userName = getString(R.string.empty_slot);
-            }
-
-            ProfilePictureView profilePictureView = (ProfilePictureView) convertView.findViewById(
-                    R.id.slotPic);
-            profilePictureView.setCropped(true);
-            profilePictureView.setProfileId(slot.getUserId());
-
-            TextView userNameTextView = (TextView) convertView.findViewById(
-                    R.id.slotUserName);
-            userNameTextView.setText(userName);
-
-            CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
-                    R.id.currentUserIndicator);
-            currentUserCheckBox.setChecked(slotManager.getSelectedSlot() == slot);
-
-            return convertView;
-        }
-
     }
 
     private class SlotManager {
@@ -203,49 +220,35 @@ public View getView(int position, View convertView, ViewGroup parent) {
 
         private Slot[] slots;
 
-        void restore(Context context, int oldSelectedSlot) {
+        public void restore(Context context, int oldSelectedSlot) {
             if (context == null) {
                 throw new IllegalArgumentException("context cannot be null");
             }
 
-            Context applicationContext = context.getApplicationContext();
-            applicationContext = (applicationContext == null) ? context : applicationContext;
-
             slots = new Slot[MAX_SLOTS];
             for (int i = 0; i < MAX_SLOTS; i++) {
-                SessionLoginBehavior loginBehavior = (i == 0) ?
-                        SessionLoginBehavior.SSO_WITH_FALLBACK :
-                        SessionLoginBehavior.SUPPRESS_SSO;
-                slots[i] = new Slot(applicationContext, i, loginBehavior);
+                LoginBehavior loginBehavior = (i == 0) ?
+                        LoginBehavior.SSO_WITH_FALLBACK :
+                        LoginBehavior.SUPPRESS_SSO;
+                slots[i] = new Slot(i, loginBehavior);
             }
 
             // Restore the last known state from when the app ran last.
-            settings = applicationContext.getSharedPreferences(SETTINGS_NAME, Context.MODE_PRIVATE);
+            settings = FacebookSdk.getApplicationContext().getSharedPreferences(
+                    SETTINGS_NAME, Context.MODE_PRIVATE);
             int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
             if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
-                // This will trigger the full flow of creating and opening the right session
-                toggleSlot(savedSlotNumber);
+                // This will trigger the full flow of login
+                setCurrentUserSlot(savedSlotNumber);
             } else {
                 // We already knew which slot was selected. So don't notify that a new slot was
-                // selected since that will close out the old session and recreate a new one. And
+                // selected since that will log out and start login process. And
                 // doing so will have the effect of clearing out state like the profile pic.
-                setSelectedSlotNumber(savedSlotNumber);
-            }
-        }
-
-        void toggleSlot(int slot) {
-            validateSlot(slot);
-
-            if (slot == selectedSlotNumber) {
-                setSelectedSlotNumber(NO_SLOT);
-            } else {
-                setSelectedSlotNumber(slot);
+                setCurrentUserSlot(savedSlotNumber);
             }
-
-            notifySlotChanged();
         }
 
-        Slot getSelectedSlot() {
+        public Slot getSelectedSlot() {
             if (selectedSlotNumber == NO_SLOT) {
                 return null;
             } else {
@@ -253,31 +256,94 @@ Slot getSelectedSlot() {
             }
         }
 
-        int getSelectedSlotNumber() {
+        public int getSelectedSlotNumber() {
             return selectedSlotNumber;
         }
 
-        Slot[] getAllSlots() {
+        public void setCurrentUserSlot(int slot) {
+            if (slot != selectedSlotNumber) {
+                // Store the selected slot number for when the app is closed and restarted
+                settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).apply();
+                selectedSlotNumber = slot;
+                currentUserChanged();
+            }
+        }
+
+        private Slot[] getAllSlots() {
             return slots;
         }
 
-        Slot getSlot(int slot) {
+        private Slot getSlot(int slot) {
             validateSlot(slot);
-
             return slots[slot];
         }
 
-        private void setSelectedSlotNumber(int slot) {
-            // Store the selected slot number for when the app is closed and restarted
-            settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).commit();
-            selectedSlotNumber = slot;
-        }
-
         private void validateSlot(int slot) {
             if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
                 throw new IllegalArgumentException(
-                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS-1));
+                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS - 1));
+            }
+        }
+    }
+
+    private class SlotAdapter extends ArrayAdapter<Slot> {
+
+        public SlotAdapter(ArrayList<Slot> slots) {
+            super(getActivity(), android.R.layout.simple_list_item_1, slots);
+        }
+
+        @Override
+        public View getView(final int position, View convertView, ViewGroup parent) {
+            if (null == convertView) {
+                convertView = getActivity().getLayoutInflater()
+                        .inflate(R.layout.list_item_user, parent, false);
+            }
+
+            Slot slot = getItem(position);
+            if (slot.getLoginBehavior() != LoginBehavior.SUPPRESS_SSO) {
+                convertView.setBackgroundColor(Color.argb(50, 255, 255, 255));
+            }
+
+            String userName = slot.getUserName();
+            if (userName == null) {
+                userName = getString(R.string.empty_slot);
+            }
+
+            String userId = slot.getUserId();
+            ProfilePictureView profilePic = (ProfilePictureView) convertView.findViewById(
+                    R.id.slotPic);
+            if (userId != null) {
+                profilePic.setProfileId(userId);
+            } else {
+                profilePic.setProfileId(null);
             }
+
+            TextView userNameTextView = (TextView) convertView.findViewById(
+                    R.id.slotUserName);
+            userNameTextView.setText(userName);
+
+            final CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
+                    R.id.currentUserIndicator);
+            currentUserCheckBox.setChecked(
+                    slotManager.getSelectedSlot() == slot
+                            && slot.getUserInfo() != null);
+            currentUserCheckBox.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    if (currentUserCheckBox.isChecked()) {
+                        slotManager.setCurrentUserSlot(position);
+                    } else {
+                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
+                    }
+                    SlotAdapter adapter = (SlotAdapter) getListAdapter();
+                    adapter.notifyDataSetChanged();
+                }
+            });
+
+            currentUserCheckBox.setEnabled(slot.getAccessToken() != null);
+
+            return convertView;
         }
+
     }
 }
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
index 479deb273..fcf68b68d 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
@@ -1,91 +1,70 @@
 /**
- * Copyright 2010-present Facebook.
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 package com.facebook.samples.switchuser;
 
-import android.content.Context;
-import android.os.Bundle;
-import com.facebook.*;
-import com.facebook.model.GraphUser;
+import com.facebook.AccessToken;
+import com.facebook.login.LoginBehavior;
 
 public class Slot {
+    private UserInfo userInfo;
+    private final UserInfoCache userInfoCache;
+    private LoginBehavior loginBehavior;
 
-    private static final String CACHE_NAME_FORMAT = "TokenCache%d";
-    private static final String CACHE_USER_ID_KEY = "SwitchUserSampleUserId";
-    private static final String CACHE_USER_NAME_KEY = "SwitchUserSampleUserName";
-
-    private String tokenCacheName;
-    private String userName;
-    private String userId;
-    private SharedPreferencesTokenCachingStrategy tokenCache;
-    private SessionLoginBehavior loginBehavior;
-
-    public Slot(Context context, int slotNumber, SessionLoginBehavior loginBehavior) {
+    public Slot(int slotNumber, LoginBehavior loginBehavior) {
         this.loginBehavior = loginBehavior;
-        this.tokenCacheName = String.format(CACHE_NAME_FORMAT, slotNumber);
-        this.tokenCache = new SharedPreferencesTokenCachingStrategy(
-                context,
-                tokenCacheName);
-
-        restore();
+        this.userInfoCache = new UserInfoCache(slotNumber);
+        this.userInfo = userInfoCache.get();
     }
 
-    public String getTokenCacheName() {
-        return tokenCacheName;
+    public LoginBehavior getLoginBehavior() {
+        return loginBehavior;
     }
 
     public String getUserName() {
-        return userName;
+        return (userInfo != null) ? userInfo.getUserName() : null;
     }
 
-    public String getUserId() {
-        return userId;
+    public AccessToken getAccessToken() {
+        return (userInfo != null) ? userInfo.getAccessToken() : null;
     }
 
-    public SessionLoginBehavior getLoginBehavior() {
-        return loginBehavior;
+    public String getUserId() {
+        return (userInfo != null) ? userInfo.getAccessToken().getUserId() : null;
     }
 
-    public SharedPreferencesTokenCachingStrategy getTokenCache() {
-        return tokenCache;
+    public UserInfo getUserInfo() {
+        return userInfo;
     }
 
-    public void update(GraphUser user) {
+    public void setUserInfo(UserInfo user) {
+        userInfo = user;
         if (user == null) {
             return;
         }
 
-        userId = user.getId();
-        userName = user.getName();
-
-        Bundle userInfo = tokenCache.load();
-        userInfo.putString(CACHE_USER_ID_KEY, userId);
-        userInfo.putString(CACHE_USER_NAME_KEY, userName);
-
-        tokenCache.save(userInfo);
+        userInfoCache.put(user);
     }
 
     public void clear() {
-        tokenCache.clear();
-        restore();
-    }
-
-    private void restore() {
-        Bundle userInfo = tokenCache.load();
-        userId = userInfo.getString(CACHE_USER_ID_KEY);
-        userName = userInfo.getString(CACHE_USER_NAME_KEY);
+        userInfo = null;
+        userInfoCache.clear();
     }
 }
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfo.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfo.java
new file mode 100644
index 000000000..9f0e74cce
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfo.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.facebook.AccessToken;
+
+class UserInfo implements Parcelable {
+    private String userName;
+    private AccessToken accessToken;
+
+    public UserInfo(String userName, AccessToken accessToken) {
+        this.userName = userName;
+        this.accessToken = accessToken;
+    }
+
+    public String getUserName() {
+        return userName;
+    }
+
+    public AccessToken getAccessToken() {
+        return accessToken;
+    }
+
+    UserInfo(Parcel parcel) {
+        this.userName = parcel.readString();
+        this.accessToken = parcel.readParcelable(UserInfo.class.getClassLoader());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(userName);
+        dest.writeParcelable(accessToken, 0);
+    }
+
+    public static final Parcelable.Creator<UserInfo> CREATOR = new Parcelable.Creator() {
+
+        @Override
+        public UserInfo createFromParcel(Parcel source) {
+            return new UserInfo(source);
+        }
+
+        @Override
+        public UserInfo[] newArray(int size) {
+            return new UserInfo[size];
+        }
+    };
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfoCache.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfoCache.java
new file mode 100644
index 000000000..7ff45ce19
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/UserInfoCache.java
@@ -0,0 +1,84 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Parcel;
+import android.util.Base64;
+
+import com.facebook.FacebookSdk;
+
+class UserInfoCache {
+    private static final String USER_INFO_CACHE_FORMAT = "userInfo%d";
+    private final String userInfoCacheKey;
+    private final int slot;
+
+    public UserInfoCache(int slotNumber) {
+        userInfoCacheKey = String.format(USER_INFO_CACHE_FORMAT, slotNumber);
+        slot = slotNumber;
+    }
+    public UserInfo get() {
+        SharedPreferences prefs = getSharedPrefs();
+        String encodedToken = prefs.getString(userInfoCacheKey, null);
+        if(encodedToken == null) {
+            return null;
+        }
+        return decodeUserInfo(encodedToken);
+    }
+
+    public void put(UserInfo userInfo) {
+        SharedPreferences.Editor editor = getSharedPrefs().edit();
+        String encodedToken = encodeUserInfo(userInfo);
+        editor.putString(userInfoCacheKey, encodedToken);
+        editor.apply();
+    }
+
+    public void clear() {
+        SharedPreferences.Editor editor = getSharedPrefs().edit();
+        editor.remove(userInfoCacheKey);
+        editor.apply();
+    }
+
+    private static SharedPreferences getSharedPrefs() {
+        return FacebookSdk.getApplicationContext().getSharedPreferences(
+                "accessTokens",
+                Context.MODE_PRIVATE);
+    }
+
+    private static UserInfo decodeUserInfo(String base64EncodedToken) {
+        byte[] data = Base64.decode(base64EncodedToken, Base64.DEFAULT);
+        Parcel parcel = Parcel.obtain();
+        parcel.unmarshall(data, 0, data.length);
+        parcel.setDataPosition(0);
+        UserInfo userInfo = (UserInfo) parcel.readValue(UserInfo.class.getClassLoader());
+        parcel.recycle();
+        return userInfo;
+    }
+
+    private static String encodeUserInfo(UserInfo userInfo) {
+        Parcel parcel = Parcel.obtain();
+        parcel.writeValue(userInfo);
+        byte[] data = parcel.marshall();
+        parcel.recycle();
+        return Base64.encodeToString(data, Base64.DEFAULT);
+    }
+}
diff --git a/scripts/build_and_test.sh b/scripts/build_and_test.sh
deleted file mode 100755
index 75dae1ead..000000000
--- a/scripts/build_and_test.sh
+++ /dev/null
@@ -1,51 +0,0 @@
-#!/bin/sh
-#
-# Copyright 2010-present Facebook.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-# 
-#    http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-function die() {
-  echo "$@"
-  exit 1
-}
-
-# Find enlistment root
-cd $(dirname $0) >/dev/null
-SDK=$(git rev-parse --show-toplevel) ||
-  die "Could not access git"
-
-# Build all samples
-cd $SDK/samples
-for SAMPLE in *; do
-  if [[ -d $SAMPLE ]]; then
-    cd $SAMPLE
-    ant clean ||
-      die "Error running 'ant clean' on sample $SAMPLE"
-    ant debug ||
-      die "Error running 'ant debug' on sample $SAMPLE"
-    cd ..
-  fi
-done
-
-# Remove any stale test bits, ignore errors here
-adb uninstall com.facebook.sdk.tests 2>/dev/null
-
-# Build and run tests
-cd $SDK/facebook/tests
-ant clean ||
-  die "Error running 'ant clean' on facebook sdk"
-ant debug install ||
-  die "Error running 'ant debug install' on facebook sdk"
-ant run-tests ||
-  die "Error running 'ant run-tests' on facebook sdk"
diff --git a/scripts/configure_unit_tests.sh b/scripts/configure_unit_tests.sh
index a6b85224e..237cf91b2 100755
--- a/scripts/configure_unit_tests.sh
+++ b/scripts/configure_unit_tests.sh
@@ -23,12 +23,13 @@ cd $(dirname $0)/..
 FB_SDK_ROOT=$(pwd)
 FB_SDK_TESTS=$FB_SDK_ROOT/facebook/tests
 
-if [ "$#" -lt 2 ]; then
-    echo "Usage: $0 APP_ID APP_SECRET [MACHINE_UNIQUE_USER_KEY]"
-    echo "  APP_ID                   your unit-testing Facebook application's App ID"
-    echo "  APP_SECRET               your unit-testing Facebook application's App Secret"
-    echo "  MACHINE_UNIQUE_USER_TAG  optional text used to ensure this machine will use its own set of test users rather than sharing"
-    die 'Arguments do not conform to usage'
+if [ "$#" -lt 3 ]; then
+      echo "Usage: $0 APP_ID APP_SECRET CLIENT_TOKEN [MACHINE_UNIQUE_USER_KEY]"
+      echo "  APP_ID                   your unit-testing Facebook application's App ID"
+      echo "  APP_SECRET               your unit-testing Facebook application's App Secret"
+      echo "  CLIENT_TOKEN             your unit-testing Facebook application's client token"
+      echo "  MACHINE_UNIQUE_USER_TAG  optional text used to ensure this machine will use its own set of test users rather than sharing"
+      die 'Arguments do not conform to usage'
 fi
 
 function write_config_json {
@@ -39,7 +40,7 @@ function write_config_json {
     # use heredoc syntax to output the json
     cat > "$CONFIG_JSON_FILE" \
 <<DELIMIT
-{"applicationId":"$1","applicationSecret":"$2","machineUniqueUserTag":"$3"}
+{"applicationId":"$1","applicationSecret":"$2","clientToken":"$3","machineUniqueUserTag":"$4"}
 DELIMIT
 # end heredoc
 
diff --git a/settings.gradle b/settings.gradle
index 8fb89427e..893c9c88b 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,27 +2,23 @@
 include ':facebook'
 
 // Tests
-include 'TestApp'
-project(':TestApp').projectDir = new File('facebook/TestApp')
 include 'tests'
 project(':tests').projectDir = new File('facebook/tests')
 
+include 'junitTests'
+project(':junitTests').projectDir = new File('facebook/junitTests')
+
 // Samples
-include 'FriendPickerSample'
-project(':FriendPickerSample').projectDir = new File('samples/FriendPickerSample')
-include 'GraphApiSample'
-project(':GraphApiSample').projectDir = new File('samples/GraphApiSample')
-include 'HelloFacebookSample'
-project(':HelloFacebookSample').projectDir = new File('samples/HelloFacebookSample')
-include 'PlacePickerSample'
-project(':PlacePickerSample').projectDir = new File('samples/PlacePickerSample')
-include 'ProfilePictureSample'
-project(':ProfilePictureSample').projectDir = new File('samples/ProfilePictureSample')
-include 'RPSSample'
-project(':RPSSample').projectDir = new File('samples/RPSSample')
-include 'Scrumptious'
-project(':Scrumptious').projectDir = new File('samples/Scrumptious')
-include 'SessionLoginSample'
-project(':SessionLoginSample').projectDir = new File('samples/SessionLoginSample')
-include 'SwitchUserSample'
-project(':SwitchUserSample').projectDir = new File('samples/SwitchUserSample')
+include ':samples:HelloFacebookSample'
+include ':samples:RPSSample'
+include ':samples:MessengerSendSample'
+include ':samples:Scrumptious'
+include ':samples:SwitchUserSample'
+
+if (file('internal/internal-settings.gradle').exists()) {
+  apply from: 'internal/internal-settings.gradle'
+}
+
+if (file('local.gradle').exists()) {
+  apply from: 'local.gradle'
+}
diff --git a/tests/AndroidManifest.xml b/tests/AndroidManifest.xml
deleted file mode 100644
index c0e209de6..000000000
--- a/tests/AndroidManifest.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="com.facebook.android.tests"
-      android:versionCode="1"
-      android:versionName="1.0">
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-        <activity android:name=".Tests"
-                  android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-
-    </application>
-    <uses-permission android:name="android.permission.INTERNET"></uses-permission>
-    <uses-sdk android:minSdkVersion="3" />
-</manifest> 
diff --git a/tests/res/drawable/icon.png b/tests/res/drawable/icon.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/tests/res/drawable/icon.png and /dev/null differ
diff --git a/tests/res/layout/main.xml b/tests/res/layout/main.xml
deleted file mode 100644
index 7134549a8..000000000
--- a/tests/res/layout/main.xml
+++ /dev/null
@@ -1,89 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical" android:layout_width="fill_parent"
-    android:layout_height="fill_parent" android:background="@drawable/black"
-    android:gravity="center_horizontal">
-
-    <TextView android:id="@+id/publicTests" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />
-    <TextView android:id="@+id/publicErrors" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />
-    <Button android:id="@+id/login" 
-        android:text="@string/login"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-    <TextView android:id="@+id/authenticatedTests" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />
-    <TextView android:id="@+id/authenticatedErrors" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />  
-    <Button android:id="@+id/post" 
-        android:text="@string/post"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-    <TextView android:id="@+id/wallPost" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />
-    <TextView android:id="@+id/deletedPost" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        /> 
-    <Button android:id="@+id/logout" 
-        android:text="@string/logout"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-    <TextView android:id="@+id/logoutTest" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        />
-</LinearLayout>
diff --git a/tests/res/values/colors.xml b/tests/res/values/colors.xml
deleted file mode 100644
index 43a557808..000000000
--- a/tests/res/values/colors.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <drawable name="white">#ffffff</drawable>
-    <drawable name="black">#000000</drawable>
-</resources>
diff --git a/tests/res/values/strings.xml b/tests/res/values/strings.xml
deleted file mode 100644
index a61bf4d4c..000000000
--- a/tests/res/values/strings.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="hello">Hello World, Tests!</string>
-    <string name="login">Test Login</string>
-    <string name="post">Test UI Server</string>
-    <string name="logout">Test Logout</string>
-    <string name="app_name">Functional Tests</string>
-</resources>
diff --git a/tests/src/com/facebook/android/tests/Tests.java b/tests/src/com/facebook/android/tests/Tests.java
deleted file mode 100644
index e3116289e..000000000
--- a/tests/src/com/facebook/android/tests/Tests.java
+++ /dev/null
@@ -1,595 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android.tests;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import org.json.JSONObject;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.DialogError;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.Util;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-import com.facebook.android.Facebook.DialogListener;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.TextView;
-
-public class Tests extends Activity {
-    
-    // Your Facebook Application ID must be set before running this example
-    // See http://www.facebook.com/developers/createapp.php
-    public static final String APP_ID = "110862205611506";
-    
-    private static final String[] PERMISSIONS =
-        new String[] {"publish_stream", "read_stream", "offline_access"};
-    
-    TextView publicTestsText;
-    TextView publicErrorsText;
-    Button loginButton;
-    TextView authenticatedTestsText;
-    TextView authenticatedErrorsText;
-    Button postButton;
-    TextView wallPostText;
-    TextView deletedPostText;
-    Button logoutButton;
-    TextView logoutText;
-    
-    Facebook authenticatedFacebook = new Facebook(APP_ID);
-    
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-        
-        publicTestsText = (TextView) findViewById(R.id.publicTests);
-        publicErrorsText = (TextView) findViewById(R.id.publicErrors);
-        loginButton = (Button) findViewById(R.id.login);
-        authenticatedTestsText = (TextView) findViewById(
-                R.id.authenticatedTests);
-        authenticatedErrorsText = (TextView) findViewById(
-                R.id.authenticatedErrors);
-        postButton = (Button) findViewById(R.id.post);
-        wallPostText = (TextView) findViewById(R.id.wallPost);
-        deletedPostText = (TextView) findViewById(R.id.deletedPost);
-        logoutButton = (Button) findViewById(R.id.logout);
-        logoutText = (TextView) findViewById(R.id.logoutTest);
-               
-        // button to test UI Server login method
-        loginButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                authenticatedFacebook.authorize(Tests.this, PERMISSIONS,
-                        new TestLoginListener());
-            }
-        });
-        
-        // button for testing UI server publish stream dialog
-        postButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                authenticatedFacebook.dialog(Tests.this, "stream.publish", 
-                        new TestUiServerListener());
-            }
-        });
-        
-        // enable logout test button
-        logoutButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                runTestLogout();
-            }
-        });
-        
-        runTestPublicApi();
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        authenticatedFacebook.authorizeCallback(requestCode, resultCode, data);
-    }
-
-    public void runTestPublicApi() {
-        if (testPublicApi()) {
-            publicTestsText.setText("Public API tests passed");
-            publicTestsText.setTextColor(Color.GREEN);
-        } else {
-            publicTestsText.setText("Public API tests failed");
-            publicTestsText.setTextColor(Color.RED);
-        }
-        
-        if (testPublicErrors()) {
-            publicErrorsText.setText("Public API errors passed");
-            publicErrorsText.setTextColor(Color.GREEN);
-        } else {
-            publicErrorsText.setText("Public API errors failed");
-            publicErrorsText.setTextColor(Color.RED);
-        }
-    }
-    
-    public boolean testPublicApi() {
-        Facebook fb = new Facebook(APP_ID);
-        try {
-            Log.d("Tests", "Testing standard API call");
-            JSONObject response = Util.parseJson(fb.request("4"));
-            if (!response.getString("name").equals("Mark Zuckerberg")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing an API call with a specific method");
-            response = Util.parseJson(
-                    fb.request("soneff", new Bundle(), "GET"));
-            if (!response.getString("name").equals("Steven Soneff")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing a public search query");
-            Bundle params = new Bundle();
-            params.putString("q", "facebook");
-            response = Util.parseJson(fb.request("search", params));
-            if (response.getJSONArray("data").length() == 0) return false;
-            
-            Log.d("Tests", "Public API Tests passed"); 
-            return true;
-        } catch (Throwable e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-    
-    public boolean testPublicErrors() {
-        Facebook fb = new Facebook(APP_ID);
-        try {
-            Bundle params = new Bundle();
-            
-            Log.d("Tests", "Testing illegal post");
-            params.putString("message", "Hello World");
-            try {
-                Util.parseJson(fb.request("4", params, "POST"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals("Unsupported post request.")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing illegal delete");
-            try {
-                Util.parseJson(fb.request("4", new Bundle(), "DELETE"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals(
-                        "An access token is required to request this " +
-                        "resource.")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing illegal post to Zuck's feed");
-            try {
-                Util.parseJson(fb.request("4/feed", new Bundle(), "POST"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals("(#200) The user hasn't " +
-                		"authorized the application to perform this action")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing invalidly specified parameters");
-            try {
-                Util.parseJson(fb.request("bgolub?fields=id,name,picture"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().startsWith("Unknown fields: picture?")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing request for 'me' is rejected without " +
-            		"access_token");
-            try {
-                Util.parseJson(fb.request("me"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals(
-                        "An active access token must be used to " +
-                        "query information about the current user.")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing empty request");
-            try {
-                Util.parseJson(fb.request(""));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals("Unsupported get request.")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing an invalid path");
-            try {
-                Util.parseJson(fb.request("invalidinvalidinvalidinvalid"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals(
-                        "(#803) Some of the aliases you requested do not " +
-                        "exist: invalidinvalidinvalidinvalid")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing missing query parameter");
-            try {
-                Util.parseJson(fb.request("search", new Bundle(), "GET"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals("No node specified")) return false;
-            }
-            
-            Log.d("Tests", "Testing that API method is specified");
-            try {
-                fb.request(new Bundle());
-                return false;
-            } catch (IllegalArgumentException e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals(
-                        "API method must be specified. " +
-                        "(parameters must contain key \"method\" " +
-                        "and value). See http://developers.facebook." +
-                        "com/docs/reference/rest/")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing that old API request cannot be made " +
-                           "without access token");
-            params.putString("method", "stream.publish");
-            try {
-                Util.parseJson(fb.request(params));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (e.getErrorCode() != 101 || 
-                        !e.getMessage().equals("Invalid API key") ) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing invalid access token");
-            try {
-                fb.setAccessToken("invalid");
-                Util.parseJson(fb.request("me", new Bundle(), "GET"));
-                return false;
-            } catch (FacebookError e) {
-                Log.d("Tests", "*" + e.getMessage() + "*");
-                if (!e.getMessage().equals("Invalid OAuth access token.")) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Public API Error Tests passed"); 
-            return true;
-        } catch (Throwable e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-    
-    public class TestLoginListener implements DialogListener {
-
-        public void onComplete(Bundle values) {
-            if (testAuthenticatedApi()) {
-                authenticatedTestsText.setText(
-                        "Authenticated API tests passed");
-                authenticatedTestsText.setTextColor(Color.GREEN);
-            } else {
-                authenticatedTestsText.setText(
-                        "Authenticated API tests failed");
-                authenticatedTestsText.setTextColor(Color.RED);
-            }
-            if (testAuthenticatedErrors()) {
-                authenticatedErrorsText.setText(
-                        "Authenticated API errors passed");
-                authenticatedErrorsText.setTextColor(Color.GREEN);
-            } else {
-                authenticatedErrorsText.setText(
-                        "Authenticated API errors failed");
-                authenticatedErrorsText.setTextColor(Color.RED);
-            }
-        }
-
-        public void onCancel() {
-        }
-
-        public void onError(DialogError e) {
-            e.printStackTrace();
-        }
-
-        public void onFacebookError(FacebookError e) {
-            e.printStackTrace();
-        }
-    }
-    
-    public boolean testAuthenticatedApi() {
-        if (!authenticatedFacebook.isSessionValid()) return false;
-        try {
-            Log.d("Tests", "Testing request for 'me'");
-            String response = authenticatedFacebook.request("me");
-            JSONObject obj = Util.parseJson(response);
-            if (obj.getString("name") == null || 
-                    obj.getString("name").equals("")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing graph API wall post");
-            Bundle parameters = new Bundle();
-            parameters.putString("message", "hello world");
-            parameters.putString("description", "test test test");
-            response = authenticatedFacebook.request("me/feed", parameters, 
-                    "POST");
-            Log.d("Tests", "got response: " + response);
-            if (response == null || response.equals("") || 
-                    response.equals("false")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing graph API delete");
-            response = response.replaceAll("\\{\"id\":\"", "");
-            response = response.replaceAll("\"\\}", "");
-            response = authenticatedFacebook.request(response, new Bundle(), 
-                    "DELETE");
-            if (!response.equals("true")) return false;
-            
-            Log.d("Tests", "Testing old API wall post");
-            parameters = new Bundle();
-            parameters.putString("method", "stream.publish");
-            parameters.putString("attachment", 
-                "{\"name\":\"Name=Title\"," +
-                "\"href\":\"http://www.google.fr/\",\"" +
-                "caption\":\"Caption\",\"description\":\"Description" +
-                "\",\"media\":[{\"type\":\"image\",\"src\":" +
-                "\"http://www.kratiroff.com/logo-facebook.jpg\"," +
-                "\"href\":\"http://developers.facebook.com/\"}]," +
-                "\"properties\":{\"another link\":{\"text\":\"" +
-                "Facebook homepage\",\"href\":\"http://www.facebook." +
-                "com\"}}}");;
-            response = authenticatedFacebook.request(parameters);
-            Log.d("Tests", "got response: " + response);
-            if (response == null || response.equals("") || 
-                    response.equals("false")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing wall post delete");
-            response = response.replaceAll("\"", "");
-            response = authenticatedFacebook.request(
-                    response, new Bundle(), "DELETE");
-            if (!response.equals("true")) return false;
-            
-            Log.d("Tests", "All Authenticated Tests Passed");
-            return true;
-        } catch (Throwable e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-    
-    public boolean testAuthenticatedErrors() {
-        if (!authenticatedFacebook.isSessionValid()) return false;
-        
-        Log.d("Tests", "Testing that request for 'me/invalid' is rejected");
-        try {
-            Util.parseJson(authenticatedFacebook.request("me/invalid"));
-            return false;
-        } catch (Throwable e) {
-            Log.d("Tests", "*" + e.getMessage() + "*");
-            if (!e.getMessage().equals("Unknown path components: /invalid")) {
-                return false;
-            }
-        }
-        
-        Log.d("Tests", "Testing that old API call with invalid method fails");
-        Bundle params = new Bundle();
-        params.putString("method", "something_invalid");
-        try {
-            Util.parseJson(authenticatedFacebook.request(params));
-            return false;
-        } catch (Throwable e) {
-            Log.d("Tests", "*" + e.getMessage() + "*");
-            if (!e.getMessage().equals("Unknown method") ) {
-                return false;
-            }
-        }
-        
-        Log.d("Tests", "All Authenticated Error Tests Passed");
-        return true;
-    }
-    
-    public class TestUiServerListener implements DialogListener {
-
-        public void onComplete(Bundle values) {
-            final String postId = values.getString("post_id");
-            if (postId != null) {
-                Log.d("Facebook-Example", "Dialog Success! post_id=" + postId);
-                new AsyncFacebookRunner(authenticatedFacebook).request(postId, 
-                        new TestPostRequestListener());
-            } else {
-                Tests.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        wallPostText.setText("Wall Post Failure");
-                        wallPostText.setTextColor(Color.RED);
-                    }
-                });
-            }
-        }
-
-        public void onCancel() { }
-
-        public void onError(DialogError e) {
-            e.printStackTrace();
-        }
-
-        public void onFacebookError(FacebookError e) {
-            e.printStackTrace();
-        }
-    }
-    
-    public class TestPostRequestListener implements RequestListener {
-        
-        public void onComplete(final String response, final Object state) {
-            Log.d("Tests", "Got response: " + response);
-            try {
-                JSONObject json = Util.parseJson(response);
-                //final String message = json.getString("message");
-                String postId = json.getString("id");
-                Tests.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        wallPostText.setText("Wall Post Success");
-                        wallPostText.setTextColor(Color.GREEN);
-                    }
-                });
-                
-                Log.d("Tests", "Testing wall post delete");
-                if (testPostDelete(postId)) {
-                    Tests.this.runOnUiThread(new Runnable() {
-                        public void run() {
-                            deletedPostText.setText("Deleted Post Success");
-                            deletedPostText.setTextColor(Color.GREEN);
-                        }
-                    });
-                } else {
-                    Tests.this.runOnUiThread(new Runnable() {
-                        public void run() {
-                            deletedPostText.setText("Deleted Post Failure");
-                            deletedPostText.setTextColor(Color.RED);
-                        }
-                    });
-                }
-            } catch (Throwable e) {
-                e.printStackTrace();
-                Tests.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        wallPostText.setText("Wall Post Failure");
-                        wallPostText.setTextColor(Color.RED);
-                    }
-                });
-            }
-        }
-
-        public void onFacebookError(FacebookError e, final Object state) {
-            e.printStackTrace();
-        }
-
-        public void onFileNotFoundException(FileNotFoundException e,
-                                            final Object state) {
-            e.printStackTrace();
-        }
-
-        public void onIOException(IOException e, final Object state) {
-            e.printStackTrace();
-        }
-
-        public void onMalformedURLException(MalformedURLException e,
-                                            final Object state) {
-            e.printStackTrace();
-        }
-    }
-    
-    public boolean testPostDelete(String postId) {
-        try {
-            String deleteResponse = 
-                authenticatedFacebook.request(postId, new Bundle(), "DELETE");
-            return deleteResponse.equals("true");
-        } catch (Throwable e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-    
-    public void runTestLogout() {
-        if (testLogout()) {
-            logoutText.setText("Logout Tests Passed");
-            logoutText.setTextColor(Color.GREEN);
-        } else {
-            logoutText.setText("Logout Tests Failed");
-            logoutText.setTextColor(Color.RED);
-        }
-    }
-    
-    public boolean testLogout() {
-        try {
-            Log.d("Tests", "Testing logout");
-            String response = authenticatedFacebook.logout(this);
-            Log.d("Tests", "Got logout response: *" + response + "*");
-            if (!response.equals("true")) {
-                return false;
-            }
-            
-            Log.d("Tests", "Testing logout on logged out facebook session");
-            try {
-                Util.parseJson(authenticatedFacebook.logout(this));
-                return false;
-            } catch (FacebookError e) {
-                if (e.getErrorCode() != 101 || 
-                        !e.getMessage().equals("Invalid API key") ) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "Testing logout on unauthenticated object");
-            try {
-                Util.parseJson(new Facebook(APP_ID).logout(this));
-                return false;
-            } catch (FacebookError e) {
-                if (e.getErrorCode() != 101 || 
-                        !e.getMessage().equals("Invalid API key") ) {
-                    return false;
-                }
-            }
-            
-            Log.d("Tests", "All Logout Tests Passed");
-            return true;
-        } catch (Throwable e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-    
-    // test bad UI server method?
-    
-    // test invalid permission? <-- UI server test
-}
