diff --git a/src/com/activeandroid/sebbia/DeepModel.java b/src/com/activeandroid/sebbia/DeepModel.java
new file mode 100644
index 00000000..b5470eef
--- /dev/null
+++ b/src/com/activeandroid/sebbia/DeepModel.java
@@ -0,0 +1,168 @@
+package com.activeandroid.sebbia;
+
+import com.activeandroid.sebbia.util.Log;
+import com.google.common.collect.Lists;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.List;
+
+
+public abstract class DeepModel extends Model implements IDeepModel {
+
+    @Override
+    public Long saveDeep() {
+        return saveDeep(false, null);
+    }
+
+    @Override
+    public Long saveDeep(final boolean force) {
+        return saveDeep(force, null);
+    }
+
+    @Override
+    public Long saveDeep(final boolean force, final IDeepActionHandler deepActionHandler) {
+        List<Field> fields = getAllModelFields(getClass());
+        for (Field field : fields) {
+            try {
+                Long id = -1l;
+                boolean deep = false;
+                final boolean accessible = field.isAccessible();
+                if (!accessible) field.setAccessible(true);
+                final Object model = field.get(this);
+                if (null == model) continue;
+                Exception ex = null;
+                try {
+                    if (null != deepActionHandler && model instanceof Model && deepActionHandler.shouldProcess(field.getName(), (Model) model)) {
+                        if (model instanceof DeepModel) {
+                            deep = true;
+                            id = ((IDeepModel) model).saveDeep(force);
+                        } else {
+                            id = ((Model) model).save();
+                        }
+                    } else if (null == deepActionHandler) {
+                        if (model instanceof DeepModel) {
+                            deep = true;
+                            id = ((IDeepModel) model).saveDeep(force);
+                        } else if (model instanceof Model){
+                            id = ((Model) model).save();
+                        }
+                    } else {
+                        Log.i("Skipped processing field %s for saving operation", field.getName());
+                        id = 0l;
+                    }
+                } catch (Exception e) {
+                    ex = e;
+                    Log.e("", e);
+                }
+                if (ex != null) {
+                    if (!accessible) field.setAccessible(false);
+                    if (force) {
+                        Log.e(String.format("Can't save field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep), ex);
+                    } else {
+                        final String errMsg = String.format("Can't save field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep);
+                        Log.e(errMsg);
+                        throw new RuntimeException(errMsg, ex);
+                    }
+                } else if (-1l == id) {
+                    if (!accessible) field.setAccessible(false);
+                    if (force) {
+                        Log.e(String.format("Can't save field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep));
+                    } else {
+                        final String errMsg = String.format("Can't save field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep);
+                        Log.e(errMsg);
+                        throw new RuntimeException(errMsg);
+                    }
+                } else {
+                    if (!accessible) field.setAccessible(false);
+                }
+            } catch (IllegalAccessException e) {
+                Log.e("Can't get field", e);
+            }
+        }
+
+        return this.save();
+    }
+
+    @Override
+    public void deleteDeep() {
+        deleteDeep(false, null);
+    }
+
+    @Override
+    public void deleteDeep(final boolean force) {
+        deleteDeep(force, null);
+    }
+
+    @Override
+    public void deleteDeep(final boolean force, final IDeepActionHandler deepActionHandler) {
+        List<Field> fields = getAllModelFields(getClass());
+        for (Field field : fields) {
+            try {
+                boolean deep = false;
+                final boolean accessible = field.isAccessible();
+                if (!accessible) field.setAccessible(true);
+                final Object model = field.get(this);
+                if (null == model) continue;
+                try {
+                    if (null != deepActionHandler && model instanceof Model && deepActionHandler.shouldProcess(field.getName(), (Model) model)) {
+                        if (model instanceof DeepModel) {
+                            deep = true;
+                            ((IDeepModel) model).deleteDeep(force);
+                        } else {
+                            ((Model) model).delete();
+                        }
+                    } else if (null == deepActionHandler) {
+                        if (model instanceof IDeepModel) {
+                            deep = true;
+                            ((IDeepModel) model).deleteDeep(force);
+                        } else if (model instanceof Model){
+                            ((Model) model).delete();
+                        }
+                    } else {
+                        Log.i("Skipped processing field %s for deleting operation", field.getName());
+                    }
+                } catch (Exception e) {
+                    if (force) {
+                        Log.e(String.format("Can't delete field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep), e);
+                    } else {
+                        final String errMsg = String.format("Can't delete field %s.%s in DB, deep: %b", field.getClass().getSimpleName(), field.getName(), deep);
+                        Log.e(errMsg, e);
+                        throw new RuntimeException(errMsg, e);
+                    }
+                } finally {
+                    if (!accessible) field.setAccessible(false);
+                }
+            } catch (IllegalAccessException e) {
+                Log.e("Can't get field", e);
+            }
+        }
+
+        this.delete();
+    }
+
+    private static List<Field> getAllModelFields(Class<? extends Model> clazz) {
+        final List<Field> fields = Lists.newArrayList();
+        final Field[] declaredFields = clazz.getDeclaredFields();
+
+        if (clazz == Model.class) return fields;
+
+        if (null != declaredFields && declaredFields.length > 0) {
+            for (Field input : declaredFields) {
+                if (null != input
+                        && Model.class.isAssignableFrom(input.getType())
+                        && !Modifier.isPrivate(input.getModifiers())
+                        && !Modifier.isStatic(input.getModifiers()))
+                    fields.add(input);
+            }
+        }
+
+        Class<?> superClazz = clazz.getSuperclass();
+        if (null == superClazz || !DeepModel.class.isAssignableFrom(superClazz)) return fields;
+
+        //noinspection unchecked
+        fields.addAll(getAllModelFields((Class<? extends Model>) superClazz));
+
+        return fields;
+    }
+}
diff --git a/src/com/activeandroid/sebbia/IDeepModel.java b/src/com/activeandroid/sebbia/IDeepModel.java
new file mode 100644
index 00000000..6af11815
--- /dev/null
+++ b/src/com/activeandroid/sebbia/IDeepModel.java
@@ -0,0 +1,15 @@
+package com.activeandroid.sebbia;
+
+public interface IDeepModel {
+    interface IDeepActionHandler {
+        <T extends Model> boolean shouldProcess(String fieldName, T model);
+    }
+
+    Long saveDeep();
+    Long saveDeep(boolean force);
+    Long saveDeep(boolean force, IDeepActionHandler deepActionHandler);
+
+    void deleteDeep();
+    void deleteDeep(boolean force);
+    void deleteDeep(boolean force, IDeepActionHandler deepActionHandler);
+}
