diff --git a/src/main/java/com/activeandroid/manager/DBManagerRuntime.java b/src/main/java/com/activeandroid/manager/DBManagerRuntime.java
index c71406da..1a0236a5 100644
--- a/src/main/java/com/activeandroid/manager/DBManagerRuntime.java
+++ b/src/main/java/com/activeandroid/manager/DBManagerRuntime.java
@@ -15,8 +15,8 @@
 
     private static ArrayList<SingleDBManager> managers;
 
-    static ArrayList<SingleDBManager> getManagers(){
-        if(managers==null){
+    static ArrayList<SingleDBManager> getManagers() {
+        if (managers == null) {
             managers = new ArrayList<SingleDBManager>();
         }
         return managers;
@@ -25,9 +25,10 @@
     /**
      * Quits all active DBManager queues
      */
-    public static void quit(){
-        for(SingleDBManager manager: getManagers()){
-            if(manager.hasOwnQueue()) {
+    public static void quit() {
+        ArrayList<SingleDBManager> dbManagers = getManagers();
+        for (SingleDBManager manager : dbManagers) {
+            if (manager.hasOwnQueue()) {
                 manager.getQueue().quit();
                 manager.disposeQueue();
             }
@@ -36,9 +37,15 @@ public static void quit(){
         DBBatchSaveQueue.disposeSharedQueue();
     }
 
-    public static void restartManagers(){
-        for(SingleDBManager manager: getManagers()){
-            manager.checkQueue();
+    public static void restartManagers() {
+        ArrayList<SingleDBManager> dbManagers = getManagers();
+        for (SingleDBManager manager : dbManagers) {
+            manager.restart();
         }
     }
+
+    static void addToQueue(SingleDBManager singleDBManager) {
+        ArrayList<SingleDBManager> dbManagers = getManagers();
+        dbManagers.add(singleDBManager);
+    }
 }
diff --git a/src/main/java/com/activeandroid/manager/SingleDBManager.java b/src/main/java/com/activeandroid/manager/SingleDBManager.java
index 6d99e2d4..82548925 100644
--- a/src/main/java/com/activeandroid/manager/SingleDBManager.java
+++ b/src/main/java/com/activeandroid/manager/SingleDBManager.java
@@ -7,17 +7,15 @@
 import com.activeandroid.Cache;
 import com.activeandroid.IModel;
 import com.activeandroid.exception.DBManagerNotOnMainException;
+import com.activeandroid.interfaces.CollectionReceiver;
+import com.activeandroid.interfaces.ObjectReceiver;
 import com.activeandroid.interfaces.ObjectRequester;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
-import com.activeandroid.interfaces.CollectionReceiver;
-import com.activeandroid.interfaces.ObjectReceiver;
 import com.activeandroid.runtime.DBBatchSaveQueue;
 import com.activeandroid.runtime.DBRequest;
 import com.activeandroid.runtime.DBRequestInfo;
 import com.activeandroid.runtime.DBRequestQueue;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
 import com.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
@@ -40,39 +38,61 @@
 
     private String mName;
 
-    private  final boolean hasOwnQueue;
+    private final boolean hasOwnQueue;
 
     /**
      * Creates the SingleDBManager while starting its own request queue
+     *
      * @param name
      */
-    public SingleDBManager(String name, boolean createNewQueue){
+    public SingleDBManager(String name, boolean createNewQueue) {
         mName = name;
         hasOwnQueue = createNewQueue;
         checkThread();
-        DBManagerRuntime.getManagers().add(this);
-        checkQueue();
+        DBManagerRuntime.addToQueue(this);
+        createNewQueue();
     }
 
     /**
      * Returns the application's only needed DBManager.
      * Note: this manager must be created on the main thread, otherwise a {@link com.activeandroid.exception.DBManagerNotOnMainException} will be thrown
+     *
      * @return
      */
-    public static SingleDBManager getSharedInstance(){
-        if(manager==null){
-           manager = new SingleDBManager("SingleDBManager", true);
+    public static SingleDBManager getSharedInstance() {
+        if (manager == null) {
+            manager = new SingleDBManager("SingleDBManager", true);
         }
         return manager;
     }
 
     void checkQueue() {
-        if (!getQueue().isAlive()) {
-            getQueue().start();
+        final DBRequestQueue dbRequestQueue = getQueue();
+        if (!dbRequestQueue.isAlive()) {
+            dbRequestQueue.start();
         }
-        if (!getSaveQueue().isAlive()) {
-            getSaveQueue().start();
+        final DBBatchSaveQueue saveQueue = getSaveQueue();
+        if (!saveQueue.isAlive()) {
+            saveQueue.start();
+        }
+    }
+
+    void restart() {
+        final DBRequestQueue dbRequestQueue = getQueue();
+        if (dbRequestQueue.isAlive() && !dbRequestQueue.isInterrupted()) {
+            dbRequestQueue.quit();
+        }
+        createNewQueue();
+        mQueue.start();
+    }
+
+    private DBRequestQueue createNewQueue() {
+        if (hasOwnQueue) {
+            mQueue = new DBRequestQueue(mName);
+        } else {
+            mQueue = SingleDBManager.getSharedInstance().createNewQueue();
         }
+        return mQueue;
     }
 
     public boolean hasOwnQueue() {
@@ -86,26 +106,22 @@ void disposeQueue() {
         mQueue = null;
     }
 
-    public DBRequestQueue getQueue(){
-        if(mQueue==null){
-            if(hasOwnQueue) {
-                mQueue = new DBRequestQueue(mName);
-            } else{
-                mQueue = SingleDBManager.getSharedInstance().mQueue;
-            }
+    public DBRequestQueue getQueue() {
+        if (mQueue == null) {
+            createNewQueue();
         }
         return mQueue;
     }
 
-    public DBBatchSaveQueue getSaveQueue(){
+    public DBBatchSaveQueue getSaveQueue() {
         return DBBatchSaveQueue.getSharedSaveQueue();
     }
 
     /**
      * Ensure manager was created in the main thread, otherwise handler will not work
      */
-    protected void checkThread(){
-        if(!Thread.currentThread().getName().equals("main")){
+    protected void checkThread() {
+        if (!Thread.currentThread().getName().equals("main")) {
             throw new DBManagerNotOnMainException("DBManager needs to be instantiated on the main thread so Handler is on UI thread. Was on : " + Thread.currentThread().getName());
         }
     }
@@ -117,40 +133,44 @@ protected void checkThread(){
 
     /**
      * Runs a request from the DB in the request queue
+     *
      * @param runnable
      */
-    protected void processOnBackground(DBRequest runnable){
+    protected void processOnBackground(DBRequest runnable) {
         getQueue().add(runnable);
     }
 
     /**
      * Runs UI operations in the handler
+     *
      * @param runnable
      */
-    protected synchronized void processOnForeground(Runnable runnable){
+    protected synchronized void processOnForeground(Runnable runnable) {
         mRequestHandler.post(runnable);
     }
 
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
-       return DBManagerCache.constructNewInstance(object, obClazz);
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object) {
+        return DBManagerCache.constructNewInstance(object, obClazz);
     }
 
     /**
      * Adds an object to the manager's database
+     *
      * @param inObject - object of the class defined by the manager
      */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(OBJECT_CLASS inObject){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(OBJECT_CLASS inObject) {
         inObject.save();
         return inObject;
     }
 
     /**
      * Adds a json object to this class, however its advised you ensure that the jsonobject being passed is what you want, since there's no type checking
+     *
      * @param object
      */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object) {
         try {
-            return add(getObject(obClazz,object));
+            return add(getObject(obClazz, object));
         } catch (Throwable e) {
             e.printStackTrace();
         }
@@ -159,34 +179,36 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     /**
      * Adds an object to the DB in the BG
+     *
      * @param jsonObject
      */
-    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
+    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver) {
         OBJECT_CLASS object = getObject(obClazz, jsonObject);
-        if(objectReceiver!=null){
+        if (objectReceiver != null) {
             objectReceiver.onObjectReceived(object);
         }
         getSaveQueue().add(object);
 
     }
 
-    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
-        addInBackground(obClazz, jsonObject,null);
+    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject) {
+        addInBackground(obClazz, jsonObject, null);
     }
 
 
-    public <OBJECT_CLASS extends IModel> void addInBackground(final OBJECT_CLASS object){
+    public <OBJECT_CLASS extends IModel> void addInBackground(final OBJECT_CLASS object) {
         getSaveQueue().add(object);
     }
 
     /**
      * Adds all objects to the DB
+     *
      * @param objects
      */
-    public <OBJECT_CLASS extends IModel, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
+    public <OBJECT_CLASS extends IModel, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects) {
         ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
+        try {
+            for (OBJECT_CLASS object : objects) {
                 add(object);
             }
             ActiveAndroid.setTransactionSuccessful();
@@ -197,13 +219,14 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     /**
      * Adds all objects from the passed object (if it has collection-like methods), may NOT be type-safe so be careful with this
+     *
      * @param array
      */
-    public <OBJECT_CLASS extends IModel> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
+    public <OBJECT_CLASS extends IModel> void addAll(Class<OBJECT_CLASS> obClazz, Object array) {
         ActiveAndroid.beginTransaction();
-        try{
+        try {
             int count = DBManagerCache.invokeGetSizeMethod(array);
-            for(int i = 0; i < count;i++){
+            for (int i = 0; i < count; i++) {
                 Object getObject = DBManagerCache.invokeGetMethod(array, i);
                 OBJECT_CLASS object = DBManagerCache.constructNewInstance(getObject, obClazz);
                 add(object);
@@ -222,18 +245,18 @@ protected synchronized void processOnForeground(Runnable runnable){
     }
 
 
-    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
+    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver) {
         processOnBackground(new DBRequest() {
             @Override
             public void run() {
                 final List<OBJECT_CLASS> objects = new ArrayList<OBJECT_CLASS>();
                 int count = DBManagerCache.invokeGetSizeMethod(array);
-                for(int i = 0; i < count;i++){
-                    Object getObject =  DBManagerCache.invokeGetMethod(array, i);
+                for (int i = 0; i < count; i++) {
+                    Object getObject = DBManagerCache.invokeGetMethod(array, i);
                     objects.add(getObject(obClazz, getObject));
                 }
 
-                if(collectionReceiver!=null){
+                if (collectionReceiver != null) {
                     processOnForeground(new Runnable() {
                         @Override
                         public void run() {
@@ -248,34 +271,37 @@ public void run() {
 
     }
 
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAllInBackground(final COLLECTION_CLASS collection){
-       getSaveQueue().addAll(collection);
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAllInBackground(final COLLECTION_CLASS collection) {
+        getSaveQueue().addAll(collection);
     }
 
     /**
      * Retrieves a list of objects from the database without any threading
      * Its recommended not to call this method in the foreground thread
+     *
      * @return
      */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz) {
         return new Select().from(obClazz).execute();
     }
 
     /**
      * Retrieves a list of objects from the database without any threading with the sort passed
      * Its recommended not to call this method in the foreground thread
+     *
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @return
      */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort) {
         return new Select().from(obClazz).orderBy(sort).execute();
     }
 
     /**
      * Fetches objects from this DB on the BG
+     *
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends IModel> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModel> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver) {
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -292,10 +318,11 @@ public void run() {
 
     /**
      * Fetches objects from this DB on the BG calling orderBy with the sort passed.
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
+     *
+     * @param sort     - valid SQLLite syntax for sort e.g. name ASC
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends IModel> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModel> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver) {
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -308,10 +335,12 @@ public void run() {
                 });
             }
         });
-    };
+    }
+
+    ;
 
-    public <OBJECT_CLASS extends IModel> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
-        processOnBackground(new DBRequest(DBRequestInfo.create("fetch" , DBRequest.PRIORITY_UI)) {
+    public <OBJECT_CLASS extends IModel> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver) {
+        processOnBackground(new DBRequest(DBRequestInfo.create("fetch", DBRequest.PRIORITY_UI)) {
             @Override
             public void run() {
                 final List<OBJECT_CLASS> list = getAllWithColumnValue(obClazz, column, value);
@@ -327,57 +356,63 @@ public void run() {
 
     /**
      * This will get the where statement for this object, the amount of ids passed must match the primary key column size
+     *
      * @return
      */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object... ids) {
         return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz)), ids).executeSingle();
     }
 
     /**
      * Returns a single object with the specified column name.
      * Useful for getting objects with a specific primary key
+     *
      * @param column
      * @param uid
      * @return
      */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
-        return new Select().from(obClazz).where(column+" =?", uid).executeSingle();
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid) {
+        return new Select().from(obClazz).where(column + " =?", uid).executeSingle();
     }
 
     /**
      * Returns all objects with the specified column name
+     *
      * @param column
      * @param value
      * @return
      */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value) {
         return new Select().from(obClazz).where(column + "= ?", value).execute();
     }
 
     /**
      * Gets all in a table by a group by
+     *
      * @param obClazz
      * @param groupBy
      * @param <OBJECT_CLASS>
      * @return
      */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy) {
         return new Select().from(obClazz).groupBy(groupBy).execute();
     }
 
     /**
      * Returns the count of rows from this DB manager's DB
+     *
      * @return
      */
-    public long getCount(final Class<? extends IModel> obClazz){
+    public long getCount(final Class<? extends IModel> obClazz) {
         return DatabaseUtils.queryNumEntries(Cache.openDatabase(), Cache.getTableName(obClazz));
     }
 
     /**
      * Fetches the count on the DB thread and returns it on the handler
+     *
      * @param objectReceiver
      */
-    public <OBJECT_CLASS extends IModel> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
+    public <OBJECT_CLASS extends IModel> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver) {
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -398,9 +433,9 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid) {
         OBJECT_CLASS object = getObjectById(obClazz, uid);
-        if(object==null&&requester!=null){
+        if (object == null && requester != null) {
             processOnForeground(new Runnable() {
                 @Override
                 public void run() {
@@ -408,11 +443,12 @@ public void run() {
                 }
             });
             return false;
-        } else{
+        } else {
             objectReceiver.onObjectReceived(object);
             return true;
         }
     }
+
     /**
      * Will return the object if its within the DB, if not, it will not call an{@link com.activeandroid.interfaces.ObjectRequester}
      *
@@ -420,28 +456,30 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
-       return fetchObject(obClazz, null, objectReceiver, uid);
+    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid) {
+        return fetchObject(obClazz, null, objectReceiver, uid);
     }
 
 
     /**
      * Deletes all objects from the specified table
+     *
      * @param obClazz
      * @param <OBJECT_CLASS>
      */
-    public <OBJECT_CLASS extends IModel> void deleteAll(Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModel> void deleteAll(Class<OBJECT_CLASS> obClazz) {
         new Delete().from(obClazz).execute();
     }
 
     /**
      * Deletes objects from the db
+     *
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends IModel> void deleteAll(OBJECT_CLASS...objects) {
+    public <OBJECT_CLASS extends IModel> void deleteAll(OBJECT_CLASS... objects) {
         ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
+        try {
+            for (OBJECT_CLASS object : objects) {
                 object.delete();
             }
             ActiveAndroid.setTransactionSuccessful();
@@ -452,12 +490,13 @@ public void run() {
 
     /**
      * Deletes all objects from the collection specified
+     *
      * @param objects - the list of IModel objects you wish to delete
      */
     public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAll(COLLECTION_CLASS objects) {
         ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
+        try {
+            for (OBJECT_CLASS object : objects) {
                 object.delete();
             }
             ActiveAndroid.setTransactionSuccessful();
@@ -468,17 +507,18 @@ public void run() {
 
     /**
      * Deletes objects from the db
+     *
      * @param finishedRunnable
      * @param dbRequestInfo
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
+    public <LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
                 deleteAll(objects);
-                if(finishedRunnable!=null){
+                if (finishedRunnable != null) {
                     finishedRunnable.run();
                 }
             }
@@ -487,17 +527,18 @@ public void run() {
 
     /**
      * Deletes objects from the db
+     *
      * @param finishedRunnable
      * @param dbRequestInfo
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
+    public <OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS... objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
                 deleteAll(objects);
-                if(finishedRunnable!=null){
+                if (finishedRunnable != null) {
                     finishedRunnable.run();
                 }
             }
