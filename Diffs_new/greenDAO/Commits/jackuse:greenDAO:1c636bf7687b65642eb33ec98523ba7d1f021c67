diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..26f642f9
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,75 @@
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
+
+#/local.properties
+/.idea/workspace.xml
+.DS_Store
+#/build
+.idea
+*/build
+
+# Built application files
+*.apk
+*.ap_
+
+# Files for the Dalvik VM
+*.dex
+
+# Java class files
+*.class
+
+# Generated files
+bin/
+gen/
+
+# Gradle files
+.gradle/
+build/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Proguard folder generated by Eclipse
+proguard/
+
+# Log Files
+*.log
+
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm
+
+## Directory-based project format
+.idea/
+# if you remove the above rule, at least ignore user-specific stuff:
+# .idea/workspace.xml
+# .idea/tasks.xml
+# and these sensitive or high-churn files:
+# .idea/dataSources.ids
+# .idea/dataSources.xml
+# .idea/sqlDataSources.xml
+# .idea/dynamic.xml
+
+## File-based project format
+*.ipr
+*.iml
+*.iws
+
+## Additional for IntelliJ
+out/
+
+# generated by mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# generated by JIRA plugin
+atlassian-ide-plugin.xml
+
+# generated by Crashlytics plugin (for Android Studio and Intellij)
+com_crashlytics_export_strings.xml
+crashlytics-build.properties
+
+
+Thumbs.db
+
diff --git a/DaoCore/.gitignore b/DaoCore/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/DaoCore/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
new file mode 100644
index 00000000..f5fbe52e
--- /dev/null
+++ b/DaoCore/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 21
+    buildToolsVersion "21.0.2"
+
+    defaultConfig {
+        applicationId "de.greenrobot.dao"
+        minSdkVersion 8
+        targetSdkVersion 21
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:21.0.0'
+}
diff --git a/DaoCore/proguard-rules.pro b/DaoCore/proguard-rules.pro
new file mode 100644
index 00000000..4667b2c2
--- /dev/null
+++ b/DaoCore/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in G:/android-studio-2/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/DaoCore/src/androidTest/java/com/borvo/dao/ApplicationTest.java b/DaoCore/src/androidTest/java/com/borvo/dao/ApplicationTest.java
new file mode 100644
index 00000000..e8da1884
--- /dev/null
+++ b/DaoCore/src/androidTest/java/com/borvo/dao/ApplicationTest.java
@@ -0,0 +1,13 @@
+package de.greenrobot.dao;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/AndroidManifest.xml b/DaoCore/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..f568b09e
--- /dev/null
+++ b/DaoCore/src/main/AndroidManifest.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.dao" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+        </activity>
+    </application>
+
+</manifest>
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
new file mode 100644
index 00000000..00f32919
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
@@ -0,0 +1,813 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import android.database.CrossProcessCursor;
+import android.database.Cursor;
+import android.database.CursorWindow;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import de.greenrobot.dao.identityscope.IdentityScope;
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.internal.FastCursor;
+import de.greenrobot.dao.internal.TableStatements;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+/**
+ * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
+ * 
+ * This class is thread-safe.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            Entity type
+ * @param <K>
+ *            Primary key (PK) type; use Void if entity does not have exactly one PK
+ */
+/*
+ * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
+ * 
+ * 1.) If not inside a TX already, begin a TX to acquire a DB connection (connection is to be handled like a lock)
+ * 
+ * 2.) The SQLiteStatement
+ * 
+ * 3.) identityScope
+ */
+public abstract class AbstractDao<T, K> {
+    protected final SQLiteDatabase db;
+    protected final DaoConfig config;
+    protected IdentityScope<K, T> identityScope;
+    protected IdentityScopeLong<T> identityScopeLong;
+    protected TableStatements statements;
+
+    protected final AbstractDaoSession session;
+    protected final int pkOrdinal;
+
+    public AbstractDao(DaoConfig config) {
+        this(config, null);
+    }
+
+    @SuppressWarnings("unchecked")
+    public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
+        this.config = config;
+        this.session = daoSession;
+        db = config.db;
+        identityScope = (IdentityScope<K, T>) config.getIdentityScope();
+        if (identityScope instanceof IdentityScopeLong) {
+            identityScopeLong = (IdentityScopeLong<T>) identityScope;
+        }
+        statements = config.statements;
+        pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
+    }
+
+    public AbstractDaoSession getSession() {
+        return session;
+    }
+
+    TableStatements getStatements() {
+        return config.statements;
+    }
+
+    public String getTablename() {
+        return config.tablename;
+    }
+
+    public Property[] getProperties() {
+        return config.properties;
+    }
+
+    public Property getPkProperty() {
+        return config.pkProperty;
+    }
+
+    public String[] getAllColumns() {
+        return config.allColumns;
+    }
+
+    public String[] getPkColumns() {
+        return config.pkColumns;
+    }
+
+    public String[] getNonPkColumns() {
+        return config.nonPkColumns;
+    }
+
+    /**
+     * Loads and entity for the given PK.
+     * 
+     * @param key
+     *            a PK value or null
+     * @return The entity or null, if no entity matched the PK value
+     */
+    public T load(K key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+        if (identityScope != null) {
+            T entity = identityScope.get(key);
+            if (entity != null) {
+                return entity;
+            }
+        }
+        String sql = statements.getSelectByKey();
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        return loadUniqueAndCloseCursor(cursor);
+    }
+
+    public T loadByRowId(long rowId) {
+        String[] idArray = new String[] { Long.toString(rowId) };
+        Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
+        return loadUniqueAndCloseCursor(cursor);
+    }
+
+    protected T loadUniqueAndCloseCursor(Cursor cursor) {
+        try {
+            return loadUnique(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+
+    protected T loadUnique(Cursor cursor) {
+        boolean available = cursor.moveToFirst();
+        if (!available) {
+            return null;
+        } else if (!cursor.isLast()) {
+            throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+        }
+        return loadCurrent(cursor, 0, true);
+    }
+
+    /** Loads all available entities from the database. */
+    public List<T> loadAll() {
+        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
+        return loadAllAndCloseCursor(cursor);
+    }
+
+    /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
+    public boolean detach(T entity) {
+        if (identityScope != null) {
+            K key = getKeyVerified(entity);
+            return identityScope.detach(key, entity);
+        } else {
+            return false;
+        }
+    }
+
+    protected List<T> loadAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+
+    /**
+     * Inserts the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to insert.
+     */
+    public void insertInTx(Iterable<T> entities) {
+        insertInTx(entities, isEntityUpdateable());
+    }
+
+    /**
+     * Inserts the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to insert.
+     */
+    public void insertInTx(T... entities) {
+        insertInTx(Arrays.asList(entities), isEntityUpdateable());
+    }
+
+    /**
+     * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
+     * is set.
+     * 
+     * @param entities
+     *            The entities to insert.
+     * @param setPrimaryKey
+     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     */
+    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
+        SQLiteStatement stmt = statements.getInsertStatement();
+        executeInsertInTx(stmt, entities, setPrimaryKey);
+    }
+
+    /**
+     * Inserts or replaces the given entities in the database using a transaction. The given entities will become
+     * tracked if the PK is set.
+     * 
+     * @param entities
+     *            The entities to insert.
+     * @param setPrimaryKey
+     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     */
+    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
+        SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
+        executeInsertInTx(stmt, entities, setPrimaryKey);
+    }
+
+    /**
+     * Inserts or replaces the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to insert.
+     */
+    public void insertOrReplaceInTx(Iterable<T> entities) {
+        insertOrReplaceInTx(entities, isEntityUpdateable());
+    }
+
+    /**
+     * Inserts or replaces the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to insert.
+     */
+    public void insertOrReplaceInTx(T... entities) {
+        insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
+    }
+
+    private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
+        db.beginTransaction();
+        try {
+            synchronized (stmt) {
+                if (identityScope != null) {
+                    identityScope.lock();
+                }
+                try {
+                    for (T entity : entities) {
+                        bindValues(stmt, entity);
+                        if (setPrimaryKey) {
+                            long rowId = stmt.executeInsert();
+                            updateKeyAfterInsertAndAttach(entity, rowId, false);
+                        } else {
+                            stmt.execute();
+                        }
+                    }
+                } finally {
+                    if (identityScope != null) {
+                        identityScope.unlock();
+                    }
+                }
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Insert an entity into the table associated with a concrete DAO.
+     * 
+     * @return row ID of newly inserted entity
+     */
+    public long insert(T entity) {
+        return executeInsert(entity, statements.getInsertStatement());
+    }
+
+    /**
+     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
+     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
+     * 
+     * @return row ID of newly inserted entity
+     */
+    public long insertWithoutSettingPk(T entity) {
+        SQLiteStatement stmt = statements.getInsertStatement();
+        long rowId;
+        if (db.isDbLockedByCurrentThread()) {
+            synchronized (stmt) {
+                bindValues(stmt, entity);
+                rowId = stmt.executeInsert();
+            }
+        } else {
+            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+            db.beginTransaction();
+            try {
+                synchronized (stmt) {
+                    bindValues(stmt, entity);
+                    rowId = stmt.executeInsert();
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+        return rowId;
+    }
+
+    /**
+     * Insert an entity into the table associated with a concrete DAO.
+     * 
+     * @return row ID of newly inserted entity
+     */
+    public long insertOrReplace(T entity) {
+        return executeInsert(entity, statements.getInsertOrReplaceStatement());
+    }
+
+    private long executeInsert(T entity, SQLiteStatement stmt) {
+        long rowId;
+        if (db.isDbLockedByCurrentThread()) {
+            synchronized (stmt) {
+                bindValues(stmt, entity);
+                rowId = stmt.executeInsert();
+            }
+        } else {
+            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+            db.beginTransaction();
+            try {
+                synchronized (stmt) {
+                    bindValues(stmt, entity);
+                    rowId = stmt.executeInsert();
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+        updateKeyAfterInsertAndAttach(entity, rowId, true);
+        return rowId;
+    }
+
+    protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {
+        if (rowId != -1) {
+            K key = updateKeyAfterInsert(entity, rowId);
+            attachEntity(key, entity, lock);
+        } else {
+            // TODO When does this actually happen? Should we throw instead?
+            DaoLog.w("Could not insert row (executeInsert returned -1)");
+        }
+    }
+
+    /** Reads all available rows from the given cursor and returns a list of entities. */
+    protected List<T> loadAllFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<T> list = new ArrayList<T>(count);
+        if (cursor instanceof CrossProcessCursor) {
+            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
+            if (window != null) { // E.g. Roboelectric has no Window at this point
+                if (window.getNumRows() == count) {
+                    cursor = new FastCursor(window);
+                } else {
+                    DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
+                }
+            }
+        }
+
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrent(cursor, 0, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+
+    /** Internal use only. Considers identity scope. */
+    final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
+        if (identityScopeLong != null) {
+            if (offset != 0) {
+                // Occurs with deep loads (left outer joins)
+                if (cursor.isNull(pkOrdinal + offset)) {
+                    return null;
+                }
+            }
+
+            long key = cursor.getLong(pkOrdinal + offset);
+            T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
+            if (entity != null) {
+                return entity;
+            } else {
+                entity = readEntity(cursor, offset);
+                attachEntity(entity);
+                if (lock) {
+                    identityScopeLong.put2(key, entity);
+                } else {
+                    identityScopeLong.put2NoLock(key, entity);
+                }
+                return entity;
+            }
+        } else if (identityScope != null) {
+            K key = readKey(cursor, offset);
+            if (offset != 0 && key == null) {
+                // Occurs with deep loads (left outer joins)
+                return null;
+            }
+            T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);
+            if (entity != null) {
+                return entity;
+            } else {
+                entity = readEntity(cursor, offset);
+                attachEntity(key, entity, lock);
+                return entity;
+            }
+        } else {
+            // Check offset, assume a value !=0 indicating a potential outer join, so check PK
+            if (offset != 0) {
+                K key = readKey(cursor, offset);
+                if (key == null) {
+                    // Occurs with deep loads (left outer joins)
+                    return null;
+                }
+            }
+            T entity = readEntity(cursor, offset);
+            attachEntity(entity);
+            return entity;
+        }
+    }
+
+    /** Internal use only. Considers identity scope. */
+    final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
+        return dao.loadCurrent(cursor, offset, /* TODO check this */true);
+    }
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<T> queryRaw(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
+        return loadAllAndCloseCursor(cursor);
+    }
+
+    /**
+     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
+     * arguments.
+     */
+    public Query<T> queryRawCreate(String where, Object... selectionArg) {
+        List<Object> argList = Arrays.asList(selectionArg);
+        return queryRawCreateListArgs(where, argList);
+    }
+
+    /**
+     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
+     * arguments.
+     */
+    public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
+        return Query.internalCreate(this, statements.getSelectAll() + where, selectionArg.toArray());
+    }
+
+    public void deleteAll() {
+        // String sql = SqlUtils.createSqlDelete(config.tablename, null);
+        // db.execSQL(sql);
+
+        db.execSQL("DELETE FROM '" + config.tablename + "'");
+        if (identityScope != null) {
+            identityScope.clear();
+        }
+    }
+
+    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
+    public void delete(T entity) {
+        assertSinglePk();
+        K key = getKeyVerified(entity);
+        deleteByKey(key);
+    }
+
+    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
+    public void deleteByKey(K key) {
+        assertSinglePk();
+        SQLiteStatement stmt = statements.getDeleteStatement();
+        if (db.isDbLockedByCurrentThread()) {
+            synchronized (stmt) {
+                deleteByKeyInsideSynchronized(key, stmt);
+            }
+        } else {
+            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+            db.beginTransaction();
+            try {
+                synchronized (stmt) {
+                    deleteByKeyInsideSynchronized(key, stmt);
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+        if (identityScope != null) {
+            identityScope.remove(key);
+        }
+    }
+
+    private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
+        if (key instanceof Long) {
+            stmt.bindLong(1, (Long) key);
+        } else if (key == null) {
+            throw new DaoException("Cannot delete entity, key is null");
+        } else {
+            stmt.bindString(1, key.toString());
+        }
+        stmt.execute();
+    }
+
+    private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
+        assertSinglePk();
+        SQLiteStatement stmt = statements.getDeleteStatement();
+        List<K> keysToRemoveFromIdentityScope = null;
+        db.beginTransaction();
+        try {
+            synchronized (stmt) {
+                if (identityScope != null) {
+                    identityScope.lock();
+                    keysToRemoveFromIdentityScope = new ArrayList<K>();
+                }
+                try {
+                    if (entities != null) {
+                        for (T entity : entities) {
+                            K key = getKeyVerified(entity);
+                            deleteByKeyInsideSynchronized(key, stmt);
+                            if (keysToRemoveFromIdentityScope != null) {
+                                keysToRemoveFromIdentityScope.add(key);
+                            }
+                        }
+                    }
+                    if (keys != null) {
+                        for (K key : keys) {
+                            deleteByKeyInsideSynchronized(key, stmt);
+                            if (keysToRemoveFromIdentityScope != null) {
+                                keysToRemoveFromIdentityScope.add(key);
+                            }
+                        }
+                    }
+                } finally {
+                    if (identityScope != null) {
+                        identityScope.unlock();
+                    }
+                }
+            }
+            db.setTransactionSuccessful();
+            if (keysToRemoveFromIdentityScope != null && identityScope != null) {
+                identityScope.remove(keysToRemoveFromIdentityScope);
+            }
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Deletes the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to delete.
+     */
+    public void deleteInTx(Iterable<T> entities) {
+        deleteInTxInternal(entities, null);
+    }
+
+    /**
+     * Deletes the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to delete.
+     */
+    public void deleteInTx(T... entities) {
+        deleteInTxInternal(Arrays.asList(entities), null);
+    }
+
+    /**
+     * Deletes all entities with the given keys in the database using a transaction.
+     * 
+     * @param keys
+     *            Keys of the entities to delete.
+     */
+    public void deleteByKeyInTx(Iterable<K> keys) {
+        deleteInTxInternal(null, keys);
+    }
+
+    /**
+     * Deletes all entities with the given keys in the database using a transaction.
+     * 
+     * @param keys
+     *            Keys of the entities to delete.
+     */
+    public void deleteByKeyInTx(K... keys) {
+        deleteInTxInternal(null, Arrays.asList(keys));
+    }
+
+    /** Resets all locally changed properties of the entity by reloading the values from the database. */
+    public void refresh(T entity) {
+        assertSinglePk();
+        K key = getKeyVerified(entity);
+        String sql = statements.getSelectByKey();
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass()
+                        + " with key " + key);
+            } else if (!cursor.isLast()) {
+                throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+            }
+            readEntity(cursor, entity, 0);
+            attachEntity(key, entity, true);
+        } finally {
+            cursor.close();
+        }
+    }
+
+    public void update(T entity) {
+        assertSinglePk();
+        SQLiteStatement stmt = statements.getUpdateStatement();
+        if (db.isDbLockedByCurrentThread()) {
+            synchronized (stmt) {
+                updateInsideSynchronized(entity, stmt, true);
+            }
+        } else {
+            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+            db.beginTransaction();
+            try {
+                synchronized (stmt) {
+                    updateInsideSynchronized(entity, stmt, true);
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+    }
+
+    public QueryBuilder<T> queryBuilder() {
+        return QueryBuilder.internalCreate(this);
+    }
+
+    protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
+        // To do? Check if it's worth not to bind PKs here (performance).
+        bindValues(stmt, entity);
+        int index = config.allColumns.length + 1;
+        K key = getKey(entity);
+        if (key instanceof Long) {
+            stmt.bindLong(index, (Long) key);
+        } else if (key == null) {
+            throw new DaoException("Cannot update entity without key - was it inserted before?");
+        } else {
+            stmt.bindString(index, key.toString());
+        }
+        stmt.execute();
+        attachEntity(key, entity, lock);
+    }
+
+    /**
+     * Attaches the entity to the identity scope. Calls attachEntity(T entity).
+     * 
+     * @param key
+     *            Needed only for identity scope, pass null if there's none.
+     * @param entity
+     *            The entitiy to attach
+     * */
+    protected final void attachEntity(K key, T entity, boolean lock) {
+        attachEntity(entity);
+        if (identityScope != null && key != null) {
+            if (lock) {
+                identityScope.put(key, entity);
+            } else {
+                identityScope.putNoLock(key, entity);
+            }
+        }
+    }
+
+    /**
+     * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
+     * the identity scope.
+     * 
+     * @param entity
+     *            The entitiy to attach
+     * */
+    protected void attachEntity(T entity) {
+    }
+
+    /**
+     * Updates the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to insert.
+     */
+    public void updateInTx(Iterable<T> entities) {
+        SQLiteStatement stmt = statements.getUpdateStatement();
+        db.beginTransaction();
+        try {
+            synchronized (stmt) {
+                if (identityScope != null) {
+                    identityScope.lock();
+                }
+                try {
+                    for (T entity : entities) {
+                        updateInsideSynchronized(entity, stmt, false);
+                    }
+                } finally {
+                    if (identityScope != null) {
+                        identityScope.unlock();
+                    }
+                }
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Updates the given entities in the database using a transaction.
+     * 
+     * @param entities
+     *            The entities to update.
+     */
+    public void updateInTx(T... entities) {
+        updateInTx(Arrays.asList(entities));
+    }
+
+    protected void assertSinglePk() {
+        if (config.pkColumns.length != 1) {
+            throw new DaoException(this + " (" + config.tablename + ") does not have a single-column primary key");
+        }
+    }
+
+    public long count() {
+        return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
+    }
+
+    /** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
+    protected K getKeyVerified(T entity) {
+        K key = getKey(entity);
+        if (key == null) {
+            if (entity == null) {
+                throw new NullPointerException("Entity may not be null");
+            } else {
+                throw new DaoException("Entity has no key");
+            }
+        } else {
+            return key;
+        }
+    }
+
+    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
+    public SQLiteDatabase getDatabase() {
+        return db;
+    }
+
+    /** Reads the values from the current position of the given cursor and returns a new entity. */
+    abstract protected T readEntity(Cursor cursor, int offset);
+
+    /** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
+    abstract protected K readKey(Cursor cursor, int offset);
+
+    /** Reads the values from the current position of the given cursor into an existing entity. */
+    abstract protected void readEntity(Cursor cursor, T entity, int offset);
+
+    /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
+    abstract protected void bindValues(SQLiteStatement stmt, T entity);
+
+    /**
+     * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's
+     * key regardless of whether the key existed before or not.
+     */
+    abstract protected K updateKeyAfterInsert(T entity, long rowId);
+
+    /**
+     * Returns the value of the primary key, if the entity has a single primary key, or, if not, null. Returns null if
+     * entity is null.
+     */
+    abstract protected K getKey(T entity);
+
+    /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
+    abstract protected boolean isEntityUpdateable();
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
new file mode 100644
index 00000000..40f06d12
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoMaster.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+/**
+ * The master of dao will guide you: start dao sessions with the master.
+ * 
+ * @author Markus
+ */
+public abstract class AbstractDaoMaster {
+    protected final SQLiteDatabase db;
+    protected final int schemaVersion;
+    protected final Map<Class<? extends AbstractDao<?, ?>>, DaoConfig> daoConfigMap;
+
+    public AbstractDaoMaster(SQLiteDatabase db, int schemaVersion) {
+        this.db = db;
+        this.schemaVersion = schemaVersion;
+
+        daoConfigMap = new HashMap<Class<? extends AbstractDao<?, ?>>, DaoConfig>();
+    }
+
+    protected void registerDaoClass(Class<? extends AbstractDao<?, ?>> daoClass) {
+        DaoConfig daoConfig = new DaoConfig(db, daoClass);
+        daoConfigMap.put(daoClass, daoConfig);
+    }
+
+    public int getSchemaVersion() {
+        return schemaVersion;
+    }
+
+    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
+    public SQLiteDatabase getDatabase() {
+        return db;
+    }
+
+    public abstract AbstractDaoSession newSession();
+
+    public abstract AbstractDaoSession newSession(IdentityScopeType type);
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
new file mode 100644
index 00000000..d1d61a6d
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDaoSession.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Callable;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.query.QueryBuilder;
+
+/**
+ * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br/>
+ * <br/>
+ * To access the DAOs, call the get{entity}Dao methods by the generated DaoSession sub class.<br/>
+ * <br/>
+ * DaoSession offers many of the available persistence operations on entities as a convenience. Consider using DAOs
+ * directly to access all available operations, especially if you call a lot of operations on a single entity type to
+ * avoid the overhead imposed by DaoSession (the overhead is small, but it may add up).<br/>
+ * <br/>
+ * By default, the DaoSession has a session cache (IdentityScopeType.Session). The session cache is not just a plain
+ * data cache to improve performance, but also manages object identities. For example, if you load the same entity twice
+ * in a query, you will get a single Java object instead of two when using a session cache. This is particular useful
+ * for relations pointing to a common set of entities.
+ * 
+ * This class is thread-safe.
+ * 
+ * @author Markus
+ * 
+ */
+public class AbstractDaoSession {
+    private final SQLiteDatabase db;
+    private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;
+
+    public AbstractDaoSession(SQLiteDatabase db) {
+        this.db = db;
+        this.entityToDao = new HashMap<Class<?>, AbstractDao<?, ?>>();
+    }
+
+    protected <T> void registerDao(Class<T> entityClass, AbstractDao<T, ?> dao) {
+        entityToDao.put(entityClass, dao);
+    }
+
+    /** Convenient call for {@link AbstractDao#insert(Object)}. */
+    public <T> long insert(T entity) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
+        return dao.insert(entity);
+    }
+
+    /** Convenient call for {@link AbstractDao#insertOrReplace(Object)}. */
+    public <T> long insertOrReplace(T entity) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
+        return dao.insertOrReplace(entity);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. */
+    public <T> void refresh(T entity) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
+        dao.refresh(entity);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. */
+    public <T> void update(T entity) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
+        dao.update(entity);
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. */
+    public <T> void delete(T entity) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entity.getClass());
+        dao.delete(entity);
+    }
+
+    /** Convenient call for {@link AbstractDao#deleteAll()}. */
+    public <T> void deleteAll(Class<T> entityClass) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entityClass);
+        dao.deleteAll();
+    }
+
+    /** Convenient call for {@link AbstractDao#load(Object)}. */
+    public <T, K> T load(Class<T> entityClass, K key) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
+        return dao.load(key);
+    }
+
+    /** Convenient call for {@link AbstractDao#loadAll()}. */
+    public <T, K> List<T> loadAll(Class<T> entityClass) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
+        return dao.loadAll();
+    }
+
+    /** Convenient call for {@link AbstractDao#queryRaw(String, String...)}. */
+    public <T, K> List<T> queryRaw(Class<T> entityClass, String where, String... selectionArgs) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, K> dao = (AbstractDao<T, K>) getDao(entityClass);
+        return dao.queryRaw(where, selectionArgs);
+    }
+
+    /** Convenient call for {@link AbstractDao#queryBuilder()}. */
+    public <T> QueryBuilder<T> queryBuilder(Class<T> entityClass) {
+        @SuppressWarnings("unchecked")
+        AbstractDao<T, ?> dao = (AbstractDao<T, ?>) getDao(entityClass);
+        return dao.queryBuilder();
+    }
+
+    public AbstractDao<?, ?> getDao(Class<? extends Object> entityClass) {
+        AbstractDao<?, ?> dao = entityToDao.get(entityClass);
+        if (dao == null) {
+            throw new DaoException("No DAO registered for " + entityClass);
+        }
+        return dao;
+    }
+
+    /**
+     * Run the given Runnable inside a database transaction. If you except a result, consider callInTx.
+     */
+    public void runInTx(Runnable runnable) {
+        db.beginTransaction();
+        try {
+            runnable.run();
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Calls the given Callable inside a database transaction and returns the result of the Callable. If you don't
+     * except a result, consider runInTx.
+     */
+    public <V> V callInTx(Callable<V> callable) throws Exception {
+        db.beginTransaction();
+        try {
+            V result = callable.call();
+            db.setTransactionSuccessful();
+            return result;
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Like {@link #callInTx(java.util.concurrent.Callable)} but does not require Exception handling (rethrows an Exception as a runtime
+     * DaoException).
+     */
+    public <V> V callInTxNoException(Callable<V> callable) {
+        db.beginTransaction();
+        try {
+            V result;
+            try {
+                result = callable.call();
+            } catch (Exception e) {
+                throw new DaoException("Callable failed", e);
+            }
+            db.setTransactionSuccessful();
+            return result;
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
+    public SQLiteDatabase getDatabase() {
+        return db;
+    }
+
+    /**
+     * Creates a new {@link AsyncSession} to issue asynchronous entity operations. See {@link AsyncSession} for details.
+     */
+    public AsyncSession startAsyncSession() {
+        return new AsyncSession(this);
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
new file mode 100644
index 00000000..a428d1b7
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DaoException.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao;
+
+import android.database.SQLException;
+
+/**
+ * Exception thrown when something goes wrong in the DAO/ORM layer.
+ * 
+ * @author Markus
+ * 
+ */
+public class DaoException extends SQLException {
+
+    private static final long serialVersionUID = -5877937327907457779L;
+
+    public DaoException() {
+    }
+
+    public DaoException(String error) {
+        super(error);
+    }
+
+    public DaoException(String error, Throwable cause) {
+        super(error);
+        safeInitCause(cause);
+    }
+
+    public DaoException(Throwable th) {
+        safeInitCause(th);
+    }
+
+    protected void safeInitCause(Throwable cause) {
+        try {
+            initCause(cause);
+        } catch (Throwable e) {
+            DaoLog.e("Could not set initial cause", e);
+            DaoLog.e( "Initial cause is:", cause);
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java b/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
new file mode 100644
index 00000000..e46f6e93
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DaoLog.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import android.util.Log;
+
+/**
+ * Internal greenDAO logger class. A wrapper around the Android Log class providing a static Log Tag.
+ * 
+ * @author markus
+ * 
+ */
+public class DaoLog {
+    private final static String TAG = "greenDAO";
+
+    public static final int VERBOSE = 2;
+    public static final int DEBUG = 3;
+    public static final int INFO = 4;
+    public static final int WARN = 5;
+    public static final int ERROR = 6;
+    public static final int ASSERT = 7;
+
+    public static boolean isLoggable(int level) {
+        return Log.isLoggable(TAG, level);
+    }
+
+    public static String getStackTraceString(Throwable th) {
+        return Log.getStackTraceString(th);
+    }
+
+    public static int println(int level, String msg) {
+        return Log.println(level, TAG, msg);
+    }
+
+    public static int v(String msg) {
+        return Log.v(TAG, msg);
+    }
+
+    public static int v(String msg, Throwable th) {
+        return Log.v(TAG, msg, th);
+    }
+
+    public static int d(String msg) {
+        return Log.d(TAG, msg);
+    }
+
+    public static int d(String msg, Throwable th) {
+        return Log.d(TAG, msg, th);
+    }
+
+    public static int i(String msg) {
+        return Log.i(TAG, msg);
+    }
+
+    public static int i(String msg, Throwable th) {
+        return Log.i(TAG, msg, th);
+    }
+
+    public static int w(String msg) {
+        return Log.w(TAG, msg);
+    }
+
+    public static int w(String msg, Throwable th) {
+        return Log.w(TAG, msg, th);
+    }
+
+    public static int w(Throwable th) {
+        return Log.w(TAG, th);
+    }
+
+    public static int e(String msg) {
+        return Log.w(TAG, msg);
+    }
+
+    public static int e(String msg, Throwable th) {
+        return Log.e(TAG, msg, th);
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
new file mode 100644
index 00000000..dd72001e
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/DbUtils.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/** Database utils, for example to execute SQL scripts */
+// TODO add unit tests
+public class DbUtils {
+
+    public static void vacuum(SQLiteDatabase db) {
+        db.execSQL("VACUUM");
+    }
+
+    /**
+     * Calls {@link #executeSqlScript(android.content.Context, android.database.sqlite.SQLiteDatabase, String, boolean)} with transactional set to true.
+     * 
+     * @return number of statements executed.
+     */
+    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
+        return executeSqlScript(context, db, assetFilename, true);
+    }
+
+    /**
+     * Executes the given SQL asset in the given database (SQL file should be UTF-8). The database file may contain
+     * multiple SQL statements. Statements are split using a simple regular expression (something like
+     * "semicolon before a line break"), not by analyzing the SQL syntax. This will work for many SQL files, but check
+     * yours.
+     * 
+     * @return number of statements executed.
+     */
+    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
+            throws IOException {
+        byte[] bytes = readAsset(context, assetFilename);
+        String sql = new String(bytes, "UTF-8");
+        String[] lines = sql.split(";(\\s)*[\n\r]");
+        int count;
+        if (transactional) {
+            count = executeSqlStatementsInTx(db, lines);
+        } else {
+            count = executeSqlStatements(db, lines);
+        }
+        DaoLog.i("Executed " + count + " statements from SQL script '" + assetFilename + "'");
+        return count;
+    }
+
+    public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statements) {
+        db.beginTransaction();
+        try {
+            int count = executeSqlStatements(db, statements);
+            db.setTransactionSuccessful();
+            return count;
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
+        int count = 0;
+        for (String line : statements) {
+            line = line.trim();
+            if (line.length() > 0) {
+                db.execSQL(line);
+                count++;
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Copies all available data from in to out without closing any stream.
+     * 
+     * @return number of bytes copied
+     */
+    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
+        int byteCount = 0;
+        byte[] buffer = new byte[4096];
+        while (true) {
+            int read = in.read(buffer);
+            if (read == -1) {
+                break;
+            }
+            out.write(buffer, 0, read);
+            byteCount += read;
+        }
+        return byteCount;
+    }
+
+    public static byte[] readAllBytes(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        copyAllBytes(in, out);
+        return out.toByteArray();
+    }
+
+    public static byte[] readAsset(Context context, String filename) throws IOException {
+//        String s ="";
+//        for(String str : context.getResources().getAssets().list(".")){
+//            Log.e("my test",str);
+//            s+=str+" / ";
+//        }
+//        throw new IOException(s);
+
+        InputStream in = context.getResources().getAssets().open(filename);
+        try {
+            return readAllBytes(in);
+        } finally {
+            in.close();
+        }
+    }
+
+    public static void logTableDump(SQLiteDatabase db, String tablename) {
+        Cursor cursor = db.query(tablename, null, null, null, null, null, null);
+        try {
+            String dump = DatabaseUtils.dumpCursorToString(cursor);
+            DaoLog.d(dump);
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
new file mode 100644
index 00000000..d1896079
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
@@ -0,0 +1,36 @@
+package de.greenrobot.dao;
+
+import java.util.List;
+
+import android.database.Cursor;
+import de.greenrobot.dao.internal.TableStatements;
+
+/** For internal use by greenDAO only. */
+public final class InternalQueryDaoAccess<T> {
+    private final AbstractDao<T, ?> dao;
+
+    public InternalQueryDaoAccess(AbstractDao<T, ?> abstractDao) {
+        dao = abstractDao;
+    }
+
+    public T loadCurrent(Cursor cursor, int offset, boolean lock) {
+        return dao.loadCurrent(cursor, offset, lock);
+    }
+
+    public List<T> loadAllAndCloseCursor(Cursor cursor) {
+        return dao.loadAllAndCloseCursor(cursor);
+    }
+
+    public T loadUniqueAndCloseCursor(Cursor cursor) {
+        return dao.loadUniqueAndCloseCursor(cursor);
+    }
+
+    public TableStatements getStatements() {
+        return dao.getStatements();
+    }
+
+    public static <T2> TableStatements getStatements(AbstractDao<T2, ?> dao) {
+        return dao.getStatements();
+    }
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
new file mode 100644
index 00000000..78df9030
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/InternalUnitTestDaoAccess.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import java.lang.reflect.Constructor;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.identityscope.IdentityScope;
+import de.greenrobot.dao.internal.DaoConfig;
+
+/** Reserved for internal unit tests that want to access some non-public methods. Don't use for anything else. */
+public class InternalUnitTestDaoAccess<T, K> {
+    private final AbstractDao<T, K> dao;
+
+    public InternalUnitTestDaoAccess(SQLiteDatabase db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
+            throws Exception {
+        DaoConfig daoConfig = new DaoConfig(db, daoClass);
+        daoConfig.setIdentityScope(identityScope);
+        Constructor<AbstractDao<T, K>> constructor = daoClass.getConstructor(DaoConfig.class);
+        dao = constructor.newInstance(daoConfig);
+    }
+
+    public K getKey(T entity) {
+        return dao.getKey(entity);
+    }
+
+    public Property[] getProperties() {
+        return dao.getProperties();
+    }
+
+    public boolean isEntityUpdateable() {
+        return dao.isEntityUpdateable();
+    }
+
+    public T readEntity(Cursor cursor, int offset) {
+        return dao.readEntity(cursor, offset);
+    }
+
+    public K readKey(Cursor cursor, int offset) {
+        return dao.readKey(cursor, offset);
+    }
+
+    public AbstractDao<T, K> getDao() {
+        return dao;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/MainActivity.java b/DaoCore/src/main/java/de/greenrobot/dao/MainActivity.java
new file mode 100644
index 00000000..7aa6157b
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/MainActivity.java
@@ -0,0 +1,36 @@
+package de.greenrobot.dao;
+
+import android.support.v7.app.ActionBarActivity;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
+
+
+public class MainActivity extends ActionBarActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+    }
+
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        // Inflate the menu; this adds items to the action bar if it is present.
+        getMenuInflater().inflate(R.menu.main, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle action bar item clicks here. The action bar will
+        // automatically handle clicks on the Home/Up button, so long
+        // as you specify a parent activity in AndroidManifest.xml.
+        int id = item.getItemId();
+        if (id == R.id.action_settings) {
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/Property.java b/DaoCore/src/main/java/de/greenrobot/dao/Property.java
new file mode 100644
index 00000000..77923eb7
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/Property.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao;
+
+import java.util.Collection;
+
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.query.WhereCondition;
+import de.greenrobot.dao.query.WhereCondition.PropertyCondition;
+
+/**
+ * Meta data describing a property mapped to a database column; used to create WhereCondition object used by the query builder.
+ * 
+ * @author Markus
+ */
+public class Property {
+    public final int ordinal;
+    public final Class<?> type;
+    public final String name;
+    public final boolean primaryKey;
+    public final String columnName;
+
+    public Property(int ordinal, Class<?> type, String name, boolean primaryKey, String columnName) {
+        this.ordinal = ordinal;
+        this.type = type;
+        this.name = name;
+        this.primaryKey = primaryKey;
+        this.columnName = columnName;
+    }
+
+    /** Creates an "equal ('=')" condition  for this property. */
+    public WhereCondition eq(Object value) {
+        return new PropertyCondition(this, "=?", value);
+    }
+
+    /** Creates an "not equal ('<>')" condition  for this property. */
+    public WhereCondition notEq(Object value) {
+        return new PropertyCondition(this, "<>?", value);
+    }
+
+    /** Creates an "LIKE" condition  for this property. */
+    public WhereCondition like(String value) {
+        return new PropertyCondition(this, " LIKE ?", value);
+    }
+
+    /** Creates an "BETWEEN ... AND ..." condition  for this property. */
+    public WhereCondition between(Object value1, Object value2) {
+        Object[] values = { value1, value2 };
+        return new PropertyCondition(this, " BETWEEN ? AND ?", values);
+    }
+
+    /** Creates an "IN (..., ..., ...)" condition  for this property. */
+    public WhereCondition in(Object... inValues) {
+        StringBuilder condition = new StringBuilder(" IN (");
+        SqlUtils.appendPlaceholders(condition, inValues.length).append(')');
+        return new PropertyCondition(this, condition.toString(), inValues);
+    }
+
+    /** Creates an "IN (..., ..., ...)" condition  for this property. */
+    public WhereCondition in(Collection<?> inValues) {
+        return in(inValues.toArray());
+    }
+
+    /** Creates an "NOT IN (..., ..., ...)" condition  for this property. */
+    public WhereCondition notIn(Object... notInValues) {
+        StringBuilder condition = new StringBuilder(" NOT IN (");
+        SqlUtils.appendPlaceholders(condition, notInValues.length).append(')');
+        return new PropertyCondition(this, condition.toString(), notInValues);
+    }
+
+    /** Creates an "NOT IN (..., ..., ...)" condition  for this property. */
+    public WhereCondition notIn(Collection<?> notInValues) {
+        return notIn(notInValues.toArray());
+    }
+
+    /** Creates an "greater than ('>')" condition  for this property. */
+    public WhereCondition gt(Object value) {
+        return new PropertyCondition(this, ">?", value);
+    }
+
+    /** Creates an "less than ('<')" condition  for this property. */
+    public WhereCondition lt(Object value) {
+        return new PropertyCondition(this, "<?", value);
+    }
+
+    /** Creates an "greater or equal ('>=')" condition  for this property. */
+    public WhereCondition ge(Object value) {
+        return new PropertyCondition(this, ">=?", value);
+    }
+
+    /** Creates an "less or equal ('<=')" condition  for this property. */
+    public WhereCondition le(Object value) {
+        return new PropertyCondition(this, "<=?", value);
+    }
+
+    /** Creates an "IS NULL" condition  for this property. */
+    public WhereCondition isNull() {
+        return new PropertyCondition(this, " IS NULL");
+    }
+
+    /** Creates an "IS NOT NULL" condition  for this property. */
+    public WhereCondition isNotNull() {
+        return new PropertyCondition(this, " IS NOT NULL");
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
new file mode 100644
index 00000000..48335b4a
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncDaoException.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.async;
+
+import de.greenrobot.dao.DaoException;
+
+/**
+ * Used here: {@link AsyncOperation#getResult()}.
+ * 
+ * @author Markus
+ */
+public class AsyncDaoException extends DaoException {
+
+    private static final long serialVersionUID = 5872157552005102382L;
+
+    private final AsyncOperation failedOperation;
+
+    public AsyncDaoException(AsyncOperation failedOperation, Throwable cause) {
+        super(cause);
+        this.failedOperation = failedOperation;
+    }
+
+    public AsyncOperation getFailedOperation() {
+        return failedOperation;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
new file mode 100644
index 00000000..7f1b1c02
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperation.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.async;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+
+/**
+ * An operation that will be enqueued for asynchronous execution.
+ * 
+ * @author Markus
+ * 
+ * @see AsyncSession
+ */
+// TODO Implement Future<V>
+public class AsyncOperation {
+    public static enum OperationType {
+        Insert, InsertInTxIterable, InsertInTxArray, //
+        InsertOrReplace, InsertOrReplaceInTxIterable, InsertOrReplaceInTxArray, //
+        Update, UpdateInTxIterable, UpdateInTxArray, //
+        Delete, DeleteInTxIterable, DeleteInTxArray, //
+        DeleteByKey, DeleteAll, //
+        TransactionRunnable, TransactionCallable, //
+        QueryList, QueryUnique, //
+        Load, LoadAll, //
+        Count, Refresh
+    }
+
+    public static final int FLAG_MERGE_TX = 1;
+
+    /** TODO unused, just an idea */
+    public static final int FLAG_STOP_QUEUE_ON_EXCEPTION = 1 << 1;
+
+    final OperationType type;
+    final AbstractDao<Object, Object> dao;
+    private final SQLiteDatabase database;
+    /** Entity, Iterable<Entity>, Entity[], or Runnable. */
+    final Object parameter;
+    final int flags;
+
+    volatile long timeStarted;
+    volatile long timeCompleted;
+    private volatile boolean completed;
+    volatile Throwable throwable;
+    volatile Object result;
+    volatile int mergedOperationsCount;
+
+    int sequenceNumber;
+
+    @SuppressWarnings("unchecked")
+    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, Object parameter, int flags) {
+        this.type = type;
+        this.flags = flags;
+        this.dao = (AbstractDao<Object, Object>) dao;
+        this.database = null;
+        this.parameter = parameter;
+    }
+
+    AsyncOperation(OperationType type, SQLiteDatabase database, Object parameter, int flags) {
+        this.type = type;
+        this.database = database;
+        this.flags = flags;
+        this.dao = null;
+        this.parameter = parameter;
+    }
+
+    public Throwable getThrowable() {
+        return throwable;
+    }
+
+    public void setThrowable(Throwable throwable) {
+        this.throwable = throwable;
+    }
+
+    public OperationType getType() {
+        return type;
+    }
+
+    public Object getParameter() {
+        return parameter;
+    }
+
+    /**
+     * The operation's result after it has completed. Waits until a result is available.
+     * 
+     * @return The operation's result or null if the operation type does not produce any result.
+     * @throws {@link AsyncDaoException} if the operation produced an exception
+     * @see #waitForCompletion()
+     */
+    public synchronized Object getResult() {
+        if (!completed) {
+            waitForCompletion();
+        }
+        if (throwable != null) {
+            throw new AsyncDaoException(this, throwable);
+        }
+        return result;
+    }
+
+    /** @return true if this operation may be merged with others into a single database transaction. */
+    public boolean isMergeTx() {
+        return (flags & FLAG_MERGE_TX) != 0;
+    }
+
+    SQLiteDatabase getDatabase() {
+        return database != null ? database : dao.getDatabase();
+    }
+
+    /**
+     * @return true if this operation is mergeable with the given operation. Checks for null, {@link #FLAG_MERGE_TX},
+     *         and if the database instances match.
+     */
+    boolean isMergeableWith(AsyncOperation other) {
+        return other != null && isMergeTx() && other.isMergeTx() && getDatabase() == other.getDatabase();
+    }
+
+    public long getTimeStarted() {
+        return timeStarted;
+    }
+
+    public long getTimeCompleted() {
+        return timeCompleted;
+    }
+
+    public long getDuration() {
+        if (timeCompleted == 0) {
+            throw new DaoException("This operation did not yet complete");
+        } else {
+            return timeCompleted - timeStarted;
+        }
+    }
+
+    public boolean isFailed() {
+        return throwable != null;
+    }
+
+    public boolean isCompleted() {
+        return completed;
+    }
+
+    /**
+     * Waits until the operation is complete. If the thread gets interrupted, any {@link InterruptedException} will be
+     * rethrown as a {@link DaoException}.
+     * 
+     * @return Result if any, see {@link #getResult()}
+     */
+    public synchronized Object waitForCompletion() {
+        while (!completed) {
+            try {
+                wait();
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for operation to complete", e);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Waits until the operation is complete, but at most the given amount of milliseconds.If the thread gets
+     * interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if the operation completed in the given time frame.
+     */
+    public synchronized boolean waitForCompletion(int maxMillis) {
+        if (!completed) {
+            try {
+                wait(maxMillis);
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for operation to complete", e);
+            }
+        }
+        return completed;
+    }
+
+    /** Called when the operation is done. Notifies any threads waiting for this operation's completion. */
+    synchronized void setCompleted() {
+        completed = true;
+        notifyAll();
+    }
+
+    public boolean isCompletedSucessfully() {
+        return completed && throwable == null;
+    }
+
+    /**
+     * If this operation was successfully merged with other operation into a single TX, this will give the count of
+     * merged operations. If the operation was not merged, it will be 0.
+     */
+    public int getMergedOperationsCount() {
+        return mergedOperationsCount;
+    }
+
+    /**
+     * Each operation get a unique sequence number when the operation is enqueued. Can be used for efficiently
+     * identifying/mapping operations.
+     */
+    public int getSequenceNumber() {
+        return sequenceNumber;
+    }
+
+    /** Reset to prepare another execution run. */
+    void reset() {
+        timeStarted = 0;
+        timeCompleted = 0;
+        completed = false;
+        throwable = null;
+        result = null;
+        mergedOperationsCount = 0;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
new file mode 100644
index 00000000..b63ec1b4
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.async;
+
+import java.util.ArrayList;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.Query;
+
+class AsyncOperationExecutor implements Runnable, Handler.Callback {
+
+    private static ExecutorService executorService = Executors.newCachedThreadPool();
+
+    private final BlockingQueue<AsyncOperation> queue;
+    private volatile boolean executorRunning;
+    private volatile int maxOperationCountToMerge;
+    private volatile AsyncOperationListener listener;
+    private volatile AsyncOperationListener listenerMainThread;
+    private volatile int waitForMergeMillis;
+
+    private int countOperationsEnqueued;
+    private int countOperationsCompleted;
+
+    private Handler handlerMainThread;
+    private int lastSequenceNumber;
+
+    AsyncOperationExecutor() {
+        queue = new LinkedBlockingQueue<AsyncOperation>();
+        maxOperationCountToMerge = 50;
+        waitForMergeMillis = 50;
+    }
+
+    public void enqueue(AsyncOperation operation) {
+        synchronized (this) {
+            operation.sequenceNumber = ++lastSequenceNumber;
+            queue.add(operation);
+            countOperationsEnqueued++;
+            if (!executorRunning) {
+                executorRunning = true;
+                executorService.execute(this);
+            }
+        }
+    }
+
+    public int getMaxOperationCountToMerge() {
+        return maxOperationCountToMerge;
+    }
+
+    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
+        this.maxOperationCountToMerge = maxOperationCountToMerge;
+    }
+
+    public int getWaitForMergeMillis() {
+        return waitForMergeMillis;
+    }
+
+    public void setWaitForMergeMillis(int waitForMergeMillis) {
+        this.waitForMergeMillis = waitForMergeMillis;
+    }
+
+    public AsyncOperationListener getListener() {
+        return listener;
+    }
+
+    public void setListener(AsyncOperationListener listener) {
+        this.listener = listener;
+    }
+
+    public AsyncOperationListener getListenerMainThread() {
+        return listenerMainThread;
+    }
+
+    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
+        this.listenerMainThread = listenerMainThread;
+    }
+
+    public synchronized boolean isCompleted() {
+        return countOperationsEnqueued == countOperationsCompleted;
+    }
+
+    /**
+     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
+     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     */
+    public synchronized void waitForCompletion() {
+        while (!isCompleted()) {
+            try {
+                wait();
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for all operations to complete", e);
+            }
+        }
+    }
+
+    /**
+     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
+     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if operations completed in the given time frame.
+     */
+    public synchronized boolean waitForCompletion(int maxMillis) {
+        if (!isCompleted()) {
+            try {
+                wait(maxMillis);
+            } catch (InterruptedException e) {
+                throw new DaoException("Interrupted while waiting for all operations to complete", e);
+            }
+        }
+        return isCompleted();
+    }
+
+    @Override
+    public void run() {
+        try {
+            try {
+                while (true) {
+                    AsyncOperation operation = queue.poll(1, TimeUnit.SECONDS);
+                    if (operation == null) {
+                        synchronized (this) {
+                            // Check again, this time in synchronized
+                            operation = queue.poll();
+                            if (operation == null) {
+                                executorRunning = false;
+                                return;
+                            }
+                        }
+                    }
+                    if (operation.isMergeTx()) {
+                        // Wait some ms for another operation to merge because a TX is expensive
+                        AsyncOperation operation2 = queue.poll(waitForMergeMillis, TimeUnit.MILLISECONDS);
+                        if (operation2 != null) {
+                            if (operation.isMergeableWith(operation2)) {
+                                mergeTxAndExecute(operation, operation2);
+                            } else {
+                                // Cannot merge, execute both
+                                executeOperationAndPostCompleted(operation);
+                                executeOperationAndPostCompleted(operation2);
+                            }
+                            continue;
+                        }
+                    }
+                    executeOperationAndPostCompleted(operation);
+                }
+            } catch (InterruptedException e) {
+                DaoLog.w(Thread.currentThread().getName() + " was interruppted", e);
+            }
+        } finally {
+            executorRunning = false;
+        }
+    }
+
+    private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) {
+        ArrayList<AsyncOperation> mergedOps = new ArrayList<AsyncOperation>();
+        mergedOps.add(operation1);
+        mergedOps.add(operation2);
+
+        SQLiteDatabase db = operation1.getDatabase();
+        db.beginTransaction();
+        boolean failed = false;
+        try {
+            for (int i = 0; i < mergedOps.size(); i++) {
+                AsyncOperation operation = mergedOps.get(i);
+                executeOperation(operation);
+                if (operation.isFailed()) {
+                    // Operation may still have changed the DB, roll back everything
+                    failed = true;
+                    break;
+                }
+                if (i == mergedOps.size() - 1) {
+                    AsyncOperation peekedOp = queue.peek();
+                    if (i < maxOperationCountToMerge && operation.isMergeableWith(peekedOp)) {
+                        AsyncOperation removedOp = queue.remove();
+                        if (removedOp != peekedOp) {
+                            // Paranoia check, should not occur unless threading is broken
+                            throw new DaoException("Internal error: peeked op did not match removed op");
+                        }
+                        mergedOps.add(removedOp);
+                    } else {
+                        // No more ops in the queue to merge, finish it
+                        db.setTransactionSuccessful();
+                    }
+                }
+            }
+        } finally {
+            db.endTransaction();
+        }
+        if (failed) {
+            DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.reset();
+                executeOperationAndPostCompleted(asyncOperation);
+            }
+        } else {
+            int mergedCount = mergedOps.size();
+            for (AsyncOperation asyncOperation : mergedOps) {
+                asyncOperation.mergedOperationsCount = mergedCount;
+                handleOperationCompleted(asyncOperation);
+            }
+        }
+    }
+
+    private void handleOperationCompleted(AsyncOperation operation) {
+        operation.setCompleted();
+
+        AsyncOperationListener listenerToCall = listener;
+        if (listenerToCall != null) {
+            listenerToCall.onAsyncOperationCompleted(operation);
+        }
+        if (listenerMainThread != null) {
+            if (handlerMainThread == null) {
+                handlerMainThread = new Handler(Looper.getMainLooper(), this);
+            }
+            Message msg = handlerMainThread.obtainMessage(1, operation);
+            handlerMainThread.sendMessage(msg);
+        }
+        synchronized (this) {
+            countOperationsCompleted++;
+            if (countOperationsCompleted == countOperationsEnqueued) {
+                notifyAll();
+            }
+        }
+    }
+
+    private void executeOperationAndPostCompleted(AsyncOperation operation) {
+        executeOperation(operation);
+        handleOperationCompleted(operation);
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private void executeOperation(AsyncOperation operation) {
+        operation.timeStarted = System.currentTimeMillis();
+        try {
+            switch (operation.type) {
+            case Delete:
+                operation.dao.delete(operation.parameter);
+                break;
+            case DeleteInTxIterable:
+                operation.dao.deleteInTx((Iterable<Object>) operation.parameter);
+                break;
+            case DeleteInTxArray:
+                operation.dao.deleteInTx((Object[]) operation.parameter);
+                break;
+            case Insert:
+                operation.dao.insert(operation.parameter);
+                break;
+            case InsertInTxIterable:
+                operation.dao.insertInTx((Iterable<Object>) operation.parameter);
+                break;
+            case InsertInTxArray:
+                operation.dao.insertInTx((Object[]) operation.parameter);
+                break;
+            case InsertOrReplace:
+                operation.dao.insertOrReplace(operation.parameter);
+                break;
+            case InsertOrReplaceInTxIterable:
+                operation.dao.insertOrReplaceInTx((Iterable<Object>) operation.parameter);
+                break;
+            case InsertOrReplaceInTxArray:
+                operation.dao.insertOrReplaceInTx((Object[]) operation.parameter);
+                break;
+            case Update:
+                operation.dao.update(operation.parameter);
+                break;
+            case UpdateInTxIterable:
+                operation.dao.updateInTx((Iterable<Object>) operation.parameter);
+                break;
+            case UpdateInTxArray:
+                operation.dao.updateInTx((Object[]) operation.parameter);
+                break;
+            case TransactionRunnable:
+                executeTransactionRunnable(operation);
+                break;
+            case TransactionCallable:
+                executeTransactionCallable(operation);
+                break;
+            case QueryList:
+                operation.result = ((Query) operation.parameter).list();
+                break;
+            case QueryUnique:
+                operation.result = ((Query) operation.parameter).unique();
+                break;
+            case DeleteByKey:
+                operation.dao.deleteByKey(operation.parameter);
+                break;
+            case DeleteAll:
+                operation.dao.deleteAll();
+                break;
+            case Load:
+                operation.result = operation.dao.load(operation.parameter);
+                break;
+            case LoadAll:
+                operation.result = operation.dao.loadAll();
+                break;
+            case Count:
+                operation.result = operation.dao.count();
+                break;
+            case Refresh:
+                operation.dao.refresh(operation.parameter);
+                break;
+            default:
+                throw new DaoException("Unsupported operation: " + operation.type);
+            }
+        } catch (Throwable th) {
+            operation.throwable = th;
+        }
+        operation.timeCompleted = System.currentTimeMillis();
+        // Do not set it to completed here because it might be a merged TX
+    }
+
+    private void executeTransactionRunnable(AsyncOperation operation) {
+        SQLiteDatabase db = operation.getDatabase();
+        db.beginTransaction();
+        try {
+            ((Runnable) operation.parameter).run();
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void executeTransactionCallable(AsyncOperation operation) throws Exception {
+        SQLiteDatabase db = operation.getDatabase();
+        db.beginTransaction();
+        try {
+            operation.result = ((Callable<Object>) operation.parameter).call();
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @Override
+    public boolean handleMessage(Message msg) {
+        AsyncOperationListener listenerToCall = listenerMainThread;
+        if (listenerToCall != null) {
+            listenerToCall.onAsyncOperationCompleted((AsyncOperation) msg.obj);
+        }
+        return false;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
new file mode 100644
index 00000000..6ee2cbbf
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncOperationListener.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.async;
+
+public interface AsyncOperationListener {
+    void onAsyncOperationCompleted(AsyncOperation operation);
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
new file mode 100644
index 00000000..9233e090
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/async/AsyncSession.java
@@ -0,0 +1,322 @@
+package de.greenrobot.dao.async;
+
+import java.util.concurrent.Callable;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.async.AsyncOperation.OperationType;
+import de.greenrobot.dao.query.Query;
+
+/**
+ * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
+ * immediately (fine to call on the UI/main thread). The queue will be processed in a (single) background thread. The
+ * processing order is the call order of the operations. It's possible to start multiple AsyncSessions that will execute
+ * concurrently.
+ * 
+ * @author Markus
+ * 
+ * @see AbstractDaoSession#startAsyncSession()
+ */
+// Facade to AsyncOperationExecutor: prepares operations and delegates work to AsyncOperationExecutor.
+public class AsyncSession {
+    private final AbstractDaoSession daoSession;
+    private final AsyncOperationExecutor executor;
+
+    public AsyncSession(AbstractDaoSession daoSession) {
+        this.daoSession = daoSession;
+        this.executor = new AsyncOperationExecutor();
+    }
+
+    public int getMaxOperationCountToMerge() {
+        return executor.getMaxOperationCountToMerge();
+    }
+
+    public void setMaxOperationCountToMerge(int maxOperationCountToMerge) {
+        executor.setMaxOperationCountToMerge(maxOperationCountToMerge);
+    }
+
+    public int getWaitForMergeMillis() {
+        return executor.getWaitForMergeMillis();
+    }
+
+    public void setWaitForMergeMillis(int waitForMergeMillis) {
+        executor.setWaitForMergeMillis(waitForMergeMillis);
+    }
+
+    public AsyncOperationListener getListener() {
+        return executor.getListener();
+    }
+
+    public void setListener(AsyncOperationListener listener) {
+        executor.setListener(listener);
+    }
+
+    public AsyncOperationListener getListenerMainThread() {
+        return executor.getListenerMainThread();
+    }
+
+    public void setListenerMainThread(AsyncOperationListener listenerMainThread) {
+        executor.setListenerMainThread(listenerMainThread);
+    }
+
+    public boolean isCompleted() {
+        return executor.isCompleted();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete. If the thread gets interrupted, any
+     * {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     */
+    public void waitForCompletion() {
+        executor.waitForCompletion();
+    }
+
+    /**
+     * Waits until all enqueued operations are complete, but at most the given amount of milliseconds. If the thread
+     * gets interrupted, any {@link InterruptedException} will be rethrown as a {@link DaoException}.
+     * 
+     * @return true if operations completed in the given time frame.
+     */
+    public boolean waitForCompletion(int maxMillis) {
+        return executor.waitForCompletion(maxMillis);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity) {
+        return insert(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insert(Object)}. */
+    public AsyncOperation insert(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Insert, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, E... entities) {
+        return insertInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Object...)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertInTx(Iterable)}. */
+    public <E> AsyncOperation insertInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity) {
+        return insertOrReplace(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplace(Object)}. */
+    public AsyncOperation insertOrReplace(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.InsertOrReplace, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, E... entities) {
+        return insertOrReplaceInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Object...)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities) {
+        return insertOrReplaceInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#insertOrReplaceInTx(Iterable)}. */
+    public <E> AsyncOperation insertOrReplaceInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.InsertOrReplaceInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity) {
+        return update(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#update(Object)}. */
+    public AsyncOperation update(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Update, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, E... entities) {
+        return updateInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Object...)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.UpdateInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities) {
+        return updateInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#updateInTx(Iterable)}. */
+    public <E> AsyncOperation updateInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.UpdateInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity) {
+        return delete(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#delete(Object)}. */
+    public AsyncOperation delete(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Delete, entity, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key) {
+        return deleteByKey(key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteByKey(Object)}. */
+    public AsyncOperation deleteByKey(Object key, int flags) {
+        return enqueueEntityOperation(OperationType.DeleteByKey, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, E... entities) {
+        return deleteInTx(entityClass, 0, entities);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Object...)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, int flags, E... entities) {
+        return enqueEntityOperation(OperationType.DeleteInTxArray, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities) {
+        return deleteInTx(entityClass, entities, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteInTx(Iterable)}. */
+    public <E> AsyncOperation deleteInTx(Class<E> entityClass, Iterable<E> entities, int flags) {
+        return enqueEntityOperation(OperationType.DeleteInTxIterable, entityClass, entities, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass) {
+        return deleteAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#deleteAll()}. */
+    public <E> AsyncOperation deleteAll(Class<E> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.DeleteAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable) {
+        return runInTx(runnable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#runInTx(Runnable)}. */
+    public AsyncOperation runInTx(Runnable runnable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionRunnable, runnable, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(java.util.concurrent.Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable) {
+        return callInTx(callable, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDaoSession#callInTx(java.util.concurrent.Callable)}. */
+    public AsyncOperation callInTx(Callable<?> callable, int flags) {
+        return enqueueDatabaseOperation(OperationType.TransactionCallable, callable, flags);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query) {
+        return queryList(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#list()}. */
+    public AsyncOperation queryList(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryList, query, flags);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query) {
+        return queryUnique(query, 0);
+    }
+
+    /** Asynchronous version of {@link Query#unique()}. */
+    public AsyncOperation queryUnique(Query<?> query, int flags) {
+        return enqueueDatabaseOperation(OperationType.QueryUnique, query, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key) {
+        return load(entityClass, key, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#load(Object)}. */
+    public AsyncOperation load(Class<?> entityClass, Object key, int flags) {
+        return enqueEntityOperation(OperationType.Load, entityClass, key, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass) {
+        return loadAll(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#loadAll()}. */
+    public AsyncOperation loadAll(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.LoadAll, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass) {
+        return count(entityClass, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#count()}. */
+    public AsyncOperation count(Class<?> entityClass, int flags) {
+        return enqueEntityOperation(OperationType.Count, entityClass, null, flags);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity) {
+        return refresh(entity, 0);
+    }
+
+    /** Asynchronous version of {@link AbstractDao#refresh(Object)}. */
+    public AsyncOperation refresh(Object entity, int flags) {
+        return enqueueEntityOperation(OperationType.Refresh, entity, flags);
+    }
+
+    private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
+        AsyncOperation operation = new AsyncOperation(type, daoSession.getDatabase(), param, flags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+    private AsyncOperation enqueueEntityOperation(OperationType type, Object entity, int flags) {
+        return enqueEntityOperation(type, entity.getClass(), entity, flags);
+    }
+
+    private <E> AsyncOperation enqueEntityOperation(OperationType type, Class<E> entityClass, Object param, int flags) {
+        AbstractDao<?, ?> dao = daoSession.getDao(entityClass);
+        AsyncOperation operation = new AsyncOperation(type, dao, param, flags);
+        executor.enqueue(operation);
+        return operation;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
new file mode 100644
index 00000000..173a522f
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScope.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.identityscope;
+
+/**
+ * Common interface for a identity scopes needed internally by greenDAO. Identity scopes let greenDAO re-use Java
+ * objects.
+ * 
+ * @author Markus
+ * 
+ * @param <K>
+ *            Key
+ * @param <T>
+ *            Entity
+ */
+public interface IdentityScope<K, T> {
+
+    T get(K key);
+
+    void put(K key, T entity);
+
+    T getNoLock(K key);
+
+    void putNoLock(K key, T entity);
+
+    boolean detach(K key, T entity);
+
+    void remove(K key);
+
+    void remove(Iterable<K> key);
+
+    void clear();
+
+    void lock();
+
+    void unlock();
+
+    void reserveRoom(int count);
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
new file mode 100644
index 00000000..346c95b3
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeLong.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.identityscope;
+
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.util.concurrent.locks.ReentrantLock;
+
+import de.greenrobot.dao.internal.LongHashMap;
+
+/**
+ * The context for entity identities. Provides the scope in which entities will be tracked and managed.
+ * 
+ * @author Markus
+ * @param <T>
+ *            Entity
+ */
+public class IdentityScopeLong<T> implements IdentityScope<Long, T> {
+    private final LongHashMap<Reference<T>> map;
+    private final ReentrantLock lock;
+
+    public IdentityScopeLong() {
+        map = new LongHashMap<Reference<T>>();
+        lock = new ReentrantLock();
+    }
+
+    @Override
+    public T get(Long key) {
+        return get2(key);
+    }
+
+    @Override
+    public T getNoLock(Long key) {
+        return get2NoLock(key);
+    }
+
+    public T get2(long key) {
+        lock.lock();
+        Reference<T> ref;
+        try {
+            ref = map.get(key);
+        } finally {
+            lock.unlock();
+        }
+        if (ref != null) {
+            return ref.get();
+        } else {
+            return null;
+        }
+    }
+
+    public T get2NoLock(long key) {
+        Reference<T> ref = map.get(key);
+        if (ref != null) {
+            return ref.get();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public void put(Long key, T entity) {
+        put2(key, entity);
+    }
+
+    @Override
+    public void putNoLock(Long key, T entity) {
+        put2NoLock(key, entity);
+    }
+
+    public void put2(long key, T entity) {
+        lock.lock();
+        try {
+            map.put(key, new WeakReference<T>(entity));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void put2NoLock(long key, T entity) {
+        map.put(key, new WeakReference<T>(entity));
+    }
+
+    @Override
+    public boolean detach(Long key, T entity) {
+        lock.lock();
+        try {
+            if (get(key) == entity && entity != null) {
+                remove(key);
+                return true;
+            } else {
+                return false;
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void remove(Long key) {
+        lock.lock();
+        try {
+            map.remove(key);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void remove(Iterable<Long> keys) {
+        lock.lock();
+        try {
+            for (Long key : keys) {
+                map.remove(key);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void clear() {
+        lock.lock();
+        try {
+            map.clear();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void lock() {
+        lock.lock();
+    }
+
+    @Override
+    public void unlock() {
+        lock.unlock();
+    }
+
+    @Override
+    public void reserveRoom(int count) {
+        map.reserveRoom(count);
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
new file mode 100644
index 00000000..92ff52d2
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeObject.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.identityscope;
+
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * The context for entity identities. Provides the scope in which entities will be tracked and managed.
+ * 
+ * @author Markus
+ * @param <K>
+ * @param <T>
+ */
+public class IdentityScopeObject<K, T> implements IdentityScope<K, T> {
+    private final HashMap<K, Reference<T>> map;
+    private final ReentrantLock lock;
+
+    public IdentityScopeObject() {
+        map = new HashMap<K, Reference<T>>();
+        lock = new ReentrantLock();
+    }
+
+    @Override
+    public T get(K key) {
+        Reference<T> ref;
+        lock.lock();
+        try {
+            ref = map.get(key);
+        } finally {
+            lock.unlock();
+        }
+        if (ref != null) {
+            return ref.get();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public T getNoLock(K key) {
+        Reference<T> ref = map.get(key);
+        if (ref != null) {
+            return ref.get();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public void put(K key, T entity) {
+        lock.lock();
+        try {
+            map.put(key, new WeakReference<T>(entity));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void putNoLock(K key, T entity) {
+        map.put(key, new WeakReference<T>(entity));
+    }
+
+    @Override
+    public boolean detach(K key, T entity) {
+        lock.lock();
+        try {
+            if (get(key) == entity && entity != null) {
+                remove(key);
+                return true;
+            } else {
+                return false;
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void remove(K key) {
+        lock.lock();
+        try {
+            map.remove(key);
+        } finally {
+            lock.unlock();
+        }
+    }
+    
+    @Override
+    public void remove(Iterable< K> keys) {
+        lock.lock();
+        try {
+            for (K key : keys) {
+                map.remove(key);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void clear() {
+        lock.lock();
+        try {
+            map.clear();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public void lock() {
+        lock.lock();
+    }
+
+    @Override
+    public void unlock() {
+        lock.unlock();
+    }
+
+    @Override
+    public void reserveRoom(int count) {
+        // HashMap does not allow
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
new file mode 100644
index 00000000..985124d4
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/identityscope/IdentityScopeType.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.identityscope;
+
+public enum IdentityScopeType {
+    Session, None
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
new file mode 100644
index 00000000..96473029
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/DaoConfig.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.internal;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.identityscope.IdentityScope;
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.dao.identityscope.IdentityScopeObject;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+/**
+ * Internal class used by greenDAO. DaoConfig stores essential data for DAOs, and is hold by AbstractDaoMaster. This
+ * class will retrieve the required information from the DAO classes.
+ */
+public final class DaoConfig implements Cloneable {
+
+    public final SQLiteDatabase db;
+    public final String tablename;
+    public final Property[] properties;
+
+    public final String[] allColumns;
+    public final String[] pkColumns;
+    public final String[] nonPkColumns;
+
+    /** Single property PK or null if there's no PK or a multi property PK. */
+    public final Property pkProperty;
+    public final boolean keyIsNumeric;
+    public final TableStatements statements;
+
+    private IdentityScope<?, ?> identityScope;
+
+    public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass) {
+        this.db = db;
+        try {
+            this.tablename = (String) daoClass.getField("TABLENAME").get(null);
+            Property[] properties = reflectProperties(daoClass);
+            this.properties = properties;
+
+            allColumns = new String[properties.length];
+
+            List<String> pkColumnList = new ArrayList<String>();
+            List<String> nonPkColumnList = new ArrayList<String>();
+            Property lastPkProperty = null;
+            for (int i = 0; i < properties.length; i++) {
+                Property property = properties[i];
+                String name = property.columnName;
+                allColumns[i] = name;
+                if (property.primaryKey) {
+                    pkColumnList.add(name);
+                    lastPkProperty = property;
+                } else {
+                    nonPkColumnList.add(name);
+                }
+            }
+            String[] nonPkColumnsArray = new String[nonPkColumnList.size()];
+            nonPkColumns = nonPkColumnList.toArray(nonPkColumnsArray);
+            String[] pkColumnsArray = new String[pkColumnList.size()];
+            pkColumns = pkColumnList.toArray(pkColumnsArray);
+
+            pkProperty = pkColumns.length == 1 ? lastPkProperty : null;
+            statements = new TableStatements(db, tablename, allColumns, pkColumns);
+
+            if (pkProperty != null) {
+                Class<?> type = pkProperty.type;
+                keyIsNumeric = type.equals(long.class) || type.equals(Long.class) || type.equals(int.class)
+                        || type.equals(Integer.class) || type.equals(short.class) || type.equals(Short.class)
+                        || type.equals(byte.class) || type.equals(Byte.class);
+            } else {
+                keyIsNumeric = false;
+            }
+
+        } catch (Exception e) {
+            throw new DaoException("Could not init DAOConfig", e);
+        }
+    }
+
+    private static Property[] reflectProperties(Class<? extends AbstractDao<?, ?>> daoClass)
+            throws ClassNotFoundException, IllegalArgumentException, IllegalAccessException {
+        Class<?> propertiesClass = Class.forName(daoClass.getName() + "$Properties");
+        Field[] fields = propertiesClass.getDeclaredFields();
+
+        ArrayList<Property> propertyList = new ArrayList<Property>();
+        final int modifierMask = Modifier.STATIC | Modifier.PUBLIC;
+        for (Field field : fields) {
+            // There might be other fields introduced by some tools, just ignore them (see issue #28)
+            if ((field.getModifiers() & modifierMask) == modifierMask) {
+                Object fieldValue = field.get(null);
+                if (fieldValue instanceof Property) {
+                    propertyList.add((Property) fieldValue);
+                }
+            }
+        }
+
+        Property[] properties = new Property[propertyList.size()];
+        for (Property property : propertyList) {
+            if (properties[property.ordinal] != null) {
+                throw new DaoException("Duplicate property ordinals");
+            }
+            properties[property.ordinal] = property;
+        }
+        return properties;
+    }
+
+    /** Does not copy identity scope. */
+    public DaoConfig(DaoConfig source) {
+        db = source.db;
+        tablename = source.tablename;
+        properties = source.properties;
+        allColumns = source.allColumns;
+        pkColumns = source.pkColumns;
+        nonPkColumns = source.nonPkColumns;
+        pkProperty = source.pkProperty;
+        statements = source.statements;
+        keyIsNumeric = source.keyIsNumeric;
+    }
+
+    /** Does not copy identity scope. */
+    @Override
+    public DaoConfig clone() {
+        return new DaoConfig(this);
+    }
+
+    public IdentityScope<?, ?> getIdentityScope() {
+        return identityScope;
+    }
+
+    public void setIdentityScope(IdentityScope<?, ?> identityScope) {
+        this.identityScope = identityScope;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public void initIdentityScope(IdentityScopeType type) {
+        if (type == IdentityScopeType.None) {
+            identityScope = null;
+        } else if (type == IdentityScopeType.Session) {
+            if (keyIsNumeric) {
+                identityScope = new IdentityScopeLong();
+            } else {
+                identityScope = new IdentityScopeObject();
+            }
+        } else {
+            throw new IllegalArgumentException("Unsupported type: " + type);
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
new file mode 100644
index 00000000..d43e97f6
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/FastCursor.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.internal;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.CursorWindow;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+
+/** Internal class used by greenDAO. */
+final public class FastCursor implements Cursor {
+
+    private final CursorWindow window;
+    private int position;
+    private final int count;
+
+    public FastCursor(CursorWindow window) {
+        this.window = window;
+        count = window.getNumRows();
+    }
+
+    @Override
+    public int getCount() {
+        return window.getNumRows();
+    }
+
+    @Override
+    public int getPosition() {
+        return position;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        return moveToPosition(position + offset);
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (position >= 0 && position < count) {
+            this.position = position;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        position = 0;
+        return count > 0;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (count > 0) {
+            position = count - 1;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (position < count - 1) {
+            position++;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (position > 0) {
+            position--;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isFirst() {
+        return position == 0;
+    }
+
+    @Override
+    public boolean isLast() {
+        return position == count - 1;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isAfterLast() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String[] getColumnNames() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getColumnCount() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+        return window.getBlob(position, columnIndex);
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+        return window.getString(position, columnIndex);
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+        return window.getShort(position, columnIndex);
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        return window.getInt(position, columnIndex);
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+        return window.getLong(position, columnIndex);
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+        return window.getFloat(position, columnIndex);
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+        return window.getDouble(position, columnIndex);
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+        return window.isNull(position, columnIndex);
+    }
+
+    @Override
+    public void deactivate() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean requery() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void close() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isClosed() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Bundle getExtras() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+        throw new UnsupportedOperationException();
+    }
+
+    /** Since API level 11 */
+    public int getType(int columnIndex) {
+        throw new UnsupportedOperationException();
+    }
+
+    /** Since API level 19 */
+    public Uri getNotificationUri() {
+        return null;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
new file mode 100644
index 00000000..a5394f48
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/LongHashMap.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.internal;
+
+import java.util.Arrays;
+
+import de.greenrobot.dao.DaoLog;
+
+/**
+ * An minimalistic hash map optimized for long keys.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            The class to store.
+ */
+public final class LongHashMap<T> {
+    final static class Entry<T> {
+        final long key;
+        T value;
+        Entry<T> next;
+
+        Entry(long key, T value, Entry<T> next) {
+            this.key = key;
+            this.value = value;
+            this.next = next;
+        }
+    }
+
+    private Entry<T>[] table;
+    private int capacity;
+    private int threshold;
+    private int size;
+
+    public LongHashMap() {
+        this(16);
+    }
+
+    @SuppressWarnings("unchecked")
+    public LongHashMap(int capacity) {
+        this.capacity = capacity;
+        this.threshold = capacity * 4 / 3;
+        this.table = new Entry[capacity];
+    }
+
+    public boolean containsKey(long key) {
+        final int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;
+
+        for (Entry<T> entry = table[index]; entry != null; entry = entry.next) {
+            if (entry.key == key) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public T get(long key) {
+        final int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;
+        for (Entry<T> entry = table[index]; entry != null; entry = entry.next) {
+            if (entry.key == key) {
+                return entry.value;
+            }
+        }
+        return null;
+    }
+
+    public T put(long key, T value) {
+        final int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;
+        final Entry<T> entryOriginal = table[index];
+        for (Entry<T> entry = entryOriginal; entry != null; entry = entry.next) {
+            if (entry.key == key) {
+                T oldValue = entry.value;
+                entry.value = value;
+                return oldValue;
+            }
+        }
+        table[index] = new Entry<T>(key, value, entryOriginal);
+        size++;
+        if (size > threshold) {
+            setCapacity(2 * capacity);
+        }
+        return null;
+    }
+
+    public T remove(long key) {
+        int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % capacity;
+        Entry<T> previous = null;
+        Entry<T> entry = table[index];
+        while (entry != null) {
+            Entry<T> next = entry.next;
+            if (entry.key == key) {
+                if (previous == null) {
+                    table[index] = next;
+                } else {
+                    previous.next = next;
+                }
+                size--;
+                return entry.value;
+            }
+            previous = entry;
+            entry = next;
+        }
+        return null;
+    }
+
+    public void clear() {
+        size = 0;
+        Arrays.fill(table, null);
+    }
+
+    public int size() {
+        return size;
+    }
+
+    public void setCapacity(int newCapacity) {
+        @SuppressWarnings("unchecked")
+        Entry<T>[] newTable = new Entry[newCapacity];
+        int length = table.length;
+        for (int i = 0; i < length; i++) {
+            Entry<T> entry = table[i];
+            while (entry != null) {
+                long key = entry.key;
+                int index = ((((int) (key >>> 32)) ^ ((int) (key))) & 0x7fffffff) % newCapacity;
+
+                Entry<T> originalNext = entry.next;
+                entry.next = newTable[index];
+                newTable[index] = entry;
+                entry = originalNext;
+            }
+        }
+        table = newTable;
+        capacity = newCapacity;
+        threshold = newCapacity * 4 / 3;
+    }
+
+    /** Target load: 0,6 */
+    public void reserveRoom(int entryCount) {
+        setCapacity(entryCount * 5 / 3);
+    }
+
+    public void logStats() {
+        int collisions = 0;
+        for (Entry<T> entry : table) {
+            while (entry != null && entry.next != null) {
+                collisions++;
+                entry = entry.next;
+            }
+        }
+        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
+                + collisions + ", collision ratio: " + ((float) collisions) / size);
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
new file mode 100644
index 00000000..fe1fd406
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.internal;
+
+import de.greenrobot.dao.DaoException;
+
+/** Helper class to create SQL statements as used by greenDAO internally. */
+public class SqlUtils {
+
+    public static StringBuilder appendColumn(StringBuilder builder, String column) {
+        builder.append('\'').append(column).append('\'');
+        return builder;
+    }
+
+    public static StringBuilder appendColumn(StringBuilder builder, String tableAlias, String column) {
+        builder.append(tableAlias).append(".'").append(column).append('\'');
+        return builder;
+    }
+
+    public static StringBuilder appendColumns(StringBuilder builder, String tableAlias, String[] columns) {
+        int length = columns.length;
+        for (int i = 0; i < length; i++) {
+            appendColumn(builder, tableAlias, columns[i]);
+            if (i < length - 1) {
+                builder.append(',');
+            }
+        }
+        return builder;
+    }
+
+    public static StringBuilder appendColumns(StringBuilder builder, String[] columns) {
+        int length = columns.length;
+        for (int i = 0; i < length; i++) {
+            builder.append('\'').append(columns[i]).append('\'');
+            if (i < length - 1) {
+                builder.append(',');
+            }
+        }
+        return builder;
+    }
+
+    public static StringBuilder appendPlaceholders(StringBuilder builder, int count) {
+        for (int i = 0; i < count; i++) {
+            if (i < count - 1) {
+                builder.append("?,");
+            } else {
+                builder.append('?');
+            }
+        }
+        return builder;
+    }
+
+    public static StringBuilder appendColumnsEqualPlaceholders(StringBuilder builder, String[] columns) {
+        for (int i = 0; i < columns.length; i++) {
+            appendColumn(builder, columns[i]).append("=?");
+            if (i < columns.length - 1) {
+                builder.append(',');
+            }
+        }
+        return builder;
+    }
+
+    public static StringBuilder appendColumnsEqValue(StringBuilder builder, String tableAlias, String[] columns) {
+        for (int i = 0; i < columns.length; i++) {
+            appendColumn(builder, tableAlias, columns[i]).append("=?");
+            if (i < columns.length - 1) {
+                builder.append(',');
+            }
+        }
+        return builder;
+    }
+
+    public static String createSqlInsert(String insertInto, String tablename, String[] columns) {
+        StringBuilder builder = new StringBuilder(insertInto);
+        builder.append(tablename).append(" (");
+        appendColumns(builder, columns);
+        builder.append(") VALUES (");
+        appendPlaceholders(builder, columns.length);
+        builder.append(')');
+        return builder.toString();
+    }
+
+    /** Creates an select for given columns with a trailing space */
+    public static String createSqlSelect(String tablename, String tableAlias, String[] columns) {
+        StringBuilder builder = new StringBuilder("SELECT ");
+        if (tableAlias == null || tableAlias.length() < 0) {
+            throw new DaoException("Table alias required");
+        }
+
+        SqlUtils.appendColumns(builder, tableAlias, columns).append(" FROM ");
+        builder.append(tablename).append(' ').append(tableAlias).append(' ');
+        return builder.toString();
+    }
+
+    /** Creates SELECT COUNT(*) with a trailing space. */
+    public static String createSqlSelectCountStar(String tablename, String tableAliasOrNull) {
+        StringBuilder builder = new StringBuilder("SELECT COUNT(*) FROM ");
+        builder.append(tablename).append(' ');
+        if(tableAliasOrNull != null) {
+            builder.append(tableAliasOrNull).append(' ');
+        }
+        return builder.toString();
+    }
+
+    /** Remember: SQLite does not support joins nor table alias for DELETE. */
+    public static String createSqlDelete(String tablename, String[] columns) {
+        StringBuilder builder = new StringBuilder("DELETE FROM ");
+        builder.append(tablename);
+        if (columns != null && columns.length > 0) {
+            builder.append(" WHERE ");
+            appendColumnsEqValue(builder, tablename, columns);
+        }
+        return builder.toString();
+    }
+
+    public static String createSqlUpdate(String tablename, String[] updateColumns, String[] whereColumns) {
+        StringBuilder builder = new StringBuilder("UPDATE ");
+        builder.append(tablename).append(" SET ");
+        appendColumnsEqualPlaceholders(builder, updateColumns);
+        builder.append(" WHERE ");
+        appendColumnsEqValue(builder, tablename, whereColumns);
+        return builder.toString();
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
new file mode 100644
index 00000000..9414f1f7
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.internal;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+/** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
+public class TableStatements {
+    private final SQLiteDatabase db;
+    private final String tablename;
+    private final String[] allColumns;
+    private final String[] pkColumns;
+
+    private SQLiteStatement insertStatement;
+    private SQLiteStatement insertOrReplaceStatement;
+    private SQLiteStatement updateStatement;
+    private SQLiteStatement deleteStatement;
+
+    private volatile String selectAll;
+    private volatile String selectByKey;
+    private volatile String selectByRowId;
+    private volatile String selectKeys;
+
+    public TableStatements(SQLiteDatabase db, String tablename, String[] allColumns, String[] pkColumns) {
+        this.db = db;
+        this.tablename = tablename;
+        this.allColumns = allColumns;
+        this.pkColumns = pkColumns;
+    }
+
+    public SQLiteStatement getInsertStatement() {
+        if (insertStatement == null) {
+            String sql = SqlUtils.createSqlInsert("INSERT INTO ", tablename, allColumns);
+            insertStatement = db.compileStatement(sql);
+        }
+        return insertStatement;
+    }
+
+    public SQLiteStatement getInsertOrReplaceStatement() {
+        if (insertOrReplaceStatement == null) {
+            String sql = SqlUtils.createSqlInsert("INSERT OR REPLACE INTO ", tablename, allColumns);
+            insertOrReplaceStatement = db.compileStatement(sql);
+        }
+        return insertOrReplaceStatement;
+    }
+
+    public SQLiteStatement getDeleteStatement() {
+        if (deleteStatement == null) {
+            String sql = SqlUtils.createSqlDelete(tablename, pkColumns);
+            deleteStatement = db.compileStatement(sql);
+        }
+        return deleteStatement;
+    }
+
+    public SQLiteStatement getUpdateStatement() {
+        if (updateStatement == null) {
+            String sql = SqlUtils.createSqlUpdate(tablename, allColumns, pkColumns);
+            updateStatement = db.compileStatement(sql);
+        }
+        return updateStatement;
+    }
+
+    /** ends with an space to simplify appending to this string. */
+    public String getSelectAll() {
+        if (selectAll == null) {
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns);
+        }
+        return selectAll;
+    }
+
+    /** ends with an space to simplify appending to this string. */
+    public String getSelectKeys() {
+        if (selectKeys == null) {
+            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns);
+        }
+        return selectKeys;
+    }
+
+    // TODO precompile
+    public String getSelectByKey() {
+        if (selectByKey == null) {
+            StringBuilder builder = new StringBuilder(getSelectAll());
+            builder.append("WHERE ");
+            SqlUtils.appendColumnsEqValue(builder, "T", pkColumns);
+            selectByKey = builder.toString();
+        }
+        return selectByKey;
+    }
+
+    public String getSelectByRowId() {
+        if (selectByRowId == null) {
+            selectByRowId = getSelectAll() + "WHERE ROWID=?";
+        }
+        return selectByRowId;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
new file mode 100644
index 00000000..2569011f
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQuery.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.InternalQueryDaoAccess;
+
+/**
+ * A repeatable query returning entities.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            The enitity class the query will return results for.
+ */
+// TODO support long, double, blob types directly
+abstract class AbstractQuery<T> {
+    protected final AbstractDao<T, ?> dao;
+    protected final InternalQueryDaoAccess<T> daoAccess;
+    protected final String sql;
+    protected final String[] parameters;
+    protected final Thread ownerThread;
+
+    protected static String[] toStringArray(Object[] values) {
+        int length = values.length;
+        String[] strings = new String[length];
+        for (int i = 0; i < length; i++) {
+            Object object = values[i];
+            if (object != null) {
+                strings[i] = object.toString();
+            } else {
+                strings[i] = null;
+            }
+        }
+        return strings;
+    }
+
+    protected AbstractQuery(AbstractDao<T, ?> dao, String sql, String[] parameters) {
+        this.dao = dao;
+        this.daoAccess = new InternalQueryDaoAccess<T>(dao);
+        this.sql = sql;
+        this.parameters = parameters;
+        ownerThread = Thread.currentThread();
+    }
+
+    // public void compile() {
+    // // TODO implement compile
+    // }
+
+    /**
+     * Sets the parameter (0 based) using the position in which it was added during building the query.
+     */
+    public void setParameter(int index, Object parameter) {
+        checkThread();
+        if (parameter != null) {
+            parameters[index] = parameter.toString();
+        } else {
+            parameters[index] = null;
+        }
+    }
+
+    protected void checkThread() {
+        if (Thread.currentThread() != ownerThread) {
+            throw new DaoException(
+                    "Method may be called only in owner thread, use forCurrentThread to get an instance for this thread");
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
new file mode 100644
index 00000000..7a4736ec
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/AbstractQueryData.java
@@ -0,0 +1,60 @@
+package de.greenrobot.dao.query;
+
+import java.lang.ref.WeakReference;
+
+import android.os.Process;
+import android.util.SparseArray;
+import de.greenrobot.dao.AbstractDao;
+
+abstract class AbstractQueryData<T, Q extends AbstractQuery<T>> {
+    final String sql;
+    final AbstractDao<T, ?> dao;
+    final String[] initialValues;
+    final SparseArray<WeakReference<Q>> queriesForThreads;
+
+    AbstractQueryData(AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+        this.dao = dao;
+        this.sql = sql;
+        this.initialValues = initialValues;
+        queriesForThreads = new SparseArray<WeakReference<Q>>();
+    }
+
+    /** Just an optimized version, which performs faster if the current thread is already the query's owner thread. */
+    Q forCurrentThread(Q query) {
+        if (Thread.currentThread() == query.ownerThread) {
+            System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
+            return query;
+        } else {
+            return forCurrentThread();
+        }
+    }
+
+    Q forCurrentThread() {
+        int threadId = Process.myTid();
+        synchronized (queriesForThreads) {
+            WeakReference<Q> queryRef = queriesForThreads.get(threadId);
+            Q query = queryRef != null ? queryRef.get() : null;
+            if (query == null) {
+                gc();
+                query = createQuery();
+                queriesForThreads.put(threadId, new WeakReference<Q>(query));
+            } else {
+                System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
+            }
+            return query;
+        }
+    }
+
+    abstract protected Q createQuery();
+
+    void gc() {
+        synchronized (queriesForThreads) {
+            for (int i = queriesForThreads.size() - 1; i >= 0; i--) {
+                if (queriesForThreads.valueAt(i).get() == null) {
+                    queriesForThreads.remove(queriesForThreads.keyAt(i));
+                }
+            }
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
new file mode 100644
index 00000000..d135004a
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/CloseableListIterator.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.io.Closeable;
+import java.util.ListIterator;
+
+/**
+ * A list iterator that needs to be closed (or the associated list) to free underlying resources like a database cursor.
+ * Typically used with LazyList.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ */
+public interface CloseableListIterator<T> extends ListIterator<T>, Closeable {
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
new file mode 100644
index 00000000..effc537b
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/CountQuery.java
@@ -0,0 +1,55 @@
+package de.greenrobot.dao.query;
+
+import android.database.Cursor;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+
+public class CountQuery<T> extends AbstractQuery<T> {
+
+    private final static class QueryData<T2> extends AbstractQueryData<T2, CountQuery<T2>> {
+
+        private QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
+            super(dao, sql, initialValues);
+        }
+
+        @Override
+        protected CountQuery<T2> createQuery() {
+            return new CountQuery<T2>(this, dao, sql, initialValues.clone());
+        }
+    }
+
+    static <T2> CountQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues));
+        return queryData.forCurrentThread();
+    }
+
+    private final QueryData<T> queryData;
+
+    private CountQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+        super(dao, sql, initialValues);
+        this.queryData = queryData;
+    }
+
+    public CountQuery<T> forCurrentThread() {
+        return queryData.forCurrentThread(this);
+    }
+
+    /** Returns the count (number of results matching the query). Uses SELECT COUNT (*) sematics. */
+    public long count() {
+        checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        try {
+            if (!cursor.moveToNext()) {
+                throw new DaoException("No result for count");
+            } else if (!cursor.isLast()) {
+                throw new DaoException("Unexpected row count: " + cursor.getCount());
+            } else if (cursor.getColumnCount() != 1) {
+                throw new DaoException("Unexpected column count: " + cursor.getColumnCount());
+            }
+            return cursor.getLong(0);
+        } finally {
+            cursor.close();
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
new file mode 100644
index 00000000..983e3720
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/DeleteQuery.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * A repeatable query for deleting entities.<br/>
+ * New API note: this is more likely to change.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            The enitity class the query will delete from.
+ */
+public class DeleteQuery<T> extends AbstractQuery<T> {
+    private final static class QueryData<T2> extends AbstractQueryData<T2, DeleteQuery<T2>> {
+
+        private QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues) {
+            super(dao, sql, initialValues);
+        }
+
+        @Override
+        protected DeleteQuery<T2> createQuery() {
+            return new DeleteQuery<T2>(this, dao, sql, initialValues.clone());
+        }
+    }
+
+    static <T2> DeleteQuery<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues));
+        return queryData.forCurrentThread();
+    }
+
+    private final QueryData<T> queryData;
+
+    private DeleteQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues) {
+        super(dao, sql, initialValues);
+        this.queryData = queryData;
+    }
+
+    public DeleteQuery<T> forCurrentThread() {
+        return queryData.forCurrentThread(this);
+    }
+
+    /**
+     * Deletes all matching entities without detaching them from the identity scope (aka session/cache). Note that this
+     * method may lead to stale entity objects in the session cache. Stale entities may be returned when loaded by their
+     * primary key, but not using queries.
+     */
+    public void executeDeleteWithoutDetachingEntities() {
+        checkThread();
+        SQLiteDatabase db = dao.getDatabase();
+        if (db.isDbLockedByCurrentThread()) {
+            dao.getDatabase().execSQL(sql, parameters);
+        } else {
+            // Do TX to acquire a connection before locking this to avoid deadlocks
+            // Locking order as described in AbstractDao
+            db.beginTransaction();
+            try {
+                dao.getDatabase().execSQL(sql, parameters);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        }
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
new file mode 100644
index 00000000..9bf12337
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/LazyList.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.io.Closeable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.concurrent.locks.ReentrantLock;
+
+import android.database.Cursor;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.InternalQueryDaoAccess;
+
+/**
+ * A thread-safe, unmodifiable list that reads entities once they are accessed from an underlying database cursor. Make
+ * sure to close the list once you are done with it. The lazy list can be cached or not. Cached lazy lists store the
+ * entities in memory to avoid loading entities more than once. Some features of the list are limited to cached lists
+ * (e.g. features that require the entire list). Cached lists close the cursor automatically once you queried all
+ * entities. However, to avoid leaked cursors, you should not rely on this behavior: if an exception occurs before the
+ * entire list is read, you should close the lazy list (and thus the underlying cursor) on your own to be on the safe
+ * side.
+ * 
+ * @author Markus
+ * 
+ * @param <E>
+ *            Entity type.
+ */
+public class LazyList<E> implements List<E>, Closeable {
+    protected class LazyIterator implements CloseableListIterator<E> {
+        private int index;
+        private final boolean closeWhenDone;
+
+        public LazyIterator(int startLocation, boolean closeWhenDone) {
+            index = startLocation;
+            this.closeWhenDone = closeWhenDone;
+        }
+
+        @Override
+        public void add(E object) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        /** FIXME: before hasPrevious(), next() must be called. */
+        public boolean hasPrevious() {
+            return index > 0;
+        }
+
+        @Override
+        public int nextIndex() {
+            return index;
+        }
+
+        @Override
+        /** FIXME: before previous(), next() must be called. */
+        public E previous() {
+            if (index <= 0) {
+                throw new NoSuchElementException();
+            }
+            index--;
+            E entity = get(index);
+            // if (index == size && closeWhenDone) {
+            // close();
+            // }
+            return entity;
+        }
+
+        @Override
+        public int previousIndex() {
+            return index - 1;
+        }
+
+        @Override
+        public void set(E object) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return index < size;
+        }
+
+        @Override
+        public E next() {
+            if (index >= size) {
+                throw new NoSuchElementException();
+            }
+            E entity = get(index);
+            index++;
+            if (index == size && closeWhenDone) {
+                close();
+            }
+            return entity;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void close() {
+            LazyList.this.close();
+        }
+
+    }
+
+    private final InternalQueryDaoAccess<E> daoAccess;
+    private final Cursor cursor;
+    private final List<E> entities;
+    private final int size;
+    private final ReentrantLock lock;
+    private volatile int loadedCount;
+
+    LazyList(InternalQueryDaoAccess<E> daoAccess, Cursor cursor, boolean cacheEntities) {
+        this.cursor = cursor;
+        this.daoAccess = daoAccess;
+        size = cursor.getCount();
+        if (cacheEntities) {
+            entities = new ArrayList<E>(size);
+            for (int i = 0; i < size; i++) {
+                entities.add(null);
+            }
+        } else {
+            entities = null;
+        }
+        if (size == 0) {
+            cursor.close();
+        }
+
+        lock = new ReentrantLock();
+    }
+
+    /** Loads the remaining entities (if any) that were not loaded before. Applies to cached lazy lists only. */
+    public void loadRemaining() {
+        checkCached();
+        int size = entities.size();
+        for (int i = 0; i < size; i++) {
+            get(i);
+        }
+    }
+
+    protected void checkCached() {
+        if (entities == null) {
+            throw new DaoException("This operation only works with cached lazy lists");
+        }
+    }
+
+    /** Like get but does not load the entity if it was not loaded before. */
+    public E peak(int location) {
+        if (entities != null) {
+            return entities.get(location);
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    /** Closes the underlying cursor: do not try to get entities not loaded (using get) before. */
+    public void close() {
+        cursor.close();
+    }
+
+    public boolean isClosed() {
+        return cursor.isClosed();
+    }
+
+    public int getLoadedCount() {
+        return loadedCount;
+    }
+
+    public boolean isLoadedCompletely() {
+        return loadedCount == size;
+    }
+
+    @Override
+    public boolean add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void add(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> arg0) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(int arg0, Collection<? extends E> arg1) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        loadRemaining();
+        return entities.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> collection) {
+        loadRemaining();
+        return entities.containsAll(collection);
+    }
+
+    @Override
+    public E get(int location) {
+        if (entities != null) {
+            E entity = entities.get(location);
+            if (entity == null) {
+                lock.lock();
+                try {
+                    entity = entities.get(location);
+                    if (entity == null) {
+                        entity = loadEntity(location);
+                        entities.set(location, entity);
+                        // Ignore FindBugs: increment of volatile is fine here because we use a lock
+                        loadedCount++;
+                        if (loadedCount == size) {
+                            cursor.close();
+                        }
+                    }
+                } finally {
+                    lock.unlock();
+                }
+            }
+            return entity;
+        } else {
+            return loadEntity(location);
+        }
+    }
+
+    protected E loadEntity(int location) {
+        cursor.moveToPosition(location);
+        E entity = daoAccess.loadCurrent(cursor, 0, true);
+        if (entity == null) {
+            throw new DaoException("Loading of entity failed (null) at position " + location);
+        }
+        return entity;
+    }
+
+    @Override
+    public int indexOf(Object object) {
+        loadRemaining();
+        return entities.indexOf(object);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return size == 0;
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new LazyIterator(0, false);
+    }
+
+    @Override
+    public int lastIndexOf(Object object) {
+        loadRemaining();
+        return entities.lastIndexOf(object);
+    }
+
+    @Override
+    public CloseableListIterator<E> listIterator() {
+        return new LazyIterator(0, false);
+    }
+
+    /** Closes this list's cursor once the iterator is fully iterated through. */
+    public CloseableListIterator<E> listIteratorAutoClose() {
+        return new LazyIterator(0, true);
+    }
+
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        return new LazyIterator(location, false);
+    }
+
+    @Override
+    public E remove(int location) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> arg0) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> arg0) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public E set(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public List<E> subList(int start, int end) {
+        checkCached();
+        for (int i = start; i < end; i++) {
+            entities.get(i);
+        }
+        return entities.subList(start, end);
+    }
+
+    @Override
+    public Object[] toArray() {
+        loadRemaining();
+        return entities.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] array) {
+        loadRemaining();
+        return entities.toArray(array);
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
new file mode 100644
index 00000000..4d36b1b0
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Query.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.util.List;
+
+import android.database.Cursor;
+import android.os.Process;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+
+/**
+ * A repeatable query returning entities.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            The enitity class the query will return results for.
+ */
+// TODO support long, double and other types, not just Strings, for parameters
+// TODO Make parameters setable by Property (if unique in paramaters)
+// TODO Query for PKs/ROW IDs
+// TODO Make query compilable
+public class Query<T> extends AbstractQuery<T> {
+    private final static class QueryData<T2> extends AbstractQueryData<T2, Query<T2>> {
+        private final int limitPosition;
+        private final int offsetPosition;
+
+        QueryData(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition, int offsetPosition) {
+            super(dao,sql,initialValues);
+            this.limitPosition = limitPosition;
+            this.offsetPosition = offsetPosition;
+        }
+
+        @Override
+        protected Query<T2> createQuery() {
+            return new Query<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
+        }
+
+    }
+
+    /** For internal use by greenDAO only. */
+    public static <T2> Query<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
+        return create(dao, sql, initialValues, -1, -1);
+    }
+
+    static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
+            int offsetPosition) {
+        QueryData<T2> queryData = new QueryData<T2>(dao, sql, toStringArray(initialValues), limitPosition,
+                offsetPosition);
+        return queryData.forCurrentThread();
+    }
+
+    private final int limitPosition;
+    private final int offsetPosition;
+    private final QueryData<T> queryData;
+
+    private Query(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[] initialValues, int limitPosition,
+            int offsetPosition) {
+        super(dao, sql, initialValues);
+        this.queryData = queryData;
+        this.limitPosition = limitPosition;
+        this.offsetPosition = offsetPosition;
+    }
+
+    public Query<T> forCurrentThread() {
+        return queryData.forCurrentThread(this);
+    }
+
+    /**
+     * Sets the parameter (0 based) using the position in which it was added during building the query.
+     */
+    public void setParameter(int index, Object parameter) {
+        if (index >= 0 && (index == limitPosition || index == offsetPosition)) {
+            throw new IllegalArgumentException("Illegal parameter index: " + index);
+        }
+        super.setParameter(index, parameter);
+    }
+
+    /**
+     * Sets the limit of the maximum number of results returned by this Query. {@link QueryBuilder#limit(int)} must have
+     * been called on the QueryBuilder that created this Query object.
+     */
+    public void setLimit(int limit) {
+        checkThread();
+        if (limitPosition == -1) {
+            throw new IllegalStateException("Limit must be set with QueryBuilder before it can be used here");
+        }
+        parameters[limitPosition] = Integer.toString(limit);
+    }
+
+    /**
+     * Sets the offset for results returned by this Query. {@link QueryBuilder#offset(int)} must have been called on the
+     * QueryBuilder that created this Query object.
+     */
+    public void setOffset(int offset) {
+        checkThread();
+        if (offsetPosition == -1) {
+            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
+        }
+        parameters[offsetPosition] = Integer.toString(offset);
+    }
+
+    /** Executes the query and returns the result as a list containing all entities loaded into memory. */
+    public List<T> list() {
+        checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        return daoAccess.loadAllAndCloseCursor(cursor);
+    }
+
+    /**
+     * Executes the query and returns the result as a list that lazy loads the entities on first access. Entities are
+     * cached, so accessing the same entity more than once will not result in loading an entity from the underlying
+     * cursor again.Make sure to close it to close the underlying cursor.
+     */
+    public LazyList<T> listLazy() {
+        checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        return new LazyList<T>(daoAccess, cursor, true);
+    }
+
+    /**
+     * Executes the query and returns the result as a list that lazy loads the entities on every access (uncached). Make
+     * sure to close the list to close the underlying cursor.
+     */
+    public LazyList<T> listLazyUncached() {
+        checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        return new LazyList<T>(daoAccess, cursor, false);
+    }
+
+    /**
+     * Executes the query and returns the result as a list iterator; make sure to close it to close the underlying
+     * cursor. The cursor is closed once the iterator is fully iterated through.
+     */
+    public CloseableListIterator<T> listIterator() {
+        return listLazyUncached().listIteratorAutoClose();
+    }
+
+    /**
+     * Executes the query and returns the unique result or null.
+     * 
+     * @throws DaoException
+     *             if the result is not unique
+     * @return Entity or null if no matching entity was found
+     */
+    public T unique() {
+        checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        return daoAccess.loadUniqueAndCloseCursor(cursor);
+    }
+
+    /**
+     * Executes the query and returns the unique result (never null).
+     * 
+     * @throws DaoException
+     *             if the result is not unique or no entity was found
+     * @return Entity
+     */
+    public T uniqueOrThrow() {
+        T entity = unique();
+        if (entity == null) {
+            throw new DaoException("No entity found for query");
+        }
+        return entity;
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
new file mode 100644
index 00000000..6f0c2547
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
@@ -0,0 +1,431 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.InternalQueryDaoAccess;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.query.WhereCondition.PropertyCondition;
+
+/**
+ * Builds custom entity queries using constraints and parameters and without SQL (QueryBuilder creates SQL for you). To
+ * acquire an QueryBuilder, use {@link AbstractDao#queryBuilder()} or {@link AbstractDaoSession#queryBuilder(Class)}.
+ * Entity properties are referenced by Fields in the "Properties" inner class of the generated DAOs. This approach
+ * allows compile time checks and prevents typo errors occuring at build time.<br/>
+ * <br/>
+ * Example: Query for all users with the first name "Joe" ordered by their last name. (The class Properties is an inner
+ * class of UserDao and should be imported before.)<br/>
+ * <code>
+ *  List<User> joes = dao.queryBuilder().where(Properties.FirstName.eq("Joe")).orderAsc(Properties.LastName).list();
+ *  </code>
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            Entity class to create an query for.
+ */
+public class QueryBuilder<T> {
+
+    /** Set to true to debug the SQL. */
+    public static boolean LOG_SQL;
+
+    /** Set to see the given values. */
+    public static boolean LOG_VALUES;
+
+    private StringBuilder orderBuilder;
+    private StringBuilder joinBuilder;
+
+    private final List<WhereCondition> whereConditions;
+
+    private final List<Object> values;
+    private final AbstractDao<T, ?> dao;
+    private final String tablePrefix;
+
+    private Integer limit;
+
+    private Integer offset;
+
+    /** For internal use by greenDAO only. */
+    public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
+        return new QueryBuilder<T2>(dao);
+    }
+
+    protected QueryBuilder(AbstractDao<T, ?> dao) {
+        this(dao, "T");
+    }
+
+    protected QueryBuilder(AbstractDao<T, ?> dao, String tablePrefix) {
+        this.dao = dao;
+        this.tablePrefix = tablePrefix;
+        values = new ArrayList<Object>();
+        whereConditions = new ArrayList<WhereCondition>();
+    }
+
+    private void checkOrderBuilder() {
+        if (orderBuilder == null) {
+            orderBuilder = new StringBuilder();
+        } else if (orderBuilder.length() > 0) {
+            orderBuilder.append(",");
+        }
+    }
+
+    /**
+     * Adds the given conditions to the where clause using an logical AND. To create new conditions, use the properties
+     * given in the generated dao classes.
+     */
+    public QueryBuilder<T> where(WhereCondition cond, WhereCondition... condMore) {
+        whereConditions.add(cond);
+        for (WhereCondition whereCondition : condMore) {
+            checkCondition(whereCondition);
+            whereConditions.add(whereCondition);
+        }
+        return this;
+    }
+
+    /**
+     * Adds the given conditions to the where clause using an logical OR. To create new conditions, use the properties
+     * given in the generated dao classes.
+     */
+    public QueryBuilder<T> whereOr(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        whereConditions.add(or(cond1, cond2, condMore));
+        return this;
+    }
+
+    /**
+     * Creates a WhereCondition by combining the given conditions using OR. The returned WhereCondition must be used
+     * inside {@link #where(WhereCondition, WhereCondition...)} or
+     * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
+     */
+    public WhereCondition or(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        return combineWhereConditions(" OR ", cond1, cond2, condMore);
+    }
+
+    /**
+     * Creates a WhereCondition by combining the given conditions using AND. The returned WhereCondition must be used
+     * inside {@link #where(WhereCondition, WhereCondition...)} or
+     * {@link #whereOr(WhereCondition, WhereCondition, WhereCondition...)}.
+     */
+    public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondition... condMore) {
+        return combineWhereConditions(" AND ", cond1, cond2, condMore);
+    }
+
+    protected WhereCondition combineWhereConditions(String combineOp, WhereCondition cond1, WhereCondition cond2,
+            WhereCondition... condMore) {
+        StringBuilder builder = new StringBuilder("(");
+        List<Object> combinedValues = new ArrayList<Object>();
+
+        addCondition(builder, combinedValues, cond1);
+        builder.append(combineOp);
+        addCondition(builder, combinedValues, cond2);
+
+        for (WhereCondition cond : condMore) {
+            builder.append(combineOp);
+            addCondition(builder, combinedValues, cond);
+        }
+        builder.append(')');
+        return new WhereCondition.StringCondition(builder.toString(), combinedValues.toArray());
+    }
+
+    protected void addCondition(StringBuilder builder, List<Object> values, WhereCondition condition) {
+        checkCondition(condition);
+        condition.appendTo(builder, tablePrefix);
+        condition.appendValuesTo(values);
+    }
+
+    protected void checkCondition(WhereCondition whereCondition) {
+        if (whereCondition instanceof PropertyCondition) {
+            checkProperty(((PropertyCondition) whereCondition).property);
+        }
+    }
+
+    /** Not supported yet. */
+    public <J> QueryBuilder<J> join(Class<J> entityClass, Property toOneProperty) {
+        throw new UnsupportedOperationException();
+        // return new QueryBuilder<J>();
+    }
+
+    /** Not supported yet. */
+    public <J> QueryBuilder<J> joinToMany(Class<J> entityClass, Property toManyProperty) {
+        throw new UnsupportedOperationException();
+        // @SuppressWarnings("unchecked")
+        // AbstractDao<J, ?> joinDao = (AbstractDao<J, ?>) dao.getSession().getDao(entityClass);
+        // return new QueryBuilder<J>(joinDao, "TX");
+    }
+
+    /** Adds the given properties to the ORDER BY section using ascending order. */
+    public QueryBuilder<T> orderAsc(Property... properties) {
+        orderAscOrDesc(" ASC", properties);
+        return this;
+    }
+
+    /** Adds the given properties to the ORDER BY section using descending order. */
+    public QueryBuilder<T> orderDesc(Property... properties) {
+        orderAscOrDesc(" DESC", properties);
+        return this;
+    }
+
+    private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... properties) {
+        for (Property property : properties) {
+            checkOrderBuilder();
+            append(orderBuilder, property);
+            if (String.class.equals(property.type)) {
+                orderBuilder.append(" COLLATE LOCALIZED");
+            }
+            orderBuilder.append(ascOrDescWithLeadingSpace);
+        }
+    }
+
+    /** Adds the given properties to the ORDER BY section using the given custom order. */
+    public QueryBuilder<T> orderCustom(Property property, String customOrderForProperty) {
+        checkOrderBuilder();
+        append(orderBuilder, property).append(' ');
+        orderBuilder.append(customOrderForProperty);
+        return this;
+    }
+
+    /**
+     * Adds the given raw SQL string to the ORDER BY section. Do not use this for standard properties: ordedAsc and
+     * orderDesc are prefered.
+     */
+    public QueryBuilder<T> orderRaw(String rawOrder) {
+        checkOrderBuilder();
+        orderBuilder.append(rawOrder);
+        return this;
+    }
+
+    protected StringBuilder append(StringBuilder builder, Property property) {
+        checkProperty(property);
+        builder.append(tablePrefix).append('.').append('\'').append(property.columnName).append('\'');
+        return builder;
+    }
+
+    protected void checkProperty(Property property) {
+        if (dao != null) {
+            Property[] properties = dao.getProperties();
+            boolean found = false;
+            for (Property property2 : properties) {
+                if (property == property2) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                throw new DaoException("Property '" + property.name + "' is not part of " + dao);
+            }
+        }
+    }
+
+    /** Limits the number of results returned by queries. */
+    public QueryBuilder<T> limit(int limit) {
+        this.limit = limit;
+        return this;
+    }
+
+    /**
+     * Sets the offset for query results in combination with {@link #limit(int)}. The first {@code limit} results are
+     * skipped and the total number of results will be limited by {@code limit}. You cannot use offset without limit.
+     */
+    public QueryBuilder<T> offset(int offset) {
+        this.offset = offset;
+        return this;
+    }
+
+    /**
+     * Builds a reusable query object (Query objects can be executed more efficiently than creating a QueryBuilder for
+     * each execution.
+     */
+    public Query<T> build() {
+        String select;
+        if (joinBuilder == null || joinBuilder.length() == 0) {
+            select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
+        } else {
+            select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
+        }
+        StringBuilder builder = new StringBuilder(select);
+
+        appendWhereClause(builder, tablePrefix);
+
+        if (orderBuilder != null && orderBuilder.length() > 0) {
+            builder.append(" ORDER BY ").append(orderBuilder);
+        }
+
+        int limitPosition = -1;
+        if (limit != null) {
+            builder.append(" LIMIT ?");
+            values.add(limit);
+            limitPosition = values.size() - 1;
+        }
+
+        int offsetPosition = -1;
+        if (offset != null) {
+            if (limit == null) {
+                throw new IllegalStateException("Offset cannot be set without limit");
+            }
+            builder.append(" OFFSET ?");
+            values.add(offset);
+            offsetPosition = values.size() - 1;
+        }
+
+        String sql = builder.toString();
+        if (LOG_SQL) {
+            DaoLog.d("Built SQL for query: " + sql);
+        }
+
+        if (LOG_VALUES) {
+            DaoLog.d("Values for query: " + values);
+        }
+
+        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+    }
+
+    /**
+     * Builds a reusable query object for deletion (Query objects can be executed more efficiently than creating a
+     * QueryBuilder for each execution.
+     */
+    public DeleteQuery<T> buildDelete() {
+        String tablename = dao.getTablename();
+        String baseSql = SqlUtils.createSqlDelete(tablename, null);
+        StringBuilder builder = new StringBuilder(baseSql);
+
+        // tablePrefix gets replaced by table name below. Don't use tableName here because it causes trouble when
+        // table name ends with tablePrefix.
+        appendWhereClause(builder, tablePrefix);
+
+        String sql = builder.toString();
+
+        // Remove table aliases, not supported for DELETE queries.
+        // TODO(?): don't create table aliases in the first place.
+        sql = sql.replace(tablePrefix + ".'", tablename + ".'");
+
+        if (LOG_SQL) {
+            DaoLog.d("Built SQL for delete query: " + sql);
+        }
+        if (LOG_VALUES) {
+            DaoLog.d("Values for delete query: " + values);
+        }
+
+        return DeleteQuery.create(dao, sql, values.toArray());
+    }
+
+    /**
+     * Builds a reusable query object for counting rows (Query objects can be executed more efficiently than creating a
+     * QueryBuilder for each execution.
+     */
+    public CountQuery<T> buildCount() {
+        String tablename = dao.getTablename();
+        String baseSql = SqlUtils.createSqlSelectCountStar(tablename, tablePrefix);
+        StringBuilder builder = new StringBuilder(baseSql);
+        appendWhereClause(builder, tablePrefix);
+        String sql = builder.toString();
+
+        if (LOG_SQL) {
+            DaoLog.d("Built SQL for count query: " + sql);
+        }
+        if (LOG_VALUES) {
+            DaoLog.d("Values for count query: " + values);
+        }
+
+        return CountQuery.create(dao, sql, values.toArray());
+    }
+
+    private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull) {
+        values.clear();
+        if (!whereConditions.isEmpty()) {
+            builder.append(" WHERE ");
+            ListIterator<WhereCondition> iter = whereConditions.listIterator();
+            while (iter.hasNext()) {
+                if (iter.hasPrevious()) {
+                    builder.append(" AND ");
+                }
+                WhereCondition condition = iter.next();
+                condition.appendTo(builder, tablePrefixOrNull);
+                condition.appendValuesTo(values);
+            }
+        }
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#list() list()}; see {@link Query#list()} for
+     * details. To execute a query more than once, you should build the query and keep the {@link Query} object for
+     * efficiency reasons.
+     */
+    public List<T> list() {
+        return build().list();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#listLazy() listLazy()}; see
+     * {@link Query#listLazy()} for details. To execute a query more than once, you should build the query and keep the
+     * {@link Query} object for efficiency reasons.
+     */
+    public LazyList<T> listLazy() {
+        return build().listLazy();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#listLazyUncached() listLazyUncached()}; see
+     * {@link Query#listLazyUncached()} for details. To execute a query more than once, you should build the query and
+     * keep the {@link Query} object for efficiency reasons.
+     */
+    public LazyList<T> listLazyUncached() {
+        return build().listLazyUncached();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#listIterator() listIterator()}; see
+     * {@link Query#listIterator()} for details. To execute a query more than once, you should build the query and keep
+     * the {@link Query} object for efficiency reasons.
+     */
+    public CloseableListIterator<T> listIterator() {
+        return build().listIterator();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#unique() unique()}; see {@link Query#unique()}
+     * for details. To execute a query more than once, you should build the query and keep the {@link Query} object for
+     * efficiency reasons.
+     */
+    public T unique() {
+        return build().unique();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#build() build()}.{@link Query#uniqueOrThrow() uniqueOrThrow()}; see
+     * {@link Query#uniqueOrThrow()} for details. To execute a query more than once, you should build the query and keep
+     * the {@link Query} object for efficiency reasons.
+     */
+    public T uniqueOrThrow() {
+        return build().uniqueOrThrow();
+    }
+
+    /**
+     * Shorthand for {@link de.greenrobot.dao.query.QueryBuilder#buildCount() buildCount()}.{@link CountQuery#count() count()}; see
+     * {@link CountQuery#count()} for details. To execute a query more than once, you should build the query and keep
+     * the {@link CountQuery} object for efficiency reasons.
+     */
+    public long count() {
+        return buildCount().count();
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
new file mode 100644
index 00000000..2a8b626a
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/WhereCondition.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.query;
+
+import java.util.Date;
+import java.util.List;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
+
+/**
+ * Internal interface to model WHERE conditions used in queries. Use the {@link Property} objects in the DAO classes to
+ * create new conditions.
+ */
+public interface WhereCondition {
+
+    void appendTo(StringBuilder builder, String tableAlias);
+
+    void appendValuesTo(List<Object> values);
+
+    public abstract static class AbstractCondition implements WhereCondition {
+
+        protected final boolean hasSingleValue;
+        protected final Object value;
+        protected final Object[] values;
+
+        public AbstractCondition() {
+            hasSingleValue = false;
+            value = null;
+            values = null;
+        }
+
+        public AbstractCondition(Object value) {
+            this.value = value;
+            hasSingleValue = true;
+            values = null;
+        }
+
+        public AbstractCondition(Object[] values) {
+            this.value = null;
+            hasSingleValue = false;
+            this.values = values;
+        }
+
+        @Override
+        public void appendValuesTo(List<Object> valuesTarget) {
+            if (hasSingleValue) {
+                valuesTarget.add(value);
+            }
+            if (values != null) {
+                for (Object value : values) {
+                    valuesTarget.add(value);
+                }
+            }
+        }
+    }
+
+    public static class PropertyCondition extends AbstractCondition {
+
+        private static Object checkValueForType(Property property, Object value) {
+            if (value != null && value.getClass().isArray()) {
+                throw new DaoException("Illegal value: found array, but simple object required");
+            }
+            Class<?> type = property.type;
+            if (type == Date.class) {
+                if (value instanceof Date) {
+                    return ((Date) value).getTime();
+                } else if (value instanceof Long) {
+                    return value;
+                } else {
+                    throw new DaoException("Illegal date value: expected java.util.Date or Long for value " + value);
+                }
+            } else if (property.type == boolean.class || property.type == Boolean.class) {
+                if (value instanceof Boolean) {
+                    return ((Boolean) value) ? 1 : 0;
+                } else if (value instanceof Number) {
+                    int intValue = ((Number) value).intValue();
+                    if (intValue != 0 && intValue != 1) {
+                        throw new DaoException("Illegal boolean value: numbers must be 0 or 1, but was " + value);
+                    }
+                } else if (value instanceof String) {
+                    String stringValue = ((String) value);
+                    if ("TRUE".equalsIgnoreCase(stringValue)) {
+                        return 1;
+                    } else if ("FALSE".equalsIgnoreCase(stringValue)) {
+                        return 0;
+                    } else {
+                        throw new DaoException(
+                                "Illegal boolean value: Strings must be \"TRUE\" or \"FALSE\" (case insesnsitive), but was "
+                                        + value);
+                    }
+                }
+            }
+            return value;
+        }
+
+        private static Object[] checkValuesForType(Property property, Object[] values) {
+            for (int i = 0; i < values.length; i++) {
+                values[i] = checkValueForType(property, values[i]);
+            }
+            return values;
+        }
+
+        public final Property property;
+        public final String op;
+
+        public PropertyCondition(Property property, String op) {
+            this.property = property;
+            this.op = op;
+        }
+
+        public PropertyCondition(Property property, String op, Object value) {
+            super(checkValueForType(property, value));
+            this.property = property;
+            this.op = op;
+        }
+
+        public PropertyCondition(Property property, String op, Object[] values) {
+            super(checkValuesForType(property, values));
+            this.property = property;
+            this.op = op;
+        }
+
+        @Override
+        public void appendTo(StringBuilder builder, String tableAlias) {
+            if (tableAlias != null) {
+                builder.append(tableAlias).append('.');
+            }
+            builder.append('\'').append(property.columnName).append('\'').append(op);
+        }
+    }
+
+    public static class StringCondition extends AbstractCondition {
+
+        protected final String string;
+
+        public StringCondition(String string) {
+            this.string = string;
+        }
+
+        public StringCondition(String string, Object value) {
+            super(value);
+            this.string = string;
+        }
+
+        public StringCondition(String string, Object... values) {
+            super(values);
+            this.string = string;
+        }
+
+        @Override
+        public void appendTo(StringBuilder builder, String tableAlias) {
+            builder.append(string);
+        }
+
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
new file mode 100644
index 00000000..08bc0ff9
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.AbstractDaoSession;
+
+/**
+ * Base class for DAO (master) related testing.
+ * 
+ * @author Markus
+ * 
+ * @param <T>
+ *            Type of a concrete DAO master
+ */
+public abstract class AbstractDaoSessionTest<T extends AbstractDaoMaster, S extends AbstractDaoSession>
+        extends DbTest {
+
+    private final Class<T> daoMasterClass;
+    protected T daoMaster;
+    protected S daoSession;
+
+    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
+        this(daoMasterClass, true);
+    }
+
+    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
+        super(inMemory);
+        this.daoMasterClass = daoMasterClass;
+    }
+
+	@SuppressWarnings("unchecked")
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        try {
+            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
+            daoMaster = constructor.newInstance(db);
+
+            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
+            createTableMethod.invoke(null, db, false);
+        } catch (Exception e) {
+            throw new RuntimeException("Could not prepare DAO session test", e);
+        }
+        daoSession = (S) daoMaster.newSession();
+    }
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
new file mode 100644
index 00000000..6c301da7
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import java.lang.reflect.Method;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.InternalUnitTestDaoAccess;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.identityscope.IdentityScope;
+
+/**
+ * Base class for DAO related testing. Prepares an in-memory DB and DAO.
+ * 
+ * @author Markus
+ * 
+ * @param <D>
+ *            DAO class
+ * @param <T>
+ *            Entity type of the DAO
+ * @param <K>
+ *            Key type of the DAO
+ */
+public abstract class AbstractDaoTest<D extends AbstractDao<T, K>, T, K> extends DbTest {
+
+    protected final Class<D> daoClass;
+    protected D dao;
+    protected InternalUnitTestDaoAccess<T, K> daoAccess;
+    protected Property pkColumn;
+    protected IdentityScope<K, T> identityScopeForDao;
+
+    public AbstractDaoTest(Class<D> daoClass) {
+        this(daoClass, true);
+    }
+
+    public AbstractDaoTest(Class<D> daoClass, boolean inMemory) {
+        super(inMemory);
+        this.daoClass = daoClass;
+    }
+
+    public void setIdentityScopeBeforeSetUp(IdentityScope<K, T> identityScope) {
+        this.identityScopeForDao = identityScope;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        try {
+            setUpTableForDao();
+            daoAccess = new InternalUnitTestDaoAccess<T, K>(db, (Class<AbstractDao<T, K>>) daoClass, identityScopeForDao);
+            dao = (D) daoAccess.getDao();
+        } catch (Exception e) {
+            throw new RuntimeException("Could not prepare DAO Test", e);
+        }
+    }
+
+    protected void setUpTableForDao() throws Exception {
+        try {
+            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabase.class, boolean.class);
+            createTableMethod.invoke(null, db, false);
+        } catch (NoSuchMethodException e) {
+            DaoLog.i("No createTable method");
+        }
+    }
+
+    protected void clearIdentityScopeIfAny() {
+        if (identityScopeForDao != null) {
+            identityScopeForDao.clear();
+            DaoLog.d("Identity scope cleared");
+        } else {
+            DaoLog.d("No identity scope to clear");
+        }
+    }
+
+    protected void logTableDump() {
+        logTableDump(dao.getTablename());
+    }
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
new file mode 100644
index 00000000..6be8b3d5
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoLog;
+
+/**
+ * Base class for DAOs having a long/Long as a PK, which is quite common.
+ * 
+ * @author Markus
+ * 
+ * @param <D>
+ *            DAO class
+ * @param <T>
+ *            Entity type of the DAO
+ */
+public abstract class AbstractDaoTestLongPk<D extends AbstractDao<T, Long>, T> extends AbstractDaoTestSinglePk<D, T, Long> {
+
+    public AbstractDaoTestLongPk(Class<D> daoClass) {
+        super(daoClass);
+    }
+
+    /** {@inheritDoc} */
+    protected Long createRandomPk() {
+        return random.nextLong();
+    }
+    
+    public void testAssignPk() {
+        if (daoAccess.isEntityUpdateable()) {
+            T entity1 = createEntity(null);
+            if (entity1 != null) {
+                T entity2 = createEntity(null);
+
+                dao.insert(entity1);
+                dao.insert(entity2);
+
+                Long pk1 = daoAccess.getKey(entity1);
+                assertNotNull(pk1);
+                Long pk2 = daoAccess.getKey(entity2);
+                assertNotNull(pk2);
+
+                assertFalse(pk1.equals(pk2));
+
+                assertNotNull(dao.load(pk1));
+                assertNotNull(dao.load(pk2));
+            } else {
+                DaoLog.d("Skipping testAssignPk for " + daoClass + " (createEntity returned null for null key)");
+            }
+        } else {
+            DaoLog.d("Skipping testAssignPk for not updateable " + daoClass);
+        }
+    }
+
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
new file mode 100644
index 00000000..f1d05b43
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.SQLException;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Default tests for single-PK entities.
+ *
+ * @param <D> DAO class
+ * @param <T> Entity type of the DAO
+ * @param <K> Key type of the DAO
+ * @author Markus
+ */
+public abstract class AbstractDaoTestSinglePk<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
+
+    protected Set<K> usedPks;
+    private Property pkColumn;
+
+    public AbstractDaoTestSinglePk(Class<D> daoClass) {
+        super(daoClass);
+        usedPks = new HashSet<K>();
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        Property[] columns = daoAccess.getProperties();
+        for (Property column : columns) {
+            if (column.primaryKey) {
+                if (pkColumn != null) {
+                    throw new RuntimeException("Test does not work with multiple PK columns");
+                }
+                pkColumn = column;
+            }
+        }
+        if (pkColumn == null) {
+            throw new RuntimeException("Test does not work without a PK column");
+        }
+    }
+
+    public void testInsertAndLoad() {
+        K pk = nextPk();
+        T entity = createEntity(pk);
+        dao.insert(entity);
+        assertEquals(pk, daoAccess.getKey(entity));
+        T entity2 = dao.load(pk);
+        assertNotNull(entity2);
+        assertEquals(daoAccess.getKey(entity), daoAccess.getKey(entity2));
+    }
+
+    public void testInsertInTx() {
+        dao.deleteAll();
+        List<T> list = new ArrayList<T>();
+        for (int i = 0; i < 20; i++) {
+            list.add(createEntityWithRandomPk());
+        }
+        dao.insertInTx(list);
+        assertEquals(list.size(), dao.count());
+    }
+
+    public void testCount() {
+        dao.deleteAll();
+        assertEquals(0, dao.count());
+        dao.insert(createEntityWithRandomPk());
+        assertEquals(1, dao.count());
+        dao.insert(createEntityWithRandomPk());
+        assertEquals(2, dao.count());
+    }
+
+    public void testInsertTwice() {
+        K pk = nextPk();
+        T entity = createEntity(pk);
+        dao.insert(entity);
+        try {
+            dao.insert(entity);
+            fail("Inserting twice should not work");
+        } catch (SQLException expected) {
+            // OK
+        }
+    }
+
+    public void testInsertOrReplaceTwice() {
+        T entity = createEntityWithRandomPk();
+        long rowId1 = dao.insert(entity);
+        long rowId2 = dao.insertOrReplace(entity);
+        if (dao.getPkProperty().type == Long.class) {
+            assertEquals(rowId1, rowId2);
+        }
+    }
+
+    public void testInsertOrReplaceInTx() {
+        dao.deleteAll();
+        List<T> listPartial = new ArrayList<T>();
+        List<T> listAll = new ArrayList<T>();
+        for (int i = 0; i < 20; i++) {
+            T entity = createEntityWithRandomPk();
+            if (i % 2 == 0) {
+                listPartial.add(entity);
+            }
+            listAll.add(entity);
+        }
+        dao.insertOrReplaceInTx(listPartial);
+        dao.insertOrReplaceInTx(listAll);
+        assertEquals(listAll.size(), dao.count());
+    }
+
+    public void testDelete() {
+        K pk = nextPk();
+        dao.deleteByKey(pk);
+        T entity = createEntity(pk);
+        dao.insert(entity);
+        assertNotNull(dao.load(pk));
+        dao.deleteByKey(pk);
+        assertNull(dao.load(pk));
+    }
+
+    public void testDeleteAll() {
+        List<T> entityList = new ArrayList<T>();
+        for (int i = 0; i < 10; i++) {
+            T entity = createEntityWithRandomPk();
+            entityList.add(entity);
+        }
+        dao.insertInTx(entityList);
+        dao.deleteAll();
+        assertEquals(0, dao.count());
+        for (T entity : entityList) {
+            K key = daoAccess.getKey(entity);
+            assertNotNull(key);
+            assertNull(dao.load(key));
+        }
+    }
+
+    public void testDeleteInTx() {
+        List<T> entityList = new ArrayList<T>();
+        for (int i = 0; i < 10; i++) {
+            T entity = createEntityWithRandomPk();
+            entityList.add(entity);
+        }
+        dao.insertInTx(entityList);
+        List<T> entitiesToDelete = new ArrayList<T>();
+        entitiesToDelete.add(entityList.get(0));
+        entitiesToDelete.add(entityList.get(3));
+        entitiesToDelete.add(entityList.get(4));
+        entitiesToDelete.add(entityList.get(8));
+        dao.deleteInTx(entitiesToDelete);
+        assertEquals(entityList.size() - entitiesToDelete.size(), dao.count());
+        for (T deletedEntity : entitiesToDelete) {
+            K key = daoAccess.getKey(deletedEntity);
+            assertNotNull(key);
+            assertNull(dao.load(key));
+        }
+    }
+
+    public void testDeleteByKeyInTx() {
+        List<T> entityList = new ArrayList<T>();
+        for (int i = 0; i < 10; i++) {
+            T entity = createEntityWithRandomPk();
+            entityList.add(entity);
+        }
+        dao.insertInTx(entityList);
+        List<K> keysToDelete = new ArrayList<K>();
+        keysToDelete.add(daoAccess.getKey(entityList.get(0)));
+        keysToDelete.add(daoAccess.getKey(entityList.get(3)));
+        keysToDelete.add(daoAccess.getKey(entityList.get(4)));
+        keysToDelete.add(daoAccess.getKey(entityList.get(8)));
+        dao.deleteByKeyInTx(keysToDelete);
+        assertEquals(entityList.size() - keysToDelete.size(), dao.count());
+        for (K key : keysToDelete) {
+            assertNotNull(key);
+            assertNull(dao.load(key));
+        }
+    }
+
+    public void testRowId() {
+        T entity1 = createEntityWithRandomPk();
+        T entity2 = createEntityWithRandomPk();
+        long rowId1 = dao.insert(entity1);
+        long rowId2 = dao.insert(entity2);
+        assertTrue(rowId1 != rowId2);
+    }
+
+    public void testLoadAll() {
+        dao.deleteAll();
+        List<T> list = new ArrayList<T>();
+        for (int i = 0; i < 15; i++) {
+            T entity = createEntity(nextPk());
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        List<T> loaded = dao.loadAll();
+        assertEquals(list.size(), loaded.size());
+    }
+
+    public void testQuery() {
+        dao.insert(createEntityWithRandomPk());
+        K pkForQuery = nextPk();
+        dao.insert(createEntity(pkForQuery));
+        dao.insert(createEntityWithRandomPk());
+
+        String where = "WHERE " + dao.getPkColumns()[0] + "=?";
+        List<T> list = dao.queryRaw(where, pkForQuery.toString());
+        assertEquals(1, list.size());
+        assertEquals(pkForQuery, daoAccess.getKey(list.get(0)));
+    }
+
+    public void testUpdate() {
+        dao.deleteAll();
+        T entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.update(entity);
+        assertEquals(1, dao.count());
+    }
+
+    public void testReadWithOffset() {
+        K pk = nextPk();
+        T entity = createEntity(pk);
+        dao.insert(entity);
+
+        Cursor cursor = queryWithDummyColumnsInFront(5, "42", pk);
+        try {
+            T entity2 = daoAccess.readEntity(cursor, 5);
+            assertEquals(pk, daoAccess.getKey(entity2));
+        } finally {
+            cursor.close();
+        }
+    }
+
+    public void testLoadPkWithOffset() {
+        runLoadPkTest(10);
+    }
+
+    public void testLoadPk() {
+        runLoadPkTest(0);
+    }
+
+    protected void runLoadPkTest(int offset) {
+        K pk = nextPk();
+        T entity = createEntity(pk);
+        dao.insert(entity);
+
+        Cursor cursor = queryWithDummyColumnsInFront(offset, "42", pk);
+        try {
+            K pk2 = daoAccess.readKey(cursor, offset);
+            assertEquals(pk, pk2);
+        } finally {
+            cursor.close();
+        }
+    }
+
+    protected Cursor queryWithDummyColumnsInFront(int dummyCount, String valueForColumn, K pk) {
+        StringBuilder builder = new StringBuilder("SELECT ");
+        for (int i = 0; i < dummyCount; i++) {
+            builder.append(valueForColumn).append(",");
+        }
+        SqlUtils.appendColumns(builder, "T", dao.getAllColumns()).append(" FROM ");
+        builder.append(dao.getTablename()).append(" T");
+        if (pk != null) {
+            builder.append(" WHERE ");
+
+            assertEquals(1, dao.getPkColumns().length);
+            builder.append(dao.getPkColumns()[0]).append("=");
+            DatabaseUtils.appendValueToSql(builder, pk);
+        }
+
+        String select = builder.toString();
+        Cursor cursor = db.rawQuery(select, null);
+        assertTrue(cursor.moveToFirst());
+        try {
+            for (int i = 0; i < dummyCount; i++) {
+                assertEquals(valueForColumn, cursor.getString(i));
+            }
+            if (pk != null) {
+                assertEquals(1, cursor.getCount());
+            }
+        } catch (RuntimeException ex) {
+            cursor.close();
+            throw ex;
+        }
+        return cursor;
+    }
+
+    /** Provides a collision free PK () not returned before in the current test. */
+    protected K nextPk() {
+        for (int i = 0; i < 100000; i++) {
+            K pk = createRandomPk();
+            if (usedPks.add(pk)) {
+                return pk;
+            }
+        }
+        throw new IllegalStateException("Could not find a new PK");
+    }
+
+    protected T createEntityWithRandomPk() {
+        return createEntity(nextPk());
+    }
+
+    /** K does not have to be collision free, check nextPk for collision free PKs. */
+    protected abstract K createRandomPk();
+
+    /**
+     * Creates an insertable entity. If the given key is null, but the entity's PK is not null the method must return
+     * null.
+     */
+    protected abstract T createEntity(K key);
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
new file mode 100644
index 00000000..f97b979c
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.dao.test;
+
+import de.greenrobot.dao.AbstractDao;
+
+/**
+ * Base class for DAOs having a String as a PK.
+ * 
+ * @author Markus
+ * 
+ * @param <D>
+ *            DAO class
+ * @param <T>
+ *            Entity type of the DAO
+ */
+public abstract class AbstractDaoTestStringPk<D extends AbstractDao<T, String>, T> extends
+        AbstractDaoTestSinglePk<D, T, String> {
+
+    public AbstractDaoTestStringPk(Class<D> daoClass) {
+        super(daoClass);
+    }
+
+    @Override
+    protected String createRandomPk() {
+        int len = 1 + random.nextInt(30);
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < len; i++) {
+            char c = (char) ('a' + random.nextInt('z' - 'a'));
+            builder.append(c);
+        }
+        return builder.toString();
+    }
+
+}
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
new file mode 100644
index 00000000..8587ee4b
--- /dev/null
+++ b/DaoCore/src/main/java/de/greenrobot/dao/test/DbTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.dao.test;
+
+import android.app.Application;
+import android.app.Instrumentation;
+import android.database.sqlite.SQLiteDatabase;
+import android.test.AndroidTestCase;
+import de.greenrobot.dao.DbUtils;
+
+import java.util.Random;
+
+/**
+ * Base class for database related testing, which prepares an in-memory or an file-based DB (using the test {@link
+ * android.content.Context}). Also, offers some convenience methods to create new {@link android.app.Application} objects similar to
+ * {@link android.test.ApplicationTestCase}.
+ * <p/>
+ * Unlike ApplicationTestCase, this class should behave more correctly when you call {@link #createApplication(Class)}
+ * during {@link #setUp()}: {@link android.test.ApplicationTestCase#testApplicationTestCaseSetUpProperly()} leaves
+ * Application objects un-terminated.
+ *
+ * @author Markus
+ */
+public abstract class DbTest extends AndroidTestCase {
+
+    public static final String DB_NAME = "greendao-unittest-db.temp";
+
+    protected final Random random;
+    protected final boolean inMemory;
+    protected SQLiteDatabase db;
+
+    private Application application;
+
+    public DbTest() {
+        this(true);
+    }
+
+    public DbTest(boolean inMemory) {
+        this.inMemory = inMemory;
+        random = new Random();
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        db = createDatabase();
+    }
+
+    /** Returns a prepared application with the onCreate method already called. */
+    public <T extends Application> T createApplication(Class<T> appClass) {
+        assertNull("Application already created", application);
+        T app;
+        try {
+            app = (T) Instrumentation.newApplication(appClass, getContext());
+        } catch (Exception e) {
+            throw new RuntimeException("Could not create application " + appClass, e);
+        }
+        app.onCreate();
+        application = app;
+        return app;
+    }
+
+    /** Terminates a previously created application. Also called by {@link #tearDown()} if needed. */
+    public void terminateApplication() {
+        assertNotNull("Application not yet created", application);
+        application.onTerminate();
+        application = null;
+    }
+
+    /** Gets the previously created application. */
+    public <T extends Application> T getApplication() {
+        assertNotNull("Application not yet created", application);
+        return (T) application;
+    }
+
+    /** May be overriden by sub classes to set up a different db. */
+    protected SQLiteDatabase createDatabase() {
+        if (inMemory) {
+            return SQLiteDatabase.create(null);
+        } else {
+            getContext().deleteDatabase(DB_NAME);
+            return getContext().openOrCreateDatabase(DB_NAME, 0, null);
+        }
+    }
+
+    @Override
+    /** Closes the db, and terminates an application, if one was created before. */
+    protected void tearDown() throws Exception {
+        if (application != null) {
+            terminateApplication();
+        }
+        db.close();
+        if (!inMemory) {
+            getContext().deleteDatabase(DB_NAME);
+        }
+        super.tearDown();
+    }
+
+    protected void logTableDump(String tablename) {
+        DbUtils.logTableDump(db, tablename);
+    }
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/main/res/drawable-hdpi/ic_launcher.png b/DaoCore/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 00000000..96a442e5
Binary files /dev/null and b/DaoCore/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/DaoCore/src/main/res/drawable-mdpi/ic_launcher.png b/DaoCore/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 00000000..359047df
Binary files /dev/null and b/DaoCore/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/DaoCore/src/main/res/drawable-xhdpi/ic_launcher.png b/DaoCore/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..71c6d760
Binary files /dev/null and b/DaoCore/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/DaoCore/src/main/res/drawable-xxhdpi/ic_launcher.png b/DaoCore/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..4df18946
Binary files /dev/null and b/DaoCore/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/DaoCore/src/main/res/layout/activity_main.xml b/DaoCore/src/main/res/layout/activity_main.xml
new file mode 100644
index 00000000..1cbc332c
--- /dev/null
+++ b/DaoCore/src/main/res/layout/activity_main.xml
@@ -0,0 +1,16 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    tools:context=".MainActivity">
+
+    <TextView
+        android:text="@string/hello_world"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+
+</RelativeLayout>
diff --git a/DaoCore/src/main/res/menu/main.xml b/DaoCore/src/main/res/menu/main.xml
new file mode 100644
index 00000000..7fe7424d
--- /dev/null
+++ b/DaoCore/src/main/res/menu/main.xml
@@ -0,0 +1,9 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".MainActivity" >
+    <item android:id="@+id/action_settings"
+        android:title="@string/action_settings"
+        android:orderInCategory="100"
+        app:showAsAction="never" />
+</menu>
diff --git a/DaoCore/src/main/res/values-w820dp/dimens.xml b/DaoCore/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 00000000..63fc8164
--- /dev/null
+++ b/DaoCore/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/DaoCore/src/main/res/values/dimens.xml b/DaoCore/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/DaoCore/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/DaoCore/src/main/res/values/strings.xml b/DaoCore/src/main/res/values/strings.xml
new file mode 100644
index 00000000..4a93407a
--- /dev/null
+++ b/DaoCore/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">DaoCore</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
diff --git a/DaoExample/.gitignore b/DaoExample/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/DaoExample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/DaoExample/build.gradle b/DaoExample/build.gradle
new file mode 100644
index 00000000..21b07673
--- /dev/null
+++ b/DaoExample/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 21
+    buildToolsVersion "21.0.2"
+
+    defaultConfig {
+        applicationId "de.greenrobot.daoexample"
+        minSdkVersion 8
+        targetSdkVersion 21
+        versionCode 1
+        versionName "1.0"
+    }
+//    buildTypes {
+//        release {
+//            runProguard false
+//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+//        }
+//    }
+
+    sourceSets {
+        main {
+            java.srcDirs = ['src/main/java', 'src/main/java-gen']
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:21.0.0'
+    compile project(":DaoCore")
+}
diff --git a/DaoExample/proguard-rules.pro b/DaoExample/proguard-rules.pro
new file mode 100644
index 00000000..4667b2c2
--- /dev/null
+++ b/DaoExample/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in G:/android-studio-2/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/DaoExample/src/androidTest/java/de/greenrobot/daoexample/ApplicationTest.java b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/ApplicationTest.java
new file mode 100644
index 00000000..6e1af308
--- /dev/null
+++ b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/ApplicationTest.java
@@ -0,0 +1,13 @@
+package de.greenrobot.daoexample;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/DaoExample/src/androidTest/java/de/greenrobot/daoexample/CustomerOrderTest.java b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/CustomerOrderTest.java
new file mode 100644
index 00000000..28980818
--- /dev/null
+++ b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/CustomerOrderTest.java
@@ -0,0 +1,61 @@
+package de.greenrobot.daoexample;
+
+import java.util.Date;
+import java.util.List;
+
+import android.app.Application;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class CustomerOrderTest extends AbstractDaoSessionTest<Application, DaoMaster, DaoSession> {
+
+    public CustomerOrderTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testCustomerToOrders() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        addOrderToCustomer(customer);
+        addOrderToCustomer(customer);
+
+        List<Order> orders = customer.getOrders();
+        assertEquals(2, orders.size());
+    }
+
+    public void testOrderToCustomer() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        Order order = addOrderToCustomer(customer);
+        Customer customer2 = order.getCustomer();
+        
+        assertSame(customer, customer2);
+    }
+
+    public void testUpdateBirectional() {
+        Customer customer = new Customer(null, "greenrobot");
+        daoSession.insert(customer);
+
+        addOrderToCustomer(customer);
+        List<Order> orders = customer.getOrders();
+        
+        Order newOrder = new Order();
+        newOrder.setCustomer(customer);
+        daoSession.insert(newOrder);
+        orders.add(newOrder);
+        assertEquals(2, orders.size());
+        
+        customer.resetOrders();
+        List<Order> orders2 = customer.getOrders();
+        assertEquals(orders.size(), orders2.size());
+    }
+
+    private Order addOrderToCustomer(Customer customer) {
+        Date date = new Date(System.currentTimeMillis() - ((long) (Math.random() * 1000 * 60 * 60 * 24 * 365)));
+        Order order = new Order(null, date, customer.getId());
+        daoSession.insert(order);
+        return order;
+    }
+
+}
diff --git a/DaoExample/src/androidTest/java/de/greenrobot/daoexample/NoteTest.java b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/NoteTest.java
new file mode 100644
index 00000000..ab57058f
--- /dev/null
+++ b/DaoExample/src/androidTest/java/de/greenrobot/daoexample/NoteTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daoexample;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+
+public class NoteTest extends AbstractDaoTestLongPk<NoteDao, Note> {
+
+    public NoteTest() {
+        super(NoteDao.class);
+    }
+
+    @Override
+    protected Note createEntity(Long key) {
+        Note entity = new Note();
+        entity.setId(key);
+        entity.setText("green note"); // Has to be set as it is "not null"
+        return entity;
+    }
+
+}
diff --git a/DaoExample/src/main/AndroidManifest.xml b/DaoExample/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..bc992e06
--- /dev/null
+++ b/DaoExample/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.daoexample" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".NoteActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/DaoExample/src/main/ic_launcher-web.png b/DaoExample/src/main/ic_launcher-web.png
new file mode 100644
index 00000000..4b14629c
Binary files /dev/null and b/DaoExample/src/main/ic_launcher-web.png differ
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Customer.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Customer.java
new file mode 100644
index 00000000..ed2996f7
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Customer.java
@@ -0,0 +1,107 @@
+package de.greenrobot.daoexample;
+
+import java.util.List;
+import de.greenrobot.daoexample.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table CUSTOMER.
+ */
+public class Customer {
+
+    private Long id;
+    /** Not-null value. */
+    private String name;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient CustomerDao myDao;
+
+    private List<Order> orders;
+
+    public Customer() {
+    }
+
+    public Customer(Long id) {
+        this.id = id;
+    }
+
+    public Customer(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getCustomerDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    /** Not-null value. */
+    public String getName() {
+        return name;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<Order> getOrders() {
+        if (orders == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            OrderDao targetDao = daoSession.getOrderDao();
+            List<Order> ordersNew = targetDao._queryCustomer_Orders(id);
+            synchronized (this) {
+                if(orders == null) {
+                    orders = ordersNew;
+                }
+            }
+        }
+        return orders;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetOrders() {
+        orders = null;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/CustomerDao.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/CustomerDao.java
new file mode 100644
index 00000000..25a88fc3
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/CustomerDao.java
@@ -0,0 +1,120 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Customer;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table CUSTOMER.
+*/
+public class CustomerDao extends AbstractDao<Customer, Long> {
+
+    public static final String TABLENAME = "CUSTOMER";
+
+    /**
+     * Properties of entity Customer.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Name = new Property(1, String.class, "name", false, "NAME");
+    };
+
+    private DaoSession daoSession;
+
+
+    public CustomerDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public CustomerDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'NAME' TEXT NOT NULL );"); // 1: name
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CUSTOMER'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Customer entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+        stmt.bindString(2, entity.getName());
+    }
+
+    @Override
+    protected void attachEntity(Customer entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Customer readEntity(Cursor cursor, int offset) {
+        Customer entity = new Customer( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.getString(offset + 1) // name
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Customer entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setName(cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Customer entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Customer entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoMaster.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoMaster.java
new file mode 100644
index 00000000..53627f13
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoMaster.java
@@ -0,0 +1,78 @@
+package de.greenrobot.daoexample;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.daoexample.NoteDao;
+import de.greenrobot.daoexample.CustomerDao;
+import de.greenrobot.daoexample.OrderDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1000): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1000;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        NoteDao.createTable(db, ifNotExists);
+        CustomerDao.createTable(db, ifNotExists);
+        OrderDao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        NoteDao.dropTable(db, ifExists);
+        CustomerDao.dropTable(db, ifExists);
+        OrderDao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(NoteDao.class);
+        registerDaoClass(CustomerDao.class);
+        registerDaoClass(OrderDao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoSession.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoSession.java
new file mode 100644
index 00000000..e6d19f42
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/DaoSession.java
@@ -0,0 +1,77 @@
+package de.greenrobot.daoexample;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Note;
+import de.greenrobot.daoexample.Customer;
+import de.greenrobot.daoexample.Order;
+
+import de.greenrobot.daoexample.NoteDao;
+import de.greenrobot.daoexample.CustomerDao;
+import de.greenrobot.daoexample.OrderDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig noteDaoConfig;
+    private final DaoConfig customerDaoConfig;
+    private final DaoConfig orderDaoConfig;
+
+    private final NoteDao noteDao;
+    private final CustomerDao customerDao;
+    private final OrderDao orderDao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        noteDaoConfig = daoConfigMap.get(NoteDao.class).clone();
+        noteDaoConfig.initIdentityScope(type);
+
+        customerDaoConfig = daoConfigMap.get(CustomerDao.class).clone();
+        customerDaoConfig.initIdentityScope(type);
+
+        orderDaoConfig = daoConfigMap.get(OrderDao.class).clone();
+        orderDaoConfig.initIdentityScope(type);
+
+        noteDao = new NoteDao(noteDaoConfig, this);
+        customerDao = new CustomerDao(customerDaoConfig, this);
+        orderDao = new OrderDao(orderDaoConfig, this);
+
+        registerDao(Note.class, noteDao);
+        registerDao(Customer.class, customerDao);
+        registerDao(Order.class, orderDao);
+    }
+    
+    public void clear() {
+        noteDaoConfig.getIdentityScope().clear();
+        customerDaoConfig.getIdentityScope().clear();
+        orderDaoConfig.getIdentityScope().clear();
+    }
+
+    public NoteDao getNoteDao() {
+        return noteDao;
+    }
+
+    public CustomerDao getCustomerDao() {
+        return customerDao;
+    }
+
+    public OrderDao getOrderDao() {
+        return orderDao;
+    }
+
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Note.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Note.java
new file mode 100644
index 00000000..ed057058
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Note.java
@@ -0,0 +1,63 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table NOTE.
+ */
+public class Note {
+
+    private Long id;
+    /** Not-null value. */
+    private String text;
+    private String comment;
+    private java.util.Date date;
+
+    public Note() {
+    }
+
+    public Note(Long id) {
+        this.id = id;
+    }
+
+    public Note(Long id, String text, String comment, java.util.Date date) {
+        this.id = id;
+        this.text = text;
+        this.comment = comment;
+        this.date = date;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    /** Not-null value. */
+    public String getText() {
+        return text;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setText(String text) {
+        this.text = text;
+    }
+
+    public String getComment() {
+        return comment;
+    }
+
+    public void setComment(String comment) {
+        this.comment = comment;
+    }
+
+    public java.util.Date getDate() {
+        return date;
+    }
+
+    public void setDate(java.util.Date date) {
+        this.date = date;
+    }
+
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/NoteDao.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/NoteDao.java
new file mode 100644
index 00000000..0fcaceee
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/NoteDao.java
@@ -0,0 +1,129 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Note;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table NOTE.
+*/
+public class NoteDao extends AbstractDao<Note, Long> {
+
+    public static final String TABLENAME = "NOTE";
+
+    /**
+     * Properties of entity Note.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+        public final static Property Comment = new Property(2, String.class, "comment", false, "COMMENT");
+        public final static Property Date = new Property(3, java.util.Date.class, "date", false, "DATE");
+    };
+
+
+    public NoteDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public NoteDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT NOT NULL ," + // 1: text
+                "'COMMENT' TEXT," + // 2: comment
+                "'DATE' INTEGER);"); // 3: date
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'NOTE'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Note entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+        stmt.bindString(2, entity.getText());
+ 
+        String comment = entity.getComment();
+        if (comment != null) {
+            stmt.bindString(3, comment);
+        }
+ 
+        java.util.Date date = entity.getDate();
+        if (date != null) {
+            stmt.bindLong(4, date.getTime());
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Note readEntity(Cursor cursor, int offset) {
+        Note entity = new Note( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.getString(offset + 1), // text
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // comment
+            cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)) // date
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Note entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.getString(offset + 1));
+        entity.setComment(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setDate(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Note entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Note entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Order.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Order.java
new file mode 100644
index 00000000..95ecfb86
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/Order.java
@@ -0,0 +1,121 @@
+package de.greenrobot.daoexample;
+
+import de.greenrobot.daoexample.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table ORDERS.
+ */
+public class Order {
+
+    private Long id;
+    private java.util.Date date;
+    private long customerId;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient OrderDao myDao;
+
+    private Customer customer;
+    private Long customer__resolvedKey;
+
+
+    public Order() {
+    }
+
+    public Order(Long id) {
+        this.id = id;
+    }
+
+    public Order(Long id, java.util.Date date, long customerId) {
+        this.id = id;
+        this.date = date;
+        this.customerId = customerId;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getOrderDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public java.util.Date getDate() {
+        return date;
+    }
+
+    public void setDate(java.util.Date date) {
+        this.date = date;
+    }
+
+    public long getCustomerId() {
+        return customerId;
+    }
+
+    public void setCustomerId(long customerId) {
+        this.customerId = customerId;
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public Customer getCustomer() {
+        long __key = this.customerId;
+        if (customer__resolvedKey == null || !customer__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            CustomerDao targetDao = daoSession.getCustomerDao();
+            Customer customerNew = targetDao.load(__key);
+            synchronized (this) {
+                customer = customerNew;
+            	customer__resolvedKey = __key;
+            }
+        }
+        return customer;
+    }
+
+    public void setCustomer(Customer customer) {
+        if (customer == null) {
+            throw new DaoException("To-one property 'customerId' has not-null constraint; cannot set to-one to null");
+        }
+        synchronized (this) {
+            this.customer = customer;
+            customerId = customer.getId();
+            customer__resolvedKey = customerId;
+        }
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoExample/src/main/java-gen/de/greenrobot/daoexample/OrderDao.java b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/OrderDao.java
new file mode 100644
index 00000000..d3ac55a7
--- /dev/null
+++ b/DaoExample/src/main/java-gen/de/greenrobot/daoexample/OrderDao.java
@@ -0,0 +1,243 @@
+package de.greenrobot.daoexample;
+
+import java.util.List;
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+import de.greenrobot.daoexample.Order;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table ORDERS.
+*/
+public class OrderDao extends AbstractDao<Order, Long> {
+
+    public static final String TABLENAME = "ORDERS";
+
+    /**
+     * Properties of entity Order.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Date = new Property(1, java.util.Date.class, "date", false, "DATE");
+        public final static Property CustomerId = new Property(2, long.class, "customerId", false, "CUSTOMER_ID");
+    };
+
+    private DaoSession daoSession;
+
+    private Query<Order> customer_OrdersQuery;
+
+    public OrderDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public OrderDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'DATE' INTEGER," + // 1: date
+                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 2: customerId
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ORDERS'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Order entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        java.util.Date date = entity.getDate();
+        if (date != null) {
+            stmt.bindLong(2, date.getTime());
+        }
+        stmt.bindLong(3, entity.getCustomerId());
+    }
+
+    @Override
+    protected void attachEntity(Order entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Order readEntity(Cursor cursor, int offset) {
+        Order entity = new Order( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // date
+            cursor.getLong(offset + 2) // customerId
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Order entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setDate(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
+        entity.setCustomerId(cursor.getLong(offset + 2));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Order entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Order entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /** Internal query to resolve the "orders" to-many relationship of Customer. */
+    public List<Order> _queryCustomer_Orders(long customerId) {
+        synchronized (this) {
+            if (customer_OrdersQuery == null) {
+                QueryBuilder<Order> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.CustomerId.eq(null));
+                queryBuilder.orderRaw("DATE ASC");
+                customer_OrdersQuery = queryBuilder.build();
+            }
+        }
+        Query<Order> query = customer_OrdersQuery.forCurrentThread();
+        query.setParameter(0, customerId);
+        return query.list();
+    }
+
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getCustomerDao().getAllColumns());
+            builder.append(" FROM ORDERS T");
+            builder.append(" LEFT JOIN CUSTOMER T0 ON T.'CUSTOMER_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected Order loadCurrentDeep(Cursor cursor, boolean lock) {
+        Order entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        Customer customer = loadCurrentOther(daoSession.getCustomerDao(), cursor, offset);
+         if(customer != null) {
+            entity.setCustomer(customer);
+        }
+
+        return entity;    
+    }
+
+    public Order loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<Order> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<Order> list = new ArrayList<Order>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<Order> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<Order> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+}
diff --git a/DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
new file mode 100644
index 00000000..27b063f0
--- /dev/null
+++ b/DaoExample/src/main/java/de/greenrobot/daoexample/NoteActivity.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daoexample;
+
+import android.app.ListActivity;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.inputmethod.EditorInfo;
+import android.widget.EditText;
+import android.widget.ListView;
+import android.widget.SimpleCursorAdapter;
+import android.widget.TextView;
+import android.widget.TextView.OnEditorActionListener;
+
+import java.text.DateFormat;
+import java.util.Date;
+
+import de.greenrobot.daoexample.DaoMaster.DevOpenHelper;
+
+public class NoteActivity extends ListActivity {
+
+    private SQLiteDatabase db;
+
+    private EditText editText;
+
+    private DaoMaster daoMaster;
+    private DaoSession daoSession;
+    private NoteDao noteDao;
+
+    private Cursor cursor;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);
+        db = helper.getWritableDatabase();
+        daoMaster = new DaoMaster(db);
+        daoSession = daoMaster.newSession();
+        noteDao = daoSession.getNoteDao();
+
+        String textColumn = NoteDao.Properties.Text.columnName;
+        String orderBy = textColumn + " COLLATE LOCALIZED ASC";
+        cursor = db.query(noteDao.getTablename(), noteDao.getAllColumns(), null, null, null, null, orderBy);
+        String[] from = { textColumn, NoteDao.Properties.Comment.columnName };
+        int[] to = { android.R.id.text1, android.R.id.text2 };
+
+        SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, cursor, from,
+                to);
+        setListAdapter(adapter);
+
+        editText = (EditText) findViewById(R.id.editTextNote);
+        addUiListeners();
+    }
+
+    protected void addUiListeners() {
+        editText.setOnEditorActionListener(new OnEditorActionListener() {
+
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_DONE) {
+                    addNote();
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        final View button = findViewById(R.id.buttonAdd);
+        button.setEnabled(false);
+        editText.addTextChangedListener(new TextWatcher() {
+
+            @Override
+            public void onTextChanged(CharSequence s, int start, int before, int count) {
+                boolean enable = s.length() != 0;
+                button.setEnabled(enable);
+            }
+
+            @Override
+            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            }
+
+            @Override
+            public void afterTextChanged(Editable s) {
+            }
+        });
+    }
+
+    public void onMyButtonClick(View view) {
+        addNote();
+    }
+
+    private void addNote() {
+        String noteText = editText.getText().toString();
+        editText.setText("");
+
+        final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
+        String comment = "Added on " + df.format(new Date());
+        Note note = new Note(null, noteText, comment, new Date());
+        noteDao.insert(note);
+        Log.d("DaoExample", "Inserted new note, ID: " + note.getId());
+
+        cursor.requery();
+    }
+
+    @Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        noteDao.deleteByKey(id);
+        Log.d("DaoExample", "Deleted note, ID: " + id);
+        cursor.requery();
+    }
+
+}
\ No newline at end of file
diff --git a/DaoExample/src/main/res/drawable-hdpi/ic_launcher.png b/DaoExample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 00000000..c1b44ccc
Binary files /dev/null and b/DaoExample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/DaoExample/src/main/res/drawable-mdpi/ic_launcher.png b/DaoExample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 00000000..a1bf709d
Binary files /dev/null and b/DaoExample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/DaoExample/src/main/res/drawable-xhdpi/ic_launcher.png b/DaoExample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..3b5ae5b2
Binary files /dev/null and b/DaoExample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/DaoExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/DaoExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..b7df51b1
Binary files /dev/null and b/DaoExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/DaoExample/src/main/res/layout/main.xml b/DaoExample/src/main/res/layout/main.xml
new file mode 100644
index 00000000..81641d53
--- /dev/null
+++ b/DaoExample/src/main/res/layout/main.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+	xmlns:android="http://schemas.android.com/apk/res/android"
+	android:orientation="vertical"
+	android:layout_width="fill_parent"
+	android:layout_height="fill_parent">
+	<LinearLayout
+		android:layout_width="fill_parent"
+		android:layout_height="wrap_content"
+		android:id="@+id/linearLayout1"
+		android:orientation="horizontal">
+		<EditText
+			android:layout_height="wrap_content"
+			android:layout_weight="1"
+			android:layout_width="wrap_content"
+			android:inputType="text"
+			android:imeOptions="actionDone"
+			android:id="@+id/editTextNote"
+			android:hint="Enter new note"></EditText>
+		<Button
+			android:layout_height="wrap_content"
+			android:layout_width="wrap_content"
+			android:text="Add"
+			android:id="@+id/buttonAdd"
+			android:onClick="onMyButtonClick"></Button>
+	</LinearLayout>
+	<ListView
+		android:layout_height="wrap_content"
+		android:id="@android:id/list"
+		android:layout_width="fill_parent"></ListView>
+</LinearLayout>
diff --git a/DaoExample/src/main/res/menu/main.xml b/DaoExample/src/main/res/menu/main.xml
new file mode 100644
index 00000000..7fe7424d
--- /dev/null
+++ b/DaoExample/src/main/res/menu/main.xml
@@ -0,0 +1,9 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".MainActivity" >
+    <item android:id="@+id/action_settings"
+        android:title="@string/action_settings"
+        android:orderInCategory="100"
+        app:showAsAction="never" />
+</menu>
diff --git a/DaoExample/src/main/res/values-w820dp/dimens.xml b/DaoExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 00000000..63fc8164
--- /dev/null
+++ b/DaoExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/DaoExample/src/main/res/values/dimens.xml b/DaoExample/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/DaoExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/DaoExample/src/main/res/values/strings.xml b/DaoExample/src/main/res/values/strings.xml
new file mode 100644
index 00000000..a707ed67
--- /dev/null
+++ b/DaoExample/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">DaoExample</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
diff --git a/DaoExample/src/main/res/values/styles.xml b/DaoExample/src/main/res/values/styles.xml
new file mode 100644
index 00000000..766ab993
--- /dev/null
+++ b/DaoExample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/DaoExampleGenerator/.gitignore b/DaoExampleGenerator/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/DaoExampleGenerator/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/DaoExampleGenerator/build.gradle b/DaoExampleGenerator/build.gradle
new file mode 100644
index 00000000..d170e7d3
--- /dev/null
+++ b/DaoExampleGenerator/build.gradle
@@ -0,0 +1,21 @@
+apply plugin: 'java'
+apply plugin: 'application'
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile project(':DaoGenerator')
+}
+
+mainClassName = "de.greenrobot.daogenerator.gentest.ExampleDaoGenerator"
+
+//outputDir = "../DaoTest/src/test/java-gen"
+outputDir = "../DaoExample/src/main/java-gen"
+
+task createDocs {
+    def docs = file(outputDir)
+    docs.mkdirs()
+}
+
+run {
+    args outputDir
+}
\ No newline at end of file
diff --git a/DaoExampleGenerator/src/main/java/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java b/DaoExampleGenerator/src/main/java/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
new file mode 100644
index 00000000..55b083e5
--- /dev/null
+++ b/DaoExampleGenerator/src/main/java/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daogenerator.gentest;
+
+import de.greenrobot.daogenerator.DaoGenerator;
+import de.greenrobot.daogenerator.Entity;
+import de.greenrobot.daogenerator.Property;
+import de.greenrobot.daogenerator.Schema;
+import de.greenrobot.daogenerator.ToMany;
+
+/**
+ * Generates entities and DAOs for the example project DaoExample.
+ * 
+ * Run it as a Java application (not Android).
+ * 
+ * @author Markus
+ */
+public class ExampleDaoGenerator {
+
+    public static void main(String[] args) throws Exception {
+        Schema schema = new Schema(1000, "de.greenrobot.daoexample");
+
+        addNote(schema);
+        addCustomerOrder(schema);
+
+        new DaoGenerator().generateAll(schema, args[0]);
+    }
+
+    private static void addNote(Schema schema) {
+        Entity note = schema.addEntity("Note");
+        note.addIdProperty();
+        note.addStringProperty("text").notNull();
+        note.addStringProperty("comment");
+        note.addDateProperty("date");
+    }
+
+    private static void addCustomerOrder(Schema schema) {
+        Entity customer = schema.addEntity("Customer");
+        customer.addIdProperty();
+        customer.addStringProperty("name").notNull();
+
+        Entity order = schema.addEntity("Order");
+        order.setTableName("ORDERS"); // "ORDER" is a reserved keyword
+        order.addIdProperty();
+        Property orderDate = order.addDateProperty("date").getProperty();
+        Property customerId = order.addLongProperty("customerId").notNull().getProperty();
+        order.addToOne(customer, customerId);
+
+        ToMany customerToOrders = customer.addToMany(order, customerId);
+        customerToOrders.setName("orders");
+        customerToOrders.orderAsc(orderDate);
+    }
+
+}
diff --git a/DaoGenerator/.freemarker-ide.xml b/DaoGenerator/.freemarker-ide.xml
new file mode 100644
index 00000000..d97c2fe2
--- /dev/null
+++ b/DaoGenerator/.freemarker-ide.xml
@@ -0,0 +1,33 @@
+<config>
+	<context-values>
+		<resource path="template/dao-master.ftl">
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
+		<resource path="template/content-provider.ftl">
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+			<value key="contentProvider" object-class="de.greenrobot.daogenerator.ContentProvider"/>
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
+		<resource path="template/dao.ftl">
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
+		<resource path="template/dao-deep.ftl">
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
+		<resource path="template/entity.ftl">
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+		</resource>
+		<resource path="template/dao-unit-test.ftl">
+			<value key="schema" object-class="de.greenrobot.daogenerator.Schema"/>
+			<value key="entity" object-class="de.greenrobot.daogenerator.Entity"/>
+		</resource>
+		<resource path="template/dao.ftl">
+			<value key="table" object-class="de.greenrobot.daogenerator.Entity"/>
+		</resource>
+	</context-values>
+	<macro-library>
+	</macro-library>
+</config>
\ No newline at end of file
diff --git a/DaoGenerator/.gitignore b/DaoGenerator/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/DaoGenerator/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
new file mode 100644
index 00000000..32a28fab
--- /dev/null
+++ b/DaoGenerator/build.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'java'
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile ('org.freemarker:freemarker:2.3.20')
+    testCompile 'junit:junit:4.11'
+}
+
+sourceSets {
+    main {
+        resources.srcDirs = ['template']
+    }
+}
\ No newline at end of file
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ContentProvider.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ContentProvider.java
new file mode 100644
index 00000000..d0483c2d
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ContentProvider.java
@@ -0,0 +1,79 @@
+package de.greenrobot.daogenerator;
+
+import java.util.List;
+
+public class ContentProvider {
+    private final List<Entity> entities;
+    private String authority;
+    private String basePath;
+    private String className;
+    private String javaPackage;
+    private boolean readOnly;
+    private Schema schema;
+
+    public ContentProvider(Schema schema, List<Entity> entities) {
+        this.schema = schema;
+        this.entities = entities;
+    }
+
+    public String getAuthority() {
+        return authority;
+    }
+
+    public void setAuthority(String authority) {
+        this.authority = authority;
+    }
+
+    public String getBasePath() {
+        return basePath;
+    }
+
+    public void setBasePath(String basePath) {
+        this.basePath = basePath;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    public String getJavaPackage() {
+        return javaPackage;
+    }
+
+    public void setJavaPackage(String javaPackage) {
+        this.javaPackage = javaPackage;
+    }
+
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    public void readOnly() {
+        this.readOnly = true;
+    }
+
+    public List<Entity> getEntities() {
+        return entities;
+    }
+
+    public void init2ndPass() {
+        if (authority == null) {
+            authority = schema.getDefaultJavaPackage() + ".provider";
+        }
+        if (basePath == null) {
+            basePath = "";
+        }
+        if (className == null) {
+            className = "EntityContentProvider";
+        }
+        if (javaPackage == null) {
+            javaPackage = schema.getDefaultJavaPackage();
+        }
+
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoGenerator.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoGenerator.java
new file mode 100644
index 00000000..0f9ecdd8
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoGenerator.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import freemarker.template.Configuration;
+import freemarker.template.DefaultObjectWrapper;
+import freemarker.template.Template;
+
+/**
+ * Once you have your model created, use this class to generate entities and DAOs.
+ * 
+ * @author Markus
+ */
+public class DaoGenerator {
+
+    private Pattern patternKeepIncludes;
+    private Pattern patternKeepFields;
+    private Pattern patternKeepMethods;
+
+    private Template templateDao;
+    private Template templateDaoMaster;
+    private Template templateDaoSession;
+    private Template templateEntity;
+    private Template templateDaoUnitTest;
+    private Template templateContentProvider;
+
+    public DaoGenerator() throws IOException {
+        System.out.println("greenDAO Generator");
+        System.out.println("Copyright 2011-2014 Markus Junginger, greenrobot.de. Licensed under GPL V3.");
+        System.out.println("This program comes with ABSOLUTELY NO WARRANTY");
+
+        patternKeepIncludes = compilePattern("INCLUDES");
+        patternKeepFields = compilePattern("FIELDS");
+        patternKeepMethods = compilePattern("METHODS");
+
+        Configuration config = new Configuration();
+        config.setClassForTemplateLoading(this.getClass(), "/");
+        config.setObjectWrapper(new DefaultObjectWrapper());
+
+        templateDao = config.getTemplate("dao.ftl");
+        templateDaoMaster = config.getTemplate("dao-master.ftl");
+        templateDaoSession = config.getTemplate("dao-session.ftl");
+        templateEntity = config.getTemplate("entity.ftl");
+        templateDaoUnitTest = config.getTemplate("dao-unit-test.ftl");
+        templateContentProvider = config.getTemplate("content-provider.ftl");
+    }
+
+    private Pattern compilePattern(String sectionName) {
+        int flags = Pattern.DOTALL | Pattern.MULTILINE;
+        return Pattern.compile(".*^\\s*?//\\s*?KEEP " + sectionName + ".*?\n(.*?)^\\s*// KEEP " + sectionName
+                + " END.*?\n", flags);
+    }
+
+    /** Generates all entities and DAOs for the given schema. */
+    public void generateAll(Schema schema, String outDir) throws Exception {
+        generateAll(schema, outDir, null);
+    }
+
+    /** Generates all entities and DAOs for the given schema. */
+    public void generateAll(Schema schema, String outDir, String outDirTest) throws Exception {
+        long start = System.currentTimeMillis();
+
+        File outDirFile = toFileForceExists(outDir);
+
+        File outDirTestFile = null;
+        if (outDirTest != null) {
+            outDirTestFile = toFileForceExists(outDirTest);
+        }
+
+        schema.init2ndPass();
+        schema.init3ndPass();
+
+        System.out.println("Processing schema version " + schema.getVersion() + "...");
+
+        List<Entity> entities = schema.getEntities();
+        for (Entity entity : entities) {
+            generate(templateDao, outDirFile, entity.getJavaPackageDao(), entity.getClassNameDao(), schema, entity);
+            if (!entity.isProtobuf() && !entity.isSkipGeneration()) {
+                generate(templateEntity, outDirFile, entity.getJavaPackage(), entity.getClassName(), schema, entity);
+            }
+            if (outDirTestFile != null && !entity.isSkipGenerationTest()) {
+                String javaPackageTest = entity.getJavaPackageTest();
+                String classNameTest = entity.getClassNameTest();
+                File javaFilename = toJavaFilename(outDirTestFile, javaPackageTest, classNameTest);
+                if (!javaFilename.exists()) {
+                    generate(templateDaoUnitTest, outDirTestFile, javaPackageTest, classNameTest, schema, entity);
+                } else {
+                    System.out.println("Skipped " + javaFilename.getCanonicalPath());
+                }
+            }
+            for (ContentProvider contentProvider : entity.getContentProviders()) {
+                Map<String, Object> additionalObjectsForTemplate = new HashMap<String, Object>();
+                additionalObjectsForTemplate.put("contentProvider", contentProvider);
+                generate(templateContentProvider, outDirFile, entity.getJavaPackage(), entity.getClassName()
+                        + "ContentProvider", schema, entity, additionalObjectsForTemplate);
+            }
+        }
+        generate(templateDaoMaster, outDirFile, schema.getDefaultJavaPackageDao(), "DaoMaster", schema, null);
+        generate(templateDaoSession, outDirFile, schema.getDefaultJavaPackageDao(), "DaoSession", schema, null);
+
+        long time = System.currentTimeMillis() - start;
+        System.out.println("Processed " + entities.size() + " entities in " + time + "ms");
+    }
+
+    protected File toFileForceExists(String filename) throws IOException {
+        File file = new File(filename);
+        if (!file.exists()) {
+            throw new IOException(filename
+                    + " does not exist. This check is to prevent accidental file generation into a wrong path.");
+        }
+        return file;
+    }
+
+    private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
+            Entity entity) throws Exception {
+        generate(template, outDirFile, javaPackage, javaClassName, schema, entity, null);
+    }
+
+    private void generate(Template template, File outDirFile, String javaPackage, String javaClassName, Schema schema,
+            Entity entity, Map<String, Object> additionalObjectsForTemplate) throws Exception {
+        Map<String, Object> root = new HashMap<String, Object>();
+        root.put("schema", schema);
+        root.put("entity", entity);
+        if (additionalObjectsForTemplate != null) {
+            root.putAll(additionalObjectsForTemplate);
+        }
+        try {
+            File file = toJavaFilename(outDirFile, javaPackage, javaClassName);
+            file.getParentFile().mkdirs();
+
+            if (entity != null && entity.getHasKeepSections()) {
+                checkKeepSections(file, root);
+            }
+
+            Writer writer = new FileWriter(file);
+            try {
+                template.process(root, writer);
+                writer.flush();
+                System.out.println("Written " + file.getCanonicalPath());
+            } finally {
+                writer.close();
+            }
+        } catch (Exception ex) {
+            System.err.println("Data map for template: " + root);
+            System.err.println("Error while generating " + javaPackage + "." + javaClassName + " ("
+                    + outDirFile.getCanonicalPath() + ")");
+            throw ex;
+        }
+    }
+
+    private void checkKeepSections(File file, Map<String, Object> root) {
+        if (file.exists()) {
+            try {
+                String contents = new String(DaoUtil.readAllBytes(file));
+
+                Matcher matcher;
+
+                matcher = patternKeepIncludes.matcher(contents);
+                if (matcher.matches()) {
+                    root.put("keepIncludes", matcher.group(1));
+                }
+
+                matcher = patternKeepFields.matcher(contents);
+                if (matcher.matches()) {
+                    root.put("keepFields", matcher.group(1));
+                }
+
+                matcher = patternKeepMethods.matcher(contents);
+                if (matcher.matches()) {
+                    root.put("keepMethods", matcher.group(1));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    protected File toJavaFilename(File outDirFile, String javaPackage, String javaClassName) {
+        String packageSubPath = javaPackage.replace('.', '/');
+        File packagePath = new File(outDirFile, packageSubPath);
+        File file = new File(packagePath, javaClassName + ".java");
+        return file;
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoUtil.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoUtil.java
new file mode 100644
index 00000000..aae7e250
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/DaoUtil.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/** Internal API */
+public class DaoUtil {
+    public static String dbName(String javaName) {
+        StringBuilder builder = new StringBuilder(javaName);
+        for (int i = 1; i < builder.length(); i++) {
+            boolean lastWasUpper = Character.isUpperCase(builder.charAt(i - 1));
+            boolean isUpper = Character.isUpperCase(builder.charAt(i));
+            if (isUpper && !lastWasUpper) {
+                builder.insert(i, '_');
+                i++;
+            }
+        }
+        return builder.toString().toUpperCase();
+    }
+    
+    public static byte[] readAllBytes(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        copyAllBytes(in, out);
+        return out.toByteArray();
+    }
+    
+    public static byte[] readAllBytes(File file) throws IOException {
+        FileInputStream is = new FileInputStream(file);
+        try {
+            return DaoUtil.readAllBytes(is);
+        } finally {
+            is.close();
+        }
+    }
+    
+    public static byte[] readAllBytes(String filename) throws IOException {
+        FileInputStream is = new FileInputStream(filename);
+        try {
+            return DaoUtil.readAllBytes(is);
+        } finally {
+            is.close();
+        }
+    }
+    
+    /**
+     * Copies all available data from in to out without closing any stream.
+     * 
+     * @return number of bytes copied
+     */
+    public static int copyAllBytes(InputStream in, OutputStream out) throws IOException {
+        int byteCount = 0;
+        byte[] buffer = new byte[4096];
+        while (true) {
+            int read = in.read(buffer);
+            if (read == -1) {
+                break;
+            }
+            out.write(buffer, 0, read);
+            byteCount += read;
+        }
+        return byteCount;
+    }
+    
+
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Entity.java
new file mode 100644
index 00000000..a058b946
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Entity.java
@@ -0,0 +1,619 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import de.greenrobot.daogenerator.Property.PropertyBuilder;
+
+import java.util.*;
+
+/**
+ * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
+ * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link de.greenrobot.daogenerator.Entity} itself). <br/>
+ * <br/> Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
+ * addToMany).<br/> <br/> There are further configuration possibilities: <ul> <li>{@link
+ * de.greenrobot.daogenerator.Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li> <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>Various setXXX methods</li> </ul>
+ *
+ * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
+ * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
+ */
+public class Entity {
+    private final Schema schema;
+    private final String className;
+    private final List<Property> properties;
+    private List<Property> propertiesColumns;
+    private final List<Property> propertiesPk;
+    private final List<Property> propertiesNonPk;
+    private final Set<String> propertyNames;
+    private final List<Index> indexes;
+    private final List<ToOne> toOneRelations;
+    private final List<ToMany> toManyRelations;
+    private final List<ToMany> incomingToManyRelations;
+    private final Collection<String> additionalImportsEntity;
+    private final Collection<String> additionalImportsDao;
+    private final List<String> interfacesToImplement;
+    private final List<ContentProvider> contentProviders;
+
+    private String tableName;
+    private String classNameDao;
+    private String classNameTest;
+    private String javaPackage;
+    private String javaPackageDao;
+    private String javaPackageTest;
+    private Property pkProperty;
+    private String pkType;
+    private String superclass;
+
+    private boolean protobuf;
+    private boolean constructors;
+    private boolean skipGeneration;
+    private boolean skipGenerationTest;
+    private boolean skipTableCreation;
+    private Boolean active;
+    private Boolean hasKeepSections;
+
+    Entity(Schema schema, String className) {
+        this.schema = schema;
+        this.className = className;
+        properties = new ArrayList<Property>();
+        propertiesPk = new ArrayList<Property>();
+        propertiesNonPk = new ArrayList<Property>();
+        propertyNames = new HashSet<String>();
+        indexes = new ArrayList<Index>();
+        toOneRelations = new ArrayList<ToOne>();
+        toManyRelations = new ArrayList<ToMany>();
+        incomingToManyRelations = new ArrayList<ToMany>();
+        additionalImportsEntity = new TreeSet<String>();
+        additionalImportsDao = new TreeSet<String>();
+        interfacesToImplement = new ArrayList<String>();
+        contentProviders = new ArrayList<ContentProvider>();
+        constructors = true;
+    }
+
+    public PropertyBuilder addBooleanProperty(String propertyName) {
+        return addProperty(PropertyType.Boolean, propertyName);
+    }
+
+    public PropertyBuilder addByteProperty(String propertyName) {
+        return addProperty(PropertyType.Byte, propertyName);
+    }
+
+    public PropertyBuilder addShortProperty(String propertyName) {
+        return addProperty(PropertyType.Short, propertyName);
+    }
+
+    public PropertyBuilder addIntProperty(String propertyName) {
+        return addProperty(PropertyType.Int, propertyName);
+    }
+
+    public PropertyBuilder addLongProperty(String propertyName) {
+        return addProperty(PropertyType.Long, propertyName);
+    }
+
+    public PropertyBuilder addFloatProperty(String propertyName) {
+        return addProperty(PropertyType.Float, propertyName);
+    }
+
+    public PropertyBuilder addDoubleProperty(String propertyName) {
+        return addProperty(PropertyType.Double, propertyName);
+    }
+
+    public PropertyBuilder addByteArrayProperty(String propertyName) {
+        return addProperty(PropertyType.ByteArray, propertyName);
+    }
+
+    public PropertyBuilder addStringProperty(String propertyName) {
+        return addProperty(PropertyType.String, propertyName);
+    }
+
+    public PropertyBuilder addDateProperty(String propertyName) {
+        return addProperty(PropertyType.Date, propertyName);
+    }
+
+    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
+        if (!propertyNames.add(propertyName)) {
+            throw new RuntimeException("Property already defined: " + propertyName);
+        }
+        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
+        properties.add(builder.getProperty());
+        return builder;
+    }
+
+    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
+    public PropertyBuilder addIdProperty() {
+        PropertyBuilder builder = addLongProperty("id");
+        builder.columnName("_id").primaryKey();
+        return builder;
+    }
+
+    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
+    public ToMany addToMany(Entity target, Property targetProperty) {
+        Property[] targetProperties = {targetProperty};
+        return addToMany(null, target, targetProperties);
+    }
+
+    /**
+     * Convenience method for {@link de.greenrobot.daogenerator.Entity#addToMany(de.greenrobot.daogenerator.Entity, Property)} with a subsequent call to {@link
+     * ToMany#setName(String)}.
+     */
+    public ToMany addToMany(Entity target, Property targetProperty, String name) {
+        ToMany toMany = addToMany(target, targetProperty);
+        toMany.setName(name);
+        return toMany;
+    }
+
+    /**
+     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
+     * and given source property (of this entity).
+     */
+    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
+        Property[] sourceProperties = {sourceProperty};
+        Property[] targetProperties = {targetProperty};
+        return addToMany(sourceProperties, target, targetProperties);
+    }
+
+    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+        }
+
+        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
+        toManyRelations.add(toMany);
+        target.incomingToManyRelations.add(toMany);
+        return toMany;
+    }
+
+    /**
+     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
+     * to this entity).
+     */
+    public ToOne addToOne(Entity target, Property fkProperty) {
+        if (protobuf) {
+            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+        }
+
+        Property[] fkProperties = {fkProperty};
+        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    /** Convenience for {@link #addToOne(de.greenrobot.daogenerator.Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
+    public ToOne addToOne(Entity target, Property fkProperty, String name) {
+        ToOne toOne = addToOne(target, fkProperty);
+        toOne.setName(name);
+        return toOne;
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
+        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
+    }
+
+    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
+                                         boolean unique) {
+        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
+        if (notNull) {
+            propertyBuilder.notNull();
+        }
+        if (unique) {
+            propertyBuilder.unique();
+        }
+        propertyBuilder.columnName(fkColumnName);
+        Property column = propertyBuilder.getProperty();
+        Property[] fkColumns = {column};
+        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
+        toOne.setName(name);
+        toOneRelations.add(toOne);
+        return toOne;
+    }
+
+    protected void addIncomingToMany(ToMany toMany) {
+        incomingToManyRelations.add(toMany);
+    }
+
+    public ContentProvider addContentProvider() {
+        List<Entity> entities = new ArrayList<Entity>();
+        ContentProvider contentProvider = new ContentProvider(schema, entities);
+        contentProviders.add(contentProvider);
+        return contentProvider;
+    }
+
+    /** Adds a new index to the entity. */
+    public Entity addIndex(Index index) {
+        indexes.add(index);
+        return this;
+    }
+
+    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
+    Entity useProtobuf() {
+        protobuf = true;
+        return this;
+    }
+
+    public boolean isProtobuf() {
+        return protobuf;
+    }
+
+    public Schema getSchema() {
+        return schema;
+    }
+
+    public String getTableName() {
+        return tableName;
+    }
+
+    public void setTableName(String tableName) {
+        this.tableName = tableName;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    public List<Property> getPropertiesColumns() {
+        return propertiesColumns;
+    }
+
+    public String getJavaPackage() {
+        return javaPackage;
+    }
+
+    public void setJavaPackage(String javaPackage) {
+        this.javaPackage = javaPackage;
+    }
+
+    public String getJavaPackageDao() {
+        return javaPackageDao;
+    }
+
+    public void setJavaPackageDao(String javaPackageDao) {
+        this.javaPackageDao = javaPackageDao;
+    }
+
+    public String getClassNameDao() {
+        return classNameDao;
+    }
+
+    public void setClassNameDao(String classNameDao) {
+        this.classNameDao = classNameDao;
+    }
+
+    public String getClassNameTest() {
+        return classNameTest;
+    }
+
+    public void setClassNameTest(String classNameTest) {
+        this.classNameTest = classNameTest;
+    }
+
+    public String getJavaPackageTest() {
+        return javaPackageTest;
+    }
+
+    public void setJavaPackageTest(String javaPackageTest) {
+        this.javaPackageTest = javaPackageTest;
+    }
+
+    public List<Property> getPropertiesPk() {
+        return propertiesPk;
+    }
+
+    public List<Property> getPropertiesNonPk() {
+        return propertiesNonPk;
+    }
+
+    public Property getPkProperty() {
+        return pkProperty;
+    }
+
+    public List<Index> getIndexes() {
+        return indexes;
+    }
+
+    public String getPkType() {
+        return pkType;
+    }
+
+    public boolean isConstructors() {
+        return constructors;
+    }
+
+    public void setConstructors(boolean constructors) {
+        this.constructors = constructors;
+    }
+
+    public boolean isSkipGeneration() {
+        return skipGeneration;
+    }
+
+    /**
+     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
+     * generation.
+     */
+    public void setSkipGeneration(boolean skipGeneration) {
+        this.skipGeneration = skipGeneration;
+    }
+
+    /** Flag if CREATE & DROP TABLE scripts should be skipped in Dao. */
+    public void setSkipTableCreation(boolean skipTableCreation) {
+        this.skipTableCreation = skipTableCreation;
+    }
+
+    public boolean isSkipTableCreation() {
+        return skipTableCreation;
+    }
+
+    public boolean isSkipGenerationTest() {
+        return skipGenerationTest;
+    }
+
+    public void setSkipGenerationTest(boolean skipGenerationTest) {
+        this.skipGenerationTest = skipGenerationTest;
+    }
+
+    public List<ToOne> getToOneRelations() {
+        return toOneRelations;
+    }
+
+    public List<ToMany> getToManyRelations() {
+        return toManyRelations;
+    }
+
+    public List<ToMany> getIncomingToManyRelations() {
+        return incomingToManyRelations;
+    }
+
+    /**
+     * Entities with relations are active, but this method allows to make the entities active even if it does not have
+     * relations.
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    public Boolean getActive() {
+        return active;
+    }
+
+    public Boolean getHasKeepSections() {
+        return hasKeepSections;
+    }
+
+    public Collection<String> getAdditionalImportsEntity() {
+        return additionalImportsEntity;
+    }
+
+    public Collection<String> getAdditionalImportsDao() {
+        return additionalImportsDao;
+    }
+
+    public void setHasKeepSections(Boolean hasKeepSections) {
+        this.hasKeepSections = hasKeepSections;
+    }
+
+    public List<String> getInterfacesToImplement() {
+        return interfacesToImplement;
+    }
+
+    public List<ContentProvider> getContentProviders() {
+        return contentProviders;
+    }
+
+    public void implementsInterface(String... interfaces) {
+        for (String interfaceToImplement : interfaces) {
+            interfacesToImplement.add(interfaceToImplement);
+        }
+    }
+
+    public void implementsSerializable() {
+        interfacesToImplement.add("java.io.Serializable");
+    }
+
+    public String getSuperclass() {
+        return superclass;
+    }
+
+    public void setSuperclass(String classToExtend) {
+        this.superclass = classToExtend;
+    }
+
+    void init2ndPass() {
+        init2nPassNamesWithDefaults();
+
+        for (int i = 0; i < properties.size(); i++) {
+            Property property = properties.get(i);
+            property.setOrdinal(i);
+            property.init2ndPass();
+            if (property.isPrimaryKey()) {
+                propertiesPk.add(property);
+            } else {
+                propertiesNonPk.add(property);
+            }
+        }
+
+        if (propertiesPk.size() == 1) {
+            pkProperty = propertiesPk.get(0);
+            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
+        } else {
+            pkType = "Void";
+        }
+
+        propertiesColumns = new ArrayList<Property>(properties);
+        for (ToOne toOne : toOneRelations) {
+            toOne.init2ndPass();
+            Property[] fkProperties = toOne.getFkProperties();
+            for (Property fkProperty : fkProperties) {
+                if (!propertiesColumns.contains(fkProperty)) {
+                    propertiesColumns.add(fkProperty);
+                }
+            }
+        }
+
+        for (ToMany toMany : toManyRelations) {
+            toMany.init2ndPass();
+            // Source Properties may not be virtual, so we do not need the following code:
+            // for (Property sourceProperty : toMany.getSourceProperties()) {
+            // if (!propertiesColumns.contains(sourceProperty)) {
+            // propertiesColumns.add(sourceProperty);
+            // }
+            // }
+        }
+
+        if (active == null) {
+            active = schema.isUseActiveEntitiesByDefault();
+        }
+        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
+
+        if (hasKeepSections == null) {
+            hasKeepSections = schema.isHasKeepSectionsByDefault();
+        }
+
+        init2ndPassIndexNamesWithDefaults();
+
+        for (ContentProvider contentProvider : contentProviders) {
+            contentProvider.init2ndPass();
+        }
+    }
+
+    protected void init2nPassNamesWithDefaults() {
+        if (tableName == null) {
+            tableName = DaoUtil.dbName(className);
+        }
+
+        if (classNameDao == null) {
+            classNameDao = className + "Dao";
+        }
+        if (classNameTest == null) {
+            classNameTest = className + "Test";
+        }
+
+        if (javaPackage == null) {
+            javaPackage = schema.getDefaultJavaPackage();
+        }
+
+        if (javaPackageDao == null) {
+            javaPackageDao = schema.getDefaultJavaPackageDao();
+            if (javaPackageDao == null) {
+                javaPackageDao = javaPackage;
+            }
+        }
+        if (javaPackageTest == null) {
+            javaPackageTest = schema.getDefaultJavaPackageTest();
+            if (javaPackageTest == null) {
+                javaPackageTest = javaPackage;
+            }
+        }
+    }
+
+    protected void init2ndPassIndexNamesWithDefaults() {
+        for (int i = 0; i < indexes.size(); i++) {
+            Index index = indexes.get(i);
+            if (index.getName() == null) {
+                String indexName = "IDX_" + getTableName();
+                List<Property> properties = index.getProperties();
+                for (int j = 0; j < properties.size(); j++) {
+                    Property property = properties.get(j);
+                    indexName += "_" + property.getColumnName();
+                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
+                        indexName += "_DESC";
+                    }
+                }
+                // TODO can this get too long? how to shorten reliably without depending on the order (i)
+                index.setName(indexName);
+            }
+        }
+    }
+
+    void init3ndPass() {
+        for (Property property : properties) {
+            property.init3ndPass();
+        }
+
+        init3rdPassRelations();
+        init3rdPassAdditionalImports();
+    }
+
+    private void init3rdPassRelations() {
+        Set<String> toOneNames = new HashSet<String>();
+        for (ToOne toOne : toOneRelations) {
+            toOne.init3ndPass();
+            if (!toOneNames.add(toOne.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toOne);
+            }
+        }
+
+        Set<String> toManyNames = new HashSet<String>();
+        for (ToMany toMany : toManyRelations) {
+            toMany.init3ndPass();
+            Entity targetEntity = toMany.getTargetEntity();
+            for (Property targetProperty : toMany.getTargetProperties()) {
+                if (!targetEntity.propertiesColumns.contains(targetProperty)) {
+                    targetEntity.propertiesColumns.add(targetProperty);
+                }
+            }
+            if (!toManyNames.add(toMany.getName().toLowerCase())) {
+                throw new RuntimeException("Duplicate name for " + toMany);
+            }
+        }
+    }
+
+    private void init3rdPassAdditionalImports() {
+        if (active && !javaPackage.equals(javaPackageDao)) {
+            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
+        }
+
+        for (ToOne toOne : toOneRelations) {
+            Entity targetEntity = toOne.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+            // For deep loading
+            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
+                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+            }
+        }
+
+        for (ToMany toMany : toManyRelations) {
+            Entity targetEntity = toMany.getTargetEntity();
+            checkAdditionalImportsEntityTargetEntity(targetEntity);
+        }
+    }
+
+    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
+        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+        }
+        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
+            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
+        }
+    }
+
+    public void validatePropertyExists(Property property) {
+        if (!properties.contains(property)) {
+            throw new RuntimeException("Property " + property + " does not exist in " + this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Entity " + className + " (package: " + javaPackage + ")";
+    }
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Index.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Index.java
new file mode 100644
index 00000000..a7d48f5c
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Index.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+
+public class Index extends PropertyOrderList {
+    private String name;
+    private boolean unique;
+
+    public String getName() {
+        return name;
+    }
+
+    public Index setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public Index makeUnique() {
+        unique = true;
+        return this;
+    }
+
+    public boolean isUnique() {
+        return unique;
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Property.java
new file mode 100644
index 00000000..7547cd9c
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Property.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** Model class for an entity's property: a Java property mapped to a data base column. */
+public class Property {
+
+    public static class PropertyBuilder {
+        private final Property property;
+
+        public PropertyBuilder(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
+            property = new Property(schema, entity, propertyType, propertyName);
+        }
+
+        public PropertyBuilder columnName(String columnName) {
+            property.columnName = columnName;
+            return this;
+        }
+
+        public PropertyBuilder columnType(String columnType) {
+            property.columnType = columnType;
+            return this;
+        }
+
+        public PropertyBuilder primaryKey() {
+            property.primaryKey = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyAsc() {
+            property.primaryKey = true;
+            property.pkAsc = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyDesc() {
+            property.primaryKey = true;
+            property.pkDesc = true;
+            return this;
+        }
+
+        public PropertyBuilder autoincrement() {
+            if (!property.primaryKey || property.propertyType != PropertyType.Long) {
+                throw new RuntimeException(
+                        "AUTOINCREMENT is only available to primary key properties of type long/Long");
+            }
+            property.pkAutoincrement = true;
+            return this;
+        }
+
+        public PropertyBuilder unique() {
+            property.unique = true;
+            return this;
+        }
+
+        public PropertyBuilder notNull() {
+            property.notNull = true;
+            return this;
+        }
+
+        public PropertyBuilder index() {
+            Index index = new Index();
+            index.addProperty(property);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexAsc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyAsc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexDesc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyDesc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public Property getProperty() {
+            return property;
+        }
+    }
+
+    private final Schema schema;
+    private final Entity entity;
+    private PropertyType propertyType;
+    private final String propertyName;
+
+    private String columnName;
+    private String columnType;
+
+    private boolean primaryKey;
+    private boolean pkAsc;
+    private boolean pkDesc;
+    private boolean pkAutoincrement;
+
+    private boolean unique;
+    private boolean notNull;
+
+    /** Initialized in 2nd pass */
+    private String constraints;
+
+    private int ordinal;
+
+    private String javaType;
+
+    public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
+        this.schema = schema;
+        this.entity = entity;
+        this.propertyName = propertyName;
+        this.propertyType = propertyType;
+    }
+
+    public String getPropertyName() {
+        return propertyName;
+    }
+
+    public PropertyType getPropertyType() {
+        return propertyType;
+    }
+
+    public void setPropertyType(PropertyType propertyType) {
+        this.propertyType = propertyType;
+    }
+
+    public String getColumnName() {
+        return columnName;
+    }
+
+    public String getColumnType() {
+        return columnType;
+    }
+
+    public boolean isPrimaryKey() {
+        return primaryKey;
+    }
+
+    public boolean isAutoincrement() {
+        return pkAutoincrement;
+    }
+
+    public String getConstraints() {
+        return constraints;
+    }
+
+    public boolean isUnique() {
+        return unique;
+    }
+
+    public boolean isNotNull() {
+        return notNull;
+    }
+
+    public String getJavaType() {
+        return javaType;
+    }
+
+    public int getOrdinal() {
+        return ordinal;
+    }
+
+    public void setOrdinal(int ordinal) {
+        this.ordinal = ordinal;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    void init2ndPass() {
+        initConstraint();
+        if (columnType == null) {
+            columnType = schema.mapToDbType(propertyType);
+        }
+        if (columnName == null) {
+            columnName = DaoUtil.dbName(propertyName);
+        }
+        if (notNull) {
+            javaType = schema.mapToJavaTypeNotNull(propertyType);
+        } else {
+            javaType = schema.mapToJavaTypeNullable(propertyType);
+        }
+    }
+
+    private void initConstraint() {
+        StringBuilder constraintBuilder = new StringBuilder();
+        if (primaryKey) {
+            constraintBuilder.append("PRIMARY KEY");
+            if (pkAsc) {
+                constraintBuilder.append(" ASC");
+            }
+            if (pkDesc) {
+                constraintBuilder.append(" DESC");
+            }
+            if (pkAutoincrement) {
+                constraintBuilder.append(" AUTOINCREMENT");
+            }
+        }
+        // Always have String PKs NOT NULL because SQLite is pretty strange in this respect:
+        // One could insert multiple rows with NULL PKs
+        if (notNull || (primaryKey && propertyType == PropertyType.String)) {
+            constraintBuilder.append(" NOT NULL");
+        }
+        if (unique) {
+            constraintBuilder.append(" UNIQUE");
+        }
+        String newContraints = constraintBuilder.toString().trim();
+        if (constraintBuilder.length() > 0) {
+            constraints = newContraints;
+        }
+    }
+
+    void init3ndPass() {
+        // Nothing to do so far
+    }
+
+    @Override
+    public String toString() {
+        return "Property " + propertyName + " of " + entity.getClassName();
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyOrderList.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyOrderList.java
new file mode 100644
index 00000000..71a0db62
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyOrderList.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PropertyOrderList {
+    private List<Property> properties;
+    private List<String> propertiesOrder;
+
+    public PropertyOrderList() {
+        properties = new ArrayList<Property>();
+        propertiesOrder = new ArrayList<String>();
+    }
+
+    public void addProperty(Property property) {
+        properties.add(property);
+        propertiesOrder.add(null);
+    }
+
+    public void addPropertyAsc(Property property) {
+        properties.add(property);
+        propertiesOrder.add("ASC");
+    }
+
+    public void addPropertyDesc(Property property) {
+        properties.add(property);
+        propertiesOrder.add("DESC");
+    }
+
+    public void addOrderRaw(String order) {
+        properties.add(null);
+        propertiesOrder.add(order);
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    List<String> getPropertiesOrder() {
+        return propertiesOrder;
+    }
+
+    public String getCommaSeparatedString() {
+        StringBuilder builder = new StringBuilder();
+        int size = properties.size();
+        for (int i = 0; i < size; i++) {
+            Property property = properties.get(i);
+            String order = propertiesOrder.get(i);
+            if (property != null) {
+                builder.append(property.getColumnName()).append(' ');
+            }
+            if (order != null) {
+                builder.append(order);
+            }
+            if (i < size - 1) {
+                builder.append(',');
+            }
+        }
+        return builder.toString();
+    }
+
+    public boolean isEmpty() {
+        return properties.isEmpty();
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyType.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyType.java
new file mode 100644
index 00000000..db10eaf9
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/PropertyType.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/**
+ * Currently available types for properties.
+ * 
+ * @author Markus
+ */
+public enum PropertyType {
+    Byte, Short, Int, Long, Boolean, Float, Double, String, ByteArray, Date
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Query.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Query.java
new file mode 100644
index 00000000..8929d7fb
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Query.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** NOT IMPLEMENTED YET. Check back later. */
+public class Query {
+    @SuppressWarnings("unused")
+    private String name;
+    private List<QueryParam> parameters;
+    @SuppressWarnings("unused")
+    private boolean distinct;
+
+    public Query(String name) {
+        this.name = name;
+        parameters= new ArrayList<QueryParam>();
+    }
+    
+    public QueryParam addEqualsParam(Property column) {
+        return addParam(column, "=");
+    }
+
+    public QueryParam addParam(Property column, String operator) {
+        QueryParam queryParam = new QueryParam(column, operator);
+        parameters.add(queryParam);
+        return queryParam;
+    }
+    
+    public void distinct() {
+        distinct = true;
+    }
+
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/QueryParam.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/QueryParam.java
new file mode 100644
index 00000000..b775dffc
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/QueryParam.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** NOT IMPLEMENTED YET. Check back later. */
+public class QueryParam {
+    private Property column;
+    private String operator;
+    
+    public QueryParam(Property column, String operator) {
+        this.column = column;
+        this.operator = operator;
+    }
+
+    public Property getColumn() {
+        return column;
+    }
+
+    public String getOperator() {
+        return operator;
+    }
+    
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Schema.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Schema.java
new file mode 100644
index 00000000..b9c59362
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/Schema.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * The "root" model class to which you can add entities to.
+ * 
+ * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
+ */
+public class Schema {
+    private final int version;
+    private final String defaultJavaPackage;
+    private String defaultJavaPackageDao;
+    private String defaultJavaPackageTest;
+    private final List<Entity> entities;
+    private Map<PropertyType, String> propertyToDbType;
+    private Map<PropertyType, String> propertyToJavaTypeNotNull;
+    private Map<PropertyType, String> propertyToJavaTypeNullable;
+    private boolean hasKeepSectionsByDefault;
+    private boolean useActiveEntitiesByDefault;
+
+    public Schema(int version, String defaultJavaPackage) {
+        this.version = version;
+        this.defaultJavaPackage = defaultJavaPackage;
+        this.entities = new ArrayList<Entity>();
+        initTypeMappings();
+    }
+
+    public void enableKeepSectionsByDefault() {
+        hasKeepSectionsByDefault = true;
+    }
+
+    public void enableActiveEntitiesByDefault() {
+        useActiveEntitiesByDefault = true;
+    }
+
+    private void initTypeMappings() {
+        propertyToDbType = new HashMap<PropertyType, String>();
+        propertyToDbType.put(PropertyType.Boolean, "INTEGER");
+        propertyToDbType.put(PropertyType.Byte, "INTEGER");
+        propertyToDbType.put(PropertyType.Short, "INTEGER");
+        propertyToDbType.put(PropertyType.Int, "INTEGER");
+        propertyToDbType.put(PropertyType.Long, "INTEGER");
+        propertyToDbType.put(PropertyType.Float, "REAL");
+        propertyToDbType.put(PropertyType.Double, "REAL");
+        propertyToDbType.put(PropertyType.String, "TEXT");
+        propertyToDbType.put(PropertyType.ByteArray, "BLOB");
+        propertyToDbType.put(PropertyType.Date, "INTEGER");
+
+        propertyToJavaTypeNotNull = new HashMap<PropertyType, String>();
+        propertyToJavaTypeNotNull.put(PropertyType.Boolean, "boolean");
+        propertyToJavaTypeNotNull.put(PropertyType.Byte, "byte");
+        propertyToJavaTypeNotNull.put(PropertyType.Short, "short");
+        propertyToJavaTypeNotNull.put(PropertyType.Int, "int");
+        propertyToJavaTypeNotNull.put(PropertyType.Long, "long");
+        propertyToJavaTypeNotNull.put(PropertyType.Float, "float");
+        propertyToJavaTypeNotNull.put(PropertyType.Double, "double");
+        propertyToJavaTypeNotNull.put(PropertyType.String, "String");
+        propertyToJavaTypeNotNull.put(PropertyType.ByteArray, "byte[]");
+        propertyToJavaTypeNotNull.put(PropertyType.Date, "java.util.Date");
+
+        propertyToJavaTypeNullable = new HashMap<PropertyType, String>();
+        propertyToJavaTypeNullable.put(PropertyType.Boolean, "Boolean");
+        propertyToJavaTypeNullable.put(PropertyType.Byte, "Byte");
+        propertyToJavaTypeNullable.put(PropertyType.Short, "Short");
+        propertyToJavaTypeNullable.put(PropertyType.Int, "Integer");
+        propertyToJavaTypeNullable.put(PropertyType.Long, "Long");
+        propertyToJavaTypeNullable.put(PropertyType.Float, "Float");
+        propertyToJavaTypeNullable.put(PropertyType.Double, "Double");
+        propertyToJavaTypeNullable.put(PropertyType.String, "String");
+        propertyToJavaTypeNullable.put(PropertyType.ByteArray, "byte[]");
+        propertyToJavaTypeNullable.put(PropertyType.Date, "java.util.Date");
+    }
+
+    /**
+     * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
+     * per table to create table scripts, etc.
+     */
+    public Entity addEntity(String className) {
+        Entity entity = new Entity(this, className);
+        entities.add(entity);
+        return entity;
+    }
+
+    /**
+     * Adds a new protocol buffers entity to the schema. There can be multiple entities per table, but only one may be
+     * the primary entity per table to create table scripts, etc.
+     */
+    public Entity addProtobufEntity(String className) {
+        Entity entity = addEntity(className);
+        entity.useProtobuf();
+        return entity;
+    }
+
+    public String mapToDbType(PropertyType propertyType) {
+        return mapType(propertyToDbType, propertyType);
+    }
+
+    public String mapToJavaTypeNullable(PropertyType propertyType) {
+        return mapType(propertyToJavaTypeNullable, propertyType);
+    }
+
+    public String mapToJavaTypeNotNull(PropertyType propertyType) {
+        return mapType(propertyToJavaTypeNotNull, propertyType);
+    }
+
+    private String mapType(Map<PropertyType, String> map, PropertyType propertyType) {
+        String dbType = map.get(propertyType);
+        if (dbType == null) {
+            throw new IllegalStateException("No mapping for " + propertyType);
+        }
+        return dbType;
+    }
+
+    public int getVersion() {
+        return version;
+    }
+
+    public String getDefaultJavaPackage() {
+        return defaultJavaPackage;
+    }
+
+    public String getDefaultJavaPackageDao() {
+        return defaultJavaPackageDao;
+    }
+
+    public void setDefaultJavaPackageDao(String defaultJavaPackageDao) {
+        this.defaultJavaPackageDao = defaultJavaPackageDao;
+    }
+
+    public String getDefaultJavaPackageTest() {
+        return defaultJavaPackageTest;
+    }
+
+    public void setDefaultJavaPackageTest(String defaultJavaPackageTest) {
+        this.defaultJavaPackageTest = defaultJavaPackageTest;
+    }
+
+    public List<Entity> getEntities() {
+        return entities;
+    }
+
+    public boolean isHasKeepSectionsByDefault() {
+        return hasKeepSectionsByDefault;
+    }
+
+    public boolean isUseActiveEntitiesByDefault() {
+        return useActiveEntitiesByDefault;
+    }
+
+    void init2ndPass() {
+        if (defaultJavaPackageDao == null) {
+            defaultJavaPackageDao = defaultJavaPackage;
+        }
+        if (defaultJavaPackageTest == null) {
+            defaultJavaPackageTest = defaultJavaPackageDao;
+        }
+        for (Entity entity : entities) {
+            entity.init2ndPass();
+        }
+    }
+
+    void init3ndPass() {
+        for (Entity entity : entities) {
+            entity.init3ndPass();
+        }
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToMany.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToMany.java
new file mode 100644
index 00000000..a923059d
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToMany.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+import java.util.List;
+
+/** To-many relationship from a source entity to many target entitites. */
+public class ToMany {
+    @SuppressWarnings("unused")
+    private final Schema schema;
+    private String name;
+    private final Entity sourceEntity;
+    private final Entity targetEntity;
+    private Property[] sourceProperties;
+    private final Property[] targetProperties;
+    private final PropertyOrderList propertyOrderList;
+
+    public ToMany(Schema schema, Entity sourceEntity, Property[] sourceProperties, Entity targetEntity,
+            Property[] targetProperties) {
+        this.schema = schema;
+        this.sourceEntity = sourceEntity;
+        this.targetEntity = targetEntity;
+        this.sourceProperties = sourceProperties;
+        this.targetProperties = targetProperties;
+        propertyOrderList = new PropertyOrderList();
+    }
+
+    public Entity getSourceEntity() {
+        return sourceEntity;
+    }
+
+    public Entity getTargetEntity() {
+        return targetEntity;
+    }
+
+    public Property[] getSourceProperties() {
+        return sourceProperties;
+    }
+
+    public void setSourceProperties(Property[] sourceProperties) {
+        this.sourceProperties = sourceProperties;
+    }
+
+    public Property[] getTargetProperties() {
+        return targetProperties;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
+     * to-many relationship).
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /** Property of target entity used for ascending order. */
+    public void orderAsc(Property... properties) {
+        for (Property property : properties) {
+            targetEntity.validatePropertyExists(property);
+            propertyOrderList.addPropertyAsc(property);
+        }
+    }
+
+    /** Property of target entity used for descending order. */
+    public void orderDesc(Property... properties) {
+        for (Property property : properties) {
+            targetEntity.validatePropertyExists(property);
+            propertyOrderList.addPropertyDesc(property);
+        }
+    }
+
+    public String getOrder() {
+        if (propertyOrderList.isEmpty()) {
+            return null;
+        } else {
+            return propertyOrderList.getCommaSeparatedString();
+        }
+    }
+
+    void init2ndPass() {
+        if (name == null) {
+            char[] nameCharArray = targetEntity.getClassName().toCharArray();
+            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
+            name = new String(nameCharArray) + "List";
+        }
+        if (sourceProperties == null) {
+            List<Property> pks = sourceEntity.getPropertiesPk();
+            if (pks.isEmpty()) {
+                throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
+            }
+            sourceProperties = new Property[pks.size()];
+            sourceProperties = pks.toArray(sourceProperties);
+        }
+        int count = sourceProperties.length;
+        if (count != targetProperties.length) {
+            throw new RuntimeException("Source properties do not match target properties: " + this);
+        }
+
+        for (int i = 0; i < count; i++) {
+            Property sourceProperty = sourceProperties[i];
+            Property targetProperty = targetProperties[i];
+
+            PropertyType sourceType = sourceProperty.getPropertyType();
+            PropertyType targetType = targetProperty.getPropertyType();
+            if (sourceType == null || targetType == null) {
+                throw new RuntimeException("Property type uninitialized");
+            }
+            if (sourceType != targetType) {
+                System.err.println("Warning to-one property type does not match target key type: " + this);
+            }
+        }
+    }
+
+    void init3ndPass() {
+    }
+
+    @Override
+    public String toString() {
+        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
+        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
+        return "ToMany '" + name + "' from " + sourceName + " to " + targetName;
+    }
+
+}
diff --git a/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToOne.java b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToOne.java
new file mode 100644
index 00000000..2a71e5f5
--- /dev/null
+++ b/DaoGenerator/src/main/java/de/greenrobot/daogenerator/ToOne.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator;
+
+/** To-one relationship from a source entity to one (or zero) target entity. */
+public class ToOne {
+    private final Schema schema;
+    private final Entity sourceEntity;
+    private final Entity targetEntity;
+    private final Property[] fkProperties;
+    private final String[] resolvedKeyJavaType;
+    private final boolean[] resolvedKeyUseEquals;
+    private String name;
+    private final boolean useFkProperty;
+
+    public ToOne(Schema schema, Entity sourceEntity, Entity targetEntity, Property[] fkProperties, boolean useFkProperty) {
+        this.schema = schema;
+        this.sourceEntity = sourceEntity;
+        this.targetEntity = targetEntity;
+        this.fkProperties = fkProperties;
+        this.useFkProperty = useFkProperty;
+        resolvedKeyJavaType = new String[fkProperties.length];
+        resolvedKeyUseEquals = new boolean[fkProperties.length];
+    }
+
+    public Entity getSourceEntity() {
+        return sourceEntity;
+    }
+
+    public Entity getTargetEntity() {
+        return targetEntity;
+    }
+
+    public Property[] getFkProperties() {
+        return fkProperties;
+    }
+
+    public String[] getResolvedKeyJavaType() {
+        return resolvedKeyJavaType;
+    }
+
+    public boolean[] getResolvedKeyUseEquals() {
+        return resolvedKeyUseEquals;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Sets the name of the relation, which is used as the property name in the entity (the source entity owning the
+     * to-many relationship).
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public boolean isUseFkProperty() {
+        return useFkProperty;
+    }
+
+    void init2ndPass() {
+        if (name == null) {
+            char[] nameCharArray = targetEntity.getClassName().toCharArray();
+            nameCharArray[0] = Character.toLowerCase(nameCharArray[0]);
+            name = new String(nameCharArray);
+        }
+
+    }
+
+    /** Constructs fkColumns. Depends on 2nd pass of target key properties. */
+    void init3ndPass() {
+
+        Property targetPkProperty = targetEntity.getPkProperty();
+        if (fkProperties.length != 1 || targetPkProperty == null) {
+            throw new RuntimeException("Currently only single FK columns are supported: " + this);
+        }
+
+        Property property = fkProperties[0];
+        PropertyType propertyType = property.getPropertyType();
+        if (propertyType == null) {
+            propertyType = targetPkProperty.getPropertyType();
+            property.setPropertyType(propertyType);
+            // Property is not a regular property with primitive getters/setters, so let it catch up
+            property.init2ndPass();
+            property.init3ndPass();
+        } else if (propertyType != targetPkProperty.getPropertyType()) {
+            System.err.println("Warning to-one property type does not match target key type: " + this);
+        }
+        resolvedKeyJavaType[0] = schema.mapToJavaTypeNullable(propertyType);
+        resolvedKeyUseEquals[0] = checkUseEquals(propertyType);
+    }
+
+    protected boolean checkUseEquals(PropertyType propertyType) {
+        boolean useEquals;
+        switch (propertyType) {
+        case Byte:
+        case Short:
+        case Int:
+        case Long:
+        case Boolean:
+        case Float:
+            useEquals = true;
+            break;
+        default:
+            useEquals = false;
+            break;
+        }
+        return useEquals;
+    }
+
+    @Override
+    public String toString() {
+        String sourceName = sourceEntity != null ? sourceEntity.getClassName() : null;
+        String targetName = targetEntity != null ? targetEntity.getClassName() : null;
+        return "ToOne '" + name + "' from " + sourceName + " to " + targetName;
+    }
+
+}
diff --git a/DaoGenerator/src/test/java/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java b/DaoGenerator/src/test/java/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java
new file mode 100644
index 00000000..97936809
--- /dev/null
+++ b/DaoGenerator/src/test/java/de/greenrobot/daogenerator/test/SimpleDaoGeneratorTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daogenerator.test;
+
+import org.junit.Test;
+
+import java.io.File;
+
+import de.greenrobot.daogenerator.DaoGenerator;
+import de.greenrobot.daogenerator.DaoUtil;
+import de.greenrobot.daogenerator.Entity;
+import de.greenrobot.daogenerator.Property;
+import de.greenrobot.daogenerator.Schema;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class SimpleDaoGeneratorTest {
+
+    @Test
+    public void testMinimalSchema() throws Exception {
+        Schema schema = new Schema(1, "de.greenrobot.testdao");
+        Entity adressTable = schema.addEntity("Adresse");
+        Property idProperty = adressTable.addIdProperty().getProperty();
+        adressTable.addIntProperty("count").index();
+        adressTable.addIntProperty("dummy").notNull();
+        assertEquals(1, schema.getEntities().size());
+        assertEquals(3, adressTable.getProperties().size());
+
+        File daoFile = new File("test-out/de/greenrobot/testdao/" + adressTable.getClassName() + "Dao.java");
+        daoFile.delete();
+        assertFalse(daoFile.exists());
+
+        new DaoGenerator().generateAll(schema, "test-out");
+
+        assertEquals("PRIMARY KEY", idProperty.getConstraints());
+        assertTrue(daoFile.toString(), daoFile.exists());
+    }
+
+    @Test
+    public void testDbName() {
+        assertEquals("NORMAL", DaoUtil.dbName("normal"));
+        assertEquals("NORMAL", DaoUtil.dbName("Normal"));
+        assertEquals("CAMEL_CASE", DaoUtil.dbName("CamelCase"));
+        assertEquals("CAMEL_CASE_THREE", DaoUtil.dbName("CamelCaseThree"));
+        assertEquals("CAMEL_CASE_XXXX", DaoUtil.dbName("CamelCaseXXXX"));
+    }
+
+}
diff --git a/DaoGenerator/template/content-provider.ftl b/DaoGenerator/template/content-provider.ftl
new file mode 100644
index 00000000..93396f73
--- /dev/null
+++ b/DaoGenerator/template/content-provider.ftl
@@ -0,0 +1,217 @@
+package ${contentProvider.javaPackage};
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import de.greenrobot.dao.DaoLog;
+
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+/* Copy this code snippet into your AndroidManifest.xml inside the
+<application> element:
+
+    <provider
+            android:name="${contentProvider.javaPackage}.${contentProvider.className}"
+            android:authorities="${contentProvider.authority}"/>
+    */
+
+    public class ${contentProvider.className} extends ContentProvider {
+
+    public static final String AUTHORITY = "${contentProvider.authority}";
+    public static final String BASE_PATH = "${contentProvider.basePath}";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+    + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+    + "/" + BASE_PATH;
+
+    private static final String TABLENAME = ${entity.classNameDao}.TABLENAME;
+    private static final String PK = ${entity.classNameDao}.Properties.${entity.pkProperty.propertyName?cap_first}
+    .columnName;
+
+<#assign counter = 0>
+    private static final int ${entity.className?upper_case}_DIR = ${counter};
+    private static final int ${entity.className?upper_case}_ID = ${counter+1};
+
+    private static final UriMatcher sURIMatcher;
+
+    static {
+    sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH, ${entity.className?upper_case}_DIR);
+    sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", ${entity.className?upper_case}_ID);
+    }
+
+    /**
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static DaoSession daoSession;
+
+    @Override
+    public boolean onCreate() {
+    // if(daoSession == null) {
+    // throw new IllegalStateException("DaoSession must be set before content provider is created");
+    // }
+    DaoLog.d("Content Provider started: " + CONTENT_URI);
+    return true;
+    }
+
+    protected SQLiteDatabase getDatabase() {
+    if(daoSession == null) {
+    throw new IllegalStateException("DaoSession must be set during content provider is active");
+    }
+    return daoSession.getDatabase();
+    }
+
+<#--
+##########################################
+########## Insert ##############
+##########################################
+-->
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    long id = 0;
+    String path = "";
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    id = getDatabase().insert(TABLENAME, null, values);
+    path = BASE_PATH + "/" + id;
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return Uri.parse(path);
+</#if>
+    }
+
+<#--
+##########################################
+########## Delete ##############
+##########################################
+-->
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    SQLiteDatabase db = getDatabase();
+    int rowsDeleted = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsDeleted = db.delete(TABLENAME, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id, null);
+    } else {
+    rowsDeleted = db.delete(TABLENAME, PK + "=" + id + " and "
+    + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsDeleted;
+</#if>
+    }
+
+<#--
+##########################################
+########## Update ##############
+##########################################
+-->
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+    String[] selectionArgs) {
+<#if contentProvider.isReadOnly()>
+    throw new UnsupportedOperationException("This content provider is readonly");
+<#else>
+    int uriType = sURIMatcher.match(uri);
+    SQLiteDatabase db = getDatabase();
+    int rowsUpdated = 0;
+    String id;
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    rowsUpdated = db.update(TABLENAME, values, selection, selectionArgs);
+    break;
+    case ${entity.className?upper_case}_ID:
+    id = uri.getLastPathSegment();
+    if (TextUtils.isEmpty(selection)) {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id, null);
+    } else {
+    rowsUpdated = db.update(TABLENAME, values, PK + "=" + id
+    + " and " + selection, selectionArgs);
+    }
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+    getContext().getContentResolver().notifyChange(uri, null);
+    return rowsUpdated;
+</#if>
+    }
+<#--
+##########################################
+########## Query ##############
+##########################################
+-->
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+    String[] selectionArgs, String sortOrder) {
+
+    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+    int uriType = sURIMatcher.match(uri);
+    switch (uriType) {
+    case ${entity.className?upper_case}_DIR:
+    queryBuilder.setTables(TABLENAME);
+    break;
+    case ${entity.className?upper_case}_ID:
+    queryBuilder.setTables(TABLENAME);
+    queryBuilder.appendWhere(PK + "="
+    + uri.getLastPathSegment());
+    break;
+    default:
+    throw new IllegalArgumentException("Unknown URI: " + uri);
+    }
+
+    SQLiteDatabase db = getDatabase();
+    Cursor cursor = queryBuilder.query(db, projection, selection,
+    selectionArgs, null, null, sortOrder);
+    cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+    return cursor;
+    }
+
+<#--
+##########################################
+########## GetType ##############
+##########################################
+-->
+    @Override
+    public final String getType(Uri uri) {
+    switch (sURIMatcher.match(uri)) {
+    case ${entity.className?upper_case}_DIR:
+    return CONTENT_TYPE;
+    case ${entity.className?upper_case}_ID:
+    return CONTENT_ITEM_TYPE;
+    default :
+    throw new IllegalArgumentException("Unsupported URI: " + uri);
+    }
+    }
+    }
diff --git a/DaoGenerator/template/dao-deep.ftl b/DaoGenerator/template/dao-deep.ftl
new file mode 100644
index 00000000..70587e1e
--- /dev/null
+++ b/DaoGenerator/template/dao-deep.ftl
@@ -0,0 +1,129 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#if entity.toOneRelations?has_content>
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+<#list entity.toOneRelations as toOne>
+            SqlUtils.appendColumns(builder, "T${toOne_index}", daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns());
+<#if toOne_has_next>
+            builder.append(',');
+</#if>
+</#list>
+            builder.append(" FROM ${entity.tableName} T");
+<#list entity.toOneRelations as toOne>
+            builder.append(" LEFT JOIN ${toOne.targetEntity.tableName} T${toOne_index}<#--
+--> ON T.'${toOne.fkProperties[0].columnName}'=T${toOne_index}.'${toOne.targetEntity.pkProperty.columnName}'");
+</#list>
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
+        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+<#list entity.toOneRelations as toOne>
+        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+<#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
+    </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
+<#if toOne.fkProperties[0].notNull>
+        }
+</#if>
+<#if toOne_has_next>
+        offset += daoSession.get${toOne.targetEntity.classNameDao}().getAllColumns().length;
+</#if>
+
+</#list>
+        return entity;    
+    }
+
+    public ${entity.className} loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+</#if>
\ No newline at end of file
diff --git a/DaoGenerator/template/dao-master.ftl b/DaoGenerator/template/dao-master.ftl
new file mode 100644
index 00000000..adaffc48
--- /dev/null
+++ b/DaoGenerator/template/dao-master.ftl
@@ -0,0 +1,101 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao};
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao};
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version ${schema.version?c}): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = ${schema.version?c};
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.createTable(db, ifNotExists);
+</#if>
+</#list>
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+<#list schema.entities as entity>
+<#if !entity.skipTableCreation>
+        ${entity.classNameDao}.dropTable(db, ifExists);
+</#if>
+</#list>
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+<#list schema.entities as entity>
+        registerDaoClass(${entity.classNameDao}.class);
+</#list>
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoGenerator/template/dao-session.ftl b/DaoGenerator/template/dao-session.ftl
new file mode 100644
index 00000000..e0201a48
--- /dev/null
+++ b/DaoGenerator/template/dao-session.ftl
@@ -0,0 +1,87 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${schema.defaultJavaPackageDao};
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+<#list schema.entities as entity>
+import ${entity.javaPackage}.${entity.className};
+</#list>
+
+<#list schema.entities as entity>
+import ${entity.javaPackageDao}.${entity.classNameDao};
+</#list>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+<#list schema.entities as entity>
+    private final DaoConfig ${entity.classNameDao?uncap_first}Config;
+</#list>        
+
+<#list schema.entities as entity>
+    private final ${entity.classNameDao} ${entity.classNameDao?uncap_first};
+</#list>        
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config = daoConfigMap.get(${entity.classNameDao}.class).clone();
+        ${entity.classNameDao?uncap_first}Config.initIdentityScope(type);
+
+</#list>        
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first} = new ${entity.classNameDao}<#--
+-->(${entity.classNameDao?uncap_first}Config, this);
+</#list>        
+
+<#list schema.entities as entity>
+        registerDao(${entity.className}.class, ${entity.classNameDao?uncap_first});
+</#list>        
+    }
+    
+    public void clear() {
+<#list schema.entities as entity>
+        ${entity.classNameDao?uncap_first}Config.getIdentityScope().clear();
+</#list>    
+    }
+
+<#list schema.entities as entity>
+    public ${entity.classNameDao} get${entity.classNameDao?cap_first}() {
+        return ${entity.classNameDao?uncap_first};
+    }
+
+</#list>        
+}
diff --git a/DaoGenerator/template/dao-unit-test.ftl b/DaoGenerator/template/dao-unit-test.ftl
new file mode 100644
index 00000000..9e9d9c51
--- /dev/null
+++ b/DaoGenerator/template/dao-unit-test.ftl
@@ -0,0 +1,53 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${entity.javaPackageTest};
+
+<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
+<#if isStringPK>
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+<#else>
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+</#if>
+
+import ${entity.javaPackage}.${entity.className};
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+public class ${entity.classNameTest} extends <#if
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+
+    public ${entity.classNameTest}() {
+        super(${entity.classNameDao}.class);
+    }
+
+    @Override
+    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.className} entity = new ${entity.className}();
+<#if entity.pkProperty??>
+        entity.set${entity.pkProperty.propertyName?cap_first}(key);
+</#if>
+<#list entity.properties as property>
+<#if property.notNull>
+        entity.set${property.propertyName?cap_first}();
+</#if> 
+</#list>
+        return entity;
+    }
+
+}
diff --git a/DaoGenerator/template/dao.ftl b/DaoGenerator/template/dao.ftl
new file mode 100644
index 00000000..443f74dc
--- /dev/null
+++ b/DaoGenerator/template/dao.ftl
@@ -0,0 +1,302 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
+package ${entity.javaPackageDao};
+
+<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.toOneRelations?has_content>
+import java.util.ArrayList;
+</#if>
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+<#if entity.toOneRelations?has_content>
+import de.greenrobot.dao.internal.SqlUtils;
+</#if>
+import de.greenrobot.dao.internal.DaoConfig;
+<#if entity.incomingToManyRelations?has_content>
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+</#if>
+
+<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+
+</#if>
+<#if entity.additionalImportsDao?has_content>
+<#list entity.additionalImportsDao as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+import ${entity.javaPackage}.${entity.className};
+<#if entity.protobuf>
+import ${entity.javaPackage}.${entity.className}.Builder;
+</#if>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table ${entity.tableName}.
+*/
+public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
+
+    public static final String TABLENAME = "${entity.tableName}";
+
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+<#list entity.propertiesColumns as property>
+        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
+</#list>
+    };
+
+<#if entity.active>
+    private DaoSession daoSession;
+
+</#if>
+<#list entity.incomingToManyRelations as toMany>
+    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
+</#list>
+
+    public ${entity.classNameDao}(DaoConfig config) {
+        super(config);
+    }
+    
+    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+<#if entity.active>        
+        this.daoSession = daoSession;
+</#if>
+    }
+
+<#if !entity.skipTableCreation>
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
+<#list entity.propertiesColumns as property>
+                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
+</#list>
+<#if entity.indexes?has_content >
+        // Add Indexes
+<#list entity.indexes as index>
+        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
+                " (<#list index.properties 
+as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
+</#list>
+</#if>         
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
+        db.execSQL(sql);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+        stmt.clearBindings();
+<#list entity.properties as property>
+<#if property.notNull || entity.protobuf>
+<#if entity.protobuf>
+        if(entity.has${property.propertyName?cap_first}()) {
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
+     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+<#if entity.protobuf>
+        }
+</#if>
+<#else> <#-- nullable, non-protobuff -->
+        ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
+        if (${property.propertyName} != null) {
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
+ property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+        }
+</#if>
+</#list>
+<#list entity.toOneRelations as toOne>
+<#if !toOne.fkProperties?has_content>
+
+        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        if(${toOne.name} != null) {
+            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+<#if !toOne.targetEntity.pkProperty.notNull>
+            if(${toOne.name}__targetKey != null) {
+                // TODO bind ${toOne.name}__targetKey
+            }
+<#else>
+            // TODO bind ${toOne.name}__targetKey
+</#if>
+        }
+</#if>
+</#list>
+    }
+
+<#if entity.active>
+    @Override
+    protected void attachEntity(${entity.className} entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} readKey(Cursor cursor, int offset) {
+<#if entity.pkProperty??>
+        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
+            entity.pkProperty.propertyType == "Date">)</#if>;
+<#else>
+        return null;
+</#if>  
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ${entity.className} readEntity(Cursor cursor, int offset) {
+<#if entity.protobuf>
+        Builder builder = ${entity.className}.newBuilder();
+<#list entity.properties as property>
+<#if !property.notNull>
+        if (!cursor.isNull(offset + ${property_index})) {
+    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
+<#if !property.notNull>
+        }
+</#if>        
+</#list>        
+        return builder.build();
+<#elseif entity.constructors>
+<#--
+############################## readEntity non-protobuff, constructor ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}( //
+<#list entity.properties as property>
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+            property.propertyType == "Byte">(byte) </#if><#if
+            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Boolean"> != 0</#if><#if
+            property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
+</#list>        
+        );
+        return entity;
+<#else>
+<#--
+############################## readEntity non-protobuff, setters ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}();
+        readEntity(cursor, entity, offset);
+        return entity;
+</#if>
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+<#if entity.protobuf>
+        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
+<#else> 
+<#list entity.properties as property>
+        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+            property.propertyType == "Byte">(byte) </#if><#if
+            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Boolean"> != 0</#if><#if
+            property.propertyType == "Date">)</#if>);
+</#list>
+</#if>
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.propertyType == "Long">
+<#if !entity.protobuf>
+        entity.set${entity.pkProperty.propertyName?cap_first}(rowId);
+</#if>
+        return rowId;
+<#else>
+        return entity.get${entity.pkProperty.propertyName?cap_first}();
+</#if>
+<#else>
+        // Unsupported or missing PK type
+        return null;
+</#if>
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} getKey(${entity.className} entity) {
+<#if entity.pkProperty??>
+        if(entity != null) {
+            return entity.get${entity.pkProperty.propertyName?cap_first}();
+        } else {
+            return null;
+        }
+<#else>
+        return null;
+</#if>    
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return ${(!entity.protobuf)?string};
+    }
+    
+<#list entity.incomingToManyRelations as toMany>
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
+    public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+        synchronized (this) {
+            if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
+                QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+<#list toMany.targetProperties as property>
+                queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(null));
+</#list>
+<#if toMany.order?has_content>
+                queryBuilder.orderRaw("${toMany.order}");
+</#if>
+                ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+            }
+        }
+        Query<${toMany.targetEntity.className}> query = ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
+<#list toMany.targetProperties as property>
+        query.setParameter(${property_index}, ${property.propertyName});
+</#list>
+        return query.list();
+    }
+
+</#list>   
+<#if entity.toOneRelations?has_content>
+    <#include "dao-deep.ftl">
+</#if>
+}
diff --git a/DaoGenerator/template/entity.ftl b/DaoGenerator/template/entity.ftl
new file mode 100644
index 00000000..e40c0a18
--- /dev/null
+++ b/DaoGenerator/template/entity.ftl
@@ -0,0 +1,260 @@
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign complexTypes = ["String", "ByteArray", "Date"]/>
+package ${entity.javaPackage};
+
+<#if entity.toManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.active>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+</#if>
+<#if entity.additionalImportsEntity?has_content>
+<#list entity.additionalImportsEntity as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
+<#else>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+</#if>
+/**
+ * Entity mapped to table ${entity.tableName}.
+ */
+public class ${entity.className}<#if
+entity.superclass?has_content> extends ${entity.superclass} </#if><#if
+entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
+as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
+
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    private ${property.javaType} ${property.propertyName};
+</#list>
+
+<#if entity.active>
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient ${entity.classNameDao} myDao;
+
+<#list entity.toOneRelations as toOne>
+    private ${toOne.targetEntity.className} ${toOne.name};
+<#if toOne.useFkProperty>
+    private ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+<#else>
+    private boolean ${toOne.name}__refreshed;
+</#if>
+
+</#list>
+<#list entity.toManyRelations as toMany>
+    private List<${toMany.targetEntity.className}> ${toMany.name};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP FIELDS - put your custom fields here
+${keepFields!}    // KEEP FIELDS END
+
+</#if>
+<#if entity.constructors>
+    public ${entity.className}() {
+    }
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
+
+    public ${entity.className}(<#list entity.propertiesPk as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.propertiesPk as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+    public ${entity.className}(<#list entity.properties as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.properties as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+<#if entity.active>
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    }
+
+</#if>
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    public ${property.javaType} get${property.propertyName?cap_first}() {
+        return ${property.propertyName};
+    }
+
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+</#if>
+    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
+        this.${property.propertyName} = ${property.propertyName};
+    }
+
+</#list>
+<#--
+##########################################
+########## To-One Relations ##############
+##########################################
+-->
+<#list entity.toOneRelations as toOne>
+    /** To-one relationship, resolved on first access. */
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+<#if toOne.useFkProperty>
+        ${toOne.fkProperties[0].javaType} __key = this.${toOne.fkProperties[0].propertyName};
+        if (${toOne.name}__resolvedKey == null || <#--
+        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(__key)<#--
+        --><#else>${toOne.name}__resolvedKey != __key</#if>) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            ${toOne.targetEntity.className} ${toOne.name}New = targetDao.load(__key);
+            synchronized (this) {
+                ${toOne.name} = ${toOne.name}New;
+            	${toOne.name}__resolvedKey = __key;
+            }
+        }
+<#else>
+        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            targetDao.refresh(${toOne.name});
+            ${toOne.name}__refreshed = true;
+        }
+</#if>
+        return ${toOne.name};
+    }
+<#if !toOne.useFkProperty>
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
+        return ${toOne.name};
+    }
+</#if>
+
+    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
+<#if toOne.fkProperties[0].notNull>
+        if (${toOne.name} == null) {
+            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
+        }
+</#if>
+        synchronized (this) {
+            this.${toOne.name} = ${toOne.name};
+<#if toOne.useFkProperty>        
+            ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
+            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+<#else>
+            ${toOne.name}__refreshed = true;
+</#if>
+        }
+    }
+
+</#list>
+<#--
+##########################################
+########## To-Many Relations #############
+##########################################
+-->
+<#list entity.toManyRelations as toMany>
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+        if (${toMany.name} == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
+            List<${toMany.targetEntity.className}> ${toMany.name}New = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
+            synchronized (this) {<#-- Check if another thread was faster, we cannot lock while doing the query to prevent deadlocks -->
+                if(${toMany.name} == null) {
+                    ${toMany.name} = ${toMany.name}New;
+                }
+            }
+        }
+        return ${toMany.name};
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void reset${toMany.name?cap_first}() {
+        ${toMany.name} = null;
+    }
+
+</#list>
+<#--
+##########################################
+########## Active entity operations ######
+##########################################
+-->
+<#if entity.active>
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP METHODS - put your custom methods here
+${keepMethods!}    // KEEP METHODS END
+
+</#if>
+}
diff --git a/DaoTest/.gitignore b/DaoTest/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/DaoTest/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
new file mode 100644
index 00000000..1c10b3d5
--- /dev/null
+++ b/DaoTest/build.gradle
@@ -0,0 +1,33 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 21
+    buildToolsVersion "21.0.2"
+
+    defaultConfig {
+//        applicationId "de.greenrobot.greendao"
+        minSdkVersion 15
+        targetSdkVersion 21
+        versionCode 1
+        versionName "1.0"
+        testApplicationId "de.greenrobot.daotest"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    sourceSets {
+        androidTest {
+            java.srcDirs = ['src/androidTest/java','src/androidTest/java-gen']
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile project(":DaoCore")
+}
diff --git a/DaoTest/proguard-rules.pro b/DaoTest/proguard-rules.pro
new file mode 100644
index 00000000..4777754c
--- /dev/null
+++ b/DaoTest/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in G:\android-studio-2\sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntity.java
new file mode 100644
index 00000000..e441334f
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntity.java
@@ -0,0 +1,140 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table ABCDEF_ENTITY.
+ */
+public class AbcdefEntity {
+
+    private Long id;
+    private Integer a;
+    private Integer b;
+    private Integer c;
+    private Integer d;
+    private Integer e;
+    private Integer f;
+    private Integer g;
+    private Integer h;
+    private Integer j;
+    private Integer i;
+    private Integer k;
+
+    public AbcdefEntity() {
+    }
+
+    public AbcdefEntity(Long id) {
+        this.id = id;
+    }
+
+    public AbcdefEntity(Long id, Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g, Integer h, Integer j, Integer i, Integer k) {
+        this.id = id;
+        this.a = a;
+        this.b = b;
+        this.c = c;
+        this.d = d;
+        this.e = e;
+        this.f = f;
+        this.g = g;
+        this.h = h;
+        this.j = j;
+        this.i = i;
+        this.k = k;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Integer getA() {
+        return a;
+    }
+
+    public void setA(Integer a) {
+        this.a = a;
+    }
+
+    public Integer getB() {
+        return b;
+    }
+
+    public void setB(Integer b) {
+        this.b = b;
+    }
+
+    public Integer getC() {
+        return c;
+    }
+
+    public void setC(Integer c) {
+        this.c = c;
+    }
+
+    public Integer getD() {
+        return d;
+    }
+
+    public void setD(Integer d) {
+        this.d = d;
+    }
+
+    public Integer getE() {
+        return e;
+    }
+
+    public void setE(Integer e) {
+        this.e = e;
+    }
+
+    public Integer getF() {
+        return f;
+    }
+
+    public void setF(Integer f) {
+        this.f = f;
+    }
+
+    public Integer getG() {
+        return g;
+    }
+
+    public void setG(Integer g) {
+        this.g = g;
+    }
+
+    public Integer getH() {
+        return h;
+    }
+
+    public void setH(Integer h) {
+        this.h = h;
+    }
+
+    public Integer getJ() {
+        return j;
+    }
+
+    public void setJ(Integer j) {
+        this.j = j;
+    }
+
+    public Integer getI() {
+        return i;
+    }
+
+    public void setI(Integer i) {
+        this.i = i;
+    }
+
+    public Integer getK() {
+        return k;
+    }
+
+    public void setK(Integer k) {
+        this.k = k;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntityDao.java
new file mode 100644
index 00000000..63bcfc74
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AbcdefEntityDao.java
@@ -0,0 +1,205 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.AbcdefEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table ABCDEF_ENTITY.
+*/
+public class AbcdefEntityDao extends AbstractDao<AbcdefEntity, Long> {
+
+    public static final String TABLENAME = "ABCDEF_ENTITY";
+
+    /**
+     * Properties of entity AbcdefEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property A = new Property(1, Integer.class, "a", false, "A");
+        public final static Property B = new Property(2, Integer.class, "b", false, "B");
+        public final static Property C = new Property(3, Integer.class, "c", false, "C");
+        public final static Property D = new Property(4, Integer.class, "d", false, "D");
+        public final static Property E = new Property(5, Integer.class, "e", false, "E");
+        public final static Property F = new Property(6, Integer.class, "f", false, "F");
+        public final static Property G = new Property(7, Integer.class, "g", false, "G");
+        public final static Property H = new Property(8, Integer.class, "h", false, "H");
+        public final static Property J = new Property(9, Integer.class, "j", false, "J");
+        public final static Property I = new Property(10, Integer.class, "i", false, "I");
+        public final static Property K = new Property(11, Integer.class, "k", false, "K");
+    };
+
+
+    public AbcdefEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public AbcdefEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'ABCDEF_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'A' INTEGER," + // 1: a
+                "'B' INTEGER," + // 2: b
+                "'C' INTEGER," + // 3: c
+                "'D' INTEGER," + // 4: d
+                "'E' INTEGER," + // 5: e
+                "'F' INTEGER," + // 6: f
+                "'G' INTEGER," + // 7: g
+                "'H' INTEGER," + // 8: h
+                "'J' INTEGER," + // 9: j
+                "'I' INTEGER," + // 10: i
+                "'K' INTEGER);"); // 11: k
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ABCDEF_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, AbcdefEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Integer a = entity.getA();
+        if (a != null) {
+            stmt.bindLong(2, a);
+        }
+ 
+        Integer b = entity.getB();
+        if (b != null) {
+            stmt.bindLong(3, b);
+        }
+ 
+        Integer c = entity.getC();
+        if (c != null) {
+            stmt.bindLong(4, c);
+        }
+ 
+        Integer d = entity.getD();
+        if (d != null) {
+            stmt.bindLong(5, d);
+        }
+ 
+        Integer e = entity.getE();
+        if (e != null) {
+            stmt.bindLong(6, e);
+        }
+ 
+        Integer f = entity.getF();
+        if (f != null) {
+            stmt.bindLong(7, f);
+        }
+ 
+        Integer g = entity.getG();
+        if (g != null) {
+            stmt.bindLong(8, g);
+        }
+ 
+        Integer h = entity.getH();
+        if (h != null) {
+            stmt.bindLong(9, h);
+        }
+ 
+        Integer j = entity.getJ();
+        if (j != null) {
+            stmt.bindLong(10, j);
+        }
+ 
+        Integer i = entity.getI();
+        if (i != null) {
+            stmt.bindLong(11, i);
+        }
+ 
+        Integer k = entity.getK();
+        if (k != null) {
+            stmt.bindLong(12, k);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public AbcdefEntity readEntity(Cursor cursor, int offset) {
+        AbcdefEntity entity = new AbcdefEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1), // a
+            cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2), // b
+            cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3), // c
+            cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4), // d
+            cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5), // e
+            cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6), // f
+            cursor.isNull(offset + 7) ? null : cursor.getInt(offset + 7), // g
+            cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8), // h
+            cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9), // j
+            cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10), // i
+            cursor.isNull(offset + 11) ? null : cursor.getInt(offset + 11) // k
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, AbcdefEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setA(cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1));
+        entity.setB(cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2));
+        entity.setC(cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3));
+        entity.setD(cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4));
+        entity.setE(cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5));
+        entity.setF(cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6));
+        entity.setG(cursor.isNull(offset + 7) ? null : cursor.getInt(offset + 7));
+        entity.setH(cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8));
+        entity.setJ(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));
+        entity.setI(cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10));
+        entity.setK(cursor.isNull(offset + 11) ? null : cursor.getInt(offset + 11));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(AbcdefEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(AbcdefEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntity.java
new file mode 100644
index 00000000..bcd27a00
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntity.java
@@ -0,0 +1,80 @@
+package de.greenrobot.daotest;
+
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table AN_ACTIVE_ENTITY.
+ */
+public class AnActiveEntity {
+
+    private Long id;
+    private String text;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient AnActiveEntityDao myDao;
+
+
+    public AnActiveEntity() {
+    }
+
+    public AnActiveEntity(Long id) {
+        this.id = id;
+    }
+
+    public AnActiveEntity(Long id, String text) {
+        this.id = id;
+        this.text = text;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getAnActiveEntityDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getText() {
+        return text;
+    }
+
+    public void setText(String text) {
+        this.text = text;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntityDao.java
new file mode 100644
index 00000000..21837b20
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AnActiveEntityDao.java
@@ -0,0 +1,124 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.AnActiveEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table AN_ACTIVE_ENTITY.
+*/
+public class AnActiveEntityDao extends AbstractDao<AnActiveEntity, Long> {
+
+    public static final String TABLENAME = "AN_ACTIVE_ENTITY";
+
+    /**
+     * Properties of entity AnActiveEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+    };
+
+    private DaoSession daoSession;
+
+
+    public AnActiveEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public AnActiveEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'AN_ACTIVE_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT);"); // 1: text
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AN_ACTIVE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, AnActiveEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String text = entity.getText();
+        if (text != null) {
+            stmt.bindString(2, text);
+        }
+    }
+
+    @Override
+    protected void attachEntity(AnActiveEntity entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public AnActiveEntity readEntity(Cursor cursor, int offset) {
+        AnActiveEntity entity = new AnActiveEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // text
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, AnActiveEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(AnActiveEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(AnActiveEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntity.java
new file mode 100644
index 00000000..cc81483c
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntity.java
@@ -0,0 +1,26 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table AUTOINCREMENT_ENTITY.
+ */
+public class AutoincrementEntity {
+
+    private Long id;
+
+    public AutoincrementEntity() {
+    }
+
+    public AutoincrementEntity(Long id) {
+        this.id = id;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
new file mode 100644
index 00000000..344db8df
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
@@ -0,0 +1,106 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.AutoincrementEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table AUTOINCREMENT_ENTITY.
+*/
+public class AutoincrementEntityDao extends AbstractDao<AutoincrementEntity, Long> {
+
+    public static final String TABLENAME = "AUTOINCREMENT_ENTITY";
+
+    /**
+     * Properties of entity AutoincrementEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+    };
+
+
+    public AutoincrementEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public AutoincrementEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'AUTOINCREMENT_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY AUTOINCREMENT );"); // 0: id
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AUTOINCREMENT_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, AutoincrementEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public AutoincrementEntity readEntity(Cursor cursor, int offset) {
+        AutoincrementEntity entity = new AutoincrementEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0) // id
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, AutoincrementEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(AutoincrementEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(AutoincrementEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoMaster.java
new file mode 100644
index 00000000..b68069c5
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoMaster.java
@@ -0,0 +1,124 @@
+package de.greenrobot.daotest;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.DateEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.TreeEntityDao;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+import de.greenrobot.daotest.AutoincrementEntityDao;
+import de.greenrobot.daotest.SqliteMasterDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        SimpleEntityDao.createTable(db, ifNotExists);
+        SimpleEntityNotNullDao.createTable(db, ifNotExists);
+        TestEntityDao.createTable(db, ifNotExists);
+        RelationEntityDao.createTable(db, ifNotExists);
+        DateEntityDao.createTable(db, ifNotExists);
+        SpecialNamesEntityDao.createTable(db, ifNotExists);
+        AbcdefEntityDao.createTable(db, ifNotExists);
+        ToManyTargetEntityDao.createTable(db, ifNotExists);
+        ToManyEntityDao.createTable(db, ifNotExists);
+        TreeEntityDao.createTable(db, ifNotExists);
+        AnActiveEntityDao.createTable(db, ifNotExists);
+        ExtendsImplementsEntityDao.createTable(db, ifNotExists);
+        StringKeyValueEntityDao.createTable(db, ifNotExists);
+        AutoincrementEntityDao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        SimpleEntityDao.dropTable(db, ifExists);
+        SimpleEntityNotNullDao.dropTable(db, ifExists);
+        TestEntityDao.dropTable(db, ifExists);
+        RelationEntityDao.dropTable(db, ifExists);
+        DateEntityDao.dropTable(db, ifExists);
+        SpecialNamesEntityDao.dropTable(db, ifExists);
+        AbcdefEntityDao.dropTable(db, ifExists);
+        ToManyTargetEntityDao.dropTable(db, ifExists);
+        ToManyEntityDao.dropTable(db, ifExists);
+        TreeEntityDao.dropTable(db, ifExists);
+        AnActiveEntityDao.dropTable(db, ifExists);
+        ExtendsImplementsEntityDao.dropTable(db, ifExists);
+        StringKeyValueEntityDao.dropTable(db, ifExists);
+        AutoincrementEntityDao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(SimpleEntityDao.class);
+        registerDaoClass(SimpleEntityNotNullDao.class);
+        registerDaoClass(TestEntityDao.class);
+        registerDaoClass(RelationEntityDao.class);
+        registerDaoClass(DateEntityDao.class);
+        registerDaoClass(SpecialNamesEntityDao.class);
+        registerDaoClass(AbcdefEntityDao.class);
+        registerDaoClass(ToManyTargetEntityDao.class);
+        registerDaoClass(ToManyEntityDao.class);
+        registerDaoClass(TreeEntityDao.class);
+        registerDaoClass(AnActiveEntityDao.class);
+        registerDaoClass(ExtendsImplementsEntityDao.class);
+        registerDaoClass(StringKeyValueEntityDao.class);
+        registerDaoClass(AutoincrementEntityDao.class);
+        registerDaoClass(SqliteMasterDao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoSession.java
new file mode 100644
index 00000000..0a9a8e95
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DaoSession.java
@@ -0,0 +1,245 @@
+package de.greenrobot.daotest;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.daotest.TreeEntity;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.daotest.AutoincrementEntity;
+import de.greenrobot.daotest.SqliteMaster;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.TestEntityDao;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.DateEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.TreeEntityDao;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+import de.greenrobot.daotest.AutoincrementEntityDao;
+import de.greenrobot.daotest.SqliteMasterDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig simpleEntityDaoConfig;
+    private final DaoConfig simpleEntityNotNullDaoConfig;
+    private final DaoConfig testEntityDaoConfig;
+    private final DaoConfig relationEntityDaoConfig;
+    private final DaoConfig dateEntityDaoConfig;
+    private final DaoConfig specialNamesEntityDaoConfig;
+    private final DaoConfig abcdefEntityDaoConfig;
+    private final DaoConfig toManyTargetEntityDaoConfig;
+    private final DaoConfig toManyEntityDaoConfig;
+    private final DaoConfig treeEntityDaoConfig;
+    private final DaoConfig anActiveEntityDaoConfig;
+    private final DaoConfig extendsImplementsEntityDaoConfig;
+    private final DaoConfig stringKeyValueEntityDaoConfig;
+    private final DaoConfig autoincrementEntityDaoConfig;
+    private final DaoConfig sqliteMasterDaoConfig;
+
+    private final SimpleEntityDao simpleEntityDao;
+    private final SimpleEntityNotNullDao simpleEntityNotNullDao;
+    private final TestEntityDao testEntityDao;
+    private final RelationEntityDao relationEntityDao;
+    private final DateEntityDao dateEntityDao;
+    private final SpecialNamesEntityDao specialNamesEntityDao;
+    private final AbcdefEntityDao abcdefEntityDao;
+    private final ToManyTargetEntityDao toManyTargetEntityDao;
+    private final ToManyEntityDao toManyEntityDao;
+    private final TreeEntityDao treeEntityDao;
+    private final AnActiveEntityDao anActiveEntityDao;
+    private final ExtendsImplementsEntityDao extendsImplementsEntityDao;
+    private final StringKeyValueEntityDao stringKeyValueEntityDao;
+    private final AutoincrementEntityDao autoincrementEntityDao;
+    private final SqliteMasterDao sqliteMasterDao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        simpleEntityDaoConfig = daoConfigMap.get(SimpleEntityDao.class).clone();
+        simpleEntityDaoConfig.initIdentityScope(type);
+
+        simpleEntityNotNullDaoConfig = daoConfigMap.get(SimpleEntityNotNullDao.class).clone();
+        simpleEntityNotNullDaoConfig.initIdentityScope(type);
+
+        testEntityDaoConfig = daoConfigMap.get(TestEntityDao.class).clone();
+        testEntityDaoConfig.initIdentityScope(type);
+
+        relationEntityDaoConfig = daoConfigMap.get(RelationEntityDao.class).clone();
+        relationEntityDaoConfig.initIdentityScope(type);
+
+        dateEntityDaoConfig = daoConfigMap.get(DateEntityDao.class).clone();
+        dateEntityDaoConfig.initIdentityScope(type);
+
+        specialNamesEntityDaoConfig = daoConfigMap.get(SpecialNamesEntityDao.class).clone();
+        specialNamesEntityDaoConfig.initIdentityScope(type);
+
+        abcdefEntityDaoConfig = daoConfigMap.get(AbcdefEntityDao.class).clone();
+        abcdefEntityDaoConfig.initIdentityScope(type);
+
+        toManyTargetEntityDaoConfig = daoConfigMap.get(ToManyTargetEntityDao.class).clone();
+        toManyTargetEntityDaoConfig.initIdentityScope(type);
+
+        toManyEntityDaoConfig = daoConfigMap.get(ToManyEntityDao.class).clone();
+        toManyEntityDaoConfig.initIdentityScope(type);
+
+        treeEntityDaoConfig = daoConfigMap.get(TreeEntityDao.class).clone();
+        treeEntityDaoConfig.initIdentityScope(type);
+
+        anActiveEntityDaoConfig = daoConfigMap.get(AnActiveEntityDao.class).clone();
+        anActiveEntityDaoConfig.initIdentityScope(type);
+
+        extendsImplementsEntityDaoConfig = daoConfigMap.get(ExtendsImplementsEntityDao.class).clone();
+        extendsImplementsEntityDaoConfig.initIdentityScope(type);
+
+        stringKeyValueEntityDaoConfig = daoConfigMap.get(StringKeyValueEntityDao.class).clone();
+        stringKeyValueEntityDaoConfig.initIdentityScope(type);
+
+        autoincrementEntityDaoConfig = daoConfigMap.get(AutoincrementEntityDao.class).clone();
+        autoincrementEntityDaoConfig.initIdentityScope(type);
+
+        sqliteMasterDaoConfig = daoConfigMap.get(SqliteMasterDao.class).clone();
+        sqliteMasterDaoConfig.initIdentityScope(type);
+
+        simpleEntityDao = new SimpleEntityDao(simpleEntityDaoConfig, this);
+        simpleEntityNotNullDao = new SimpleEntityNotNullDao(simpleEntityNotNullDaoConfig, this);
+        testEntityDao = new TestEntityDao(testEntityDaoConfig, this);
+        relationEntityDao = new RelationEntityDao(relationEntityDaoConfig, this);
+        dateEntityDao = new DateEntityDao(dateEntityDaoConfig, this);
+        specialNamesEntityDao = new SpecialNamesEntityDao(specialNamesEntityDaoConfig, this);
+        abcdefEntityDao = new AbcdefEntityDao(abcdefEntityDaoConfig, this);
+        toManyTargetEntityDao = new ToManyTargetEntityDao(toManyTargetEntityDaoConfig, this);
+        toManyEntityDao = new ToManyEntityDao(toManyEntityDaoConfig, this);
+        treeEntityDao = new TreeEntityDao(treeEntityDaoConfig, this);
+        anActiveEntityDao = new AnActiveEntityDao(anActiveEntityDaoConfig, this);
+        extendsImplementsEntityDao = new ExtendsImplementsEntityDao(extendsImplementsEntityDaoConfig, this);
+        stringKeyValueEntityDao = new StringKeyValueEntityDao(stringKeyValueEntityDaoConfig, this);
+        autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
+        sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
+
+        registerDao(SimpleEntity.class, simpleEntityDao);
+        registerDao(SimpleEntityNotNull.class, simpleEntityNotNullDao);
+        registerDao(TestEntity.class, testEntityDao);
+        registerDao(RelationEntity.class, relationEntityDao);
+        registerDao(DateEntity.class, dateEntityDao);
+        registerDao(SpecialNamesEntity.class, specialNamesEntityDao);
+        registerDao(AbcdefEntity.class, abcdefEntityDao);
+        registerDao(ToManyTargetEntity.class, toManyTargetEntityDao);
+        registerDao(ToManyEntity.class, toManyEntityDao);
+        registerDao(TreeEntity.class, treeEntityDao);
+        registerDao(AnActiveEntity.class, anActiveEntityDao);
+        registerDao(ExtendsImplementsEntity.class, extendsImplementsEntityDao);
+        registerDao(StringKeyValueEntity.class, stringKeyValueEntityDao);
+        registerDao(AutoincrementEntity.class, autoincrementEntityDao);
+        registerDao(SqliteMaster.class, sqliteMasterDao);
+    }
+    
+    public void clear() {
+        simpleEntityDaoConfig.getIdentityScope().clear();
+        simpleEntityNotNullDaoConfig.getIdentityScope().clear();
+        testEntityDaoConfig.getIdentityScope().clear();
+        relationEntityDaoConfig.getIdentityScope().clear();
+        dateEntityDaoConfig.getIdentityScope().clear();
+        specialNamesEntityDaoConfig.getIdentityScope().clear();
+        abcdefEntityDaoConfig.getIdentityScope().clear();
+        toManyTargetEntityDaoConfig.getIdentityScope().clear();
+        toManyEntityDaoConfig.getIdentityScope().clear();
+        treeEntityDaoConfig.getIdentityScope().clear();
+        anActiveEntityDaoConfig.getIdentityScope().clear();
+        extendsImplementsEntityDaoConfig.getIdentityScope().clear();
+        stringKeyValueEntityDaoConfig.getIdentityScope().clear();
+        autoincrementEntityDaoConfig.getIdentityScope().clear();
+        sqliteMasterDaoConfig.getIdentityScope().clear();
+    }
+
+    public SimpleEntityDao getSimpleEntityDao() {
+        return simpleEntityDao;
+    }
+
+    public SimpleEntityNotNullDao getSimpleEntityNotNullDao() {
+        return simpleEntityNotNullDao;
+    }
+
+    public TestEntityDao getTestEntityDao() {
+        return testEntityDao;
+    }
+
+    public RelationEntityDao getRelationEntityDao() {
+        return relationEntityDao;
+    }
+
+    public DateEntityDao getDateEntityDao() {
+        return dateEntityDao;
+    }
+
+    public SpecialNamesEntityDao getSpecialNamesEntityDao() {
+        return specialNamesEntityDao;
+    }
+
+    public AbcdefEntityDao getAbcdefEntityDao() {
+        return abcdefEntityDao;
+    }
+
+    public ToManyTargetEntityDao getToManyTargetEntityDao() {
+        return toManyTargetEntityDao;
+    }
+
+    public ToManyEntityDao getToManyEntityDao() {
+        return toManyEntityDao;
+    }
+
+    public TreeEntityDao getTreeEntityDao() {
+        return treeEntityDao;
+    }
+
+    public AnActiveEntityDao getAnActiveEntityDao() {
+        return anActiveEntityDao;
+    }
+
+    public ExtendsImplementsEntityDao getExtendsImplementsEntityDao() {
+        return extendsImplementsEntityDao;
+    }
+
+    public StringKeyValueEntityDao getStringKeyValueEntityDao() {
+        return stringKeyValueEntityDao;
+    }
+
+    public AutoincrementEntityDao getAutoincrementEntityDao() {
+        return autoincrementEntityDao;
+    }
+
+    public SqliteMasterDao getSqliteMasterDao() {
+        return sqliteMasterDao;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntity.java
new file mode 100644
index 00000000..b01bd724
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntity.java
@@ -0,0 +1,53 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table DATE_ENTITY.
+ */
+public class DateEntity {
+
+    private Long id;
+    private java.util.Date date;
+    /** Not-null value. */
+    private java.util.Date dateNotNull;
+
+    public DateEntity() {
+    }
+
+    public DateEntity(Long id) {
+        this.id = id;
+    }
+
+    public DateEntity(Long id, java.util.Date date, java.util.Date dateNotNull) {
+        this.id = id;
+        this.date = date;
+        this.dateNotNull = dateNotNull;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public java.util.Date getDate() {
+        return date;
+    }
+
+    public void setDate(java.util.Date date) {
+        this.date = date;
+    }
+
+    /** Not-null value. */
+    public java.util.Date getDateNotNull() {
+        return dateNotNull;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setDateNotNull(java.util.Date dateNotNull) {
+        this.dateNotNull = dateNotNull;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntityDao.java
new file mode 100644
index 00000000..b3eb348f
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/DateEntityDao.java
@@ -0,0 +1,120 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.DateEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table DATE_ENTITY.
+*/
+public class DateEntityDao extends AbstractDao<DateEntity, Long> {
+
+    public static final String TABLENAME = "DATE_ENTITY";
+
+    /**
+     * Properties of entity DateEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Date = new Property(1, java.util.Date.class, "date", false, "DATE");
+        public final static Property DateNotNull = new Property(2, java.util.Date.class, "dateNotNull", false, "DATE_NOT_NULL");
+    };
+
+
+    public DateEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public DateEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'DATE_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'DATE' INTEGER," + // 1: date
+                "'DATE_NOT_NULL' INTEGER NOT NULL );"); // 2: dateNotNull
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'DATE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, DateEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        java.util.Date date = entity.getDate();
+        if (date != null) {
+            stmt.bindLong(2, date.getTime());
+        }
+        stmt.bindLong(3, entity.getDateNotNull().getTime());
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public DateEntity readEntity(Cursor cursor, int offset) {
+        DateEntity entity = new DateEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // date
+            new java.util.Date(cursor.getLong(offset + 2)) // dateNotNull
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, DateEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setDate(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
+        entity.setDateNotNull(new java.util.Date(cursor.getLong(offset + 2)));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(DateEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(DateEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
new file mode 100644
index 00000000..72c57ee8
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table EXTENDS_IMPLEMENTS_ENTITY.
+ */
+public class ExtendsImplementsEntity extends TestSuperclass  implements TestInterface, java.io.Serializable {
+
+    private Long id;
+    private String text;
+
+    public ExtendsImplementsEntity() {
+    }
+
+    public ExtendsImplementsEntity(Long id) {
+        this.id = id;
+    }
+
+    public ExtendsImplementsEntity(Long id, String text) {
+        this.id = id;
+        this.text = text;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getText() {
+        return text;
+    }
+
+    public void setText(String text) {
+        this.text = text;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
new file mode 100644
index 00000000..10e62249
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
@@ -0,0 +1,115 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.ExtendsImplementsEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table EXTENDS_IMPLEMENTS_ENTITY.
+*/
+public class ExtendsImplementsEntityDao extends AbstractDao<ExtendsImplementsEntity, Long> {
+
+    public static final String TABLENAME = "EXTENDS_IMPLEMENTS_ENTITY";
+
+    /**
+     * Properties of entity ExtendsImplementsEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+    };
+
+
+    public ExtendsImplementsEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ExtendsImplementsEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'EXTENDS_IMPLEMENTS_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT);"); // 1: text
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EXTENDS_IMPLEMENTS_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ExtendsImplementsEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String text = entity.getText();
+        if (text != null) {
+            stmt.bindString(2, text);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ExtendsImplementsEntity readEntity(Cursor cursor, int offset) {
+        ExtendsImplementsEntity entity = new ExtendsImplementsEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // text
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ExtendsImplementsEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(ExtendsImplementsEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(ExtendsImplementsEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntity.java
new file mode 100644
index 00000000..7a2d6944
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntity.java
@@ -0,0 +1,225 @@
+package de.greenrobot.daotest;
+
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table RELATION_ENTITY.
+ */
+public class RelationEntity {
+
+    private Long id;
+    private Long parentId;
+    private Long testId;
+    private long testIdNotNull;
+    private String simpleString;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient RelationEntityDao myDao;
+
+    private RelationEntity parent;
+    private Long parent__resolvedKey;
+
+    private TestEntity testEntity;
+    private Long testEntity__resolvedKey;
+
+    private TestEntity testNotNull;
+    private Long testNotNull__resolvedKey;
+
+    private TestEntity testWithoutProperty;
+    private boolean testWithoutProperty__refreshed;
+
+
+    public RelationEntity() {
+    }
+
+    public RelationEntity(Long id) {
+        this.id = id;
+    }
+
+    public RelationEntity(Long id, Long parentId, Long testId, long testIdNotNull, String simpleString) {
+        this.id = id;
+        this.parentId = parentId;
+        this.testId = testId;
+        this.testIdNotNull = testIdNotNull;
+        this.simpleString = simpleString;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getRelationEntityDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Long getParentId() {
+        return parentId;
+    }
+
+    public void setParentId(Long parentId) {
+        this.parentId = parentId;
+    }
+
+    public Long getTestId() {
+        return testId;
+    }
+
+    public void setTestId(Long testId) {
+        this.testId = testId;
+    }
+
+    public long getTestIdNotNull() {
+        return testIdNotNull;
+    }
+
+    public void setTestIdNotNull(long testIdNotNull) {
+        this.testIdNotNull = testIdNotNull;
+    }
+
+    public String getSimpleString() {
+        return simpleString;
+    }
+
+    public void setSimpleString(String simpleString) {
+        this.simpleString = simpleString;
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public RelationEntity getParent() {
+        Long __key = this.parentId;
+        if (parent__resolvedKey == null || !parent__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            RelationEntityDao targetDao = daoSession.getRelationEntityDao();
+            RelationEntity parentNew = targetDao.load(__key);
+            synchronized (this) {
+                parent = parentNew;
+            	parent__resolvedKey = __key;
+            }
+        }
+        return parent;
+    }
+
+    public void setParent(RelationEntity parent) {
+        synchronized (this) {
+            this.parent = parent;
+            parentId = parent == null ? null : parent.getId();
+            parent__resolvedKey = parentId;
+        }
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public TestEntity getTestEntity() {
+        Long __key = this.testId;
+        if (testEntity__resolvedKey == null || !testEntity__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            TestEntityDao targetDao = daoSession.getTestEntityDao();
+            TestEntity testEntityNew = targetDao.load(__key);
+            synchronized (this) {
+                testEntity = testEntityNew;
+            	testEntity__resolvedKey = __key;
+            }
+        }
+        return testEntity;
+    }
+
+    public void setTestEntity(TestEntity testEntity) {
+        synchronized (this) {
+            this.testEntity = testEntity;
+            testId = testEntity == null ? null : testEntity.getId();
+            testEntity__resolvedKey = testId;
+        }
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public TestEntity getTestNotNull() {
+        long __key = this.testIdNotNull;
+        if (testNotNull__resolvedKey == null || !testNotNull__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            TestEntityDao targetDao = daoSession.getTestEntityDao();
+            TestEntity testNotNullNew = targetDao.load(__key);
+            synchronized (this) {
+                testNotNull = testNotNullNew;
+            	testNotNull__resolvedKey = __key;
+            }
+        }
+        return testNotNull;
+    }
+
+    public void setTestNotNull(TestEntity testNotNull) {
+        if (testNotNull == null) {
+            throw new DaoException("To-one property 'testIdNotNull' has not-null constraint; cannot set to-one to null");
+        }
+        synchronized (this) {
+            this.testNotNull = testNotNull;
+            testIdNotNull = testNotNull.getId();
+            testNotNull__resolvedKey = testIdNotNull;
+        }
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public TestEntity getTestWithoutProperty() {
+        if (testWithoutProperty != null || !testWithoutProperty__refreshed) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            TestEntityDao targetDao = daoSession.getTestEntityDao();
+            targetDao.refresh(testWithoutProperty);
+            testWithoutProperty__refreshed = true;
+        }
+        return testWithoutProperty;
+    }
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    public TestEntity peakTestWithoutProperty() {
+        return testWithoutProperty;
+    }
+
+    public void setTestWithoutProperty(TestEntity testWithoutProperty) {
+        synchronized (this) {
+            this.testWithoutProperty = testWithoutProperty;
+            testWithoutProperty__refreshed = true;
+        }
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntityDao.java
new file mode 100644
index 00000000..4f09837e
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -0,0 +1,266 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.RelationEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table RELATION_ENTITY.
+*/
+public class RelationEntityDao extends AbstractDao<RelationEntity, Long> {
+
+    public static final String TABLENAME = "RELATION_ENTITY";
+
+    /**
+     * Properties of entity RelationEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property ParentId = new Property(1, Long.class, "parentId", false, "PARENT_ID");
+        public final static Property TestId = new Property(2, Long.class, "testId", false, "TEST_ID");
+        public final static Property TestIdNotNull = new Property(3, long.class, "testIdNotNull", false, "TEST_ID_NOT_NULL");
+        public final static Property SimpleString = new Property(4, String.class, "simpleString", false, "SIMPLE_STRING");
+        public final static Property TestWithoutProperty = new Property(5, Long.class, "testWithoutProperty", false, "WITHOUT_PROPERTY_TEST_ID");
+    };
+
+    private DaoSession daoSession;
+
+
+    public RelationEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public RelationEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'RELATION_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'PARENT_ID' INTEGER," + // 1: parentId
+                "'TEST_ID' INTEGER," + // 2: testId
+                "'TEST_ID_NOT_NULL' INTEGER NOT NULL ," + // 3: testIdNotNull
+                "'SIMPLE_STRING' TEXT," + // 4: simpleString
+                "'WITHOUT_PROPERTY_TEST_ID' INTEGER);"); // 5: testWithoutProperty
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, RelationEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Long parentId = entity.getParentId();
+        if (parentId != null) {
+            stmt.bindLong(2, parentId);
+        }
+ 
+        Long testId = entity.getTestId();
+        if (testId != null) {
+            stmt.bindLong(3, testId);
+        }
+        stmt.bindLong(4, entity.getTestIdNotNull());
+ 
+        String simpleString = entity.getSimpleString();
+        if (simpleString != null) {
+            stmt.bindString(5, simpleString);
+        }
+    }
+
+    @Override
+    protected void attachEntity(RelationEntity entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public RelationEntity readEntity(Cursor cursor, int offset) {
+        RelationEntity entity = new RelationEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // parentId
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // testId
+            cursor.getLong(offset + 3), // testIdNotNull
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4) // simpleString
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, RelationEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setParentId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+        entity.setTestId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
+        entity.setTestIdNotNull(cursor.getLong(offset + 3));
+        entity.setSimpleString(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(RelationEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(RelationEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getRelationEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T1", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T2", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(" FROM RELATION_ENTITY T");
+            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationEntity loadCurrentDeep(Cursor cursor, boolean lock) {
+        RelationEntity entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        RelationEntity parent = loadCurrentOther(daoSession.getRelationEntityDao(), cursor, offset);
+        entity.setParent(parent);
+        offset += daoSession.getRelationEntityDao().getAllColumns().length;
+
+        TestEntity testEntity = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+        entity.setTestEntity(testEntity);
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testNotNull = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+         if(testNotNull != null) {
+            entity.setTestNotNull(testNotNull);
+        }
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testWithoutProperty = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+        entity.setTestWithoutProperty(testWithoutProperty);
+
+        return entity;    
+    }
+
+    public RelationEntity loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationEntity> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<RelationEntity> list = new ArrayList<RelationEntity>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationEntity> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntity.java
new file mode 100644
index 00000000..9c072e1e
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntity.java
@@ -0,0 +1,120 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table SIMPLE_ENTITY.
+ */
+public class SimpleEntity {
+
+    private Long id;
+    private Boolean simpleBoolean;
+    private Byte simpleByte;
+    private Short simpleShort;
+    private Integer simpleInt;
+    private Long simpleLong;
+    private Float simpleFloat;
+    private Double simpleDouble;
+    private String simpleString;
+    private byte[] simpleByteArray;
+
+    public SimpleEntity() {
+    }
+
+    public SimpleEntity(Long id) {
+        this.id = id;
+    }
+
+    public SimpleEntity(Long id, Boolean simpleBoolean, Byte simpleByte, Short simpleShort, Integer simpleInt, Long simpleLong, Float simpleFloat, Double simpleDouble, String simpleString, byte[] simpleByteArray) {
+        this.id = id;
+        this.simpleBoolean = simpleBoolean;
+        this.simpleByte = simpleByte;
+        this.simpleShort = simpleShort;
+        this.simpleInt = simpleInt;
+        this.simpleLong = simpleLong;
+        this.simpleFloat = simpleFloat;
+        this.simpleDouble = simpleDouble;
+        this.simpleString = simpleString;
+        this.simpleByteArray = simpleByteArray;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Boolean getSimpleBoolean() {
+        return simpleBoolean;
+    }
+
+    public void setSimpleBoolean(Boolean simpleBoolean) {
+        this.simpleBoolean = simpleBoolean;
+    }
+
+    public Byte getSimpleByte() {
+        return simpleByte;
+    }
+
+    public void setSimpleByte(Byte simpleByte) {
+        this.simpleByte = simpleByte;
+    }
+
+    public Short getSimpleShort() {
+        return simpleShort;
+    }
+
+    public void setSimpleShort(Short simpleShort) {
+        this.simpleShort = simpleShort;
+    }
+
+    public Integer getSimpleInt() {
+        return simpleInt;
+    }
+
+    public void setSimpleInt(Integer simpleInt) {
+        this.simpleInt = simpleInt;
+    }
+
+    public Long getSimpleLong() {
+        return simpleLong;
+    }
+
+    public void setSimpleLong(Long simpleLong) {
+        this.simpleLong = simpleLong;
+    }
+
+    public Float getSimpleFloat() {
+        return simpleFloat;
+    }
+
+    public void setSimpleFloat(Float simpleFloat) {
+        this.simpleFloat = simpleFloat;
+    }
+
+    public Double getSimpleDouble() {
+        return simpleDouble;
+    }
+
+    public void setSimpleDouble(Double simpleDouble) {
+        this.simpleDouble = simpleDouble;
+    }
+
+    public String getSimpleString() {
+        return simpleString;
+    }
+
+    public void setSimpleString(String simpleString) {
+        this.simpleString = simpleString;
+    }
+
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
new file mode 100644
index 00000000..1375e1cf
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
@@ -0,0 +1,123 @@
+package de.greenrobot.daotest;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+
+import de.greenrobot.dao.DaoLog;
+
+import de.greenrobot.daotest.SimpleEntityDao;
+
+/* Copy this code snippet into your AndroidManifest.xml inside the <application> element:
+
+    <provider
+        android:name="de.greenrobot.daotest.SimpleEntityContentProvider"
+        android:authorities="de.greenrobot.daotest" />
+*/
+
+public class SimpleEntityContentProvider extends ContentProvider {
+
+    public static final String AUTHORITY = "de.greenrobot.daotest";
+    public static final String BASE_PATH = "SimpleEntity";
+    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
+    public static final String CONTENT_TYPE = ContentResolver.CURSOR_DIR_BASE_TYPE
+            + "/" + BASE_PATH;
+    public static final String CONTENT_ITEM_TYPE = ContentResolver.CURSOR_ITEM_BASE_TYPE
+            + "/" + BASE_PATH;
+            
+    private static final String TABLENAME = SimpleEntityDao.TABLENAME;
+    private static final String PK = SimpleEntityDao.Properties.Id.columnName;
+
+    private static final int SIMPLEENTITY_DIR = 0;
+    private static final int SIMPLEENTITY_ID = 1;
+
+    private static final UriMatcher sURIMatcher;
+     
+    static {
+        sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);      
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH, SIMPLEENTITY_DIR);
+        sURIMatcher.addURI(AUTHORITY, BASE_PATH + "/#", SIMPLEENTITY_ID);
+    }
+    
+    /** 
+    * This must be set from outside, it's recommended to do this inside your Application object.
+    * Subject to change (static isn't nice).
+    */
+    public static DaoSession daoSession;
+    
+    @Override
+    public boolean onCreate() {
+        // if(daoSession == null) {
+        //     throw new IllegalStateException("DaoSession must be set before content provider is created");
+        // }
+        DaoLog.d("Content Provider started: " + CONTENT_URI);
+        return true;
+    }
+    
+    protected SQLiteDatabase getDatabase() {
+        if(daoSession == null) {
+            throw new IllegalStateException("DaoSession must be set during content provider is active");
+        }
+        return daoSession.getDatabase();
+    }
+        
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+    
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+        throw new UnsupportedOperationException("This content provider is readonly");
+    }
+ 
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+
+        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
+        int uriType = sURIMatcher.match(uri);
+        switch (uriType) {
+        case SIMPLEENTITY_DIR:
+            queryBuilder.setTables(TABLENAME);
+            break;
+        case SIMPLEENTITY_ID:
+            queryBuilder.setTables(TABLENAME);
+            queryBuilder.appendWhere(PK + "="
+                    + uri.getLastPathSegment());
+            break;
+        default:
+            throw new IllegalArgumentException("Unknown URI: " + uri);
+        }
+
+        SQLiteDatabase db = getDatabase();
+        Cursor cursor = queryBuilder.query(db, projection, selection,
+                selectionArgs, null, null, sortOrder);
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+    
+    @Override
+    public final String getType(Uri uri) {
+        switch (sURIMatcher.match(uri)) {
+        case SIMPLEENTITY_DIR:
+            return CONTENT_TYPE;
+        case SIMPLEENTITY_ID:
+            return CONTENT_ITEM_TYPE;
+        default :
+            throw new IllegalArgumentException("Unsupported URI: " + uri);
+        }
+    }
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityDao.java
new file mode 100644
index 00000000..70a5df92
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityDao.java
@@ -0,0 +1,187 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.SimpleEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SIMPLE_ENTITY.
+*/
+public class SimpleEntityDao extends AbstractDao<SimpleEntity, Long> {
+
+    public static final String TABLENAME = "SIMPLE_ENTITY";
+
+    /**
+     * Properties of entity SimpleEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property SimpleBoolean = new Property(1, Boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+        public final static Property SimpleByte = new Property(2, Byte.class, "simpleByte", false, "SIMPLE_BYTE");
+        public final static Property SimpleShort = new Property(3, Short.class, "simpleShort", false, "SIMPLE_SHORT");
+        public final static Property SimpleInt = new Property(4, Integer.class, "simpleInt", false, "SIMPLE_INT");
+        public final static Property SimpleLong = new Property(5, Long.class, "simpleLong", false, "SIMPLE_LONG");
+        public final static Property SimpleFloat = new Property(6, Float.class, "simpleFloat", false, "SIMPLE_FLOAT");
+        public final static Property SimpleDouble = new Property(7, Double.class, "simpleDouble", false, "SIMPLE_DOUBLE");
+        public final static Property SimpleString = new Property(8, String.class, "simpleString", false, "SIMPLE_STRING");
+        public final static Property SimpleByteArray = new Property(9, byte[].class, "simpleByteArray", false, "SIMPLE_BYTE_ARRAY");
+    };
+
+
+    public SimpleEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SimpleEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'SIMPLE_BOOLEAN' INTEGER," + // 1: simpleBoolean
+                "'SIMPLE_BYTE' INTEGER," + // 2: simpleByte
+                "'SIMPLE_SHORT' INTEGER," + // 3: simpleShort
+                "'SIMPLE_INT' INTEGER," + // 4: simpleInt
+                "'SIMPLE_LONG' INTEGER," + // 5: simpleLong
+                "'SIMPLE_FLOAT' REAL," + // 6: simpleFloat
+                "'SIMPLE_DOUBLE' REAL," + // 7: simpleDouble
+                "'SIMPLE_STRING' TEXT," + // 8: simpleString
+                "'SIMPLE_BYTE_ARRAY' BLOB);"); // 9: simpleByteArray
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SimpleEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Boolean simpleBoolean = entity.getSimpleBoolean();
+        if (simpleBoolean != null) {
+            stmt.bindLong(2, simpleBoolean ? 1l: 0l);
+        }
+ 
+        Byte simpleByte = entity.getSimpleByte();
+        if (simpleByte != null) {
+            stmt.bindLong(3, simpleByte);
+        }
+ 
+        Short simpleShort = entity.getSimpleShort();
+        if (simpleShort != null) {
+            stmt.bindLong(4, simpleShort);
+        }
+ 
+        Integer simpleInt = entity.getSimpleInt();
+        if (simpleInt != null) {
+            stmt.bindLong(5, simpleInt);
+        }
+ 
+        Long simpleLong = entity.getSimpleLong();
+        if (simpleLong != null) {
+            stmt.bindLong(6, simpleLong);
+        }
+ 
+        Float simpleFloat = entity.getSimpleFloat();
+        if (simpleFloat != null) {
+            stmt.bindDouble(7, simpleFloat);
+        }
+ 
+        Double simpleDouble = entity.getSimpleDouble();
+        if (simpleDouble != null) {
+            stmt.bindDouble(8, simpleDouble);
+        }
+ 
+        String simpleString = entity.getSimpleString();
+        if (simpleString != null) {
+            stmt.bindString(9, simpleString);
+        }
+ 
+        byte[] simpleByteArray = entity.getSimpleByteArray();
+        if (simpleByteArray != null) {
+            stmt.bindBlob(10, simpleByteArray);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SimpleEntity readEntity(Cursor cursor, int offset) {
+        SimpleEntity entity = new SimpleEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getShort(offset + 1) != 0, // simpleBoolean
+            cursor.isNull(offset + 2) ? null : (byte) cursor.getShort(offset + 2), // simpleByte
+            cursor.isNull(offset + 3) ? null : cursor.getShort(offset + 3), // simpleShort
+            cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4), // simpleInt
+            cursor.isNull(offset + 5) ? null : cursor.getLong(offset + 5), // simpleLong
+            cursor.isNull(offset + 6) ? null : cursor.getFloat(offset + 6), // simpleFloat
+            cursor.isNull(offset + 7) ? null : cursor.getDouble(offset + 7), // simpleDouble
+            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // simpleString
+            cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9) // simpleByteArray
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SimpleEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setSimpleBoolean(cursor.isNull(offset + 1) ? null : cursor.getShort(offset + 1) != 0);
+        entity.setSimpleByte(cursor.isNull(offset + 2) ? null : (byte) cursor.getShort(offset + 2));
+        entity.setSimpleShort(cursor.isNull(offset + 3) ? null : cursor.getShort(offset + 3));
+        entity.setSimpleInt(cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4));
+        entity.setSimpleLong(cursor.isNull(offset + 5) ? null : cursor.getLong(offset + 5));
+        entity.setSimpleFloat(cursor.isNull(offset + 6) ? null : cursor.getFloat(offset + 6));
+        entity.setSimpleDouble(cursor.isNull(offset + 7) ? null : cursor.getDouble(offset + 7));
+        entity.setSimpleString(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
+        entity.setSimpleByteArray(cursor.isNull(offset + 9) ? null : cursor.getBlob(offset + 9));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(SimpleEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(SimpleEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNull.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
new file mode 100644
index 00000000..98c6a053
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNull.java
@@ -0,0 +1,126 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table SIMPLE_ENTITY_NOT_NULL.
+ */
+public class SimpleEntityNotNull {
+
+    private long id;
+    private boolean simpleBoolean;
+    private byte simpleByte;
+    private short simpleShort;
+    private int simpleInt;
+    private long simpleLong;
+    private float simpleFloat;
+    private double simpleDouble;
+    /** Not-null value. */
+    private String simpleString;
+    /** Not-null value. */
+    private byte[] simpleByteArray;
+
+    public SimpleEntityNotNull() {
+    }
+
+    public SimpleEntityNotNull(long id) {
+        this.id = id;
+    }
+
+    public SimpleEntityNotNull(long id, boolean simpleBoolean, byte simpleByte, short simpleShort, int simpleInt, long simpleLong, float simpleFloat, double simpleDouble, String simpleString, byte[] simpleByteArray) {
+        this.id = id;
+        this.simpleBoolean = simpleBoolean;
+        this.simpleByte = simpleByte;
+        this.simpleShort = simpleShort;
+        this.simpleInt = simpleInt;
+        this.simpleLong = simpleLong;
+        this.simpleFloat = simpleFloat;
+        this.simpleDouble = simpleDouble;
+        this.simpleString = simpleString;
+        this.simpleByteArray = simpleByteArray;
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    public boolean getSimpleBoolean() {
+        return simpleBoolean;
+    }
+
+    public void setSimpleBoolean(boolean simpleBoolean) {
+        this.simpleBoolean = simpleBoolean;
+    }
+
+    public byte getSimpleByte() {
+        return simpleByte;
+    }
+
+    public void setSimpleByte(byte simpleByte) {
+        this.simpleByte = simpleByte;
+    }
+
+    public short getSimpleShort() {
+        return simpleShort;
+    }
+
+    public void setSimpleShort(short simpleShort) {
+        this.simpleShort = simpleShort;
+    }
+
+    public int getSimpleInt() {
+        return simpleInt;
+    }
+
+    public void setSimpleInt(int simpleInt) {
+        this.simpleInt = simpleInt;
+    }
+
+    public long getSimpleLong() {
+        return simpleLong;
+    }
+
+    public void setSimpleLong(long simpleLong) {
+        this.simpleLong = simpleLong;
+    }
+
+    public float getSimpleFloat() {
+        return simpleFloat;
+    }
+
+    public void setSimpleFloat(float simpleFloat) {
+        this.simpleFloat = simpleFloat;
+    }
+
+    public double getSimpleDouble() {
+        return simpleDouble;
+    }
+
+    public void setSimpleDouble(double simpleDouble) {
+        this.simpleDouble = simpleDouble;
+    }
+
+    /** Not-null value. */
+    public String getSimpleString() {
+        return simpleString;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setSimpleString(String simpleString) {
+        this.simpleString = simpleString;
+    }
+
+    /** Not-null value. */
+    public byte[] getSimpleByteArray() {
+        return simpleByteArray;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setSimpleByteArray(byte[] simpleByteArray) {
+        this.simpleByteArray = simpleByteArray;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
new file mode 100644
index 00000000..246d9392
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
@@ -0,0 +1,147 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SIMPLE_ENTITY_NOT_NULL.
+*/
+public class SimpleEntityNotNullDao extends AbstractDao<SimpleEntityNotNull, Long> {
+
+    public static final String TABLENAME = "SIMPLE_ENTITY_NOT_NULL";
+
+    /**
+     * Properties of entity SimpleEntityNotNull.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, long.class, "id", true, "_id");
+        public final static Property SimpleBoolean = new Property(1, boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+        public final static Property SimpleByte = new Property(2, byte.class, "simpleByte", false, "SIMPLE_BYTE");
+        public final static Property SimpleShort = new Property(3, short.class, "simpleShort", false, "SIMPLE_SHORT");
+        public final static Property SimpleInt = new Property(4, int.class, "simpleInt", false, "SIMPLE_INT");
+        public final static Property SimpleLong = new Property(5, long.class, "simpleLong", false, "SIMPLE_LONG");
+        public final static Property SimpleFloat = new Property(6, float.class, "simpleFloat", false, "SIMPLE_FLOAT");
+        public final static Property SimpleDouble = new Property(7, double.class, "simpleDouble", false, "SIMPLE_DOUBLE");
+        public final static Property SimpleString = new Property(8, String.class, "simpleString", false, "SIMPLE_STRING");
+        public final static Property SimpleByteArray = new Property(9, byte[].class, "simpleByteArray", false, "SIMPLE_BYTE_ARRAY");
+    };
+
+
+    public SimpleEntityNotNullDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SimpleEntityNotNullDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY_NOT_NULL' (" + //
+                "'_id' INTEGER PRIMARY KEY NOT NULL ," + // 0: id
+                "'SIMPLE_BOOLEAN' INTEGER NOT NULL ," + // 1: simpleBoolean
+                "'SIMPLE_BYTE' INTEGER NOT NULL ," + // 2: simpleByte
+                "'SIMPLE_SHORT' INTEGER NOT NULL ," + // 3: simpleShort
+                "'SIMPLE_INT' INTEGER NOT NULL ," + // 4: simpleInt
+                "'SIMPLE_LONG' INTEGER NOT NULL ," + // 5: simpleLong
+                "'SIMPLE_FLOAT' REAL NOT NULL ," + // 6: simpleFloat
+                "'SIMPLE_DOUBLE' REAL NOT NULL ," + // 7: simpleDouble
+                "'SIMPLE_STRING' TEXT NOT NULL ," + // 8: simpleString
+                "'SIMPLE_BYTE_ARRAY' BLOB NOT NULL );"); // 9: simpleByteArray
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY_NOT_NULL'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SimpleEntityNotNull entity) {
+        stmt.clearBindings();
+        stmt.bindLong(1, entity.getId());
+        stmt.bindLong(2, entity.getSimpleBoolean() ? 1l: 0l);
+        stmt.bindLong(3, entity.getSimpleByte());
+        stmt.bindLong(4, entity.getSimpleShort());
+        stmt.bindLong(5, entity.getSimpleInt());
+        stmt.bindLong(6, entity.getSimpleLong());
+        stmt.bindDouble(7, entity.getSimpleFloat());
+        stmt.bindDouble(8, entity.getSimpleDouble());
+        stmt.bindString(9, entity.getSimpleString());
+        stmt.bindBlob(10, entity.getSimpleByteArray());
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SimpleEntityNotNull readEntity(Cursor cursor, int offset) {
+        SimpleEntityNotNull entity = new SimpleEntityNotNull( //
+            cursor.getLong(offset + 0), // id
+            cursor.getShort(offset + 1) != 0, // simpleBoolean
+            (byte) cursor.getShort(offset + 2), // simpleByte
+            cursor.getShort(offset + 3), // simpleShort
+            cursor.getInt(offset + 4), // simpleInt
+            cursor.getLong(offset + 5), // simpleLong
+            cursor.getFloat(offset + 6), // simpleFloat
+            cursor.getDouble(offset + 7), // simpleDouble
+            cursor.getString(offset + 8), // simpleString
+            cursor.getBlob(offset + 9) // simpleByteArray
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SimpleEntityNotNull entity, int offset) {
+        entity.setId(cursor.getLong(offset + 0));
+        entity.setSimpleBoolean(cursor.getShort(offset + 1) != 0);
+        entity.setSimpleByte((byte) cursor.getShort(offset + 2));
+        entity.setSimpleShort(cursor.getShort(offset + 3));
+        entity.setSimpleInt(cursor.getInt(offset + 4));
+        entity.setSimpleLong(cursor.getLong(offset + 5));
+        entity.setSimpleFloat(cursor.getFloat(offset + 6));
+        entity.setSimpleDouble(cursor.getDouble(offset + 7));
+        entity.setSimpleString(cursor.getString(offset + 8));
+        entity.setSimpleByteArray(cursor.getBlob(offset + 9));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(SimpleEntityNotNull entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(SimpleEntityNotNull entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntity.java
new file mode 100644
index 00000000..3a907aeb
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntity.java
@@ -0,0 +1,120 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table SPECIAL_NAMES_ENTITY.
+ */
+public class SpecialNamesEntity {
+
+    private Long id;
+    private String count;
+    private String select;
+    private String sum;
+    private String avg;
+    private String join;
+    private String distinct;
+    private String on;
+    private String index;
+    private Integer order;
+
+    public SpecialNamesEntity() {
+    }
+
+    public SpecialNamesEntity(Long id) {
+        this.id = id;
+    }
+
+    public SpecialNamesEntity(Long id, String count, String select, String sum, String avg, String join, String distinct, String on, String index, Integer order) {
+        this.id = id;
+        this.count = count;
+        this.select = select;
+        this.sum = sum;
+        this.avg = avg;
+        this.join = join;
+        this.distinct = distinct;
+        this.on = on;
+        this.index = index;
+        this.order = order;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getCount() {
+        return count;
+    }
+
+    public void setCount(String count) {
+        this.count = count;
+    }
+
+    public String getSelect() {
+        return select;
+    }
+
+    public void setSelect(String select) {
+        this.select = select;
+    }
+
+    public String getSum() {
+        return sum;
+    }
+
+    public void setSum(String sum) {
+        this.sum = sum;
+    }
+
+    public String getAvg() {
+        return avg;
+    }
+
+    public void setAvg(String avg) {
+        this.avg = avg;
+    }
+
+    public String getJoin() {
+        return join;
+    }
+
+    public void setJoin(String join) {
+        this.join = join;
+    }
+
+    public String getDistinct() {
+        return distinct;
+    }
+
+    public void setDistinct(String distinct) {
+        this.distinct = distinct;
+    }
+
+    public String getOn() {
+        return on;
+    }
+
+    public void setOn(String on) {
+        this.on = on;
+    }
+
+    public String getIndex() {
+        return index;
+    }
+
+    public void setIndex(String index) {
+        this.index = index;
+    }
+
+    public Integer getOrder() {
+        return order;
+    }
+
+    public void setOrder(Integer order) {
+        this.order = order;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
new file mode 100644
index 00000000..184203a7
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
@@ -0,0 +1,187 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.SpecialNamesEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SPECIAL_NAMES_ENTITY.
+*/
+public class SpecialNamesEntityDao extends AbstractDao<SpecialNamesEntity, Long> {
+
+    public static final String TABLENAME = "SPECIAL_NAMES_ENTITY";
+
+    /**
+     * Properties of entity SpecialNamesEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Count = new Property(1, String.class, "count", false, "COUNT");
+        public final static Property Select = new Property(2, String.class, "select", false, "SELECT");
+        public final static Property Sum = new Property(3, String.class, "sum", false, "SUM");
+        public final static Property Avg = new Property(4, String.class, "avg", false, "AVG");
+        public final static Property Join = new Property(5, String.class, "join", false, "JOIN");
+        public final static Property Distinct = new Property(6, String.class, "distinct", false, "DISTINCT");
+        public final static Property On = new Property(7, String.class, "on", false, "ON");
+        public final static Property Index = new Property(8, String.class, "index", false, "INDEX");
+        public final static Property Order = new Property(9, Integer.class, "order", false, "ORDER");
+    };
+
+
+    public SpecialNamesEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'SPECIAL_NAMES_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'COUNT' TEXT," + // 1: count
+                "'SELECT' TEXT," + // 2: select
+                "'SUM' TEXT," + // 3: sum
+                "'AVG' TEXT," + // 4: avg
+                "'JOIN' TEXT," + // 5: join
+                "'DISTINCT' TEXT," + // 6: distinct
+                "'ON' TEXT," + // 7: on
+                "'INDEX' TEXT," + // 8: index
+                "'ORDER' INTEGER);"); // 9: order
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SPECIAL_NAMES_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SpecialNamesEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String count = entity.getCount();
+        if (count != null) {
+            stmt.bindString(2, count);
+        }
+ 
+        String select = entity.getSelect();
+        if (select != null) {
+            stmt.bindString(3, select);
+        }
+ 
+        String sum = entity.getSum();
+        if (sum != null) {
+            stmt.bindString(4, sum);
+        }
+ 
+        String avg = entity.getAvg();
+        if (avg != null) {
+            stmt.bindString(5, avg);
+        }
+ 
+        String join = entity.getJoin();
+        if (join != null) {
+            stmt.bindString(6, join);
+        }
+ 
+        String distinct = entity.getDistinct();
+        if (distinct != null) {
+            stmt.bindString(7, distinct);
+        }
+ 
+        String on = entity.getOn();
+        if (on != null) {
+            stmt.bindString(8, on);
+        }
+ 
+        String index = entity.getIndex();
+        if (index != null) {
+            stmt.bindString(9, index);
+        }
+ 
+        Integer order = entity.getOrder();
+        if (order != null) {
+            stmt.bindLong(10, order);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SpecialNamesEntity readEntity(Cursor cursor, int offset) {
+        SpecialNamesEntity entity = new SpecialNamesEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // count
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // select
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // sum
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // avg
+            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // join
+            cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // distinct
+            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // on
+            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // index
+            cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9) // order
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SpecialNamesEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setCount(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+        entity.setSelect(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setSum(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+        entity.setAvg(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+        entity.setJoin(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
+        entity.setDistinct(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
+        entity.setOn(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
+        entity.setIndex(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
+        entity.setOrder(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(SpecialNamesEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(SpecialNamesEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMaster.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMaster.java
new file mode 100644
index 00000000..d67dc10f
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMaster.java
@@ -0,0 +1,79 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+// KEEP INCLUDES END
+/**
+ * Entity mapped to table SQLITE_MASTER.
+ */
+public class SqliteMaster {
+
+    private String type;
+    private String name;
+    private String tableName;
+    private Long rootpage;
+    private String sql;
+
+    // KEEP FIELDS - put your custom fields here
+    // KEEP FIELDS END
+
+    public SqliteMaster() {
+    }
+
+    public SqliteMaster(String type, String name, String tableName, Long rootpage, String sql) {
+        this.type = type;
+        this.name = name;
+        this.tableName = tableName;
+        this.rootpage = rootpage;
+        this.sql = sql;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getTableName() {
+        return tableName;
+    }
+
+    public void setTableName(String tableName) {
+        this.tableName = tableName;
+    }
+
+    public Long getRootpage() {
+        return rootpage;
+    }
+
+    public void setRootpage(Long rootpage) {
+        this.rootpage = rootpage;
+    }
+
+    public String getSql() {
+        return sql;
+    }
+
+    public void setSql(String sql) {
+        this.sql = sql;
+    }
+
+    // KEEP METHODS - put your custom methods here
+    @Override
+    public String toString() {
+        return "Type: " + type + ", name: " + name + ", table: " + tableName + ", SQL: " + sql;
+    }
+    // KEEP METHODS END
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMasterDao.java
new file mode 100644
index 00000000..b83e409c
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/SqliteMasterDao.java
@@ -0,0 +1,121 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.SqliteMaster;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SQLITE_MASTER.
+*/
+public class SqliteMasterDao extends AbstractDao<SqliteMaster, Void> {
+
+    public static final String TABLENAME = "SQLITE_MASTER";
+
+    /**
+     * Properties of entity SqliteMaster.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Type = new Property(0, String.class, "type", false, "TYPE");
+        public final static Property Name = new Property(1, String.class, "name", false, "NAME");
+        public final static Property TableName = new Property(2, String.class, "tableName", false, "tbl_name");
+        public final static Property Rootpage = new Property(3, Long.class, "rootpage", false, "ROOTPAGE");
+        public final static Property Sql = new Property(4, String.class, "sql", false, "SQL");
+    };
+
+
+    public SqliteMasterDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SqliteMasterDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SqliteMaster entity) {
+        stmt.clearBindings();
+ 
+        String type = entity.getType();
+        if (type != null) {
+            stmt.bindString(1, type);
+        }
+ 
+        String name = entity.getName();
+        if (name != null) {
+            stmt.bindString(2, name);
+        }
+ 
+        String tableName = entity.getTableName();
+        if (tableName != null) {
+            stmt.bindString(3, tableName);
+        }
+ 
+        Long rootpage = entity.getRootpage();
+        if (rootpage != null) {
+            stmt.bindLong(4, rootpage);
+        }
+ 
+        String sql = entity.getSql();
+        if (sql != null) {
+            stmt.bindString(5, sql);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Void readKey(Cursor cursor, int offset) {
+        return null;
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SqliteMaster readEntity(Cursor cursor, int offset) {
+        SqliteMaster entity = new SqliteMaster( //
+            cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0), // type
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // name
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // tableName
+            cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3), // rootpage
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4) // sql
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SqliteMaster entity, int offset) {
+        entity.setType(cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0));
+        entity.setName(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+        entity.setTableName(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setRootpage(cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3));
+        entity.setSql(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Void updateKeyAfterInsert(SqliteMaster entity, long rowId) {
+        // Unsupported or missing PK type
+        return null;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Void getKey(SqliteMaster entity) {
+        return null;
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntity.java
new file mode 100644
index 00000000..b436d049
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table STRING_KEY_VALUE_ENTITY.
+ */
+public class StringKeyValueEntity {
+
+    private String key;
+    private String value;
+
+    public StringKeyValueEntity() {
+    }
+
+    public StringKeyValueEntity(String key) {
+        this.key = key;
+    }
+
+    public StringKeyValueEntity(String key, String value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
new file mode 100644
index 00000000..bdf2cd83
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
@@ -0,0 +1,114 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.StringKeyValueEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table STRING_KEY_VALUE_ENTITY.
+*/
+public class StringKeyValueEntityDao extends AbstractDao<StringKeyValueEntity, String> {
+
+    public static final String TABLENAME = "STRING_KEY_VALUE_ENTITY";
+
+    /**
+     * Properties of entity StringKeyValueEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Key = new Property(0, String.class, "key", true, "KEY");
+        public final static Property Value = new Property(1, String.class, "value", false, "VALUE");
+    };
+
+
+    public StringKeyValueEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public StringKeyValueEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'STRING_KEY_VALUE_ENTITY' (" + //
+                "'KEY' TEXT PRIMARY KEY NOT NULL ," + // 0: key
+                "'VALUE' TEXT);"); // 1: value
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'STRING_KEY_VALUE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, StringKeyValueEntity entity) {
+        stmt.clearBindings();
+ 
+        String key = entity.getKey();
+        if (key != null) {
+            stmt.bindString(1, key);
+        }
+ 
+        String value = entity.getValue();
+        if (value != null) {
+            stmt.bindString(2, value);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public String readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public StringKeyValueEntity readEntity(Cursor cursor, int offset) {
+        StringKeyValueEntity entity = new StringKeyValueEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0), // key
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // value
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, StringKeyValueEntity entity, int offset) {
+        entity.setKey(cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0));
+        entity.setValue(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected String updateKeyAfterInsert(StringKeyValueEntity entity, long rowId) {
+        return entity.getKey();
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public String getKey(StringKeyValueEntity entity) {
+        if(entity != null) {
+            return entity.getKey();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntity.java
new file mode 100644
index 00000000..82bde4bd
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntity.java
@@ -0,0 +1,113 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table TEST_ENTITY.
+ */
+public class TestEntity {
+
+    private Long id;
+    private int simpleInt;
+    private Integer simpleInteger;
+    /** Not-null value. */
+    private String simpleStringNotNull;
+    private String simpleString;
+    private String indexedString;
+    private String indexedStringAscUnique;
+    private java.util.Date simpleDate;
+    private Boolean simpleBoolean;
+
+    public TestEntity() {
+    }
+
+    public TestEntity(Long id) {
+        this.id = id;
+    }
+
+    public TestEntity(Long id, int simpleInt, Integer simpleInteger, String simpleStringNotNull, String simpleString, String indexedString, String indexedStringAscUnique, java.util.Date simpleDate, Boolean simpleBoolean) {
+        this.id = id;
+        this.simpleInt = simpleInt;
+        this.simpleInteger = simpleInteger;
+        this.simpleStringNotNull = simpleStringNotNull;
+        this.simpleString = simpleString;
+        this.indexedString = indexedString;
+        this.indexedStringAscUnique = indexedStringAscUnique;
+        this.simpleDate = simpleDate;
+        this.simpleBoolean = simpleBoolean;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public int getSimpleInt() {
+        return simpleInt;
+    }
+
+    public void setSimpleInt(int simpleInt) {
+        this.simpleInt = simpleInt;
+    }
+
+    public Integer getSimpleInteger() {
+        return simpleInteger;
+    }
+
+    public void setSimpleInteger(Integer simpleInteger) {
+        this.simpleInteger = simpleInteger;
+    }
+
+    /** Not-null value. */
+    public String getSimpleStringNotNull() {
+        return simpleStringNotNull;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setSimpleStringNotNull(String simpleStringNotNull) {
+        this.simpleStringNotNull = simpleStringNotNull;
+    }
+
+    public String getSimpleString() {
+        return simpleString;
+    }
+
+    public void setSimpleString(String simpleString) {
+        this.simpleString = simpleString;
+    }
+
+    public String getIndexedString() {
+        return indexedString;
+    }
+
+    public void setIndexedString(String indexedString) {
+        this.indexedString = indexedString;
+    }
+
+    public String getIndexedStringAscUnique() {
+        return indexedStringAscUnique;
+    }
+
+    public void setIndexedStringAscUnique(String indexedStringAscUnique) {
+        this.indexedStringAscUnique = indexedStringAscUnique;
+    }
+
+    public java.util.Date getSimpleDate() {
+        return simpleDate;
+    }
+
+    public void setSimpleDate(java.util.Date simpleDate) {
+        this.simpleDate = simpleDate;
+    }
+
+    public Boolean getSimpleBoolean() {
+        return simpleBoolean;
+    }
+
+    public void setSimpleBoolean(Boolean simpleBoolean) {
+        this.simpleBoolean = simpleBoolean;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntityDao.java
new file mode 100644
index 00000000..b3d584ae
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -0,0 +1,175 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.TestEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TEST_ENTITY.
+*/
+public class TestEntityDao extends AbstractDao<TestEntity, Long> {
+
+    public static final String TABLENAME = "TEST_ENTITY";
+
+    /**
+     * Properties of entity TestEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property SimpleInt = new Property(1, int.class, "simpleInt", false, "SIMPLE_INT");
+        public final static Property SimpleInteger = new Property(2, Integer.class, "simpleInteger", false, "SIMPLE_INTEGER");
+        public final static Property SimpleStringNotNull = new Property(3, String.class, "simpleStringNotNull", false, "SIMPLE_STRING_NOT_NULL");
+        public final static Property SimpleString = new Property(4, String.class, "simpleString", false, "SIMPLE_STRING");
+        public final static Property IndexedString = new Property(5, String.class, "indexedString", false, "INDEXED_STRING");
+        public final static Property IndexedStringAscUnique = new Property(6, String.class, "indexedStringAscUnique", false, "INDEXED_STRING_ASC_UNIQUE");
+        public final static Property SimpleDate = new Property(7, java.util.Date.class, "simpleDate", false, "SIMPLE_DATE");
+        public final static Property SimpleBoolean = new Property(8, Boolean.class, "simpleBoolean", false, "SIMPLE_BOOLEAN");
+    };
+
+
+    public TestEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public TestEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TEST_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'SIMPLE_INT' INTEGER NOT NULL ," + // 1: simpleInt
+                "'SIMPLE_INTEGER' INTEGER," + // 2: simpleInteger
+                "'SIMPLE_STRING_NOT_NULL' TEXT NOT NULL ," + // 3: simpleStringNotNull
+                "'SIMPLE_STRING' TEXT," + // 4: simpleString
+                "'INDEXED_STRING' TEXT," + // 5: indexedString
+                "'INDEXED_STRING_ASC_UNIQUE' TEXT," + // 6: indexedStringAscUnique
+                "'SIMPLE_DATE' INTEGER," + // 7: simpleDate
+                "'SIMPLE_BOOLEAN' INTEGER);"); // 8: simpleBoolean
+        // Add Indexes
+        db.execSQL("CREATE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING ON TEST_ENTITY" +
+                " (INDEXED_STRING);");
+        db.execSQL("CREATE UNIQUE INDEX " + constraint + "IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE ON TEST_ENTITY" +
+                " (INDEXED_STRING_ASC_UNIQUE);");
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TEST_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, TestEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+        stmt.bindLong(2, entity.getSimpleInt());
+ 
+        Integer simpleInteger = entity.getSimpleInteger();
+        if (simpleInteger != null) {
+            stmt.bindLong(3, simpleInteger);
+        }
+        stmt.bindString(4, entity.getSimpleStringNotNull());
+ 
+        String simpleString = entity.getSimpleString();
+        if (simpleString != null) {
+            stmt.bindString(5, simpleString);
+        }
+ 
+        String indexedString = entity.getIndexedString();
+        if (indexedString != null) {
+            stmt.bindString(6, indexedString);
+        }
+ 
+        String indexedStringAscUnique = entity.getIndexedStringAscUnique();
+        if (indexedStringAscUnique != null) {
+            stmt.bindString(7, indexedStringAscUnique);
+        }
+ 
+        java.util.Date simpleDate = entity.getSimpleDate();
+        if (simpleDate != null) {
+            stmt.bindLong(8, simpleDate.getTime());
+        }
+ 
+        Boolean simpleBoolean = entity.getSimpleBoolean();
+        if (simpleBoolean != null) {
+            stmt.bindLong(9, simpleBoolean ? 1l: 0l);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public TestEntity readEntity(Cursor cursor, int offset) {
+        TestEntity entity = new TestEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.getInt(offset + 1), // simpleInt
+            cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2), // simpleInteger
+            cursor.getString(offset + 3), // simpleStringNotNull
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // simpleString
+            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // indexedString
+            cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // indexedStringAscUnique
+            cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)), // simpleDate
+            cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0 // simpleBoolean
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, TestEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setSimpleInt(cursor.getInt(offset + 1));
+        entity.setSimpleInteger(cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2));
+        entity.setSimpleStringNotNull(cursor.getString(offset + 3));
+        entity.setSimpleString(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+        entity.setIndexedString(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
+        entity.setIndexedStringAscUnique(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
+        entity.setSimpleDate(cursor.isNull(offset + 7) ? null : new java.util.Date(cursor.getLong(offset + 7)));
+        entity.setSimpleBoolean(cursor.isNull(offset + 8) ? null : cursor.getShort(offset + 8) != 0);
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(TestEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(TestEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntity.java
new file mode 100644
index 00000000..c88b577f
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntity.java
@@ -0,0 +1,173 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table TO_MANY_ENTITY.
+ */
+public class ToManyEntity {
+
+    private Long id;
+    private String sourceJoinProperty;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient ToManyEntityDao myDao;
+
+    private List<ToManyTargetEntity> toManyTargetEntityList;
+    private List<ToManyTargetEntity> toManyDescList;
+    private List<ToManyTargetEntity> toManyByJoinProperty;
+    private List<ToManyTargetEntity> toManyJoinTwo;
+
+    public ToManyEntity() {
+    }
+
+    public ToManyEntity(Long id) {
+        this.id = id;
+    }
+
+    public ToManyEntity(Long id, String sourceJoinProperty) {
+        this.id = id;
+        this.sourceJoinProperty = sourceJoinProperty;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getToManyEntityDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getSourceJoinProperty() {
+        return sourceJoinProperty;
+    }
+
+    public void setSourceJoinProperty(String sourceJoinProperty) {
+        this.sourceJoinProperty = sourceJoinProperty;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<ToManyTargetEntity> getToManyTargetEntityList() {
+        if (toManyTargetEntityList == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToManyTargetEntityDao targetDao = daoSession.getToManyTargetEntityDao();
+            List<ToManyTargetEntity> toManyTargetEntityListNew = targetDao._queryToManyEntity_ToManyTargetEntityList(id);
+            synchronized (this) {
+                if(toManyTargetEntityList == null) {
+                    toManyTargetEntityList = toManyTargetEntityListNew;
+                }
+            }
+        }
+        return toManyTargetEntityList;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetToManyTargetEntityList() {
+        toManyTargetEntityList = null;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<ToManyTargetEntity> getToManyDescList() {
+        if (toManyDescList == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToManyTargetEntityDao targetDao = daoSession.getToManyTargetEntityDao();
+            List<ToManyTargetEntity> toManyDescListNew = targetDao._queryToManyEntity_ToManyDescList(id);
+            synchronized (this) {
+                if(toManyDescList == null) {
+                    toManyDescList = toManyDescListNew;
+                }
+            }
+        }
+        return toManyDescList;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetToManyDescList() {
+        toManyDescList = null;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<ToManyTargetEntity> getToManyByJoinProperty() {
+        if (toManyByJoinProperty == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToManyTargetEntityDao targetDao = daoSession.getToManyTargetEntityDao();
+            List<ToManyTargetEntity> toManyByJoinPropertyNew = targetDao._queryToManyEntity_ToManyByJoinProperty(sourceJoinProperty);
+            synchronized (this) {
+                if(toManyByJoinProperty == null) {
+                    toManyByJoinProperty = toManyByJoinPropertyNew;
+                }
+            }
+        }
+        return toManyByJoinProperty;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetToManyByJoinProperty() {
+        toManyByJoinProperty = null;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<ToManyTargetEntity> getToManyJoinTwo() {
+        if (toManyJoinTwo == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToManyTargetEntityDao targetDao = daoSession.getToManyTargetEntityDao();
+            List<ToManyTargetEntity> toManyJoinTwoNew = targetDao._queryToManyEntity_ToManyJoinTwo(id, sourceJoinProperty);
+            synchronized (this) {
+                if(toManyJoinTwo == null) {
+                    toManyJoinTwo = toManyJoinTwoNew;
+                }
+            }
+        }
+        return toManyJoinTwo;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetToManyJoinTwo() {
+        toManyJoinTwo = null;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntityDao.java
new file mode 100644
index 00000000..953c2ad0
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyEntityDao.java
@@ -0,0 +1,124 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.ToManyEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TO_MANY_ENTITY.
+*/
+public class ToManyEntityDao extends AbstractDao<ToManyEntity, Long> {
+
+    public static final String TABLENAME = "TO_MANY_ENTITY";
+
+    /**
+     * Properties of entity ToManyEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property SourceJoinProperty = new Property(1, String.class, "sourceJoinProperty", false, "SOURCE_JOIN_PROPERTY");
+    };
+
+    private DaoSession daoSession;
+
+
+    public ToManyEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ToManyEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'SOURCE_JOIN_PROPERTY' TEXT);"); // 1: sourceJoinProperty
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ToManyEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String sourceJoinProperty = entity.getSourceJoinProperty();
+        if (sourceJoinProperty != null) {
+            stmt.bindString(2, sourceJoinProperty);
+        }
+    }
+
+    @Override
+    protected void attachEntity(ToManyEntity entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ToManyEntity readEntity(Cursor cursor, int offset) {
+        ToManyEntity entity = new ToManyEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // sourceJoinProperty
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ToManyEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setSourceJoinProperty(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(ToManyEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(ToManyEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntity.java
new file mode 100644
index 00000000..ad585ffb
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntity.java
@@ -0,0 +1,60 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table TO_MANY_TARGET_ENTITY.
+ */
+public class ToManyTargetEntity {
+
+    private Long toManyId;
+    private Long toManyIdDesc;
+    private Long id;
+    private String targetJoinProperty;
+
+    public ToManyTargetEntity() {
+    }
+
+    public ToManyTargetEntity(Long id) {
+        this.id = id;
+    }
+
+    public ToManyTargetEntity(Long toManyId, Long toManyIdDesc, Long id, String targetJoinProperty) {
+        this.toManyId = toManyId;
+        this.toManyIdDesc = toManyIdDesc;
+        this.id = id;
+        this.targetJoinProperty = targetJoinProperty;
+    }
+
+    public Long getToManyId() {
+        return toManyId;
+    }
+
+    public void setToManyId(Long toManyId) {
+        this.toManyId = toManyId;
+    }
+
+    public Long getToManyIdDesc() {
+        return toManyIdDesc;
+    }
+
+    public void setToManyIdDesc(Long toManyIdDesc) {
+        this.toManyIdDesc = toManyIdDesc;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getTargetJoinProperty() {
+        return targetJoinProperty;
+    }
+
+    public void setTargetJoinProperty(String targetJoinProperty) {
+        this.targetJoinProperty = targetJoinProperty;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
new file mode 100644
index 00000000..ff44764b
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
@@ -0,0 +1,202 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+import de.greenrobot.daotest.ToManyTargetEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TO_MANY_TARGET_ENTITY.
+*/
+public class ToManyTargetEntityDao extends AbstractDao<ToManyTargetEntity, Long> {
+
+    public static final String TABLENAME = "TO_MANY_TARGET_ENTITY";
+
+    /**
+     * Properties of entity ToManyTargetEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property ToManyId = new Property(0, Long.class, "toManyId", false, "TO_MANY_ID");
+        public final static Property ToManyIdDesc = new Property(1, Long.class, "toManyIdDesc", false, "TO_MANY_ID_DESC");
+        public final static Property Id = new Property(2, Long.class, "id", true, "_id");
+        public final static Property TargetJoinProperty = new Property(3, String.class, "targetJoinProperty", false, "TARGET_JOIN_PROPERTY");
+    };
+
+    private Query<ToManyTargetEntity> toManyEntity_ToManyTargetEntityListQuery;
+    private Query<ToManyTargetEntity> toManyEntity_ToManyDescListQuery;
+    private Query<ToManyTargetEntity> toManyEntity_ToManyByJoinPropertyQuery;
+    private Query<ToManyTargetEntity> toManyEntity_ToManyJoinTwoQuery;
+
+    public ToManyTargetEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ToManyTargetEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET_ENTITY' (" + //
+                "'TO_MANY_ID' INTEGER," + // 0: toManyId
+                "'TO_MANY_ID_DESC' INTEGER," + // 1: toManyIdDesc
+                "'_id' INTEGER PRIMARY KEY ," + // 2: id
+                "'TARGET_JOIN_PROPERTY' TEXT);"); // 3: targetJoinProperty
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ToManyTargetEntity entity) {
+        stmt.clearBindings();
+ 
+        Long toManyId = entity.getToManyId();
+        if (toManyId != null) {
+            stmt.bindLong(1, toManyId);
+        }
+ 
+        Long toManyIdDesc = entity.getToManyIdDesc();
+        if (toManyIdDesc != null) {
+            stmt.bindLong(2, toManyIdDesc);
+        }
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(3, id);
+        }
+ 
+        String targetJoinProperty = entity.getTargetJoinProperty();
+        if (targetJoinProperty != null) {
+            stmt.bindString(4, targetJoinProperty);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ToManyTargetEntity readEntity(Cursor cursor, int offset) {
+        ToManyTargetEntity entity = new ToManyTargetEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // toManyId
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // toManyIdDesc
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // id
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3) // targetJoinProperty
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ToManyTargetEntity entity, int offset) {
+        entity.setToManyId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setToManyIdDesc(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+        entity.setId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
+        entity.setTargetJoinProperty(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(ToManyTargetEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(ToManyTargetEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /** Internal query to resolve the "toManyTargetEntityList" to-many relationship of ToManyEntity. */
+    public List<ToManyTargetEntity> _queryToManyEntity_ToManyTargetEntityList(Long toManyId) {
+        synchronized (this) {
+            if (toManyEntity_ToManyTargetEntityListQuery == null) {
+                QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.ToManyId.eq(null));
+                queryBuilder.orderRaw("_id ASC");
+                toManyEntity_ToManyTargetEntityListQuery = queryBuilder.build();
+            }
+        }
+        Query<ToManyTargetEntity> query = toManyEntity_ToManyTargetEntityListQuery.forCurrentThread();
+        query.setParameter(0, toManyId);
+        return query.list();
+    }
+
+    /** Internal query to resolve the "toManyDescList" to-many relationship of ToManyEntity. */
+    public List<ToManyTargetEntity> _queryToManyEntity_ToManyDescList(Long toManyIdDesc) {
+        synchronized (this) {
+            if (toManyEntity_ToManyDescListQuery == null) {
+                QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.ToManyIdDesc.eq(null));
+                queryBuilder.orderRaw("_id DESC");
+                toManyEntity_ToManyDescListQuery = queryBuilder.build();
+            }
+        }
+        Query<ToManyTargetEntity> query = toManyEntity_ToManyDescListQuery.forCurrentThread();
+        query.setParameter(0, toManyIdDesc);
+        return query.list();
+    }
+
+    /** Internal query to resolve the "toManyByJoinProperty" to-many relationship of ToManyEntity. */
+    public List<ToManyTargetEntity> _queryToManyEntity_ToManyByJoinProperty(String targetJoinProperty) {
+        synchronized (this) {
+            if (toManyEntity_ToManyByJoinPropertyQuery == null) {
+                QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.TargetJoinProperty.eq(null));
+                queryBuilder.orderRaw("_id ASC");
+                toManyEntity_ToManyByJoinPropertyQuery = queryBuilder.build();
+            }
+        }
+        Query<ToManyTargetEntity> query = toManyEntity_ToManyByJoinPropertyQuery.forCurrentThread();
+        query.setParameter(0, targetJoinProperty);
+        return query.list();
+    }
+
+    /** Internal query to resolve the "toManyJoinTwo" to-many relationship of ToManyEntity. */
+    public List<ToManyTargetEntity> _queryToManyEntity_ToManyJoinTwo(Long toManyId, String targetJoinProperty) {
+        synchronized (this) {
+            if (toManyEntity_ToManyJoinTwoQuery == null) {
+                QueryBuilder<ToManyTargetEntity> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.ToManyId.eq(null));
+                queryBuilder.where(Properties.TargetJoinProperty.eq(null));
+                queryBuilder.orderRaw("TARGET_JOIN_PROPERTY DESC,_id DESC");
+                toManyEntity_ToManyJoinTwoQuery = queryBuilder.build();
+            }
+        }
+        Query<ToManyTargetEntity> query = toManyEntity_ToManyJoinTwoQuery.forCurrentThread();
+        query.setParameter(0, toManyId);
+        query.setParameter(1, targetJoinProperty);
+        return query.list();
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntity.java
new file mode 100644
index 00000000..8b4d0ca3
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntity.java
@@ -0,0 +1,132 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table TREE_ENTITY.
+ */
+public class TreeEntity {
+
+    private Long id;
+    private Long parentId;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient TreeEntityDao myDao;
+
+    private TreeEntity parent;
+    private Long parent__resolvedKey;
+
+    private List<TreeEntity> children;
+
+    public TreeEntity() {
+    }
+
+    public TreeEntity(Long id) {
+        this.id = id;
+    }
+
+    public TreeEntity(Long id, Long parentId) {
+        this.id = id;
+        this.parentId = parentId;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getTreeEntityDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Long getParentId() {
+        return parentId;
+    }
+
+    public void setParentId(Long parentId) {
+        this.parentId = parentId;
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public TreeEntity getParent() {
+        Long __key = this.parentId;
+        if (parent__resolvedKey == null || !parent__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            TreeEntityDao targetDao = daoSession.getTreeEntityDao();
+            TreeEntity parentNew = targetDao.load(__key);
+            synchronized (this) {
+                parent = parentNew;
+            	parent__resolvedKey = __key;
+            }
+        }
+        return parent;
+    }
+
+    public void setParent(TreeEntity parent) {
+        synchronized (this) {
+            this.parent = parent;
+            parentId = parent == null ? null : parent.getId();
+            parent__resolvedKey = parentId;
+        }
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<TreeEntity> getChildren() {
+        if (children == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            TreeEntityDao targetDao = daoSession.getTreeEntityDao();
+            List<TreeEntity> childrenNew = targetDao._queryTreeEntity_Children(id);
+            synchronized (this) {
+                if(children == null) {
+                    children = childrenNew;
+                }
+            }
+        }
+        return children;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetChildren() {
+        children = null;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntityDao.java
new file mode 100644
index 00000000..14d3521a
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -0,0 +1,235 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+import de.greenrobot.daotest.TreeEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TREE_ENTITY.
+*/
+public class TreeEntityDao extends AbstractDao<TreeEntity, Long> {
+
+    public static final String TABLENAME = "TREE_ENTITY";
+
+    /**
+     * Properties of entity TreeEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property ParentId = new Property(1, Long.class, "parentId", false, "PARENT_ID");
+    };
+
+    private DaoSession daoSession;
+
+    private Query<TreeEntity> treeEntity_ChildrenQuery;
+
+    public TreeEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public TreeEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TREE_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'PARENT_ID' INTEGER);"); // 1: parentId
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TREE_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, TreeEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Long parentId = entity.getParentId();
+        if (parentId != null) {
+            stmt.bindLong(2, parentId);
+        }
+    }
+
+    @Override
+    protected void attachEntity(TreeEntity entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public TreeEntity readEntity(Cursor cursor, int offset) {
+        TreeEntity entity = new TreeEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1) // parentId
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, TreeEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setParentId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(TreeEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(TreeEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /** Internal query to resolve the "children" to-many relationship of TreeEntity. */
+    public List<TreeEntity> _queryTreeEntity_Children(Long parentId) {
+        synchronized (this) {
+            if (treeEntity_ChildrenQuery == null) {
+                QueryBuilder<TreeEntity> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.ParentId.eq(null));
+                treeEntity_ChildrenQuery = queryBuilder.build();
+            }
+        }
+        Query<TreeEntity> query = treeEntity_ChildrenQuery.forCurrentThread();
+        query.setParameter(0, parentId);
+        return query.list();
+    }
+
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
+            builder.append(" FROM TREE_ENTITY T");
+            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected TreeEntity loadCurrentDeep(Cursor cursor, boolean lock) {
+        TreeEntity entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        TreeEntity parent = loadCurrentOther(daoSession.getTreeEntityDao(), cursor, offset);
+        entity.setParent(parent);
+
+        return entity;    
+    }
+
+    public TreeEntity loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<TreeEntity> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<TreeEntity> list = new ArrayList<TreeEntity>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<TreeEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<TreeEntity> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/KeepEntity.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/KeepEntity.java
new file mode 100644
index 00000000..b3b185a8
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/KeepEntity.java
@@ -0,0 +1,41 @@
+package de.greenrobot.daotest2;
+
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+import android.os.Build;
+// KEEP INCLUDES END
+/**
+ * Entity mapped to table KEEP_ENTITY.
+ */
+public class KeepEntity {
+
+    private Long id;
+
+    // KEEP FIELDS - put your custom fields here
+    String extra = Build.VERSION.SDK;
+    // KEEP FIELDS END
+
+    public KeepEntity() {
+    }
+
+    public KeepEntity(Long id) {
+        this.id = id;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    // KEEP METHODS - put your custom methods here
+    @Override
+    public String toString() {
+        return "KeepEntity ID=42 (extra=" + extra + ")";
+    }
+    // KEEP METHODS END
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/ToManyTarget2.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/ToManyTarget2.java
new file mode 100644
index 00000000..3265f8ec
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/ToManyTarget2.java
@@ -0,0 +1,49 @@
+package de.greenrobot.daotest2;
+
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+// KEEP INCLUDES END
+/**
+ * Entity mapped to table TO_MANY_TARGET2.
+ */
+public class ToManyTarget2 {
+
+    private Long id;
+    private Long fkId;
+
+    // KEEP FIELDS - put your custom fields here
+    // KEEP FIELDS END
+
+    public ToManyTarget2() {
+    }
+
+    public ToManyTarget2(Long id) {
+        this.id = id;
+    }
+
+    public ToManyTarget2(Long id, Long fkId) {
+        this.id = id;
+        this.fkId = fkId;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Long getFkId() {
+        return fkId;
+    }
+
+    public void setFkId(Long fkId) {
+        this.fkId = fkId;
+    }
+
+    // KEEP METHODS - put your custom methods here
+    // KEEP METHODS END
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoMaster.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoMaster.java
new file mode 100644
index 00000000..699914c8
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoMaster.java
@@ -0,0 +1,82 @@
+package de.greenrobot.daotest2.dao;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.daotest2.dao.KeepEntityDao;
+import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
+import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        KeepEntityDao.createTable(db, ifNotExists);
+        ToManyTarget2Dao.createTable(db, ifNotExists);
+        ToOneTarget2Dao.createTable(db, ifNotExists);
+        RelationSource2Dao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        KeepEntityDao.dropTable(db, ifExists);
+        ToManyTarget2Dao.dropTable(db, ifExists);
+        ToOneTarget2Dao.dropTable(db, ifExists);
+        RelationSource2Dao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(KeepEntityDao.class);
+        registerDaoClass(ToManyTarget2Dao.class);
+        registerDaoClass(ToOneTarget2Dao.class);
+        registerDaoClass(RelationSource2Dao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoSession.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoSession.java
new file mode 100644
index 00000000..ecd6983b
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/DaoSession.java
@@ -0,0 +1,91 @@
+package de.greenrobot.daotest2.dao;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest2.KeepEntity;
+import de.greenrobot.daotest2.ToManyTarget2;
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+import de.greenrobot.daotest2.specialentity.RelationSource2;
+
+import de.greenrobot.daotest2.dao.KeepEntityDao;
+import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
+import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig keepEntityDaoConfig;
+    private final DaoConfig toManyTarget2DaoConfig;
+    private final DaoConfig toOneTarget2DaoConfig;
+    private final DaoConfig relationSource2DaoConfig;
+
+    private final KeepEntityDao keepEntityDao;
+    private final ToManyTarget2Dao toManyTarget2Dao;
+    private final ToOneTarget2Dao toOneTarget2Dao;
+    private final RelationSource2Dao relationSource2Dao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        keepEntityDaoConfig = daoConfigMap.get(KeepEntityDao.class).clone();
+        keepEntityDaoConfig.initIdentityScope(type);
+
+        toManyTarget2DaoConfig = daoConfigMap.get(ToManyTarget2Dao.class).clone();
+        toManyTarget2DaoConfig.initIdentityScope(type);
+
+        toOneTarget2DaoConfig = daoConfigMap.get(ToOneTarget2Dao.class).clone();
+        toOneTarget2DaoConfig.initIdentityScope(type);
+
+        relationSource2DaoConfig = daoConfigMap.get(RelationSource2Dao.class).clone();
+        relationSource2DaoConfig.initIdentityScope(type);
+
+        keepEntityDao = new KeepEntityDao(keepEntityDaoConfig, this);
+        toManyTarget2Dao = new ToManyTarget2Dao(toManyTarget2DaoConfig, this);
+        toOneTarget2Dao = new ToOneTarget2Dao(toOneTarget2DaoConfig, this);
+        relationSource2Dao = new RelationSource2Dao(relationSource2DaoConfig, this);
+
+        registerDao(KeepEntity.class, keepEntityDao);
+        registerDao(ToManyTarget2.class, toManyTarget2Dao);
+        registerDao(ToOneTarget2.class, toOneTarget2Dao);
+        registerDao(RelationSource2.class, relationSource2Dao);
+    }
+    
+    public void clear() {
+        keepEntityDaoConfig.getIdentityScope().clear();
+        toManyTarget2DaoConfig.getIdentityScope().clear();
+        toOneTarget2DaoConfig.getIdentityScope().clear();
+        relationSource2DaoConfig.getIdentityScope().clear();
+    }
+
+    public KeepEntityDao getKeepEntityDao() {
+        return keepEntityDao;
+    }
+
+    public ToManyTarget2Dao getToManyTarget2Dao() {
+        return toManyTarget2Dao;
+    }
+
+    public ToOneTarget2Dao getToOneTarget2Dao() {
+        return toOneTarget2Dao;
+    }
+
+    public RelationSource2Dao getRelationSource2Dao() {
+        return relationSource2Dao;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
new file mode 100644
index 00000000..f8de31aa
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
@@ -0,0 +1,106 @@
+package de.greenrobot.daotest2.dao;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest2.KeepEntity;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table KEEP_ENTITY.
+*/
+public class KeepEntityDao extends AbstractDao<KeepEntity, Long> {
+
+    public static final String TABLENAME = "KEEP_ENTITY";
+
+    /**
+     * Properties of entity KeepEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+    };
+
+
+    public KeepEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public KeepEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'KEEP_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY );"); // 0: id
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'KEEP_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, KeepEntity entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public KeepEntity readEntity(Cursor cursor, int offset) {
+        KeepEntity entity = new KeepEntity( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0) // id
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, KeepEntity entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(KeepEntity entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(KeepEntity entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
new file mode 100644
index 00000000..a55df346
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
@@ -0,0 +1,133 @@
+package de.greenrobot.daotest2.dao;
+
+import java.util.List;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+import de.greenrobot.daotest2.ToManyTarget2;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TO_MANY_TARGET2.
+*/
+public class ToManyTarget2Dao extends AbstractDao<ToManyTarget2, Long> {
+
+    public static final String TABLENAME = "TO_MANY_TARGET2";
+
+    /**
+     * Properties of entity ToManyTarget2.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property FkId = new Property(1, Long.class, "fkId", false, "FK_ID");
+    };
+
+    private Query<ToManyTarget2> relationSource2_ToManyTarget2ListQuery;
+
+    public ToManyTarget2Dao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ToManyTarget2Dao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET2' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'FK_ID' INTEGER);"); // 1: fkId
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET2'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ToManyTarget2 entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Long fkId = entity.getFkId();
+        if (fkId != null) {
+            stmt.bindLong(2, fkId);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ToManyTarget2 readEntity(Cursor cursor, int offset) {
+        ToManyTarget2 entity = new ToManyTarget2( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1) // fkId
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ToManyTarget2 entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setFkId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(ToManyTarget2 entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(ToManyTarget2 entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /** Internal query to resolve the "toManyTarget2List" to-many relationship of RelationSource2. */
+    public List<ToManyTarget2> _queryRelationSource2_ToManyTarget2List(Long fkId) {
+        synchronized (this) {
+            if (relationSource2_ToManyTarget2ListQuery == null) {
+                QueryBuilder<ToManyTarget2> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.FkId.eq(null));
+                relationSource2_ToManyTarget2ListQuery = queryBuilder.build();
+            }
+        }
+        Query<ToManyTarget2> query = relationSource2_ToManyTarget2ListQuery.forCurrentThread();
+        query.setParameter(0, fkId);
+        return query.list();
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
new file mode 100644
index 00000000..107160bc
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -0,0 +1,222 @@
+package de.greenrobot.daotest2.specialdao;
+
+import java.util.List;
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest2.dao.DaoSession;
+
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+
+import de.greenrobot.daotest2.specialentity.RelationSource2;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table RELATION_SOURCE2.
+*/
+public class RelationSource2Dao extends AbstractDao<RelationSource2, Long> {
+
+    public static final String TABLENAME = "RELATION_SOURCE2";
+
+    /**
+     * Properties of entity RelationSource2.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property ToOneId = new Property(1, Long.class, "toOneId", false, "TO_ONE_ID");
+    };
+
+    private DaoSession daoSession;
+
+
+    public RelationSource2Dao(DaoConfig config) {
+        super(config);
+    }
+    
+    public RelationSource2Dao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'RELATION_SOURCE2' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TO_ONE_ID' INTEGER);"); // 1: toOneId
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_SOURCE2'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, RelationSource2 entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Long toOneId = entity.getToOneId();
+        if (toOneId != null) {
+            stmt.bindLong(2, toOneId);
+        }
+    }
+
+    @Override
+    protected void attachEntity(RelationSource2 entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public RelationSource2 readEntity(Cursor cursor, int offset) {
+        RelationSource2 entity = new RelationSource2( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1) // toOneId
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, RelationSource2 entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setToOneId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(RelationSource2 entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(RelationSource2 entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
+            builder.append(" FROM RELATION_SOURCE2 T");
+            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationSource2 loadCurrentDeep(Cursor cursor, boolean lock) {
+        RelationSource2 entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        ToOneTarget2 toOneTarget2 = loadCurrentOther(daoSession.getToOneTarget2Dao(), cursor, offset);
+        entity.setToOneTarget2(toOneTarget2);
+
+        return entity;    
+    }
+
+    public RelationSource2 loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationSource2> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<RelationSource2> list = new ArrayList<RelationSource2>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationSource2> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationSource2> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
new file mode 100644
index 00000000..ff587223
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/specialentity/RelationSource2.java
@@ -0,0 +1,147 @@
+package de.greenrobot.daotest2.specialentity;
+
+import java.util.List;
+import de.greenrobot.daotest2.dao.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+import de.greenrobot.daotest2.ToManyTarget2;
+import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+// KEEP INCLUDES END
+/**
+ * Entity mapped to table RELATION_SOURCE2.
+ */
+public class RelationSource2 {
+
+    private Long id;
+    private Long toOneId;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient RelationSource2Dao myDao;
+
+    private ToOneTarget2 toOneTarget2;
+    private Long toOneTarget2__resolvedKey;
+
+    private List<ToManyTarget2> toManyTarget2List;
+
+    // KEEP FIELDS - put your custom fields here
+    // KEEP FIELDS END
+
+    public RelationSource2() {
+    }
+
+    public RelationSource2(Long id) {
+        this.id = id;
+    }
+
+    public RelationSource2(Long id, Long toOneId) {
+        this.id = id;
+        this.toOneId = toOneId;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getRelationSource2Dao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Long getToOneId() {
+        return toOneId;
+    }
+
+    public void setToOneId(Long toOneId) {
+        this.toOneId = toOneId;
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public ToOneTarget2 getToOneTarget2() {
+        Long __key = this.toOneId;
+        if (toOneTarget2__resolvedKey == null || !toOneTarget2__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToOneTarget2Dao targetDao = daoSession.getToOneTarget2Dao();
+            ToOneTarget2 toOneTarget2New = targetDao.load(__key);
+            synchronized (this) {
+                toOneTarget2 = toOneTarget2New;
+            	toOneTarget2__resolvedKey = __key;
+            }
+        }
+        return toOneTarget2;
+    }
+
+    public void setToOneTarget2(ToOneTarget2 toOneTarget2) {
+        synchronized (this) {
+            this.toOneTarget2 = toOneTarget2;
+            toOneId = toOneTarget2 == null ? null : toOneTarget2.getId();
+            toOneTarget2__resolvedKey = toOneId;
+        }
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<ToManyTarget2> getToManyTarget2List() {
+        if (toManyTarget2List == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ToManyTarget2Dao targetDao = daoSession.getToManyTarget2Dao();
+            List<ToManyTarget2> toManyTarget2ListNew = targetDao._queryRelationSource2_ToManyTarget2List(id);
+            synchronized (this) {
+                if(toManyTarget2List == null) {
+                    toManyTarget2List = toManyTarget2ListNew;
+                }
+            }
+        }
+        return toManyTarget2List;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetToManyTarget2List() {
+        toManyTarget2List = null;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+    // KEEP METHODS - put your custom methods here
+    // KEEP METHODS END
+
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
new file mode 100644
index 00000000..3ff139b3
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
@@ -0,0 +1,108 @@
+package de.greenrobot.daotest2.to1_specialdao;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest2.dao.DaoSession;
+
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table TO_ONE_TARGET2.
+*/
+public class ToOneTarget2Dao extends AbstractDao<ToOneTarget2, Long> {
+
+    public static final String TABLENAME = "TO_ONE_TARGET2";
+
+    /**
+     * Properties of entity ToOneTarget2.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+    };
+
+
+    public ToOneTarget2Dao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ToOneTarget2Dao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'TO_ONE_TARGET2' (" + //
+                "'_id' INTEGER PRIMARY KEY );"); // 0: id
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_ONE_TARGET2'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ToOneTarget2 entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ToOneTarget2 readEntity(Cursor cursor, int offset) {
+        ToOneTarget2 entity = new ToOneTarget2( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0) // id
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ToOneTarget2 entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(ToOneTarget2 entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(ToOneTarget2 entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
new file mode 100644
index 00000000..d5444c79
--- /dev/null
+++ b/DaoTest/src/androidTest/java-gen/de/greenrobot/daotest2/to1_specialentity/ToOneTarget2.java
@@ -0,0 +1,35 @@
+package de.greenrobot.daotest2.to1_specialentity;
+
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+// KEEP INCLUDES END
+/**
+ * Entity mapped to table TO_ONE_TARGET2.
+ */
+public class ToOneTarget2 {
+
+    private Long id;
+
+    // KEEP FIELDS - put your custom fields here
+    // KEEP FIELDS END
+
+    public ToOneTarget2() {
+    }
+
+    public ToOneTarget2(Long id) {
+        this.id = id;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    // KEEP METHODS - put your custom methods here
+    // KEEP METHODS END
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/ApplicationTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/ApplicationTest.java
new file mode 100644
index 00000000..ce49ddce
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/ApplicationTest.java
@@ -0,0 +1,13 @@
+package de.greenrobot.daotest;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java
new file mode 100644
index 00000000..ffa9e718
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -0,0 +1,352 @@
+package de.greenrobot.daotest;
+
+import java.util.concurrent.CountDownLatch;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.os.SystemClock;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class DaoSessionConcurrentTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+    class TestThread extends Thread {
+        final Runnable runnable;
+
+        public TestThread(Runnable runnable) {
+            this.runnable = runnable;
+        }
+
+        @Override
+        public void run() {
+            latchThreadsReady.countDown();
+            try {
+                latchInsideTx.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            runnable.run();
+            latchThreadsDone.countDown();
+        }
+
+    }
+
+    private final static int TIME_TO_WAIT_FOR_THREAD = 100; // Use 1000 to be on the safe side, 100 once stable
+
+    protected TestEntityDao dao;
+
+    protected CountDownLatch latchThreadsReady;
+    protected CountDownLatch latchInsideTx;
+    protected CountDownLatch latchThreadsDone;
+
+    public DaoSessionConcurrentTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getTestEntityDao();
+    }
+
+    protected void initThreads(Runnable... runnables) throws InterruptedException {
+        latchThreadsReady = new CountDownLatch(runnables.length);
+        latchInsideTx = new CountDownLatch(1);
+        latchThreadsDone = new CountDownLatch(runnables.length);
+        for (Runnable runnable : runnables) {
+            new TestThread(runnable).start();
+        }
+        latchThreadsReady.await();
+    }
+
+    public void testConcurrentInsertDuringTx() throws InterruptedException {
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                dao.insert(createEntity(null));
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                dao.insertInTx(createEntity(null));
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                daoSession.runInTx(new Runnable() {
+                    @Override
+                    public void run() {
+                        dao.insert(createEntity(null));
+                    }
+                });
+            }
+        };
+        Runnable runnable4 = new Runnable() {
+            @Override
+            public void run() {
+                dao.insertWithoutSettingPk(createEntity(null));
+            }
+        };
+        Runnable runnable5 = new Runnable() {
+            @Override
+            public void run() {
+                dao.insertOrReplace(createEntity(null));
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3, runnable4, runnable5);
+        // Builds the statement so it is ready immediately in the thread
+        dao.insert(createEntity(null));
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                dao.insert(createEntity(null));
+            }
+        });
+        latchThreadsDone.await();
+        assertEquals(7, dao.count());
+    }
+
+    public void testConcurrentUpdateDuringTx() throws InterruptedException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                dao.update(entity);
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                dao.updateInTx(entity);
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                daoSession.runInTx(new Runnable() {
+                    @Override
+                    public void run() {
+                        dao.update(entity);
+                    }
+                });
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3);
+        // Builds the statement so it is ready immediately in the thread
+        dao.update(entity);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                dao.update(entity);
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentDeleteDuringTx() throws InterruptedException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                dao.delete(entity);
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                dao.deleteInTx(entity);
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                daoSession.runInTx(new Runnable() {
+                    @Override
+                    public void run() {
+                        dao.delete(entity);
+                    }
+                });
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3);
+        // Builds the statement so it is ready immediately in the thread
+        dao.delete(entity);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                dao.delete(entity);
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    // Query doesn't involve any statement locking currently, but just to stay on the safe side...
+    public void testConcurrentQueryDuringTx() throws InterruptedException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final Query<TestEntity> query = dao.queryBuilder().build();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                query.forCurrentThread().list();
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.list();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                query.list();
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    // No connection for read can be acquired while TX is active; this will deadlock!
+    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final Query<TestEntity> query = dao.queryBuilder().build();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    query.list();
+                }
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.list();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    query.list();
+                }
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentDeleteQueryDuringTx() throws InterruptedException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                query.forCurrentThread().executeDeleteWithoutDetachingEntities();
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.executeDeleteWithoutDetachingEntities();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                query.executeDeleteWithoutDetachingEntities();
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentResolveToMany() throws InterruptedException {
+        final ToManyEntity entity = new ToManyEntity();
+        ToManyEntityDao toManyDao = daoSession.getToManyEntityDao();
+        toManyDao.insert(entity);
+
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                entity.getToManyTargetEntityList();
+            }
+        };
+
+        initThreads(runnable1);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                entity.getToManyTargetEntityList();
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentResolveToOne() throws InterruptedException {
+        final TreeEntity entity = new TreeEntity();
+        TreeEntityDao toOneDao = daoSession.getTreeEntityDao();
+        toOneDao.insert(entity);
+
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                entity.getParent();
+            }
+        };
+
+        initThreads(runnable1);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                entity.getParent();
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    /**
+     * We could put the statements inside ThreadLocals (fast enough), but it comes with initialization penalty for new
+     * threads and costs more memory.
+     */
+    public void _testThreadLocalSpeed() {
+        final SQLiteDatabase db = dao.getDatabase();
+        ThreadLocal<SQLiteStatement> threadLocal = new ThreadLocal<SQLiteStatement>() {
+            @Override
+            protected SQLiteStatement initialValue() {
+                return db.compileStatement("SELECT 42");
+            }
+        };
+        threadLocal.get();
+        long start = SystemClock.currentThreadTimeMillis();
+        for (int i = 0; i < 1000; i++) {
+            SQLiteStatement sqLiteStatement = threadLocal.get();
+            assertNotNull(sqLiteStatement);
+        }
+        Long time = SystemClock.currentThreadTimeMillis() - start;
+        DaoLog.d("TIME: " + time + "ms");
+        // Around 1ms on a S3
+        assertTrue(time < 10);
+    }
+
+    protected void doTx(final Runnable runnableInsideTx) {
+        daoSession.runInTx(new Runnable() {
+            @Override
+            public void run() {
+                latchInsideTx.countDown();
+                // Give the concurrent thread time so it will try to acquire locks
+                try {
+                    Thread.sleep(TIME_TO_WAIT_FOR_THREAD);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+                runnableInsideTx.run();
+            }
+        });
+    }
+
+    protected TestEntity createEntity(Long key) {
+        TestEntity entity = new TestEntity(key);
+        entity.setSimpleStringNotNull("green");
+        return entity;
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
new file mode 100644
index 00000000..89f66b6c
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
@@ -0,0 +1,60 @@
+package de.greenrobot.daotest;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Build;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.Query;
+
+import java.lang.reflect.Method;
+
+public class DaoSessionConcurrentWALTest extends DaoSessionConcurrentTest {
+
+    @Override
+    protected SQLiteDatabase createDatabase() {
+        int MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;
+        getContext().deleteDatabase(DB_NAME);
+        return getContext().openOrCreateDatabase(DB_NAME, MODE_ENABLE_WRITE_AHEAD_LOGGING, null);
+    }
+
+    public void testConcurrentLockAndQueryDuringTxWAL() throws InterruptedException {
+        if (Build.VERSION.SDK_INT >= 16) {
+            try {
+                Method method = db.getClass().getMethod("isWriteAheadLoggingEnabled");
+                boolean walEnabled = (Boolean) method.invoke(db);
+                if (!walEnabled) {
+                    throw new RuntimeException("WAL is disabled. This test will deadlock without WAL");
+                }
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            DaoLog.e("Sorry, we need at least API level 16 for WAL");
+            return;
+        }
+
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final Query<TestEntity> query = dao.queryBuilder().build();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    query.forCurrentThread().list();
+                }
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.list();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    query.list();
+                }
+            }
+        });
+        latchThreadsDone.await();
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionTest.java
new file mode 100644
index 00000000..dc44c2b7
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DaoSessionTest.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class DaoSessionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public DaoSessionTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testInsertAndLoad() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        Long id = entity.getId();
+        assertNotNull(id);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, id);
+        assertNotNull(entity2);
+    }
+
+    public void testIdentity() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+    }
+
+    public void testIdentityPerSession() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        DaoSession session2 = daoMaster.newSession();
+        SimpleEntity entity2 = session2.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
+
+    public void testSessionReset() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
+}
\ No newline at end of file
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbTestTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbTestTest.java
new file mode 100644
index 00000000..1ec6d84f
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbTestTest.java
@@ -0,0 +1,117 @@
+package de.greenrobot.daotest;
+
+import android.app.Application;
+import de.greenrobot.dao.test.DbTest;
+import junit.framework.AssertionFailedError;
+
+public class DbTestTest extends DbTest {
+    public static class MyApp extends Application {
+        static int onCreateCounterStatic;
+        static int onTerminateCounterStatic;
+
+        int onCreateCounter;
+        int onTerminateCounter;
+
+        @Override
+        public void onCreate() {
+            super.onCreate();
+            onCreateCounter++;
+            onCreateCounterStatic++;
+        }
+
+        @Override
+        public void onTerminate() {
+            super.onTerminate();
+            onTerminateCounterStatic++;
+            onTerminateCounter++;
+        }
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        MyApp.onCreateCounterStatic = 0;
+        MyApp.onTerminateCounterStatic = 0;
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        assertEquals(MyApp.onCreateCounterStatic, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testCreateApplication() {
+        MyApp app = createApplication(MyApp.class);
+        assertNotNull(app);
+
+        assertEquals(1, app.onCreateCounter);
+        assertEquals(1, MyApp.onCreateCounterStatic);
+        assertEquals(0, app.onTerminateCounter);
+        assertEquals(0, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testTerminateApplication() {
+        MyApp app = createApplication(MyApp.class);
+        terminateApplication();
+
+        assertEquals(1, app.onCreateCounter);
+        assertEquals(1, MyApp.onCreateCounterStatic);
+        assertEquals(1, app.onTerminateCounter);
+        assertEquals(1, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testGetApplicationBeforeCreate() {
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+    }
+
+    public void testGetApplication() {
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+
+        MyApp app = createApplication(MyApp.class);
+        MyApp app2 = getApplication();
+        assertSame(app, app2);
+    }
+
+    public void testGetApplicationAfterTerminate() {
+        MyApp app = createApplication(MyApp.class);
+        terminateApplication();
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+    }
+
+
+    public void testMultipleApplications() {
+        MyApp app1 = createApplication(MyApp.class);
+        terminateApplication();
+
+        MyApp app2 = createApplication(MyApp.class);
+        assertNotSame(app2, app1);
+
+        MyApp app = getApplication();
+        assertSame(app2, app);
+
+        assertEquals(1, app1.onCreateCounter);
+        assertEquals(1, app1.onTerminateCounter);
+        assertEquals(1, app2.onCreateCounter);
+        assertEquals(0, app2.onTerminateCounter);
+
+        assertEquals(2, MyApp.onCreateCounterStatic);
+        assertEquals(1, MyApp.onTerminateCounterStatic);
+    }
+
+
+}
\ No newline at end of file
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbUtilsTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbUtilsTest.java
new file mode 100644
index 00000000..09f71b5c
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/DbUtilsTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import de.greenrobot.dao.test.DbTest;
+
+public class DbUtilsTest extends DbTest {
+//    public void testExecuteSqlScript() throws IOException {
+//        DbUtils.executeSqlScript(getContext(), db, "minimal-entity.sql");
+//        Cursor cursor = db.rawQuery("SELECT count(*) from MINIMAL_ENTITY", null);
+//        try {
+//            cursor.moveToFirst();
+//            assertEquals(5, cursor.getInt(0));
+//        } finally {
+//            cursor.close();
+//        }
+//    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/IndexTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/IndexTest.java
new file mode 100644
index 00000000..402b367c
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/IndexTest.java
@@ -0,0 +1,49 @@
+package de.greenrobot.daotest;
+
+import java.util.List;
+
+import junit.framework.Assert;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SqliteMasterDao.Properties;
+
+public class IndexTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
+
+    public IndexTest() {
+        super(SqliteMasterDao.class);
+    }
+
+    public void testIndexesCreated() {
+        Assert.assertEquals(0, getIndexes().size());
+
+        TestEntityDao.createTable(db, false);
+        List<SqliteMaster> indexes = getIndexes();
+        Assert.assertEquals(2, indexes.size());
+
+        SqliteMaster index1 = indexes.get(0);
+        SqliteMaster index2 = indexes.get(1);
+        Assert.assertEquals(TestEntityDao.TABLENAME, index1.getTableName());
+        Assert.assertEquals(TestEntityDao.TABLENAME, index2.getTableName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING", index1.getName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE", index2.getName());
+
+        for (SqliteMaster index : indexes) {
+            DaoLog.v(index.toString());
+        }
+    }
+    
+    public void testIndexCreateIfNotExists() {
+        Assert.assertEquals(0, getIndexes().size());
+        TestEntityDao.createTable(db, false);
+        Assert.assertEquals(2, getIndexes().size());
+        TestEntityDao.createTable(db, true);
+        Assert.assertEquals(2, getIndexes().size());
+    }
+
+    private List<SqliteMaster> getIndexes() {
+        String where = "WHERE " + Properties.Type.columnName + "=? ORDER BY " + Properties.Name.columnName;
+        List<SqliteMaster> indexes = dao.queryRaw(where, "index");
+        return indexes;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/LongHashMapTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/LongHashMapTest.java
new file mode 100644
index 00000000..433658bd
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/LongHashMapTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.util.Random;
+
+import junit.framework.TestCase;
+import de.greenrobot.dao.internal.LongHashMap;
+
+public class LongHashMapTest extends TestCase {
+
+    Random random;
+    private String traceName;
+    private long start;
+
+    public LongHashMapTest() {
+        this.random = new Random();
+    }
+
+    public void testLongHashMapSimple() {
+        LongHashMap<Object> map = new LongHashMap<Object>();
+
+        map.put(1l << 33, "OK");
+        assertNull(map.get(0));
+        assertEquals("OK", map.get(1l << 33));
+
+        long keyLong = 0x7fffffffl << 33l + 14;
+        assertNull(map.remove(keyLong));
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+        assertEquals("OK", map.remove(keyLong));
+
+        keyLong = Long.MAX_VALUE;
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+
+        keyLong = 8064216579113853113l;
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+
+    }
+
+    public void testLongHashMapRandom() {
+        LongHashMap<Object> map = new LongHashMap<Object>();
+        for (int i = 0; i < 5000; i++) {
+            long key = random.nextLong();
+            String value = "Value-" + key;
+            map.put(key, value);
+            assertTrue("" + key, map.containsKey(key));
+
+            int keyInt = (int) key;
+            String valueInt = "Value-" + keyInt;
+            map.put(keyInt, valueInt);
+            assertTrue(map.containsKey(keyInt));
+
+            assertEquals(value, map.get(key));
+            assertEquals(valueInt, map.get(keyInt));
+
+            assertEquals(value, map.remove(key));
+            assertEquals(valueInt, map.remove(keyInt));
+
+            assertNull(map.get(key));
+            assertNull(map.get(keyInt));
+        }
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestInterface.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestInterface.java
new file mode 100644
index 00000000..035d4ab2
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestInterface.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest;
+
+public interface TestInterface {
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestSuperclass.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestSuperclass.java
new file mode 100644
index 00000000..f360e3d0
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/TestSuperclass.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest;
+
+public class TestSuperclass {
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/AbstractAsyncTest.java
new file mode 100644
index 00000000..c363aa5e
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/AbstractAsyncTest.java
@@ -0,0 +1,47 @@
+package de.greenrobot.daotest.async;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> implements
+        AsyncOperationListener {
+
+    protected AsyncSession asyncSession;
+    protected List<AsyncOperation> completedOperations;
+
+    public AbstractAsyncTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        asyncSession = daoSession.startAsyncSession();
+        asyncSession.setListener(this);
+        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
+    }
+
+    public void assertWaitForCompletion1Sec() {
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertTrue(asyncSession.isCompleted());
+    }
+
+    @Override
+    public void onAsyncOperationCompleted(AsyncOperation operation) {
+        completedOperations.add(operation);
+    }
+
+    protected void assertSingleOperationCompleted(AsyncOperation operation) {
+        assertSame(operation, completedOperations.get(0));
+        assertEquals(1, completedOperations.size());
+        assertTrue(operation.isCompleted());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/BasicAsyncTest.java
new file mode 100644
index 00000000..af7cdc69
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/BasicAsyncTest.java
@@ -0,0 +1,157 @@
+package de.greenrobot.daotest.async;
+
+import android.os.Looper;
+
+import java.util.concurrent.Callable;
+
+import de.greenrobot.dao.async.AsyncDaoException;
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class BasicAsyncTest extends de.greenrobot.daotest.async.AbstractAsyncTest {
+
+    Thread txThread;
+    boolean testListenerMainThread_done;
+
+    public void testSequenceNumber() {
+        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
+        assertEquals(1, op1.getSequenceNumber());
+        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
+        assertEquals(2, op2.getSequenceNumber());
+    }
+
+    public void testWaitForCompletionNoOps() {
+        assertTrue(asyncSession.isCompleted());
+        assertTrue(asyncSession.waitForCompletion(1));
+        asyncSession.waitForCompletion();
+    }
+
+    public void testAsyncInsert() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("heho", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        entity.setSimpleString("updated");
+        AsyncOperation operation = asyncSession.update(entity);
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("updated", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testOperationGetResult() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        daoSession.clear();
+
+        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity result = (SimpleEntity) operation.getResult();
+        assertTrue(operation.isCompleted());
+        assertTrue(operation.isCompletedSucessfully());
+        assertNotNull(result);
+        assertNotSame(entity, result);
+        assertEquals(entity.getId(), result.getId());
+        assertEquals(entity.getSimpleString(), result.getSimpleString());
+    }
+
+    public void testOperationGetResultException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        try {
+            operation.getResult();
+            fail("getResult should have thrown");
+        } catch (AsyncDaoException expected) {
+            // OK
+        }
+        assertTrue(operation.isCompleted());
+        assertFalse(operation.isCompletedSucessfully());
+        assertTrue(operation.isFailed());
+    }
+
+    public void testAsyncException() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+
+        assertTrue(operation.isFailed());
+        assertNotNull(operation.getThrowable());
+    }
+
+    public void testAsyncOperationWaitMillis() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncOperationWait() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        asyncSession.waitForCompletion();
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncRunInTx() {
+        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
+
+            @Override
+            public void run() {
+                txThread = Thread.currentThread();
+            }
+        });
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testAsynCallInTx() {
+        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
+
+            @Override
+            public String call() throws Exception {
+                txThread = Thread.currentThread();
+                return "OK";
+            }
+        });
+        assertEquals("OK", operation.waitForCompletion());
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testListenerMainThread() throws InterruptedException {
+        AsyncOperationListener listener = new AsyncOperationListener() {
+            @Override
+            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
+                assertEquals(Looper.getMainLooper(), Looper.myLooper());
+                testListenerMainThread_done = true;
+                notifyAll();
+            }
+        };
+        asyncSession.setListenerMainThread(listener);
+        asyncSession.insert(new SimpleEntity());
+        assertWaitForCompletion1Sec();
+        while (!testListenerMainThread_done) {
+            synchronized (listener) {
+                listener.wait();
+            }
+        }
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/MergeTxAsyncTest.java
new file mode 100644
index 00000000..b22958a9
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/async/MergeTxAsyncTest.java
@@ -0,0 +1,30 @@
+package de.greenrobot.daotest.async;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class MergeTxAsyncTest extends AbstractAsyncTest {
+
+    public void testMergeInsertAndUpdate() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(42l);
+        entity.setSimpleString("heho");
+        
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setId(42l);
+        entity2.setSimpleString("updated");
+        
+        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
+        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
+        
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
+        assertNotNull(entity3);
+        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
+        
+        assertEquals(2, op1.getMergedOperationsCount());
+        assertEquals(2, op2.getMergedOperationsCount());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
new file mode 100644
index 00000000..d66bfa5a
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.contentprovider;
+
+import android.database.Cursor;
+import android.test.suitebuilder.annotation.Suppress;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityContentProvider;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+@Suppress
+// TODO Activate once the gradle build is fixed (AndroidManifest.xml is not used for instrumentTest)
+public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public SimpleEntityContentProviderTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        SimpleEntityContentProvider.daoSession = daoSession;
+    }
+
+    public void testQuery() {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("hello");
+        daoSession.insert(entity);
+        long id = entity.getId();
+
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setSimpleString("content");
+        daoSession.insert(entity2);
+        long id2 = entity2.getId();
+        Cursor cursor = getContext().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
+                null, null, "_id");
+        assertEquals(2, cursor.getCount());
+        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
+        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
+
+        assertTrue(cursor.moveToFirst());
+        assertEquals("hello", cursor.getString(idxString));
+        assertEquals(id, cursor.getLong(idxId));
+
+        assertTrue(cursor.moveToNext());
+        assertEquals("content", cursor.getString(idxString));
+        assertEquals(id2, cursor.getLong(idxId));
+    }
+
+}
\ No newline at end of file
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AbcdefEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AbcdefEntityTest.java
new file mode 100644
index 00000000..e2797471
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AbcdefEntityTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.AbcdefEntityDao;
+
+public class AbcdefEntityTest extends AbstractDaoTestLongPk<AbcdefEntityDao, AbcdefEntity> {
+
+    public AbcdefEntityTest() {
+        super(AbcdefEntityDao.class);
+    }
+
+    @Override
+    protected AbcdefEntity createEntity(Long key) {
+        AbcdefEntity entity = new AbcdefEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
new file mode 100644
index 00000000..af0fc459
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.lang.reflect.Field;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public class AnActiveEntityMultithreadingTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    /** Serious multithreading tests require this set to true. */
+    private static final boolean LONG_RUNNING = false;
+    private static final int ENTITIES_TO_CHECK = LONG_RUNNING ? 1000000 : 10000;
+
+    private AnActiveEntityDao dao;
+    private CountDownLatch latch = new CountDownLatch(2);
+    volatile boolean running = true;
+
+    public AnActiveEntityMultithreadingTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getAnActiveEntityDao();
+    }
+
+    public void testAlwaysAttachedWithInsertDelete() throws Exception {
+        doTestAlwaysAttached(new InsertDeleteThread());
+    }
+
+    public void testAlwaysAttachedWithDetach() throws Exception {
+        doTestAlwaysAttached(new DetachThread());
+    }
+
+    private void doTestAlwaysAttached(Thread thread) throws Exception {
+        thread.start();
+
+        Field daoSessionField = AnActiveEntity.class.getDeclaredField("daoSession");
+        daoSessionField.setAccessible(true);
+
+        int countEntity = 0;
+        countDownAndAwaitLatch();
+
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+            for (int i = 0;; i++) {
+                AnActiveEntity entity = dao.load(1l);
+                if (entity != null) {
+                    countEntity++;
+                    assertNotNull(daoSessionField.get(entity));
+                }
+                if (i == 1000000 && countEntity == 0) {
+                    fail("No entity available");
+                }
+                if (countEntity % 10000 == 0) {
+                    DaoLog.d("Checked entities " + countEntity + " in " + i + " iterations");
+                }
+                if (countEntity == ENTITIES_TO_CHECK) {
+                    break;
+                }
+            }
+        } finally {
+            running = false;
+            thread.join();
+        }
+    }
+
+    private void countDownAndAwaitLatch() {
+        latch.countDown();
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    class InsertDeleteThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            while (running) {
+                AnActiveEntity entity = null;
+                entity = new AnActiveEntity(1l);
+                dao.insert(entity);
+                dao.delete(entity);
+            }
+        }
+    }
+
+    class DetachThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            AnActiveEntity entity = new AnActiveEntity(1l);
+            dao.insert(entity);
+            while (running) {
+                dao.detach(entity);
+                entity = dao.load(1l);
+            }
+        }
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityTest.java
new file mode 100644
index 00000000..ddb9398f
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AnActiveEntityTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public class AnActiveEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private AnActiveEntityDao dao;
+
+    public AnActiveEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getAnActiveEntityDao();
+    }
+
+    public void testThrowWhenDetached() {
+        AnActiveEntity entity = new AnActiveEntity();
+        try {
+            entity.delete();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+        try {
+            entity.refresh();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+        try {
+            entity.update();
+            fail("Should fail for detached entity");
+        } catch (DaoException e) {
+            // OK, expected
+        }
+    }
+
+    public void testActiveUpdate() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        long rowId = dao.insert(entity);
+
+        entity.setText("NEW");
+        entity.update();
+
+        daoSession.clear();
+        AnActiveEntity entity2 = dao.load(rowId);
+        assertNotSame(entity, entity2);
+        assertEquals("NEW", entity2.getText());
+    }
+
+    public void testActiveRefresh() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        dao.insert(entity);
+
+        AnActiveEntity entity2 = new AnActiveEntity(1l);
+        entity2.setText("NEW");
+        dao.update(entity2);
+
+        entity.refresh();
+        assertEquals("NEW", entity.getText());
+    }
+
+    public void testActiveDelete() {
+        AnActiveEntity entity = new AnActiveEntity(1l);
+        dao.insert(entity);
+
+        entity.delete();
+        assertNull(dao.load(1l));
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AutoincrementEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
new file mode 100644
index 00000000..2be68193
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/AutoincrementEntityTest.java
@@ -0,0 +1,39 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AutoincrementEntity;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class AutoincrementEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public AutoincrementEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testAutoincrement() {
+        AutoincrementEntity entity = new AutoincrementEntity();
+        daoSession.insert(entity);
+        Long id1 = entity.getId();
+        assertNotNull(id1);
+        daoSession.delete(entity);
+
+        AutoincrementEntity entity2 = new AutoincrementEntity();
+        daoSession.insert(entity2);
+        assertEquals(id1 + 1, (long) entity2.getId());
+    }
+
+    public void testNoAutoincrement() {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        Long id1 = entity.getId();
+        assertNotNull(id1);
+        daoSession.delete(entity);
+
+        SimpleEntity entity2 = new SimpleEntity();
+        daoSession.insert(entity2);
+        assertEquals(id1, entity2.getId());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/DateEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/DateEntityTest.java
new file mode 100644
index 00000000..d3a8b21b
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/DateEntityTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.Date;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.daotest.DateEntityDao;
+
+public class DateEntityTest extends AbstractDaoTestLongPk<DateEntityDao, DateEntity> {
+
+    public DateEntityTest() {
+        super(DateEntityDao.class);
+    }
+
+    @Override
+    protected DateEntity createEntity(Long key) {
+        DateEntity entity = new DateEntity();
+        entity.setId(key);
+        entity.setDateNotNull(new Date());
+        return entity;
+    }
+    
+    public void testValues() {
+        DateEntity entity = createEntity(1l);
+        dao.insert(entity);
+        
+        DateEntity reloaded = dao.load(entity.getId());
+        assertNull(reloaded.getDate());
+        assertNotNull(reloaded.getDateNotNull());
+        assertEquals(entity.getDateNotNull(), reloaded.getDateNotNull());
+    }
+
+    public void testValues2() {
+        DateEntity entity = createEntity(1l);
+        long t1=32479875;
+        long t2=976345942443435235l;
+        entity.setDate(new Date(t1));
+        entity.setDateNotNull(new Date(t2));
+        dao.insert(entity);
+        
+        DateEntity reloaded = dao.load(entity.getId());
+        assertNotNull(reloaded.getDate());
+        assertNotNull(reloaded.getDateNotNull());
+        assertEquals(t1, reloaded.getDate().getTime());
+        assertEquals(t2, reloaded.getDateNotNull().getTime());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
new file mode 100644
index 00000000..3096e7c4
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ExtendsImplementsEntityTest.java
@@ -0,0 +1,32 @@
+package de.greenrobot.daotest.entity;
+
+import java.io.Serializable;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.TestInterface;
+import de.greenrobot.daotest.TestSuperclass;
+
+public class ExtendsImplementsEntityTest extends
+        AbstractDaoTestLongPk<ExtendsImplementsEntityDao, ExtendsImplementsEntity> {
+
+    public ExtendsImplementsEntityTest() {
+        super(ExtendsImplementsEntityDao.class);
+    }
+
+    @Override
+    protected ExtendsImplementsEntity createEntity(Long key) {
+        ExtendsImplementsEntity entity = new ExtendsImplementsEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testInheritance() {
+        ExtendsImplementsEntity entity = createEntityWithRandomPk();
+        assertTrue(entity instanceof TestSuperclass);
+        assertTrue(entity instanceof TestInterface);
+        assertTrue(entity instanceof Serializable);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTest.java
new file mode 100644
index 00000000..fe9b2f45
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTest.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.List;
+
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public class RelationEntityTest extends AbstractDaoTestLongPk<RelationEntityDao, RelationEntity> {
+
+    protected DaoMaster daoMaster;
+    protected DaoSession daoSession;
+    /** set before calling setUp of this class. */
+    protected IdentityScopeType identityScopeTypeForSession;
+
+    public RelationEntityTest() {
+        super(RelationEntityDao.class);
+        identityScopeTypeForSession = IdentityScopeType.None;
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        TestEntityDao.createTable(db, false);
+        daoMaster = new DaoMaster(db);
+        daoSession = daoMaster.newSession(identityScopeTypeForSession);
+        dao = daoSession.getRelationEntityDao();
+    }
+
+    @Override
+    protected RelationEntity createEntity(Long key) {
+        RelationEntity entity = new RelationEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testToOne() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity = dao.load(entity.getId());
+        assertTestEntity(entity);
+    }
+
+    public void testToOneSelf() {
+        RelationEntity entity = createEntity(1l);
+        dao.insert(entity);
+
+        entity = dao.load(1l);
+        assertNull(entity.getParent());
+
+        entity.setParentId(entity.getId());
+        dao.update(entity);
+
+        entity = dao.load(1l);
+        RelationEntity parent = entity.getParent();
+        assertEquals(entity.getId(), parent.getId());
+    }
+
+    public void testToOneClearKey() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getParent());
+        entity.setParentId(null);
+        assertNull(entity.getParent());
+    }
+
+    public void testToOneClearEntity() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getParentId());
+        entity.setParent(null);
+        assertNull(entity.getParentId());
+    }
+
+    public void testToOneUpdateKey() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        TestEntity testEntity = entity.getTestEntity();
+        RelationEntity entity2 = insertEntityWithRelations(43l);
+        TestEntity testEntity2 = entity2.getTestEntity();
+
+        entity.setTestId(testEntity2.getId());
+        assertEquals(testEntity2.getId(), entity.getTestEntity().getId());
+
+        entity.setTestId(null);
+        assertNull(entity.getTestEntity());
+
+        entity.setTestId(testEntity.getId());
+        assertEquals(testEntity.getId(), entity.getTestEntity().getId());
+    }
+
+    public void testToOneUpdateEntity() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        TestEntity testEntity = entity.getTestEntity();
+        RelationEntity entity2 = insertEntityWithRelations(43l);
+        TestEntity testEntity2 = entity2.getTestEntity();
+
+        entity.setTestEntity(testEntity2);
+        assertEquals(testEntity2.getId(), entity.getTestId());
+
+        entity.setTestEntity(null);
+        assertNull(entity.getTestId());
+
+        entity.setTestEntity(testEntity);
+        assertEquals(testEntity.getId(), entity.getTestId());
+    }
+
+    public void testToOneLoadDeep() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity = dao.loadDeep(entity.getId());
+        assertTestEntity(entity);
+    }
+
+    public void testToOneNoMatch() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getTestEntity());
+        entity.setTestId(23l);
+        entity.setTestIdNotNull(-78);
+        assertNull(entity.getTestEntity());
+        assertNull(entity.getTestNotNull());
+    }
+
+    public void testToOneNoMatchLoadDeep() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getTestEntity());
+        entity.setTestId(23l);
+        entity.setTestIdNotNull(-78);
+        dao.update(entity);
+        entity = dao.loadDeep(entity.getId());
+        assertNull(entity.getTestEntity());
+        assertNull(entity.getTestNotNull());
+    }
+
+    public void testToOneLoadDeepNull() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity.setParentId(null);
+        entity.setTestId(null);
+        dao.update(entity);
+        entity = dao.loadDeep(entity.getId());
+        assertNull(entity.getParent());
+        assertNull(entity.getTestEntity());
+    }
+
+    public void testQueryDeep() {
+        insertEntityWithRelations(42l);
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        assertEquals(1, entityList.size());
+        assertTestEntity(entityList.get(0));
+    }
+
+    protected RelationEntity insertEntityWithRelations(Long testEntityId) {
+        TestEntity testEntity = daoSession.getTestEntityDao().load(testEntityId);
+        if (testEntity == null) {
+            testEntity = new TestEntity(testEntityId);
+            testEntity.setSimpleStringNotNull("mytest");
+            daoSession.getTestEntityDao().insert(testEntity);
+        }
+
+        RelationEntity parentEntity = createEntity(null);
+        parentEntity.setSimpleString("I'm a parent");
+        parentEntity.setTestNotNull(testEntity);
+        dao.insert(parentEntity);
+
+        RelationEntity entity = createEntity(null);
+        entity.setTestId(testEntityId);
+        entity.setParentId(parentEntity.getId());
+        entity.setSimpleString("findMe");
+        entity.setTestNotNull(testEntity);
+        dao.insert(entity);
+
+        return entity;
+    }
+
+    protected void assertTestEntity(RelationEntity entity) {
+        TestEntity testEntity = entity.getTestEntity();
+        assertNotNull(testEntity);
+        assertEquals(42l, (long) testEntity.getId());
+        assertEquals("mytest", testEntity.getSimpleStringNotNull());
+        assertEquals("I'm a parent", entity.getParent().getSimpleString());
+        assertEquals(entity.getParentId(), entity.getParent().getId());
+        assertNotNull(entity.getTestNotNull());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
new file mode 100644
index 00000000..3cee5b10
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.List;
+
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+
+/**
+ * @author Markus
+ */
+public class RelationEntityTestIdentityScope extends RelationEntityTest {
+
+    @Override
+    protected void setUp() throws Exception {
+        identityScopeTypeForSession = IdentityScopeType.Session;
+        super.setUp();
+    }
+
+    public void testToOneLoadDeepIdentityScope() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        RelationEntity entity2 = insertEntityWithRelations(42l);
+        entity = dao.loadDeep(entity.getId());
+        entity2 = dao.loadDeep(entity2.getId());
+        assertFalse(entity.getId().equals(entity2.getId()));
+        assertTestEntity(entity);
+        assertTestEntity(entity2);
+        assertSame(entity.getTestEntity(), entity2.getTestEntity());
+    }
+
+    public void testToQueryDeepIdentityScope() {
+        insertEntityWithRelations(42l);
+        RelationEntity entity2 = insertEntityWithRelations(42l);
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        assertEquals(2, entityList.size());
+        RelationEntity entity = entityList.get(0);
+        assertTestEntity(entity);
+        entity2 = entityList.get(1);
+        assertTestEntity(entity2);
+        assertSame(entity.getTestEntity(), entity2.getTestEntity());
+    }
+
+    public void testLoadDeepIdentityScope() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        RelationEntity entity2 = dao.loadDeep(entity.getId());
+        RelationEntity entity3 = dao.loadDeep(entity.getId());
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+        assertTestEntity(entity);
+    }
+
+    public void testQueryDeepIdentityScope() {
+        RelationEntity entity = insertEntityWithRelations(42l);
+
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        RelationEntity entity2 = entityList.get(0);
+        entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        RelationEntity entity3 = entityList.get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+        assertTestEntity(entity);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
new file mode 100644
index 00000000..54f2b3c6
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+
+public class SimpleEntityNotNullHelper {
+    public static SimpleEntityNotNull createEntity(Long key) {
+        if (key == null) {
+            return null;
+        }
+        SimpleEntityNotNull entity = new SimpleEntityNotNull();
+        entity.setId(key);
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+        return entity;
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
new file mode 100644
index 00000000..15111b52
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityNotNullTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.Arrays;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+
+public class SimpleEntityNotNullTest extends AbstractDaoTestLongPk<SimpleEntityNotNullDao, SimpleEntityNotNull> {
+
+    public SimpleEntityNotNullTest() {
+        super(SimpleEntityNotNullDao.class);
+    }
+
+    @Override
+    protected SimpleEntityNotNull createEntity(Long key) {
+        return SimpleEntityNotNullHelper.createEntity(key);
+    }
+
+    public void testValues() {
+        SimpleEntityNotNull entity = createEntity(1l);
+        dao.insert(entity);
+        SimpleEntityNotNull reloaded = dao.load(1l);
+        assertEqualProperties(entity, reloaded);
+    }
+
+    protected static void assertEqualProperties(SimpleEntityNotNull entity, SimpleEntityNotNull reloaded) {
+        assertNotSame(entity, reloaded);
+
+        assertEquals(entity.getId(), reloaded.getId());
+        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
+        assertEquals(entity.getSimpleDouble(), reloaded.getSimpleDouble());
+        assertEquals(entity.getSimpleFloat(), reloaded.getSimpleFloat());
+        assertEquals(entity.getSimpleLong(), reloaded.getSimpleLong());
+        assertEquals(entity.getSimpleByte(), reloaded.getSimpleByte());
+        assertEquals(entity.getSimpleInt(), reloaded.getSimpleInt());
+        assertEquals(entity.getSimpleShort(), reloaded.getSimpleShort());
+        assertEquals(entity.getSimpleBoolean(), reloaded.getSimpleBoolean());
+        assertEquals(entity.getSimpleString(), reloaded.getSimpleString());
+        assertTrue(Arrays.equals(entity.getSimpleByteArray(), reloaded.getSimpleByteArray()));
+    }
+
+    public void testUpdateValues() {
+        SimpleEntityNotNull entity = createEntity(1l);
+        dao.insert(entity);
+        entity = dao.load(1l);
+
+        entity.setSimpleBoolean(false);
+        entity.setSimpleByte(Byte.MIN_VALUE);
+        entity.setSimpleShort(Short.MIN_VALUE);
+        entity.setSimpleInt(Integer.MIN_VALUE);
+        entity.setSimpleLong(Long.MIN_VALUE);
+        entity.setSimpleFloat(Float.MIN_VALUE);
+        entity.setSimpleDouble(Double.MIN_VALUE);
+        entity.setSimpleString("greenDAO");
+        byte[] bytes = { -1, 0, 1 };
+        entity.setSimpleByteArray(bytes);
+        dao.update(entity);
+
+        SimpleEntityNotNull reloaded = dao.load(1l);
+        assertEqualProperties(entity, reloaded);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityTest.java
new file mode 100644
index 00000000..0bb5899a
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SimpleEntityTest.java
@@ -0,0 +1,134 @@
+package de.greenrobot.daotest.entity;
+
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+import java.util.Arrays;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+public class SimpleEntityTest extends AbstractDaoTestLongPk<SimpleEntityDao, SimpleEntity> {
+
+    public SimpleEntityTest() {
+        super(SimpleEntityDao.class);
+    }
+
+    @Override
+    protected SimpleEntity createEntity(Long key) {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testValuesNull() {
+        SimpleEntity entity = createEntity(1l);
+        dao.insert(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+
+        assertEquals(entity.getId(), reloaded.getId());
+        assertValuesNull(reloaded);
+    }
+
+    public void testValues() {
+        SimpleEntity entity = createEntity(1l);
+        setValues(entity);
+        dao.insert(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValues(reloaded);
+    }
+
+    public void testUpdateValues() {
+        SimpleEntity entity = createEntity(1l);
+        dao.insert(entity);
+        entity = dao.load(1l);
+        setValues(entity);
+        dao.update(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValues(reloaded);
+    }
+
+    public void testUpdateValuesToNull() {
+        SimpleEntity entity = createEntity(1l);
+        setValues(entity);
+        dao.insert(entity);
+        entity = dao.load(1l);
+        assertValues(entity);
+        setValuesToNull(entity);
+        dao.update(entity);
+        SimpleEntity reloaded = dao.load(1l);
+        assertNotSame(entity, reloaded);
+        assertValuesNull(reloaded);
+    }
+
+    protected void assertValues(SimpleEntity reloaded) {
+        assertEquals(1l, (long) reloaded.getId());
+        assertEquals(true, (boolean) reloaded.getSimpleBoolean());
+        assertEquals(Double.MAX_VALUE, reloaded.getSimpleDouble());
+        assertEquals(Float.MAX_VALUE, reloaded.getSimpleFloat());
+        assertEquals(Long.MAX_VALUE, (long) reloaded.getSimpleLong());
+        assertEquals(Byte.MAX_VALUE, (byte) reloaded.getSimpleByte());
+        assertEquals(Integer.MAX_VALUE, (int) reloaded.getSimpleInt());
+        assertEquals(Short.MAX_VALUE, (short) reloaded.getSimpleShort());
+        assertEquals("greenrobot greenDAO", reloaded.getSimpleString());
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        assertTrue(Arrays.equals(bytes, reloaded.getSimpleByteArray()));
+    }
+
+    protected void setValues(SimpleEntity entity) {
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+    }
+
+    protected void setValuesToNull(SimpleEntity entity) {
+        entity.setSimpleBoolean(null);
+        entity.setSimpleByte(null);
+        entity.setSimpleShort(null);
+        entity.setSimpleInt(null);
+        entity.setSimpleLong(null);
+        entity.setSimpleFloat(null);
+        entity.setSimpleDouble(null);
+        entity.setSimpleString(null);
+        entity.setSimpleByteArray(null);
+    }
+
+    protected void assertValuesNull(SimpleEntity reloaded) {
+        assertNull(reloaded.getSimpleBoolean());
+        assertNull(reloaded.getSimpleDouble());
+        assertNull(reloaded.getSimpleFloat());
+        assertNull(reloaded.getSimpleLong());
+        assertNull(reloaded.getSimpleByte());
+        assertNull(reloaded.getSimpleInt());
+        assertNull(reloaded.getSimpleShort());
+        assertNull(reloaded.getSimpleBoolean());
+        assertNull(reloaded.getSimpleString());
+        assertNull(reloaded.getSimpleByteArray());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
new file mode 100644
index 00000000..35806fef
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SpecialNamesEntityTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+
+public class SpecialNamesEntityTest extends AbstractDaoTestLongPk<SpecialNamesEntityDao, SpecialNamesEntity> {
+
+    public SpecialNamesEntityTest() {
+        super(SpecialNamesEntityDao.class);
+    }
+
+    @Override
+    protected SpecialNamesEntity createEntity(Long key) {
+        SpecialNamesEntity entity = new SpecialNamesEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SqliteMasterTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SqliteMasterTest.java
new file mode 100644
index 00000000..913b6a33
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/SqliteMasterTest.java
@@ -0,0 +1,31 @@
+package de.greenrobot.daotest.entity;
+
+import java.util.List;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SqliteMaster;
+import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.daotest.SqliteMasterDao.Properties;
+
+public class SqliteMasterTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Void> {
+
+    public SqliteMasterTest() {
+        super(SqliteMasterDao.class);
+    }
+
+    public void testLoadAll() {
+        List<SqliteMaster> all = dao.loadAll();
+        for (SqliteMaster meta : all) {
+            DaoLog.v(meta.toString());
+        }
+    }
+
+    public void testQueryRaw() {
+        List<SqliteMaster> tables = dao.queryRaw("WHERE " + Properties.Type.columnName + "=?", "table");
+        for (SqliteMaster table : tables) {
+            DaoLog.v(table.toString());
+        }
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
new file mode 100644
index 00000000..a071cfe4
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.identityscope.IdentityScopeObject;
+import de.greenrobot.daotest.StringKeyValueEntity;
+
+public class StringKeyValueEntityIdentityScopeTest extends StringKeyValueEntityTest {
+    @Override
+    protected void setUp() throws Exception {
+        setIdentityScopeBeforeSetUp(new IdentityScopeObject<String, StringKeyValueEntity>());
+        super.setUp();
+    }
+
+    public void testLoadIdScope() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadIdScope_load() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertNotSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testDetach() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        dao.detach(entity2);
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertNotSame(entity, entity2);
+        assertNotSame(entity2, entity3);
+        assertNotSame(entity, entity3);
+    }
+
+    public void testDetachOther() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        dao.detach(entity);
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadAllScope() {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        StringKeyValueEntity entity2 = dao.loadAll().get(0);
+        StringKeyValueEntity entity3 = dao.loadAll().get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
new file mode 100644
index 00000000..80876125
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/StringKeyValueEntityTest.java
@@ -0,0 +1,31 @@
+package de.greenrobot.daotest.entity;
+
+import junit.framework.Assert;
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.daotest.StringKeyValueEntityDao;
+
+public class StringKeyValueEntityTest extends AbstractDaoTestStringPk<StringKeyValueEntityDao, StringKeyValueEntity> {
+
+    public StringKeyValueEntityTest() {
+        super(StringKeyValueEntityDao.class);
+    }
+
+    @Override
+    protected StringKeyValueEntity createEntity(String key) {
+        StringKeyValueEntity entity = new StringKeyValueEntity();
+        entity.setKey(key);
+        return entity;
+    }
+
+    public void testInsertWithoutPK() {
+        StringKeyValueEntity entity = createEntity(null);
+        try {
+            dao.insert(entity);
+            Assert.fail("Insert without pre-set PK succeeded");
+        } catch (Exception e) {
+            // Expected
+        }
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
new file mode 100644
index 00000000..755156cb
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.daotest.TestEntity;
+
+public class TestEntityIdentityScopeTest extends TestEntityTest {
+    @Override
+    protected void setUp() throws Exception {
+        setIdentityScopeBeforeSetUp(new IdentityScopeLong<TestEntity>());
+        super.setUp();
+    }
+
+    public void testLoadIdScope() {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testDetach() {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        dao.detach(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        dao.detach(entity2);
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertNotSame(entity, entity2);
+        assertNotSame(entity2, entity3);
+        assertNotSame(entity, entity3);
+    }
+
+    public void testDetachOther() {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        dao.detach(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        dao.detach(entity);
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadAllScope() {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        TestEntity entity2 = dao.loadAll().get(0);
+        TestEntity entity3 = dao.loadAll().get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTest.java
new file mode 100644
index 00000000..2ad04693
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public class TestEntityTest extends AbstractDaoTestLongPk<TestEntityDao, TestEntity> {
+
+    public TestEntityTest() {
+        super(TestEntityDao.class);
+    }
+
+    @Override
+    protected TestEntity createEntity(Long key) {
+        TestEntity entity = new TestEntity();
+        entity.setId(key);
+        entity.setSimpleStringNotNull("green");
+        return entity;
+    }
+
+    public void testRefresh() {
+        TestEntity entity = createEntity(1l);
+        entity.setSimpleInteger(42);
+        entity.setSimpleString(null);
+        dao.insert(entity);
+        entity.setSimpleInteger(null);
+        entity.setSimpleString("temp");
+        dao.refresh(entity);
+        assertEquals(42, (int) entity.getSimpleInteger());
+        assertNull(entity.getSimpleString());
+    }
+
+    public void testRefreshIllegal() {
+        TestEntity entity = createEntity(1l);
+        try {
+            dao.refresh(entity);
+            fail("Exception expected");
+        } catch (DaoException expected) {
+        }
+        dao.insert(entity);
+        dao.delete(entity);
+        try {
+            dao.refresh(entity);
+            fail("Exception expected");
+        } catch (DaoException expected) {
+        }
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTestBase.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTestBase.java
new file mode 100644
index 00000000..e232d3ee
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TestEntityTestBase.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.ArrayList;
+
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public abstract class TestEntityTestBase extends AbstractDaoTest<TestEntityDao, TestEntity, Long> {
+
+    public TestEntityTestBase() {
+        super(TestEntityDao.class);
+    }
+
+    protected TestEntity createEntity(int simpleInteger, String simpleString) {
+        TestEntity entity = new TestEntity();
+        entity.setId(null);
+        entity.setSimpleStringNotNull("green");
+        entity.setSimpleInteger(simpleInteger);
+        entity.setSimpleString(simpleString);
+        return entity;
+    }
+
+    protected ArrayList<TestEntity> insert(int count) {
+        ArrayList<TestEntity> list = new ArrayList<TestEntity>();
+        for (int i = 0; i < count; i++) {
+            TestEntity entity = createEntity(getSimpleInteger(i), getSimpleString(i));
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    protected String getSimpleString(int i) {
+        return "String" + (i + 100);
+    }
+
+    protected int getSimpleInteger(int i) {
+        return 100 + i;
+    }
+
+    protected void assertIds(ArrayList<TestEntity> list, LazyList<TestEntity> list2) {
+        for (int i = 0; i < list.size(); i++) {
+            TestEntity entity = list.get(i);
+            TestEntity lazyEntity = list2.get(i);
+            assertIds(entity, lazyEntity);
+        }
+    }
+
+    protected void assertIds(TestEntity entity, TestEntity entity2) {
+        assertEquals(entity.getId(), entity2.getId());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyEntityTest.java
new file mode 100644
index 00000000..55fd37bd
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyEntityTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.daotest.ToManyEntityDao;
+import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+
+public class ToManyEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private ToManyEntityDao toManyEntityDao;
+    private ToManyTargetEntityDao toManyTargetEntityDao;
+
+    public ToManyEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        toManyEntityDao = daoSession.getToManyEntityDao();
+        toManyTargetEntityDao = daoSession.getToManyTargetEntityDao();
+    }
+
+    public void testToManyBasics() {
+        int count = 0;
+        for (int i = 0; i < 16; i++) {
+            runTestToManyBasics(i + 1, i);
+            count += i;
+        }
+        assertEquals(count, toManyTargetEntityDao.count());
+    }
+
+    public void runTestToManyBasics(long id, int count) {
+        ToManyTargetEntity[] targetEntities = prepareToMany(id, count);
+
+        ToManyEntity testEntity = toManyEntityDao.load(id);
+        List<ToManyTargetEntity> resolvedToMany = testEntity.getToManyTargetEntityList();
+        assertSameEntities(targetEntities, resolvedToMany);
+    }
+
+    private void assertSameEntities(ToManyTargetEntity[] targetEntities, List<ToManyTargetEntity> resolvedToMany) {
+        int count = targetEntities.length;
+        assertEquals(count, resolvedToMany.size());
+
+        Map<Long, ToManyTargetEntity> resolvedMap = new HashMap<Long, ToManyTargetEntity>();
+        for (ToManyTargetEntity resolvedEntity : resolvedToMany) {
+            resolvedMap.put(resolvedEntity.getId(), resolvedEntity);
+        }
+        for (int i = 0; i < count; i++) {
+            long entityId = (long) targetEntities[i].getId();
+            assertTrue("ID=" + entityId, resolvedMap.containsKey(entityId));
+            assertSame(targetEntities[i], resolvedMap.get(entityId));
+        }
+    }
+
+    private ToManyTargetEntity[] prepareToMany(long id, int count) {
+        ToManyEntity entity = new ToManyEntity(id);
+        daoSession.insert(entity);
+        return insertTargetEntitites(id, count, null);
+    }
+
+    private ToManyTargetEntity[] insertTargetEntitites(Long toManyId, int count, String joinProperty) {
+        ToManyTargetEntity[] targetEntities = new ToManyTargetEntity[count];
+        for (int i = 0; i < count; i++) {
+            ToManyTargetEntity target = new ToManyTargetEntity();
+            target.setToManyId(toManyId);
+            target.setToManyIdDesc(toManyId);
+            target.setTargetJoinProperty(joinProperty);
+            targetEntities[i] = target;
+        }
+        toManyTargetEntityDao.insertInTx(targetEntities);
+        return targetEntities;
+    }
+
+    public void testGetToManyTwice() {
+        prepareToMany(1, 3);
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
+        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
+        assertSame(resolvedToMany1, resolvedToMany2);
+    }
+
+    public void testResetToMany() {
+        ToManyTargetEntity[] targetEntities = prepareToMany(1, 3);
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
+        testEntity.resetToManyTargetEntityList();
+        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
+        assertNotSame(resolvedToMany1, resolvedToMany2);
+        assertSameEntities(targetEntities, resolvedToMany2);
+    }
+
+    public void testChangeResetToMany() {
+        prepareToMany(1, 3);
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> resolvedToMany1 = testEntity.getToManyTargetEntityList();
+        testEntity.resetToManyTargetEntityList();
+
+        ToManyTargetEntity newEntity = new ToManyTargetEntity();
+        newEntity.setToManyId(1l);
+        daoSession.insert(newEntity);
+
+        List<ToManyTargetEntity> resolvedToMany2 = testEntity.getToManyTargetEntityList();
+        assertNotSame(resolvedToMany1, resolvedToMany2);
+        assertEquals(resolvedToMany1.size() + 1, resolvedToMany2.size());
+
+        testEntity.resetToManyTargetEntityList();
+        toManyTargetEntityDao.deleteAll();
+        List<ToManyTargetEntity> resolvedToMany3 = testEntity.getToManyTargetEntityList();
+        assertEquals(0, resolvedToMany3.size());
+    }
+
+    public void testToManyOrder() {
+        prepareToMany(1, 3);
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> resolvedToManyAsc = testEntity.getToManyTargetEntityList();
+        List<ToManyTargetEntity> resolvedToManyDesc = testEntity.getToManyDescList();
+        assertNotSame(resolvedToManyAsc, resolvedToManyDesc);
+        assertEquals(resolvedToManyAsc.get(0).getId(), resolvedToManyDesc.get(2).getId());
+        assertSame(resolvedToManyAsc.get(0), resolvedToManyDesc.get(2));
+        assertSame(resolvedToManyAsc.get(1), resolvedToManyDesc.get(1));
+        assertSame(resolvedToManyAsc.get(2), resolvedToManyDesc.get(0));
+    }
+
+    public void testJoinProperty() {
+        ToManyEntity entity = new ToManyEntity(1l);
+        entity.setSourceJoinProperty("JOIN ME");
+        daoSession.insert(entity);
+        insertTargetEntitites(null, 3, "JOIN ME");
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> targetEntities = testEntity.getToManyByJoinProperty();
+        assertEquals(3, targetEntities.size());
+
+        ToManyTargetEntity middleEntity = targetEntities.get(1);
+        middleEntity.setTargetJoinProperty("DON'T JOIN ME");
+        toManyTargetEntityDao.update(middleEntity);
+
+        testEntity.resetToManyByJoinProperty();
+        targetEntities = testEntity.getToManyByJoinProperty();
+        assertEquals(2, targetEntities.size());
+
+        assertFalse(middleEntity.getId() == targetEntities.get(0).getId());
+        assertFalse(middleEntity.getId() == targetEntities.get(1).getId());
+    }
+
+    public void testTwoJoinProperty() {
+        ToManyEntity entity = new ToManyEntity(1l);
+        entity.setSourceJoinProperty("JOIN ME");
+        daoSession.insert(entity);
+        insertTargetEntitites(1l, 3, "JOIN ME");
+
+        ToManyEntity testEntity = toManyEntityDao.load(1l);
+        List<ToManyTargetEntity> targetEntities = testEntity.getToManyJoinTwo();
+        assertEquals(3, targetEntities.size());
+
+        ToManyTargetEntity middleEntity = targetEntities.get(1);
+        middleEntity.setTargetJoinProperty("DON'T JOIN ME");
+        toManyTargetEntityDao.update(middleEntity);
+
+        testEntity.resetToManyJoinTwo();
+        targetEntities = testEntity.getToManyJoinTwo();
+        assertEquals(2, targetEntities.size());
+
+        assertFalse(middleEntity.getId() == targetEntities.get(0).getId());
+        assertFalse(middleEntity.getId() == targetEntities.get(1).getId());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
new file mode 100644
index 00000000..b6b806d6
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/ToManyTargetEntityTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.daotest.ToManyTargetEntityDao;
+
+public class ToManyTargetEntityTest extends AbstractDaoTestLongPk<ToManyTargetEntityDao, ToManyTargetEntity> {
+
+    public ToManyTargetEntityTest() {
+        super(ToManyTargetEntityDao.class);
+    }
+
+    @Override
+    protected ToManyTargetEntity createEntity(Long key) {
+        ToManyTargetEntity entity = new ToManyTargetEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TreeEntityTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TreeEntityTest.java
new file mode 100644
index 00000000..dc09eb9b
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/entity/TreeEntityTest.java
@@ -0,0 +1,93 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.TreeEntity;
+import de.greenrobot.daotest.TreeEntityDao;
+
+public class TreeEntityTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    private TreeEntityDao treeEntityDao;
+
+    public TreeEntityTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        treeEntityDao = daoSession.getTreeEntityDao();
+    }
+
+    public void testNavigateTreeFromLeaf() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity child1Child = treeEntityDao.load(101l);
+        assertEquals(0, child1Child.getChildren().size());
+
+        TreeEntity child1 = child1Child.getParent();
+        assertEquals(11l, child1.getId().longValue());
+        assertEquals(1, child1.getChildren().size());
+        assertSame(child1Child, child1.getChildren().get(0));
+
+        TreeEntity root = child1.getParent();
+        assertEquals(1l, root.getId().longValue());
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+    }
+
+    public void testNavigateTreeFromMiddle() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity child1 = treeEntityDao.load(11l);
+        assertEquals(1, child1.getChildren().size());
+        TreeEntity child1Child = child1.getChildren().get(0);
+        assertEquals(101, child1Child.getId().longValue());
+        assertEquals(0, child1Child.getChildren().size());
+
+        TreeEntity root = child1.getParent();
+        assertEquals(1l, root.getId().longValue());
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+    }
+
+    public void testNavigateTreeFromRoot() {
+        createTree();
+        daoSession.clear();
+
+        TreeEntity root = treeEntityDao.load(1l);
+        assertEquals(2, root.getChildren().size());
+        assertNull(root.getParent());
+
+        TreeEntity child1 = root.getChildren().get(0);
+        TreeEntity child2 = root.getChildren().get(1);
+        if (child1.getId() != 11l) {
+            child1 = child2;
+            child2 = root.getChildren().get(0);
+        }
+
+        assertSame(root, child1.getParent());
+        assertEquals(1, child1.getChildren().size());
+        TreeEntity child1Child = child1.getChildren().get(0);
+        assertEquals(101, child1Child.getId().longValue());
+        assertEquals(0, child1Child.getChildren().size());
+        
+        assertSame(root, child2.getParent());
+        assertEquals(0, child2.getChildren().size());
+    }
+
+    private void createTree() {
+        TreeEntity root = new TreeEntity(1l);
+        TreeEntity child1 = new TreeEntity(11l);
+        child1.setParent(root);
+        TreeEntity child2 = new TreeEntity(12l);
+        child2.setParent(root);
+        TreeEntity child1Child = new TreeEntity(101l);
+        child1Child.setParent(child1);
+        treeEntityDao.insertInTx(root, child1, child2, child1Child);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/LoockupPerformanceTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
new file mode 100644
index 00000000..9b697d53
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+
+import junit.framework.TestCase;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.internal.LongHashMap;
+import de.greenrobot.daotest.performance.target.LongHashMapAmarena2DZechner;
+import de.greenrobot.daotest.performance.target.LongHashMapJDBM;
+import de.greenrobot.daotest.performance.target.LongSparseArray;
+
+public class LoockupPerformanceTest extends TestCase {
+
+    Random random;
+    private String traceName;
+    private long start;
+
+    public LoockupPerformanceTest() {
+        this.random = new Random();
+    }
+
+    public void testHashMapPerformance() {
+        // runTests(100);
+        // runTests(1000);
+        // runTests(10000);
+        // runTests(100000); // hash: 1485/420ms; sparse: 148196/196ms
+        DaoLog.d("testHashMapPerformance DONE");
+    }
+
+    private void runTests(int count) {
+        runTests(count, false);
+        runTests(count, true);
+    }
+
+    private void runTests(int count, boolean randomKeys) {
+        DaoLog.d("-----------------------------------");
+        DaoLog.d("Look up " + count + (randomKeys ? " random" : " linear") + " keys on " + new Date());
+        DaoLog.d("-----------------------------------");
+        long[] keys = new long[count];
+        for (int i = 0; i < count; i++) {
+            if (randomKeys) {
+                keys[i] = random.nextLong();
+            } else {
+                keys[i] = i;
+            }
+        }
+        for (int i = 0; i < 3; i++) {
+            runMapTest(new HashMap<Long, Object>(count), keys, "hashmap");
+            // runMapTest(new WeakHashMap<Long, Object>(count), keys, "weakhashmap");
+            // runMapTest(new ConcurrentHashMap<Long, Object>(count), keys, "concurrent-hashmap");
+            // runLongSparseArrayTest(keys);
+            runLongHashMap(keys);
+            runLongHashMapAmarena2DZechnerTest(keys);
+            // runLongHashMapJDBMTest(keys);
+            DaoLog.d("-----------------------------------");
+        }
+    }
+
+    protected void runMapTest(Map<Long, Object> map, long[] keys, String name) {
+        startClock("put-" + name + "-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-" + name + "-" + keys.length);
+        int lossCount = 0;
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                lossCount++;
+            }
+        }
+        if (lossCount > 0) {
+            stopClock("losses: " + lossCount);
+        } else {
+            stopClock();
+        }
+    }
+
+    private void runLongSparseArrayTest(long[] keys) {
+        if (keys.length > 10000) {
+            DaoLog.d("Skipping runLongSparseArrayTest for " + keys.length);
+            return;
+        }
+        LongSparseArray<Object> array = new LongSparseArray<Object>(keys.length);
+
+        startClock("put-sparsearray-" + keys.length);
+        for (long key : keys) {
+            array.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-sparsearray-" + keys.length);
+        for (long key : keys) {
+            Object object = array.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+    }
+
+    private void runLongHashMapJDBMTest(long[] keys) {
+        LongHashMapJDBM<Object> map = new LongHashMapJDBM<Object>(keys.length);
+
+        startClock("put-jdbm-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-jdbm-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+    }
+
+    private void runLongHashMap(long[] keys) {
+        LongHashMap<Object> map = new LongHashMap<Object>(keys.length);
+        map.reserveRoom(keys.length);
+
+        startClock("put-my-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-my-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+        map.logStats();
+    }
+
+    private void runLongHashMapAmarena2DZechnerTest(long[] keys) {
+        LongHashMapAmarena2DZechner<Object> map = new LongHashMapAmarena2DZechner<Object>(keys.length);
+
+        startClock("put-amarena-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-amarena-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+        map.logStats();
+    }
+
+    protected void startClock(String traceName) {
+        this.traceName = traceName;
+        start = System.currentTimeMillis();
+    }
+
+    protected void stopClock() {
+        stopClock(null);
+    }
+
+    protected void stopClock(String extraInfoOrNull) {
+        long time = System.currentTimeMillis() - start;
+        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
+        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java
new file mode 100644
index 00000000..6eb3aab6
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTest.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import android.os.Debug;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+
+public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
+    long start;
+    private String traceName;
+    boolean useTraceView = false;
+
+    public PerformanceTest(Class<D> daoClass) {
+        super(daoClass, false);
+    }
+
+    public void testPerformance() throws Exception {
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+    }
+
+    protected void runTests(int entityCount) {
+        DaoLog.d("####################");
+        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
+        DaoLog.d("####################");
+        clearIdentityScopeIfAny();
+
+        List<T> list = new ArrayList<T>(entityCount);
+        for (int i = 0; i < entityCount; i++) {
+            list.add(createEntity());
+        }
+        System.gc();
+
+        dao.deleteAll();
+        // runOneByOneTests(list, entityCount, entityCount / 10);
+        dao.deleteAll();
+        DaoLog.d("------------------------");
+        System.gc();
+
+        // runBatchTests(list);
+
+        startClock("delete-all");
+        dao.deleteAll();
+        stopClock();
+        System.gc();
+    }
+
+    protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) {
+        dao.insertInTx(list);
+        List<K> keys = new ArrayList<K>(loadCount);
+        for (int i = 0; i < loadCount; i++) {
+            keys.add(daoAccess.getKey(list.get(i)));
+        }
+        clearIdentityScopeIfAny();
+        System.gc();
+
+        list = runLoadOneByOne(keys, "load-one-by-one-1");
+        list = runLoadOneByOne(keys, "load-one-by-one-2");
+        Debug.stopMethodTracing();
+
+        dao.deleteAll();
+        System.gc();
+
+        startClock("insert-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.insert(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("update-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.update(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("delete-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.delete(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+    }
+
+    protected List<T> runLoadOneByOne(List<K> keys, String traceName) {
+        List<T> list = new ArrayList<T>(keys.size());
+        startClock(traceName);
+        for (K key : keys) {
+            list.add(dao.load(key));
+        }
+        stopClock(keys.size() + " entities");
+        return list;
+    }
+
+    protected void runBatchTests(List<T> list) {
+        startClock("insert");
+        dao.insertInTx(list);
+        stopClock(list.size() + " entities");
+
+        list = null;
+        System.gc();
+
+        clearIdentityScopeIfAny();
+        list = runLoadAll("load-all-1");
+        list = runLoadAll("load-all-2");
+
+        startClock("update");
+        dao.updateInTx(list);
+        stopClock(list.size() + " entities");
+    }
+
+    protected List<T> runLoadAll(String traceName) {
+        startClock(traceName);
+        List<T> list = dao.loadAll();
+        stopClock(list.size() + " entities");
+        return list;
+    }
+
+    protected void startClock(String traceName) {
+        System.gc();
+        this.traceName = traceName;
+        if (useTraceView) {
+            Debug.startMethodTracing(traceName);
+        }
+        start = System.currentTimeMillis();
+    }
+
+    protected void stopClock() {
+        stopClock(null);
+    }
+
+    protected void stopClock(String extraInfoOrNull) {
+        long time = System.currentTimeMillis() - start;
+        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
+        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
+        if (useTraceView) {
+            Debug.stopMethodTracing();
+        }
+        System.gc();
+    }
+
+    protected abstract T createEntity();
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
new file mode 100644
index 00000000..7b256544
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
+
+public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
+
+    static long sequence;
+
+    public PerformanceTestNotNull() {
+        super(SimpleEntityNotNullDao.class);
+    }
+
+    @Override
+    protected SimpleEntityNotNull createEntity() {
+        return SimpleEntityNotNullHelper.createEntity(sequence++);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
new file mode 100644
index 00000000..eabbb7c0
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+public class PerformanceTestNotNullIdentityScope extends PerformanceTestNotNull {
+
+    @Override
+    protected void setUp() throws Exception {
+        IdentityScopeLong<SimpleEntityNotNull> identityScope = new IdentityScopeLong< SimpleEntityNotNull>();
+        setIdentityScopeBeforeSetUp(identityScope);
+        super.setUp();
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
new file mode 100644
index 00000000..6abddab2
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import de.greenrobot.dao.DaoLog;
+
+public class ReflectionPerformanceTest // extends TestCase
+{
+
+    int intValue;
+    String stringValue;
+
+    public int getIntValue() {
+        return intValue;
+    }
+
+    public void setIntValue(int inValue) {
+        this.intValue = inValue;
+    }
+
+    public String getStringValue() {
+        return stringValue;
+    }
+
+    public void setStringValue(String stringValue) {
+        this.stringValue = stringValue;
+    }
+
+    public void testSetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setIntValue(i);
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setIntValue", int.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, i);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = getIntValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getIntValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = (Integer) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+
+    public void testSetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setStringValue("the quick brown fox");
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setStringValue", String.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, "the quick brown fox");
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = getStringValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getStringValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = (String) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/ArrayUtils.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/ArrayUtils.java
new file mode 100644
index 00000000..0168b463
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/ArrayUtils.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import java.lang.reflect.Array;
+import java.util.Collection;
+
+// XXX these should be changed to reflect the actual memory allocator we use.
+// it looks like right now objects want to be powers of 2 minus 8
+// and the array size eats another 4 bytes
+
+/**
+ * ArrayUtils contains some methods that you can call to find out
+ * the most efficient increments by which to grow arrays.
+ */
+public class ArrayUtils
+{
+    private static Object[] EMPTY = new Object[0];
+    private static final int CACHE_SIZE = 73;
+    private static Object[] sCache = new Object[CACHE_SIZE];
+
+    private ArrayUtils() { /* cannot be instantiated */ }
+
+    public static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++)
+            if (need <= (1 << i) - 12)
+                return (1 << i) - 12;
+
+        return need;
+    }
+
+    public static int idealBooleanArraySize(int need) {
+        return idealByteArraySize(need);
+    }
+
+    public static int idealShortArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealCharArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealIntArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealFloatArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealObjectArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealLongArraySize(int need) {
+        return idealByteArraySize(need * 8) / 8;
+    }
+
+    /**
+     * Checks if the beginnings of two byte arrays are equal.
+     *
+     * @param array1 the first byte array
+     * @param array2 the second byte array
+     * @param length the number of bytes to check
+     * @return true if they're equal, false otherwise
+     */
+    public static boolean equals(byte[] array1, byte[] array2, int length) {
+        if (array1 == array2) {
+            return true;
+        }
+        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (array1[i] != array2[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns an empty array of the specified type.  The intent is that
+     * it will return the same empty array every time to avoid reallocation,
+     * although this is not guaranteed.
+     */
+    public static <T> T[] emptyArray(Class<T> kind) {
+        if (kind == Object.class) {
+            return (T[]) EMPTY;
+        }
+
+        int bucket = ((System.identityHashCode(kind) / 8) & 0x7FFFFFFF) % CACHE_SIZE;
+        Object cache = sCache[bucket];
+
+        if (cache == null || cache.getClass().getComponentType() != kind) {
+            cache = Array.newInstance(kind, 0);
+            sCache[bucket] = cache;
+
+            // Log.e("cache", "new empty " + kind.getName() + " at " + bucket);
+        }
+
+        return (T[]) cache;
+    }
+
+    /**
+     * Checks that value is present as at least one of the elements of the array.
+     * @param array the array to check in
+     * @param value the value to check for
+     * @return true if the value is present in the array
+     */
+    public static <T> boolean contains(T[] array, T value) {
+        for (T element : array) {
+            if (element == null) {
+                if (value == null) return true;
+            } else {
+                if (value != null && element.equals(value)) return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
new file mode 100644
index 00000000..2979e9f9
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
@@ -0,0 +1,249 @@
+/*******************************************************************************
+ * Copyright 2010 Mario Zechner (contact@badlogicgames.com)
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ ******************************************************************************/
+
+package de.greenrobot.daotest.performance.target;
+
+import java.util.Iterator;
+
+import de.greenrobot.dao.DaoLog;
+
+/**
+ * An long to object hashmap, taken from Amarena2D (thanks Christoph :p).
+ * 
+ * @author christop widulle
+ * 
+ * @param <T>
+ */
+public class LongHashMapAmarena2DZechner<T> {
+
+    private Entry[] table;
+    private float loadFactor;
+    private int size, mask, capacity, threshold;
+
+    public LongHashMapAmarena2DZechner() {
+        this(16, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity) {
+        this(initialCapacity, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity, float loadFactor) {
+        if (initialCapacity > 1 << 30)
+            throw new IllegalArgumentException("initialCapacity is too large.");
+        if (initialCapacity < 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        if (loadFactor <= 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        capacity = 1;
+        while (capacity < initialCapacity) {
+            capacity <<= 1;
+        }
+        this.loadFactor = loadFactor;
+        this.threshold = (int) (capacity * loadFactor);
+        this.table = new Entry[capacity];
+        this.mask = capacity - 1;
+    }
+
+    public boolean containsValue(Object value) {
+        Entry[] table = this.table;
+        for (int i = table.length; i-- > 0;)
+            for (Entry e = table[i]; e != null; e = e.next)
+                if (e.value.equals(value))
+                    return true;
+        return false;
+    }
+
+    public boolean containsKey(long key) {
+        int index = ((int) key) & mask;
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return true;
+        return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T get(long key) {
+        int index = (int) (key & mask);
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return (T) e.value;
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T put(long key, T value) {
+        int index = (int) (key & mask);
+        // Check if key already exists.
+        for (Entry e = table[index]; e != null; e = e.next) {
+            if (e.key != key)
+                continue;
+            Object oldValue = e.value;
+            e.value = value;
+            return (T) oldValue;
+        }
+        table[index] = new Entry(key, value, table[index]);
+        if (size++ >= threshold) {
+            // Rehash.
+            int newCapacity = 2 * capacity;
+            Entry[] newTable = new Entry[newCapacity];
+            Entry[] src = table;
+            int bucketmask = newCapacity - 1;
+            for (int j = 0; j < src.length; j++) {
+                Entry e = src[j];
+                if (e != null) {
+                    src[j] = null;
+                    do {
+                        Entry next = e.next;
+                        index = (int) (e.key & bucketmask);
+                        e.next = newTable[index];
+                        newTable[index] = e;
+                        e = next;
+                    } while (e != null);
+                }
+            }
+            table = newTable;
+            capacity = newCapacity;
+            threshold = (int) (newCapacity * loadFactor);
+            mask = capacity - 1;
+        }
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T remove(long key) {
+        int index = (int) (key & mask);
+        Entry prev = table[index];
+        Entry e = prev;
+        while (e != null) {
+            Entry next = e.next;
+            if (e.key == key) {
+                size--;
+                if (prev == e) {
+                    table[index] = next;
+                } else {
+                    prev.next = next;
+                }
+                return (T) e.value;
+            }
+            prev = e;
+            e = next;
+        }
+        return null;
+    }
+
+    public int size() {
+        return size;
+    }
+
+    public void clear() {
+        Entry[] table = this.table;
+        for (int index = table.length; --index >= 0;)
+            table[index] = null;
+        size = 0;
+    }
+
+    static class Entry {
+        final long key;
+        Object value;
+        Entry next;
+
+        Entry(long k, Object v, Entry n) {
+            key = k;
+            value = v;
+            next = n;
+        }
+    }
+
+    EntryIterable iterable = new EntryIterable();
+
+    public Iterable<T> values() {
+        iterable.reset();
+        return iterable;
+    }
+
+    class EntryIterable implements Iterable<T> {
+        int currIndex = -1;
+        Entry currEntry = null;
+
+        Iterator<T> iter = new Iterator<T>() {
+            @Override
+            public boolean hasNext() {
+                if (currEntry == null) {
+                    if (!loadNextEntry())
+                        return false;
+                } else {
+                    if (currEntry.next == null) {
+                        if (loadNextEntry() == false)
+                            return false;
+                    } else
+                        currEntry = currEntry.next;
+                }
+
+                return true;
+            }
+
+            @SuppressWarnings("synthetic-access")
+            private boolean loadNextEntry() {
+                while (true) {
+                    currIndex++;
+                    if (currIndex >= table.length)
+                        return false;
+
+                    if (table[currIndex] == null)
+                        continue;
+                    else {
+                        currEntry = table[currIndex];
+                        return true;
+                    }
+                }
+            }
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public T next() {
+                return (T) currEntry.value;
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException("not implemented");
+            }
+
+        };
+
+        public void reset() {
+            currIndex = -1;
+            currEntry = null;
+        }
+
+        @Override
+        public Iterator<T> iterator() {
+            return iter;
+        }
+
+    }
+
+    public void logStats() {
+        int collisions = 0;
+        for (Entry entry : table) {
+            while (entry != null && entry.next != null) {
+                collisions++;
+                entry = entry.next;
+            }
+        }
+        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
+                + collisions + ", collision ratio: " + ((float) collisions) / size);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
new file mode 100644
index 00000000..3eeee1cb
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
@@ -0,0 +1,587 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Hash Map which uses primitive long as key. 
+ * Main advantage is new instanceof of Long does not have to be created for each lookup.
+ * <p>
+ * This code comes from Android, which in turns comes to Apache Harmony. 
+ * This class was modified to use primitive longs and stripped down to consume less space. 
+ * <p>
+ * Author of JDBM modifications: Jan Kotek
+ * <p>
+ * Note: This map have weakened hash function, this works well for JDBM, but may be wrong for many other applications.  
+ */
+public class LongHashMapJDBM<V> implements  Serializable {
+    private static final long serialVersionUID = 362499999763181265L;
+
+    protected int elementCount;
+
+    protected Entry<V>[] elementData;
+
+    private final float loadFactor;
+
+    protected int threshold;
+
+    transient int modCount = 0;	
+
+    private static final int DEFAULT_SIZE = 16;
+    
+    transient Entry<V> reuseAfterDelete = null;
+
+    static final class Entry<V> {
+
+        Entry<V> next;
+
+        long key;
+        V value;
+        
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object instanceof Entry) {
+                Entry<?> entry = (Entry) object;
+                return ( key == entry.key)
+                        && (value == null ? entry.value == null : value
+                                .equals(entry.value));
+            }
+            return false;
+        }
+
+
+        
+        public int hashCode() {
+            return (int)(key)
+                    ^ (value == null ? 0 : value.hashCode());
+        }
+
+        
+        
+        public String toString() {
+            return key + "=" + value;
+        }
+        
+
+        
+        Entry(long theKey) {
+        	this.key = theKey;
+        	this.value = null;
+        }
+
+        Entry(long theKey, V theValue) {
+            this.key = theKey;
+            this.value = theValue;
+            //origKeyHash = (int)(theKey ^ (theKey >>> 32));
+        }
+
+    }
+    
+
+    interface EntryType<RT,VT> {
+        RT get(Entry<VT> entry);
+    }
+
+    static class HashMapIterator<E,VT> implements Iterator<E> {
+        private int position = 0;
+
+        int expectedModCount;
+
+        final EntryType<E, VT> type;
+
+        boolean canRemove = false;
+
+        Entry<VT> entry;
+
+        Entry<VT> lastEntry;
+
+        final LongHashMapJDBM<VT> associatedMap;
+
+        HashMapIterator(EntryType<E, VT> value, LongHashMapJDBM<VT> hm) {
+            associatedMap = hm;
+            type = value;
+            expectedModCount = hm.modCount;
+        }
+
+        public boolean hasNext() {
+            if (entry != null) {
+                return true;
+            }
+            // BEGIN android-changed
+            Entry<VT>[] elementData = associatedMap.elementData;
+            int length = elementData.length;
+            int newPosition = position;
+            boolean result = false;
+
+            while (newPosition < length) {
+                if (elementData[newPosition] == null) {
+                    newPosition++;
+                } else {
+                    result = true;
+                    break;
+                }
+            }
+
+            position = newPosition;
+            return result;
+            // END android-changed
+        }
+
+        void checkConcurrentMod() throws ConcurrentModificationException {
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        public E next() {
+            // BEGIN android-changed
+            // inline checkConcurrentMod()
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+
+            Entry<VT> result;
+            Entry<VT> _entry  = entry;
+            if (_entry == null) {
+                result = lastEntry = associatedMap.elementData[position++];
+                entry = lastEntry.next;
+            } else {
+                if (lastEntry.next != _entry) {
+                    lastEntry = lastEntry.next;
+                }
+                result = _entry;
+                entry = _entry.next;
+            }
+            canRemove = true;
+            return type.get(result);
+            // END android-changed
+        }
+
+        public void remove() {
+            checkConcurrentMod();
+            if (!canRemove) {
+                throw new IllegalStateException();
+            }
+
+            canRemove = false;
+            associatedMap.modCount++;
+            if (lastEntry.next == entry) {
+                while (associatedMap.elementData[--position] == null) {
+                    // Do nothing
+                }
+                associatedMap.elementData[position] = associatedMap.elementData[position].next;
+                entry = null;
+            } else {
+                lastEntry.next = entry;
+            }
+            if(lastEntry!=null){
+            	Entry<VT> reuse = lastEntry;
+            	lastEntry = null;
+            	reuse.key = Long.MIN_VALUE;
+            	reuse.value = null;
+            	associatedMap.reuseAfterDelete = reuse;
+            }
+
+            associatedMap.elementCount--;
+            expectedModCount++;
+        }
+    }
+
+
+
+    @SuppressWarnings("unchecked")
+    Entry<V>[] newElementArray(int s) {
+        return new Entry[s];
+    }
+
+    /**
+     * Constructs a new empty {@code HashMap} instance.
+     * 
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM() {
+        this(DEFAULT_SIZE);
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero.
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM(int capacity) {
+        if (capacity >= 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            loadFactor = 0.75f; // Default load factor of 0.75
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity and
+     * load factor.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @param loadFactor
+     *            the initial load factor.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero or the load factor is
+     *                less or equal to zero.
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM(int capacity, float loadFactor) {
+        if (capacity >= 0 && loadFactor > 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            this.loadFactor = loadFactor;
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+
+
+    // BEGIN android-changed
+    /**
+     * Removes all mappings from this hash map, leaving it empty.
+     * 
+     * @see #isEmpty
+     * @see #size
+     * @since Android 1.0
+     */
+    
+    public void clear() {
+        if (elementCount > 0) {
+            elementCount = 0;
+            Arrays.fill(elementData, null);
+            modCount++;
+        }
+    }
+    // END android-changed
+
+    /**
+     * Returns a shallow copy of this map.
+     * 
+     * @return a shallow copy of this map.
+     * @since Android 1.0
+     */
+    
+
+    private void computeMaxSize() {
+        threshold = (int) (elementData.length * loadFactor);
+    }
+
+    /**
+     * Returns whether this map contains the specified key.
+     * 
+     * @param key
+     *            the key to search for.
+     * @return {@code true} if this map contains the specified key,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsKey(long key) {
+            int hash = (int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            Entry<V> m = findNonNullKeyEntry(key, index, hash);
+        return m != null;
+    }
+
+    /**
+     * Returns whether this map contains the specified value.
+     * 
+     * @param value
+     *            the value to search for.
+     * @return {@code true} if this map contains the specified value,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsValue(Object value) {
+        if (value != null) {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (value.equals(entry.value)) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        } else {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (entry.value == null) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        }
+        return false;
+    }
+
+
+    /**
+     * Returns the value of the mapping with the specified key.
+     * 
+     * @param key
+     *            the key.
+     * @return the value of the mapping with the specified key, or {@code null}
+     *         if no mapping for the specified key is found.
+     * @since Android 1.0
+     */
+    
+    public V get(long key) {
+        Entry<V> m;
+        int hash = (int)(key);
+        int index = (hash & 0x7FFFFFFF) % elementData.length;
+        m = findNonNullKeyEntry(key, index, hash);
+
+        if (m != null) {
+            return m.value;
+        }
+        return null;
+    }
+
+    final Entry<V> findNonNullKeyEntry(long key, int index, int keyHash) {
+        Entry<V> m = elementData[index];
+            while (m != null) {
+
+                    if (key == m.key) {
+                        return m;
+                    }
+
+                m = m.next;
+
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns whether this map is empty.
+     * 
+     * @return {@code true} if this map has no elements, {@code false}
+     *         otherwise.
+     * @see #size()
+     * @since Android 1.0
+     */
+    
+    public boolean isEmpty() {
+        return elementCount == 0;
+    }
+
+    /**
+     * @return iterator over keys
+     */
+    
+//      public Iterator<K> keyIterator(){
+//                 return new HashMapIterator<K, K, V>(
+//                            new MapEntry.Type<K, K, V>() {
+//                                public K get(Entry<K, V> entry) {
+//                                    return entry.key;
+//                                }
+//                            }, HashMap.this);
+//
+//     }
+
+    /**
+     * Maps the specified key to the specified value.
+     * 
+     * @param key
+     *            the key.
+     * @param value
+     *            the value.
+     * @return the value of any previous mapping with the specified key or
+     *         {@code null} if there was no such mapping.
+     * @since Android 1.0
+     */
+    
+
+    public V put(long key, V value) {
+        Entry<V> entry;
+            int hash =(int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            entry = findNonNullKeyEntry(key, index, hash);
+            if (entry == null) {
+                modCount++;
+                if (++elementCount > threshold) {
+                    rehash();
+                    index = (hash & 0x7FFFFFFF) % elementData.length;
+                }
+                entry = createHashedEntry(key, index);
+            }
+
+
+        V result = entry.value;
+        entry.value = value;
+        return result;
+    }
+
+    Entry<V> createEntry(long key, int index, V value) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null){ 
+        	entry = new Entry<V>(key, value);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = value;
+        }
+        
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+    Entry<V> createHashedEntry(long key, int index) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null) {
+        	entry = new Entry<V>(key);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = null;
+        }
+
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+
+    void rehash(int capacity) {
+        int length = (capacity == 0 ? 1 : capacity << 1);
+
+        Entry<V>[] newData = newElementArray(length);
+        for (int i = 0; i < elementData.length; i++) {
+            Entry<V> entry = elementData[i];
+            while (entry != null) {
+                int index = ((int)entry.key & 0x7FFFFFFF) % length;
+                Entry<V> next = entry.next;
+                entry.next = newData[index];
+                newData[index] = entry;
+                entry = next;
+            }
+        }
+        elementData = newData;
+        computeMaxSize();
+    }
+
+    void rehash() {
+        rehash(elementData.length);
+    }
+
+    /**
+     * Removes the mapping with the specified key from this map.
+     * 
+     * @param key
+     *            the key of the mapping to remove.
+     * @return the value of the removed mapping or {@code null} if no mapping
+     *         for the specified key was found.
+     * @since Android 1.0
+     */
+    
+    public V remove(long key) {
+        Entry<V> entry = removeEntry(key);
+        if(entry == null)
+        	return null;
+        V ret = entry.value;
+        entry.value = null;
+        entry.key = Long.MIN_VALUE;
+        reuseAfterDelete = entry;
+        
+        return ret;
+    }
+
+    Entry<V> removeEntry(long key) {
+        int index = 0;
+        Entry<V> entry;
+        Entry<V> last = null;
+
+        int hash = (int)(key);
+        index = (hash & 0x7FFFFFFF) % elementData.length;
+        entry = elementData[index];
+         while (entry != null && !(/*((int)entry.key) == hash &&*/ key == entry.key)) {
+             last = entry;
+              entry = entry.next;
+         }
+         
+         if (entry == null) {
+             return null;
+         }
+         
+        if (last == null) {
+            elementData[index] = entry.next;
+        } else {
+            last.next = entry.next;
+        }
+        modCount++;
+        elementCount--;
+        return entry;
+    }
+
+    /**
+     * Returns the number of elements in this map.
+     * 
+     * @return the number of elements in this map.
+     * @since Android 1.0
+     */
+    
+    public int size() {
+        return elementCount;
+    }
+
+    /**
+     * @returns iterator over values in map
+     */
+    public Iterator<V> valuesIterator() {
+        return new HashMapIterator<V, V>(
+                new EntryType<V,  V>() {
+                    public V get(Entry< V> entry) {
+                        return entry.value;
+                    }
+                }, LongHashMapJDBM.this);
+
+    }
+
+
+}
+
+
+
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongSparseArray.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongSparseArray.java
new file mode 100644
index 00000000..f515ad05
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/performance/target/LongSparseArray.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import android.util.Log;
+
+/**
+ * SparseArrays map longs to Objects.  Unlike a normal array of Objects,
+ * there can be gaps in the indices.  It is intended to be more efficient
+ * than using a HashMap to map Longs to Objects.
+ *
+ * @hide
+ */
+public class LongSparseArray<E> {
+    private static final Object DELETED = new Object();
+    private boolean mGarbage = false;
+
+    /**
+     * Creates a new SparseArray containing no mappings.
+     */
+    public LongSparseArray() {
+        this(10);
+    }
+
+    /**
+     * Creates a new SparseArray containing no mappings that will not
+     * require any additional memory allocation to store the specified
+     * number of mappings.
+     */
+    public LongSparseArray(int initialCapacity) {
+        initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);
+
+        mKeys = new long[initialCapacity];
+        mValues = new Object[initialCapacity];
+        mSize = 0;
+    }
+    
+    /**
+     * @return A copy of all keys contained in the sparse array.
+     */
+    public long[] getKeys() {
+        int length = mKeys.length;
+        long[] result = new long[length];
+        System.arraycopy(mKeys, 0, result, 0, length);
+        return result;
+    }
+    
+    /**
+     * Sets all supplied keys to the given unique value.
+     * @param keys Keys to set
+     * @param uniqueValue Value to set all supplied keys to
+     */
+    public void setValues(long[] keys, E uniqueValue) {
+        int length = keys.length;
+        for (int i = 0; i < length; i++) {
+            put(keys[i], uniqueValue);
+        }
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or <code>null</code>
+     * if no such mapping has been made.
+     */
+    public E get(long key) {
+        return get(key, null);
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or the specified Object
+     * if no such mapping has been made.
+     */
+    public E get(long key, E valueIfKeyNotFound) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i < 0 || mValues[i] == DELETED) {
+            return valueIfKeyNotFound;
+        } else {
+            return (E) mValues[i];
+        }
+    }
+
+    /**
+     * Removes the mapping from the specified key, if there was any.
+     */
+    public void delete(long key) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            if (mValues[i] != DELETED) {
+                mValues[i] = DELETED;
+                mGarbage = true;
+            }
+        }
+    }
+
+    /**
+     * Alias for {@link #delete(long)}.
+     */
+    public void remove(long key) {
+        delete(key);
+    }
+
+    private void gc() {
+        // Log.e("SparseArray", "gc start with " + mSize);
+
+        int n = mSize;
+        int o = 0;
+        long[] keys = mKeys;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            Object val = values[i];
+
+            if (val != DELETED) {
+                if (i != o) {
+                    keys[o] = keys[i];
+                    values[o] = val;
+                }
+
+                o++;
+            }
+        }
+
+        mGarbage = false;
+        mSize = o;
+
+        // Log.e("SparseArray", "gc end with " + mSize);
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value,
+     * replacing the previous mapping from the specified key if there
+     * was one.
+     */
+    public void put(long key, E value) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+
+            if (i < mSize && mValues[i] == DELETED) {
+                mKeys[i] = key;
+                mValues[i] = value;
+                return;
+            }
+
+            if (mGarbage && mSize >= mKeys.length) {
+                gc();
+
+                // Search again because indices may have changed.
+                i = ~binarySearch(mKeys, 0, mSize, key);
+            }
+
+            if (mSize >= mKeys.length) {
+                int n = ArrayUtils.idealIntArraySize(mSize + 1);
+
+                long[] nkeys = new long[n];
+                Object[] nvalues = new Object[n];
+
+                // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+                mKeys = nkeys;
+                mValues = nvalues;
+            }
+
+            if (mSize - i != 0) {
+                // Log.e("SparseArray", "move " + (mSize - i));
+                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
+                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
+            }
+
+            mKeys[i] = key;
+            mValues[i] = value;
+            mSize++;
+        }
+    }
+
+    /**
+     * Returns the number of key-value mappings that this SparseArray
+     * currently stores.
+     */
+    public int size() {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the key from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public long keyAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the value from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public E valueAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return (E) mValues[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, sets a new
+     * value for the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public void setValueAt(int index, E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        mValues[index] = value;
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the
+     * specified key, or a negative number if the specified
+     * key is not mapped.
+     */
+    public int indexOfKey(long key) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return binarySearch(mKeys, 0, mSize, key);
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the
+     * specified key, or a negative number if no keys map to the
+     * specified value.
+     * Beware that this is a linear search, unlike lookups by key,
+     * and that multiple keys can map to the same value and this will
+     * find only one of them.
+     */
+    public int indexOfValue(E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        for (int i = 0; i < mSize; i++)
+            if (mValues[i] == value)
+                return i;
+
+        return -1;
+    }
+
+    /**
+     * Removes all key-value mappings from this SparseArray.
+     */
+    public void clear() {
+        int n = mSize;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            values[i] = null;
+        }
+
+        mSize = 0;
+        mGarbage = false;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where
+     * the key is greater than all existing keys in the array.
+     */
+    public void append(long key, E value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        if (mGarbage && mSize >= mKeys.length) {
+            gc();
+        }
+
+        int pos = mSize;
+        if (pos >= mKeys.length) {
+            int n = ArrayUtils.idealIntArraySize(pos + 1);
+
+            long[] nkeys = new long[n];
+            Object[] nvalues = new Object[n];
+
+            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+            mKeys = nkeys;
+            mValues = nvalues;
+        }
+
+        mKeys[pos] = key;
+        mValues[pos] = value;
+        mSize = pos + 1;
+    }
+
+    private static int binarySearch(long[] a, int start, int len, long key) {
+        int high = start + len, low = start - 1, guess;
+
+        while (high - low > 1) {
+            guess = (high + low) / 2;
+
+            if (a[guess] < key)
+                low = guess;
+            else
+                high = guess;
+        }
+
+        if (high == start + len)
+            return ~(start + len);
+        else if (a[high] == key)
+            return high;
+        else
+            return ~high;
+    }
+
+    private void checkIntegrity() {
+        for (int i = 1; i < mSize; i++) {
+            if (mKeys[i] <= mKeys[i - 1]) {
+                for (int j = 0; j < mSize; j++) {
+                    Log.e("FAIL", j + ": " + mKeys[j] + " -> " + mValues[j]);
+                }
+
+                throw new RuntimeException();
+            }
+        }
+    }
+
+    private long[] mKeys;
+    private Object[] mValues;
+    private int mSize;
+}
\ No newline at end of file
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryTest.java
new file mode 100644
index 00000000..8c4593ff
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+
+import de.greenrobot.dao.query.CountQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class CountQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testCountQuerySimple() {
+        int value = getSimpleInteger(1);
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(1, query.count());
+
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+        assertEquals(2, query.count());
+
+        dao.deleteAll();
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryTwoParameters() {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(1);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(1, query.count());
+
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(valueString);
+        dao.update(inserted.get(2));
+        assertEquals(2, query.count());
+
+        dao.deleteAll();
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryTwoParametersOr() {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(2);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(2, query.count());
+
+        inserted.get(1).setSimpleInteger(getSimpleInteger(2));
+        dao.update(inserted.get(1));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(getSimpleString(3));
+        dao.update(inserted.get(2));
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryChangeParameter() {
+        insert(3);
+
+        String value = "not existing value";
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildCount();
+        assertEquals(0, query.count());
+        query.setParameter(0, getSimpleString(1));
+        assertEquals(1, query.count());
+        query.setParameter(0, getSimpleString(2));
+        assertEquals(1, query.count());
+        query.setParameter(0, "you won't find me either");
+        assertEquals(0, query.count());
+    }
+
+    public void testBuildQueryAndCountQuery() {
+        insert(3);
+        int value = getSimpleInteger(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
+        Query<TestEntity> query = builder.build();
+        CountQuery<TestEntity> countQuery = builder.buildCount();
+
+        assertEquals(1, query.list().size());
+        assertEquals(1, countQuery.count());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
new file mode 100644
index 00000000..8d64894e
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.CountQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class CountQueryThreadLocalTest extends TestEntityTestBase {
+    private CountQuery<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        CountQuery<TestEntity> query = dao.queryBuilder().buildCount();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() {
+        insert(3);
+        int value = getSimpleInteger(1);
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
+        query.setParameter(0, value + 100);
+        assertEquals(0, query.count());
+        query = query.forCurrentThread();
+        assertEquals(1, query.count());
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException {
+        insert(3);
+        createQueryFromOtherThread();
+        CountQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        assertEquals(1, query.count());
+        query.setParameter(0, -10);
+        assertEquals(0, query.count());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.count();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                queryFromOtherThread = builder.buildCount();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryTest.java
new file mode 100644
index 00000000..d189ad77
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class DeleteQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testDeleteQuerySimple() {
+        ArrayList<TestEntity> inserted = insert(3);
+        int value = getSimpleInteger(1);
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleInteger.eq(value))
+                .buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(getSimpleInteger(0), (int) allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryOr() {
+        ArrayList<TestEntity> inserted = insert(3);
+
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        Integer value1 = inserted.get(0).getSimpleInteger();
+        Integer value2 = inserted.get(2).getSimpleInteger();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value1), Properties.SimpleInteger.eq(value2));
+        DeleteQuery<TestEntity> deleteQuery = queryBuilder.buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(inserted.get(1).getSimpleInteger(), allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryExecutingMultipleTimes() {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        insert(3);
+        assertEquals(5, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(4, dao.count());
+    }
+
+    public void testDeleteQueryChangeParameter() {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.setParameter(0, getSimpleString(0));
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(1, dao.count());
+
+        TestEntity remaining = dao.loadAll().get(0);
+        assertEquals(getSimpleString(2), remaining.getSimpleString());
+    }
+
+    public void testBuildQueryAndDeleteQuery() {
+        insert(3);
+        int value = getSimpleInteger(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
+        Query<TestEntity> query = builder.build();
+        DeleteQuery<TestEntity> deleteQuery = builder.buildDelete();
+
+        assertEquals(1, query.list().size());
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(0, query.list().size());
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
new file mode 100644
index 00000000..adb0c582
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class DeleteQueryThreadLocalTest extends TestEntityTestBase {
+    private DeleteQuery<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() {
+        insert(3);
+        int value = getSimpleInteger(1);
+        DeleteQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildDelete();
+        query.setParameter(0, value + 100);
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(3, dao.count());
+        query = query.forCurrentThread();
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException {
+        insert(3);
+        createQueryFromOtherThread();
+        DeleteQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        query.setParameter(0, getSimpleInteger(2));
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.executeDeleteWithoutDetachingEntities();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                queryFromOtherThread = builder.buildDelete();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/LazyListTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/LazyListTest.java
new file mode 100644
index 00000000..dbfdfd86
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/LazyListTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.CloseableListIterator;
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class LazyListTest extends TestEntityTestBase {
+
+    public void testSizeAndGetAndPeak() {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+    public void testGetAll100() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        assertIds(list, listLazy);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testGetAll100Uncached() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        assertIds(list, listLazy);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    public void testIterator() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        testIerator(list, listLazy, false);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testIteratorUncached() {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        testIerator(list, listLazy, true);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    protected void testIerator(ArrayList<TestEntity> list, LazyList<TestEntity> listLazy, boolean uncached) {
+        ListIterator<TestEntity> iterator = listLazy.listIterator();
+        try {
+            iterator.previous();
+            fail("previous should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+        int size = list.size();
+        for (int i = 0; i < size; i++) {
+            assertTrue(iterator.hasNext());
+            assertEquals(i > 0, iterator.hasPrevious());
+            assertEquals(i, iterator.nextIndex());
+            assertEquals(i - 1, iterator.previousIndex());
+
+            if (i > 0) {
+                TestEntity entityPrevious = list.get(i - 1);
+                assertEquals(entityPrevious.getId(), iterator.previous().getId());
+                iterator.next();
+            }
+
+            TestEntity entity = list.get(i);
+            assertNull(listLazy.peak(i));
+            TestEntity lazyEntity = iterator.next();
+            if (uncached) {
+                assertNull(listLazy.peak(i));
+            } else {
+                assertNotNull(listLazy.peak(i));
+            }
+            assertEquals(entity.getId(), lazyEntity.getId());
+        }
+        assertFalse(iterator.hasNext());
+        try {
+            iterator.next();
+            fail("next should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+    }
+
+    public void testEmpty() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().where(Properties.SimpleInteger.eq(-1)).build().listLazy();
+        assertTrue(listLazy.isEmpty());
+        assertTrue(listLazy.isClosed());
+        try {
+            listLazy.get(0);
+            fail("Not empty");
+        } catch (RuntimeException e) {
+            // Expected, OK
+        }
+
+    }
+
+    public void testUncached() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazyUncached();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        TestEntity entity1 = listLazy.get(0);
+        TestEntity entity2 = listLazy.get(0);
+        assertEquals(entity1.getId(), entity2.getId());
+        if (identityScopeForDao == null) {
+            assertNotSame(entity1, entity2);
+        } else {
+            assertSame(entity1, entity2);
+        }
+        assertFalse(listLazy.isClosed());
+        try {
+            listLazy.loadRemaining();
+            fail("Not empty");
+        } catch (DaoException expected) {
+            // Expected, OK
+        }
+        listLazy.close();
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testClose() {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        listLazy.get(0);
+        assertTrue(listLazy.isClosed());
+
+        // Closing again should not harm
+        listLazy.close();
+        listLazy.close();
+    }
+
+    public void testAutoClose() {
+        insert(10);
+        LazyList<TestEntity> lazyList = dao.queryBuilder().build().listLazyUncached();
+        CloseableListIterator<TestEntity> iterator = lazyList.listIteratorAutoClose();
+        while (iterator.hasNext()) {
+            assertFalse(lazyList.isClosed());
+            iterator.next();
+        }
+        assertTrue(lazyList.isClosed());
+    }
+    
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
new file mode 100644
index 00000000..d9e946b2
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao.Properties;
+
+public class QueryBuilderAndOrTest extends AbstractDaoTest<AbcdefEntityDao, AbcdefEntity, Long> {
+
+    public QueryBuilderAndOrTest() {
+        super(AbcdefEntityDao.class);
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    protected ArrayList<AbcdefEntity> insert(int count) {
+        ArrayList<AbcdefEntity> list = new ArrayList<AbcdefEntity>();
+        for (int i = 0; i < count; i++) {
+            int base = i * 100;
+            AbcdefEntity entity = new AbcdefEntity(null, base + 1, base + 2, base + 3, base + 4, base + 5, base + 6,
+                    base + 7, base + 8, base + 9, base + 10, base + 11);
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    public void testSimpleQuery() {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder().where(Properties.A.eq(1)).orderAsc(Properties.A);
+        List<AbcdefEntity> result = queryBuilder.list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        AbcdefEntity resultEntity = result.get(0);
+        assertEquals(1, (int) resultEntity.getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr() {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(2, result.size());
+        assertEquals(2, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr3() {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101), Properties.B.eq(302));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+        assertEquals(301, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNested() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                Properties.B.eq(302), Properties.C.eq(603));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNestedNested() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                queryBuilder.or(Properties.B.eq(302), //
+                        queryBuilder.or(Properties.C.eq(503), Properties.D.eq(804))));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(4, result.size());
+        assertEquals(4, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(501, (int) result.get(2).getA());
+        assertEquals(801, (int) result.get(3).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testAnd() {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.A.eq(201), Properties.B.eq(202));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrAnd() {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(201), //
+                queryBuilder.and(Properties.B.gt(402), Properties.C.lt(703)));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+        assertEquals(501, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderOrderTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
new file mode 100644
index 00000000..f9a43e6b
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryBuilderOrderTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testOrderAsc() {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(0);
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleInteger).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+        result = dao.queryBuilder().orderAsc(Properties.SimpleInteger, Properties.SimpleString).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    public void testOrderDesc() {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(1);
+        List<TestEntity> result = dao.queryBuilder().orderDesc(Properties.SimpleInteger).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+        result = dao.queryBuilder().orderDesc(Properties.SimpleInteger, Properties.SimpleString).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    public void testOrderUpperLowercase() {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityAA = addEntity(list, "aa");
+        TestEntity entityAB = addEntity(list, "Ab");
+        TestEntity entityAC = addEntity(list, "ac");
+        TestEntity entityZA = addEntity(list, "ZA");
+        TestEntity entityZB = addEntity(list, "zB");
+        TestEntity entityZC = addEntity(list, "ZC");
+        Collections.shuffle(list);
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAA.getId(), result.get(0).getId());
+        assertEquals(entityAB.getId(), result.get(1).getId());
+        assertEquals(entityAC.getId(), result.get(2).getId());
+        assertEquals(entityZA.getId(), result.get(3).getId());
+        assertEquals(entityZB.getId(), result.get(4).getId());
+        assertEquals(entityZC.getId(), result.get(5).getId());
+    }
+
+    public void testOrderUmlauts() {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityV = addEntity(list, "V");
+        TestEntity entityB = addEntity(list, "B");
+        TestEntity entityUE = addEntity(list, "");
+        TestEntity entityAE = addEntity(list, "");
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAE.getId(), result.get(0).getId());
+        assertEquals(entityB.getId(), result.get(1).getId());
+        assertEquals(entityUE.getId(), result.get(2).getId());
+        assertEquals(entityV.getId(), result.get(3).getId());
+    }
+
+    public void testOrderCustom() {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityAA = addEntity(list, "Aa");
+        TestEntity entityAB = addEntity(list, "ab");
+        TestEntity entityAC = addEntity(list, "Ac");
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderCustom(Properties.SimpleString, "ASC").list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAA.getId(), result.get(0).getId());
+        assertEquals(entityAC.getId(), result.get(1).getId());
+        assertEquals(entityAB.getId(), result.get(2).getId());
+    }
+
+    public void testOrderRaw() {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(0);
+        List<TestEntity> result = dao.queryBuilder().orderRaw(Properties.SimpleInteger.columnName + " ASC").list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    private TestEntity addEntity(List<TestEntity> list, String simpleString) {
+        TestEntity entityAB = createEntity(42, simpleString);
+        list.add(entityAB);
+        return entityAB;
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
new file mode 100644
index 00000000..3f9f7276
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryBuilderSimpleTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testEqInteger() {
+        ArrayList<TestEntity> inserted = insert(3);
+        int value = getSimpleInteger(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, (int) resultEntity.getSimpleInteger());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testEqString() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.eq(value)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testIn() {
+        ArrayList<TestEntity> inserted = insert(10);
+        String value1 = getSimpleString(2);
+        String value2 = getSimpleString(8);
+        String value3 = getSimpleString(9);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.in(value1, value2, value3))
+                .orderAsc(Properties.SimpleString).list();
+        assertEquals(3, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        assertEquals(value1, resultEntity1.getSimpleString());
+        assertEquals(inserted.get(2).getId(), resultEntity1.getId());
+
+        TestEntity resultEntity2 = result.get(1);
+        assertEquals(value2, resultEntity2.getSimpleString());
+        assertEquals(inserted.get(8).getId(), resultEntity2.getId());
+
+        TestEntity resultEntity3 = result.get(2);
+        assertEquals(value3, resultEntity3.getSimpleString());
+        assertEquals(inserted.get(9).getId(), resultEntity3.getId());
+    }
+
+    public void testNotIn() {
+        ArrayList<TestEntity> inserted = insert(5);
+        String value1 = getSimpleString(0);
+        String value2 = getSimpleString(2);
+        String value3 = getSimpleString(4);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notIn(value1, value2, value3))
+                .orderAsc(Properties.SimpleString).list();
+        assertEquals(2, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        assertEquals(inserted.get(1).getId(), resultEntity1.getId());
+
+        TestEntity resultEntity2 = result.get(1);
+        assertEquals(inserted.get(3).getId(), resultEntity2.getId());
+    }
+
+    public void testEqStringAndInteger() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String valueStr = getSimpleString(1);
+        int valueInt = getSimpleInteger(1);
+
+        List<TestEntity> result = dao.queryBuilder()
+                .where(Properties.SimpleString.eq(valueStr), Properties.SimpleInteger.eq(valueInt)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testNotEqString() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notEq(value)).list();
+        assertEquals(2, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        TestEntity resultEntity2 = result.get(1);
+        long loId = Math.min(resultEntity1.getId(), resultEntity2.getId());
+        long hiId = Math.max(resultEntity1.getId(), resultEntity2.getId());
+        assertEquals((long) inserted.get(0).getId(), loId);
+        assertEquals((long) inserted.get(2).getId(), hiId);
+    }
+
+    public void testEqDate() {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        Date date = new Date();
+        testEntity.setSimpleDate(date);
+        dao.update(testEntity);
+
+        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date.getTime())).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+    }
+
+    public void testEqBoolean() {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        testEntity.setSimpleBoolean(true);
+        dao.update(testEntity);
+
+        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(true)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(Boolean.TRUE)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("TRUE")).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("truE")).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+    }
+
+    public void testIsNullIsNotNull() {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity testEntityNull = inserted.get(0);
+        TestEntity testEntityNotNull = inserted.get(1);
+
+        testEntityNull.setSimpleInteger(null);
+        testEntityNotNull.setSimpleInteger(42);
+        dao.update(testEntityNull);
+        dao.update(testEntityNotNull);
+
+        TestEntity testEntityNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNull()).uniqueOrThrow();
+        assertEquals(testEntityNull.getId(), testEntityNull2.getId());
+
+        TestEntity testEntityNotNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNotNull()).uniqueOrThrow();
+        assertEquals(testEntityNotNull.getId(), testEntityNotNull2.getId());
+    }
+
+    public void testBuildTwice() {
+        insert(3);
+        String value = getSimpleString(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleString.eq(value));
+        Query<TestEntity> query1 = builder.build();
+        Query<TestEntity> query2 = builder.build();
+        List<TestEntity> list1 = query1.list();
+        List<TestEntity> list2 = query2.list();
+        assertEquals(1, list1.size());
+        assertEquals(1, list2.size());
+        assertEquals(list1.get(0).getId(), list2.get(0).getId());
+    }
+
+    public void testLike() {
+        TestEntity entity = insert(3).get(1);
+        entity.setSimpleString("greenrobot");
+        dao.update(entity);
+
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
+        TestEntity entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "green%");
+        entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "%enrob%");
+        entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "%nothere%");
+        entity2 = query.unique();
+        assertNull(entity2);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryForThreadTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryForThreadTest.java
new file mode 100644
index 00000000..c99e2747
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryForThreadTest.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import android.util.SparseArray;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryForThreadTest extends TestEntityTestBase {
+    /** Takes longer when activated */
+    private final static boolean DO_LEAK_TESTS = false;
+    private final static int LEAK_TEST_ITERATIONS = DO_LEAK_TESTS ? 100000 : 2500;
+
+    private Query<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        Query<TestEntity> query = dao.queryBuilder().build();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() {
+        insert(3);
+        int value = getSimpleInteger(1);
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).build();
+        query.setParameter(0, value + 1);
+        TestEntity entityFor2 = query.unique();
+        assertEquals(value + 1, (int) entityFor2.getSimpleInteger());
+        query = query.forCurrentThread();
+        TestEntity entityFor1 = query.unique();
+    }
+
+    public void testGetForCurrentThread_ManyThreadsDontLeak() throws Exception {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        final Query<TestEntity> query = builder.build();
+        for (int i = 1; i <= LEAK_TEST_ITERATIONS; i++) {
+            Thread thread = new Thread() {
+                public void run() {
+                    query.forCurrentThread();
+                };
+            };
+            thread.start();
+            if (i % 10 == 0) {
+                thread.join();
+            }
+        }
+        Field queryDataField = Query.class.getDeclaredField("queryData");
+        queryDataField.setAccessible(true);
+        Object queryData = queryDataField.get(query);
+        Class<?> dataSuperclass = queryData.getClass().getSuperclass();
+        Field mapField = dataSuperclass.getDeclaredField("queriesForThreads");
+        mapField.setAccessible(true);
+
+        Method gcMethod = dataSuperclass.getDeclaredMethod("gc");
+        gcMethod.setAccessible(true);
+        SparseArray<?> map = (SparseArray<?>) mapField.get(queryData);
+        for (int i = 0; map.size() > 1 && i < 1000; i++) {
+            DaoLog.d("Queries left after " + i + ". GC: " + map.size());
+            System.gc();
+            gcMethod.invoke(queryData);
+        }
+        assertEquals(1, map.size());
+    }
+
+    public void testBuildQueryDoesntLeak() {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        for (int i = 0; i < LEAK_TEST_ITERATIONS; i++) {
+            builder.build();
+        }
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException {
+        insert(3);
+        createQueryFromOtherThread();
+        Query<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        query.setLimit(10);
+        query.setOffset(0);
+        assertEquals(getSimpleInteger(1), (int) query.uniqueOrThrow().getSimpleInteger());
+        int expected = getSimpleInteger(2);
+        query.setParameter(0, expected);
+        assertEquals(expected, (int) query.list().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.listLazy().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.listLazyUncached().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.unique().getSimpleInteger());
+        assertEquals(expected, (int) query.uniqueOrThrow().getSimpleInteger());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.list();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.listIterator();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.listLazyUncached();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setLimit(2);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setOffset(2);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.unique();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.uniqueOrThrow();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                builder.limit(10).offset(20);
+                queryFromOtherThread = builder.build();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryLimitOffsetTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
new file mode 100644
index 00000000..acf773fe
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryLimitOffsetTest extends TestEntityTestBase {
+    
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testQueryBuilderLimit() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(0), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(1), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(2), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimit() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().offset(3).limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(3), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(4), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimitWithWhere() {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(1))).offset(2)
+                .limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryOffsetAndLimit() {
+        insert(10);
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(-1))).offset(-1)
+                .limit(-1).orderAsc(Properties.SimpleInt).build(); 
+        query.setParameter(0, getSimpleInteger(1));
+        query.setLimit(3);
+        query.setOffset(2);
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+    
+    public void testQueryBuilderOffsetWithoutLimit() {
+        try{
+            dao.queryBuilder().offset(7).orderAsc(Properties.SimpleInt).build();
+            fail("Offset may not be set alone");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryLimitAndSetParameter() {
+        Query<TestEntity> query = dao.queryBuilder().limit(5).offset(1).build();
+        try{
+            query.setParameter(0, null);
+            fail("Offset/limit parameters must not interfere with user parameters");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryUnsetLimit() {
+        Query<TestEntity> query = dao.queryBuilder().build();
+        try{
+            query.setLimit(1);
+            fail("Limit must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+    public void testQueryUnsetOffset() {
+        Query<TestEntity> query = dao.queryBuilder().limit(1).build();
+        try{
+            query.setOffset(1);
+            fail("Offset must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QuerySpecialNamesTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
new file mode 100644
index 00000000..2709b516
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao.Properties;
+
+public class QuerySpecialNamesTest extends AbstractDaoTest<SpecialNamesEntityDao, SpecialNamesEntity, Long> {
+
+    public QuerySpecialNamesTest() {
+        super(SpecialNamesEntityDao.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testWhereWithSpecialNames() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.isNotNull());
+        queryBuilder.where(Properties.Count.isNotNull());
+        queryBuilder.where(Properties.Distinct.isNotNull());
+        queryBuilder.where(Properties.Index.isNotNull());
+        queryBuilder.where(Properties.Join.isNotNull());
+        queryBuilder.where(Properties.On.isNotNull());
+        queryBuilder.where(Properties.Select.isNotNull());
+        queryBuilder.where(Properties.Sum.isNotNull());
+        queryBuilder.where(Properties.Order.isNotNull());
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testWhereWithSpecialNamesWithValues() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.eq("test"));
+        queryBuilder.where(Properties.Count.notIn("test", "test2"));
+        queryBuilder.where(Properties.Distinct.ge("test"));
+        queryBuilder.where(Properties.Index.le("test"));
+        queryBuilder.where(Properties.Join.like("test"));
+        queryBuilder.where(Properties.On.notEq("test"));
+        queryBuilder.where(Properties.Select.in("test", "test2"));
+        queryBuilder.where(Properties.Sum.lt(1));
+        queryBuilder.where(Properties.Order.gt(1));
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrderWithSpecialNames() {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.orderAsc(Properties.Avg);
+        queryBuilder.orderAsc(Properties.Count);
+        queryBuilder.orderAsc(Properties.Distinct);
+        queryBuilder.orderAsc(Properties.Index);
+        queryBuilder.orderAsc(Properties.Join);
+        queryBuilder.orderAsc(Properties.On);
+        queryBuilder.orderAsc(Properties.Select);
+        queryBuilder.orderAsc(Properties.Sum);
+        queryBuilder.orderAsc(Properties.Order);
+        queryBuilder.list();
+    }
+
+}
diff --git a/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/RawQueryTest.java
new file mode 100644
index 00000000..1a9126cc
--- /dev/null
+++ b/DaoTest/src/androidTest/java/de/greenrobot/daotest/query/RawQueryTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class RawQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testRawQueryEmptySql() {
+        insert(3);
+        Query<TestEntity> query = dao.queryRawCreate("");
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+    }
+
+    public void testRawQueryEqualsString() {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testRawQueryCreate_setParameterInQuery() {
+        insert(3);
+        String value = getSimpleString(2);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
+        query.list();
+
+        query.setParameter(0, value);
+        List<TestEntity> result = query.list();
+
+        assertEquals(1, result.size());
+        assertEquals(value, result.get(0).getSimpleString());
+    }
+    
+    public void testRawQueryLazyList() {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+}
diff --git a/DaoTest/src/androidTest/res/assets/minimal-entity.sql b/DaoTest/src/androidTest/res/assets/minimal-entity.sql
new file mode 100644
index 00000000..edae6051
--- /dev/null
+++ b/DaoTest/src/androidTest/res/assets/minimal-entity.sql
@@ -0,0 +1,7 @@
+CREATE TABLE MINIMAL_ENTITY (_id INTEGER PRIMARY KEY);
+INSERT INTO MINIMAL_ENTITY VALUES (1);
+INSERT INTO MINIMAL_ENTITY 
+	VALUES (2);
+INSERT INTO MINIMAL_ENTITY VALUES (3)   ;
+INSERT INTO MINIMAL_ENTITY VALUES (4);  
+INSERT INTO MINIMAL_ENTITY VALUES (5) ;  
diff --git a/DaoTest/src/main/AndroidManifest.xml b/DaoTest/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..7f7945e7
--- /dev/null
+++ b/DaoTest/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.greenrobot.greendao" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".MyActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/DaoTest/src/main/java/com/borvo/de.greenrobot.greendao/MyActivity.java b/DaoTest/src/main/java/com/borvo/de.greenrobot.greendao/MyActivity.java
new file mode 100644
index 00000000..b3342e79
--- /dev/null
+++ b/DaoTest/src/main/java/com/borvo/de.greenrobot.greendao/MyActivity.java
@@ -0,0 +1,36 @@
+package de.greenrobot.greendao;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
+
+
+public class MyActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_my);
+    }
+
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        // Inflate the menu; this adds items to the action bar if it is present.
+        getMenuInflater().inflate(R.menu.my, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle action bar item clicks here. The action bar will
+        // automatically handle clicks on the Home/Up button, so long
+        // as you specify a parent activity in AndroidManifest.xml.
+        int id = item.getItemId();
+        if (id == R.id.action_settings) {
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+}
diff --git a/DaoTest/src/main/res/assets/minimal-entity.sql b/DaoTest/src/main/res/assets/minimal-entity.sql
new file mode 100644
index 00000000..edae6051
--- /dev/null
+++ b/DaoTest/src/main/res/assets/minimal-entity.sql
@@ -0,0 +1,7 @@
+CREATE TABLE MINIMAL_ENTITY (_id INTEGER PRIMARY KEY);
+INSERT INTO MINIMAL_ENTITY VALUES (1);
+INSERT INTO MINIMAL_ENTITY 
+	VALUES (2);
+INSERT INTO MINIMAL_ENTITY VALUES (3)   ;
+INSERT INTO MINIMAL_ENTITY VALUES (4);  
+INSERT INTO MINIMAL_ENTITY VALUES (5) ;  
diff --git a/DaoTest/src/main/res/drawable-hdpi/ic_launcher.png b/DaoTest/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 00000000..96a442e5
Binary files /dev/null and b/DaoTest/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/DaoTest/src/main/res/drawable-mdpi/ic_launcher.png b/DaoTest/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 00000000..359047df
Binary files /dev/null and b/DaoTest/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/DaoTest/src/main/res/drawable-xhdpi/ic_launcher.png b/DaoTest/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 00000000..71c6d760
Binary files /dev/null and b/DaoTest/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/DaoTest/src/main/res/drawable-xxhdpi/ic_launcher.png b/DaoTest/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 00000000..4df18946
Binary files /dev/null and b/DaoTest/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/DaoTest/src/main/res/layout/activity_my.xml b/DaoTest/src/main/res/layout/activity_my.xml
new file mode 100644
index 00000000..c17166f4
--- /dev/null
+++ b/DaoTest/src/main/res/layout/activity_my.xml
@@ -0,0 +1,16 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    tools:context=".MyActivity">
+
+    <TextView
+        android:text="@string/hello_world"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+
+</RelativeLayout>
diff --git a/DaoTest/src/main/res/menu/my.xml b/DaoTest/src/main/res/menu/my.xml
new file mode 100644
index 00000000..bea58cc0
--- /dev/null
+++ b/DaoTest/src/main/res/menu/my.xml
@@ -0,0 +1,8 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".MyActivity" >
+    <item android:id="@+id/action_settings"
+        android:title="@string/action_settings"
+        android:orderInCategory="100"
+        android:showAsAction="never" />
+</menu>
diff --git a/DaoTest/src/main/res/values-v21/styles.xml b/DaoTest/src/main/res/values-v21/styles.xml
new file mode 100644
index 00000000..dba3c417
--- /dev/null
+++ b/DaoTest/src/main/res/values-v21/styles.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <style name="AppTheme" parent="android:Theme.Material.Light">
+    </style>
+</resources>
diff --git a/DaoTest/src/main/res/values-w820dp/dimens.xml b/DaoTest/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 00000000..63fc8164
--- /dev/null
+++ b/DaoTest/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/DaoTest/src/main/res/values/dimens.xml b/DaoTest/src/main/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/DaoTest/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/DaoTest/src/main/res/values/strings.xml b/DaoTest/src/main/res/values/strings.xml
new file mode 100644
index 00000000..35ef01bb
--- /dev/null
+++ b/DaoTest/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">GreenDAO</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
diff --git a/DaoTest/src/main/res/values/styles.xml b/DaoTest/src/main/res/values/styles.xml
new file mode 100644
index 00000000..ff6c9d2c
--- /dev/null
+++ b/DaoTest/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..9b8abe4f
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.12.2'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..5d08ba75
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..8c0fb64a
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..1e61d1fd
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..8a0b282a
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..f8ce9e78
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':app', ':DaoCore', ':DaoGenerator', ':DaoTest', ':DaoExampleGenerator', ':DaoExample'
