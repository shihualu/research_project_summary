diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 509e04f50..f211415d7 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -82,19 +82,19 @@ final ResolvedBindings resolvedBindings(BindingRequest request) {
   /**
    * The type that defines the component for this graph.
    *
-   * @see ComponentDescriptor#componentDefinitionType()
+   * @see ComponentDescriptor#typeElement()
    */
-  TypeElement componentType() {
-    return componentDescriptor().componentDefinitionType();
+  TypeElement componentTypeElement() {
+    return componentDescriptor().typeElement();
   }
 
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
    * their bindings are used in this graph. For graphs representing top-level {@link
-   * dagger.Component components}, this set will be the same as
-   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
-   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
-   * owned by any of their ancestors.
+   * dagger.Component components}, this set will be the same as {@linkplain
+   * ComponentDescriptor#modules() the component's transitive modules}. For {@linkplain Subcomponent
+   * subcomponents}, this set will be the transitive modules that are not owned by any of their
+   * ancestors.
    */
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index a892c45b1..89ad6f195 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -206,7 +206,7 @@ private BindingNode bindingNode(
         ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
       return BindingNode.create(
           componentTreePath()
-              .pathFromRootToAncestor(owningComponent.componentDefinitionType())
+              .pathFromRootToAncestor(owningComponent.typeElement())
               .toComponentPath(),
           binding,
           associatedDeclaringElements(resolvedBindings),
@@ -224,7 +224,7 @@ private BindingNode bindingNode(
     private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
       return BindingGraphProxies.missingBindingNode(
           componentTreePath()
-              .pathFromRootToAncestor(dependencies.owningComponent().componentDefinitionType())
+              .pathFromRootToAncestor(dependencies.owningComponent().typeElement())
               .toComponentPath(),
           dependencies.key());
     }
@@ -232,9 +232,9 @@ private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
     private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
       TypeElement subcomponentBuilderElement = asTypeElement(subcomponentBuilderType);
       ComponentDescriptor subcomponent =
-          graph.componentDescriptor().subcomponentsByBuilderType().get(subcomponentBuilderElement);
+          graph.componentDescriptor().getChildComponentWithBuilderType(subcomponentBuilderElement);
       return ComponentNodeImpl.create(
-          componentTreePath().childPath(subcomponent.componentDefinitionType()).toComponentPath(),
+          componentTreePath().childPath(subcomponent.typeElement()).toComponentPath(),
           subcomponent);
     }
 
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index d49a503a2..b0c55e949 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -46,7 +46,6 @@
 import dagger.MembersInjector;
 import dagger.Reusable;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -111,8 +110,7 @@ private BindingGraph create(
     ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
     // binding for the component itself
-    explicitBindingsBuilder.add(
-        bindingFactory.componentBinding(componentDescriptor.componentDefinitionType()));
+    explicitBindingsBuilder.add(bindingFactory.componentBinding(componentDescriptor.typeElement()));
 
     // Collect Component dependencies.
     for (ComponentRequirement dependency : componentDescriptor.dependencies()) {
@@ -138,22 +136,24 @@ private BindingGraph create(
       }
     }
 
-    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> componentMethodAndSubcomponent :
-        componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {
-      ComponentMethodDescriptor componentMethod = componentMethodAndSubcomponent.getKey();
-      ComponentDescriptor subcomponentDescriptor = componentMethodAndSubcomponent.getValue();
-      if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {
-        explicitBindingsBuilder.add(
-            bindingFactory.subcomponentBuilderBinding(
-                componentMethod.methodElement(), componentDescriptor.componentDefinitionType()));
-      }
-    }
+    componentDescriptor
+        .childComponentsDeclaredByBuilderEntryPoints()
+        .forEach(
+            (builderEntryPoint, childComponent) -> {
+              if (!componentDescriptor
+                  .childComponentsDeclaredByModules()
+                  .contains(childComponent)) {
+                explicitBindingsBuilder.add(
+                    bindingFactory.subcomponentBuilderBinding(
+                        builderEntryPoint.methodElement(), componentDescriptor.typeElement()));
+              }
+            });
 
     ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations = ImmutableSet.builder();
     ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations = ImmutableSet.builder();
 
     // Collect transitive module bindings and multibinding declarations.
-    for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
+    for (ModuleDescriptor moduleDescriptor : componentDescriptor.modules()) {
       explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
       multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
       subcomponentDeclarations.addAll(moduleDescriptor.subcomponentDeclarations());
@@ -254,20 +254,18 @@ private BindingGraph create(
       this.explicitMultibindings = multibindingContributionsByMultibindingKey(explicitBindingsSet);
       this.delegateMultibindingDeclarations =
           multibindingContributionsByMultibindingKey(delegateDeclarations.values());
-      subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());
+      subcomponentsToResolve.addAll(
+          componentDescriptor.childComponentsDeclaredByFactoryMethods().values());
+      subcomponentsToResolve.addAll(
+          componentDescriptor.childComponentsDeclaredByBuilderEntryPoints().values());
     }
 
     /** Returns the optional factory method for this component. */
     Optional<ExecutableElement> getFactoryMethod() {
       return parentResolver
-          .map(
-              parent -> {
-                return parent
-                    .componentDescriptor
-                    .subcomponentsByFactoryMethod()
-                    .inverse()
-                    .get(componentDescriptor);
-              })
+          .flatMap(
+              parent ->
+                  parent.componentDescriptor.getFactoryMethodForChildComponent(componentDescriptor))
           .map(method -> method.methodElement());
     }
 
@@ -359,7 +357,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
 
       TypeElement builderType = MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());
       owningResolver.subcomponentsToResolve.add(
-          owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
+          owningResolver.componentDescriptor.getChildComponentWithBuilderType(builderType));
     }
 
     private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
@@ -633,15 +631,14 @@ private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBindi
     private ComponentPath componentPath(Resolver destination) {
       ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
       for (Resolver resolver : getResolverLineage()) {
-        path.add(resolver.componentDescriptor.componentDefinitionType());
+        path.add(resolver.componentDescriptor.typeElement());
         if (resolver == destination) {
           return ComponentPath.create(path.build());
         }
       }
       throw new AssertionError(
           String.format(
-              "%s not found in %s",
-              destination.componentDescriptor.componentDefinitionType(), path.build()));
+              "%s not found in %s", destination.componentDescriptor.typeElement(), path.build()));
     }
 
     /** Returns the resolver lineage from parent to child. */
@@ -887,14 +884,13 @@ private void resolveDependencies(ResolvedBindings resolvedBindings) {
       return parentResolver.isPresent()
           ? Sets.union(
                   parentResolver.get().getInheritedModules(),
-                  parentResolver.get().componentDescriptor.transitiveModules())
+                  parentResolver.get().componentDescriptor.modules())
               .immutableCopy()
           : ImmutableSet.<ModuleDescriptor>of();
     }
 
     ImmutableSet<ModuleDescriptor> getOwnedModules() {
-      return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
-          .immutableCopy();
+      return Sets.difference(componentDescriptor.modules(), getInheritedModules()).immutableCopy();
     }
 
     private final class LocalDependencyChecker {
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index f05d0d041..5858d1c39 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -230,7 +230,7 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
     BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
     return MethodSpec.overriding(
             componentMethod.methodElement(),
-            MoreTypes.asDeclared(graph.componentType().asType()),
+            MoreTypes.asDeclared(graph.componentTypeElement().asType()),
             types)
         .addCode(
             getBindingExpression(request)
@@ -641,7 +641,7 @@ BindingExpression wrapInMethod(
     BindingMethodImplementation methodImplementation =
         methodImplementation(resolvedBindings, request, bindingExpression);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
-        graph.componentDescriptor().findMatchingComponentMethod(request);
+        graph.componentDescriptor().firstMatchingComponentMethod(request);
     Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
         componentImplementation.getModifiableBindingMethod(request);
 
diff --git a/java/dagger/internal/codegen/ComponentBuilderImplementation.java b/java/dagger/internal/codegen/ComponentBuilderImplementation.java
index 0cf2da8cc..68691a356 100644
--- a/java/dagger/internal/codegen/ComponentBuilderImplementation.java
+++ b/java/dagger/internal/codegen/ComponentBuilderImplementation.java
@@ -183,7 +183,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
       } else {
         buildMethod = methodBuilder("build");
       }
-      buildMethod.returns(ClassName.get(graph.componentType())).addModifiers(PUBLIC);
+      buildMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
 
       builderFields.forEach(
           (requirement, field) -> {
@@ -267,19 +267,18 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
           methods.add(builderMethod.build());
         }
       } else {
-        for (ComponentRequirement componentRequirement :
-            graph.componentDescriptor().availableDependencies()) {
-          String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
+        for (ComponentRequirement requirement :
+            graph.componentDescriptor().dependenciesAndConcreteModules()) {
+          String componentRequirementName = simpleVariableName(requirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
                   .returns(componentImplementation.getBuilderName())
                   .addModifiers(PUBLIC)
-                  .addParameter(
-                      TypeName.get(componentRequirement.type()), componentRequirementName);
-          if (componentRequirements.contains(componentRequirement)) {
+                  .addParameter(TypeName.get(requirement.type()), componentRequirementName);
+          if (componentRequirements.contains(requirement)) {
             builderMethod.addStatement(
                 "this.$N = $T.checkNotNull($L)",
-                builderFields.get(componentRequirement),
+                builderFields.get(requirement),
                 Preconditions.class,
                 componentRequirementName);
           } else {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 21c429b39..eb4699916 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -18,6 +18,7 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
@@ -26,6 +27,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerTypes.isFutureType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -39,8 +41,8 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.collect.FluentIterable;
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -194,13 +196,14 @@ boolean isProducer() {
 
   abstract Kind kind();
 
-  abstract AnnotationMirror componentAnnotation();
+  /** The annotation that specifies that {@link #typeElement()} is a component. */
+  abstract AnnotationMirror annotation();
 
   /**
-   * The type (interface or abstract class) that defines the component. This is the element to which
-   * the {@link Component} annotation was applied.
+   * The element that defines the component. This is the element to which the {@link #annotation()}
+   * was applied.
    */
-  abstract TypeElement componentDefinitionType();
+  abstract TypeElement typeElement();
 
   /**
    * The set of component dependencies listed in {@link Component#dependencies} or {@link
@@ -208,11 +211,10 @@ boolean isProducer() {
    */
   abstract ImmutableSet<ComponentRequirement> dependencies();
 
-  /** The non-abstract {@link #transitiveModules()} and the {@link #dependencies()}. */
-  ImmutableSet<ComponentRequirement> availableDependencies() {
+  /** The non-abstract {@link #modules()} and the {@link #dependencies()}. */
+  final ImmutableSet<ComponentRequirement> dependenciesAndConcreteModules() {
     return Stream.concat(
-            transitiveModuleTypes()
-                .stream()
+            moduleTypes().stream()
                 .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
                 .map(module -> ComponentRequirement.forModule(module.asType())),
             dependencies().stream())
@@ -220,35 +222,32 @@ boolean isProducer() {
   }
 
   /**
-   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
-   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
-   * {@link Module#includes}.
+   * The {@link ModuleDescriptor modules} declared in {@link Component#modules()} and reachable by
+   * traversing {@link Module#includes()}.
    */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
-  /**
-   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
-   * those reachable by traversing {@link Module#includes}.
-   *
-   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
-   * are declared in parent components.
-   */
-  abstract ImmutableSet<ModuleDescriptor> transitiveModules();
-
-  ImmutableSet<TypeElement> transitiveModuleTypes() {
-    return FluentIterable.from(transitiveModules())
-        .transform(ModuleDescriptor::moduleElement)
-        .toSet();
+  /** The types of the {@link #modules()}. */
+  final ImmutableSet<TypeElement> moduleTypes() {
+    return modules().stream().map(ModuleDescriptor::moduleElement).collect(toImmutableSet());
   }
 
   /**
    * This component's {@linkplain #dependencies() dependencies} keyed by each provision or
-   * production method implemented by that dependency. Note that the dependencies' types are not
-   * simply the enclosing type of the method; a method may be declared by a supertype of the actual
+   * production method defined by that dependency. Note that the dependencies' types are not simply
+   * the enclosing type of the method; a method may be declared by a supertype of the actual
    * dependency.
    */
   abstract ImmutableMap<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod();
 
+  /** The {@linkplain #dependencies() component dependency} that defines a method. */
+  final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
+    checkArgument(
+        method instanceof ExecutableElement, "method must be an executable element: %s", method);
+    return checkNotNull(
+        dependenciesByDependencyMethod().get(method), "no dependency implements %s", method);
+  }
+
   /**
    * The scopes of the component.
    */
@@ -257,14 +256,14 @@ boolean isProducer() {
   /**
    * All {@link Subcomponent}s which are direct children of this component. This includes
    * subcomponents installed from {@link Module#subcomponents()} as well as subcomponent {@linkplain
-   * #subcomponentsByFactoryMethod() factory methods} and {@linkplain
-   * #subcomponentsByBuilderMethod() builder methods}.
+   * #childComponentsDeclaredByFactoryMethods() factory methods} and {@linkplain
+   * #childComponentsDeclaredByBuilderEntryPoints() builder methods}.
    */
-  ImmutableSet<ComponentDescriptor> subcomponents() {
+  final ImmutableSet<ComponentDescriptor> childComponents() {
     return ImmutableSet.<ComponentDescriptor>builder()
-        .addAll(subcomponentsByFactoryMethod().values())
-        .addAll(subcomponentsByBuilderMethod().values())
-        .addAll(subcomponentsFromModules())
+        .addAll(childComponentsDeclaredByFactoryMethods().values())
+        .addAll(childComponentsDeclaredByBuilderEntryPoints().values())
+        .addAll(childComponentsDeclaredByModules())
         .build();
   }
 
@@ -272,51 +271,52 @@ boolean isProducer() {
    * All {@linkplain Subcomponent direct child} components that are declared by a {@linkplain
    * Module#subcomponents() module's subcomponents}.
    */
-  abstract ImmutableSet<ComponentDescriptor> subcomponentsFromModules();
+  abstract ImmutableSet<ComponentDescriptor> childComponentsDeclaredByModules();
 
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * factory method.
    */
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
-      subcomponentsByFactoryMethod();
+      childComponentsDeclaredByFactoryMethods();
+
+  /** Returns the factory method that declares a child component. */
+  final Optional<ComponentMethodDescriptor> getFactoryMethodForChildComponent(
+      ComponentDescriptor childComponent) {
+    return Optional.ofNullable(
+        childComponentsDeclaredByFactoryMethods().inverse().get(childComponent));
+  }
 
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * builder method.
    */
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
-      subcomponentsByBuilderMethod();
-
-  /**
-   * All {@linkplain Subcomponent direct child} components that are declared by an entry point
-   * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}
-   * and {@link #subcomponentsByBuilderMethod()}.
-   */
-  ImmutableSet<ComponentDescriptor> subcomponentsFromEntryPoints() {
-    return ImmutableSet.<ComponentDescriptor>builder()
-        .addAll(subcomponentsByFactoryMethod().values())
-        .addAll(subcomponentsByBuilderMethod().values())
-        .build();
-  }
-
-  @Memoized
-  ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
-    ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
-        ImmutableBiMap.builder();
-    for (ComponentDescriptor subcomponent : subcomponents()) {
-      if (subcomponent.builderSpec().isPresent()) {
-        subcomponentsByBuilderType.put(
-            subcomponent.builderSpec().get().builderDefinitionType(), subcomponent);
-      }
-    }
-    return subcomponentsByBuilderType.build();
+      childComponentsDeclaredByBuilderEntryPoints();
+
+  private final Supplier<ImmutableMap<TypeElement, ComponentDescriptor>>
+      childComponentsByBuilderType =
+          Suppliers.memoize(
+              () ->
+                  childComponents().stream()
+                      .filter(child -> child.builderSpec().isPresent())
+                      .collect(
+                          toImmutableMap(
+                              child -> child.builderSpec().get().builderDefinitionType(),
+                              child -> child)));
+
+  /** Returns the child component with the given builder type. */
+  final ComponentDescriptor getChildComponentWithBuilderType(TypeElement builderType) {
+    return checkNotNull(
+        childComponentsByBuilderType.get().get(builderType),
+        "no child component found for builder type %s",
+        builderType.getQualifiedName());
   }
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
   /** Returns the first component method associated with this binding request, if one exists. */
-  Optional<ComponentMethodDescriptor> findMatchingComponentMethod(BindingRequest request) {
+  Optional<ComponentMethodDescriptor> firstMatchingComponentMethod(BindingRequest request) {
     return componentMethods().stream()
         .filter(method -> doesComponentMethodMatch(method, request))
         .findFirst();
@@ -333,7 +333,7 @@ private static boolean doesComponentMethodMatch(
   }
 
   /** The entry point methods on the component type. */
-  ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
+  final ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
     return componentMethods()
         .stream()
         .filter(method -> method.dependencyRequest().isPresent())
@@ -341,7 +341,7 @@ private static boolean doesComponentMethodMatch(
   }
 
   /** The entry point dependency requests on the component type. */
-  ImmutableSet<DependencyRequest> entryPoints() {
+  final ImmutableSet<DependencyRequest> entryPoints() {
     return entryPointMethods()
         .stream()
         .map(method -> method.dependencyRequest().get())
@@ -356,7 +356,7 @@ private static boolean doesComponentMethodMatch(
    * Returns {@code true} for components that have a builder, either because the user {@linkplain
    * #builderSpec() specified one} or because it's a top-level component.
    */
-  boolean hasBuilder() {
+  final boolean hasBuilder() {
     return kind().isTopLevel() || builderSpec().isPresent();
   }
 
@@ -364,9 +364,9 @@ boolean hasBuilder() {
    * Returns the {@link CancellationPolicy} for this component, or an empty optional if either the
    * component is not a production component or no {@code CancellationPolicy} annotation is present.
    */
-  Optional<CancellationPolicy> cancellationPolicy() {
+  final Optional<CancellationPolicy> cancellationPolicy() {
     return kind().isProducer()
-        ? Optional.ofNullable(componentDefinitionType().getAnnotation(CancellationPolicy.class))
+        ? Optional.ofNullable(typeElement().getAnnotation(CancellationPolicy.class))
         : Optional.empty();
   }
 
@@ -601,7 +601,6 @@ private ComponentDescriptor create(
           componentMirror,
           componentDefinitionType,
           componentDependencies,
-          modules,
           transitiveModules,
           dependenciesByDependencyMethod.build(),
           scopes,
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index 8cc8b7c64..d8ce67961 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -112,7 +112,7 @@
     /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
       ValidationReport.Builder<TypeElement> report =
-          ValidationReport.about(rootComponent.componentDefinitionType());
+          ValidationReport.about(rootComponent.typeElement());
       reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
       return report.build();
     }
@@ -120,9 +120,7 @@
     /** Returns the report builder for a (sub)component. */
     private ValidationReport.Builder<TypeElement> report(ComponentDescriptor component) {
       return reentrantComputeIfAbsent(
-          reports,
-          component,
-          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+          reports, component, descriptor -> ValidationReport.about(descriptor.typeElement()));
     }
 
     void visitComponent(ComponentDescriptor component) {
@@ -130,13 +128,12 @@ void visitComponent(ComponentDescriptor component) {
       validateComponentDependencyHierarchy(component);
       validateModules(component);
       validateBuilders(component);
-      component.subcomponents().forEach(this::visitComponent);
+      component.childComponents().forEach(this::visitComponent);
     }
 
     /** Validates that component dependencies do not form a cycle. */
     private void validateComponentDependencyHierarchy(ComponentDescriptor component) {
-      validateComponentDependencyHierarchy(
-          component, component.componentDefinitionType(), new ArrayDeque<>());
+      validateComponentDependencyHierarchy(component, component.typeElement(), new ArrayDeque<>());
     }
 
     /** Recursive method to validate that component dependencies do not form a cycle. */
@@ -145,7 +142,7 @@ private void validateComponentDependencyHierarchy(
       if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(component.typeElement().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
         dependencyStack.push(dependency);
         appendIndentedComponentsList(message, dependencyStack);
@@ -154,8 +151,8 @@ private void validateComponentDependencyHierarchy(
             .addItem(
                 message.toString(),
                 compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                component.componentDefinitionType(),
-                getComponentAnnotation(component.componentDefinitionType()).get());
+                component.typeElement(),
+                getComponentAnnotation(component.typeElement()).get());
       } else {
         Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
@@ -201,8 +198,8 @@ private void validateDependencyScopes(ComponentDescriptor component) {
                 .addItem(
                     message.toString(),
                     compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                    component.componentDefinitionType(),
-                    component.componentAnnotation());
+                    component.typeElement(),
+                    component.annotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -211,20 +208,17 @@ private void validateDependencyScopes(ComponentDescriptor component) {
             message.append(getReadableSource(scope)).append(' ');
           }
           message
-              .append(component.componentDefinitionType().getQualifiedName())
+              .append(component.typeElement().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           report(component)
-              .addError(
-                  message.toString(),
-                  component.componentDefinitionType(),
-                  component.componentAnnotation());
+              .addError(message.toString(), component.typeElement(), component.annotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateDependencyScopeHierarchy(
                 component,
-                component.componentDefinitionType(),
+                component.typeElement(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
           }
@@ -233,20 +227,17 @@ private void validateDependencyScopes(ComponentDescriptor component) {
         // Scopeless components may not depend on scoped components.
         if (!scopedDependencies.isEmpty()) {
           StringBuilder message =
-              new StringBuilder(component.componentDefinitionType().getQualifiedName())
+              new StringBuilder(component.typeElement().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           report(component)
-              .addError(
-                  message.toString(),
-                  component.componentDefinitionType(),
-                  component.componentAnnotation());
+              .addError(message.toString(), component.typeElement(), component.annotation());
         }
       }
     }
 
     private void validateModules(ComponentDescriptor component) {
-      for (ModuleDescriptor module : component.transitiveModules()) {
+      for (ModuleDescriptor module : component.modules()) {
         if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
           for (ContributionBinding binding : module.bindings()) {
             if (binding.requiresModuleInstance()) {
@@ -283,11 +274,7 @@ private void validateBuilders(ComponentDescriptor component) {
         return;
       }
 
-      Set<ComponentRequirement> availableDependencies = component.availableDependencies();
-      Set<ComponentRequirement> requiredDependencies =
-          Sets.filter(
-              availableDependencies,
-              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
+      Set<ComponentRequirement> requirements = component.dependenciesAndConcreteModules();
       final BuilderSpec spec = componentDesc.builderSpec().get();
       ImmutableSet<BuilderRequirementMethod> declaredSetters =
           spec.requirementMethods()
@@ -301,8 +288,7 @@ private void validateBuilders(ComponentDescriptor component) {
               .collect(toImmutableSet());
 
       ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(component.kind());
-      Set<ComponentRequirement> extraSetters =
-          Sets.difference(declaredRequirements, availableDependencies);
+      Set<ComponentRequirement> extraSetters = Sets.difference(declaredRequirements, requirements);
       if (!extraSetters.isEmpty()) {
         List<ExecutableElement> excessMethods =
             declaredSetters
@@ -321,8 +307,11 @@ private void validateBuilders(ComponentDescriptor component) {
             .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
+      Set<ComponentRequirement> mustBePassed =
+          Sets.filter(
+              requirements, input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
       Set<ComponentRequirement> missingSetters =
-          Sets.difference(requiredDependencies, declaredRequirements);
+          Sets.difference(mustBePassed, declaredRequirements);
       if (!missingSetters.isEmpty()) {
         report(component)
             .addError(
@@ -372,7 +361,7 @@ private void validateDependencyScopeHierarchy(
         scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(component.typeElement().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
@@ -380,8 +369,8 @@ private void validateDependencyScopeHierarchy(
               .addItem(
                   message.toString(),
                   compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                  component.componentDefinitionType(),
-                  getComponentAnnotation(component.componentDefinitionType()).get());
+                  component.typeElement(),
+                  getComponentAnnotation(component.typeElement()).get());
         }
         scopedDependencyStack.pop();
       } else {
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 79c962f1a..dad54b7f7 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -47,7 +47,7 @@
 
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
-    return componentName(input.componentType());
+    return componentName(input.componentTypeElement());
   }
 
   static ClassName componentName(TypeElement componentDefinitionType) {
@@ -57,7 +57,7 @@ static ClassName componentName(TypeElement componentDefinitionType) {
 
   @Override
   Element originatingElement(BindingGraph input) {
-    return input.componentType();
+    return input.componentTypeElement();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 770b2fc83..a502e451f 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -48,13 +48,11 @@
 
   ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
     ValidationReport.Builder<TypeElement> report =
-        ValidationReport.about(componentDescriptor.componentDefinitionType());
+        ValidationReport.about(componentDescriptor.typeElement());
     validateSubcomponentMethods(
         report,
         componentDescriptor,
-        Maps.toMap(
-            componentDescriptor.transitiveModuleTypes(),
-            constant(componentDescriptor.componentDefinitionType())));
+        Maps.toMap(componentDescriptor.moduleTypes(), constant(componentDescriptor.typeElement())));
 
     if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
       validateScopeHierarchy(
@@ -67,33 +65,31 @@ private void validateSubcomponentMethods(
       ValidationReport.Builder<?> report,
       ComponentDescriptor componentDescriptor,
       ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
-    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-        componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
-      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
-      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
+    componentDescriptor
+        .childComponentsDeclaredByFactoryMethods()
+        .forEach(
+            (method, childComponent) -> {
+              if (childComponent.hasBuilder()) {
+                report.addError(
+                    "Components may not have factory methods for subcomponents that define a "
+                        + "builder.",
+                    method.methodElement());
+              } else {
+                validateFactoryMethodParameters(report, method, existingModuleToOwners);
+              }
 
-      if (subcomponentDescriptor.hasBuilder()) {
-        report.addError(
-            "Components may not have factory methods for subcomponents that define a builder.",
-            subcomponentMethodDescriptor.methodElement());
-      } else {
-        validateFactoryMethodParameters(
-            report, subcomponentMethodDescriptor, existingModuleToOwners);
-      }
-
-      validateSubcomponentMethods(
-          report,
-          subcomponentDescriptor,
-          new ImmutableMap.Builder<TypeElement, TypeElement>()
-              .putAll(existingModuleToOwners)
-              .putAll(
-                  Maps.toMap(
-                      Sets.difference(
-                          subcomponentDescriptor.transitiveModuleTypes(),
-                          existingModuleToOwners.keySet()),
-                      constant(subcomponentDescriptor.componentDefinitionType())))
-              .build());
-    }
+              validateSubcomponentMethods(
+                  report,
+                  childComponent,
+                  new ImmutableMap.Builder<TypeElement, TypeElement>()
+                      .putAll(existingModuleToOwners)
+                      .putAll(
+                          Maps.toMap(
+                              Sets.difference(
+                                  childComponent.moduleTypes(), existingModuleToOwners.keySet()),
+                              constant(childComponent.typeElement())))
+                      .build());
+            });
   }
 
   private void validateFactoryMethodParameters(
@@ -126,8 +122,8 @@ private void validateScopeHierarchy(
       SetMultimap<ComponentDescriptor, Scope> scopesByComponent) {
     scopesByComponent.putAll(subject, subject.scopes());
 
-    for (ComponentDescriptor child : subject.subcomponents()) {
-      validateScopeHierarchy(report, child, scopesByComponent);
+    for (ComponentDescriptor childComponent : subject.childComponents()) {
+      validateScopeHierarchy(report, childComponent, scopesByComponent);
     }
 
     scopesByComponent.removeAll(subject);
@@ -142,19 +138,20 @@ private void validateScopeHierarchy(
     if (!overlappingScopes.isEmpty()) {
       StringBuilder error =
           new StringBuilder()
-              .append(subject.componentDefinitionType().getQualifiedName())
+              .append(subject.typeElement().getQualifiedName())
               .append(" has conflicting scopes:");
       for (Map.Entry<ComponentDescriptor, Scope> entry : overlappingScopes.entries()) {
         Scope scope = entry.getValue();
-        error.append("\n  ")
-            .append(entry.getKey().componentDefinitionType().getQualifiedName())
+        error
+            .append("\n  ")
+            .append(entry.getKey().typeElement().getQualifiedName())
             .append(" also has ")
             .append(getReadableSource(scope));
       }
       report.addItem(
           error.toString(),
           compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-          subject.componentDefinitionType());
+          subject.typeElement());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index c8b59d3ac..a5e6df112 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -143,12 +143,12 @@
 
     @Override
     ClassName nameGeneratedType(ComponentDescriptor input) {
-      return componentName(input.componentDefinitionType());
+      return componentName(input.typeElement());
     }
 
     @Override
     Element originatingElement(ComponentDescriptor input) {
-      return input.componentDefinitionType();
+      return input.typeElement();
     }
 
     @Override
@@ -158,7 +158,7 @@ Element originatingElement(ComponentDescriptor input) {
           TypeSpec.classBuilder(generatedTypeName)
               .addModifiers(PUBLIC, FINAL)
               .addMethod(privateConstructor());
-      TypeElement componentElement = componentDescriptor.componentDefinitionType();
+      TypeElement componentElement = componentDescriptor.typeElement();
       addSupertype(generatedComponent, componentElement);
 
       TypeName builderMethodReturnType;
@@ -225,9 +225,7 @@ private MethodSpec privateConstructor() {
     checkArgument(component.kind().isTopLevel());
     return Stream.concat(
         component.dependencies().stream(),
-        component
-            .transitiveModules()
-            .stream()
+        component.modules().stream()
             .filter(module -> !module.moduleElement().getModifiers().contains(ABSTRACT))
             .map(module -> ComponentRequirement.forModule(module.moduleElement().asType())));
   }
@@ -255,7 +253,7 @@ private MethodSpec builderInstanceMethod(
   private MethodSpec builderBuildMethod(ComponentDescriptor component) {
     return MethodSpec.methodBuilder("build")
         .addModifiers(PUBLIC)
-        .returns(ClassName.get(component.componentDefinitionType()))
+        .returns(ClassName.get(component.typeElement()))
         .build();
   }
 
@@ -269,7 +267,7 @@ private MethodSpec staticBuilderMethod(TypeName builderMethodReturnType) {
   private MethodSpec createMethod(ComponentDescriptor componentDescriptor) {
     return MethodSpec.methodBuilder("create")
         .addModifiers(PUBLIC, STATIC)
-        .returns(ClassName.get(componentDescriptor.componentDefinitionType()))
+        .returns(ClassName.get(componentDescriptor.typeElement()))
         .build();
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 5dc1505db..56885c9b8 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -253,10 +253,10 @@ ClassName getBuilderName() {
   /** Returns the name of the nested implementation class for a child component. */
   ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
     checkArgument(
-        componentDescriptor.subcomponents().contains(childDescriptor),
-        "%s is not a child of %s",
-        childDescriptor.componentDefinitionType(),
-        componentDescriptor.componentDefinitionType());
+        componentDescriptor.childComponents().contains(childDescriptor),
+        "%s is not a child component of %s",
+        childDescriptor.typeElement(),
+        componentDescriptor.typeElement());
     return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
   }
 
@@ -267,7 +267,7 @@ String getSubcomponentName(Key key) {
 
   /** Returns the child implementation. */
   Optional<ComponentImplementation> childImplementation(ComponentDescriptor child) {
-    return Optional.ofNullable(childImplementations.get(child.componentDefinitionType()));
+    return Optional.ofNullable(childImplementations.get(child.typeElement()));
   }
 
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
@@ -356,7 +356,7 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
 
   /** Adds the type generated from the given child implementation. */
   void addChild(ComponentDescriptor child, ComponentImplementation childImplementation) {
-    childImplementations.put(child.componentDefinitionType(), childImplementation);
+    childImplementations.put(child.typeElement(), childImplementation);
     addType(TypeSpecKind.SUBCOMPONENT, childImplementation.generate().build());
   }
 
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index a3001aed4..4662feb71 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -104,7 +104,7 @@
    */
   ComponentImplementation createComponentImplementation(BindingGraph bindingGraph) {
     ComponentImplementation componentImplementation =
-        topLevelImplementation(componentName(bindingGraph.componentType()), bindingGraph);
+        topLevelImplementation(componentName(bindingGraph.componentTypeElement()), bindingGraph);
     OptionalFactories optionalFactories = new OptionalFactories(componentImplementation);
     Optional<ComponentBuilderImplementation> componentBuilderImplementation =
         ComponentBuilderImplementation.create(
@@ -126,7 +126,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
           compilerOptions.aheadOfTimeSubcomponents(),
           "Calling 'componentImplementation()' on %s when not generating ahead-of-time "
               + "subcomponents.",
-          bindingGraph.componentDescriptor().componentDefinitionType());
+          bindingGraph.componentDescriptor().typeElement());
       return new SubcomponentImplementationBuilder(
               Optional.empty(), /* parent */
               bindingGraph,
@@ -199,8 +199,7 @@ final ComponentImplementation build() {
           .map(ComponentBuilderImplementation::componentBuilderClass)
           .ifPresent(this::addBuilderClass);
 
-      getLocalAndInheritedMethods(
-              graph.componentDescriptor().componentDefinitionType(), types, elements)
+      getLocalAndInheritedMethods(graph.componentDescriptor().typeElement(), types, elements)
           .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
 
       addFactoryMethods();
@@ -222,7 +221,7 @@ final void setSupertype() {
         componentImplementation.addSuperclass(
             componentImplementation.superclassImplementation().get().name());
       } else {
-        componentImplementation.addSupertype(graph.componentType());
+        componentImplementation.addSupertype(graph.componentTypeElement());
       }
     }
 
@@ -342,7 +341,7 @@ void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
 
     final MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
       return MethodSignature.forComponentMethod(
-          method, MoreTypes.asDeclared(graph.componentType().asType()), types);
+          method, MoreTypes.asDeclared(graph.componentTypeElement().asType()), types);
     }
 
     final void addChildComponents() {
@@ -366,7 +365,7 @@ final ComponentImplementation getChildSuperclassImplementation(ComponentDescript
             childSuperclassImplementation.isPresent(),
             "Cannot find abstract implementation of %s within %s while generating implemention "
                 + "within %s",
-            child.componentDefinitionType(),
+            child.typeElement(),
             superclassImplementation.name(),
             componentImplementation.name());
         return childSuperclassImplementation.get();
@@ -543,7 +542,7 @@ void addFactoryMethods() {
         componentImplementation.addMethod(
             BUILDER_METHOD,
             methodBuilder("create")
-                .returns(ClassName.get(super.graph.componentType()))
+                .returns(ClassName.get(super.graph.componentTypeElement()))
                 .addModifiers(PUBLIC, STATIC)
                 .addStatement("return new Builder().$L()", buildMethodName)
                 .build());
@@ -627,7 +626,7 @@ void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
     }
 
     DeclaredType parentType() {
-      return asDeclared(parent.get().graph.componentType().asType());
+      return asDeclared(parent.get().graph.componentTypeElement().asType());
     }
 
     @Override
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index f781a8986..0f6c0be78 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -56,8 +56,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   private ComponentRequirement componentRequirement() {
     return bindingGraph
         .componentDescriptor()
-        .dependenciesByDependencyMethod()
-        .get(binding.bindingElement().get());
+        .getDependencyThatDefinesMethod(binding.bindingElement().get());
   }
 
   static CodeBlock maybeCheckForNull(
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 8dbd1e72f..bfc79a5ca 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -38,7 +38,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.LinkedHashMultiset;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -80,7 +79,7 @@ public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOp
         rootGraph.componentDescriptor().kind().isTopLevel()
             || compilerOptions.aheadOfTimeSubcomponents(),
         "only top-level graphs can be traversed, not %s",
-        rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
+        rootGraph.componentDescriptor().typeElement().getQualifiedName());
     bindingGraphPath.add(rootGraph);
   }
 
@@ -117,15 +116,13 @@ public final void traverseComponents() {
   protected void visitComponent(BindingGraph graph) {
     if (bindingGraphPath.size() > 1) {
       BindingGraph parent = Iterators.get(bindingGraphPath.descendingIterator(), 1);
-      ComponentMethodDescriptor childFactoryMethod =
-          parent
-              .componentDescriptor()
-              .subcomponentsByFactoryMethod()
-              .inverse()
-              .get(graph.componentDescriptor());
-      if (childFactoryMethod != null) {
-        visitSubcomponentFactoryMethod(graph, parent, childFactoryMethod.methodElement());
-      }
+      parent
+          .componentDescriptor()
+          .getFactoryMethodForChildComponent(graph.componentDescriptor())
+          .ifPresent(
+              childFactoryMethod ->
+                  visitSubcomponentFactoryMethod(
+                      graph, parent, childFactoryMethod.methodElement()));
     }
 
     for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
@@ -572,7 +569,7 @@ public BindingGraph currentGraph() {
 
     /** Returns the type of the component at the end of the path. */
     public TypeElement currentComponent() {
-      return currentGraph().componentDescriptor().componentDefinitionType();
+      return currentGraph().componentDescriptor().typeElement();
     }
 
     /**
@@ -619,7 +616,7 @@ ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
       ImmutableList.Builder<BindingGraph> path = ImmutableList.builder();
       for (BindingGraph graph : graphsInPath()) {
         path.add(graph);
-        if (graph.componentDescriptor().componentDefinitionType().equals(ancestor)) {
+        if (graph.componentDescriptor().typeElement().equals(ancestor)) {
           return create(path.build());
         }
       }
@@ -636,7 +633,7 @@ ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
      */
     ComponentTreePath childPath(TypeElement subcomponent) {
       for (BindingGraph child : currentGraph().subgraphs()) {
-        if (child.componentType().equals(subcomponent)) {
+        if (child.componentTypeElement().equals(subcomponent)) {
           return create(
               ImmutableList.<BindingGraph>builder().addAll(graphsInPath()).add(child).build());
         }
@@ -644,7 +641,8 @@ ComponentTreePath childPath(TypeElement subcomponent) {
       throw new IllegalArgumentException(
           String.format(
               "%s is not a child of %s",
-              subcomponent.getQualifiedName(), currentGraph().componentType().getQualifiedName()));
+              subcomponent.getQualifiedName(),
+              currentGraph().componentTypeElement().getQualifiedName()));
     }
 
     private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
@@ -654,14 +652,13 @@ private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
     /** Converts this {@link ComponentTreePath} into a {@link ComponentPath}. */
     ComponentPath toComponentPath() {
       return ComponentPath.create(
-          graphsInPath().stream().map(BindingGraph::componentType).collect(toList()));
+          graphsInPath().stream().map(BindingGraph::componentTypeElement).collect(toList()));
     }
 
     @Override
     public final String toString() {
-      return graphsInPath()
-          .stream()
-          .map(BindingGraph::componentType)
+      return graphsInPath().stream()
+          .map(BindingGraph::componentTypeElement)
           .map(TypeElement::getQualifiedName)
           .collect(joining("  "));
     }
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index d939bc595..48b31651c 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -166,7 +166,7 @@ static boolean isSubcomponentBuilder(Element element) {
    * given seed modules. If a module is malformed and a type listed in {@link Module#includes} is
    * not annotated with {@link Module}, it is ignored.
    *
-   * @deprecated Use {@link ComponentDescriptor#transitiveModules}.
+   * @deprecated Use {@link ComponentDescriptor#modules()}.
    */
   @Deprecated
   static ImmutableSet<TypeElement> getTransitiveModules(
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index 349536e97..2aff3ef78 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -149,12 +149,12 @@ private void addDependencyEdge(
   }
 
   private void addModuleEdges(BindingGraph graph) {
-    Optional<VName> componentNode = jvmNode(graph.componentType());
+    Optional<VName> componentNode = jvmNode(graph.componentTypeElement());
     if (!componentNode.isPresent()) {
-      logger.warning("Missing JVM node for component: " + graph.componentType());
+      logger.warning("Missing JVM node for component: " + graph.componentTypeElement());
       return;
     }
-    for (ModuleDescriptor module : graph.componentDescriptor().transitiveModules()) {
+    for (ModuleDescriptor module : graph.componentDescriptor().modules()) {
       Optional<VName> moduleNode = jvmNode(module.moduleElement());
       if (moduleNode.isPresent()) {
         emitEdge(componentNode.get(), "/inject/installsmodule", moduleNode.get());
@@ -165,17 +165,17 @@ private void addModuleEdges(BindingGraph graph) {
   }
 
   private void addChildComponentEdges(BindingGraph graph) {
-    Optional<VName> componentNode = jvmNode(graph.componentType());
+    Optional<VName> componentNode = jvmNode(graph.componentTypeElement());
     if (!componentNode.isPresent()) {
-      logger.warning("Missing JVM node for component: " + graph.componentType());
+      logger.warning("Missing JVM node for component: " + graph.componentTypeElement());
       return;
     }
     for (BindingGraph subgraph : graph.subgraphs()) {
-      Optional<VName> subcomponentNode = jvmNode(subgraph.componentType());
+      Optional<VName> subcomponentNode = jvmNode(subgraph.componentTypeElement());
       if (subcomponentNode.isPresent()) {
         emitEdge(componentNode.get(), "/inject/childcomponent", subcomponentNode.get());
       } else {
-        logger.warning("Missing JVM node for subcomponent: " + subgraph.componentType());
+        logger.warning("Missing JVM node for subcomponent: " + subgraph.componentTypeElement());
       }
     }
   }
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index ca1aadfdf..acfdb99fc 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -58,10 +58,7 @@
   @Override
   public CodeBlock creationExpression() {
     ComponentRequirement dependency =
-        graph
-            .componentDescriptor()
-            .dependenciesByDependencyMethod()
-            .get(binding.bindingElement().get());
+        graph.componentDescriptor().getDependencyThatDefinesMethod(binding.bindingElement().get());
     FieldSpec dependencyField =
         FieldSpec.builder(
                 ClassName.get(dependency.typeElement()), dependency.variableName(), PRIVATE, FINAL)
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index 81fd28bda..128e28663 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -117,7 +117,7 @@ private ClassName factoryClassName() {
   }
 
   private ComponentRequirement dependency() {
-    return graph.componentDescriptor().dependenciesByDependencyMethod().get(provisionMethod());
+    return graph.componentDescriptor().getDependencyThatDefinesMethod(provisionMethod());
   }
 
   private Element provisionMethod() {
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 02b7abeaf..30d11e034 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -179,7 +179,7 @@ private BindingExpression createModifiableBindingExpression(
     Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
         componentImplementation.getModifiableBindingMethod(request);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
-        graph.componentDescriptor().findMatchingComponentMethod(request);
+        graph.componentDescriptor().firstMatchingComponentMethod(request);
     switch (type) {
       case GENERATED_INSTANCE:
         // If the subcomponent is abstract then we need to define an (un-implemented)
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 7c05bc159..306b0b84f 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -106,7 +106,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private SetView<TypeElement> ownedModules(ComponentNode component, BindingGraph graph) {
     return Sets.difference(
-        ((ComponentNodeImpl) component).componentDescriptor().transitiveModuleTypes(),
+        ((ComponentNodeImpl) component).componentDescriptor().moduleTypes(),
         inheritedModules(component, graph));
   }
 
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index c059ee3e1..756424f7b 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -62,8 +62,7 @@ String get(Key key) {
     ImmutableListMultimap<String, ComponentDescriptor> componentDescriptorsBySimpleName =
         Multimaps.index(
             graph.componentDescriptors(),
-            componentDescriptor ->
-                componentDescriptor.componentDefinitionType().getSimpleName().toString());
+            componentDescriptor -> componentDescriptor.typeElement().getSimpleName().toString());
     ImmutableMap<ComponentDescriptor, Namer> componentNamers =
         qualifiedNames(graph.componentDescriptors());
     Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
@@ -125,7 +124,7 @@ String get(Key key) {
       Iterable<ComponentDescriptor> componentDescriptors) {
     ImmutableMap.Builder<ComponentDescriptor, Namer> builder = ImmutableMap.builder();
     for (ComponentDescriptor component : componentDescriptors) {
-      builder.put(component, new Namer(component.componentDefinitionType()));
+      builder.put(component, new Namer(component.typeElement()));
     }
     return builder.build();
   }
