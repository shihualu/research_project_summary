diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e9a41d6c2..5fda5c029 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -158,7 +158,6 @@ java_library(
         "DependencyRequestFormatter.java",
         "DependencyVariableNamer.java",  # Used by SourceFiles
         "ErrorMessages.java",  # Consider splitting this up as it pulls in too much
-        "FrameworkDependency.java",
         "FrameworkField.java",  # Used by SourceFiles
         "FrameworkType.java",
         "FrameworkTypeMapper.java",
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index c0f6b71e3..9502fadc7 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -17,29 +17,19 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Suppliers.memoize;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.Scope;
-import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -98,7 +88,6 @@ final FrameworkType frameworkType() {
    * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
    * user-defined injection site. This returns an unmodifiable set.
    */
-  // TODO(gak): this will eventually get changed to return a set of FrameworkDependency
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return ImmutableSet.of();
   }
@@ -122,144 +111,6 @@ final FrameworkType frameworkType() {
     return dependencies.get();
   }
 
-  private final Supplier<ImmutableList<FrameworkDependency>> frameworkDependencies =
-      memoize(
-          () ->
-              dependencyAssociations()
-                  .stream()
-                  .map(DependencyAssociation::frameworkDependency)
-                  .collect(toImmutableList()));
-
-  /**
-   * The framework dependencies of {@code binding}. There will be one element for each different
-   * binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of {@code
-   * binding}.
-   *
-   * <p>For example, given the following modules:
-   *
-   * <pre><code>
-   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
-   *     {@literal @Provides} Foo provideFoo(T t, String string) {
-   *       return …;
-   *     }
-   *   }
-   *
-   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
-   * </code></pre>
-   *
-   * Both dependencies of {@code StringModule.provideFoo} have the same binding key: {@code String}.
-   * But there are still two dependencies, because in the unresolved binding they have different
-   * binding keys:
-   *
-   * <dl>
-   *   <dt>{@code T}
-   *   <dd>{@code String t}
-   *   <dt>{@code String}
-   *   <dd>{@code String string}
-   * </dl>
-   *
-   * <p>Note that the sets returned by this method when called on the same binding will be equal,
-   * and their elements will be in the same order.
-   */
-  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
-   * instances of Binding, because it really depends on the order of the binding's dependencies,
-   * and two equal instances of Binding may have the same dependencies in a different order. */
-  final ImmutableList<FrameworkDependency> frameworkDependencies() {
-    return frameworkDependencies.get();
-  }
-
-  /**
-   * Associates a {@link FrameworkDependency} with the set of {@link DependencyRequest} instances
-   * that correlate for a binding.
-   */
-  @AutoValue
-  abstract static class DependencyAssociation {
-    abstract FrameworkDependency frameworkDependency();
-
-    abstract ImmutableSet<DependencyRequest> dependencyRequests();
-
-    static DependencyAssociation create(
-        FrameworkDependency frameworkDependency, Iterable<DependencyRequest> dependencyRequests) {
-      return new AutoValue_Binding_DependencyAssociation(
-          frameworkDependency, ImmutableSet.copyOf(dependencyRequests));
-    }
-  }
-
-  private final Supplier<ImmutableList<DependencyAssociation>> dependencyAssociations =
-      memoize(
-          () -> {
-            FrameworkTypeMapper frameworkTypeMapper =
-                FrameworkTypeMapper.forBindingType(bindingType());
-            ImmutableList.Builder<DependencyAssociation> list = ImmutableList.builder();
-            for (Set<DependencyRequest> requests : groupByUnresolvedKey()) {
-              list.add(
-                  DependencyAssociation.create(
-                      FrameworkDependency.create(
-                          getOnlyElement(
-                              requests.stream().map(DependencyRequest::key).collect(toSet())),
-                          frameworkTypeMapper.getFrameworkType(requests)),
-                      requests));
-            }
-            return list.build();
-          });
-
-  /**
-   * Returns the same {@link FrameworkDependency} instances from {@link #frameworkDependencies}, but
-   * with the set of {@link DependencyRequest} instances with which each is associated.
-   *
-   * <p>Ths method returns a list of {@link Map.Entry entries} rather than a {@link Map} or {@link
-   * com.google.common.collect.Multimap} because any given {@link FrameworkDependency} may appear
-   * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
-   * distinction is not important, the entries can be merged into a single mapping.
-   */
-  final ImmutableList<DependencyAssociation> dependencyAssociations() {
-    return dependencyAssociations.get();
-  }
-
-  private final Supplier<ImmutableMap<DependencyRequest, FrameworkDependency>>
-      frameworkDependenciesMap =
-          memoize(
-              () -> {
-                ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencies =
-                    ImmutableMap.builder();
-                for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
-                  for (DependencyRequest dependencyRequest :
-                      dependencyAssociation.dependencyRequests()) {
-                    frameworkDependencies.put(
-                        dependencyRequest, dependencyAssociation.frameworkDependency());
-                  }
-                }
-                return frameworkDependencies.build();
-              });
-
-  /**
-   * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
-   * FrameworkDependency}.
-   */
-  final ImmutableMap<DependencyRequest, FrameworkDependency>
-      dependenciesToFrameworkDependenciesMap() {
-    return frameworkDependenciesMap.get();
-  }
-
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   */
-  private ImmutableList<Set<DependencyRequest>> groupByUnresolvedKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    Iterator<DependencyRequest> dependencies = dependencies().iterator();
-    Binding unresolved = unresolved().isPresent() ? unresolved().get() : this;
-    Iterator<DependencyRequest> unresolvedDependencies = unresolved.dependencies().iterator();
-    while (dependencies.hasNext()) {
-      dependenciesByKeyBuilder.put(unresolvedDependencies.next().key(), dependencies.next());
-    }
-    return ImmutableList.copyOf(
-        Multimaps.asMap(
-                dependenciesByKeyBuilder.orderValuesBy(SourceFiles.DEPENDENCY_ORDERING).build())
-            .values());
-  }
-
   /**
    * If this binding's key's type parameters are different from those of the
    * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index 0f49f005c..2c1535557 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -64,11 +64,6 @@ static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
         key, frameworkType.requestKind(), Optional.of(frameworkType));
   }
 
-  /** Creates a {@link BindingRequest} for the given {@link FrameworkDependency}. */
-  static BindingRequest bindingRequest(FrameworkDependency frameworkDependency) {
-    return bindingRequest(frameworkDependency.key(), frameworkDependency.frameworkType());
-  }
-
   /** Returns the {@link Key} for the requested binding. */
   abstract Key key();
 
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index ef1c4c841..84daadb1e 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -142,8 +142,8 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
               componentImplementation.name()));
     }
 
-    binding.frameworkDependencies().stream()
-        .map(BindingRequest::bindingRequest)
+    binding.dependencies().stream()
+        .map(dependency -> frameworkRequest(binding, dependency))
         .map(request -> getDependencyExpression(request, componentImplementation.name()))
         .map(Expression::codeBlock)
         .forEach(arguments::add);
@@ -151,6 +151,15 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
     return arguments.build();
   }
 
+  private static BindingRequest frameworkRequest(
+      ContributionBinding binding, DependencyRequest dependency) {
+    // TODO(user): See if we can get rid of FrameworkTypeMatcher
+    FrameworkType frameworkType =
+        FrameworkTypeMapper.forBindingType(binding.bindingType())
+            .getFrameworkType(dependency.kind());
+    return BindingRequest.bindingRequest(dependency.key(), frameworkType);
+  }
+
   /**
    * Returns an expression that evaluates to the value of a dependency request, for passing to a
    * binding method, an {@code @Inject}-annotated constructor or member, or a proxy for one.
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 543540a9f..5d53c1f85 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -60,7 +60,7 @@
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollector;
-import dagger.model.Key;
+import dagger.model.DependencyRequest;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
@@ -69,8 +69,8 @@
 import javax.lang.model.element.Element;
 
 /**
- * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
- * {@link Inject} constructors.
+ * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for {@link
+ * Inject} constructors.
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final DaggerTypes types;
@@ -170,7 +170,7 @@ private void addConstructorAndFields(ProvisionBinding binding, TypeSpec.Builder
     return Optional.empty();
   }
 
-  private ImmutableMap<Key, FieldSpec> frameworkFields(ProvisionBinding binding) {
+  private ImmutableMap<DependencyRequest, FieldSpec> frameworkFields(ProvisionBinding binding) {
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     // TODO(user, dpb): Add a test for the case when a Factory parameter is named "module".
     if (binding.requiresModuleInstance()) {
@@ -232,7 +232,7 @@ private MethodSpec getMethod(ProvisionBinding binding) {
             .addModifiers(PUBLIC)
             .returns(providedTypeName);
 
-    ImmutableMap<Key, FieldSpec> frameworkFields = frameworkFields(binding);
+    ImmutableMap<DependencyRequest, FieldSpec> frameworkFields = frameworkFields(binding);
     CodeBlock parametersCodeBlock =
         makeParametersCodeBlock(
             frameworkFieldUsages(binding.provisionDependencies(), frameworkFields).values());
@@ -247,7 +247,7 @@ private MethodSpec getMethod(ProvisionBinding binding) {
               binding,
               request ->
                   frameworkTypeUsageStatement(
-                      CodeBlock.of("$N", frameworkFields.get(request.key())), request.kind()),
+                      CodeBlock.of("$N", frameworkFields.get(request)), request.kind()),
               nameGeneratedType(binding),
               binding.requiresModuleInstance()
                   ? Optional.of(CodeBlock.of("module"))
diff --git a/java/dagger/internal/codegen/FrameworkDependency.java b/java/dagger/internal/codegen/FrameworkDependency.java
deleted file mode 100644
index feea7a0a6..000000000
--- a/java/dagger/internal/codegen/FrameworkDependency.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import dagger.model.Key;
-
-/**
- * The framework class and binding key for a resolved dependency of a binding. If a binding has
- * several dependencies for a key, then only one instance of this class will represent them all.
- *
- * <p>In the following example, the binding {@code provideFoo()} has two dependency requests:
- *
- * <ol>
- *   <li>{@code Bar bar}
- *   <li>{@code Provider<Bar> barProvider}
- * </ol>
- *
- * But they both can be satisfied with the same instance of {@code Provider<Bar>}. So one instance
- * of {@code FrameworkDependency} will be used for both. Its {@link #key()} will be for {@code Bar},
- * and its {@link #frameworkType()} will be {@link FrameworkType#PROVIDER}.
- *
- * <pre><code>
- *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider<Bar>} barProvider) {
- *     return new Foo(…);
- *   }
- * </code></pre>
- */
-@AutoValue
-abstract class FrameworkDependency {
-
-  /** The fully-resolved key shared by all the dependency requests. */
-  abstract Key key();
-
-  /** The type of the framework dependency. */
-  abstract FrameworkType frameworkType();
-
-  /** The framework class to use for this dependency. */
-  final Class<?> frameworkClass() {
-    return frameworkType().frameworkClass();
-  }
-
-  /** Returns a new instance with the given key and type. */
-  static FrameworkDependency create(Key key, FrameworkType frameworkType) {
-    return new AutoValue_FrameworkDependency(key, frameworkType);
-  }
-}
diff --git a/java/dagger/internal/codegen/FrameworkTypeMapper.java b/java/dagger/internal/codegen/FrameworkTypeMapper.java
index 774669253..04915350b 100644
--- a/java/dagger/internal/codegen/FrameworkTypeMapper.java
+++ b/java/dagger/internal/codegen/FrameworkTypeMapper.java
@@ -16,15 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static java.util.stream.Collectors.toSet;
 
-import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
-import java.util.Set;
 import javax.inject.Provider;
 
 /**
@@ -72,14 +67,4 @@ static FrameworkTypeMapper forBindingType(BindingType bindingType) {
   }
 
   abstract FrameworkType getFrameworkType(RequestKind requestKind);
-
-  /**
-   * Returns the {@link FrameworkType} to use for a collection of requests of the same {@link Key}.
-   * This allows factories to only take a single argument for multiple requests of the same key.
-   */
-  FrameworkType getFrameworkType(Set<DependencyRequest> requests) {
-    Set<FrameworkType> frameworkTypes =
-        requests.stream().map(request -> getFrameworkType(request.kind())).collect(toSet());
-    return frameworkTypes.size() == 1 ? getOnlyElement(frameworkTypes) : FrameworkType.PROVIDER;
-  }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectorGenerator.java b/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 952e1c74a..6b677b6b0 100644
--- a/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -53,7 +53,7 @@
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollector;
-import dagger.model.Key;
+import dagger.model.DependencyRequest;
 import java.util.Map.Entry;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
@@ -123,9 +123,11 @@ Element originatingElement(MembersInjectionBinding binding) {
             .addAnnotation(Override.class)
             .addParameter(injectedTypeName, "instance");
 
-    ImmutableMap<Key, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
+    ImmutableMap<DependencyRequest, FrameworkField> fields =
+        generateBindingFieldsForDependencies(binding);
 
-    ImmutableMap.Builder<Key, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
+    ImmutableMap.Builder<DependencyRequest, FieldSpec> dependencyFieldsBuilder =
+        ImmutableMap.builder();
 
     MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
 
@@ -144,14 +146,14 @@ Element originatingElement(MembersInjectionBinding binding) {
 
     boolean usesRawFrameworkTypes = false;
     UniqueNameSet fieldNames = new UniqueNameSet();
-    for (Entry<Key, FrameworkField> fieldEntry : fields.entrySet()) {
-      Key dependencyKey = fieldEntry.getKey();
+    for (Entry<DependencyRequest, FrameworkField> fieldEntry : fields.entrySet()) {
+      DependencyRequest dependency = fieldEntry.getKey();
       FrameworkField bindingField = fieldEntry.getValue();
 
       // If the dependency type is not visible to this members injector, then use the raw framework
       // type for the field.
       boolean useRawFrameworkType =
-          !isTypeAccessibleFrom(dependencyKey.type(), generatedTypeName.packageName());
+          !isTypeAccessibleFrom(dependency.key().type(), generatedTypeName.packageName());
 
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType = useRawFrameworkType ? bindingField.type().rawType : bindingField.type();
@@ -172,7 +174,7 @@ Element originatingElement(MembersInjectionBinding binding) {
       FieldSpec field = fieldBuilder.build();
       injectorTypeBuilder.addField(field);
       constructorBuilder.addStatement("this.$1N = $1N", field);
-      dependencyFieldsBuilder.put(dependencyKey, field);
+      dependencyFieldsBuilder.put(dependency, field);
       constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
 
@@ -183,7 +185,7 @@ Element originatingElement(MembersInjectionBinding binding) {
     injectorTypeBuilder.addMethod(constructorBuilder.build());
     injectorTypeBuilder.addMethod(createMethodBuilder.build());
 
-    ImmutableMap<Key, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<DependencyRequest, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
 
     injectMembersBuilder.addCode(
         InjectionSiteMethod.invokeAll(
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 2e55ad9f1..20c714e7b 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -68,7 +68,9 @@
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducesMethodProducer;
 import dagger.producers.internal.Producers;
-import java.util.Map;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map.Entry;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
@@ -76,9 +78,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
- */
+/** Generates {@link Producer} implementations from {@link ProductionBinding} instances. */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
   private final CompilerOptions compilerOptions;
   private final KeyFactory keyFactory;
@@ -121,7 +121,7 @@ Element originatingElement(ProductionBinding binding) {
             .addTypeVariables(bindingTypeElementTypeVariableNames(binding));
 
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
-    ImmutableMap.Builder<Key, FieldSpec> fieldsBuilder = ImmutableMap.builder();
+    ImmutableMap.Builder<DependencyRequest, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
     MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PRIVATE);
 
@@ -135,53 +135,52 @@ Element originatingElement(ProductionBinding binding) {
                     TypeName.get(binding.bindingTypeElement().get().asType())))
             : Optional.empty();
 
-    String[] executorParameterName = new String[1];
-    String[] monitorParameterName = new String[1];
-    Map<Key, FrameworkField> bindingFieldsForDependencies =
+    List<CodeBlock> frameworkFieldAssignments = new ArrayList<>();
+
+    String executorParameterName = null;
+    String monitorParameterName = null;
+    ImmutableMap<DependencyRequest, FrameworkField> bindingFieldsForDependencies =
         generateBindingFieldsForDependencies(binding);
-    bindingFieldsForDependencies.forEach(
-        (key, bindingField) -> {
-          String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
-          if (key.equals(keyFactory.forProductionImplementationExecutor())) {
-            executorParameterName[0] = fieldName;
-            constructorBuilder.addParameter(bindingField.type(), executorParameterName[0]);
-          } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
-            monitorParameterName[0] = fieldName;
-            constructorBuilder.addParameter(bindingField.type(), monitorParameterName[0]);
-          } else {
-            FieldSpec field =
-                addFieldAndConstructorParameter(
-                    factoryBuilder, constructorBuilder, fieldName, bindingField.type());
-            fieldsBuilder.put(key, field);
-          }
-        });
-    ImmutableMap<Key, FieldSpec> fields = fieldsBuilder.build();
+    for (Entry<DependencyRequest, FrameworkField> entry : bindingFieldsForDependencies.entrySet()) {
+      DependencyRequest dependency = entry.getKey();
+      Key key = dependency.key();
+      FrameworkField bindingField = entry.getValue();
+      String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
+      if (key.equals(keyFactory.forProductionImplementationExecutor())) {
+        executorParameterName = fieldName;
+        constructorBuilder.addParameter(bindingField.type(), executorParameterName);
+      } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
+        monitorParameterName = fieldName;
+        constructorBuilder.addParameter(bindingField.type(), monitorParameterName);
+      } else {
+        FieldSpec field =
+            addFieldAndConstructorParameter(
+                factoryBuilder, constructorBuilder, fieldName, bindingField.type());
+        fieldsBuilder.put(dependency, field);
+        frameworkFieldAssignments.add(fieldAssignment(field, bindingField.type()));
+      }
+    }
+    ImmutableMap<DependencyRequest, FieldSpec> fields = fieldsBuilder.build();
 
     constructorBuilder.addStatement(
         "super($N, $L, $N)",
-        verifyNotNull(monitorParameterName[0]),
+        verifyNotNull(monitorParameterName),
         producerTokenConstruction(generatedTypeName, binding),
-        verifyNotNull(executorParameterName[0]));
+        verifyNotNull(executorParameterName));
 
     if (binding.requiresModuleInstance()) {
       assignField(constructorBuilder, moduleField.get(), null);
     }
 
-    fields.forEach(
-        (key, field) -> {
-          ParameterizedTypeName type = bindingFieldsForDependencies.get(key).type();
-          assignField(constructorBuilder, field, type);
-        });
+    constructorBuilder.addCode(CodeBlock.join(frameworkFieldAssignments, "\n"));
 
     MethodSpec.Builder collectDependenciesBuilder =
-        methodBuilder("collectDependencies")
-            .addAnnotation(Override.class)
-            .addModifiers(PROTECTED);
+        methodBuilder("collectDependencies").addAnnotation(Override.class).addModifiers(PROTECTED);
 
     ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
-      CodeBlock futureAccess = CodeBlock.of("$N.get()", fields.get(dependency.key()));
+      CodeBlock futureAccess = CodeBlock.of("$N.get()", fields.get(dependency));
       collectDependenciesBuilder.addStatement(
           "$T $L = $L",
           futureType,
@@ -255,6 +254,17 @@ private static FieldSpec addFieldAndConstructorParameter(
     return field;
   }
 
+  private static CodeBlock fieldAssignment(FieldSpec field, ParameterizedTypeName type) {
+    CodeBlock.Builder statement = CodeBlock.builder();
+    if (type != null && type.rawType.equals(TypeNames.PRODUCER)) {
+      statement.addStatement(
+          "this.$1N = $2T.nonCancellationPropagatingViewOf($1N)", field, Producers.class);
+    } else {
+      statement.addStatement("this.$1N = $1N", field);
+    }
+    return statement.build();
+  }
+
   private static void assignField(
       MethodSpec.Builder constructorBuilder, FieldSpec field, ParameterizedTypeName type) {
     if (type != null && type.rawType.equals(TypeNames.PRODUCER)) {
@@ -267,17 +277,9 @@ private static void assignField(
 
   /** Returns a list of dependencies that are generated asynchronously. */
   private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
-    final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
-        binding.dependenciesToFrameworkDependenciesMap();
-    return FluentIterable.from(binding.dependencies())
-        .filter(
-            dependency ->
-                isAsyncDependency(dependency)
-                    && frameworkDependencies
-                        .get(dependency)
-                        .frameworkClass()
-                        .equals(Producer.class))
-        .toList();
+    return binding.dependencies().stream()
+        .filter(ProducerFactoryGenerator::isAsyncDependency)
+        .collect(toImmutableList());
   }
 
   private CodeBlock producerTokenConstruction(
@@ -301,10 +303,10 @@ private static String dependencyFutureName(DependencyRequest dependency) {
 
   /** Represents the transformation of an input future by a producer method. */
   abstract static class FutureTransform {
-    protected final ImmutableMap<Key, FieldSpec> fields;
+    protected final ImmutableMap<DependencyRequest, FieldSpec> fields;
     protected final ProductionBinding binding;
 
-    FutureTransform(ImmutableMap<Key, FieldSpec> fields, ProductionBinding binding) {
+    FutureTransform(ImmutableMap<DependencyRequest, FieldSpec> fields, ProductionBinding binding) {
       this.fields = fields;
       this.binding = binding;
     }
@@ -328,11 +330,11 @@ boolean hasUncheckedCast() {
 
     CodeBlock frameworkTypeUsageStatement(DependencyRequest dependency) {
       return SourceFiles.frameworkTypeUsageStatement(
-          CodeBlock.of("$N", fields.get(dependency.key())), dependency.kind());
+          CodeBlock.of("$N", fields.get(dependency)), dependency.kind());
     }
 
     static FutureTransform create(
-        ImmutableMap<Key, FieldSpec> fields,
+        ImmutableMap<DependencyRequest, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       if (asyncDependencies.isEmpty()) {
@@ -347,7 +349,8 @@ static FutureTransform create(
   }
 
   static final class NoArgFutureTransform extends FutureTransform {
-    NoArgFutureTransform(ImmutableMap<Key, FieldSpec> fields, ProductionBinding binding) {
+    NoArgFutureTransform(
+        ImmutableMap<DependencyRequest, FieldSpec> fields, ProductionBinding binding) {
       super(fields, binding);
     }
 
@@ -378,7 +381,7 @@ String applyArgName() {
     private final DependencyRequest asyncDependency;
 
     SingleArgFutureTransform(
-        ImmutableMap<Key, FieldSpec> fields,
+        ImmutableMap<DependencyRequest, FieldSpec> fields,
         ProductionBinding binding,
         DependencyRequest asyncDependency) {
       super(fields, binding);
@@ -424,7 +427,7 @@ String applyArgName() {
     private final ImmutableList<DependencyRequest> asyncDependencies;
 
     MultiArgFutureTransform(
-        ImmutableMap<Key, FieldSpec> fields,
+        ImmutableMap<DependencyRequest, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       super(fields, binding);
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index fd93d0d37..0c6321d6f 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -22,8 +22,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.javapoet.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.javapoet.TypeNames.MAP_FACTORY;
 import static dagger.internal.codegen.javapoet.TypeNames.MAP_OF_PRODUCED_PRODUCER;
@@ -37,11 +35,9 @@
 import static dagger.model.BindingKind.INJECTION;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static dagger.model.BindingKind.MULTIBOUND_SET;
-import static java.util.Comparator.comparing;
 import static javax.lang.model.SourceVersion.isName;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -56,47 +52,24 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.SetFactory;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
-import java.util.Comparator;
-import java.util.Iterator;
 import java.util.List;
 import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 
-/**
- * Utilities for generating files.
- */
+/** Utilities for generating files. */
 class SourceFiles {
 
   private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('_');
 
-  /**
-   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
-   * importance.
-   */
-  static final Comparator<DependencyRequest> DEPENDENCY_ORDERING =
-      // put fields before parameters
-      comparing(
-              (DependencyRequest request) -> request.requestElement().map(Element::getKind),
-              optionalComparator())
-          // order by dependency kind
-          .thenComparing(DependencyRequest::kind)
-          // then sort by name
-          .thenComparing(
-              request ->
-                  request.requestElement().map(element -> element.getSimpleName().toString()),
-              optionalComparator());
-
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
    * all of the dependencies of {@code binding}. It is responsible for choosing a name that
@@ -109,44 +82,21 @@
    *
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
-  static ImmutableMap<Key, FrameworkField> generateBindingFieldsForDependencies(
+  static ImmutableMap<DependencyRequest, FrameworkField> generateBindingFieldsForDependencies(
       Binding binding) {
     checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
 
-    ImmutableMap.Builder<Key, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (Binding.DependencyAssociation dependencyAssociation : binding.dependencyAssociations()) {
-      FrameworkDependency frameworkDependency = dependencyAssociation.frameworkDependency();
-      bindingFields.put(
-          frameworkDependency.key(),
-          FrameworkField.create(
-              ClassName.get(frameworkDependency.frameworkClass()),
-              TypeName.get(frameworkDependency.key().type()),
-              fieldNameForDependency(dependencyAssociation.dependencyRequests())));
-    }
-    return bindingFields.build();
-  }
-
-  private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
-    // collect together all of the names that we would want to call the provider
-    ImmutableSet<String> dependencyNames =
-        dependencyRequests.stream().map(DependencyVariableNamer::name).collect(toImmutableSet());
+    FrameworkTypeMapper frameworkTypeMapper =
+        FrameworkTypeMapper.forBindingType(binding.bindingType());
 
-    if (dependencyNames.size() == 1) {
-      // if there's only one name, great! use it!
-      return Iterables.getOnlyElement(dependencyNames);
-    } else {
-      // in the event that a field is being used for a bunch of deps with different names,
-      // add all the names together with "And"s in the middle. E.g.: stringAndS
-      Iterator<String> namesIterator = dependencyNames.iterator();
-      String first = namesIterator.next();
-      StringBuilder compositeNameBuilder = new StringBuilder(first);
-      while (namesIterator.hasNext()) {
-        compositeNameBuilder
-            .append("And")
-            .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
-      }
-      return compositeNameBuilder.toString();
-    }
+    return Maps.toMap(
+        binding.dependencies(),
+        dependency ->
+            FrameworkField.create(
+                ClassName.get(
+                    frameworkTypeMapper.getFrameworkType(dependency.kind()).frameworkClass()),
+                TypeName.get(dependency.key().type()),
+                DependencyVariableNamer.name(dependency)));
   }
 
   static CodeBlock frameworkTypeUsageStatement(
@@ -172,16 +122,14 @@ static CodeBlock frameworkTypeUsageStatement(
    * #frameworkTypeUsageStatement(CodeBlock, RequestKind) use them}.
    */
   static ImmutableMap<DependencyRequest, CodeBlock> frameworkFieldUsages(
-      ImmutableSet<DependencyRequest> dependencies, ImmutableMap<Key, FieldSpec> fields) {
+      ImmutableSet<DependencyRequest> dependencies,
+      ImmutableMap<DependencyRequest, FieldSpec> fields) {
     return Maps.toMap(
         dependencies,
-        dep ->
-            frameworkTypeUsageStatement(CodeBlock.of("$N", fields.get(dep.key())), dep.kind()));
+        dep -> frameworkTypeUsageStatement(CodeBlock.of("$N", fields.get(dep)), dep.kind()));
   }
 
-  /**
-   * Returns the generated factory or members injector name for a binding.
-   */
+  /** Returns the generated factory or members injector name for a binding. */
   static ClassName generatedClassNameForBinding(Binding binding) {
     switch (binding.bindingType()) {
       case PROVISION:
@@ -256,9 +204,9 @@ private static ClassName siblingClassName(TypeElement typeElement, String suffix
    * The {@link java.util.Set} factory class name appropriate for set bindings.
    *
    * <ul>
-   * <li>{@link SetFactory} for provision bindings.
-   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
-   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   *   <li>{@link SetFactory} for provision bindings.
+   *   <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   *   <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
    * </ul>
    */
   static ClassName setFactoryClassName(ContributionBinding binding) {
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 4f3e4031f..9ba2484dd 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -187,7 +187,8 @@
             "import javax.inject.Provider;",
             "",
             GENERATED_CODE_ANNOTATIONS,
-            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "public final class GenericClass_Factory<A, B> implements",
+            "    Factory<GenericClass<A, B>> {",
             "  private final Provider<A> aProvider;",
             "  private final Provider<B> bProvider;",
             "",
@@ -281,7 +282,8 @@
             "import javax.inject.Provider;",
             "",
             GENERATED_CODE_ANNOTATIONS,
-            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "public final class GenericClass_Factory<A, B>",
+            "    implements Factory<GenericClass<A, B>> {",
             "  private final Provider<A> aProvider;",
             "  private final Provider<B> bProvider;",
             "",
@@ -404,61 +406,107 @@
             GENERATED_CODE_ANNOTATIONS,
             "public final class GenericClass_Factory<A, B>",
             "    implements Factory<GenericClass<A, B>> {",
-            "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<A> a2Provider;",
+            "  private final Provider<A> paProvider;",
             "  private final Provider<A> qaProvider;",
-            "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+            "  private final Provider<A> laProvider;",
+            "  private final Provider<String> sProvider;",
+            "  private final Provider<String> s2Provider;",
+            "  private final Provider<String> psProvider;",
             "  private final Provider<String> qsProvider;",
-            "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+            "  private final Provider<String> lsProvider;",
+            "  private final Provider<B> bProvider;",
+            "  private final Provider<B> b2Provider;",
+            "  private final Provider<B> pbProvider;",
             "  private final Provider<B> qbProvider;",
+            "  private final Provider<B> lbProvider;",
             "",
-            "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+            "  public GenericClass_Factory(",
+            "      Provider<A> aProvider,",
+            "      Provider<A> a2Provider,",
+            "      Provider<A> paProvider,",
             "      Provider<A> qaProvider,",
-            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<A> laProvider,",
+            "      Provider<String> sProvider,",
+            "      Provider<String> s2Provider,",
+            "      Provider<String> psProvider,",
             "      Provider<String> qsProvider,",
-            "      Provider<B> bAndB2AndPbAndLbProvider,",
-            "      Provider<B> qbProvider) {",
-            "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+            "      Provider<String> lsProvider,",
+            "      Provider<B> bProvider,",
+            "      Provider<B> b2Provider,",
+            "      Provider<B> pbProvider,",
+            "      Provider<B> qbProvider,",
+            "      Provider<B> lbProvider) {",
+            "    this.aProvider = aProvider;",
+            "    this.a2Provider = a2Provider;",
+            "    this.paProvider = paProvider;",
             "    this.qaProvider = qaProvider;",
-            "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+            "    this.laProvider = laProvider;",
+            "    this.sProvider = sProvider;",
+            "    this.s2Provider = s2Provider;",
+            "    this.psProvider = psProvider;",
             "    this.qsProvider = qsProvider;",
-            "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+            "    this.lsProvider = lsProvider;",
+            "    this.bProvider = bProvider;",
+            "    this.b2Provider = b2Provider;",
+            "    this.pbProvider = pbProvider;",
             "    this.qbProvider = qbProvider;",
+            "    this.lbProvider = lbProvider;",
             "  }",
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
             "    return new GenericClass<A, B>(",
-            "      aAndA2AndPaAndLaProvider.get(),",
-            "      aAndA2AndPaAndLaProvider.get(),",
-            "      aAndA2AndPaAndLaProvider,",
-            "      qaProvider.get(),",
-            "      DoubleCheck.lazy(aAndA2AndPaAndLaProvider),",
-            "      sAndS2AndPsAndLsProvider.get(),",
-            "      sAndS2AndPsAndLsProvider.get(),",
-            "      sAndS2AndPsAndLsProvider,",
-            "      qsProvider.get(),",
-            "      DoubleCheck.lazy(sAndS2AndPsAndLsProvider),",
-            "      bAndB2AndPbAndLbProvider.get(),",
-            "      bAndB2AndPbAndLbProvider.get(),",
-            "      bAndB2AndPbAndLbProvider,",
-            "      qbProvider.get(),",
-            "      DoubleCheck.lazy(bAndB2AndPbAndLbProvider));",
+            "        aProvider.get(),",
+            "        a2Provider.get(),",
+            "        paProvider,",
+            "        qaProvider.get(),",
+            "        DoubleCheck.lazy(laProvider),",
+            "        sProvider.get(),",
+            "        s2Provider.get(),",
+            "        psProvider,",
+            "        qsProvider.get(),",
+            "        DoubleCheck.lazy(lsProvider),",
+            "        bProvider.get(),",
+            "        b2Provider.get(),",
+            "        pbProvider,",
+            "        qbProvider.get(),",
+            "        DoubleCheck.lazy(lbProvider));",
             "  }",
             "",
             "  public static <A, B> GenericClass_Factory<A, B> create(",
-            "      Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> aProvider,",
+            "      Provider<A> a2Provider,",
+            "      Provider<A> paProvider,",
             "      Provider<A> qaProvider,",
-            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<A> laProvider,",
+            "      Provider<String> sProvider,",
+            "      Provider<String> s2Provider,",
+            "      Provider<String> psProvider,",
             "      Provider<String> qsProvider,",
-            "      Provider<B> bAndB2AndPbAndLbProvider,",
-            "      Provider<B> qbProvider) {",
+            "      Provider<String> lsProvider,",
+            "      Provider<B> bProvider,",
+            "      Provider<B> b2Provider,",
+            "      Provider<B> pbProvider,",
+            "      Provider<B> qbProvider,",
+            "      Provider<B> lbProvider) {",
             "    return new GenericClass_Factory<A, B>(",
-            "        aAndA2AndPaAndLaProvider,",
+            "        aProvider,",
+            "        a2Provider,",
+            "        paProvider,",
             "        qaProvider,",
-            "        sAndS2AndPsAndLsProvider,",
+            "        laProvider,",
+            "        sProvider,",
+            "        s2Provider,",
+            "        psProvider,",
             "        qsProvider,",
-            "        bAndB2AndPbAndLbProvider,",
-            "        qbProvider);",
+            "        lsProvider,",
+            "        bProvider,",
+            "        b2Provider,",
+            "        pbProvider,",
+            "        qbProvider,",
+            "        lbProvider);",
             "  }",
             "",
             "  public static <A, B> GenericClass<A, B> newInstance(",
@@ -1071,25 +1119,36 @@
             GENERATED_CODE_ANNOTATIONS,
             "public final class AllInjections_Factory implements Factory<AllInjections> {",
             "  private final Provider<String> sProvider;",
+            "  private final Provider<String> sProvider2;",
+            "  private final Provider<String> sProvider3;",
             "",
-            "  public AllInjections_Factory(Provider<String> sProvider) {",
+            "  public AllInjections_Factory(",
+            "      Provider<String> sProvider,",
+            "      Provider<String> sProvider2,",
+            "      Provider<String> sProvider3) {",
             "    this.sProvider = sProvider;",
+            "    this.sProvider2 = sProvider2;",
+            "    this.sProvider3 = sProvider3;",
             "  }",
             "",
-            "  @Override public AllInjections get() {",
+            "  @Override",
+            "  public AllInjections get() {",
             "    AllInjections instance = new AllInjections(sProvider.get());",
-            "    AllInjections_MembersInjector.injectS(instance, sProvider.get());",
-            "    AllInjections_MembersInjector.injectS2(instance, sProvider.get());",
+            "    AllInjections_MembersInjector.injectS(instance, sProvider2.get());",
+            "    AllInjections_MembersInjector.injectS2(instance, sProvider3.get());",
             "    return instance;",
             "  }",
             "",
-            "  public static AllInjections_Factory create(Provider<String> sProvider) {",
-            "    return new AllInjections_Factory(sProvider);",
+            "  public static AllInjections_Factory create(",
+            "      Provider<String> sProvider,",
+            "      Provider<String> sProvider2,",
+            "      Provider<String> sProvider3) {",
+            "    return new AllInjections_Factory(sProvider, sProvider2, sProvider3);",
             "  }",
             "",
             "  public static AllInjections newInstance(String s) {",
-            "     return new AllInjections(s);",
-            "   }",
+            "    return new AllInjections(s);",
+            "  }",
             "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 07048e633..e661dd98e 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -271,50 +271,64 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.Child_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        IMPORT_GENERATED_ANNOTATION,
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_CODE_ANNOTATIONS,
-        "public final class Child_MembersInjector<T>",
-        "    implements MembersInjector<Child<T>> {",
-        "  private final Provider<T> tAndXProvider;",
-        "  private final Provider<A> aAndYProvider;",
-        "  private final Provider<A2> a2Provider;",
-        "",
-        "  public Child_MembersInjector(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    this.tAndXProvider = tAndXProvider;",
-        "    this.aAndYProvider = aAndYProvider;",
-        "    this.a2Provider = a2Provider;",
-        "  }",
-        "",
-        "  public static <T> MembersInjector<Child<T>> create(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(Child<T> instance) {",
-        "    Parent_MembersInjector.injectX(instance, tAndXProvider.get());",
-        "    Parent_MembersInjector.injectY(instance, aAndYProvider.get());",
-        "    Parent_MembersInjector.injectA2(instance, a2Provider.get());",
-        "    injectA(instance, aAndYProvider.get());",
-        "    injectT(instance, tAndXProvider.get());",
-        "  }",
-        "",
-        "  public static <T> void injectA(Object instance, Object a) {",
-        "    ((Child<T>) instance).a = (A) a;",
-        "  }",
-        "",
-        "  public static <T> void injectT(Object instance, T t) {",
-        "    ((Child<T>) instance).t = t;",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.Child_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_CODE_ANNOTATIONS,
+            "public final class Child_MembersInjector<T>",
+            "    implements MembersInjector<Child<T>> {",
+            "  private final Provider<T> xProvider;",
+            "  private final Provider<A> yProvider;",
+            "  private final Provider<A2> a2Provider;",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<T> tProvider;",
+            "",
+            "  public Child_MembersInjector(",
+            "      Provider<T> xProvider,",
+            "      Provider<A> yProvider,",
+            "      Provider<A2> a2Provider,",
+            "      Provider<A> aProvider,",
+            "      Provider<T> tProvider) {",
+            "    this.xProvider = xProvider;",
+            "    this.yProvider = yProvider;",
+            "    this.a2Provider = a2Provider;",
+            "    this.aProvider = aProvider;",
+            "    this.tProvider = tProvider;",
+            "  }",
+            "",
+            "  public static <T> MembersInjector<Child<T>> create(",
+            "      Provider<T> xProvider,",
+            "      Provider<A> yProvider,",
+            "      Provider<A2> a2Provider,",
+            "      Provider<A> aProvider,",
+            "      Provider<T> tProvider) {",
+            "    return new Child_MembersInjector<T>(xProvider, yProvider, a2Provider, aProvider,"
+                + " tProvider);",
+            "}",
+            "",
+            "  @Override",
+            "  public void injectMembers(Child<T> instance) {",
+            "    Parent_MembersInjector.injectX(instance, xProvider.get());",
+            "    Parent_MembersInjector.injectY(instance, yProvider.get());",
+            "    Parent_MembersInjector.injectA2(instance, a2Provider.get());",
+            "    injectA(instance, aProvider.get());",
+            "    injectT(instance, tProvider.get());",
+            "  }",
+            "",
+            "  public static <T> void injectA(Object instance, Object a) {",
+            "    ((Child<T>) instance).a = (A) a;",
+            "  }",
+            "",
+            "  public static <T> void injectT(Object instance, T t) {",
+            "    ((Child<T>) instance).t = t;",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(a, a2, parent, child))
         .withCompilerOptions(compilerMode.javacopts())
@@ -352,21 +366,29 @@ public void parentClass_injectedMembersInSupertype() {
             "public final class FieldInjection_MembersInjector",
             "    implements MembersInjector<FieldInjection> {",
             "  private final Provider<String> stringProvider;",
+            "  private final Provider<String> stringProvider2;",
+            "  private final Provider<String> stringProvider3;",
             "",
-            "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
+            "  public FieldInjection_MembersInjector(Provider<String> stringProvider,",
+            "      Provider<String> stringProvider2, Provider<String> stringProvider3) {",
             "    this.stringProvider = stringProvider;",
+            "    this.stringProvider2 = stringProvider2;",
+            "    this.stringProvider3 = stringProvider3;",
             "  }",
             "",
             "  public static MembersInjector<FieldInjection> create(",
-            "      Provider<String> stringProvider) {",
-            "    return new FieldInjection_MembersInjector(stringProvider);",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> stringProvider2,",
+            "      Provider<String> stringProvider3) {",
+            "    return new FieldInjection_MembersInjector(",
+            "        stringProvider, stringProvider2, stringProvider3);",
             "  }",
             "",
             "  @Override",
             "  public void injectMembers(FieldInjection instance) {",
             "    injectString(instance, stringProvider.get());",
-            "    injectLazyString(instance, DoubleCheck.lazy(stringProvider));",
-            "    injectStringProvider(instance, stringProvider);",
+            "    injectLazyString(instance, DoubleCheck.lazy(stringProvider2));",
+            "    injectStringProvider(instance, stringProvider3);",
             "  }",
             "",
             "  public static void injectString(Object instance, String string) {",
@@ -419,17 +441,29 @@ public void parentClass_injectedMembersInSupertype() {
             GENERATED_CODE_ANNOTATIONS,
             "public final class MethodInjection_MembersInjector",
             "     implements MembersInjector<MethodInjection> {",
-            "",
             "  private final Provider<String> stringProvider;",
-            "",
-            "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
+            "  private final Provider<String> stringProvider2;",
+            "  private final Provider<String> stringProvider3;",
+            "  private final Provider<String> stringProvider4;",
+            "",
+            "  public MethodInjection_MembersInjector(",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> stringProvider2,",
+            "      Provider<String> stringProvider3,",
+            "      Provider<String> stringProvider4) {",
             "    this.stringProvider = stringProvider;",
+            "    this.stringProvider2 = stringProvider2;",
+            "    this.stringProvider3 = stringProvider3;",
+            "    this.stringProvider4 = stringProvider4;",
             "  }",
             "",
             "  public static MembersInjector<MethodInjection> create(",
-            "      Provider<String> stringProvider) {",
-            "    return new MethodInjection_MembersInjector(stringProvider);",
-            "  }",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> stringProvider2,",
+            "      Provider<String> stringProvider3,",
+            "      Provider<String> stringProvider4) {",
+            "    return new MethodInjection_MembersInjector(",
+            "        stringProvider, stringProvider2, stringProvider3, stringProvider4);}",
             "",
             "  @Override",
             "  public void injectMembers(MethodInjection instance) {",
@@ -437,9 +471,9 @@ public void parentClass_injectedMembersInSupertype() {
             "    injectOneArg(instance, stringProvider.get());",
             "    injectManyArgs(",
             "        instance,",
-            "        stringProvider.get(),",
-            "        DoubleCheck.lazy(stringProvider),",
-            "        stringProvider);",
+            "        stringProvider2.get(),",
+            "        DoubleCheck.lazy(stringProvider3),",
+            "        stringProvider4);",
             "  }",
             "",
             "  public static void injectNoArgs(Object instance) {",
@@ -483,59 +517,66 @@ public void mixedMemberInjection() {
         "  @Inject Object object;",
         "  @Inject void setObject(Object o) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        IMPORT_GENERATED_ANNOTATION,
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_CODE_ANNOTATIONS,
-        "public final class MixedMemberInjection_MembersInjector",
-        "    implements MembersInjector<MixedMemberInjection> {",
-        "",
-        "  private final Provider<String> stringAndSProvider;",
-        "  private final Provider<Object> objectAndOProvider;",
-        "",
-        "  public MixedMemberInjection_MembersInjector(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    this.stringAndSProvider = stringAndSProvider;",
-        "    this.objectAndOProvider = objectAndOProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<MixedMemberInjection> create(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    return new MixedMemberInjection_MembersInjector(",
-        "        stringAndSProvider, objectAndOProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(MixedMemberInjection instance) {",
-        "    injectString(instance, stringAndSProvider.get());",
-        "    injectObject(instance, objectAndOProvider.get());",
-        "    injectSetString(instance, stringAndSProvider.get());",
-        "    injectSetObject(instance, objectAndOProvider.get());",
-        "  }",
-        "",
-        "  public static void injectString(Object instance, String string) {",
-        "    ((MixedMemberInjection) instance).string = string;",
-        "  }",
-        "",
-        "  public static void injectObject(Object instance, Object object) {",
-        "    ((MixedMemberInjection) instance).object = object;",
-        "  }",
-        "",
-        "  public static void injectSetString(Object instance, String s) {",
-        "    ((MixedMemberInjection) instance).setString(s);",
-        "  }",
-        "",
-        "  public static void injectSetObject(Object instance, Object o) {",
-        "    ((MixedMemberInjection) instance).setObject(o);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.MixedMemberInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_CODE_ANNOTATIONS,
+            "public final class MixedMemberInjection_MembersInjector",
+            "    implements MembersInjector<MixedMemberInjection> {",
+            "  private final Provider<String> stringProvider;",
+            "  private final Provider<Object> objectProvider;",
+            "  private final Provider<String> sProvider;",
+            "  private final Provider<Object> oProvider;",
+            "",
+            "  public MixedMemberInjection_MembersInjector(",
+            "      Provider<String> stringProvider,",
+            "      Provider<Object> objectProvider,",
+            "      Provider<String> sProvider,",
+            "      Provider<Object> oProvider) {",
+            "    this.stringProvider = stringProvider;",
+            "    this.objectProvider = objectProvider;",
+            "    this.sProvider = sProvider;",
+            "    this.oProvider = oProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<MixedMemberInjection> create(",
+            "      Provider<String> stringProvider,",
+            "      Provider<Object> objectProvider,",
+            "      Provider<String> sProvider,",
+            "      Provider<Object> oProvider) {",
+            "    return new MixedMemberInjection_MembersInjector(",
+            "        stringProvider, objectProvider, sProvider, oProvider);}",
+            "",
+            "  @Override",
+            "  public void injectMembers(MixedMemberInjection instance) {",
+            "    injectString(instance, stringProvider.get());",
+            "    injectObject(instance, objectProvider.get());",
+            "    injectSetString(instance, sProvider.get());",
+            "    injectSetObject(instance, oProvider.get());",
+            "  }",
+            "",
+            "  public static void injectString(Object instance, String string) {",
+            "    ((MixedMemberInjection) instance).string = string;",
+            "  }",
+            "",
+            "  public static void injectObject(Object instance, Object object) {",
+            "    ((MixedMemberInjection) instance).object = object;",
+            "  }",
+            "",
+            "  public static void injectSetString(Object instance, String s) {",
+            "    ((MixedMemberInjection) instance).setString(s);",
+            "  }",
+            "",
+            "  public static void injectSetObject(Object instance, Object o) {",
+            "    ((MixedMemberInjection) instance).setObject(o);",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .withCompilerOptions(compilerMode.javacopts())
@@ -556,45 +597,49 @@ public void mixedMemberInjection() {
         "  @Inject AllInjections(String s) {}",
         "  @Inject void s(String s) {}",
         "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        IMPORT_GENERATED_ANNOTATION,
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_CODE_ANNOTATIONS,
-        "public final class AllInjections_MembersInjector ",
-        "    implements MembersInjector<AllInjections> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections_MembersInjector(Provider<String> sProvider) {",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "      return new AllInjections_MembersInjector(sProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(AllInjections instance) {",
-        "    injectS(instance, sProvider.get());",
-        "    injectS2(instance, sProvider.get());",
-        "  }",
-        "",
-        // TODO(b/64477506): now that these all take "object", it would be nice to rename "instance"
-        // to the type name
-        "  public static void injectS(Object instance, String s) {",
-        "    ((AllInjections) instance).s = s;",
-        "  }",
-        "",
-        "  public static void injectS2(Object instance, String s) {",
-        "    ((AllInjections) instance).s(s);",
-        "  }",
-        "",
-        "}");
+    JavaFileObject expectedMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.AllInjections_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_CODE_ANNOTATIONS,
+            "public final class AllInjections_MembersInjector ",
+            "    implements MembersInjector<AllInjections> {",
+            "  private final Provider<String> sProvider;",
+            "  private final Provider<String> sProvider2;",
+            "",
+            "  public AllInjections_MembersInjector(",
+            "      Provider<String> sProvider, Provider<String> sProvider2) {",
+            "    this.sProvider = sProvider;",
+            "    this.sProvider2 = sProvider2;",
+            "  }",
+            "",
+            "  public static MembersInjector<AllInjections> create(",
+            "      Provider<String> sProvider, Provider<String> sProvider2) {",
+            "    return new AllInjections_MembersInjector(sProvider, sProvider2);}",
+            "",
+            "  @Override",
+            "  public void injectMembers(AllInjections instance) {",
+            "    injectS(instance, sProvider.get());",
+            "    injectS2(instance, sProvider2.get());",
+            "  }",
+            "",
+            // TODO(b/64477506): now that these all take "object", it would be nice to rename
+            // "instance"
+            // to the type name
+            "  public static void injectS(Object instance, String s) {",
+            "    ((AllInjections) instance).s = s;",
+            "  }",
+            "",
+            "  public static void injectS2(Object instance, String s) {",
+            "    ((AllInjections) instance).s(s);",
+            "  }",
+            "",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .withCompilerOptions(compilerMode.javacopts())
@@ -1100,22 +1145,23 @@ public void injectsPrimitive() {
             GENERATED_CODE_ANNOTATIONS,
             "public final class InjectedType_MembersInjector ",
             "    implements MembersInjector<InjectedType> {",
-            "  private final Provider<Integer> boxedIntAndPrimitiveIntProvider;",
+            "  private final Provider<Integer> primitiveIntProvider;",
+            "  private final Provider<Integer> boxedIntProvider;",
             "",
             "  public InjectedType_MembersInjector(",
-            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
-            "    this.boxedIntAndPrimitiveIntProvider = boxedIntAndPrimitiveIntProvider;",
+            "      Provider<Integer> primitiveIntProvider, Provider<Integer> boxedIntProvider) {",
+            "    this.primitiveIntProvider = primitiveIntProvider;",
+            "    this.boxedIntProvider = boxedIntProvider;",
             "  }",
             "",
             "  public static MembersInjector<InjectedType> create(",
-            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
-            "    return new InjectedType_MembersInjector(boxedIntAndPrimitiveIntProvider);",
-            "  }",
+            "      Provider<Integer> primitiveIntProvider, Provider<Integer> boxedIntProvider) {",
+            "    return new InjectedType_MembersInjector(primitiveIntProvider, boxedIntProvider);}",
             "",
             "  @Override",
             "  public void injectMembers(InjectedType instance) {",
-            "    injectPrimitiveInt(instance, boxedIntAndPrimitiveIntProvider.get());",
-            "    injectBoxedInt(instance, boxedIntAndPrimitiveIntProvider.get());",
+            "    injectPrimitiveInt(instance, primitiveIntProvider.get());",
+            "    injectBoxedInt(instance, boxedIntProvider.get());",
             "  }",
             "",
             "  public static void injectPrimitiveInt(Object instance, int primitiveInt) {",
@@ -1137,25 +1183,28 @@ public void injectsPrimitive() {
             "",
             GENERATED_CODE_ANNOTATIONS,
             "public final class InjectedType_Factory implements Factory<InjectedType> {",
-            "  private final Provider<Integer> boxedIntAndPrimitiveIntProvider;",
+            "  private final Provider<Integer> primitiveIntProvider;",
             "",
-            "  public InjectedType_Factory(Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
-            "    this.boxedIntAndPrimitiveIntProvider = boxedIntAndPrimitiveIntProvider;",
+            "  private final Provider<Integer> boxedIntProvider;",
+            "",
+            "  public InjectedType_Factory(",
+            "      Provider<Integer> primitiveIntProvider, Provider<Integer> boxedIntProvider) {",
+            "    this.primitiveIntProvider = primitiveIntProvider;",
+            "    this.boxedIntProvider = boxedIntProvider;",
             "  }",
             "",
             "  @Override",
             "  public InjectedType get() {",
             "    InjectedType instance = new InjectedType();",
             "    InjectedType_MembersInjector.injectPrimitiveInt(",
-            "        instance, boxedIntAndPrimitiveIntProvider.get());",
-            "    InjectedType_MembersInjector.injectBoxedInt(",
-            "        instance, boxedIntAndPrimitiveIntProvider.get());",
+            "        instance, primitiveIntProvider.get());",
+            "    InjectedType_MembersInjector.injectBoxedInt(instance, boxedIntProvider.get());",
             "    return instance;",
             "  }",
             "",
             "  public static InjectedType_Factory create(",
-            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
-            "    return new InjectedType_Factory(boxedIntAndPrimitiveIntProvider);",
+            "      Provider<Integer> primitiveIntProvider, Provider<Integer> boxedIntProvider) {",
+            "    return new InjectedType_Factory(primitiveIntProvider, boxedIntProvider);",
             "  }",
             "",
             "  public static InjectedType newInstance() {",
@@ -1240,19 +1289,22 @@ public void accessibility() {
                 "public final class Inaccessible_MembersInjector",
                 "    implements MembersInjector<Inaccessible> {",
                 "  private final Provider<Foo> fooProvider;",
+                "  private final Provider<Foo> fooProvider2;",
                 "",
-                "  public Inaccessible_MembersInjector(Provider<Foo> fooProvider) {",
+                "  public Inaccessible_MembersInjector(",
+                "      Provider<Foo> fooProvider, Provider<Foo> fooProvider2) {",
                 "    this.fooProvider = fooProvider;",
+                "    this.fooProvider2 = fooProvider2;",
                 "  }",
                 "",
-                "  public static MembersInjector<Inaccessible> create(Provider<Foo> fooProvider) {",
-                "    return new Inaccessible_MembersInjector(fooProvider);",
-                "  }",
+                "  public static MembersInjector<Inaccessible> create(",
+                "      Provider<Foo> fooProvider, Provider<Foo> fooProvider2) {",
+                "    return new Inaccessible_MembersInjector(fooProvider, fooProvider2);}",
                 "",
                 "  @Override",
                 "  public void injectMembers(Inaccessible instance) {",
                 "    injectFoo(instance, fooProvider.get());",
-                "    injectMethod(instance, fooProvider.get());",
+                "    injectMethod(instance, fooProvider2.get());",
                 "  }",
                 "",
                 "  public static void injectFoo(Object instance, Object foo) {",
