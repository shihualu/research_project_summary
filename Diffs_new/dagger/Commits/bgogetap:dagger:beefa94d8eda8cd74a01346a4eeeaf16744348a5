diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 0c0018f0f..a35414e2f 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -25,9 +25,12 @@
 import static com.google.common.collect.Lists.asList;
 import static com.google.common.collect.Sets.filter;
 import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
+import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerGraphs.shortestPath;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static java.util.Collections.min;
 import static java.util.Comparator.comparing;
 import static java.util.Comparator.comparingInt;
@@ -244,14 +247,17 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
     /** The diagnostic information associated with an error. */
     private final class DiagnosticInfo {
       final ImmutableList<DependencyEdge> dependencyTrace;
+      final ImmutableSet<DependencyEdge> requests;
       final ImmutableSet<DependencyEdge> entryPoints;
 
       DiagnosticInfo(MaybeBindingNode bindingNode) {
         entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
+        requests = requests(bindingNode);
         dependencyTrace = dependencyTrace(bindingNode, entryPoints);
       }
 
       DiagnosticInfo(DependencyEdge dependencyEdge) {
+        requests = ImmutableSet.of(dependencyEdge);
         ImmutableList.Builder<DependencyEdge> dependencyTraceBuilder = ImmutableList.builder();
         dependencyTraceBuilder.add(dependencyEdge);
 
@@ -276,6 +282,21 @@ public String toString() {
             edge -> dependencyRequestFormatter.appendFormatLine(message, edge.dependencyRequest()));
         appendComponentPathUnlessAtRoot(message, source(getLast(dependencyTrace)));
 
+        // List any other dependency requests.
+        ImmutableSet<Element> otherRequests =
+            requests.stream()
+                .filter(request -> !request.isEntryPoint()) // skip entry points, listed below
+                // skip the request from the dependency trace above
+                .filter(request -> !request.equals(dependencyTrace.get(0)))
+                .map(request -> request.dependencyRequest().requestElement().get())
+                .collect(toImmutableSet());
+        if (!otherRequests.isEmpty()) {
+          message.append("\nIt is also requested at:");
+          for (Element otherRequest : otherRequests) {
+            message.append("\n    ").append(elementToString(otherRequest));
+          }
+        }
+
         // List the remaining entry points, showing which component they're in.
         if (entryPoints.size() > 1) {
           message.append("\nThe following other entry points also depend on it:");
@@ -351,6 +372,15 @@ public String toString() {
         return dependencyTrace.build().reverse();
       }
 
+      /** Returns all the nonsynthetic dependency requests for a binding node. */
+      ImmutableSet<DependencyEdge> requests(MaybeBindingNode bindingNode) {
+        return graph.inEdges(bindingNode).stream()
+            .flatMap(instancesOf(DependencyEdge.class))
+            .filter(edge -> edge.dependencyRequest().requestElement().isPresent())
+            .sorted(requestEnclosingTypeName().thenComparing(requestElementDeclarationOrder()))
+            .collect(toImmutableSet());
+      }
+
       /**
        * Returns a comparator that sorts entry points in components whose paths from the root are
        * shorter first.
@@ -405,6 +435,18 @@ TypeElement typeDeclaringEntryPoint(DependencyEdge entryPoint) {
             entryPoint.dependencyRequest().requestElement().get().getEnclosingElement());
       }
 
+      /**
+       * Returns a comparator that sorts dependency edges lexicographically by the qualified name of
+       * the type that contains them. Only appropriate for edges with request elements.
+       */
+      Comparator<DependencyEdge> requestEnclosingTypeName() {
+        return comparing(
+            edge ->
+                closestEnclosingTypeElement(edge.dependencyRequest().requestElement().get())
+                    .getQualifiedName()
+                    .toString());
+      }
+
       /**
        * Returns a comparator that sorts edges in the order in which their request elements were
        * declared in their declaring type.
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index bdcc3e944..ab8e754ce 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -37,6 +37,7 @@
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -77,35 +78,35 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    // TODO(ronshapiro): Maybe report each missing binding once instead of each dependency.
-    graph.missingBindingNodes().stream()
-        .flatMap(node -> graph.inEdges(node).stream())
-        .flatMap(instancesOf(DependencyEdge.class))
-        .forEach(edge -> reportMissingBinding(edge, graph, diagnosticReporter));
+    graph
+        .missingBindingNodes()
+        .forEach(node -> reportMissingBinding(node, graph, diagnosticReporter));
   }
 
   private void reportMissingBinding(
-      DependencyEdge edge, BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    diagnosticReporter.reportDependency(
+      MissingBindingNode missingBindingNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    diagnosticReporter.reportBinding(
         ERROR,
-        edge,
-        missingReleasableReferenceManagerBindingErrorMessage(edge, graph)
-            .orElseGet(() -> missingBindingErrorMessage(edge, graph)));
+        missingBindingNode,
+        missingReleasableReferenceManagerBindingErrorMessage(missingBindingNode, graph)
+            .orElseGet(() -> missingBindingErrorMessage(missingBindingNode, graph)));
   }
 
-  private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
-    Key key = edge.dependencyRequest().key();
+  private String missingBindingErrorMessage(
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    Key key = missingBindingNode.key();
     StringBuilder errorMessage = new StringBuilder();
     // Wildcards should have already been checked by DependencyRequestValidator.
-    verify(
-        !key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", edge);
+    verify(!key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", key);
     // TODO(ronshapiro): replace "provided" with "satisfied"?
     errorMessage.append(key).append(" cannot be provided without ");
     if (isValidImplicitProvisionKey(key, types)) {
       errorMessage.append("an @Inject constructor or ");
     }
     errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-    if (dependencyCanBeProduction(edge, graph)) {
+    if (allIncomingDependenciesCanUseProduction(missingBindingNode, graph)) {
       errorMessage.append(" or @Produces-");
     }
     errorMessage.append("annotated method.");
@@ -124,6 +125,13 @@ private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph grap
     return errorMessage.toString();
   }
 
+  private boolean allIncomingDependenciesCanUseProduction(
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    return graph.inEdges(missingBindingNode).stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .allMatch(edge -> dependencyCanBeProduction(edge, graph));
+  }
+
   private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
     Node source = graph.incidentNodes(edge).source();
     if (source instanceof ComponentNode) {
@@ -143,10 +151,10 @@ private boolean typeHasInjectionSites(Key key) {
   }
 
   /**
-   * If {@code edge} is missing a binding because it's an invalid {@code @ForReleasableReferences}
-   * request, returns a more specific error message.
+   * If {@code missingBindingNode}'s key is for an invalid {@code @ForReleasableReferences}, returns
+   * a more specific error message.
    *
-   * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or {@link
+   * <p>An invalid key is one whose type is either {@link ReleasableReferenceManager} or {@link
    * TypedReleasableReferenceManager}, and whose scope:
    *
    * <ul>
@@ -156,8 +164,8 @@ private boolean typeHasInjectionSites(Key key) {
    * </ul>
    */
   private Optional<String> missingReleasableReferenceManagerBindingErrorMessage(
-      DependencyEdge edge, BindingGraph graph) {
-    Key key = edge.dependencyRequest().key();
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    Key key = missingBindingNode.key();
     if (!key.qualifier().isPresent()
         || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
         || !isType(key.type())) {
diff --git a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
index 9a677a4d2..66e81a8c7 100644
--- a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
@@ -606,4 +606,61 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
         .inFile(parent)
         .onLineContaining("interface Parent");
   }
+
+  @Test
+  public void manyDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object object();",
+            "  String string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object object(NotBound notBound);",
+            "",
+            "  @Provides static String string(NotBound notBound, Object object) {",
+            "    return notBound.toString();",
+            "  }",
+            "}");
+    JavaFileObject notBound =
+        JavaFileObjects.forSourceLines(
+            "test.NotBound", //
+            "package test;",
+            "",
+            "interface NotBound {}");
+    Compilation compilation = daggerCompiler().compile(component, module, notBound);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[Dagger/MissingBinding] "
+                    + "test.NotBound cannot be provided without an @Provides-annotated method.",
+                "    test.NotBound is injected at",
+                "        test.TestModule.object(notBound)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.object()",
+                "It is also requested at:",
+                "    test.TestModule.string(notBound, â€¦)",
+                "The following other entry points also depend on it:",
+                "    test.TestComponent.string()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+    assertThat(compilation).hadErrorCount(1);
+  }
 }
