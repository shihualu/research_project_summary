diff --git a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
deleted file mode 100644
index 80de62760..000000000
--- a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Set;
-import javax.inject.Inject;
-
-/**
- * Releases references in {@link ReleaseReferencesAt} {@linkplain javax.inject.Scope scopes} in
- * low-memory conditions.
- *
- * <p>In order to release references in low-memory conditions, inject an {@code
- * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
- * {@link android.app.Application#onTrimMemory(int)} to it.
- *
- * <p>For example:
- *
- * <pre>
- *   class MyApplication extends Application {
- *     {@literal @Inject} AndroidMemorySensitiveReferenceManager manager;
- *
- *     public void onTrimMemory(int level) {
- *       manager.onTrimMemory(level);
- *     }
- *   }</pre>
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public final class AndroidMemorySensitiveReferenceManager {
-
-  private final Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers;
-
-  @Inject
-  AndroidMemorySensitiveReferenceManager(
-      Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers) {
-    this.managers = managers;
-  }
-
-  /**
-   * Releases references for {@link ReleaseReferencesAt} scopes whose {@link
-   * ReleaseReferencesAt#value()} is less than or equal to {@code level}. Restores references for
-   * scopes whose {@link ReleaseReferencesAt#value()} is greater than {@code level}.
-   *
-   * @see android.app.Application#onTrimMemory(int)
-   */
-  public void onTrimMemory(int level) {
-    for (TypedReleasableReferenceManager<ReleaseReferencesAt> manager : managers) {
-      if (level >= manager.metadata().value()) {
-        manager.releaseStrongReferences();
-      } else {
-        manager.restoreStrongReferences();
-      }
-    }
-  }
-}
diff --git a/java/dagger/android/ReleaseReferencesAt.java b/java/dagger/android/ReleaseReferencesAt.java
deleted file mode 100644
index 78ae99c4d..000000000
--- a/java/dagger/android/ReleaseReferencesAt.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates {@linkplain javax.inject.Scope scopes} to associate them with a low-memory threshold
- * level, as described in {@link android.app.Application#onTrimMemory(int)}.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention}(RUNTIME)
- *   {@literal @Target}({TYPE, METHOD})
- *   {@literal @ReleaseReferencesAt}(TRIM_MEMORY_BACKGROUND)
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * <p>Any scope annotated with {@code @ReleaseReferencesAt} can {@linkplain CanReleaseReferences
- * release its references}.
- *
- * <p>In order to release references in low-memory conditions, inject an {@link
- * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
- * {@link android.app.Application#onTrimMemory(int)} to it.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target(ANNOTATION_TYPE)
-@CanReleaseReferences
-@Deprecated
-public @interface ReleaseReferencesAt {
-  /**
-   * If {@link AndroidMemorySensitiveReferenceManager#onTrimMemory(int)} is called with a value
-   * greater than or equal to this, the scope's references will be released. If it is called with a
-   * value less than this, the scope's references will be restored.
-   *
-   * <p>Use one of the constants defined in {@link android.content.ComponentCallbacks2}.
-   */
-  @OnTrimMemoryValue
-  int value();
-}
diff --git a/java/dagger/android/package-info.java b/java/dagger/android/package-info.java
index 3739a50c2..f59ef488c 100644
--- a/java/dagger/android/package-info.java
+++ b/java/dagger/android/package-info.java
@@ -14,12 +14,8 @@
  * limitations under the License.
  */
 
+/** APIs to assist with performing injection on Android. */
 @CheckReturnValue
 package dagger.android;
 
-/**
- * APIs to assist with using Dagger on Android devices. It includes common code to perform injection
- * as well as Android-specific extensions to {@link dagger.releasablereferences}.
- */
-
 import com.google.errorprone.annotations.CheckReturnValue;
diff --git a/java/dagger/internal/ReferenceReleasingProvider.java b/java/dagger/internal/ReferenceReleasingProvider.java
deleted file mode 100644
index 30a9cb4b5..000000000
--- a/java/dagger/internal/ReferenceReleasingProvider.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import java.lang.ref.WeakReference;
-import javax.inject.Provider;
-
-/**
- * A {@link Provider} implementation that can exchange its strong reference to the stored object for
- * a {@link WeakReference}.
- *
- * <p>The provider can be in any one of four states at a time:
- *
- * <ul>
- *   <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
- *       both {@code null}.
- *   <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's
- *       value is {@code null}.
- *   <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
- *       weak reference is {@code null}.
- *   <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
- *       reference's value is not {@code null}.
- * </ul>
- *
- * <p>The provider starts in <b>uninitialized</b> state.
- *
- * <p>{@link #get()} transitions to <b>strong-reference</b> state when in <b>uninitialized</b> or
- * <b>cleared</b> state.
- *
- * <p>{@link #releaseStrongReference()} transitions to <b>weak-reference</b> state when in
- * <b>strong-reference</b> state, unless the stored value is {@code null}.
- *
- * <p>{@link #restoreStrongReference()} transitions to <b>strong-reference</b> state when in
- * <b>weak-reference</b> state.
- *
- * <p>If garbage collection clears the weak reference while in <b>weak-reference</b> state, the
- * provider transitions to <b>cleared</b> state.
- *
- * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- */
-@GwtIncompatible
-public final class ReferenceReleasingProvider<T> implements Provider<T> {
-  private static final Object NULL = new Object(); // sentinel used when provider.get() returns null
-
-  private final Provider<T> provider;
-  private volatile Object strongReference;
-  private volatile WeakReference<T> weakReference;
-
-  private ReferenceReleasingProvider(Provider<T> provider) {
-    assert provider != null;
-    this.provider = provider;
-  }
-
-  /**
-   * Releases the strong reference to the object previously returned by {@link #get()}, and creates
-   * a {@link WeakReference} to that object, unless the stored value is {@code null}.
-   */
-  public void releaseStrongReference() {
-    Object value = strongReference;
-    if (value != null && value != NULL) {
-      synchronized (this) {
-        @SuppressWarnings("unchecked") // values other than NULL come from the provider
-        T storedValue = (T) value;
-        weakReference = new WeakReference<T>(storedValue);
-        strongReference = null;
-      }
-    }
-  }
-
-  /**
-   * Restores the strong reference that was previously {@linkplain #releaseStrongReference()
-   * released} if the {@link WeakReference} has not yet been cleared during garbage collection.
-   */
-  public void restoreStrongReference() {
-    Object value = strongReference;
-    if (weakReference != null && value == null) {
-      synchronized (this) {
-        value = strongReference;
-        if (weakReference != null && value == null) {
-          value = weakReference.get();
-          if (value != null) {
-            strongReference = value;
-            weakReference = null;
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Returns the result of calling {@link Provider#get()} on the underlying {@link Provider}.
-   *
-   * <p>Calling {@code get()} in <b>uninitialized</b> or <b>cleared</b> state calls {@code get()}
-   * on the underlying provider, sets the strong reference to the returned value, and returns it,
-   * leaving the provider in <b>strong-reference</b> state.
-   *
-   * <p>Calling {@code get()} in <b>strong-reference</b> state simply returns the strong reference,
-   * leaving the provider in <b>strong-reference</b> state.
-   *
-   * <p>Calling {@code get()} in <b>weak-reference</b> state returns the {@link WeakReference}'s
-   * value, leaving the provider in <b>weak-reference</b> state.
-   */
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
-  @Override
-  public T get() {
-    Object value = currentValue();
-    if (value == null) {
-      synchronized (this) {
-        value = currentValue();
-        if (value == null) {
-          value = provider.get();
-          if (value == null) {
-            value = NULL;
-          }
-          strongReference = value;
-        }
-      }
-    }
-    return value == NULL ? null : (T) value;
-  }
-
-  private Object currentValue() {
-    Object value = strongReference;
-    if (value != null) {
-      return value;
-    }
-    if (weakReference != null) {
-      return weakReference.get();
-    }
-    return null;
-  }
-
-  /**
-   * Returns a {@link Provider} that stores the value from the given delegate provider and is
-   * managed by {@code references}.
-   */
-  public static <T> ReferenceReleasingProvider<T> create(
-      Provider<T> delegate, ReferenceReleasingProviderManager references) {
-    ReferenceReleasingProvider<T> provider =
-        new ReferenceReleasingProvider<T>(checkNotNull(delegate));
-    references.addProvider(provider);
-    return provider;
-  }
-}
diff --git a/java/dagger/internal/ReferenceReleasingProviderManager.java b/java/dagger/internal/ReferenceReleasingProviderManager.java
deleted file mode 100644
index 9be7c342a..000000000
--- a/java/dagger/internal/ReferenceReleasingProviderManager.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import dagger.releasablereferences.ReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import java.util.Iterator;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-/**
- * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
- * {@link ReferenceReleasingProvider}s.
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- */
-@GwtIncompatible
-public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
-
-  private final Class<? extends Annotation> scope;
-  private final Queue<WeakReference<ReferenceReleasingProvider<?>>> providers =
-      new ConcurrentLinkedQueue<WeakReference<ReferenceReleasingProvider<?>>>();
-
-  public ReferenceReleasingProviderManager(Class<? extends Annotation> scope) {
-    this.scope = checkNotNull(scope);
-  }
-
-  /**
-   * Adds a weak reference to {@code provider}.
-   */
-  public void addProvider(ReferenceReleasingProvider<?> provider) {
-    providers.add(new WeakReference<ReferenceReleasingProvider<?>>(provider));
-  }
-
-  @Override
-  public Class<? extends Annotation> scope() {
-    return scope;
-  }
-
-  /**
-   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#releaseStrongReference()} on all
-   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
-   * are still weakly referenced.
-   */
-  @Override
-  public void releaseStrongReferences() {
-    execute(Operation.RELEASE);
-  }
-
-  /**
-   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#restoreStrongReference()} on all
-   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
-   * are still weakly referenced.
-   */
-  @Override
-  public void restoreStrongReferences() {
-    execute(Operation.RESTORE);
-  }
-
-  private void execute(Operation operation) {
-    Iterator<WeakReference<ReferenceReleasingProvider<?>>> iterator = providers.iterator();
-    while (iterator.hasNext()) {
-      ReferenceReleasingProvider<?> provider = iterator.next().get();
-      if (provider == null) {
-        iterator.remove();
-      } else {
-        operation.execute(provider);
-      }
-    }
-  }
-
-  private enum Operation {
-    RELEASE {
-      @Override
-      void execute(ReferenceReleasingProvider<?> provider) {
-        provider.releaseStrongReference();
-      }
-    },
-    RESTORE {
-      @Override
-      void execute(ReferenceReleasingProvider<?> provider) {
-        provider.restoreStrongReference();
-      }
-    },
-    ;
-
-    abstract void execute(ReferenceReleasingProvider<?> provider);
-  }
-}
diff --git a/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java b/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
deleted file mode 100644
index a1167ef8e..000000000
--- a/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-
-/**
- * A {@link TypedReleasableReferenceManager} that decorates another {@link
- * ReleasableReferenceManager} with a metadata annotation.
- *
- * <p>For each scope that requires a {@link ReleasableReferenceManager}, the generated component
- * implementation has a field that implements that manager. For every {@link
- * TypedReleasableReferenceManager} that is required for that scope, the component uses this class
- * to decorate the field with the metadata annotation.
- *
- * @param <M> the type of the metadata annotation
- */
-@GwtIncompatible
-public final class TypedReleasableReferenceManagerDecorator<M extends Annotation>
-    implements TypedReleasableReferenceManager<M> {
-
-  private final ReleasableReferenceManager delegate;
-  private final M metadata;
-
-  /**
-   * Constructs a manager that delegates {@link #releaseStrongReferences()} and {@link
-   * #releaseStrongReferences()} to {@code delegate}.
-   */
-  public TypedReleasableReferenceManagerDecorator(ReleasableReferenceManager delegate, M metadata) {
-    this.delegate = checkNotNull(delegate);
-    this.metadata = checkNotNull(metadata);
-  }
-
-  @Override
-  public Class<? extends Annotation> scope() {
-    return delegate.scope();
-  }
-
-  @Override
-  public M metadata() {
-    return metadata;
-  }
-
-  @Override
-  public void releaseStrongReferences() {
-    delegate.releaseStrongReferences();
-  }
-
-  @Override
-  public void restoreStrongReferences() {
-    delegate.restoreStrongReferences();
-  }
-}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index dc3ab271d..e2f8f8167 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -177,13 +177,11 @@ java_library(
         "BindsMethodValidator.java",
         "BindsOptionalOfMethodValidator.java",
         "BuilderValidator.java",
-        "CanReleaseReferencesValidator.java",
         "ComponentDescriptorValidator.java",
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
         "DependencyRequestValidator.java",
-        "ForReleasableReferencesValidator.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
         "MembersInjectionValidator.java",
@@ -292,9 +290,6 @@ java_library(
         "ProductionExecutorModuleGenerator.java",
         "ProviderInstanceBindingExpression.java",
         "PrunedConcreteMethodBindingExpression.java",
-        "ReferenceReleasingManagerFields.java",
-        "ReleasableReferenceManagerProviderCreationExpression.java",
-        "ReleasableReferenceManagerSetProviderCreationExpression.java",
         "SetBindingExpression.java",
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
@@ -329,7 +324,6 @@ java_library(
         "BindingGraphPlugins.java",
         "BindingGraphPluginsModule.java",
         "BindingMethodValidatorsModule.java",
-        "CanReleaseReferencesProcessingStep.java",
         "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
         "ComponentModelBuilder.java",
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 13a960c4e..72ece3ca1 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
@@ -30,7 +28,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import dagger.model.BindingKind;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeKind;
@@ -43,11 +40,6 @@
   private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
       immutableEnumSet(EXECUTABLE, DECLARED);
 
-  private static final ImmutableSet<BindingKind>
-      FORMATTABLE_ELEMENTLESS_BINDING_KINDS =
-          immutableEnumSet(
-              RELEASABLE_REFERENCE_MANAGER, RELEASABLE_REFERENCE_MANAGERS);
-
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   @Inject
@@ -56,14 +48,9 @@
   }
 
   /**
-   * Returns {@code true} for declarations that this formatter can format. Specifically:
-   *
-   * <ul>
-   * <li>Those with {@linkplain BindingDeclaration#bindingElement() binding elements} that are
-   *     methods, constructors, or types.
-   * <li>{@link BindingKind#RELEASABLE_REFERENCE_MANAGER} bindings.
-   * <li>{@link BindingKind#RELEASABLE_REFERENCE_MANAGERS} bindings.
-   * </ul>
+   * Returns {@code true} for declarations that this formatter can format. Specifically bindings
+   * from subcomponent declarations or those with {@linkplain BindingDeclaration#bindingElement()
+   * binding elements} that are methods, constructors, or types.
    */
   boolean canFormat(BindingDeclaration bindingDeclaration) {
     if (bindingDeclaration instanceof SubcomponentDeclaration) {
@@ -73,10 +60,6 @@ boolean canFormat(BindingDeclaration bindingDeclaration) {
       return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
           bindingDeclaration.bindingElement().get().asType().getKind());
     }
-    if (bindingDeclaration instanceof ContributionBinding) {
-      ContributionBinding contributionBinding = (ContributionBinding) bindingDeclaration;
-      return FORMATTABLE_ELEMENTLESS_BINDING_KINDS.contains(contributionBinding.kind());
-    }
     return false;
   }
 
@@ -105,12 +88,6 @@ public String format(BindingDeclaration bindingDeclaration) {
       }
     }
 
-    if (isReleasableReferenceManagerBinding(bindingDeclaration)) {
-      return String.format(
-          "binding for %s from the scope declaration",
-          stripCommonTypePrefixes(bindingDeclaration.key().toString()));
-    }
-
     return String.format(
         "Dagger-generated binding for %s",
         stripCommonTypePrefixes(bindingDeclaration.key().toString()));
@@ -143,9 +120,4 @@ private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponen
         annotationValue,
         subcomponentDeclaration.contributingModule().get());
   }
-
-  private boolean isReleasableReferenceManagerBinding(BindingDeclaration bindingDeclaration) {
-    return bindingDeclaration instanceof ContributionBinding
-        && ((ContributionBinding) bindingDeclaration).kind().equals(RELEASABLE_REFERENCE_MANAGER);
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 9406467c2..42ef6ff64 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -44,8 +44,6 @@
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.PRODUCTION;
 import static dagger.model.BindingKind.PROVISION;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -66,7 +64,6 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.ArrayList;
@@ -431,52 +428,6 @@ private ContributionBinding buildDelegateBinding(
         .build();
   }
 
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
-   * ReleasableReferenceManager}.
-   */
-  ProvisionBinding releasableReferenceManagerBinding(Scope scope) {
-    return ProvisionBinding.builder()
-        .contributionType(ContributionType.UNIQUE)
-        .key(keyFactory.forReleasableReferenceManager(scope))
-        .kind(RELEASABLE_REFERENCE_MANAGER)
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
-   * TypedReleasableReferenceManager<M>}.
-   */
-  ProvisionBinding typedReleasableReferenceManagerBinding(Scope scope, DeclaredType metadataType) {
-    return releasableReferenceManagerBinding(scope)
-        .toBuilder()
-        .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
-   * {@code ReleasableReferenceManager}s.
-   */
-  ProvisionBinding setOfReleasableReferenceManagersBinding() {
-    return ProvisionBinding.builder()
-        .contributionType(ContributionType.UNIQUE)
-        .key(keyFactory.forSetOfReleasableReferenceManagers())
-        .kind(RELEASABLE_REFERENCE_MANAGERS)
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
-   * {@code TypedReleasableReferenceManager<M>}s.
-   */
-  ProvisionBinding setOfTypedReleasableReferenceManagersBinding(DeclaredType metadataType) {
-    return setOfReleasableReferenceManagersBinding()
-        .toBuilder()
-        .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
-        .build();
-  }
-
   /**
    * Returns an {@link dagger.model.BindingKind#OPTIONAL} binding for {@code key}.
    *
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 9ec4d2aea..a55966dba 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -32,9 +32,6 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.Optional;
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
@@ -84,23 +81,6 @@ final ResolvedBindings resolvedBindings(BindingRequest request) {
 
   abstract ImmutableSet<BindingGraph> subgraphs();
 
-  /**
-   * The scopes in the graph that {@linkplain CanReleaseReferences can release their references} for
-   * which there is a dependency request for any of the following:
-   *
-   * <ul>
-   *   <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
-   *   <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *       {@code M} is the releasable-references metadata type for {@code scope}
-   *   <li>{@code Set<ReleasableReferenceManager>}
-   *   <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
-   *       the scope
-   * </ul>
-   *
-   * <p>This set is always empty for subcomponent graphs.
-   */
-  abstract ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers();
-
   /** Returns the resolved bindings for the dependencies of {@code binding}. */
   ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
     return binding
@@ -230,7 +210,6 @@ static BindingGraph create(
       ImmutableMap<Key, ResolvedBindings> resolvedContributionBindingsMap,
       ImmutableMap<Key, ResolvedBindings> resolvedMembersInjectionBindings,
       ImmutableSet<BindingGraph> subgraphs,
-      ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers,
       ImmutableSet<ModuleDescriptor> ownedModules,
       Optional<ExecutableElement> factoryMethod) {
     return new AutoValue_BindingGraph(
@@ -238,7 +217,6 @@ static BindingGraph create(
         resolvedContributionBindingsMap,
         resolvedMembersInjectionBindings,
         subgraphs,
-        scopesRequiringReleasableReferenceManagers,
         ownedModules,
         factoryMethod);
   }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 5e61db699..f62f73e1a 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -54,8 +54,6 @@
 import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -71,7 +69,6 @@
 import java.util.function.Function;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -164,10 +161,6 @@ private BindingGraph create(
       optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
     }
 
-    ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings =
-        getReleasableReferenceManagerBindings(componentDescriptor);
-    explicitBindingsBuilder.addAll(releasableReferenceManagerBindings.values());
-
     final Resolver requestResolver =
         new Resolver(
             parentResolver,
@@ -214,75 +207,10 @@ private BindingGraph create(
         resolvedContributionBindingsMap,
         requestResolver.getResolvedMembersInjectionBindings(),
         subgraphs.build(),
-        getScopesRequiringReleasableReferenceManagers(
-            releasableReferenceManagerBindings, resolvedContributionBindingsMap.keySet()),
         requestResolver.getOwnedModules(),
         requestResolver.getFactoryMethod());
   }
 
-  /**
-   * Returns the bindings for {@link ReleasableReferenceManager}s for all {@link
-   * CanReleaseReferences @CanReleaseReferences} scopes.
-   */
-  private ImmutableSetMultimap<Scope, ProvisionBinding> getReleasableReferenceManagerBindings(
-      ComponentDescriptor componentDescriptor) {
-    ImmutableSetMultimap.Builder<Scope, ProvisionBinding> bindings = ImmutableSetMultimap.builder();
-    // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
-    // none?
-    for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
-      // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
-      bindings.put(scope, bindingFactory.releasableReferenceManagerBinding(scope));
-
-      /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
-       * once, each instance will be equal to the rest. Since they're being added to a set, there
-       * will be only one instance. */
-      bindings.put(scope, bindingFactory.setOfReleasableReferenceManagersBinding());
-
-      for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-        // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
-        bindings.put(
-            scope,
-            bindingFactory.typedReleasableReferenceManagerBinding(
-                scope, metadata.getAnnotationType()));
-
-        /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
-         * than once, each instance will be equal to the rest. Since they're being added to a set,
-         * there will be only one instance. */
-        bindings.put(
-            scope,
-            bindingFactory.setOfTypedReleasableReferenceManagersBinding(
-                metadata.getAnnotationType()));
-      }
-    }
-    return bindings.build();
-  }
-
-  /**
-   * Returns the set of scopes that will be returned by {@link
-   * BindingGraph#scopesRequiringReleasableReferenceManagers()}.
-   *
-   * @param releasableReferenceManagerBindings the {@link ReleasableReferenceManager} bindings for
-   *     each scope
-   * @param resolvedContributionKeys the keys of the resolved bindings for the component
-   */
-  private ImmutableSet<Scope> getScopesRequiringReleasableReferenceManagers(
-      ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings,
-      ImmutableSet<Key> resolvedContributionKeys) {
-    ImmutableSet.Builder<Scope> scopes = ImmutableSet.builder();
-    releasableReferenceManagerBindings
-        .asMap()
-        .forEach(
-            (scope, bindings) -> {
-              for (Binding binding : bindings) {
-                if (resolvedContributionKeys.contains(binding.key())) {
-                  scopes.add(scope);
-                  return;
-                }
-              }
-            });
-    return scopes.build();
-  }
-
   /** Indexes {@code bindingDeclarations} by {@link BindingDeclaration#key()}. */
   private static <T extends BindingDeclaration>
       ImmutableSetMultimap<Key, T> indexBindingDeclarationsByKey(Iterable<T> declarations) {
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java b/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
deleted file mode 100644
index f3333dab3..000000000
--- a/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.inject.Scope;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * Processes annotations annotated with {@link CanReleaseReferences}. For each one that is not also
- * a {@link Scope}, generates a class that can create instances at runtime.
- */
-final class CanReleaseReferencesProcessingStep implements ProcessingStep {
-
-  private final Messager messager;
-  private final CanReleaseReferencesValidator canReleaseReferencesValidator;
-  private final AnnotationCreatorGenerator annotationCreatorGenerator;
-
-  @Inject
-  CanReleaseReferencesProcessingStep(
-      Messager messager,
-      CanReleaseReferencesValidator canReleaseReferencesValidator,
-      AnnotationCreatorGenerator annotationCreatorGenerator) {
-    this.messager = messager;
-    this.canReleaseReferencesValidator = canReleaseReferencesValidator;
-    this.annotationCreatorGenerator = annotationCreatorGenerator;
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(CanReleaseReferences.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement annotatedElement :
-        typesIn(elementsByAnnotation.get(CanReleaseReferences.class))) {
-      ValidationReport<TypeElement> report =
-          canReleaseReferencesValidator.validate(annotatedElement);
-      report.printMessagesTo(messager);
-      if (report.isClean() && !isAnnotationPresent(annotatedElement, Scope.class)) {
-        annotationCreatorGenerator.generate(annotatedElement, messager);
-      }
-    }
-    return ImmutableSet.of();
-  }
-}
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
deleted file mode 100644
index 5c79dab0a..000000000
--- a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
-
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.SimpleAnnotationValueVisitor7;
-
-/**
- * Validates that {@link CanReleaseReferences} are applied only to valid annotations.
- *
- * <p>They must not annotate annotations that have {@link RetentionPolicy#SOURCE}-level retention.
- */
-final class CanReleaseReferencesValidator {
-
-  @Inject CanReleaseReferencesValidator() {}
-
-  ValidationReport<TypeElement> validate(TypeElement annotatedElement) {
-    ValidationReport.Builder<TypeElement> report = ValidationReport.about(annotatedElement);
-    checkNoSourceRetention(annotatedElement, report);
-    return report.build();
-  }
-
-  private void checkNoSourceRetention(
-      TypeElement annotatedElement, ValidationReport.Builder<TypeElement> report) {
-    getAnnotationMirror(annotatedElement, Retention.class)
-        .ifPresent(
-            retention -> {
-              if (getRetentionPolicy(retention).equals(SOURCE)) {
-                report.addError(
-                    "@CanReleaseReferences annotations must not have SOURCE retention",
-                    report.getSubject(),
-                    retention);
-              }
-            });
-  }
-
-  // TODO(dpb): Move the ability to get an annotation type's retention policy somewhere common.
-  private RetentionPolicy getRetentionPolicy(AnnotationMirror retention) {
-    return getAnnotationValue(retention, "value")
-        .accept(
-            new SimpleAnnotationValueVisitor7<RetentionPolicy, Void>() {
-              @Override
-              public RetentionPolicy visitEnumConstant(VariableElement element, Void p) {
-                return RetentionPolicy.valueOf(element.getSimpleName().toString());
-              }
-            },
-            null);
-  }
-}
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 528413793..91a0cd0b7 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
@@ -60,7 +59,6 @@
   private final BindingGraph graph;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentRequirementFields componentRequirementFields;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private final OptionalFactories optionalFactories;
   private final DaggerTypes types;
   private final DaggerElements elements;
@@ -84,7 +82,6 @@
         graph,
         generatedComponentModel,
         componentRequirementFields,
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel, compilerOptions),
         new StaticSwitchingProviders(generatedComponentModel, types),
         optionalFactories,
         types,
@@ -97,7 +94,6 @@ private ComponentBindingExpressions(
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
       ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
       StaticSwitchingProviders staticSwitchingProviders,
       OptionalFactories optionalFactories,
       DaggerTypes types,
@@ -107,7 +103,6 @@ private ComponentBindingExpressions(
     this.graph = graph;
     this.generatedComponentModel = generatedComponentModel;
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
@@ -138,7 +133,6 @@ ComponentBindingExpressions forChildComponent(
         childGraph,
         childComponentModel,
         childComponentRequirementFields,
-        referenceReleasingManagerFields,
         staticSwitchingProviders,
         optionalFactories,
         types,
@@ -320,21 +314,11 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
 
   private FrameworkInstanceCreationExpression scope(
       ResolvedBindings resolvedBindings, FrameworkInstanceCreationExpression unscoped) {
-    if (requiresReleasableReferences(resolvedBindings)) {
-      return () ->
-          CodeBlock.of(
-              "$T.create($L, $L)",
-              REFERENCE_RELEASING_PROVIDER,
-              unscoped.creationExpression(),
-              referenceReleasingManagerFields.getExpression(
-                  resolvedBindings.scope().get(), generatedComponentModel.name()));
-    } else {
-      return () ->
-          CodeBlock.of(
-              "$T.provider($L)",
-              resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
-              unscoped.creationExpression());
-    }
+    return () ->
+        CodeBlock.of(
+            "$T.provider($L)",
+            resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
+            unscoped.creationExpression());
   }
 
   /**
@@ -387,14 +371,6 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
         return new MapFactoryCreationExpression(
             binding, generatedComponentModel, this, graph, elements);
 
-      case RELEASABLE_REFERENCE_MANAGER:
-        return new ReleasableReferenceManagerProviderCreationExpression(
-            binding, generatedComponentModel, referenceReleasingManagerFields);
-
-      case RELEASABLE_REFERENCE_MANAGERS:
-        return new ReleasableReferenceManagerSetProviderCreationExpression(
-            binding, generatedComponentModel, referenceReleasingManagerFields, graph);
-
       case DELEGATE:
         return new DelegatingFrameworkInstanceCreationExpression(
             binding, generatedComponentModel, this);
@@ -524,9 +500,6 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
    * instance of this binding, return it, wrapped in a method if the binding {@linkplain
    * #needsCaching(ResolvedBindings) needs to be cached} or the expression has dependencies.
    *
-   * <p>In default mode, we can use direct expressions for bindings that don't need to be cached in
-   * a reference-releasing scope.
-   *
    * <p>In fastInit mode, we can use direct expressions unless the binding needs to be cached.
    */
   private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
@@ -614,9 +587,6 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
                 elements));
 
       case MEMBERS_INJECTOR:
-      case RELEASABLE_REFERENCE_MANAGER:
-      case RELEASABLE_REFERENCE_MANAGERS:
-        // TODO(dpb): Implement direct expressions for these.
         return Optional.empty();
 
       case MEMBERS_INJECTION:
@@ -648,12 +618,10 @@ private boolean useStaticFactoryCreation(ContributionBinding binding) {
    * we can.
    *
    * <p>In fastInit mode, we can use a direct expression even if the binding {@linkplain
-   * #needsCaching(ResolvedBindings) needs to be cached} as long as it's not in a
-   * reference-releasing scope.
+   * #needsCaching(ResolvedBindings) needs to be cached}.
    */
   private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings) {
-    return !needsCaching(resolvedBindings)
-        || (compilerOptions.fastInit() && !requiresReleasableReferences(resolvedBindings));
+    return !needsCaching(resolvedBindings) || compilerOptions.fastInit();
   }
 
   /**
@@ -744,11 +712,4 @@ private boolean needsCaching(ResolvedBindings resolvedBindings) {
     }
     return true;
   }
-
-  // TODO(user): Enable releasable references in fastInit
-  private boolean requiresReleasableReferences(ResolvedBindings resolvedBindings) {
-    return resolvedBindings.scope().isPresent()
-        && referenceReleasingManagerFields.requiresReleasableReferences(
-            resolvedBindings.scope().get());
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 8b8c35e3c..a5f1f1538 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -46,7 +46,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import com.google.common.graph.Traverser;
 import com.squareup.javapoet.ClassName;
 import dagger.BindsInstance;
 import dagger.Component;
@@ -58,7 +57,6 @@
 import dagger.producers.CancellationPolicy;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
-import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
@@ -353,23 +351,6 @@ private static boolean doesComponentMethodMatch(
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
 
-  /**
-   * For {@link Component @Component}s, all {@link CanReleaseReferences @CanReleaseReferences}
-   * scopes associated with this component or any subcomponent. Otherwise empty.
-   */
-  ImmutableSet<Scope> releasableReferencesScopes() {
-    return kind().equals(Kind.COMPONENT)
-        ? FluentIterable.from(SUBCOMPONENT_TRAVERSER.breadthFirst(this))
-            .transformAndConcat(ComponentDescriptor::scopes)
-            .filter(Scope::canReleaseReferences)
-            .toSet()
-        : ImmutableSet.<Scope>of();
-  }
-
-  /** {@link Traverser} for the subcomponent tree. */
-  private static final Traverser<ComponentDescriptor> SUBCOMPONENT_TRAVERSER =
-      Traverser.forTree(ComponentDescriptor::subcomponents);
-
   /**
    * Returns the {@link CancellationPolicy} for this component, or an empty optional if either the
    * component is not a production component or no {@code CancellationPolicy} annotation is present.
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 0a48df17f..2beaad439 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -152,8 +152,6 @@ Builder testingPlugins(
     @Provides
     static ImmutableList<ProcessingStep> processingSteps(
         MapKeyProcessingStep mapKeyProcessingStep,
-        ForReleasableReferencesValidator forReleasableReferencesValidator,
-        CanReleaseReferencesProcessingStep canReleaseReferencesProcessingStep,
         InjectProcessingStep injectProcessingStep,
         MonitoringModuleProcessingStep monitoringModuleProcessingStep,
         ProductionExecutorModuleProcessingStep productionExecutorModuleProcessingStep,
@@ -166,8 +164,6 @@ Builder testingPlugins(
         CompilerOptions compilerOptions) {
       return ImmutableList.of(
           mapKeyProcessingStep,
-          forReleasableReferencesValidator,
-          canReleaseReferencesProcessingStep,
           injectProcessingStep,
           monitoringModuleProcessingStep,
           productionExecutorModuleProcessingStep,
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index aaafe6f87..8f1ed0c55 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -26,7 +26,6 @@
 
 import com.squareup.javapoet.ClassName;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@link BindingExpression} for {@code @Binds} methods. */
@@ -113,21 +112,15 @@ private Expression castToRawTypeIfNecessary(
 
   private enum ScopeKind {
     UNSCOPED,
-    RELEASABLE,
     SINGLE_CHECK,
     DOUBLE_CHECK,
     ;
 
     static ScopeKind get(Binding binding, BindingGraph graph) {
-      if (!binding.scope().isPresent()) {
-        return UNSCOPED;
-      }
-
-      Scope scope = binding.scope().get();
-      if (graph.scopesRequiringReleasableReferenceManagers().contains(scope)) {
-        return RELEASABLE;
-      }
-      return scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK;
+      return binding
+          .scope()
+          .map(scope -> scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK)
+          .orElse(UNSCOPED);
     }
 
     boolean isStrongerScopeThan(ScopeKind other) {
diff --git a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
deleted file mode 100644
index df8d3b969..000000000
--- a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.Scopes.scope;
-import static dagger.model.Scope.isScope;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/** Validates uses of {@link ForReleasableReferences @ForReleasableReferences}. */
-final class ForReleasableReferencesValidator implements ProcessingStep {
-
-  private final Messager messager;
-
-  @Inject
-  ForReleasableReferencesValidator(Messager messager) {
-    this.messager = messager;
-  }
-
-  ValidationReport<Element> validateAnnotatedElement(Element annotatedElement) {
-    checkArgument(isAnnotationPresent(annotatedElement, ForReleasableReferences.class));
-    ValidationReport.Builder<Element> report = ValidationReport.about(annotatedElement);
-    AnnotationMirror annotation =
-        getAnnotationMirror(annotatedElement, ForReleasableReferences.class).get();
-    TypeElement scopeType = MoreTypes.asTypeElement(getTypeValue(annotation, "value"));
-    if (!isScope(scopeType)) {
-      report.addError(
-          forReleasableReferencesValueNotAScope(scopeType), annotatedElement, annotation);
-    } else if (!scope(scopeType).canReleaseReferences()) {
-      report.addError(
-          forReleasableReferencesValueCannotReleaseReferences(scopeType),
-          annotatedElement,
-          annotation);
-    }
-    return report.build();
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(ForReleasableReferences.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    elementsByAnnotation
-        .get(ForReleasableReferences.class)
-        .stream()
-        .map(this::validateAnnotatedElement)
-        .forEach(report -> report.printMessagesTo(messager));
-    return ImmutableSet.of();
-  }
-
-  private static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType,
-        String.format(
-            "@%s and @%s",
-            javax.inject.Scope.class.getCanonicalName(),
-            CanReleaseReferences.class.getCanonicalName()));
-  }
-
-  private static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
-  }
-
-  private static String forReleasableReferencesValueNeedsAnnotation(
-      TypeElement scopeType, String annotations) {
-    return String.format(
-        "The value of @%s must be a reference-releasing scope. "
-            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
-        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
-  }
-}
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 65bbbf5f7..c8a535060 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -44,7 +44,6 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -65,8 +64,8 @@
 /** The model of the component being generated. */
 final class GeneratedComponentModel {
   /** A type of field that this component model can generate. */
-  // TODO(user, dpb): Move component requirements and reference managers to top? The order should
-  // be component requirements, reference managers, framework fields, private method fields, ... etc
+  // TODO(user, dpb): Move component requirements to top? The order should be component
+  // requirements, framework fields, private method fields, ... etc
   enum FieldSpecKind {
 
     /**
@@ -81,9 +80,6 @@
     /** A framework field for type T, e.g. Provider<T>. */
     FRAMEWORK_FIELD,
 
-    /** A field for a {@link ReferenceReleasingProviderManager}. */
-    REFERENCE_RELEASING_MANAGER_FIELD,
-
     /** A static field that always returns an absent {@code Optional} value for the binding. */
     ABSENT_OPTIONAL_FIELD
   }
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 645c2193e..22e644887 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -33,23 +33,18 @@
 import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.model.Key;
 import dagger.model.Key.MultibindingContributionIdentifier;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
 import dagger.producers.monitoring.ProductionComponentMonitor;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -99,11 +94,6 @@ private TypeMirror mapOfFrameworkType(
     return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
   }
 
-  private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
-    return types.getDeclaredType(
-        getClassElement(TypedReleasableReferenceManager.class), metadataType);
-  }
-
   Key forComponentMethod(ExecutableElement componentMethod) {
     checkArgument(componentMethod.getKind().equals(METHOD));
     return forMethod(componentMethod, componentMethod.getReturnType());
@@ -441,39 +431,4 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
             .type(extractKeyType(getRequestKind(optionalValueType), optionalValueType))
             .build());
   }
-
-  /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
-  Key forReleasableReferenceManager(Scope scope) {
-    return forQualifiedType(
-        Optional.of(forReleasableReferencesAnnotationMirror(scope)),
-        getClassElement(ReleasableReferenceManager.class).asType());
-  }
-
-  /**
-   * Returns a key for a {@code @ForReleasableReferences(scope)
-   * TypedReleasableReferenceManager<metadataType>}
-   */
-  Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
-    return Key.builder(typedReleasableReferenceManagerOf(metadataType))
-        .qualifier(forReleasableReferencesAnnotationMirror(scope))
-        .build();
-  }
-
-  /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
-  Key forSetOfReleasableReferenceManagers() {
-    return Key.builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
-  }
-
-  /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
-  Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
-    return forQualifiedType(
-        Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
-  }
-
-  private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
-    return SimpleAnnotationMirror.of(
-        getClassElement(ForReleasableReferences.class),
-        ImmutableMap.of(
-            "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
-  }
 }
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index 0e1e7a7e6..74097d5e6 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -16,23 +16,13 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asTypeElement;
-import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
-import static dagger.internal.codegen.Scopes.getReadableSource;
-import static java.util.function.Predicate.isEqual;
-import static java.util.stream.Collectors.toList;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-import com.google.auto.common.MoreTypes;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
@@ -40,35 +30,22 @@
 import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.Key;
-import dagger.model.Scope;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
-import java.util.List;
-import java.util.Optional;
-import java.util.stream.Stream;
 import javax.inject.Inject;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 
 /** Reports errors for missing bindings. */
 final class MissingBindingValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
-  private final DaggerElements elements;
   private final InjectBindingRegistry injectBindingRegistry;
 
   @Inject
   MissingBindingValidator(
-      DaggerTypes types, DaggerElements elements, InjectBindingRegistry injectBindingRegistry) {
+      DaggerTypes types, InjectBindingRegistry injectBindingRegistry) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.elements = elements;
   }
 
   @Override
@@ -88,10 +65,7 @@ private void reportMissingBinding(
       BindingGraph graph,
       DiagnosticReporter diagnosticReporter) {
     diagnosticReporter.reportBinding(
-        ERROR,
-        missingBindingNode,
-        missingReleasableReferenceManagerBindingErrorMessage(missingBindingNode, graph)
-            .orElseGet(() -> missingBindingErrorMessage(missingBindingNode, graph)));
+        ERROR, missingBindingNode, missingBindingErrorMessage(missingBindingNode, graph));
   }
 
   private String missingBindingErrorMessage(
@@ -149,77 +123,4 @@ private boolean typeHasInjectionSites(Key key) {
         .map(binding -> !binding.injectionSites().isEmpty())
         .orElse(false);
   }
-
-  /**
-   * If {@code missingBindingNode}'s key is for an invalid {@code @ForReleasableReferences}, returns
-   * a more specific error message.
-   *
-   * <p>An invalid key is one whose type is either {@link ReleasableReferenceManager} or {@link
-   * TypedReleasableReferenceManager}, and whose scope:
-   *
-   * <ul>
-   *   <li>does not annotate any component in the hierarchy, or
-   *   <li>is not annotated with the metadata annotation type that is the {@link
-   *       TypedReleasableReferenceManager}'s type argument
-   * </ul>
-   */
-  private Optional<String> missingReleasableReferenceManagerBindingErrorMessage(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    Key key = missingBindingNode.key();
-    if (!key.qualifier().isPresent()
-        || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
-        || !isType(key.type())) {
-      return Optional.empty();
-    }
-
-    Optional<DeclaredType> metadataType;
-    if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
-      metadataType = Optional.empty();
-    } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
-      List<? extends TypeMirror> typeArguments =
-          MoreTypes.asDeclared(key.type()).getTypeArguments();
-      if (typeArguments.size() != 1 || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
-        return Optional.empty();
-      }
-      metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
-    } else {
-      return Optional.empty();
-    }
-
-    Scope scope = Scopes.scope(asTypeElement(getTypeValue(key.qualifier().get(), "value")));
-    if (releasableReferencesScopes(graph).noneMatch(isEqual(scope))) {
-      return Optional.of(
-          String.format(
-              "There is no binding for %s because no component in %s's component hierarchy is "
-                  + "annotated with %s. The available reference-releasing scopes are %s.",
-              key,
-              graph.rootComponentNode().componentPath().currentComponent().getQualifiedName(),
-              getReadableSource(scope),
-              releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
-    }
-    if (metadataType.isPresent()) {
-      TypeElement metadataTypeElement = asTypeElement(metadataType.get());
-      if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
-        return Optional.of(notAnnotated(key, scope.scopeAnnotationElement(), metadataTypeElement));
-      }
-      if (!isAnnotationPresent(metadataTypeElement, CanReleaseReferences.class)) {
-        return Optional.of(
-            notAnnotated(
-                key, metadataTypeElement, elements.getTypeElement(CanReleaseReferences.class)));
-      }
-    }
-    return Optional.empty();
-  }
-
-  private static String notAnnotated(Key key, TypeElement type, TypeElement annotation) {
-    return String.format(
-        "There is no binding for %s because %s is not annotated with @%s.",
-        key, type.getQualifiedName(), annotation);
-  }
-
-  private Stream<Scope> releasableReferencesScopes(BindingGraph graph) {
-    return graph.componentNodes().stream()
-        .flatMap(node -> node.scopes().stream())
-        .filter(Scope::canReleaseReferences);
-  }
 }
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
deleted file mode 100644
index 0a42fb2ac..000000000
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.REFERENCE_RELEASING_MANAGER_FIELD;
-import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
-import dagger.model.Scope;
-import java.util.HashMap;
-import java.util.Map;
-import javax.lang.model.element.AnnotationMirror;
-
-/**
- * Manages the {@link dagger.internal.ReferenceReleasingProviderManager} fields and the logic for
- * releasable bindings in the graph.
- *
- * <p>This class should only be created once at the root component and reused by all subcomponents.
- * This is because, currently, all {@link dagger.internal.ReferenceReleasingProviderManager} fields
- * are stored in the root component.
- */
-public class ReferenceReleasingManagerFields {
-  /**
-   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
-   * indexed by their {@code CanReleaseReferences @CanReleaseReferences} scope.
-   */
-  private final Map<Scope, MemberSelect> referenceReleasingManagerFields = new HashMap<>();
-
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-
-  ReferenceReleasingManagerFields(
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      CompilerOptions compilerOptions) {
-    this.graph = checkNotNull(graph);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    if (!compilerOptions.aheadOfTimeSubcomponents()) {
-      checkArgument(graph.componentDescriptor().kind().isTopLevel());
-    }
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  static CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T<$T>($L, $L)",
-        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-        metadata.getAnnotationType(),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  /**
-   * Returns {@code true} if {@code scope} is in {@link
-   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
-   */
-  boolean requiresReleasableReferences(Scope scope) {
-    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
-  }
-
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  CodeBlock getExpression(Scope scope, ClassName requestingClass) {
-    return reentrantComputeIfAbsent(
-            referenceReleasingManagerFields, scope, this::createReferenceReleasingManagerField)
-        .getExpressionFor(requestingClass);
-  }
-
-  private MemberSelect createReferenceReleasingManagerField(Scope scope) {
-    FieldSpec field = referenceReleasingProxyManagerField(scope);
-    generatedComponentModel.addField(REFERENCE_RELEASING_MANAGER_FIELD, field);
-    return localField(generatedComponentModel.name(), field.name);
-  }
-
-  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
-    String fieldName =
-        UPPER_CAMEL.to(LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References");
-    return FieldSpec.builder(
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            generatedComponentModel.getUniqueFieldName(fieldName))
-        .addModifiers(PRIVATE, FINAL)
-        .initializer(
-            "new $T($T.class)",
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            scope.scopeAnnotationElement())
-        .addJavadoc(
-            "The manager that releases references for the {@link $T} scope.\n",
-            scope.scopeAnnotationElement())
-        .build();
-  }
-}
diff --git a/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java b/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java
deleted file mode 100644
index 083244c19..000000000
--- a/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.ReferenceReleasingManagerFields.typedReleasableReferenceManagerDecoratorExpression;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.model.Scope;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link dagger.releasablereferences.ReleasableReferenceManager
- * Provider<ReleasableReferenceManager>} creation expression.
- *
- * <p>The {@code get()} method just returns the component's {@link
- * dagger.internal.ReferenceReleasingProviderManager} field.
- */
-final class ReleasableReferenceManagerProviderCreationExpression
-    implements FrameworkInstanceCreationExpression {
-
-  private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-
-  ReleasableReferenceManagerProviderCreationExpression(
-      ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields) {
-    this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-  }
-
-  @Override
-  public CodeBlock creationExpression() {
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", releasableReferenceManagerExpression())
-                    .build())
-            .build());
-  }
-
-  private CodeBlock releasableReferenceManagerExpression() {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      return typedReleasableReferenceManagerDecoratorExpression(
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()),
-          scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      return referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-    }
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scopes.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
-  }
-}
diff --git a/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java b/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java
deleted file mode 100644
index 078fd6b4a..000000000
--- a/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ReferenceReleasingManagerFields.typedReleasableReferenceManagerDecoratorExpression;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.common.collect.ImmutableList;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.model.Scope;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Optional;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link ReleasableReferenceManager Provider<Set<ReleasableReferenceManager>>} creation
- * expression.
- *
- * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
- * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
- * include managers for all reference-releasing scopes whose metadata type is {@code M}.
- */
-final class ReleasableReferenceManagerSetProviderCreationExpression
-    implements FrameworkInstanceCreationExpression {
-  private final ContributionBinding binding;
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-
-  ReleasableReferenceManagerSetProviderCreationExpression(
-      ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
-      BindingGraph graph) {
-    this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-    this.graph = checkNotNull(graph);
-  }
-
-  @Override
-  public CodeBlock creationExpression() {
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(releasableReferenceManagerExpressions()))
-                    .build())
-            .build());
-  }
-
-  private ImmutableList<CodeBlock> releasableReferenceManagerExpressions() {
-    SetType keyType = SetType.from(binding.key());
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
-      CodeBlock releasableReferenceManagerExpression =
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    return managerExpressions.build();
-  }
-}
diff --git a/java/dagger/internal/codegen/TypeNames.java b/java/dagger/internal/codegen/TypeNames.java
index ed2ee286b..2b590d4b4 100644
--- a/java/dagger/internal/codegen/TypeNames.java
+++ b/java/dagger/internal/codegen/TypeNames.java
@@ -31,11 +31,8 @@
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.ProviderOfLazy;
-import dagger.internal.ReferenceReleasingProvider;
-import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.SetFactory;
 import dagger.internal.SingleCheck;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -87,17 +84,11 @@
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
   static final ClassName RUNNABLE = ClassName.get(Runnable.class);
-  static final ClassName REFERENCE_RELEASING_PROVIDER =
-      ClassName.get(ReferenceReleasingProvider.class);
-  static final ClassName REFERENCE_RELEASING_PROVIDER_MANAGER =
-      ClassName.get(ReferenceReleasingProviderManager.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
-  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR =
-      ClassName.get(TypedReleasableReferenceManagerDecorator.class);
 
   /**
    * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
diff --git a/java/dagger/model/BindingKind.java b/java/dagger/model/BindingKind.java
index 3ea2f9c93..0c9bb35b8 100644
--- a/java/dagger/model/BindingKind.java
+++ b/java/dagger/model/BindingKind.java
@@ -83,18 +83,6 @@
    */
   OPTIONAL,
 
-  /**
-   * A binding for a {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager} object for a scope.
-   */
-  RELEASABLE_REFERENCE_MANAGER,
-
-  /**
-   * A binding for a set of {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager} objects.
-   */
-  RELEASABLE_REFERENCE_MANAGERS,
-
   /**
    * A binding for {@link dagger.Binds}-annotated method that that delegates from requests for one
    * key to another.
diff --git a/java/dagger/model/Scope.java b/java/dagger/model/Scope.java
index 541a69f0b..7d255e1ca 100644
--- a/java/dagger/model/Scope.java
+++ b/java/dagger/model/Scope.java
@@ -16,7 +16,6 @@
 
 package dagger.model;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -25,16 +24,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableSet;
 import dagger.Reusable;
 import dagger.producers.ProductionScope;
-import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
-import java.util.Optional;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 /** A representation of a {@link javax.inject.Scope}. */
 @AutoValue
@@ -93,41 +88,6 @@ private boolean isScope(Class<? extends Annotation> annotation) {
     return scopeAnnotationElement().getQualifiedName().contentEquals(annotation.getCanonicalName());
   }
 
-  /**
-   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
-   * other annotation that is itself annotated with {@link CanReleaseReferences}.
-   */
-  // Implementation note: you need to check
-  // BindingGraph.scopesRequiringReleasableReferenceManagers() to see if a given binding graph
-  // actually binds a ReleasableReferenceManager for this scope.
-  public final boolean canReleaseReferences() {
-    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
-        || !releasableReferencesMetadata().isEmpty();
-  }
-
-  /**
-   * Returns the set of annotations on the scope that are themselves annotated with {@link
-   * CanReleaseReferences}. These annotations are used as metadata for {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager}.
-   */
-  public final ImmutableSet<AnnotationMirror> releasableReferencesMetadata() {
-    return ImmutableSet.copyOf(
-        getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class));
-  }
-
-  /**
-   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
-   * annotation of the given type, if there is one for this scope.
-   */
-  public final Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
-    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
-      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
-        return Optional.of(metadata);
-      }
-    }
-    return Optional.empty();
-  }
-
   /** Returns a debug representation of the scope. */
   @Override
   public String toString() {
diff --git a/java/dagger/releasablereferences/CanReleaseReferences.java b/java/dagger/releasablereferences/CanReleaseReferences.java
deleted file mode 100644
index b240b0442..000000000
--- a/java/dagger/releasablereferences/CanReleaseReferences.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
- * objects stored within that scope can be <a
- * href="https://google.github.io/dagger/users-guide.html#releasable-references">released</a> during the lifetime
- * of the scope.
- *
- * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
- * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @CanReleaseReferences}
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * or:
- *
- * <pre>
- *   {@literal @CanReleaseReferences}
- *   public {@literal @interface} SomeAnnotation {}
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @SomeAnnotation}
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target(ANNOTATION_TYPE)
-@Deprecated
-public @interface CanReleaseReferences {}
diff --git a/java/dagger/releasablereferences/ForReleasableReferences.java b/java/dagger/releasablereferences/ForReleasableReferences.java
deleted file mode 100644
index e8cd4a48a..000000000
--- a/java/dagger/releasablereferences/ForReleasableReferences.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Qualifier;
-
-/**
- * A {@link Qualifier} to inject a {@link ReleasableReferenceManager} or {@link
- * TypedReleasableReferenceManager} object for a particular scope.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @CanReleaseReferences}
- *   {@literal @Scope}
- *   {@literal public @interface} MyScope {}
- *
- *   {@literal @CanReleaseReferences}
- *   {@literal public @interface} MyMetadata {
- *     int value();
- *   }
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @MyMetadata}(15)
- *   {@literal @Scope}
- *   {@literal public @interface YourScope} {}
- *
- *   class MyClass {
- *     {@literal @Inject}
- *     MyClass(
- *         {@literal @ForReleasableReferences(MyScope.class)}
- *         ReleasableReferenceManager myScopeReferenceManager,
- *         {@literal @ForReleasableReferences(YourScope.class)}
- *         {@literal TypedReleasableReferenceManager<MyMetadata>} yourScopeReferenceManager) {
- *       // 
- *     }
- *   }
- * </pre>
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target({FIELD, PARAMETER, METHOD})
-@Retention(RUNTIME)
-@Qualifier
-@Deprecated
-public @interface ForReleasableReferences {
-  /** The {@linkplain CanReleaseReferences reference-releasing} scope annotation type. */
-  Class<? extends Annotation> value();
-}
diff --git a/java/dagger/releasablereferences/ReleasableReferenceManager.java b/java/dagger/releasablereferences/ReleasableReferenceManager.java
deleted file mode 100644
index 506bee25f..000000000
--- a/java/dagger/releasablereferences/ReleasableReferenceManager.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import javax.inject.Provider;
-
-/**
- * An object that can <a href="https://google.github.io/dagger/users-guide.html#releasable-references">release or
- * restore strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
- *
- * <p>Your top-level component can provide a {@link
- * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
- * object for any {@link CanReleaseReferences @CanReleaseReferences}-annotated scope {@code Foo}
- * anywhere in your component hierarchy.
- *
- * <p>It can also provide a {@code Set<ReleasableReferenceManager>} that contains all such objects.
- *
- * <p>Each provider in the {@link CanReleaseReferences @CanReleaseReferences} {@link #scope()} can
- * be in any one of four states at a time:
- *
- * <ul>
- *   <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link
- *       WeakReference} are both {@code null}.
- *   <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
- *       WeakReference}'s value is {@code null}.
- *   <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached
- *       value, and its {@link WeakReference} is {@code null}.
- *   <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
- *       {@link WeakReference}'s value is not {@code null}.
- * </ul>
- *
- * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
- *
- * <p>Calling {@link Provider#get()} on a provider within {@link #scope()} transitions it to
- * <b>strong-reference</b> state if it was in <b>uninitialized</b> or <b>empty</b> state.
- *
- * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
- * in <b>strong-reference</b> state to <b>weak-reference</b> state.
- *
- * <p>{@link #restoreStrongReferences()} transitions all providers within {@link #scope()} that are
- * in <b>weak-reference</b> state to <b>strong-reference</b> state.
- *
- * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
- * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
- * state.
- *
- * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png"
- * alt="ReleasableReferenceManager state machine">
- *
- * <p>This interface is implemented by Dagger.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public interface ReleasableReferenceManager {
-
-  /** The scope whose references are managed by this object. */
-  Class<? extends Annotation> scope();
-
-  /**
-   * Releases the strong references held by all providers in this {@linkplain #scope() scope} to the
-   * objects previously returned by {@link Provider#get()}, leaving only {@link WeakReference}s.
-   *
-   * <p>If any such {@link WeakReference} is cleared during garbage collection, the next call to
-   * that {@link Provider#get()} will execute the underlying binding again, and the provider will
-   * hold a strong reference to the new returned value.
-   *
-   * <p>Calls to {@link Provider#get()} on any such provider return the weakly-referenced object
-   * until the {@link WeakReference} is cleared or {@link #restoreStrongReferences()} is called.
-   */
-  void releaseStrongReferences();
-
-  /**
-   * Restores strong references for all providers in this {@linkplain #scope() scope} that were
-   * previously {@linkplain #releaseStrongReferences() released} but whose {@link WeakReference} has
-   * not yet been cleared during garbage collection.
-   */
-  void restoreStrongReferences();
-}
diff --git a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
deleted file mode 100644
index eb42b7898..000000000
--- a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-
-/**
- * A {@link ReleasableReferenceManager} for a scope that is annotated with an annotation that itself
- * is annotated with {@link CanReleaseReferences}. That annotation is available as {@link
- * #metadata()} and may be useful at runtime to decide when to release references held by the scope.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @CanReleaseReferences}
- *   public {@literal @interface} SomeAnnotation {
- *     int value();
- *   }
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @SomeAnnotation}(15)
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}
- *
- *   // In a component that is (or has a subcomponent) annotated with {@literal @MyScope}:
- *   {@literal @Inject}
- *   void manager(
- *       {@literal @ForReferenceReleasingScope(MyScope.class)}
- *       {@literal TypedReferenceReleasingScope<SomeAnnotation>} manager) {
- *     manager.metadata().value(); // returns 15
- *   }</pre>
- *
- * <p>This interface is implemented by Dagger.
- *
- * @param <M> the type of the metadata annotation
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public interface TypedReleasableReferenceManager<M extends Annotation>
-    extends ReleasableReferenceManager {
-
-  /**
-   * Returns the annotation on {@link #scope()} that is annotated with {@link CanReleaseReferences}.
-   */
-  M metadata();
-}
diff --git a/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png b/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png
deleted file mode 100644
index 6400f1d23..000000000
Binary files a/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png and /dev/null differ
diff --git a/java/dagger/releasablereferences/package-info.java b/java/dagger/releasablereferences/package-info.java
deleted file mode 100644
index a306bdbdc..000000000
--- a/java/dagger/releasablereferences/package-info.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This package contains the API by which Dagger allows you <a
- * href="https://google.github.io/dagger/users-guide.html#releasable-references">release references</a> held within
- * some scopes.
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @since 2.8
- */
-package dagger.releasablereferences;
diff --git a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
deleted file mode 100644
index df0c890bf..000000000
--- a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.android.functional.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-/** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
-@RunWith(RobolectricTestRunner.class)
-public final class AndroidMemorySensitiveReferenceManagerTest {
-
-  private TestModule testModule;
-  private TestComponent component;
-
-  @Before
-  public void setUp() {
-    testModule = new TestModule();
-    component = DaggerTestComponent.builder().testModule(testModule).build();
-  }
-
-  @Test
-  public void scoped() {
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_aboveThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_COMPLETE);
-    GcFinalization.awaitDone(
-        allWeakReferencesCleared(
-            component.releasedWhenUiHidden(), component.releasedWhenModerate()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(2);
-  }
-
-  @Test
-  public void onTrimMemory_atOneThresholdBelowAnother() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    GcFinalization.awaitDone(allWeakReferencesCleared(component.releasedWhenUiHidden()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_belowThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_restore() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  static final class AllWeakReferencesCleared implements FinalizationPredicate {
-
-    private final ImmutableList<WeakReference<Object>> references;
-
-    AllWeakReferencesCleared(ImmutableList<WeakReference<Object>> references) {
-      this.references = references;
-    }
-
-    @Override
-    public boolean isDone() {
-      for (WeakReference<Object> reference : references) {
-        if (reference.get() != null) {
-          return false;
-        }
-      }
-      return true;
-    }
-
-    static AllWeakReferencesCleared allWeakReferencesCleared(Object... objects) {
-      ImmutableList.Builder<WeakReference<Object>> referencesBuilder = ImmutableList.builder();
-      for (Object object : objects) {
-        referencesBuilder.add(new WeakReference<>(object));
-      }
-      return new AllWeakReferencesCleared(referencesBuilder.build());
-    }
-  }
-}
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
deleted file mode 100644
index f975dede8..000000000
--- a/javatests/dagger/android/functional/BUILD
+++ /dev/null
@@ -1,67 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional test code for Dagger-Android
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-)
-load("//:test_defs.bzl", "GenRobolectricTests")
-
-# Sample code to be tested in functional tests.
-android_library(
-    name = "code_under_test",
-    srcs = glob(
-        ["*.java"],
-        exclude = ["*Test.java"],
-    ),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
-        # used without a Guava and jsr305 deps.
-        "//:dagger_with_compiler",
-        "//:android",
-    ],
-)
-
-GenRobolectricTests(
-    name = "android_functional_tests",
-    srcs = glob(["*Test.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        ":code_under_test",
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/guava:testlib",
-        "@google_bazel_common//third_party/java/junit",
-        "@google_bazel_common//third_party/java/truth",
-    ],
-)
-
-GenRobolectricTests(
-    name = "android_functional_tests_with_aot",
-    srcs = glob(["*Test.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    with_aot = True,
-    deps = [
-        ":code_under_test",
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/guava:testlib",
-        "@google_bazel_common//third_party/java/junit",
-        "@google_bazel_common//third_party/java/truth",
-    ],
-)
diff --git a/javatests/dagger/android/functional/InScope.java b/javatests/dagger/android/functional/InScope.java
deleted file mode 100644
index 295ee069c..000000000
--- a/javatests/dagger/android/functional/InScope.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import java.lang.annotation.Annotation;
-import javax.inject.Qualifier;
-
-@Qualifier
-@interface InScope {
-  Class<? extends Annotation> value();
-}
diff --git a/javatests/dagger/android/functional/ReleaseWhenModerate.java b/javatests/dagger/android/functional/ReleaseWhenModerate.java
deleted file mode 100644
index c8971b42d..000000000
--- a/javatests/dagger/android/functional/ReleaseWhenModerate.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_MODERATE)
-@Scope
-@interface ReleaseWhenModerate {}
diff --git a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
deleted file mode 100644
index ca22db44a..000000000
--- a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_UI_HIDDEN)
-@Scope
-@interface ReleaseWhenUiHidden {}
diff --git a/javatests/dagger/android/functional/TestComponent.java b/javatests/dagger/android/functional/TestComponent.java
deleted file mode 100644
index 03d40755b..000000000
--- a/javatests/dagger/android/functional/TestComponent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import dagger.Component;
-import dagger.android.AndroidMemorySensitiveReferenceManager;
-import javax.inject.Singleton;
-
-@Singleton
-@ReleaseWhenUiHidden
-@ReleaseWhenModerate
-@Component(modules = TestModule.class)
-interface TestComponent {
-  AndroidMemorySensitiveReferenceManager manager();
-
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden();
-
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate();
-}
diff --git a/javatests/dagger/android/functional/TestModule.java b/javatests/dagger/android/functional/TestModule.java
deleted file mode 100644
index dd3adaa0b..000000000
--- a/javatests/dagger/android/functional/TestModule.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class TestModule {
-  int releasedWhenUiHiddenCalls;
-  int releasedWhenModerateCalls;
-
-  @Provides
-  @ReleaseWhenUiHidden
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden() {
-    ++releasedWhenUiHiddenCalls;
-    return new Object();
-  }
-
-  @Provides
-  @ReleaseWhenModerate
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate() {
-    ++releasedWhenModerateCalls;
-    return new Object();
-  }
-}
diff --git a/javatests/dagger/functional/ReleasableReferencesComponents.java b/javatests/dagger/functional/ReleasableReferencesComponents.java
deleted file mode 100644
index 4717e8970..000000000
--- a/javatests/dagger/functional/ReleasableReferencesComponents.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional;
-
-import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import com.google.auto.value.AutoValue;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.IntoMap;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Retention;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Scope;
-
-final class ReleasableReferencesComponents {
-
-  interface ThingComponent {
-    /**
-     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
-     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
-     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
-     * ChildModule ChildModule.class}.
-     */
-    Map<Class<?>, Thing> things();
-  }
-
-  @ParentRegularScope
-  @ParentReleasableScope1
-  @ParentReleasableScope2
-  @Component(modules = ParentModule.class)
-  interface Parent extends ThingComponent {
-
-    Set<ReleasableReferenceManager> managers();
-
-    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
-
-    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
-
-    @ForReleasableReferences(ParentReleasableScope1.class)
-    ReleasableReferenceManager parentReleasableScope1Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    ReleasableReferenceManager parentReleasableScope2Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
-
-    @ForReleasableReferences(ChildReleasableScope1.class)
-    ReleasableReferenceManager childReleasableScope1Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    ReleasableReferenceManager childReleasableScope2Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
-
-    Child child();
-  }
-
-  @AutoValue
-  abstract static class Thing {
-    abstract int count();
-
-    static Thing thing(int count) {
-      return new AutoValue_ReleasableReferencesComponents_Thing(count);
-    }
-  }
-
-  @ChildRegularScope
-  @ChildReleasableScope1
-  @ChildReleasableScope2
-  @ChildReleasableScope3
-  @Subcomponent(modules = ChildModule.class)
-  interface Child extends ThingComponent {}
-
-  @CanReleaseReferences
-  @interface Metadata1 {
-    String value();
-  }
-
-  @CanReleaseReferences
-  @interface Metadata2 {
-    String value();
-  }
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ParentRegularScope {}
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ChildRegularScope {}
-
-  @Retention(RUNTIME)
-  @CanReleaseReferences
-  @Scope
-  @interface ParentReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ParentReleasableScope2")
-  @Scope
-  @interface ParentReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata2("ChildReleasableScope1")
-  @Scope
-  @interface ChildReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope2.1")
-  @Metadata2("ChildReleasableScope2.2")
-  @Scope
-  @interface ChildReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope3.1")
-  @Metadata2("ChildReleasableScope3.2")
-  @CanReleaseReferences
-  @Scope
-  @interface ChildReleasableScope3 {}
-
-  @Module
-  static final class ParentModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentModule.class)
-    Thing parentUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentRegularScope.class)
-    @ParentRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope1.class)
-    @ParentReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope2.class)
-    @ParentReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-
-  @Module
-  static final class ChildModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildModule.class)
-    Thing childUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildRegularScope.class)
-    @ChildRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope1.class)
-    @ChildReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope2.class)
-    @ChildReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-}
diff --git a/javatests/dagger/functional/ReleasableReferencesComponentsTest.java b/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
deleted file mode 100644
index 2e30791f3..000000000
--- a/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
-
-import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import dagger.functional.ReleasableReferencesComponents.Child;
-import dagger.functional.ReleasableReferencesComponents.ChildModule;
-import dagger.functional.ReleasableReferencesComponents.ChildRegularScope;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope1;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope2;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope3;
-import dagger.functional.ReleasableReferencesComponents.Metadata1;
-import dagger.functional.ReleasableReferencesComponents.Parent;
-import dagger.functional.ReleasableReferencesComponents.ParentModule;
-import dagger.functional.ReleasableReferencesComponents.ParentRegularScope;
-import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope1;
-import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope2;
-import dagger.functional.ReleasableReferencesComponents.Thing;
-import dagger.functional.ReleasableReferencesComponents.ThingComponent;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class ReleasableReferencesComponentsTest {
-
-  private Parent component;
-  private ParentAsserts parentAsserts;
-  private ChildAsserts childAsserts;
-
-  @Before
-  public void setUp() {
-    component = DaggerReleasableReferencesComponents_Parent.create();
-    parentAsserts = new ParentAsserts(component);
-    childAsserts = parentAsserts.newChildAsserts();
-  }
-
-  @Test
-  public void releasableReferenceManagers() {
-    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
-        Maps.uniqueIndex(
-            component.managers(),
-            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
-              @Override
-              public Class<? extends Annotation> apply(
-                  ReleasableReferenceManager releasableReferenceManager) {
-                return releasableReferenceManager.scope();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
-    // Should contain a manager for ChildReleasableScope3 even though
-    // @ForReleasableReferences(Scope5.class) isn't needed.
-    assertThat(managers).containsKey(ChildReleasableScope3.class);
-  }
-
-  @Test
-  public void setOfTypedReleasableReferenceManagers() {
-    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
-        Multimaps.transformValues(
-            Multimaps.index(
-                component.typedReleasableReferenceManagers1(),
-                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
-                  @Override
-                  public Class<? extends Annotation> apply(
-                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
-                    return releasableReferenceManager.scope();
-                  }
-                }),
-            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
-              @Override
-              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
-                return manager.metadata();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
-  }
-
-  @AutoAnnotation
-  static Metadata1 metadata1(String value) {
-    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
-  }
-
-  @Test
-  public void basicScopingWorks() {
-    assertBindingCallCounts();
-    // assert again to make sure that the scoped bindings aren't called again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenGc() {
-    assertBindingCallCounts();
-    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-
-    // Releasing again and GCing again means the binding is executed again.
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenGc() {
-    assertBindingCallCounts();
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void twoInstancesOfSameSubcomponent() {
-    // Two instances of the same subcomponent.
-    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
-    childAsserts.assertBindingCallCounts();
-    child2Asserts.assertBindingCallCounts();
-
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
-    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    childAsserts.assertBindingCallCounts(); // when calling child.things()
-    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
-    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
-  }
-
-  private void assertBindingCallCounts() {
-    parentAsserts.assertBindingCallCounts();
-    childAsserts.assertBindingCallCounts();
-  }
-
-  /**
-   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
-   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
-   * keys} to be cleared.
-   */
-  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
-    GcFinalization.awaitDone(
-        new FinalizationPredicate() {
-          @Override
-          public boolean isDone() {
-            for (Class<?> key : keys) {
-              if (parentAsserts.weakThingReferenceUncollected(key)
-                  || childAsserts.weakThingReferenceUncollected(key)) {
-                return false;
-              }
-            }
-            return true;
-          }
-        });
-  }
-
-  /**
-   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
-   * also tell when certain values in the map have been finalized.
-   */
-  private abstract static class ThingAsserts {
-
-    private final ThingComponent component;
-    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
-
-    protected ThingAsserts(ThingComponent component) {
-      this.component = component;
-    }
-
-    /**
-     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
-     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
-     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
-     */
-    final void assertBindingCallCounts() {
-      Map<Class<?>, Thing> things = component.things();
-      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
-      weakThings =
-          ImmutableMap.copyOf(
-              Maps.transformValues(
-                  things,
-                  new Function<Thing, WeakReference<Thing>>() {
-                    @Override
-                    public WeakReference<Thing> apply(Thing thing) {
-                      return new WeakReference<>(thing);
-                    }
-                  }));
-    }
-
-    /** Returns the expected map. */
-    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
-
-    /**
-     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
-     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
-     */
-    boolean weakThingReferenceUncollected(Object key) {
-      WeakReference<Thing> weakThing = weakThings.get(key);
-      return weakThing != null && weakThing.get() != null;
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
-  private static final class ParentAsserts extends ThingAsserts {
-    final Parent parent;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForParentUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForParentRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope2Thing = 1;
-
-    ParentAsserts(Parent parent) {
-      super(parent);
-      this.parent = parent;
-    }
-
-    /**
-     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
-     * Child#things()}.
-     */
-    ChildAsserts newChildAsserts() {
-      return new ChildAsserts(this, parent.child());
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
-      return ImmutableMap.of(
-          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
-          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
-          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
-          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
-  private static final class ChildAsserts extends ThingAsserts {
-    final ParentAsserts parentAsserts;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForChildUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope2Thing = 1;
-
-    ChildAsserts(ParentAsserts parentAsserts, Child child) {
-      super(child);
-      this.parentAsserts = parentAsserts;
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
-      return new ImmutableMap.Builder<Class<?>, Thing>()
-          .putAll(parentAsserts.expectedThingMap())
-          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
-          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
-          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
-          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
-          .build();
-    }
-  }
-}
diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
deleted file mode 100644
index fda3a04c0..000000000
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link CanReleaseReferencesValidator}. */
-@RunWith(JUnit4.class)
-public final class CanReleaseReferencesValidationTest {
-  @Test
-  public void annotatesSourceRetainedAnnotation() {
-    JavaFileObject annotation =
-        JavaFileObjects.forSourceLines(
-            "test.Metadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import java.lang.annotation.RetentionPolicy;",
-            "",
-            "@CanReleaseReferences",
-            "@Retention(RetentionPolicy.SOURCE)",
-            "@interface Metadata {}");
-    Compilation compilation = daggerCompiler().compile(annotation);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("SOURCE").inFile(annotation).onLine(8);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index e9a2679bc..8bb8e0395 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -73,23 +73,6 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "  @Inject ReusableScoped() {}",
           "}");
 
-  private static final JavaFileObject RELEASABLE_SCOPED =
-      JavaFileObjects.forSourceLines(
-          "test.ReleasableScoped",
-          "package test;",
-          "",
-          "import dagger.releasablereferences.CanReleaseReferences;",
-          "import javax.inject.Scope;",
-          "import javax.inject.Inject;",
-          "",
-          "@ReleasableScoped.CustomScope",
-          "class ReleasableScoped {",
-          "  @Inject ReleasableScoped() {}",
-          "",
-          "  @CanReleaseReferences",
-          "  @Scope @interface CustomScope {}",
-          "}");
-
   private static final JavaFileObject UNSCOPED =
       JavaFileObjects.forSourceLines(
           "test.Unscoped",
@@ -107,12 +90,9 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "package test;",
           "",
           "import dagger.Component;",
-          "import dagger.releasablereferences.ForReleasableReferences;",
-          "import dagger.releasablereferences.ReleasableReferenceManager;",
           "",
           "@Component(modules = TestModule.class)",
           "@RegularScoped.CustomScope",
-          "@ReleasableScoped.CustomScope",
           "interface TestComponent {",
           "  @Qualifier(RegularScoped.class)",
           "  Object regular();",
@@ -120,15 +100,8 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "  @Qualifier(ReusableScoped.class)",
           "  Object reusable();",
           "",
-          "  @Qualifier(ReleasableScoped.class)",
-          "  Object releasable();",
-          "",
           "  @Qualifier(Unscoped.class)",
           "  Object unscoped();",
-          "",
-          // force a reference releasing provider to be created
-          "  @ForReleasableReferences(ReleasableScoped.CustomScope.class)",
-          "  ReleasableReferenceManager releasableReferenceManager();",
           "}");
 
   private static final JavaFileObject QUALIFIER =
@@ -159,9 +132,6 @@ public void toDoubleCheck() {
             "  @Binds @RegularScoped.CustomScope @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @RegularScoped.CustomScope @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @RegularScoped.CustomScope @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -204,36 +174,20 @@ public void toDoubleCheck() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
                     "        SingleCheck.provider(ReusableScoped_Factory.create());",
                     "    this.reusableProvider = DoubleCheck.provider(",
-                    "        (Provider) reusableScopedProvider);")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.releasableProvider = DoubleCheck.provider(",
-                    "        (Provider) releasableScopedProvider);",
+                    "        (Provider) reusableScopedProvider);",
                     "    this.unscopedProvider = DoubleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
+                    "        (Provider) Unscoped_Factory.create());",
+                    "  }")
+                .addLines( //
                     "}")
                 .build());
   }
@@ -257,9 +211,6 @@ public void toSingleCheck() {
             "  @Binds @Reusable @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @Reusable @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @Reusable @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -302,156 +253,19 @@ public void toSingleCheck() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
-                    "    this.regularScopedProvider = ",
-                    "        DoubleCheck.provider(RegularScoped_Factory.create());",
-                    "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.releasableProvider = SingleCheck.provider(",
-                    "        (Provider) releasableScopedProvider);",
-                    "    this.unscopedProvider = SingleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
-                    "}")
-                .build());
-  }
-
-  @Test
-  public void toReleasableCheck() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface TestModule {",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(RegularScoped.class)",
-            "  Object regular(RegularScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReusableScoped.class)",
-            "  Object reusable(ReusableScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(Unscoped.class)",
-            "  Object unscoped(Unscoped delegate);",
-            "}");
-
-    assertThatCompilationWithModule(module)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(
-            compilerMode
-                .javaFileBuilder("test.DaggerTestComponent")
-                .addLines(
-                    "package test;",
-                    "",
-                    GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "  private volatile Object regularScoped = new MemoizedSentinel();",
-                    "  private volatile ReusableScoped reusableScoped;",
-                    "  private volatile Provider<Unscoped> unscopedProvider;",
-                    "",
-                    "  private RegularScoped getRegularScoped() {",
-                    "    Object local = regularScoped;",
-                    "    if (local instanceof MemoizedSentinel) {",
-                    "      synchronized (local) {",
-                    "        local = regularScoped;",
-                    "        if (local instanceof MemoizedSentinel) {",
-                    "          local = new RegularScoped();",
-                    "          regularScoped = DoubleCheck.reentrantCheck(regularScoped, local);",
-                    "        }",
-                    "      }",
-                    "    }",
-                    "    return (RegularScoped) local;",
-                    "  }",
-                    "",
-                    "  private ReusableScoped getReusableScoped() {",
-                    "    Object local = reusableScoped;",
-                    "    if (local == null) {",
-                    "      local = new ReusableScoped();",
-                    "      reusableScoped = (ReusableScoped) local;",
-                    "    }",
-                    "    return (ReusableScoped) local;",
-                    "  }",
-                    "",
-                    "  private Provider<Unscoped> getUnscopedProvider() {",
-                    "    Object local = unscopedProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(0);",
-                    "      unscopedProvider = (Provider<Unscoped>) local;",
-                    "    }",
-                    "    return (Provider<Unscoped>) local;",
-                    "  }",
-                    "")
-                .addLines(
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
-                .addLinesIn(
-                    DEFAULT_MODE,
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.unscopedProvider =",
-                    "        ReferenceReleasingProvider.create(",
-                    "            (Provider) Unscoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "    this.unscopedProvider2 =",
-                    "        ReferenceReleasingProvider.create(",
-                    "            (Provider) getUnscopedProvider(), customScopeReferences);")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "  private final class SwitchingProvider<T> implements Provider<T> {",
-                    "    @SuppressWarnings(\"unchecked\")",
-                    "    @Override",
-                    "    public T get() {",
-                    "      switch (id) {",
-                    "        case 0: return (T) new Unscoped();",
-                    "        default: throw new AssertionError(id);",
-                    "      }",
-                    "    }",
+                    "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                    "    this.unscopedProvider = SingleCheck.provider(",
+                    "        (Provider) Unscoped_Factory.create());",
                     "  }")
-                .addLines("}")
+                .addLines( //
+                    "}")
                 .build());
   }
 
@@ -473,9 +287,6 @@ public void toUnscoped() {
             "  @Binds @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -518,27 +329,16 @@ public void toUnscoped() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);",
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
+                    "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                    "  }")
+                .addLines( //
                     "}")
                 .build());
   }
@@ -1185,7 +985,6 @@ private CompilationSubject assertThatCompilationWithModule(JavaFileObject module
                 QUALIFIER,
                 REGULAR_SCOPED,
                 REUSABLE_SCOPED,
-                RELEASABLE_SCOPED,
                 UNSCOPED);
     assertThat(compilation).succeeded();
     return assertThat(compilation);
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
deleted file mode 100644
index e15c6dbc1..000000000
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests validation of {@code @ForReleasableRefernces}. */
-@RunWith(JUnit4.class)
-public class ForReleasableReferencesValidationTest {
-  @Test
-  public void notAScope() {
-    JavaFileObject notAScope =
-        JavaFileObjects.forSourceLines(
-            "test.NotAScope", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface NotAScope {}");
-    JavaFileObject injects =
-        JavaFileObjects.forSourceLines(
-            "test.Injects",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "interface Injects {",
-            "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(notAScope, injects);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "The value of @ForReleasableReferences must be a reference-releasing scope. "
-                + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
-                + "@dagger.releasablereferences.CanReleaseReferences?")
-        .inFile(injects)
-        .onLine(7)
-        .atColumn(3);
-  }
-
-  @Test
-  public void notAReferenceReleasingScope() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@Retention(RUNTIME)",
-            "@Scope",
-            "@interface TestScope {}");
-    JavaFileObject injects =
-        JavaFileObjects.forSourceLines(
-            "test.Injects",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "interface Injects {",
-            "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(testScope, injects);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "The value of @ForReleasableReferences must be a reference-releasing scope. "
-                + "Did you mean to annotate test.TestScope with "
-                + "@dagger.releasablereferences.CanReleaseReferences?")
-        .inFile(injects)
-        .onLine(7)
-        .atColumn(3);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
deleted file mode 100644
index ad039cad3..000000000
--- a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.TestUtils.message;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ReleasableReferenceManagerValidationTest {
-  @Test
-  public void missingReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@BadMetadata",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject otherScope =
-        JavaFileObjects.forSourceLines(
-            "test.OtherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface OtherScope {}");
-    JavaFileObject yetAnotherScope =
-        JavaFileObjects.forSourceLines(
-            "test.YetAnotherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface YetAnotherScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-    JavaFileObject badMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.BadMetadata", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface BadMetadata {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponents",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "interface TestComponents {",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface WrongScopeComponent {",
-            "    @ForReleasableReferences(OtherScope.class)",
-            "    ReleasableReferenceManager otherManager();",
-            "  }",
-            "",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface WrongMetadataComponent {",
-            "    @ForReleasableReferences(TestScope.class)",
-            "    TypedReleasableReferenceManager<TestMetadata> wrongMetadata();",
-            "  }",
-            "",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface BadMetadataComponent {",
-            "    @ForReleasableReferences(TestScope.class)",
-            "    TypedReleasableReferenceManager<BadMetadata> badManager();",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
-                + "dagger.releasablereferences.ReleasableReferenceManager "
-                + "because no component in test.TestComponents.WrongScopeComponent's "
-                + "component hierarchy is annotated with @test.OtherScope. "
-                + "The available reference-releasing scopes are "
-                + "[@test.TestScope, @test.YetAnotherScope].")
-        .inFile(component)
-        .onLineContaining("interface WrongScopeComponent");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
-                + "because test.TestScope is not annotated with @test.TestMetadata")
-        .inFile(component)
-        .onLineContaining("interface WrongMetadataComponent");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
-                + "because test.BadMetadata is not annotated with "
-                + "@dagger.releasablereferences.CanReleaseReferences")
-        .inFile(component)
-        .onLineContaining("interface BadMetadataComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_ReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static ReleasableReferenceManager rrm() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  ReleasableReferenceManager testManager();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "    binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_TypedReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "is bound multiple times:",
-                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "test.TestModule.typedRrm()",
-                    "    binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_SetOfReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides",
-            "  static Set<ReleasableReferenceManager> rrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Set<ReleasableReferenceManager> managers();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "is bound multiple times:",
-                "    @Provides "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "test.TestModule.rrmSet()",
-                "    Dagger-generated binding for "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_SetOfTypedReleasableReferenceManagers() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides",
-            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "is bound multiple times:",
-                    "    @Provides "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "test.TestModule.typedRrmSet()",
-                    "    Dagger-generated binding for "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-}
