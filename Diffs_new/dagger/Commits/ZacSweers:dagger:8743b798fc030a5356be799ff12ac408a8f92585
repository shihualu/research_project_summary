diff --git a/WORKSPACE b/WORKSPACE
index eeb97348a..638951266 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -49,14 +49,14 @@ maven_jar(
 
 maven_jar(
     name = "com_google_guava_guava",
-    artifact = "com.google.guava:guava:21.0",
-    sha1 = "3a3d111be1be1b745edfa7d91678a12d7ed38709",
+    artifact = "com.google.guava:guava:23.3-jre",
+    sha1 = "9124c2675a9de3ba953f66d62339cf62f8e1a143",
 )
 
 maven_jar(
     name = "com_google_guava_guava_testlib",
-    artifact = "com.google.guava:guava-testlib:21.0-rc1",
-    sha1 = "13f0f0dce4e710bb0bb791bd07f6e9858670a865",
+    artifact = "com.google.guava:guava-testlib:23.3-jre",
+    sha1 = "5dd4cc9849497042d84b782f8a1eed2b7dae290c",
 )
 
 maven_jar(
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index a780e93fb..73db97676 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -19,8 +19,11 @@ package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
 
+EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
+
 CODEGEN_SRCS = glob(
     ["*.java"],
+    exclude = EXPERIMENTAL_VISUALIZER_SRCS,
 )
 
 CODEGEN_PLUGINS = [
@@ -60,6 +63,7 @@ java_library(
         "DaggerTypes.java",
         "Expression.java",
         "FeatureStatus.java",
+        "ForwardingNetwork.java",
         "InjectionAnnotations.java",
         "MapKeyAccessibility.java",
         "MethodSignature.java",
@@ -91,7 +95,9 @@ java_library(
         "Binding.java",
         "BindingDeclaration.java",
         "BindingGraph.java",
+        "BindingGraphPlugin.java",  # TODO(ronshapiro): this should move to it's own spi target
         "BindingKey.java",
+        "BindingNetwork.java",
         "BindingType.java",
         "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
@@ -258,6 +264,19 @@ java_library(
     deps = CODEGEN_DEPS,
 )
 
+java_plugin(
+    name = "dagger-experimental-visualizer",
+    srcs = EXPERIMENTAL_VISUALIZER_SRCS,
+    deps = [
+        ":base",
+        ":binding",
+        "//third_party:auto_service",
+        "//third_party:error_prone_annotations",
+        "//third_party:guava",
+        "//third_party:javapoet",
+    ],
+)
+
 java_plugin(
     name = "component-codegen",
     generates_api = 1,
diff --git a/java/dagger/internal/codegen/BindingGraphPlugin.java b/java/dagger/internal/codegen/BindingGraphPlugin.java
new file mode 100644
index 000000000..47628deed
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingGraphPlugin.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+
+/**
+ * A pluggable visitor for {@link BindingNetwork}.
+ *
+ * <p>Note: This is still experimental and will change.
+ */
+public abstract class BindingGraphPlugin {
+
+  private Filer filer;
+
+  final void setFiler(Filer filer) {
+    this.filer = filer;
+  }
+
+  /**
+   * Returns a filer that this plug-in can use to write Java or other files based on the binding
+   * graph.
+   */
+  protected final Filer filer() {
+    return filer;
+  }
+
+  /** Called once for each valid root binding graph encountered by the Dagger processor. */
+  protected abstract void visitGraph(BindingNetwork bindingNetwork);
+
+  /**
+   * Returns the annotation-processing options that this plugin uses to configure behavior.
+   *
+   * @see Processor#getSupportedOptions()
+   */
+  protected Set<String> getSupportedOptions() {
+    return Collections.emptySet();
+  }
+
+  /**
+   * If {@link #getSupportedOptions()} returns a non-empty set, then this method will be called with
+   * matching options that were actually passed on the {@code javac} command-line.
+   *
+   * @see ProcessingEnvironment#getOptions()
+   */
+  // TODO(dpb, ronshapiro): Consider a protected method returning ProcessingEnvironment instead.
+  protected void setOptions(Map<String, String> options) {}
+}
diff --git a/java/dagger/internal/codegen/BindingNetwork.java b/java/dagger/internal/codegen/BindingNetwork.java
new file mode 100644
index 000000000..825e72336
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingNetwork.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asType;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.MoreObjects.toStringHelper;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.concat;
+import static com.google.common.collect.Sets.intersection;
+import static com.google.common.graph.Graphs.inducedSubgraph;
+import static com.google.common.graph.Graphs.reachableNodes;
+import static com.google.common.graph.Graphs.transpose;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.BindingKey.membersInjection;
+import static dagger.internal.codegen.ContributionBinding.Kind.SUBCOMPONENT_BUILDER;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.Network;
+import com.google.common.graph.NetworkBuilder;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.internal.codegen.ComponentTreeTraverser.ComponentTreePath;
+import dagger.multibindings.Multibinds;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * The immutable graph of bindings, dependency requests, and components for a valid root component.
+ *
+ * <h3>Nodes</h3>
+ *
+ * <p>There is a <b>{@linkplain BindingNode binding node}</b> for each owned binding in the graph.
+ * If a binding is owned by more than one component, there is one binding node for that binding for
+ * every owning component.
+ *
+ * <p>There is a <b>{@linkplain ComponentNode component node}</b> (without a binding) for each
+ * component in the graph.
+ *
+ * <h3>Edges</h3>
+ *
+ * <p>There is a <b>{@linkplain DependencyEdge dependency edge}</b> for each dependency request in
+ * the graph. Its target node is the binding node for the binding that satisfies the request. For
+ * entry point dependency requests, the source node is the component node for the component for
+ * which it is an entry point. For other dependency requests, the source node is the binding node
+ * for the binding that contains the request.
+ *
+ * <p>There is a <b>subcomponent edge</b> for each parent-child component relationship in the graph.
+ * The target node is the component node for the child component. For subcomponents defined by a
+ * {@linkplain SubcomponentBuilderBindingEdge subcomponent builder binding} (either a method on the
+ * component or a set of {@code @Module.subcomponents} annotation values), the source node is the
+ * binding node for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
+ * ChildFactoryMethodEdge subcomponent factory methods}, the source node is the component node for
+ * the parent.
+ */
+// TODO(dpb): Represent graphs with missing or conflicting bindings.
+public final class BindingNetwork
+    extends ForwardingNetwork<BindingNetwork.Node, BindingNetwork.Edge> {
+
+  /** Creates a {@link BindingNetwork} representing the given root {@link BindingGraph}. */
+  static BindingNetwork create(BindingGraph graph) {
+    Factory factory = new Factory(graph);
+    factory.traverseComponents();
+    return factory.bindingNetwork();
+  }
+
+  private BindingNetwork(Network<Node, Edge> bindingNetwork) {
+    super(ImmutableNetwork.copyOf(bindingNetwork));
+  }
+
+  /** Returns the binding nodes. */
+  public ImmutableSet<BindingNode> bindingNodes() {
+    return bindingNodesStream().collect(toImmutableSet());
+  }
+
+  /** Returns the binding nodes for a binding. */
+  public ImmutableSet<BindingNode> bindingNodes(BindingKey bindingKey) {
+    return bindingNodesStream()
+        .filter(node -> node.bindingKey().equals(bindingKey))
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the component nodes. */
+  public ImmutableSet<ComponentNode> componentNodes() {
+    return componentNodeStream().collect(toImmutableSet());
+  }
+
+  /** Returns the component node for a component. */
+  public Optional<ComponentNode> componentNode(ComponentTreePath component) {
+    return componentNodeStream()
+        .filter(node -> node.componentTreePath().equals(component))
+        .findFirst();
+  }
+
+  /** Returns the component nodes for a component. */
+  public ImmutableSet<ComponentNode> componentNodes(TypeElement component) {
+    return componentNodeStream()
+        .filter(node -> node.componentTreePath().currentComponent().equals(component))
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the component node for the root component. */
+  public ComponentNode rootComponentNode() {
+    return componentNodeStream()
+        .filter(node -> node.componentTreePath().atRoot())
+        .findFirst()
+        .get();
+  }
+
+  /** Returns the dependency edges. */
+  public ImmutableSet<DependencyEdge> dependencyEdges() {
+    return dependencyEdgeStream().collect(toImmutableSet());
+  }
+
+  /** Returns the dependency edges for the dependencies of a binding. */
+  public ImmutableMap<DependencyRequest, DependencyEdge> dependencyEdges(BindingNode bindingNode) {
+    return outEdges(bindingNode)
+        .stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .collect(toImmutableMap(DependencyEdge::dependencyRequest, edge -> edge));
+  }
+
+  /** Returns the dependency edges from any binding for a dependency request. */
+  public ImmutableSet<DependencyEdge> dependencyEdges(DependencyRequest dependencyRequest) {
+    return dependencyEdgeStream()
+        .filter(edge -> edge.dependencyRequest().equals(dependencyRequest))
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the dependency edges for all entry points for all components and subcomponents. Each
+   * edge's source node is a component node.
+   */
+  public ImmutableSet<DependencyEdge> entryPointEdges() {
+    return entryPointEdgeStream().collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the dependency edges for the entry points of a given {@code component}. Each edge's
+   * source node is that component's component node.
+   */
+  public ImmutableSet<DependencyEdge> entryPointEdges(ComponentTreePath component) {
+    return outEdges(componentNode(component).get())
+        .stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the binding nodes for bindings that directly satisfy entry points. */
+  public ImmutableSet<BindingNode> entryPointBindingNodes() {
+    return entryPointEdgeStream()
+        .map(edge -> (BindingNode) incidentNodes(edge).target())
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the edges for entry points that transitively depend on a binding. */
+  public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
+      BindingNode bindingNode) {
+    Network<Node, Edge> subgraphDependingOnBindingNode =
+        inducedSubgraph(this, reachableNodes(transpose(this).asGraph(), bindingNode));
+    return ImmutableSet.copyOf(
+        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
+  }
+
+  private Stream<BindingNode> bindingNodesStream() {
+    return nodes().stream().flatMap(instancesOf(BindingNode.class));
+  }
+
+  private Stream<ComponentNode> componentNodeStream() {
+    return nodes().stream().flatMap(instancesOf(ComponentNode.class));
+  }
+
+  private Stream<DependencyEdge> dependencyEdgeStream() {
+    return edges().stream().flatMap(instancesOf(DependencyEdge.class));
+  }
+
+  private Stream<DependencyEdge> entryPointEdgeStream() {
+    return dependencyEdgeStream().filter(DependencyEdge::isEntryPoint);
+  }
+
+  /**
+   * An edge in the binding graph. Either a {@link DependencyEdge}, a {@link
+   * ChildFactoryMethodEdge}, or a {@link SubcomponentBuilderBindingEdge}.
+   */
+  public interface Edge {}
+
+  /**
+   * An edge that represents a dependency on a binding.
+   *
+   * <p>Because one {@link DependencyRequest} may represent a dependency from two bindings (e.g., a
+   * dependency of {@code Foo<String>} and {@code Foo<Number>} may have the same key and request
+   * element), this class does not override {@link #equals(Object)} to use value semantics.
+   */
+  public static final class DependencyEdge implements Edge {
+
+    private final DependencyRequest dependencyRequest;
+    private final boolean entryPoint;
+
+    private DependencyEdge(DependencyRequest dependencyRequest, boolean entryPoint) {
+      this.dependencyRequest = dependencyRequest;
+      this.entryPoint = entryPoint;
+    }
+
+    /** The dependency request. */
+    public DependencyRequest dependencyRequest() {
+      return dependencyRequest;
+    }
+
+    /** Returns {@code true} if this edge represents an entry point. */
+    public boolean isEntryPoint() {
+      return entryPoint;
+    }
+
+    @Override
+    public String toString() {
+      return toStringHelper(this)
+          .add("dependencyRequest", dependencyRequest)
+          .add("entryPoint", entryPoint)
+          .toString();
+    }
+  }
+
+  /**
+   * An edge that represents a subcomponent factory method linking a parent component to a child
+   * subcomponent.
+   */
+  public static final class ChildFactoryMethodEdge implements Edge {
+
+    private final ExecutableElement factoryMethod;
+
+    private ChildFactoryMethodEdge(ExecutableElement factoryMethod) {
+      this.factoryMethod = factoryMethod;
+    }
+
+    /** The subcomponent factory method element. */
+    public ExecutableElement factoryMethod() {
+      return factoryMethod;
+    }
+
+    @Override
+    public String toString() {
+      return toStringHelper(this).add("factoryMethod", factoryMethod).toString();
+    }
+  }
+
+  /**
+   * An edge that represents the link between a parent component and a child subcomponent implied by
+   * a subcomponent builder binding.
+   */
+  public static final class SubcomponentBuilderBindingEdge implements Edge {
+
+    private final ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations;
+
+    private SubcomponentBuilderBindingEdge(
+        Iterable<SubcomponentDeclaration> subcomponentDeclarations) {
+      this.subcomponentDeclarations = ImmutableSet.copyOf(subcomponentDeclarations);
+    }
+
+    /**
+     * The {@code @Module.subcomponents} declarations that generated this edge. May be empty if the
+     * parent component has a subcomponent builder method.
+     */
+    public ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations() {
+      return subcomponentDeclarations;
+    }
+
+    @Override
+    public String toString() {
+      return toStringHelper(this)
+          .add("subcomponentDeclarations", subcomponentDeclarations)
+          .toString();
+    }
+  }
+
+  /** A node in the binding graph. Either a {@link BindingNode} or a {@link ComponentNode}. */
+  public interface Node {
+    /** The component this node belongs to. */
+    ComponentTreePath componentTreePath();
+  }
+
+  /**
+   * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
+   * there is one binding node for that binding for every owning component.
+   */
+  // TODO(dpb): Should this be a value type?
+  public static final class BindingNode implements Node {
+
+    private final ComponentTreePath component;
+    private final Binding binding;
+    private final ImmutableSet<BindingDeclaration> associatedDeclarations;
+
+    private BindingNode(
+        ComponentTreePath component,
+        Binding binding,
+        Iterable<BindingDeclaration> associatedDeclarations) {
+      this.component = component;
+      this.binding = binding;
+      this.associatedDeclarations = ImmutableSet.copyOf(associatedDeclarations);
+    }
+
+    /** The component that owns the {@link #binding()}. */
+    @Override
+    public ComponentTreePath componentTreePath() {
+      return component;
+    }
+
+    /** The binding. */
+    Binding binding() {
+      return binding;
+    }
+
+    /** The binding key for this binding. */
+    // TODO(dpb): Put this on Binding.
+    public BindingKey bindingKey() {
+      switch (binding.bindingType()) {
+        case MEMBERS_INJECTION:
+          return membersInjection(binding.key());
+
+        case PRODUCTION:
+        case PROVISION:
+          return contribution(binding.key());
+
+        default:
+          throw new AssertionError(binding);
+      }
+    }
+
+    /**
+     * The declarations (other than the binding's {@link Binding#bindingElement()}) that are
+     * associated with the binding.
+     *
+     * <ul>
+     *   <li>For {@linkplain BindsOptionalOf optional bindings}, the {@link
+     *       OptionalBindingDeclaration}s.
+     *   <li>For {@linkplain Module#subcomponents() module subcomponents}, the {@link
+     *       SubcomponentDeclaration}s.
+     *   <li>For {@linkplain Multibinds multibindings}, the {@link MultibindingDeclaration}s.
+     * </ul>
+     */
+    public ImmutableSet<BindingDeclaration> associatedDeclarations() {
+      return associatedDeclarations;
+    }
+
+    @Override
+    public String toString() {
+      return toStringHelper(this)
+          .add("component", component)
+          .add("binding", binding)
+          .add("associatedDeclarations", associatedDeclarations)
+          .toString();
+    }
+  }
+
+  /**
+   * A <b>component node</b> in the graph. Every entry point {@linkplain DependencyEdge dependency
+   * edge}'s source node is a component node for the component containing the entry point.
+   */
+  @AutoValue
+  public abstract static class ComponentNode implements Node {
+
+    /** The component represented by this node. */
+    @Override
+    public abstract ComponentTreePath componentTreePath();
+
+    private static ComponentNode create(ComponentTreePath component) {
+      return new AutoValue_BindingNetwork_ComponentNode(component);
+    }
+  }
+
+  private static class Factory extends ComponentTreeTraverser {
+
+    private final MutableNetwork<Node, Edge> network =
+        NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();
+
+    private ComponentNode parentComponent;
+    private ComponentNode currentComponent;
+
+    Factory(BindingGraph graph) {
+      super(graph);
+    }
+
+    @Override
+    protected void visitComponent(BindingGraph graph) {
+      ComponentNode grandparentNode = parentComponent;
+      parentComponent = currentComponent;
+      currentComponent = ComponentNode.create(componentTreePath());
+      network.addNode(currentComponent);
+      super.visitComponent(graph);
+      currentComponent = parentComponent;
+      parentComponent = grandparentNode;
+    }
+
+    @Override
+    protected void visitSubcomponentFactoryMethod(
+        BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
+      network.addEdge(parentComponent, currentComponent, new ChildFactoryMethodEdge(factoryMethod));
+      super.visitSubcomponentFactoryMethod(graph, parent, factoryMethod);
+    }
+
+    @Override
+    protected BindingGraphTraverser bindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      return new BindingGraphVisitor(componentPath, entryPoint);
+    }
+
+    BindingNetwork bindingNetwork() {
+      return new BindingNetwork(network);
+    }
+
+    private final class BindingGraphVisitor extends BindingGraphTraverser {
+
+      private Node current;
+
+      BindingGraphVisitor(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+        super(componentPath, entryPoint);
+        current = currentComponent;
+        network.addNode(current);
+      }
+
+      @Override
+      protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
+        // TODO(dpb): Should we visit only bindings owned by the current component, since other
+        // bindings will be visited in the parent?
+        Node previous = current;
+        current = newBindingNode(resolvedBindings(), binding, owningComponent);
+        network.addNode(current);
+        if (binding instanceof ContributionBinding) {
+          ContributionBinding contributionBinding = (ContributionBinding) binding;
+          if (contributionBinding.bindingKind().equals(SUBCOMPONENT_BUILDER)) {
+            network.addEdge(
+                current,
+                subcomponentNode(contributionBinding, owningComponent),
+                new SubcomponentBuilderBindingEdge(resolvedBindings().subcomponentDeclarations()));
+          }
+        }
+        if (network
+            .edgesConnecting(previous, current)
+            .stream()
+            .flatMap(instancesOf(DependencyEdge.class))
+            .noneMatch(e -> e.dependencyRequest().equals(dependencyRequest()))) {
+          network.addEdge(
+              previous, current, new DependencyEdge(dependencyRequest(), atEntryPoint()));
+          super.visitBinding(binding, owningComponent);
+        }
+        current = previous;
+      }
+
+      private ComponentNode subcomponentNode(
+          ContributionBinding binding, ComponentDescriptor subcomponentParent) {
+        checkArgument(binding.bindingKind().equals(SUBCOMPONENT_BUILDER));
+        TypeElement builderType = asTypeElement(binding.key().type());
+        TypeElement subcomponentType = asType(builderType.getEnclosingElement());
+        ComponentTreePath childPath =
+            componentTreePath()
+                .pathFromRootToAncestor(subcomponentParent)
+                .childPath(subcomponentType);
+        ComponentNode childNode = ComponentNode.create(childPath);
+        network.addNode(childNode);
+        return childNode;
+      }
+
+      private BindingNode newBindingNode(
+          ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
+        return new BindingNode(
+            componentTreePath().pathFromRootToAncestor(owningComponent),
+            binding,
+            concat(
+                resolvedBindings.multibindingDeclarations(),
+                resolvedBindings.optionalBindingDeclarations(),
+                resolvedBindings.subcomponentDeclarations()));
+      }
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingNetworkVisualizer.java b/java/dagger/internal/codegen/BindingNetworkVisualizer.java
new file mode 100644
index 000000000..b431beba2
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingNetworkVisualizer.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static java.util.UUID.randomUUID;
+import static java.util.regex.Matcher.quoteReplacement;
+import static java.util.stream.Collectors.groupingBy;
+
+import com.google.auto.service.AutoService;
+import com.google.common.base.Joiner;
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterators;
+import com.google.common.graph.EndpointPair;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.BindingNetwork.BindingNode;
+import dagger.internal.codegen.BindingNetwork.ChildFactoryMethodEdge;
+import dagger.internal.codegen.BindingNetwork.DependencyEdge;
+import dagger.internal.codegen.BindingNetwork.Edge;
+import dagger.internal.codegen.BindingNetwork.Node;
+import dagger.internal.codegen.BindingNetwork.SubcomponentBuilderBindingEdge;
+import dagger.internal.codegen.ComponentTreeTraverser.ComponentTreePath;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import javax.lang.model.element.TypeElement;
+import javax.tools.FileObject;
+import javax.tools.StandardLocation;
+
+/**
+ * Experimental network visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
+ *
+ * <p>For each component, writes a <a href=http://www.graphviz.org/content/dot-language>DOT file</a>
+ * in the same package. The file name is the name of the component type (with enclosing type names,
+ * joined by underscores, preceding it), with a {@code .dot} extension.
+ *
+ * <p>For example, for a nested component type {@code Foo.Bar} this will generate a file {@code
+ * Foo_Bar.dot}.
+ */
+@AutoService(BindingGraphPlugin.class)
+public final class BindingNetworkVisualizer extends BindingGraphPlugin {
+
+  /** Graphviz color names to use for binding nodes within each component. */
+  private static final ImmutableList<String> COMPONENT_COLORS =
+      ImmutableList.of(
+          "/set312/1",
+          "/set312/2",
+          "/set312/3",
+          "/set312/4",
+          "/set312/5",
+          "/set312/6",
+          "/set312/7",
+          "/set312/8",
+          "/set312/9",
+          "/set312/10",
+          "/set312/11",
+          "/set312/12");
+
+  @Override
+  public void visitGraph(BindingNetwork bindingNetwork) {
+    TypeElement componentElement =
+        bindingNetwork.rootComponentNode().componentTreePath().currentComponent();
+    DotGraph graph = new NodesGraph(bindingNetwork).graph();
+    ClassName componentName = ClassName.get(componentElement);
+    try {
+      FileObject file =
+          filer()
+              .createResource(
+                  StandardLocation.CLASS_OUTPUT,
+                  componentName.packageName(),
+                  Joiner.on('_').join(componentName.simpleNames()) + ".dot",
+                  componentElement);
+      try (PrintWriter writer = new PrintWriter(file.openWriter())) {
+        graph.write(0, writer);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private abstract static class Indented {
+
+    abstract void write(int level, PrintWriter writer);
+
+    @CanIgnoreReturnValue
+    PrintWriter indent(int level, PrintWriter writer) {
+      writer.print(Strings.repeat(" ", level * 2));
+      return writer;
+    }
+  }
+
+  static class DotGraph extends Indented {
+    private final String header;
+    private final List<Indented> elements = new ArrayList<>();
+
+    DotGraph(String header) {
+      this.header = header;
+    }
+
+    @CanIgnoreReturnValue
+    DotGraph add(Indented element) {
+      elements.add(element);
+      return this;
+    }
+
+    @Override
+    void write(int level, PrintWriter writer) {
+      indent(level, writer);
+      writer.println(header + " {");
+      for (Indented element : elements) {
+        element.write(level + 1, writer);
+      }
+      indent(level, writer);
+      writer.println("}");
+    }
+  }
+
+  static class DotStatement<S extends DotStatement<S>> extends Indented {
+    private final String base;
+    private final Map<String, Object> attributes = new LinkedHashMap<>();
+
+    DotStatement(String base) {
+      this.base = base;
+    }
+
+    @SuppressWarnings("unchecked")
+    @CanIgnoreReturnValue
+    S addAttribute(String name, Object value) {
+      attributes.put(name, value);
+      return (S) this;
+    }
+
+    @CanIgnoreReturnValue
+    S addAttributeFormat(String name, String format, Object... args) {
+      return addAttribute(name, String.format(format, args));
+    }
+
+    @Override
+    void write(int level, PrintWriter writer) {
+      indent(level, writer);
+      writer.print(base);
+      if (!attributes.isEmpty()) {
+        writer.print(
+            attributes
+                .entrySet()
+                .stream()
+                .map(
+                    entry ->
+                        String.format("%s=%s", entry.getKey(), quote(entry.getValue().toString())))
+                .collect(Collectors.joining(", ", " [", "]")));
+      }
+      writer.println();
+    }
+  }
+
+  private static String quote(String string) {
+    return '"' + string.replaceAll("\"", quoteReplacement("\\\"")) + '"';
+  }
+
+  static class DotNode extends DotStatement<DotNode> {
+    DotNode(Object nodeName) {
+      super(quote(nodeName.toString()));
+    }
+  }
+
+  static class DotEdge extends DotStatement<DotEdge> {
+    DotEdge(Object leftNode, Object rightNode) {
+      super(quote(leftNode.toString()) + " -> " + quote(rightNode.toString()));
+    }
+  }
+
+  static class NodesGraph {
+    private final DotGraph graph =
+        new DotGraph("digraph")
+            .add(
+                new DotStatement<>("graph")
+                    .addAttribute("rankdir", "LR")
+                    .addAttribute("labeljust", "l")
+                    .addAttribute("compound", true));
+
+    private final BindingNetwork bindingNetwork;
+    private final Map<Node, UUID> nodeIds = new HashMap<>();
+
+    NodesGraph(BindingNetwork bindingNetwork) {
+      this.bindingNetwork = bindingNetwork;
+    }
+
+    DotGraph graph() {
+      if (nodeIds.isEmpty()) {
+        Iterator<String> colors = Iterators.cycle(BindingNetworkVisualizer.COMPONENT_COLORS);
+        bindingNetwork
+            .nodes()
+            .stream()
+            .collect(groupingBy(Node::componentTreePath))
+            .forEach(
+                (component, networkNodes) -> {
+                  DotGraph subgraph = subgraph(component);
+                  subgraph.add(
+                      new DotStatement<>("node")
+                          .addAttribute("style", "filled")
+                          .addAttribute("shape", "box")
+                          .addAttribute("fillcolor", colors.next()));
+                  subgraph.add(new DotStatement<>("graph").addAttribute("label", component));
+                  for (Node node : networkNodes) {
+                    subgraph.add(dotNode(node));
+                  }
+                });
+        for (Edge edge : bindingNetwork.edges()) {
+          dotEdge(edge).ifPresent(graph::add);
+        }
+      }
+      return graph;
+    }
+
+    DotGraph subgraph(ComponentTreePath component) {
+      DotGraph subgraph = new DotGraph("subgraph " + quote(clusterName(component)));
+      graph.add(subgraph);
+      return subgraph;
+    }
+
+    UUID nodeId(Node node) {
+      return nodeIds.computeIfAbsent(node, n -> randomUUID());
+    }
+
+    Optional<DotEdge> dotEdge(Edge edge) {
+      EndpointPair<Node> incidentNodes = bindingNetwork.incidentNodes(edge);
+      DotEdge dotEdge = new DotEdge(nodeId(incidentNodes.source()), nodeId(incidentNodes.target()));
+      if (edge instanceof DependencyEdge) {
+        if (((DependencyEdge) edge).isEntryPoint()) {
+          return Optional.empty();
+        }
+      } else if (edge instanceof ChildFactoryMethodEdge) {
+        dotEdge.addAttribute("style", "dashed");
+        dotEdge.addAttribute("lhead", clusterName(incidentNodes.target().componentTreePath()));
+        dotEdge.addAttribute("ltail", clusterName(incidentNodes.source().componentTreePath()));
+        dotEdge.addAttribute("taillabel", ((ChildFactoryMethodEdge) edge).factoryMethod());
+      } else if (edge instanceof SubcomponentBuilderBindingEdge) {
+        dotEdge.addAttribute("style", "dashed");
+        dotEdge.addAttribute("lhead", clusterName(incidentNodes.target().componentTreePath()));
+        dotEdge.addAttribute("taillabel", "subcomponent");
+      }
+      return Optional.of(dotEdge);
+    }
+
+    DotNode dotNode(Node node) {
+      DotNode dotNode = new DotNode(nodeId(node));
+      if (node instanceof BindingNode) {
+        Binding binding = ((BindingNode) node).binding();
+        switch (binding.bindingType()) {
+          case PROVISION:
+            dotNode.addAttribute("label", binding.key());
+            break;
+
+          case PRODUCTION:
+            dotNode.addAttributeFormat("label", "@Produces %s", binding.key());
+            break;
+
+          case MEMBERS_INJECTION:
+            dotNode.addAttributeFormat("label", "MembersInjector<%s>", binding.key());
+            break;
+
+          default:
+            throw new AssertionError(binding);
+        }
+        dotNode.addAttribute("tooltip", "");
+        if (bindingNetwork.entryPointBindingNodes().contains(node)) {
+          dotNode.addAttribute("penwidth", 3);
+        }
+      } else {
+        dotNode.addAttribute("style", "invis").addAttribute("shape", "point");
+      }
+      return dotNode;
+    }
+
+    private static String clusterName(ComponentTreePath owningComponentPath) {
+      return "cluster" + owningComponentPath;
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 302ba5afb..500e826c3 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,9 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
@@ -51,6 +54,7 @@
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
+  private final ImmutableList<BindingGraphPlugin> bindingGraphPlugins;
 
   ComponentProcessingStep(
       Messager messager,
@@ -61,7 +65,8 @@
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
+      ComponentGenerator componentGenerator,
+      Iterable<BindingGraphPlugin> bindingGraphPlugins) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
@@ -71,6 +76,7 @@
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
+    this.bindingGraphPlugins = ImmutableList.copyOf(bindingGraphPlugins);
   }
 
   @Override
@@ -112,8 +118,7 @@
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
 
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
+    for (TypeElement componentTypeElement : typesIn(componentElements)) {
       try {
         ComponentValidationReport validationReport =
             componentValidator.validate(
@@ -135,6 +140,11 @@
                 bindingGraphValidator.validate(bindingGraph);
             graphReport.printMessagesTo(messager);
             if (graphReport.isClean()) {
+              if (!bindingGraphPlugins.isEmpty()) {
+                // TODO(b/68982932): Address performance of BindingNetwork.create().
+                BindingNetwork bindingNetwork = BindingNetwork.create(bindingGraph);
+                bindingGraphPlugins.forEach(plugin -> plugin.visitGraph(bindingNetwork));
+              }
               generateComponent(bindingGraph);
             }
           }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 89297f22b..b8399dbb3 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -22,7 +22,10 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import java.util.ServiceLoader;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -44,6 +47,7 @@
   private InjectBindingRegistry injectBindingRegistry;
   private FactoryGenerator factoryGenerator;
   private MembersInjectorGenerator membersInjectorGenerator;
+  private ImmutableList<BindingGraphPlugin> bindingGraphPlugins;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -52,7 +56,12 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return CompilerOptions.SUPPORTED_OPTIONS;
+    ImmutableSet.Builder<String> options = ImmutableSet.builder();
+    options.addAll(CompilerOptions.SUPPORTED_OPTIONS);
+    for (BindingGraphPlugin plugin : bindingGraphPlugins) {
+      options.addAll(plugin.getSupportedOptions());
+    }
+    return options.build();
   }
 
   @Override
@@ -61,6 +70,7 @@ public SourceVersion getSupportedSourceVersion() {
     DaggerTypes types = new DaggerTypes(processingEnv);
     DaggerElements elements = new DaggerElements(processingEnv);
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
+
     Filer filer;
     if (compilerOptions.headerCompilation()) {
       filer = processingEnv.getFiler();
@@ -68,6 +78,17 @@ public SourceVersion getSupportedSourceVersion() {
       filer = new FormattingFiler(processingEnv.getFiler());
     }
 
+    this.bindingGraphPlugins =
+        ImmutableList.copyOf(
+            ServiceLoader.load(BindingGraphPlugin.class, getClass().getClassLoader()));
+    for (BindingGraphPlugin plugin : bindingGraphPlugins) {
+      plugin.setFiler(filer);
+      Set<String> supportedOptions = plugin.getSupportedOptions();
+      if (!supportedOptions.isEmpty()) {
+        plugin.setOptions(Maps.filterKeys(processingEnv.getOptions(), supportedOptions::contains));
+      }
+    }
+
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
         new BindingDeclarationFormatter(methodSignatureFormatter);
@@ -202,8 +223,8 @@ public SourceVersion getSupportedSourceVersion() {
                 bindingGraphValidator,
                 componentDescriptorFactory,
                 bindingGraphFactory,
-                componentGenerator);
-
+                componentGenerator,
+                bindingGraphPlugins);
     return ImmutableList.of(
         new MapKeyProcessingStep(
             messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 46feb17cb..aebe58082 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Verify.verify;
@@ -28,7 +29,10 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static java.util.Spliterator.ORDERED;
 import static java.util.Spliterator.SIZED;
+import static java.util.stream.Collectors.joining;
 
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -49,6 +53,7 @@
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 
 /**
  * An object that traverses the entire component hierarchy, starting from the root component.
@@ -182,10 +187,15 @@ protected BindingGraphTraverser bindingGraphTraverser(
    * component.
    */
   protected final ComponentTreePath componentTreePath() {
-    return new ComponentTreePath(bindingGraphPath);
+    return ComponentTreePath.create(bindingGraphPath);
   }
 
-  /** An object that traverses the binding graph starting from an entry point. */
+  /**
+   * An object that traverses the binding graph of a component, starting from an entry point.
+   *
+   * <p>Note that the traversal includes bindings that are owned by an ancestor component, which may
+   * already have been traversed when traversing that ancestor's binding graph.
+   */
   public static class BindingGraphTraverser {
 
     private final ComponentTreePath componentTreePath;
@@ -527,28 +537,28 @@ public void traverseDependencies() {}
    * A path from the root component to a component within the component tree during a {@linkplain
    * ComponentTreeTraverser traversal}.
    */
-  public static final class ComponentTreePath {
-    /** The binding graph path from the root graph to the currently visited graph. */
-    private final ImmutableList<BindingGraph> bindingGraphPath;
+  @AutoValue
+  public abstract static class ComponentTreePath {
 
-    private ComponentTreePath(Iterable<BindingGraph> path) {
-      this.bindingGraphPath = ImmutableList.copyOf(path);
+    private static ComponentTreePath create(Iterable<BindingGraph> path) {
+      return new AutoValue_ComponentTreeTraverser_ComponentTreePath(ImmutableList.copyOf(path));
     }
 
     /**
      * Returns the binding graphs in the path, starting from the {@linkplain #rootGraph() root
      * graph} and ending with the {@linkplain #currentGraph() current graph}.
      */
-    public ImmutableList<BindingGraph> graphsInPath() {
-      return bindingGraphPath;
-    }
+    public abstract ImmutableList<BindingGraph> graphsInPath();
 
     /** Returns the binding graph for the component at the end of the path. */
     public BindingGraph currentGraph() {
-      return Iterables.getLast(bindingGraphPath);
+      return Iterables.getLast(graphsInPath());
     }
 
-    // TODO(dpb): Do we also want methods that return ComponentDescriptors, like currentComponent()?
+    /** Returns the type of the component at the end of the path. */
+    public TypeElement currentComponent() {
+      return currentGraph().componentDescriptor().componentDefinitionType();
+    }
 
     /**
      * Returns the binding graph for the parent of the {@linkplain #currentGraph() current
@@ -558,12 +568,12 @@ public BindingGraph currentGraph() {
      */
     public BindingGraph parentGraph() {
       checkState(!atRoot());
-      return bindingGraphPath.reverse().get(1);
+      return graphsInPath().reverse().get(1);
     }
 
     /** Returns the binding graph for the root component. */
     public BindingGraph rootGraph() {
-      return bindingGraphPath.get(0);
+      return graphsInPath().get(0);
     }
 
     /**
@@ -571,7 +581,7 @@ public BindingGraph rootGraph() {
      * #rootGraph() root graph}.
      */
     public boolean atRoot() {
-      return bindingGraphPath.size() == 1;
+      return graphsInPath().size() == 1;
     }
 
     /** Returns the rootmost binding graph in the component path among the given components. */
@@ -582,11 +592,59 @@ public BindingGraph rootmostGraph(Iterable<ComponentDescriptor> components) {
 
     /** Returns the binding graph within this path that represents the given component. */
     public BindingGraph graphForComponent(ComponentDescriptor component) {
+      checkNotNull(component);
       return rootmostGraph(graph -> graph.componentDescriptor().equals(component));
     }
 
+    /**
+     * Returns the subpath from the root component to the matching {@code ancestor} of the current
+     * component.
+     */
+    ComponentTreePath pathFromRootToAncestor(ComponentDescriptor ancestor) {
+      checkNotNull(ancestor);
+      ImmutableList.Builder<BindingGraph> path = ImmutableList.builder();
+      for (BindingGraph graph : graphsInPath()) {
+        path.add(graph);
+        if (graph.componentDescriptor().equals(ancestor)) {
+          return create(path.build());
+        }
+      }
+      throw new IllegalArgumentException(
+          String.format(
+              "%s is not in the current path: %s",
+              ancestor.componentDefinitionType().getQualifiedName(), this));
+    }
+
+    /**
+     * Returns the path from the root component to the child of the current component for a {@code
+     * subcomponent}.
+     *
+     * @throws IllegalArgumentException if {@code subcomponent} is not a child of the current
+     *     component
+     */
+    ComponentTreePath childPath(TypeElement subcomponent) {
+      for (BindingGraph child : currentGraph().subgraphs()) {
+        if (child.componentType().equals(subcomponent)) {
+          return create(FluentIterable.from(graphsInPath()).append(child));
+        }
+      }
+      throw new IllegalArgumentException(
+          String.format(
+              "%s is not a child of %s",
+              subcomponent.getQualifiedName(), currentGraph().componentType().getQualifiedName()));
+    }
+
     private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
-      return bindingGraphPath.stream().filter(predicate).findFirst().get();
+      return graphsInPath().stream().filter(predicate).findFirst().get();
+    }
+
+    @Override
+    public String toString() {
+      return graphsInPath()
+          .stream()
+          .map(BindingGraph::componentType)
+          .map(TypeElement::getQualifiedName)
+          .collect(joining(" â†’ "));
     }
   }
 
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index 582934129..ce8dc1ebf 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -20,8 +20,14 @@
 import static java.util.stream.Collectors.toList;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import java.util.Map;
+import java.util.function.Function;
 import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 /** Utilities for streams. */
 final class DaggerStreams {
@@ -42,5 +48,33 @@
     return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
 
+  /**
+   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
+   * and values are the result of applying the provided mapping functions to the input elements.
+   * Entries appear in the result {@code ImmutableMap} in encounter order.
+   */
+  static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
+      Function<? super T, K> keyMapper, Function<? super T, V> valueMapper) {
+    return Collectors.mapping(
+        value -> Maps.immutableEntry(keyMapper.apply(value), valueMapper.apply(value)),
+        Collector.of(
+            ImmutableMap::builder,
+            (ImmutableMap.Builder<K, V> builder, Map.Entry<K, V> entry) -> builder.put(entry),
+            (left, right) -> left.putAll(right.build()),
+            ImmutableMap.Builder::build));
+  }
+
+  /**
+   * Returns a function from {@link Object} to {@code Stream<T>}, which returns a stream containing
+   * its input if its input is an instance of {@code T}.
+   *
+   * <p>Use as an argument to {@link Stream#flatMap(Function)}:
+   *
+   * <pre>{@code Stream<Bar>} barStream = fooStream.flatMap(instancesOf(Bar.class));</pre>
+   */
+  static <T> Function<Object, Stream<T>> instancesOf(Class<T> to) {
+    return f -> to.isInstance(f) ? Stream.of(to.cast(f)) : Stream.empty();
+  }
+
   private DaggerStreams() {}
 }
diff --git a/java/dagger/internal/codegen/ForwardingNetwork.java b/java/dagger/internal/codegen/ForwardingNetwork.java
new file mode 100644
index 000000000..741789443
--- /dev/null
+++ b/java/dagger/internal/codegen/ForwardingNetwork.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import com.google.common.collect.ForwardingObject;
+import com.google.common.graph.ElementOrder;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.Graph;
+import com.google.common.graph.Network;
+import java.util.Optional;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+/** A {@link Network} that delegates all methods to another instance. */
+// TODO(dpb): Move to com.google.common.graph.
+public class ForwardingNetwork<N, E> extends ForwardingObject implements Network<N, E> {
+
+  private final Network<N, E> delegate;
+
+  protected ForwardingNetwork(Network<N, E> delegate) {
+    this.delegate = checkNotNull(delegate);
+  }
+
+  @Override
+  protected final Network<N, E> delegate() {
+    return delegate;
+  }
+
+  @Override
+  public Set<N> nodes() {
+    return delegate().nodes();
+  }
+
+  @Override
+  public Set<E> edges() {
+    return delegate().edges();
+  }
+
+  @Override
+  public Graph<N> asGraph() {
+    return delegate().asGraph();
+  }
+
+  @Override
+  public boolean isDirected() {
+    return delegate().isDirected();
+  }
+
+  @Override
+  public boolean allowsParallelEdges() {
+    return delegate().allowsParallelEdges();
+  }
+
+  @Override
+  public boolean allowsSelfLoops() {
+    return delegate().allowsSelfLoops();
+  }
+
+  @Override
+  public ElementOrder<N> nodeOrder() {
+    return delegate().nodeOrder();
+  }
+
+  @Override
+  public ElementOrder<E> edgeOrder() {
+    return delegate().edgeOrder();
+  }
+
+  @Override
+  public Set<N> adjacentNodes(N node) {
+    return delegate().adjacentNodes(node);
+  }
+
+  @Override
+  public Set<N> predecessors(N node) {
+    return delegate().predecessors(node);
+  }
+
+  @Override
+  public Set<N> successors(N node) {
+    return delegate().successors(node);
+  }
+
+  @Override
+  public Set<E> incidentEdges(N node) {
+    return delegate().incidentEdges(node);
+  }
+
+  @Override
+  public Set<E> inEdges(N node) {
+    return delegate().inEdges(node);
+  }
+
+  @Override
+  public Set<E> outEdges(N node) {
+    return delegate().outEdges(node);
+  }
+
+  @Override
+  public int degree(N node) {
+    return delegate().degree(node);
+  }
+
+  @Override
+  public int inDegree(N node) {
+    return delegate().inDegree(node);
+  }
+
+  @Override
+  public int outDegree(N node) {
+    return delegate().outDegree(node);
+  }
+
+  @Override
+  public EndpointPair<N> incidentNodes(E edge) {
+    return delegate().incidentNodes(edge);
+  }
+
+  @Override
+  public Set<E> adjacentEdges(E edge) {
+    return delegate().adjacentEdges(edge);
+  }
+
+  @Override
+  public Set<E> edgesConnecting(N nodeU, N nodeV) {
+    return delegate().edgesConnecting(nodeU, nodeV);
+  }
+
+  @SuppressWarnings("MissingOverride") // Until Guava 23.0
+  public Optional<E> edgeConnecting(N nodeU, N nodeV) {
+    return Optional.ofNullable(edgeConnectingOrNull(nodeU, nodeV));
+  }
+
+  @SuppressWarnings("MissingOverride") // Until Guava 23.0
+  @Nullable
+  public E edgeConnectingOrNull(N nodeU, N nodeV) {
+    return delegate().edgeConnectingOrNull(nodeU, nodeV);
+  }
+
+  @Override
+  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
+    return delegate().hasEdgeConnecting(nodeU, nodeV);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return delegate().equals(obj);
+  }
+
+  @Override
+  public int hashCode() {
+    return delegate().hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return delegate().toString();
+  }
+}
diff --git a/javatests/dagger/functional/spi/BUILD b/javatests/dagger/functional/spi/BUILD
new file mode 100644
index 000000000..c210b6e47
--- /dev/null
+++ b/javatests/dagger/functional/spi/BUILD
@@ -0,0 +1,53 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for the experimental Dagger SPI
+
+package(default_visibility = ["//:src"])
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+java_plugin(
+    name = "test_plugin",
+    srcs = ["TestPlugin.java"],
+    deps = [
+        "//java/dagger/internal/codegen:binding",
+        "//third_party:auto_service",
+        "//third_party:guava",
+        "//third_party:javapoet",
+    ],
+)
+
+java_library(
+    name = "test_lib",
+    exported_plugins = [":test_plugin"],
+)
+
+GenJavaTests(
+    name = "tests",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["TestPlugin.java"],
+    ),
+    test_only_deps = [
+        "//third_party:truth",
+        "//third_party:junit",
+    ],
+    deps = [
+        ":test_lib",
+        "//:dagger_with_compiler",
+        "//third_party:guava",
+    ],
+)
diff --git a/javatests/dagger/functional/spi/SpiTest.java b/javatests/dagger/functional/spi/SpiTest.java
new file mode 100644
index 000000000..05495e5c0
--- /dev/null
+++ b/javatests/dagger/functional/spi/SpiTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.spi;
+
+import static com.google.common.io.Resources.getResource;
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SpiTest {
+
+  @Component(modules = M.class)
+  interface C {
+    String string();
+  }
+
+  @Module
+  abstract static class M {
+    @Provides
+    static String string() {
+      return "string";
+    }
+  }
+
+  @Test
+  public void testPluginRuns() throws IOException {
+    Properties properties = new Properties();
+    try (InputStream stream = getResource(SpiTest.class, "SpiTest_C.properties").openStream()) {
+      properties.load(stream);
+    }
+    assertThat(properties).containsEntry("component[0]", C.class.getCanonicalName());
+  }
+}
diff --git a/javatests/dagger/functional/spi/TestPlugin.java b/javatests/dagger/functional/spi/TestPlugin.java
new file mode 100644
index 000000000..0e81514c2
--- /dev/null
+++ b/javatests/dagger/functional/spi/TestPlugin.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.spi;
+
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.auto.service.AutoService;
+import com.google.common.base.Joiner;
+import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.BindingGraphPlugin;
+import dagger.internal.codegen.BindingNetwork;
+import dagger.internal.codegen.BindingNetwork.ComponentNode;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.io.Writer;
+import java.util.Properties;
+
+@AutoService(BindingGraphPlugin.class)
+public final class TestPlugin extends BindingGraphPlugin {
+
+  @Override
+  protected void visitGraph(BindingNetwork bindingNetwork) {
+    Properties properties = new Properties();
+    int i = 0;
+    for (ComponentNode node : bindingNetwork.componentNodes()) {
+      properties.setProperty(
+          String.format("component[%s]", i++), node.componentTreePath().toString());
+    }
+    write(bindingNetwork, properties);
+  }
+
+  private void write(BindingNetwork bindingNetwork, Properties properties) {
+    ClassName rootComponentName =
+        ClassName.get(bindingNetwork.rootComponentNode().componentTreePath().currentComponent());
+    try (Writer writer =
+        filer()
+            .createResource(
+                CLASS_OUTPUT,
+                rootComponentName.packageName(),
+                Joiner.on('_').join(rootComponentName.simpleNames()) + ".properties")
+            .openWriter()) {
+      properties.store(writer, "");
+    } catch (IOException e) {
+      throw new UncheckedIOException(e);
+    }
+  }
+}
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
index d78410fe5..9ad098714 100644
--- a/tools/javadoc.bzl
+++ b/tools/javadoc.bzl
@@ -15,7 +15,7 @@
 _EXTERNAL_JAVADOC_LINKS = [
     "https://docs.oracle.com/javase/8/docs/api/",
     "https://developer.android.com/reference/",
-    "https://google.github.io/guava/releases/21.0/api/docs/",
+    "https://google.github.io/guava/releases/23.3-jre/api/docs/",
     "https://docs.oracle.com/javaee/7/api/",
 ]
 
