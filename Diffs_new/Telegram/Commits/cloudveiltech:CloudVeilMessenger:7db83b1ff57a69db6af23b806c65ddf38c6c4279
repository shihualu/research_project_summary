diff --git a/TMessagesProj/jni/NativeLoader.cpp b/TMessagesProj/jni/NativeLoader.cpp
index f2eb1ca98..c1e291707 100644
--- a/TMessagesProj/jni/NativeLoader.cpp
+++ b/TMessagesProj/jni/NativeLoader.cpp
@@ -1,7 +1,5 @@
 #include <jni.h>
 #include <stdio.h>
-#include "breakpad/client/linux/handler/exception_handler.h"
-#include "breakpad/client/linux/handler/minidump_descriptor.h"
 
 /*static google_breakpad::ExceptionHandler *exceptionHandler;
 
@@ -19,4 +17,4 @@ extern "C" {
             exceptionHandler = new google_breakpad::ExceptionHandler(descriptor, NULL, callback, NULL, true, -1);
         }*/
     }
-}
\ No newline at end of file
+}
diff --git a/TMessagesProj/jni/TgNetWrapper.cpp b/TMessagesProj/jni/TgNetWrapper.cpp
index 63728d15a..8986708cd 100644
--- a/TMessagesProj/jni/TgNetWrapper.cpp
+++ b/TMessagesProj/jni/TgNetWrapper.cpp
@@ -13,6 +13,9 @@ jmethodID jclass_RequestDelegateInternal_run;
 jclass jclass_QuickAckDelegate;
 jmethodID jclass_QuickAckDelegate_run;
 
+jclass jclass_WriteToSocketDelegate;
+jmethodID jclass_WriteToSocketDelegate_run;
+
 jclass jclass_FileLoadOperationDelegate;
 jmethodID jclass_FileLoadOperationDelegate_onFinished;
 jmethodID jclass_FileLoadOperationDelegate_onFailed;
@@ -28,6 +31,7 @@ jmethodID jclass_ConnectionsManager_onInternalPushReceived;
 jmethodID jclass_ConnectionsManager_onUpdateConfig;
 jmethodID jclass_ConnectionsManager_onBytesSent;
 jmethodID jclass_ConnectionsManager_onBytesReceived;
+jmethodID jclass_ConnectionsManager_onRequestNewServerIpAndPort;
 
 jint createLoadOpetation(JNIEnv *env, jclass c, jint dc_id, jlong id, jlong volume_id, jlong access_hash, jint local_id, jbyteArray encKey, jbyteArray encIv, jstring extension, jint version, jint size, jstring dest, jstring temp, jobject delegate) {
     if (encKey != nullptr && encIv == nullptr || encKey == nullptr && encIv != nullptr || extension == nullptr || dest == nullptr || temp == nullptr) {
@@ -157,11 +161,15 @@ jint getCurrentTime(JNIEnv *env, jclass c) {
     return ConnectionsManager::getInstance().getCurrentTime();
 }
 
+jint isTestBackend(JNIEnv *env, jclass c) {
+    return ConnectionsManager::getInstance().isTestBackend() ? 1 : 0;
+}
+
 jint getTimeDifference(JNIEnv *env, jclass c) {
     return ConnectionsManager::getInstance().getTimeDifference();
 }
 
-void sendRequest(JNIEnv *env, jclass c, jint object, jobject onComplete, jobject onQuickAck, jint flags, jint datacenterId, jint connetionType, jboolean immediate, jint token) {
+void sendRequest(JNIEnv *env, jclass c, jint object, jobject onComplete, jobject onQuickAck, jobject onWriteToSocket, jint flags, jint datacenterId, jint connetionType, jboolean immediate, jint token) {
     TL_api_request *request = new TL_api_request();
     request->request = (NativeByteBuffer *) object;
     if (onComplete != nullptr) {
@@ -170,6 +178,9 @@ void sendRequest(JNIEnv *env, jclass c, jint object, jobject onComplete, jobject
     if (onQuickAck != nullptr) {
         onQuickAck = env->NewGlobalRef(onQuickAck);
     }
+    if (onWriteToSocket != nullptr) {
+        onWriteToSocket = env->NewGlobalRef(onWriteToSocket);
+    }
     ConnectionsManager::getInstance().sendRequest(request, ([onComplete](TLObject *response, TL_error *error, int32_t networkType) {
         TL_api_response *resp = (TL_api_response *) response;
         jint ptr = 0;
@@ -191,7 +202,11 @@ void sendRequest(JNIEnv *env, jclass c, jint object, jobject onComplete, jobject
         if (onQuickAck != nullptr) {
             jniEnv->CallVoidMethod(onQuickAck, jclass_QuickAckDelegate_run);
         }
-    }), flags, datacenterId, (ConnectionType) connetionType, immediate, token, onComplete, onQuickAck);
+    }), ([onWriteToSocket] {
+        if (onWriteToSocket != nullptr) {
+            jniEnv->CallVoidMethod(onWriteToSocket, jclass_WriteToSocketDelegate_run);
+        }
+    }), flags, datacenterId, (ConnectionType) connetionType, immediate, token, onComplete, onQuickAck, onWriteToSocket);
 }
 
 void cancelRequest(JNIEnv *env, jclass c, jint token, jboolean notifyServer) {
@@ -220,6 +235,24 @@ void applyDatacenterAddress(JNIEnv *env, jclass c, jint datacenterId, jstring ip
     }
 }
 
+void setProxySettings(JNIEnv *env, jclass c, jstring address, jint port, jstring username, jstring password) {
+    const char *addressStr = env->GetStringUTFChars(address, 0);
+    const char *usernameStr = env->GetStringUTFChars(username, 0);
+    const char *passwordStr = env->GetStringUTFChars(password, 0);
+
+    ConnectionsManager::getInstance().setProxySettings(addressStr, (uint16_t) port, usernameStr, passwordStr);
+
+    if (addressStr != 0) {
+        env->ReleaseStringUTFChars(address, addressStr);
+    }
+    if (usernameStr != 0) {
+        env->ReleaseStringUTFChars(username, usernameStr);
+    }
+    if (passwordStr != 0) {
+        env->ReleaseStringUTFChars(password, passwordStr);
+    }
+}
+
 jint getConnectionState(JNIEnv *env, jclass c) {
     return ConnectionsManager::getInstance().getConnectionState();
 }
@@ -241,7 +274,7 @@ void resumeNetwork(JNIEnv *env, jclass c, jboolean partial) {
 }
 
 void updateDcSettings(JNIEnv *env, jclass c) {
-    ConnectionsManager::getInstance().updateDcSettings(0);
+    ConnectionsManager::getInstance().updateDcSettings(0, false);
 }
 
 void setUseIpv6(JNIEnv *env, jclass c, bool value) {
@@ -256,6 +289,10 @@ void setPushConnectionEnabled(JNIEnv *env, jclass c, jboolean value) {
     ConnectionsManager::getInstance().setPushConnectionEnabled(value);
 }
 
+void applyDnsConfig(JNIEnv *env, jclass c, jint address) {
+    ConnectionsManager::getInstance().applyDnsConfig((NativeByteBuffer *) address);
+}
+
 class Delegate : public ConnectiosManagerDelegate {
     
     void onUpdate() {
@@ -299,17 +336,32 @@ class Delegate : public ConnectiosManagerDelegate {
     void onBytesSent(int32_t amount, int32_t networkType) {
         jniEnv->CallStaticVoidMethod(jclass_ConnectionsManager, jclass_ConnectionsManager_onBytesSent, amount, networkType);
     }
+
+    void onRequestNewServerIpAndPort(int32_t second) {
+        jniEnv->CallStaticVoidMethod(jclass_ConnectionsManager, jclass_ConnectionsManager_onRequestNewServerIpAndPort, second);
+    }
 };
 
-void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring deviceModel, jstring systemVersion, jstring appVersion, jstring langCode, jstring configPath, jstring logPath, jint userId, jboolean enablePushConnection, jboolean hasNetwork, jint networkType) {
+void setLangCode(JNIEnv *env, jclass c, jstring langCode) {
+    const char *langCodeStr = env->GetStringUTFChars(langCode, 0);
+
+    ConnectionsManager::getInstance().setLangCode(std::string(langCodeStr));
+
+    if (langCodeStr != 0) {
+        env->ReleaseStringUTFChars(langCode, langCodeStr);
+    }
+}
+
+void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring deviceModel, jstring systemVersion, jstring appVersion, jstring langCode, jstring systemLangCode, jstring configPath, jstring logPath, jint userId, jboolean enablePushConnection, jboolean hasNetwork, jint networkType) {
     const char *deviceModelStr = env->GetStringUTFChars(deviceModel, 0);
     const char *systemVersionStr = env->GetStringUTFChars(systemVersion, 0);
     const char *appVersionStr = env->GetStringUTFChars(appVersion, 0);
     const char *langCodeStr = env->GetStringUTFChars(langCode, 0);
+    const char *systemLangCodeStr = env->GetStringUTFChars(systemLangCode, 0);
     const char *configPathStr = env->GetStringUTFChars(configPath, 0);
     const char *logPathStr = env->GetStringUTFChars(logPath, 0);
 
-    ConnectionsManager::getInstance().init(version, layer, apiId, std::string(deviceModelStr), std::string(systemVersionStr), std::string(appVersionStr), std::string(langCodeStr), std::string(configPathStr), std::string(logPathStr), userId, true, enablePushConnection, hasNetwork, networkType);
+    ConnectionsManager::getInstance().init(version, layer, apiId, std::string(deviceModelStr), std::string(systemVersionStr), std::string(appVersionStr), std::string(langCodeStr), std::string(systemLangCodeStr), std::string(configPathStr), std::string(logPathStr), userId, true, enablePushConnection, hasNetwork, networkType);
 
     if (deviceModelStr != 0) {
         env->ReleaseStringUTFChars(deviceModel, deviceModelStr);
@@ -323,6 +375,9 @@ void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring d
     if (langCodeStr != 0) {
         env->ReleaseStringUTFChars(langCode, langCodeStr);
     }
+    if (systemLangCodeStr != 0) {
+        env->ReleaseStringUTFChars(systemLangCode, systemLangCodeStr);
+    }
     if (configPathStr != 0) {
         env->ReleaseStringUTFChars(configPath, configPathStr);
     }
@@ -340,16 +395,19 @@ static const char *ConnectionsManagerClassPathName = "org/telegram/tgnet/Connect
 static JNINativeMethod ConnectionsManagerMethods[] = {
         {"native_getCurrentTimeMillis", "()J", (void *) getCurrentTimeMillis},
         {"native_getCurrentTime", "()I", (void *) getCurrentTime},
+        {"native_isTestBackend", "()I", (void *) isTestBackend},
         {"native_getTimeDifference", "()I", (void *) getTimeDifference},
-        {"native_sendRequest", "(ILorg/telegram/tgnet/RequestDelegateInternal;Lorg/telegram/tgnet/QuickAckDelegate;IIIZI)V", (void *) sendRequest},
+        {"native_sendRequest", "(ILorg/telegram/tgnet/RequestDelegateInternal;Lorg/telegram/tgnet/QuickAckDelegate;Lorg/telegram/tgnet/WriteToSocketDelegate;IIIZI)V", (void *) sendRequest},
         {"native_cancelRequest", "(IZ)V", (void *) cancelRequest},
         {"native_cleanUp", "()V", (void *) cleanUp},
         {"native_cancelRequestsForGuid", "(I)V", (void *) cancelRequestsForGuid},
         {"native_bindRequestToGuid", "(II)V", (void *) bindRequestToGuid},
         {"native_applyDatacenterAddress", "(ILjava/lang/String;I)V", (void *) applyDatacenterAddress},
+        {"native_setProxySettings", "(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V", (void *) setProxySettings},
         {"native_getConnectionState", "()I", (void *) getConnectionState},
         {"native_setUserId", "(I)V", (void *) setUserId},
-        {"native_init", "(IIILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IZZI)V", (void *) init},
+        {"native_init", "(IIILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IZZI)V", (void *) init},
+        {"native_setLangCode", "(Ljava/lang/String;)V", (void *) setLangCode},
         {"native_switchBackend", "()V", (void *) switchBackend},
         {"native_pauseNetwork", "()V", (void *) pauseNetwork},
         {"native_resumeNetwork", "(Z)V", (void *) resumeNetwork},
@@ -357,7 +415,8 @@ static JNINativeMethod ConnectionsManagerMethods[] = {
         {"native_setUseIpv6", "(Z)V", (void *) setUseIpv6},
         {"native_setNetworkAvailable", "(ZI)V", (void *) setNetworkAvailable},
         {"native_setPushConnectionEnabled", "(Z)V", (void *) setPushConnectionEnabled},
-        {"native_setJava", "(Z)V", (void *) setJava}
+        {"native_setJava", "(Z)V", (void *) setJava},
+        {"native_applyDnsConfig", "(I)V", (void *) applyDnsConfig}
 };
 
 inline int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int methodsCount) {
@@ -405,6 +464,15 @@ extern "C" int registerNativeTgNetFunctions(JavaVM *vm, JNIEnv *env) {
         return JNI_FALSE;
     }
 
+    jclass_WriteToSocketDelegate = (jclass) env->NewGlobalRef(env->FindClass("org/telegram/tgnet/WriteToSocketDelegate"));
+    if (jclass_WriteToSocketDelegate == 0) {
+        return JNI_FALSE;
+    }
+    jclass_WriteToSocketDelegate_run = env->GetMethodID(jclass_WriteToSocketDelegate, "run", "()V");
+    if (jclass_WriteToSocketDelegate_run == 0) {
+        return JNI_FALSE;
+    }
+
     jclass_FileLoadOperationDelegate = (jclass) env->NewGlobalRef(env->FindClass("org/telegram/tgnet/FileLoadOperationDelegate"));
     if (jclass_FileLoadOperationDelegate == 0) {
         return JNI_FALSE;
@@ -465,6 +533,10 @@ extern "C" int registerNativeTgNetFunctions(JavaVM *vm, JNIEnv *env) {
     if (jclass_ConnectionsManager_onBytesReceived == 0) {
         return JNI_FALSE;
     }
+    jclass_ConnectionsManager_onRequestNewServerIpAndPort = env->GetStaticMethodID(jclass_ConnectionsManager, "onRequestNewServerIpAndPort", "(I)V");
+    if (jclass_ConnectionsManager_onRequestNewServerIpAndPort == 0) {
+        return JNI_FALSE;
+    }
     ConnectionsManager::getInstance().setDelegate(new Delegate());
     
     return JNI_TRUE;
diff --git a/TMessagesProj/jni/breakpad/LICENSE b/TMessagesProj/jni/breakpad/LICENSE
deleted file mode 100644
index 95207bdf6..000000000
--- a/TMessagesProj/jni/breakpad/LICENSE
+++ /dev/null
@@ -1,50 +0,0 @@
-Copyright (c) 2006, Google Inc.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    * Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-copyright notice, this list of conditions and the following disclaimer
-in the documentation and/or other materials provided with the
-distribution.
-    * Neither the name of Google Inc. nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
---------------------------------------------------------------------
-
-Copyright 2001-2004 Unicode, Inc.
-
-Disclaimer
-
-This source code is provided as is by Unicode, Inc. No claims are
-made as to fitness for any particular purpose. No warranties of any
-kind are expressed or implied. The recipient agrees to determine
-applicability of information provided. If this file has been
-purchased on magnetic or optical media from Unicode, Inc., the
-sole remedy for any claim will be exchange of defective media
-within 90 days of receipt.
-
-Limitations on Rights to Redistribute This Code
-
-Unicode, Inc. hereby grants the right to freely use the information
-supplied in this file in the creation of products supporting the
-Unicode Standard, and to make copies of this file in any form
-for internal or external distribution as long as this notice
-remains attached.
diff --git a/TMessagesProj/jni/breakpad/client/linux/crash_generation/client_info.h b/TMessagesProj/jni/breakpad/client/linux/crash_generation/client_info.h
deleted file mode 100644
index d0a184a63..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/crash_generation/client_info.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_CRASH_GENERATION_CLIENT_INFO_H_
-#define CLIENT_LINUX_CRASH_GENERATION_CLIENT_INFO_H_
-
-namespace google_breakpad {
-
-class CrashGenerationServer;
-
-class ClientInfo {
- public:
-  ClientInfo(pid_t pid, CrashGenerationServer* crash_server)
-    : crash_server_(crash_server),
-      pid_(pid) {}
-
-  CrashGenerationServer* crash_server() const { return crash_server_; }
-  pid_t pid() const { return pid_; }
-
- private:
-  CrashGenerationServer* crash_server_;
-  pid_t pid_;
-};
-
-}
-
-#endif // CLIENT_LINUX_CRASH_GENERATION_CLIENT_INFO_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.cc b/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.cc
deleted file mode 100644
index d8bfbbad2..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.cc
+++ /dev/null
@@ -1,105 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "client/linux/crash_generation/crash_generation_client.h"
-
-#include <stdio.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-
-#include <algorithm>
-
-#include "common/linux/eintr_wrapper.h"
-#include "common/linux/ignore_ret.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-namespace {
-
-class CrashGenerationClientImpl : public CrashGenerationClient {
- public:
-  explicit CrashGenerationClientImpl(int server_fd) : server_fd_(server_fd) {}
-  virtual ~CrashGenerationClientImpl() {}
-
-  virtual bool RequestDump(const void* blob, size_t blob_size) {
-    int fds[2];
-    if (sys_pipe(fds) < 0)
-      return false;
-    static const unsigned kControlMsgSize = CMSG_SPACE(sizeof(int));
-
-    struct kernel_iovec iov;
-    iov.iov_base = const_cast<void*>(blob);
-    iov.iov_len = blob_size;
-
-    struct kernel_msghdr msg = { 0 };
-    msg.msg_iov = &iov;
-    msg.msg_iovlen = 1;
-    char cmsg[kControlMsgSize] = "";
-    msg.msg_control = cmsg;
-    msg.msg_controllen = sizeof(cmsg);
-
-    struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg);
-    hdr->cmsg_level = SOL_SOCKET;
-    hdr->cmsg_type = SCM_RIGHTS;
-    hdr->cmsg_len = CMSG_LEN(sizeof(int));
-    int* p = reinterpret_cast<int*>(CMSG_DATA(hdr));
-    *p = fds[1];
-
-    ssize_t ret = HANDLE_EINTR(sys_sendmsg(server_fd_, &msg, 0));
-    sys_close(fds[1]);
-    if (ret < 0) {
-      sys_close(fds[0]);
-      return false;
-    }
-
-    // Wait for an ACK from the server.
-    char b;
-    IGNORE_RET(HANDLE_EINTR(sys_read(fds[0], &b, 1)));
-    sys_close(fds[0]);
-
-    return true;
-  }
-
- private:
-  int server_fd_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashGenerationClientImpl);
-};
-
-}  // namespace
-
-// static
-CrashGenerationClient* CrashGenerationClient::TryCreate(int server_fd) {
-  if (server_fd < 0)
-    return NULL;
-  return new CrashGenerationClientImpl(server_fd);
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.h b/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.h
deleted file mode 100644
index 4e68424ae..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/crash_generation/crash_generation_client.h
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
-#define CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
-
-#include "common/basictypes.h"
-
-#include <stddef.h>
-
-namespace google_breakpad {
-
-// CrashGenerationClient is an interface for implementing out-of-process crash
-// dumping.  The default implementation, accessed via the TryCreate() factory,
-// works in conjunction with the CrashGenerationServer to generate a minidump
-// via a remote process.
-class CrashGenerationClient {
- public:
-  CrashGenerationClient() {}
-  virtual ~CrashGenerationClient() {}
-
-  // Request the crash server to generate a dump.  |blob| is an opaque
-  // CrashContext pointer from exception_handler.h.
-  // Returns true if the dump was successful; false otherwise.
-  virtual bool RequestDump(const void* blob, size_t blob_size) = 0;
-
-  // Returns a new CrashGenerationClient if |server_fd| is valid and
-  // connects to a CrashGenerationServer.  Otherwise, return NULL.
-  // The returned CrashGenerationClient* is owned by the caller of
-  // this function.
-  static CrashGenerationClient* TryCreate(int server_fd);
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(CrashGenerationClient);
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/mapping_info.h b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/mapping_info.h
deleted file mode 100644
index 5f247cfd4..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/mapping_info.h
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
-#define CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
-
-#include <limits.h>
-#include <list>
-#include <stdint.h>
-
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-// One of these is produced for each mapping in the process (i.e. line in
-// /proc/$x/maps).
-struct MappingInfo {
-  uintptr_t start_addr;
-  size_t size;
-  size_t offset;  // offset into the backed file.
-  bool exec;  // true if the mapping has the execute bit set.
-  char name[NAME_MAX];
-};
-
-struct MappingEntry {
-  MappingInfo first;
-  uint8_t second[sizeof(MDGUID)];
-};
-
-// A list of <MappingInfo, GUID>
-typedef std::list<MappingEntry> MappingList;
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/raw_context_cpu.h b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/raw_context_cpu.h
deleted file mode 100644
index e2ef45df5..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/raw_context_cpu.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
-#define CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
-
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-#if defined(__i386__)
-typedef MDRawContextX86 RawContextCPU;
-#elif defined(__x86_64)
-typedef MDRawContextAMD64 RawContextCPU;
-#elif defined(__ARM_EABI__)
-typedef MDRawContextARM RawContextCPU;
-#elif defined(__aarch64__)
-typedef MDRawContextARM64 RawContextCPU;
-#elif defined(__mips__)
-typedef MDRawContextMIPS RawContextCPU;
-#else
-#error "This code has not been ported to your platform yet."
-#endif
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.cc b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.cc
deleted file mode 100644
index 9956d4450..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.cc
+++ /dev/null
@@ -1,299 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "client/linux/dump_writer_common/thread_info.h"
-
-#include <string.h>
-#include <assert.h>
-
-#include "common/linux/linux_libc_support.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace {
-
-#if defined(__i386__)
-// Write a uint16_t to memory
-//   out: memory location to write to
-//   v: value to write.
-void U16(void* out, uint16_t v) {
-  my_memcpy(out, &v, sizeof(v));
-}
-
-// Write a uint32_t to memory
-//   out: memory location to write to
-//   v: value to write.
-void U32(void* out, uint32_t v) {
-  my_memcpy(out, &v, sizeof(v));
-}
-#endif
-
-}
-
-namespace google_breakpad {
-
-#if defined(__i386__)
-
-uintptr_t ThreadInfo::GetInstructionPointer() const {
-  return regs.eip;
-}
-
-void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
-  out->context_flags = MD_CONTEXT_X86_ALL;
-
-  out->dr0 = dregs[0];
-  out->dr1 = dregs[1];
-  out->dr2 = dregs[2];
-  out->dr3 = dregs[3];
-  // 4 and 5 deliberatly omitted because they aren't included in the minidump
-  // format.
-  out->dr6 = dregs[6];
-  out->dr7 = dregs[7];
-
-  out->gs = regs.xgs;
-  out->fs = regs.xfs;
-  out->es = regs.xes;
-  out->ds = regs.xds;
-
-  out->edi = regs.edi;
-  out->esi = regs.esi;
-  out->ebx = regs.ebx;
-  out->edx = regs.edx;
-  out->ecx = regs.ecx;
-  out->eax = regs.eax;
-
-  out->ebp = regs.ebp;
-  out->eip = regs.eip;
-  out->cs = regs.xcs;
-  out->eflags = regs.eflags;
-  out->esp = regs.esp;
-  out->ss = regs.xss;
-
-  out->float_save.control_word = fpregs.cwd;
-  out->float_save.status_word = fpregs.swd;
-  out->float_save.tag_word = fpregs.twd;
-  out->float_save.error_offset = fpregs.fip;
-  out->float_save.error_selector = fpregs.fcs;
-  out->float_save.data_offset = fpregs.foo;
-  out->float_save.data_selector = fpregs.fos;
-
-  // 8 registers * 10 bytes per register.
-  my_memcpy(out->float_save.register_area, fpregs.st_space, 10 * 8);
-
-  // This matches the Intel fpsave format.
-  U16(out->extended_registers + 0, fpregs.cwd);
-  U16(out->extended_registers + 2, fpregs.swd);
-  U16(out->extended_registers + 4, fpregs.twd);
-  U16(out->extended_registers + 6, fpxregs.fop);
-  U32(out->extended_registers + 8, fpxregs.fip);
-  U16(out->extended_registers + 12, fpxregs.fcs);
-  U32(out->extended_registers + 16, fpregs.foo);
-  U16(out->extended_registers + 20, fpregs.fos);
-  U32(out->extended_registers + 24, fpxregs.mxcsr);
-
-  my_memcpy(out->extended_registers + 32, &fpxregs.st_space, 128);
-  my_memcpy(out->extended_registers + 160, &fpxregs.xmm_space, 128);
-}
-
-#elif defined(__x86_64)
-
-uintptr_t ThreadInfo::GetInstructionPointer() const {
-  return regs.rip;
-}
-
-void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
-  out->context_flags = MD_CONTEXT_AMD64_FULL |
-                       MD_CONTEXT_AMD64_SEGMENTS;
-
-  out->cs = regs.cs;
-
-  out->ds = regs.ds;
-  out->es = regs.es;
-  out->fs = regs.fs;
-  out->gs = regs.gs;
-
-  out->ss = regs.ss;
-  out->eflags = regs.eflags;
-
-  out->dr0 = dregs[0];
-  out->dr1 = dregs[1];
-  out->dr2 = dregs[2];
-  out->dr3 = dregs[3];
-  // 4 and 5 deliberatly omitted because they aren't included in the minidump
-  // format.
-  out->dr6 = dregs[6];
-  out->dr7 = dregs[7];
-
-  out->rax = regs.rax;
-  out->rcx = regs.rcx;
-  out->rdx = regs.rdx;
-  out->rbx = regs.rbx;
-
-  out->rsp = regs.rsp;
-
-  out->rbp = regs.rbp;
-  out->rsi = regs.rsi;
-  out->rdi = regs.rdi;
-  out->r8 = regs.r8;
-  out->r9 = regs.r9;
-  out->r10 = regs.r10;
-  out->r11 = regs.r11;
-  out->r12 = regs.r12;
-  out->r13 = regs.r13;
-  out->r14 = regs.r14;
-  out->r15 = regs.r15;
-
-  out->rip = regs.rip;
-
-  out->flt_save.control_word = fpregs.cwd;
-  out->flt_save.status_word = fpregs.swd;
-  out->flt_save.tag_word = fpregs.ftw;
-  out->flt_save.error_opcode = fpregs.fop;
-  out->flt_save.error_offset = fpregs.rip;
-  out->flt_save.error_selector = 0;  // We don't have this.
-  out->flt_save.data_offset = fpregs.rdp;
-  out->flt_save.data_selector = 0;   // We don't have this.
-  out->flt_save.mx_csr = fpregs.mxcsr;
-  out->flt_save.mx_csr_mask = fpregs.mxcr_mask;
-
-  my_memcpy(&out->flt_save.float_registers, &fpregs.st_space, 8 * 16);
-  my_memcpy(&out->flt_save.xmm_registers, &fpregs.xmm_space, 16 * 16);
-}
-
-#elif defined(__ARM_EABI__)
-
-uintptr_t ThreadInfo::GetInstructionPointer() const {
-  return regs.uregs[15];
-}
-
-void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
-  out->context_flags = MD_CONTEXT_ARM_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_ARM_GPR_COUNT; ++i)
-    out->iregs[i] = regs.uregs[i];
-  // No CPSR register in ThreadInfo(it's not accessible via ptrace)
-  out->cpsr = 0;
-#if !defined(__ANDROID__)
-  out->float_save.fpscr = fpregs.fpsr |
-    (static_cast<uint64_t>(fpregs.fpcr) << 32);
-  // TODO: sort this out, actually collect floating point registers
-  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
-  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
-#endif
-}
-
-#elif defined(__aarch64__)
-
-uintptr_t ThreadInfo::GetInstructionPointer() const {
-  return regs.pc;
-}
-
-void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
-  out->context_flags = MD_CONTEXT_ARM64_FULL;
-
-  out->cpsr = static_cast<uint32_t>(regs.pstate);
-  for (int i = 0; i < MD_CONTEXT_ARM64_REG_SP; ++i)
-    out->iregs[i] = regs.regs[i];
-  out->iregs[MD_CONTEXT_ARM64_REG_SP] = regs.sp;
-  out->iregs[MD_CONTEXT_ARM64_REG_PC] = regs.pc;
-
-  out->float_save.fpsr = fpregs.fpsr;
-  out->float_save.fpcr = fpregs.fpcr;
-  my_memcpy(&out->float_save.regs, &fpregs.vregs,
-      MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
-}
-
-#elif defined(__mips__)
-
-uintptr_t ThreadInfo::GetInstructionPointer() const {
-  return mcontext.pc;
-}
-
-void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
-  out->context_flags = MD_CONTEXT_MIPS_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
-    out->iregs[i] = mcontext.gregs[i];
-
-  out->mdhi = mcontext.mdhi;
-  out->mdlo = mcontext.mdlo;
-  out->dsp_control = mcontext.dsp;
-
-  out->hi[0] = mcontext.hi1;
-  out->lo[0] = mcontext.lo1;
-  out->hi[1] = mcontext.hi2;
-  out->lo[1] = mcontext.lo2;
-  out->hi[2] = mcontext.hi3;
-  out->lo[2] = mcontext.lo3;
-
-  out->epc = mcontext.pc;
-  out->badvaddr = 0; // Not stored in mcontext
-  out->status = 0; // Not stored in mcontext
-  out->cause = 0; // Not stored in mcontext
-
-  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
-    out->float_save.regs[i] = mcontext.fpregs.fp_r.fp_fregs[i]._fp_fregs;
-
-  out->float_save.fpcsr = mcontext.fpc_csr;
-#if _MIPS_SIM == _ABIO32
-  out->float_save.fir = mcontext.fpc_eir;
-#endif
-}
-#endif  // __mips__
-
-void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
-  assert(gp_regs || size);
-#if defined(__mips__)
-  if (gp_regs)
-    *gp_regs = mcontext.gregs;
-  if (size)
-    *size = sizeof(mcontext.gregs);
-#else
-  if (gp_regs)
-    *gp_regs = &regs;
-  if (size)
-    *size = sizeof(regs);
-#endif
-}
-
-void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
-  assert(fp_regs || size);
-#if defined(__mips__)
-  if (fp_regs)
-    *fp_regs = &mcontext.fpregs;
-  if (size)
-    *size = sizeof(mcontext.fpregs);
-#else
-  if (fp_regs)
-    *fp_regs = &fpregs;
-  if (size)
-    *size = sizeof(fpregs);
-#endif
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.h b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.h
deleted file mode 100644
index 99093d2e0..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/thread_info.h
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
-#define CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
-
-#include <sys/ucontext.h>
-#include <sys/user.h>
-
-#include "client/linux/dump_writer_common/raw_context_cpu.h"
-#include "common/memory.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-#if defined(__i386) || defined(__x86_64)
-typedef __typeof__(((struct user*) 0)->u_debugreg[0]) debugreg_t;
-#endif
-
-// We produce one of these structures for each thread in the crashed process.
-struct ThreadInfo {
-  pid_t tgid;   // thread group id
-  pid_t ppid;   // parent process
-
-  uintptr_t stack_pointer;  // thread stack pointer
-
-
-#if defined(__i386) || defined(__x86_64)
-  user_regs_struct regs;
-  user_fpregs_struct fpregs;
-  static const unsigned kNumDebugRegisters = 8;
-  debugreg_t dregs[8];
-#if defined(__i386)
-  user_fpxregs_struct fpxregs;
-#endif  // defined(__i386)
-
-#elif defined(__ARM_EABI__)
-  // Mimicking how strace does this(see syscall.c, search for GETREGS)
-  struct user_regs regs;
-  struct user_fpregs fpregs;
-#elif defined(__aarch64__)
-  // Use the structures defined in <sys/user.h>
-  struct user_regs_struct regs;
-  struct user_fpsimd_struct fpregs;
-#elif defined(__mips__)
-  // Use the structure defined in <sys/ucontext.h>.
-  mcontext_t mcontext;
-#endif
-
-  // Returns the instruction pointer (platform-dependent impl.).
-  uintptr_t GetInstructionPointer() const;
-
-  // Fills a RawContextCPU using the context in the ThreadInfo object.
-  void FillCPUContext(RawContextCPU* out) const;
-
-  // Returns the pointer and size of general purpose register area.
-  void GetGeneralPurposeRegisters(void** gp_regs, size_t* size);
-
-  // Returns the pointer and size of float point register area.
-  void GetFloatingPointRegisters(void** fp_regs, size_t* size);
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.cc b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.cc
deleted file mode 100644
index d37fdeb01..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.cc
+++ /dev/null
@@ -1,253 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "client/linux/dump_writer_common/ucontext_reader.h"
-
-#include "common/linux/linux_libc_support.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-// Minidump defines register structures which are different from the raw
-// structures which we get from the kernel. These are platform specific
-// functions to juggle the ucontext and user structures into minidump format.
-
-#if defined(__i386__)
-
-uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.gregs[REG_ESP];
-}
-
-uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.gregs[REG_EIP];
-}
-
-void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc,
-                                    const struct _libc_fpstate* fp) {
-  const greg_t* regs = uc->uc_mcontext.gregs;
-
-  out->context_flags = MD_CONTEXT_X86_FULL |
-                       MD_CONTEXT_X86_FLOATING_POINT;
-
-  out->gs = regs[REG_GS];
-  out->fs = regs[REG_FS];
-  out->es = regs[REG_ES];
-  out->ds = regs[REG_DS];
-
-  out->edi = regs[REG_EDI];
-  out->esi = regs[REG_ESI];
-  out->ebx = regs[REG_EBX];
-  out->edx = regs[REG_EDX];
-  out->ecx = regs[REG_ECX];
-  out->eax = regs[REG_EAX];
-
-  out->ebp = regs[REG_EBP];
-  out->eip = regs[REG_EIP];
-  out->cs = regs[REG_CS];
-  out->eflags = regs[REG_EFL];
-  out->esp = regs[REG_UESP];
-  out->ss = regs[REG_SS];
-
-  out->float_save.control_word = fp->cw;
-  out->float_save.status_word = fp->sw;
-  out->float_save.tag_word = fp->tag;
-  out->float_save.error_offset = fp->ipoff;
-  out->float_save.error_selector = fp->cssel;
-  out->float_save.data_offset = fp->dataoff;
-  out->float_save.data_selector = fp->datasel;
-
-  // 8 registers * 10 bytes per register.
-  my_memcpy(out->float_save.register_area, fp->_st, 10 * 8);
-}
-
-#elif defined(__x86_64)
-
-uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.gregs[REG_RSP];
-}
-
-uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.gregs[REG_RIP];
-}
-
-void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc,
-                                    const struct _libc_fpstate* fpregs) {
-  const greg_t* regs = uc->uc_mcontext.gregs;
-
-  out->context_flags = MD_CONTEXT_AMD64_FULL;
-
-  out->cs = regs[REG_CSGSFS] & 0xffff;
-
-  out->fs = (regs[REG_CSGSFS] >> 32) & 0xffff;
-  out->gs = (regs[REG_CSGSFS] >> 16) & 0xffff;
-
-  out->eflags = regs[REG_EFL];
-
-  out->rax = regs[REG_RAX];
-  out->rcx = regs[REG_RCX];
-  out->rdx = regs[REG_RDX];
-  out->rbx = regs[REG_RBX];
-
-  out->rsp = regs[REG_RSP];
-  out->rbp = regs[REG_RBP];
-  out->rsi = regs[REG_RSI];
-  out->rdi = regs[REG_RDI];
-  out->r8 = regs[REG_R8];
-  out->r9 = regs[REG_R9];
-  out->r10 = regs[REG_R10];
-  out->r11 = regs[REG_R11];
-  out->r12 = regs[REG_R12];
-  out->r13 = regs[REG_R13];
-  out->r14 = regs[REG_R14];
-  out->r15 = regs[REG_R15];
-
-  out->rip = regs[REG_RIP];
-
-  out->flt_save.control_word = fpregs->cwd;
-  out->flt_save.status_word = fpregs->swd;
-  out->flt_save.tag_word = fpregs->ftw;
-  out->flt_save.error_opcode = fpregs->fop;
-  out->flt_save.error_offset = fpregs->rip;
-  out->flt_save.data_offset = fpregs->rdp;
-  out->flt_save.error_selector = 0;  // We don't have this.
-  out->flt_save.data_selector = 0;  // We don't have this.
-  out->flt_save.mx_csr = fpregs->mxcsr;
-  out->flt_save.mx_csr_mask = fpregs->mxcr_mask;
-  my_memcpy(&out->flt_save.float_registers, &fpregs->_st, 8 * 16);
-  my_memcpy(&out->flt_save.xmm_registers, &fpregs->_xmm, 16 * 16);
-}
-
-#elif defined(__ARM_EABI__)
-
-uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.arm_sp;
-}
-
-uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.arm_pc;
-}
-
-void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc) {
-  out->context_flags = MD_CONTEXT_ARM_FULL;
-
-  out->iregs[0] = uc->uc_mcontext.arm_r0;
-  out->iregs[1] = uc->uc_mcontext.arm_r1;
-  out->iregs[2] = uc->uc_mcontext.arm_r2;
-  out->iregs[3] = uc->uc_mcontext.arm_r3;
-  out->iregs[4] = uc->uc_mcontext.arm_r4;
-  out->iregs[5] = uc->uc_mcontext.arm_r5;
-  out->iregs[6] = uc->uc_mcontext.arm_r6;
-  out->iregs[7] = uc->uc_mcontext.arm_r7;
-  out->iregs[8] = uc->uc_mcontext.arm_r8;
-  out->iregs[9] = uc->uc_mcontext.arm_r9;
-  out->iregs[10] = uc->uc_mcontext.arm_r10;
-
-  out->iregs[11] = uc->uc_mcontext.arm_fp;
-  out->iregs[12] = uc->uc_mcontext.arm_ip;
-  out->iregs[13] = uc->uc_mcontext.arm_sp;
-  out->iregs[14] = uc->uc_mcontext.arm_lr;
-  out->iregs[15] = uc->uc_mcontext.arm_pc;
-
-  out->cpsr = uc->uc_mcontext.arm_cpsr;
-
-  // TODO: fix this after fixing ExceptionHandler
-  out->float_save.fpscr = 0;
-  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
-  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
-}
-
-#elif defined(__aarch64__)
-
-uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.sp;
-}
-
-uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.pc;
-}
-
-void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc,
-                                    const struct fpsimd_context* fpregs) {
-  out->context_flags = MD_CONTEXT_ARM64_FULL;
-
-  out->cpsr = static_cast<uint32_t>(uc->uc_mcontext.pstate);
-  for (int i = 0; i < MD_CONTEXT_ARM64_REG_SP; ++i)
-    out->iregs[i] = uc->uc_mcontext.regs[i];
-  out->iregs[MD_CONTEXT_ARM64_REG_SP] = uc->uc_mcontext.sp;
-  out->iregs[MD_CONTEXT_ARM64_REG_PC] = uc->uc_mcontext.pc;
-
-  out->float_save.fpsr = fpregs->fpsr;
-  out->float_save.fpcr = fpregs->fpcr;
-  my_memcpy(&out->float_save.regs, &fpregs->vregs,
-      MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
-}
-
-#elif defined(__mips__)
-
-uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP];
-}
-
-uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
-  return uc->uc_mcontext.pc;
-}
-
-void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc) {
-  out->context_flags = MD_CONTEXT_MIPS_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
-    out->iregs[i] = uc->uc_mcontext.gregs[i];
-
-  out->mdhi = uc->uc_mcontext.mdhi;
-  out->mdlo = uc->uc_mcontext.mdlo;
-
-  out->hi[0] = uc->uc_mcontext.hi1;
-  out->hi[1] = uc->uc_mcontext.hi2;
-  out->hi[2] = uc->uc_mcontext.hi3;
-  out->lo[0] = uc->uc_mcontext.lo1;
-  out->lo[1] = uc->uc_mcontext.lo2;
-  out->lo[2] = uc->uc_mcontext.lo3;
-  out->dsp_control = uc->uc_mcontext.dsp;
-
-  out->epc = uc->uc_mcontext.pc;
-  out->badvaddr = 0;  // Not reported in signal context.
-  out->status = 0;  // Not reported in signal context.
-  out->cause = 0;  // Not reported in signal context.
-
-  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
-    out->float_save.regs[i] = uc->uc_mcontext.fpregs.fp_r.fp_dregs[i];
-
-  out->float_save.fpcsr = uc->uc_mcontext.fpc_csr;
-#if _MIPS_SIM == _ABIO32
-  out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
-#endif
-}
-#endif
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.h b/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.h
deleted file mode 100644
index b6e77b4b5..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/dump_writer_common/ucontext_reader.h
+++ /dev/null
@@ -1,64 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
-#define CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
-
-#include <sys/ucontext.h>
-#include <sys/user.h>
-
-#include "client/linux/dump_writer_common/raw_context_cpu.h"
-#include "common/memory.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-// Wraps platform-dependent implementations of accessors to ucontext structs.
-struct UContextReader {
-  static uintptr_t GetStackPointer(const struct ucontext* uc);
-
-  static uintptr_t GetInstructionPointer(const struct ucontext* uc);
-
-  // Juggle a arch-specific ucontext into a minidump format
-  //   out: the minidump structure
-  //   info: the collection of register structures.
-#if defined(__i386__) || defined(__x86_64)
-  static void FillCPUContext(RawContextCPU *out, const ucontext *uc,
-                             const struct _libc_fpstate* fp);
-#elif defined(__aarch64__)
-  static void FillCPUContext(RawContextCPU *out, const ucontext *uc,
-                             const struct fpsimd_context* fpregs);
-#else
-  static void FillCPUContext(RawContextCPU *out, const ucontext *uc);
-#endif
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
diff --git a/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.cc b/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.cc
deleted file mode 100644
index 9b20fe251..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.cc
+++ /dev/null
@@ -1,754 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// The ExceptionHandler object installs signal handlers for a number of
-// signals. We rely on the signal handler running on the thread which crashed
-// in order to identify it. This is true of the synchronous signals (SEGV etc),
-// but not true of ABRT. Thus, if you send ABRT to yourself in a program which
-// uses ExceptionHandler, you need to use tgkill to direct it to the current
-// thread.
-//
-// The signal flow looks like this:
-//
-//   SignalHandler (uses a global stack of ExceptionHandler objects to find
-//        |         one to handle the signal. If the first rejects it, try
-//        |         the second etc...)
-//        V
-//   HandleSignal ----------------------------| (clones a new process which
-//        |                                   |  shares an address space with
-//   (wait for cloned                         |  the crashed process. This
-//     process)                               |  allows us to ptrace the crashed
-//        |                                   |  process)
-//        V                                   V
-//   (set signal handler to             ThreadEntry (static function to bounce
-//    SIG_DFL and rethrow,                    |      back into the object)
-//    killing the crashed                     |
-//    process)                                V
-//                                          DoDump  (writes minidump)
-//                                            |
-//                                            V
-//                                         sys_exit
-//
-
-// This code is a little fragmented. Different functions of the ExceptionHandler
-// class run in a number of different contexts. Some of them run in a normal
-// context and are easy to code, others run in a compromised context and the
-// restrictions at the top of minidump_writer.cc apply: no libc and use the
-// alternative malloc. Each function should have comment above it detailing the
-// context which it runs in.
-
-#include "client/linux/handler/exception_handler.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <linux/limits.h>
-#include <pthread.h>
-#include <sched.h>
-#include <signal.h>
-#include <stdio.h>
-#include <sys/mman.h>
-#include <sys/prctl.h>
-#include <sys/syscall.h>
-#include <sys/wait.h>
-#include <unistd.h>
-
-#include <sys/signal.h>
-#include <sys/ucontext.h>
-#include <sys/user.h>
-#include <ucontext.h>
-
-#include <algorithm>
-#include <utility>
-#include <vector>
-
-#include "common/basictypes.h"
-#include "common/linux/linux_libc_support.h"
-#include "common/memory.h"
-#include "client/linux/log/log.h"
-#include "client/linux/microdump_writer/microdump_writer.h"
-#include "client/linux/minidump_writer/linux_dumper.h"
-#include "client/linux/minidump_writer/minidump_writer.h"
-#include "common/linux/eintr_wrapper.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-#if defined(__ANDROID__)
-#include "linux/sched.h"
-#endif
-
-#ifndef PR_SET_PTRACER
-#define PR_SET_PTRACER 0x59616d61
-#endif
-
-// A wrapper for the tgkill syscall: send a signal to a specific thread.
-static int tgkill(pid_t tgid, pid_t tid, int sig) {
-  return syscall(__NR_tgkill, tgid, tid, sig);
-  return 0;
-}
-
-namespace google_breakpad {
-
-namespace {
-// The list of signals which we consider to be crashes. The default action for
-// all these signals must be Core (see man 7 signal) because we rethrow the
-// signal after handling it and expect that it'll be fatal.
-const int kExceptionSignals[] = {
-  SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS
-};
-const int kNumHandledSignals =
-    sizeof(kExceptionSignals) / sizeof(kExceptionSignals[0]);
-struct sigaction old_handlers[kNumHandledSignals];
-bool handlers_installed = false;
-
-// InstallAlternateStackLocked will store the newly installed stack in new_stack
-// and (if it exists) the previously installed stack in old_stack.
-stack_t old_stack;
-stack_t new_stack;
-bool stack_installed = false;
-
-// Create an alternative stack to run the signal handlers on. This is done since
-// the signal might have been caused by a stack overflow.
-// Runs before crashing: normal context.
-void InstallAlternateStackLocked() {
-  if (stack_installed)
-    return;
-
-  memset(&old_stack, 0, sizeof(old_stack));
-  memset(&new_stack, 0, sizeof(new_stack));
-
-  // SIGSTKSZ may be too small to prevent the signal handlers from overrunning
-  // the alternative stack. Ensure that the size of the alternative stack is
-  // large enough.
-  static const unsigned kSigStackSize = std::max(16384, SIGSTKSZ);
-
-  // Only set an alternative stack if there isn't already one, or if the current
-  // one is too small.
-  if (sys_sigaltstack(NULL, &old_stack) == -1 || !old_stack.ss_sp ||
-      old_stack.ss_size < kSigStackSize) {
-    new_stack.ss_sp = calloc(1, kSigStackSize);
-    new_stack.ss_size = kSigStackSize;
-
-    if (sys_sigaltstack(&new_stack, NULL) == -1) {
-      free(new_stack.ss_sp);
-      return;
-    }
-    stack_installed = true;
-  }
-}
-
-// Runs before crashing: normal context.
-void RestoreAlternateStackLocked() {
-  if (!stack_installed)
-    return;
-
-  stack_t current_stack;
-  if (sys_sigaltstack(NULL, &current_stack) == -1)
-    return;
-
-  // Only restore the old_stack if the current alternative stack is the one
-  // installed by the call to InstallAlternateStackLocked.
-  if (current_stack.ss_sp == new_stack.ss_sp) {
-    if (old_stack.ss_sp) {
-      if (sys_sigaltstack(&old_stack, NULL) == -1)
-        return;
-    } else {
-      stack_t disable_stack;
-      disable_stack.ss_flags = SS_DISABLE;
-      if (sys_sigaltstack(&disable_stack, NULL) == -1)
-        return;
-    }
-  }
-
-  free(new_stack.ss_sp);
-  stack_installed = false;
-}
-
-void InstallDefaultHandler(int sig) {
-#if defined(__ANDROID__)
-  // Android L+ expose signal and sigaction symbols that override the system
-  // ones. There is a bug in these functions where a request to set the handler
-  // to SIG_DFL is ignored. In that case, an infinite loop is entered as the
-  // signal is repeatedly sent to breakpad's signal handler.
-  // To work around this, directly call the system's sigaction.
-  struct kernel_sigaction sa;
-  memset(&sa, 0, sizeof(sa));
-  sys_sigemptyset(&sa.sa_mask);
-  sa.sa_handler_ = SIG_DFL;
-  sa.sa_flags = SA_RESTART;
-  sys_rt_sigaction(sig, &sa, NULL, sizeof(kernel_sigset_t));
-#else
-  signal(sig, SIG_DFL);
-#endif
-}
-
-// The global exception handler stack. This is needed because there may exist
-// multiple ExceptionHandler instances in a process. Each will have itself
-// registered in this stack.
-std::vector<ExceptionHandler*>* g_handler_stack_ = NULL;
-pthread_mutex_t g_handler_stack_mutex_ = PTHREAD_MUTEX_INITIALIZER;
-
-}  // namespace
-
-// Runs before crashing: normal context.
-ExceptionHandler::ExceptionHandler(const MinidumpDescriptor& descriptor,
-                                   FilterCallback filter,
-                                   MinidumpCallback callback,
-                                   void* callback_context,
-                                   bool install_handler,
-                                   const int server_fd)
-    : filter_(filter),
-      callback_(callback),
-      callback_context_(callback_context),
-      minidump_descriptor_(descriptor),
-      crash_handler_(NULL) {
-  if (server_fd >= 0)
-    crash_generation_client_.reset(CrashGenerationClient::TryCreate(server_fd));
-
-  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD() &&
-      !minidump_descriptor_.IsMicrodumpOnConsole())
-    minidump_descriptor_.UpdatePath();
-
-#if defined(__ANDROID__)
-  if (minidump_descriptor_.IsMicrodumpOnConsole())
-    logger::initializeCrashLogWriter();
-#endif
-
-  pthread_mutex_lock(&g_handler_stack_mutex_);
-  if (!g_handler_stack_)
-    g_handler_stack_ = new std::vector<ExceptionHandler*>;
-  if (install_handler) {
-    InstallAlternateStackLocked();
-    InstallHandlersLocked();
-  }
-  g_handler_stack_->push_back(this);
-  pthread_mutex_unlock(&g_handler_stack_mutex_);
-}
-
-// Runs before crashing: normal context.
-ExceptionHandler::~ExceptionHandler() {
-  pthread_mutex_lock(&g_handler_stack_mutex_);
-  std::vector<ExceptionHandler*>::iterator handler =
-      std::find(g_handler_stack_->begin(), g_handler_stack_->end(), this);
-  g_handler_stack_->erase(handler);
-  if (g_handler_stack_->empty()) {
-    delete g_handler_stack_;
-    g_handler_stack_ = NULL;
-    RestoreAlternateStackLocked();
-    RestoreHandlersLocked();
-  }
-  pthread_mutex_unlock(&g_handler_stack_mutex_);
-}
-
-// Runs before crashing: normal context.
-// static
-bool ExceptionHandler::InstallHandlersLocked() {
-  if (handlers_installed)
-    return false;
-
-  // Fail if unable to store all the old handlers.
-  for (int i = 0; i < kNumHandledSignals; ++i) {
-    if (sigaction(kExceptionSignals[i], NULL, &old_handlers[i]) == -1)
-      return false;
-  }
-
-  struct sigaction sa;
-  memset(&sa, 0, sizeof(sa));
-  sigemptyset(&sa.sa_mask);
-
-  // Mask all exception signals when we're handling one of them.
-  for (int i = 0; i < kNumHandledSignals; ++i)
-    sigaddset(&sa.sa_mask, kExceptionSignals[i]);
-
-  sa.sa_sigaction = SignalHandler;
-  sa.sa_flags = SA_ONSTACK | SA_SIGINFO;
-
-  for (int i = 0; i < kNumHandledSignals; ++i) {
-    if (sigaction(kExceptionSignals[i], &sa, NULL) == -1) {
-      // At this point it is impractical to back out changes, and so failure to
-      // install a signal is intentionally ignored.
-    }
-  }
-  handlers_installed = true;
-  return true;
-}
-
-// This function runs in a compromised context: see the top of the file.
-// Runs on the crashing thread.
-// static
-void ExceptionHandler::RestoreHandlersLocked() {
-  if (!handlers_installed)
-    return;
-
-  for (int i = 0; i < kNumHandledSignals; ++i) {
-    if (sigaction(kExceptionSignals[i], &old_handlers[i], NULL) == -1) {
-      InstallDefaultHandler(kExceptionSignals[i]);
-    }
-  }
-  handlers_installed = false;
-}
-
-// void ExceptionHandler::set_crash_handler(HandlerCallback callback) {
-//   crash_handler_ = callback;
-// }
-
-// This function runs in a compromised context: see the top of the file.
-// Runs on the crashing thread.
-// static
-void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
-  // All the exception signals are blocked at this point.
-  pthread_mutex_lock(&g_handler_stack_mutex_);
-
-  // Sometimes, Breakpad runs inside a process where some other buggy code
-  // saves and restores signal handlers temporarily with 'signal'
-  // instead of 'sigaction'. This loses the SA_SIGINFO flag associated
-  // with this function. As a consequence, the values of 'info' and 'uc'
-  // become totally bogus, generally inducing a crash.
-  //
-  // The following code tries to detect this case. When it does, it
-  // resets the signal handlers with sigaction + SA_SIGINFO and returns.
-  // This forces the signal to be thrown again, but this time the kernel
-  // will call the function with the right arguments.
-  struct sigaction cur_handler;
-  if (sigaction(sig, NULL, &cur_handler) == 0 &&
-      (cur_handler.sa_flags & SA_SIGINFO) == 0) {
-    // Reset signal handler with the right flags.
-    sigemptyset(&cur_handler.sa_mask);
-    sigaddset(&cur_handler.sa_mask, sig);
-
-    cur_handler.sa_sigaction = SignalHandler;
-    cur_handler.sa_flags = SA_ONSTACK | SA_SIGINFO;
-
-    if (sigaction(sig, &cur_handler, NULL) == -1) {
-      // When resetting the handler fails, try to reset the
-      // default one to avoid an infinite loop here.
-      InstallDefaultHandler(sig);
-    }
-    pthread_mutex_unlock(&g_handler_stack_mutex_);
-    return;
-  }
-
-  bool handled = false;
-  for (int i = g_handler_stack_->size() - 1; !handled && i >= 0; --i) {
-    handled = (*g_handler_stack_)[i]->HandleSignal(sig, info, uc);
-  }
-
-  // Upon returning from this signal handler, sig will become unmasked and then
-  // it will be retriggered. If one of the ExceptionHandlers handled it
-  // successfully, restore the default handler. Otherwise, restore the
-  // previously installed handler. Then, when the signal is retriggered, it will
-  // be delivered to the appropriate handler.
-  if (handled) {
-    InstallDefaultHandler(sig);
-  } else {
-    RestoreHandlersLocked();
-  }
-
-  pthread_mutex_unlock(&g_handler_stack_mutex_);
-
-  // info->si_code <= 0 iff SI_FROMUSER (SI_FROMKERNEL otherwise).
-  if (info->si_code <= 0 || sig == SIGABRT) {
-    // This signal was triggered by somebody sending us the signal with kill().
-    // In order to retrigger it, we have to queue a new signal by calling
-    // kill() ourselves.  The special case (si_pid == 0 && sig == SIGABRT) is
-    // due to the kernel sending a SIGABRT from a user request via SysRQ.
-    if (tgkill(getpid(), syscall(__NR_gettid), sig) < 0) {
-      // If we failed to kill ourselves (e.g. because a sandbox disallows us
-      // to do so), we instead resort to terminating our process. This will
-      // result in an incorrect exit code.
-      _exit(1);
-    }
-  } else {
-    // This was a synchronous signal triggered by a hard fault (e.g. SIGSEGV).
-    // No need to reissue the signal. It will automatically trigger again,
-    // when we return from the signal handler.
-  }
-}
-
-struct ThreadArgument {
-  pid_t pid;  // the crashing process
-  const MinidumpDescriptor* minidump_descriptor;
-  ExceptionHandler* handler;
-  const void* context;  // a CrashContext structure
-  size_t context_size;
-};
-
-// This is the entry function for the cloned process. We are in a compromised
-// context here: see the top of the file.
-// static
-int ExceptionHandler::ThreadEntry(void *arg) {
-  const ThreadArgument *thread_arg = reinterpret_cast<ThreadArgument*>(arg);
-
-  // Block here until the crashing process unblocks us when
-  // we're allowed to use ptrace
-  thread_arg->handler->WaitForContinueSignal();
-
-  return thread_arg->handler->DoDump(thread_arg->pid, thread_arg->context,
-                                     thread_arg->context_size) == false;
-}
-
-// This function runs in a compromised context: see the top of the file.
-// Runs on the crashing thread.
-bool ExceptionHandler::HandleSignal(int sig, siginfo_t* info, void* uc) {
-  if (filter_ && !filter_(callback_context_))
-    return false;
-
-  // Allow ourselves to be dumped if the signal is trusted.
-  bool signal_trusted = info->si_code > 0;
-  bool signal_pid_trusted = info->si_code == SI_USER ||
-      info->si_code == SI_TKILL;
-  if (signal_trusted || (signal_pid_trusted && info->si_pid == getpid())) {
-    sys_prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
-  }
-  CrashContext context;
-  // Fill in all the holes in the struct to make Valgrind happy.
-  memset(&context, 0, sizeof(context));
-  memcpy(&context.siginfo, info, sizeof(siginfo_t));
-  memcpy(&context.context, uc, sizeof(struct ucontext));
-#if defined(__aarch64__)
-  struct ucontext *uc_ptr = (struct ucontext*)uc;
-  struct fpsimd_context *fp_ptr =
-      (struct fpsimd_context*)&uc_ptr->uc_mcontext.__reserved;
-  if (fp_ptr->head.magic == FPSIMD_MAGIC) {
-    memcpy(&context.float_state, fp_ptr, sizeof(context.float_state));
-  }
-#elif !defined(__ARM_EABI__)  && !defined(__mips__)
-  // FP state is not part of user ABI on ARM Linux.
-  // In case of MIPS Linux FP state is already part of struct ucontext
-  // and 'float_state' is not a member of CrashContext.
-  struct ucontext *uc_ptr = (struct ucontext*)uc;
-  if (uc_ptr->uc_mcontext.fpregs) {
-    memcpy(&context.float_state,
-           uc_ptr->uc_mcontext.fpregs,
-           sizeof(context.float_state));
-  }
-#endif
-  context.tid = syscall(__NR_gettid);
-  if (crash_handler_ != NULL) {
-    if (crash_handler_(&context, sizeof(context), callback_context_)) {
-      return true;
-    }
-  }
-  return GenerateDump(&context);
-}
-
-// This is a public interface to HandleSignal that allows the client to
-// generate a crash dump. This function may run in a compromised context.
-bool ExceptionHandler::SimulateSignalDelivery(int sig) {
-  siginfo_t siginfo = {};
-  // Mimic a trusted signal to allow tracing the process (see
-  // ExceptionHandler::HandleSignal().
-  siginfo.si_code = SI_USER;
-  siginfo.si_pid = getpid();
-  struct ucontext context;
-  getcontext(&context);
-  return HandleSignal(sig, &siginfo, &context);
-}
-
-// This function may run in a compromised context: see the top of the file.
-bool ExceptionHandler::GenerateDump(CrashContext *context) {
-  if (IsOutOfProcess())
-    return crash_generation_client_->RequestDump(context, sizeof(*context));
-
-  // Allocating too much stack isn't a problem, and better to err on the side
-  // of caution than smash it into random locations.
-  static const unsigned kChildStackSize = 16000;
-  PageAllocator allocator;
-  uint8_t* stack = reinterpret_cast<uint8_t*>(allocator.Alloc(kChildStackSize));
-  if (!stack)
-    return false;
-  // clone() needs the top-most address. (scrub just to be safe)
-  stack += kChildStackSize;
-  my_memset(stack - 16, 0, 16);
-
-  ThreadArgument thread_arg;
-  thread_arg.handler = this;
-  thread_arg.minidump_descriptor = &minidump_descriptor_;
-  thread_arg.pid = getpid();
-  thread_arg.context = context;
-  thread_arg.context_size = sizeof(*context);
-
-  // We need to explicitly enable ptrace of parent processes on some
-  // kernels, but we need to know the PID of the cloned process before we
-  // can do this. Create a pipe here which we can use to block the
-  // cloned process after creating it, until we have explicitly enabled ptrace
-  if (sys_pipe(fdes) == -1) {
-    // Creating the pipe failed. We'll log an error but carry on anyway,
-    // as we'll probably still get a useful crash report. All that will happen
-    // is the write() and read() calls will fail with EBADF
-    static const char no_pipe_msg[] = "ExceptionHandler::GenerateDump "
-                                      "sys_pipe failed:";
-    logger::write(no_pipe_msg, sizeof(no_pipe_msg) - 1);
-    logger::write(strerror(errno), strlen(strerror(errno)));
-    logger::write("\n", 1);
-
-    // Ensure fdes[0] and fdes[1] are invalid file descriptors.
-    fdes[0] = fdes[1] = -1;
-  }
-
-  const pid_t child = sys_clone(
-      ThreadEntry, stack, CLONE_FILES | CLONE_FS | CLONE_UNTRACED,
-      &thread_arg, NULL, NULL, NULL);
-  if (child == -1) {
-    sys_close(fdes[0]);
-    sys_close(fdes[1]);
-    return false;
-  }
-
-  // Allow the child to ptrace us
-  sys_prctl(PR_SET_PTRACER, child, 0, 0, 0);
-  SendContinueSignalToChild();
-  int status;
-  const int r = HANDLE_EINTR(sys_waitpid(child, &status, __WALL));
-
-  sys_close(fdes[0]);
-  sys_close(fdes[1]);
-
-  if (r == -1) {
-    static const char msg[] = "ExceptionHandler::GenerateDump waitpid failed:";
-    logger::write(msg, sizeof(msg) - 1);
-    logger::write(strerror(errno), strlen(strerror(errno)));
-    logger::write("\n", 1);
-  }
-
-  bool success = r != -1 && WIFEXITED(status) && WEXITSTATUS(status) == 0;
-  if (callback_)
-    success = callback_(minidump_descriptor_, callback_context_, success);
-  return success;
-}
-
-// This function runs in a compromised context: see the top of the file.
-void ExceptionHandler::SendContinueSignalToChild() {
-  static const char okToContinueMessage = 'a';
-  int r;
-  r = HANDLE_EINTR(sys_write(fdes[1], &okToContinueMessage, sizeof(char)));
-  if (r == -1) {
-    static const char msg[] = "ExceptionHandler::SendContinueSignalToChild "
-                              "sys_write failed:";
-    logger::write(msg, sizeof(msg) - 1);
-    logger::write(strerror(errno), strlen(strerror(errno)));
-    logger::write("\n", 1);
-  }
-}
-
-// This function runs in a compromised context: see the top of the file.
-// Runs on the cloned process.
-void ExceptionHandler::WaitForContinueSignal() {
-  int r;
-  char receivedMessage;
-  r = HANDLE_EINTR(sys_read(fdes[0], &receivedMessage, sizeof(char)));
-  if (r == -1) {
-    static const char msg[] = "ExceptionHandler::WaitForContinueSignal "
-                              "sys_read failed:";
-    logger::write(msg, sizeof(msg) - 1);
-    logger::write(strerror(errno), strlen(strerror(errno)));
-    logger::write("\n", 1);
-  }
-}
-
-// This function runs in a compromised context: see the top of the file.
-// Runs on the cloned process.
-bool ExceptionHandler::DoDump(pid_t crashing_process, const void* context,
-                              size_t context_size) {
-  if (minidump_descriptor_.IsMicrodumpOnConsole()) {
-    return google_breakpad::WriteMicrodump(
-        crashing_process,
-        context,
-        context_size,
-        mapping_list_,
-        minidump_descriptor_.microdump_build_fingerprint(),
-        minidump_descriptor_.microdump_product_info());
-  }
-  if (minidump_descriptor_.IsFD()) {
-    return google_breakpad::WriteMinidump(minidump_descriptor_.fd(),
-                                          minidump_descriptor_.size_limit(),
-                                          crashing_process,
-                                          context,
-                                          context_size,
-                                          mapping_list_,
-                                          app_memory_list_);
-  }
-  return google_breakpad::WriteMinidump(minidump_descriptor_.path(),
-                                        minidump_descriptor_.size_limit(),
-                                        crashing_process,
-                                        context,
-                                        context_size,
-                                        mapping_list_,
-                                        app_memory_list_);
-}
-
-// static
-bool ExceptionHandler::WriteMinidump(const string& dump_path,
-                                     MinidumpCallback callback,
-                                     void* callback_context) {
-  MinidumpDescriptor descriptor(dump_path);
-  ExceptionHandler eh(descriptor, NULL, callback, callback_context, false, -1);
-  return eh.WriteMinidump();
-}
-
-// In order to making using EBP to calculate the desired value for ESP
-// a valid operation, ensure that this function is compiled with a
-// frame pointer using the following attribute. This attribute
-// is supported on GCC but not on clang.
-#if defined(__i386__) && defined(__GNUC__) && !defined(__clang__)
-__attribute__((optimize("no-omit-frame-pointer")))
-#endif
-bool ExceptionHandler::WriteMinidump() {
-  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD() &&
-      !minidump_descriptor_.IsMicrodumpOnConsole()) {
-    // Update the path of the minidump so that this can be called multiple times
-    // and new files are created for each minidump.  This is done before the
-    // generation happens, as clients may want to access the MinidumpDescriptor
-    // after this call to find the exact path to the minidump file.
-    minidump_descriptor_.UpdatePath();
-  } else if (minidump_descriptor_.IsFD()) {
-    // Reposition the FD to its beginning and resize it to get rid of the
-    // previous minidump info.
-    lseek(minidump_descriptor_.fd(), 0, SEEK_SET);
-    ignore_result(ftruncate(minidump_descriptor_.fd(), 0));
-  }
-
-  // Allow this process to be dumped.
-  sys_prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
-
-  CrashContext context;
-  int getcontext_result = getcontext(&context.context);
-  if (getcontext_result)
-    return false;
-
-#if defined(__i386__)
-  // In CPUFillFromUContext in minidumpwriter.cc the stack pointer is retrieved
-  // from REG_UESP instead of from REG_ESP. REG_UESP is the user stack pointer
-  // and it only makes sense when running in kernel mode with a different stack
-  // pointer. When WriteMiniDump is called during normal processing REG_UESP is
-  // zero which leads to bad minidump files.
-  if (!context.context.uc_mcontext.gregs[REG_UESP]) {
-    // If REG_UESP is set to REG_ESP then that includes the stack space for the
-    // CrashContext object in this function, which is about 128 KB. Since the
-    // Linux dumper only records 32 KB of stack this would mean that nothing
-    // useful would be recorded. A better option is to set REG_UESP to REG_EBP,
-    // perhaps with a small negative offset in case there is any code that
-    // objects to them being equal.
-    context.context.uc_mcontext.gregs[REG_UESP] =
-      context.context.uc_mcontext.gregs[REG_EBP] - 16;
-    // The stack saving is based off of REG_ESP so it must be set to match the
-    // new REG_UESP.
-    context.context.uc_mcontext.gregs[REG_ESP] =
-      context.context.uc_mcontext.gregs[REG_UESP];
-  }
-#endif
-
-#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
-  // FPU state is not part of ARM EABI ucontext_t.
-  memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
-         sizeof(context.float_state));
-#endif
-  context.tid = sys_gettid();
-
-  // Add an exception stream to the minidump for better reporting.
-  memset(&context.siginfo, 0, sizeof(context.siginfo));
-  context.siginfo.si_signo = MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED;
-#if defined(__i386__)
-  context.siginfo.si_addr =
-      reinterpret_cast<void*>(context.context.uc_mcontext.gregs[REG_EIP]);
-#elif defined(__x86_64__)
-  context.siginfo.si_addr =
-      reinterpret_cast<void*>(context.context.uc_mcontext.gregs[REG_RIP]);
-#elif defined(__arm__)
-  context.siginfo.si_addr =
-      reinterpret_cast<void*>(context.context.uc_mcontext.arm_pc);
-#elif defined(__aarch64__)
-  context.siginfo.si_addr =
-      reinterpret_cast<void*>(context.context.uc_mcontext.pc);
-#elif defined(__mips__)
-  context.siginfo.si_addr =
-      reinterpret_cast<void*>(context.context.uc_mcontext.pc);
-#else
-#error "This code has not been ported to your platform yet."
-#endif
-
-  return GenerateDump(&context);
-}
-
-void ExceptionHandler::AddMappingInfo(const string& name,
-                                      const uint8_t identifier[sizeof(MDGUID)],
-                                      uintptr_t start_address,
-                                      size_t mapping_size,
-                                      size_t file_offset) {
-  MappingInfo info;
-  info.start_addr = start_address;
-  info.size = mapping_size;
-  info.offset = file_offset;
-  strncpy(info.name, name.c_str(), sizeof(info.name) - 1);
-  info.name[sizeof(info.name) - 1] = '\0';
-
-  MappingEntry mapping;
-  mapping.first = info;
-  memcpy(mapping.second, identifier, sizeof(MDGUID));
-  mapping_list_.push_back(mapping);
-}
-
-void ExceptionHandler::RegisterAppMemory(void* ptr, size_t length) {
-  AppMemoryList::iterator iter =
-    std::find(app_memory_list_.begin(), app_memory_list_.end(), ptr);
-  if (iter != app_memory_list_.end()) {
-    // Don't allow registering the same pointer twice.
-    return;
-  }
-
-  AppMemory app_memory;
-  app_memory.ptr = ptr;
-  app_memory.length = length;
-  app_memory_list_.push_back(app_memory);
-}
-
-void ExceptionHandler::UnregisterAppMemory(void* ptr) {
-  AppMemoryList::iterator iter =
-    std::find(app_memory_list_.begin(), app_memory_list_.end(), ptr);
-  if (iter != app_memory_list_.end()) {
-    app_memory_list_.erase(iter);
-  }
-}
-
-// static
-bool ExceptionHandler::WriteMinidumpForChild(pid_t child,
-                                             pid_t child_blamed_thread,
-                                             const string& dump_path,
-                                             MinidumpCallback callback,
-                                             void* callback_context) {
-  // This function is not run in a compromised context.
-  MinidumpDescriptor descriptor(dump_path);
-  descriptor.UpdatePath();
-  if (!google_breakpad::WriteMinidump(descriptor.path(),
-                                      child,
-                                      child_blamed_thread))
-      return false;
-
-  return callback ? callback(descriptor, callback_context, true) : true;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.h b/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.h
deleted file mode 100644
index 591c31085..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/handler/exception_handler.h
+++ /dev/null
@@ -1,278 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
-#define CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
-
-#include <signal.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <sys/ucontext.h>
-
-#include <string>
-
-#include "client/linux/crash_generation/crash_generation_client.h"
-#include "client/linux/handler/minidump_descriptor.h"
-#include "client/linux/minidump_writer/minidump_writer.h"
-#include "common/scoped_ptr.h"
-#include "common/using_std_string.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-// ExceptionHandler
-//
-// ExceptionHandler can write a minidump file when an exception occurs,
-// or when WriteMinidump() is called explicitly by your program.
-//
-// To have the exception handler write minidumps when an uncaught exception
-// (crash) occurs, you should create an instance early in the execution
-// of your program, and keep it around for the entire time you want to
-// have crash handling active (typically, until shutdown).
-// (NOTE): There should be only be one this kind of exception handler
-// object per process.
-//
-// If you want to write minidumps without installing the exception handler,
-// you can create an ExceptionHandler with install_handler set to false,
-// then call WriteMinidump.  You can also use this technique if you want to
-// use different minidump callbacks for different call sites.
-//
-// In either case, a callback function is called when a minidump is written,
-// which receives the full path or file descriptor of the minidump.  The
-// caller can collect and write additional application state to that minidump,
-// and launch an external crash-reporting application.
-//
-// Caller should try to make the callbacks as crash-friendly as possible,
-// it should avoid use heap memory allocation as much as possible.
-
-class ExceptionHandler {
- public:
-  // A callback function to run before Breakpad performs any substantial
-  // processing of an exception.  A FilterCallback is called before writing
-  // a minidump.  |context| is the parameter supplied by the user as
-  // callback_context when the handler was created.
-  //
-  // If a FilterCallback returns true, Breakpad will continue processing,
-  // attempting to write a minidump.  If a FilterCallback returns false,
-  // Breakpad  will immediately report the exception as unhandled without
-  // writing a minidump, allowing another handler the opportunity to handle it.
-  typedef bool (*FilterCallback)(void *context);
-
-  // A callback function to run after the minidump has been written.
-  // |descriptor| contains the file descriptor or file path containing the
-  // minidump. |context| is the parameter supplied by the user as
-  // callback_context when the handler was created.  |succeeded| indicates
-  // whether a minidump file was successfully written.
-  //
-  // If an exception occurred and the callback returns true, Breakpad will
-  // treat the exception as fully-handled, suppressing any other handlers from
-  // being notified of the exception.  If the callback returns false, Breakpad
-  // will treat the exception as unhandled, and allow another handler to handle
-  // it. If there are no other handlers, Breakpad will report the exception to
-  // the system as unhandled, allowing a debugger or native crash dialog the
-  // opportunity to handle the exception.  Most callback implementations
-  // should normally return the value of |succeeded|, or when they wish to
-  // not report an exception of handled, false.  Callbacks will rarely want to
-  // return true directly (unless |succeeded| is true).
-  typedef bool (*MinidumpCallback)(const MinidumpDescriptor& descriptor,
-                                   void* context,
-                                   bool succeeded);
-
-  // In certain cases, a user may wish to handle the generation of the minidump
-  // themselves. In this case, they can install a handler callback which is
-  // called when a crash has occurred. If this function returns true, no other
-  // processing of occurs and the process will shortly be crashed. If this
-  // returns false, the normal processing continues.
-  typedef bool (*HandlerCallback)(const void* crash_context,
-                                  size_t crash_context_size,
-                                  void* context);
-
-  // Creates a new ExceptionHandler instance to handle writing minidumps.
-  // Before writing a minidump, the optional |filter| callback will be called.
-  // Its return value determines whether or not Breakpad should write a
-  // minidump.  The minidump content will be written to the file path or file
-  // descriptor from |descriptor|, and the optional |callback| is called after
-  // writing the dump file, as described above.
-  // If install_handler is true, then a minidump will be written whenever
-  // an unhandled exception occurs.  If it is false, minidumps will only
-  // be written when WriteMinidump is called.
-  // If |server_fd| is valid, the minidump is generated out-of-process.  If it
-  // is -1, in-process generation will always be used.
-  ExceptionHandler(const MinidumpDescriptor& descriptor,
-                   FilterCallback filter,
-                   MinidumpCallback callback,
-                   void* callback_context,
-                   bool install_handler,
-                   const int server_fd);
-  ~ExceptionHandler();
-
-  const MinidumpDescriptor& minidump_descriptor() const {
-    return minidump_descriptor_;
-  }
-
-  void set_minidump_descriptor(const MinidumpDescriptor& descriptor) {
-    minidump_descriptor_ = descriptor;
-  }
-
-  void set_crash_handler(HandlerCallback callback) {
-    crash_handler_ = callback;
-  }
-
-  void set_crash_generation_client(CrashGenerationClient* client) {
-    crash_generation_client_.reset(client);
-  }
-
-  // Writes a minidump immediately.  This can be used to capture the execution
-  // state independently of a crash.
-  // Returns true on success.
-  // If the ExceptionHandler has been created with a path, a new file is
-  // generated for each minidump.  The file path can be retrieved in the
-  // MinidumpDescriptor passed to the MinidumpCallback or by accessing the
-  // MinidumpDescriptor directly from the ExceptionHandler (with
-  // minidump_descriptor()).
-  // If the ExceptionHandler has been created with a file descriptor, the file
-  // descriptor is repositioned to its beginning and the previous generated
-  // minidump is overwritten.
-  // Note that this method is not supposed to be called from a compromised
-  // context as it uses the heap.
-  bool WriteMinidump();
-
-  // Convenience form of WriteMinidump which does not require an
-  // ExceptionHandler instance.
-  static bool WriteMinidump(const string& dump_path,
-                            MinidumpCallback callback,
-                            void* callback_context);
-
-  // Write a minidump of |child| immediately.  This can be used to
-  // capture the execution state of |child| independently of a crash.
-  // Pass a meaningful |child_blamed_thread| to make that thread in
-  // the child process the one from which a crash signature is
-  // extracted.
-  //
-  // WARNING: the return of this function *must* happen before
-  // the code that will eventually reap |child| executes.
-  // Otherwise there's a pernicious race condition in which |child|
-  // exits, is reaped, another process created with its pid, then that
-  // new process dumped.
-  static bool WriteMinidumpForChild(pid_t child,
-                                    pid_t child_blamed_thread,
-                                    const string& dump_path,
-                                    MinidumpCallback callback,
-                                    void* callback_context);
-
-  // This structure is passed to minidump_writer.h:WriteMinidump via an opaque
-  // blob. It shouldn't be needed in any user code.
-  struct CrashContext {
-    siginfo_t siginfo;
-    pid_t tid;  // the crashing thread.
-    struct ucontext context;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-    // #ifdef this out because FP state is not part of user ABI for Linux ARM.
-    // In case of MIPS Linux FP state is already part of struct
-    // ucontext so 'float_state' is not required.
-    fpstate_t float_state;
-#endif
-  };
-
-  // Returns whether out-of-process dump generation is used or not.
-  bool IsOutOfProcess() const {
-    return crash_generation_client_.get() != NULL;
-  }
-
-  // Add information about a memory mapping. This can be used if
-  // a custom library loader is used that maps things in a way
-  // that the linux dumper can't handle by reading the maps file.
-  void AddMappingInfo(const string& name,
-                      const uint8_t identifier[sizeof(MDGUID)],
-                      uintptr_t start_address,
-                      size_t mapping_size,
-                      size_t file_offset);
-
-  // Register a block of memory of length bytes starting at address ptr
-  // to be copied to the minidump when a crash happens.
-  void RegisterAppMemory(void* ptr, size_t length);
-
-  // Unregister a block of memory that was registered with RegisterAppMemory.
-  void UnregisterAppMemory(void* ptr);
-
-  // Force signal handling for the specified signal.
-  bool SimulateSignalDelivery(int sig);
-
-  // Report a crash signal from an SA_SIGINFO signal handler.
-  bool HandleSignal(int sig, siginfo_t* info, void* uc);
-
- private:
-  // Save the old signal handlers and install new ones.
-  static bool InstallHandlersLocked();
-  // Restore the old signal handlers.
-  static void RestoreHandlersLocked();
-
-  void PreresolveSymbols();
-  bool GenerateDump(CrashContext *context);
-  void SendContinueSignalToChild();
-  void WaitForContinueSignal();
-
-  static void SignalHandler(int sig, siginfo_t* info, void* uc);
-  static int ThreadEntry(void* arg);
-  bool DoDump(pid_t crashing_process, const void* context,
-              size_t context_size);
-
-  const FilterCallback filter_;
-  const MinidumpCallback callback_;
-  void* const callback_context_;
-
-  scoped_ptr<CrashGenerationClient> crash_generation_client_;
-
-  MinidumpDescriptor minidump_descriptor_;
-
-  // Must be volatile. The compiler is unaware of the code which runs in
-  // the signal handler which reads this variable. Without volatile the
-  // compiler is free to optimise away writes to this variable which it
-  // believes are never read.
-  volatile HandlerCallback crash_handler_;
-
-  // We need to explicitly enable ptrace of parent processes on some
-  // kernels, but we need to know the PID of the cloned process before we
-  // can do this. We create a pipe which we can use to block the
-  // cloned process after creating it, until we have explicitly enabled
-  // ptrace. This is used to store the file descriptors for the pipe
-  int fdes[2];
-
-  // Callers can add extra info about mappings for cases where the
-  // dumper code cannot extract enough information from /proc/<pid>/maps.
-  MappingList mapping_list_;
-
-  // Callers can request additional memory regions to be included in
-  // the dump.
-  AppMemoryList app_memory_list_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.cc b/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.cc
deleted file mode 100644
index c601d35f0..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.cc
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2012 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include <stdio.h>
-
-#include "client/linux/handler/minidump_descriptor.h"
-
-#include "common/linux/guid_creator.h"
-
-namespace google_breakpad {
-
-//static
-const MinidumpDescriptor::MicrodumpOnConsole
-    MinidumpDescriptor::kMicrodumpOnConsole = {};
-
-MinidumpDescriptor::MinidumpDescriptor(const MinidumpDescriptor& descriptor)
-    : mode_(descriptor.mode_),
-      fd_(descriptor.fd_),
-      directory_(descriptor.directory_),
-      c_path_(NULL),
-      size_limit_(descriptor.size_limit_),
-      microdump_build_fingerprint_(descriptor.microdump_build_fingerprint_),
-      microdump_product_info_(descriptor.microdump_product_info_) {
-  // The copy constructor is not allowed to be called on a MinidumpDescriptor
-  // with a valid path_, as getting its c_path_ would require the heap which
-  // can cause problems in compromised environments.
-  assert(descriptor.path_.empty());
-}
-
-MinidumpDescriptor& MinidumpDescriptor::operator=(
-    const MinidumpDescriptor& descriptor) {
-  assert(descriptor.path_.empty());
-
-  mode_ = descriptor.mode_;
-  fd_ = descriptor.fd_;
-  directory_ = descriptor.directory_;
-  path_.clear();
-  if (c_path_) {
-    // This descriptor already had a path set, so generate a new one.
-    c_path_ = NULL;
-    UpdatePath();
-  }
-  size_limit_ = descriptor.size_limit_;
-  microdump_build_fingerprint_ = descriptor.microdump_build_fingerprint_;
-  microdump_product_info_ = descriptor.microdump_product_info_;
-  return *this;
-}
-
-void MinidumpDescriptor::UpdatePath() {
-  assert(mode_ == kWriteMinidumpToFile && !directory_.empty());
-
-  GUID guid;
-  char guid_str[kGUIDStringLength + 1];
-  if (!CreateGUID(&guid) || !GUIDToString(&guid, guid_str, sizeof(guid_str))) {
-    assert(false);
-  }
-
-  path_.clear();
-  path_ = directory_ + "/" + guid_str + ".dmp";
-  c_path_ = path_.c_str();
-}
-
-void MinidumpDescriptor::SetMicrodumpBuildFingerprint(
-    const char* build_fingerprint) {
-  assert(mode_ == kWriteMicrodumpToConsole);
-  microdump_build_fingerprint_ = build_fingerprint;
-}
-
-void MinidumpDescriptor::SetMicrodumpProductInfo(const char* product_info) {
-  assert(mode_ == kWriteMicrodumpToConsole);
-  microdump_product_info_ = product_info;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.h b/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.h
deleted file mode 100644
index 3584c6922..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/handler/minidump_descriptor.h
+++ /dev/null
@@ -1,161 +0,0 @@
-// Copyright (c) 2012 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_HANDLER_MINIDUMP_DESCRIPTOR_H_
-#define CLIENT_LINUX_HANDLER_MINIDUMP_DESCRIPTOR_H_
-
-#include <assert.h>
-#include <sys/types.h>
-
-#include <string>
-
-#include "common/using_std_string.h"
-
-// This class describes how a crash dump should be generated, either:
-// - Writing a full minidump to a file in a given directory (the actual path,
-//   inside the directory, is determined by this class).
-// - Writing a full minidump to a given fd.
-// - Writing a reduced microdump to the console (logcat on Android).
-namespace google_breakpad {
-
-class MinidumpDescriptor {
- public:
-  struct MicrodumpOnConsole {};
-  static const MicrodumpOnConsole kMicrodumpOnConsole;
-
-  MinidumpDescriptor() : mode_(kUninitialized),
-                         fd_(-1),
-                         size_limit_(-1),
-                         microdump_build_fingerprint_(NULL),
-                         microdump_product_info_(NULL) {}
-
-  explicit MinidumpDescriptor(const string& directory)
-      : mode_(kWriteMinidumpToFile),
-        fd_(-1),
-        directory_(directory),
-        c_path_(NULL),
-        size_limit_(-1),
-        microdump_build_fingerprint_(NULL),
-        microdump_product_info_(NULL) {
-    assert(!directory.empty());
-  }
-
-  explicit MinidumpDescriptor(int fd)
-      : mode_(kWriteMinidumpToFd),
-        fd_(fd),
-        c_path_(NULL),
-        size_limit_(-1),
-        microdump_build_fingerprint_(NULL),
-        microdump_product_info_(NULL) {
-    assert(fd != -1);
-  }
-
-  explicit MinidumpDescriptor(const MicrodumpOnConsole&)
-      : mode_(kWriteMicrodumpToConsole),
-        fd_(-1),
-        size_limit_(-1),
-        microdump_build_fingerprint_(NULL),
-        microdump_product_info_(NULL) {}
-
-  explicit MinidumpDescriptor(const MinidumpDescriptor& descriptor);
-  MinidumpDescriptor& operator=(const MinidumpDescriptor& descriptor);
-
-  static MinidumpDescriptor getMicrodumpDescriptor();
-
-  bool IsFD() const { return mode_ == kWriteMinidumpToFd; }
-
-  int fd() const { return fd_; }
-
-  string directory() const { return directory_; }
-
-  const char* path() const { return c_path_; }
-
-  bool IsMicrodumpOnConsole() const {
-    return mode_ == kWriteMicrodumpToConsole;
-  }
-
-  // Updates the path so it is unique.
-  // Should be called from a normal context: this methods uses the heap.
-  void UpdatePath();
-
-  off_t size_limit() const { return size_limit_; }
-  void set_size_limit(off_t limit) { size_limit_ = limit; }
-
-  // TODO(primiano): make this and product info (below) just part of the
-  // microdump ctor once it is rolled stably into Chrome. ETA: June 2015.
-  void SetMicrodumpBuildFingerprint(const char* build_fingerprint);
-  const char* microdump_build_fingerprint() const {
-    return microdump_build_fingerprint_;
-  }
-
-  void SetMicrodumpProductInfo(const char* product_info);
-  const char* microdump_product_info() const {
-    return microdump_product_info_;
-  }
-
- private:
-  enum DumpMode {
-    kUninitialized = 0,
-    kWriteMinidumpToFile,
-    kWriteMinidumpToFd,
-    kWriteMicrodumpToConsole
-  };
-
-  // Specifies the dump mode (see DumpMode).
-  DumpMode mode_;
-
-  // The file descriptor where the minidump is generated.
-  int fd_;
-
-  // The directory where the minidump should be generated.
-  string directory_;
-
-  // The full path to the generated minidump.
-  string path_;
-
-  // The C string of |path_|. Precomputed so it can be access from a compromised
-  // context.
-  const char* c_path_;
-
-  off_t size_limit_;
-
-  // The product name/version and build fingerprint that should be appended to
-  // the dump (microdump only). Microdumps don't have the ability of appending
-  // extra metadata after the dump is generated (as opposite to minidumps
-  // MIME fields), therefore the product details must be provided upfront.
-  // The string pointers are supposed to be valid through all the lifetime of
-  // the process (read: the caller has to guarantee that they are stored in
-  // global static storage).
-  const char* microdump_build_fingerprint_;
-  const char* microdump_product_info_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_HANDLER_MINIDUMP_DESCRIPTOR_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/log/log.cc b/TMessagesProj/jni/breakpad/client/linux/log/log.cc
deleted file mode 100644
index fc23aa6d5..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/log/log.cc
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright (c) 2012 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "client/linux/log/log.h"
-
-#if defined(__ANDROID__)
-#include <android/log.h>
-#include <dlfcn.h>
-#else
-#include "third_party/lss/linux_syscall_support.h"
-#endif
-
-namespace logger {
-
-#if defined(__ANDROID__)
-namespace {
-
-// __android_log_buf_write() is not exported in the NDK and is being used by
-// dynamic runtime linking. Its declaration is taken from Android's
-// system/core/include/log/log.h.
-using AndroidLogBufferWriteFunc = int (*)(int bufID, int prio, const char *tag,
-                                          const char *text);
-const int kAndroidCrashLogId = 4;  // From LOG_ID_CRASH in log.h.
-const char kAndroidLogTag[] = "google-breakpad";
-
-bool g_crash_log_initialized = false;
-AndroidLogBufferWriteFunc g_android_log_buf_write = nullptr;
-
-}  // namespace
-
-void initializeCrashLogWriter() {
-  if (g_crash_log_initialized)
-    return;
-  g_android_log_buf_write = reinterpret_cast<AndroidLogBufferWriteFunc>(
-      dlsym(RTLD_DEFAULT, "__android_log_buf_write"));
-  g_crash_log_initialized = true;
-}
-
-int writeToCrashLog(const char* buf) {
-  // Try writing to the crash log ring buffer. If not available, fall back to
-  // the standard log buffer.
-  if (g_android_log_buf_write) {
-    return g_android_log_buf_write(kAndroidCrashLogId, ANDROID_LOG_FATAL,
-                                   kAndroidLogTag, buf);
-  }
-  return __android_log_write(ANDROID_LOG_FATAL, kAndroidLogTag, buf);
-}
-#endif
-
-int write(const char* buf, size_t nbytes) {
-#if defined(__ANDROID__)
-  return __android_log_write(ANDROID_LOG_WARN, kAndroidLogTag, buf);
-#else
-  return sys_write(2, buf, nbytes);
-#endif
-}
-
-}  // namespace logger
diff --git a/TMessagesProj/jni/breakpad/client/linux/log/log.h b/TMessagesProj/jni/breakpad/client/linux/log/log.h
deleted file mode 100644
index f94bbd5fb..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/log/log.h
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_LOG_LOG_H_
-#define CLIENT_LINUX_LOG_LOG_H_
-
-#include <stddef.h>
-
-namespace logger {
-
-int write(const char* buf, size_t nbytes);
-
-// In the case of Android the log can be written to the default system log
-// (default behavior of write() above, or to the crash log (see
-// writeToCrashLog() below).
-#if defined(__ANDROID__)
-
-// The logger must be initialized in a non-compromised context.
-void initializeCrashLogWriter();
-
-// Once initialized, writeToCrashLog is safe to use in a compromised context,
-// even if the initialization failed, in which case this will silently fall
-// back on write().
-int writeToCrashLog(const char* buf);
-#endif
-
-}  // namespace logger
-
-#endif  // CLIENT_LINUX_LOG_LOG_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.cc b/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.cc
deleted file mode 100644
index d2eaa6ee6..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.cc
+++ /dev/null
@@ -1,425 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// This translation unit generates microdumps into the console (logcat on
-// Android). See crbug.com/410294 for more info and design docs.
-
-#include "client/linux/microdump_writer/microdump_writer.h"
-
-#include <sys/utsname.h>
-
-#include "client/linux/dump_writer_common/thread_info.h"
-#include "client/linux/dump_writer_common/ucontext_reader.h"
-#include "client/linux/handler/exception_handler.h"
-#include "client/linux/log/log.h"
-#include "client/linux/minidump_writer/linux_ptrace_dumper.h"
-#include "common/linux/linux_libc_support.h"
-
-namespace {
-
-using google_breakpad::ExceptionHandler;
-using google_breakpad::LinuxDumper;
-using google_breakpad::LinuxPtraceDumper;
-using google_breakpad::MappingInfo;
-using google_breakpad::MappingList;
-using google_breakpad::RawContextCPU;
-using google_breakpad::ThreadInfo;
-using google_breakpad::UContextReader;
-
-const size_t kLineBufferSize = 2048;
-
-class MicrodumpWriter {
- public:
-  MicrodumpWriter(const ExceptionHandler::CrashContext* context,
-                  const MappingList& mappings,
-                  const char* build_fingerprint,
-                  const char* product_info,
-                  LinuxDumper* dumper)
-      : ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-        float_state_(context ? &context->float_state : NULL),
-#endif
-        dumper_(dumper),
-        mapping_list_(mappings),
-        build_fingerprint_(build_fingerprint),
-        product_info_(product_info),
-        log_line_(NULL) {
-    log_line_ = reinterpret_cast<char*>(Alloc(kLineBufferSize));
-    if (log_line_)
-      log_line_[0] = '\0';  // Clear out the log line buffer.
-  }
-
-  ~MicrodumpWriter() { dumper_->ThreadsResume(); }
-
-  bool Init() {
-    // In the exceptional case where the system was out of memory and there
-    // wasn't even room to allocate the line buffer, bail out. There is nothing
-    // useful we can possibly achieve without the ability to Log. At least let's
-    // try to not crash.
-    if (!dumper_->Init() || !log_line_)
-      return false;
-    return dumper_->ThreadsSuspend() && dumper_->LateInit();
-  }
-
-  bool Dump() {
-    bool success;
-    LogLine("-----BEGIN BREAKPAD MICRODUMP-----");
-    DumpProductInformation();
-    DumpOSInformation();
-    success = DumpCrashingThread();
-    if (success)
-      success = DumpMappings();
-    LogLine("-----END BREAKPAD MICRODUMP-----");
-    dumper_->ThreadsResume();
-    return success;
-  }
-
- private:
-  // Writes one line to the system log.
-  void LogLine(const char* msg) {
-#if defined(__ANDROID__)
-    logger::writeToCrashLog(msg);
-#else
-    logger::write(msg, my_strlen(msg));
-    logger::write("\n", 1);
-#endif
-  }
-
-  // Stages the given string in the current line buffer.
-  void LogAppend(const char* str) {
-    my_strlcat(log_line_, str, kLineBufferSize);
-  }
-
-  // As above (required to take precedence over template specialization below).
-  void LogAppend(char* str) {
-    LogAppend(const_cast<const char*>(str));
-  }
-
-  // Stages the hex repr. of the given int type in the current line buffer.
-  template<typename T>
-  void LogAppend(T value) {
-    // Make enough room to hex encode the largest int type + NUL.
-    static const char HEX[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-                               'A', 'B', 'C', 'D', 'E', 'F'};
-    char hexstr[sizeof(T) * 2 + 1];
-    for (int i = sizeof(T) * 2 - 1; i >= 0; --i, value >>= 4)
-      hexstr[i] = HEX[static_cast<uint8_t>(value) & 0x0F];
-    hexstr[sizeof(T) * 2] = '\0';
-    LogAppend(hexstr);
-  }
-
-  // Stages the buffer content hex-encoded in the current line buffer.
-  void LogAppend(const void* buf, size_t length) {
-    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(buf);
-    for (size_t i = 0; i < length; ++i, ++ptr)
-      LogAppend(*ptr);
-  }
-
-  // Writes out the current line buffer on the system log.
-  void LogCommitLine() {
-    LogLine(log_line_);
-    my_strlcpy(log_line_, "", kLineBufferSize);
-  }
-
-  void DumpProductInformation() {
-    LogAppend("V ");
-    if (product_info_) {
-      LogAppend(product_info_);
-    } else {
-      LogAppend("UNKNOWN:0.0.0.0");
-    }
-    LogCommitLine();
-  }
-
-  void DumpOSInformation() {
-    const uint8_t n_cpus = static_cast<uint8_t>(sysconf(_SC_NPROCESSORS_CONF));
-
-#if defined(__ANDROID__)
-    const char kOSId[] = "A";
-#else
-    const char kOSId[] = "L";
-#endif
-
-// Dump the runtime architecture. On multiarch devices it might not match the
-// hw architecture (the one returned by uname()), for instance in the case of
-// a 32-bit app running on a aarch64 device.
-#if defined(__aarch64__)
-    const char kArch[] = "arm64";
-#elif defined(__ARMEL__)
-    const char kArch[] = "arm";
-#elif defined(__x86_64__)
-    const char kArch[] = "x86_64";
-#elif defined(__i386__)
-    const char kArch[] = "x86";
-#elif defined(__mips__)
-    const char kArch[] = "mips";
-#else
-#error "This code has not been ported to your platform yet"
-#endif
-
-    LogAppend("O ");
-    LogAppend(kOSId);
-    LogAppend(" ");
-    LogAppend(kArch);
-    LogAppend(" ");
-    LogAppend(n_cpus);
-    LogAppend(" ");
-
-    // Dump the HW architecture (e.g., armv7l, aarch64).
-    struct utsname uts;
-    const bool has_uts_info = (uname(&uts) == 0);
-    const char* hwArch = has_uts_info ? uts.machine : "unknown_hw_arch";
-    LogAppend(hwArch);
-    LogAppend(" ");
-
-    // If the client has attached a build fingerprint to the MinidumpDescriptor
-    // use that one. Otherwise try to get some basic info from uname().
-    if (build_fingerprint_) {
-      LogAppend(build_fingerprint_);
-    } else if (has_uts_info) {
-      LogAppend(uts.release);
-      LogAppend(" ");
-      LogAppend(uts.version);
-    } else {
-      LogAppend("no build fingerprint available");
-    }
-    LogCommitLine();
-  }
-
-  bool DumpThreadStack(uint32_t thread_id,
-                       uintptr_t stack_pointer,
-                       int max_stack_len,
-                       uint8_t** stack_copy) {
-    *stack_copy = NULL;
-    const void* stack;
-    size_t stack_len;
-
-    if (!dumper_->GetStackInfo(&stack, &stack_len, stack_pointer)) {
-      // The stack pointer might not be available. In this case we don't hard
-      // fail, just produce a (almost useless) microdump w/o a stack section.
-      return true;
-    }
-
-    LogAppend("S 0 ");
-    LogAppend(stack_pointer);
-    LogAppend(" ");
-    LogAppend(reinterpret_cast<uintptr_t>(stack));
-    LogAppend(" ");
-    LogAppend(stack_len);
-    LogCommitLine();
-
-    if (max_stack_len >= 0 &&
-        stack_len > static_cast<unsigned int>(max_stack_len)) {
-      stack_len = max_stack_len;
-    }
-
-    *stack_copy = reinterpret_cast<uint8_t*>(Alloc(stack_len));
-    dumper_->CopyFromProcess(*stack_copy, thread_id, stack, stack_len);
-
-    // Dump the content of the stack, splicing it into chunks which size is
-    // compatible with the max logcat line size (see LOGGER_ENTRY_MAX_PAYLOAD).
-    const size_t STACK_DUMP_CHUNK_SIZE = 384;
-    for (size_t stack_off = 0; stack_off < stack_len;
-         stack_off += STACK_DUMP_CHUNK_SIZE) {
-      LogAppend("S ");
-      LogAppend(reinterpret_cast<uintptr_t>(stack) + stack_off);
-      LogAppend(" ");
-      LogAppend(*stack_copy + stack_off,
-                std::min(STACK_DUMP_CHUNK_SIZE, stack_len - stack_off));
-      LogCommitLine();
-    }
-    return true;
-  }
-
-  // Write information about the crashing thread.
-  bool DumpCrashingThread() {
-    const unsigned num_threads = dumper_->threads().size();
-
-    for (unsigned i = 0; i < num_threads; ++i) {
-      MDRawThread thread;
-      my_memset(&thread, 0, sizeof(thread));
-      thread.thread_id = dumper_->threads()[i];
-
-      // Dump only the crashing thread.
-      if (static_cast<pid_t>(thread.thread_id) != dumper_->crash_thread())
-        continue;
-
-      assert(ucontext_);
-      assert(!dumper_->IsPostMortem());
-
-      uint8_t* stack_copy;
-      const uintptr_t stack_ptr = UContextReader::GetStackPointer(ucontext_);
-      if (!DumpThreadStack(thread.thread_id, stack_ptr, -1, &stack_copy))
-        return false;
-
-      RawContextCPU cpu;
-      my_memset(&cpu, 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-      UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
-#else
-      UContextReader::FillCPUContext(&cpu, ucontext_);
-#endif
-      DumpCPUState(&cpu);
-    }
-    return true;
-  }
-
-  void DumpCPUState(RawContextCPU* cpu) {
-    LogAppend("C ");
-    LogAppend(cpu, sizeof(*cpu));
-    LogCommitLine();
-  }
-
-  // If there is caller-provided information about this mapping
-  // in the mapping_list_ list, return true. Otherwise, return false.
-  bool HaveMappingInfo(const MappingInfo& mapping) {
-    for (MappingList::const_iterator iter = mapping_list_.begin();
-         iter != mapping_list_.end();
-         ++iter) {
-      // Ignore any mappings that are wholly contained within
-      // mappings in the mapping_info_ list.
-      if (mapping.start_addr >= iter->first.start_addr &&
-          (mapping.start_addr + mapping.size) <=
-              (iter->first.start_addr + iter->first.size)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  // Dump information about the provided |mapping|. If |identifier| is non-NULL,
-  // use it instead of calculating a file ID from the mapping.
-  void DumpModule(const MappingInfo& mapping,
-                  bool member,
-                  unsigned int mapping_id,
-                  const uint8_t* identifier) {
-    MDGUID module_identifier;
-    if (identifier) {
-      // GUID was provided by caller.
-      my_memcpy(&module_identifier, identifier, sizeof(MDGUID));
-    } else {
-      dumper_->ElfFileIdentifierForMapping(
-          mapping,
-          member,
-          mapping_id,
-          reinterpret_cast<uint8_t*>(&module_identifier));
-    }
-
-    char file_name[NAME_MAX];
-    char file_path[NAME_MAX];
-    LinuxDumper::GetMappingEffectiveNameAndPath(
-        mapping, file_path, sizeof(file_path), file_name, sizeof(file_name));
-
-    LogAppend("M ");
-    LogAppend(static_cast<uintptr_t>(mapping.start_addr));
-    LogAppend(" ");
-    LogAppend(mapping.offset);
-    LogAppend(" ");
-    LogAppend(mapping.size);
-    LogAppend(" ");
-    LogAppend(module_identifier.data1);
-    LogAppend(module_identifier.data2);
-    LogAppend(module_identifier.data3);
-    LogAppend(module_identifier.data4[0]);
-    LogAppend(module_identifier.data4[1]);
-    LogAppend(module_identifier.data4[2]);
-    LogAppend(module_identifier.data4[3]);
-    LogAppend(module_identifier.data4[4]);
-    LogAppend(module_identifier.data4[5]);
-    LogAppend(module_identifier.data4[6]);
-    LogAppend(module_identifier.data4[7]);
-    LogAppend("0 ");  // Age is always 0 on Linux.
-    LogAppend(file_name);
-    LogCommitLine();
-  }
-
-  // Write information about the mappings in effect.
-  bool DumpMappings() {
-    // First write all the mappings from the dumper
-    for (unsigned i = 0; i < dumper_->mappings().size(); ++i) {
-      const MappingInfo& mapping = *dumper_->mappings()[i];
-      if (mapping.name[0] == 0 ||  // only want modules with filenames.
-          !mapping.exec ||  // only want executable mappings.
-          mapping.size < 4096 || // too small to get a signature for.
-          HaveMappingInfo(mapping)) {
-        continue;
-      }
-
-      DumpModule(mapping, true, i, NULL);
-    }
-    // Next write all the mappings provided by the caller
-    for (MappingList::const_iterator iter = mapping_list_.begin();
-         iter != mapping_list_.end();
-         ++iter) {
-      DumpModule(iter->first, false, 0, iter->second);
-    }
-    return true;
-  }
-
-  void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
-
-  const struct ucontext* const ucontext_;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-  const google_breakpad::fpstate_t* const float_state_;
-#endif
-  LinuxDumper* dumper_;
-  const MappingList& mapping_list_;
-  const char* const build_fingerprint_;
-  const char* const product_info_;
-  char* log_line_;
-};
-}  // namespace
-
-namespace google_breakpad {
-
-bool WriteMicrodump(pid_t crashing_process,
-                    const void* blob,
-                    size_t blob_size,
-                    const MappingList& mappings,
-                    const char* build_fingerprint,
-                    const char* product_info) {
-  LinuxPtraceDumper dumper(crashing_process);
-  const ExceptionHandler::CrashContext* context = NULL;
-  if (blob) {
-    if (blob_size != sizeof(ExceptionHandler::CrashContext))
-      return false;
-    context = reinterpret_cast<const ExceptionHandler::CrashContext*>(blob);
-    dumper.set_crash_address(
-        reinterpret_cast<uintptr_t>(context->siginfo.si_addr));
-    dumper.set_crash_signal(context->siginfo.si_signo);
-    dumper.set_crash_thread(context->tid);
-  }
-  MicrodumpWriter writer(context, mappings, build_fingerprint, product_info,
-                         &dumper);
-  if (!writer.Init())
-    return false;
-  return writer.Dump();
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.h b/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.h
deleted file mode 100644
index e21855836..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/microdump_writer/microdump_writer.h
+++ /dev/null
@@ -1,64 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "client/linux/dump_writer_common/mapping_info.h"
-
-namespace google_breakpad {
-
-// Writes a microdump (a reduced dump containing only the state of the crashing
-// thread) on the console (logcat on Android). These functions do not malloc nor
-// use libc functions which may. Thus, it can be used in contexts where the
-// state of the heap may be corrupt.
-// Args:
-//   crashing_process: the pid of the crashing process. This must be trusted.
-//   blob: a blob of data from the crashing process. See exception_handler.h
-//   blob_size: the length of |blob| in bytes.
-//   mappings: a list of additional mappings provided by the application.
-//   build_fingerprint: a (optional) C string which determines the OS
-//     build fingerprint (e.g., aosp/occam/mako:5.1.1/LMY47W/1234:eng/dev-keys).
-//   product_info: a (optional) C string which determines the product name and
-//     version (e.g., WebView:42.0.2311.136).
-//
-// Returns true iff successful.
-bool WriteMicrodump(pid_t crashing_process,
-                    const void* blob,
-                    size_t blob_size,
-                    const MappingList& mappings,
-                    const char* build_fingerprint,
-                    const char* product_info);
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/cpu_set.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/cpu_set.h
deleted file mode 100644
index 1cca9aa5a..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/cpu_set.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright (c) 2013, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_CPU_SET_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_CPU_SET_H_
-
-#include <stdint.h>
-#include <assert.h>
-#include <string.h>
-
-#include "common/linux/linux_libc_support.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-// Helper class used to model a set of CPUs, as read from sysfs
-// files like /sys/devices/system/cpu/present
-// See See http://www.kernel.org/doc/Documentation/cputopology.txt
-class CpuSet {
-public:
-  // The maximum number of supported CPUs.
-  static const size_t kMaxCpus = 1024;
-
-  CpuSet() {
-    my_memset(mask_, 0, sizeof(mask_));
-  }
-
-  // Parse a sysfs file to extract the corresponding CPU set.
-  bool ParseSysFile(int fd) {
-    char buffer[512];
-    int ret = sys_read(fd, buffer, sizeof(buffer)-1);
-    if (ret < 0)
-      return false;
-
-    buffer[ret] = '\0';
-
-    // Expected format: comma-separated list of items, where each
-    // item can be a decimal integer, or two decimal integers separated
-    // by a dash.
-    // E.g.:
-    //       0
-    //       0,1,2,3
-    //       0-3
-    //       1,10-23
-    const char* p = buffer;
-    const char* p_end = p + ret;
-    while (p < p_end) {
-      // Skip leading space, if any
-      while (p < p_end && my_isspace(*p))
-        p++;
-
-      // Find start and size of current item.
-      const char* item = p;
-      size_t item_len = static_cast<size_t>(p_end - p);
-      const char* item_next =
-          static_cast<const char*>(my_memchr(p, ',', item_len));
-      if (item_next != NULL) {
-        p = item_next + 1;
-        item_len = static_cast<size_t>(item_next - item);
-      } else {
-        p = p_end;
-        item_next = p_end;
-      }
-
-      // Ignore trailing spaces.
-      while (item_next > item && my_isspace(item_next[-1]))
-        item_next--;
-
-      // skip empty items.
-      if (item_next == item)
-        continue;
-
-      // read first decimal value.
-      uintptr_t start = 0;
-      const char* next = my_read_decimal_ptr(&start, item);
-      uintptr_t end = start;
-      if (*next == '-')
-        my_read_decimal_ptr(&end, next+1);
-
-      while (start <= end)
-        SetBit(start++);
-    }
-    return true;
-  }
-
-  // Intersect this CPU set with another one.
-  void IntersectWith(const CpuSet& other) {
-    for (size_t nn = 0; nn < kMaskWordCount; ++nn)
-      mask_[nn] &= other.mask_[nn];
-  }
-
-  // Return the number of CPUs in this set.
-  int GetCount() {
-    int result = 0;
-    for (size_t nn = 0; nn < kMaskWordCount; ++nn) {
-      result += __builtin_popcount(mask_[nn]);
-    }
-    return result;
-  }
-
-private:
-  void SetBit(uintptr_t index) {
-    size_t nn = static_cast<size_t>(index);
-    if (nn < kMaxCpus)
-      mask_[nn / kMaskWordBits] |= (1U << (nn % kMaskWordBits));
-  }
-
-  typedef uint32_t MaskWordType;
-  static const size_t kMaskWordBits = 8*sizeof(MaskWordType);
-  static const size_t kMaskWordCount =
-      (kMaxCpus + kMaskWordBits - 1) / kMaskWordBits;
-
-  MaskWordType mask_[kMaskWordCount];
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_CPU_SET_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/directory_reader.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/directory_reader.h
deleted file mode 100644
index a4bde1803..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/directory_reader.h
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright (c) 2009, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_DIRECTORY_READER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_DIRECTORY_READER_H_
-
-#include <stdint.h>
-#include <unistd.h>
-#include <limits.h>
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-
-#include "common/linux/linux_libc_support.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-// A class for enumerating a directory without using diropen/readdir or other
-// functions which may allocate memory.
-class DirectoryReader {
- public:
-  DirectoryReader(int fd)
-      : fd_(fd),
-        buf_used_(0) {
-  }
-
-  // Return the next entry from the directory
-  //   name: (output) the NUL terminated entry name
-  //
-  // Returns true iff successful (false on EOF).
-  //
-  // After calling this, one must call |PopEntry| otherwise you'll get the same
-  // entry over and over.
-  bool GetNextEntry(const char** name) {
-    struct kernel_dirent* const dent =
-      reinterpret_cast<kernel_dirent*>(buf_);
-
-    if (buf_used_ == 0) {
-      // need to read more entries.
-      const int n = sys_getdents(fd_, dent, sizeof(buf_));
-      if (n < 0) {
-        return false;
-      } else if (n == 0) {
-        hit_eof_ = true;
-      } else {
-        buf_used_ += n;
-      }
-    }
-
-    if (buf_used_ == 0 && hit_eof_)
-      return false;
-
-    assert(buf_used_ > 0);
-
-    *name = dent->d_name;
-    return true;
-  }
-
-  void PopEntry() {
-    if (!buf_used_)
-      return;
-
-    const struct kernel_dirent* const dent =
-      reinterpret_cast<kernel_dirent*>(buf_);
-
-    buf_used_ -= dent->d_reclen;
-    my_memmove(buf_, buf_ + dent->d_reclen, buf_used_);
-  }
-
- private:
-  const int fd_;
-  bool hit_eof_;
-  unsigned buf_used_;
-  uint8_t buf_[sizeof(struct kernel_dirent) + NAME_MAX + 1];
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_DIRECTORY_READER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/line_reader.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/line_reader.h
deleted file mode 100644
index 779cfeb60..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/line_reader.h
+++ /dev/null
@@ -1,131 +0,0 @@
-// Copyright (c) 2009, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_LINE_READER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_LINE_READER_H_
-
-#include <stdint.h>
-#include <assert.h>
-#include <string.h>
-
-#include "common/linux/linux_libc_support.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-// A class for reading a file, line by line, without using fopen/fgets or other
-// functions which may allocate memory.
-class LineReader {
- public:
-  LineReader(int fd)
-      : fd_(fd),
-        hit_eof_(false),
-        buf_used_(0) {
-  }
-
-  // The maximum length of a line.
-  static const size_t kMaxLineLen = 512;
-
-  // Return the next line from the file.
-  //   line: (output) a pointer to the start of the line. The line is NUL
-  //     terminated.
-  //   len: (output) the length of the line (not inc the NUL byte)
-  //
-  // Returns true iff successful (false on EOF).
-  //
-  // One must call |PopLine| after this function, otherwise you'll continue to
-  // get the same line over and over.
-  bool GetNextLine(const char **line, unsigned *len) {
-    for (;;) {
-      if (buf_used_ == 0 && hit_eof_)
-        return false;
-
-      for (unsigned i = 0; i < buf_used_; ++i) {
-        if (buf_[i] == '\n' || buf_[i] == 0) {
-          buf_[i] = 0;
-          *len = i;
-          *line = buf_;
-          return true;
-        }
-      }
-
-      if (buf_used_ == sizeof(buf_)) {
-        // we scanned the whole buffer and didn't find an end-of-line marker.
-        // This line is too long to process.
-        return false;
-      }
-
-      // We didn't find any end-of-line terminators in the buffer. However, if
-      // this is the last line in the file it might not have one:
-      if (hit_eof_) {
-        assert(buf_used_);
-        // There's room for the NUL because of the buf_used_ == sizeof(buf_)
-        // check above.
-        buf_[buf_used_] = 0;
-        *len = buf_used_;
-        buf_used_ += 1;  // since we appended the NUL.
-        *line = buf_;
-        return true;
-      }
-
-      // Otherwise, we should pull in more data from the file
-      const ssize_t n = sys_read(fd_, buf_ + buf_used_,
-                                 sizeof(buf_) - buf_used_);
-      if (n < 0) {
-        return false;
-      } else if (n == 0) {
-        hit_eof_ = true;
-      } else {
-        buf_used_ += n;
-      }
-
-      // At this point, we have either set the hit_eof_ flag, or we have more
-      // data to process...
-    }
-  }
-
-  void PopLine(unsigned len) {
-    // len doesn't include the NUL byte at the end.
-
-    assert(buf_used_ >= len + 1);
-    buf_used_ -= len + 1;
-    my_memmove(buf_, buf_ + len + 1, buf_used_);
-  }
-
- private:
-  const int fd_;
-
-  bool hit_eof_;
-  unsigned buf_used_;
-  char buf_[kMaxLineLen];
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_LINE_READER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.cc b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.cc
deleted file mode 100644
index 4df68a847..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.cc
+++ /dev/null
@@ -1,612 +0,0 @@
-// Copyright (c) 2010, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// linux_dumper.cc: Implement google_breakpad::LinuxDumper.
-// See linux_dumper.h for details.
-
-// This code deals with the mechanics of getting information about a crashed
-// process. Since this code may run in a compromised address space, the same
-// rules apply as detailed at the top of minidump_writer.h: no libc calls and
-// use the alternative allocator.
-
-#include "client/linux/minidump_writer/linux_dumper.h"
-
-#include <assert.h>
-#include <elf.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stddef.h>
-#include <string.h>
-
-# if __WORDSIZE == 64
-#  define UINTPTR_MAX		(18446744073709551615UL)
-# else
-#  define UINTPTR_MAX		(4294967295U)
-# endif
-
-
-#include "client/linux/minidump_writer/line_reader.h"
-#include "common/linux/elfutils.h"
-#include "common/linux/file_id.h"
-#include "common/linux/linux_libc_support.h"
-#include "common/linux/memory_mapped_file.h"
-#include "common/linux/safe_readlink.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-#if defined(__ANDROID__)
-
-// Android packed relocations definitions are not yet available from the
-// NDK header files, so we have to provide them manually here.
-#ifndef DT_LOOS
-#define DT_LOOS 0x6000000d
-#endif
-#ifndef DT_ANDROID_REL
-static const int DT_ANDROID_REL = DT_LOOS + 2;
-#endif
-#ifndef DT_ANDROID_RELA
-static const int DT_ANDROID_RELA = DT_LOOS + 4;
-#endif
-
-#endif  // __ANDROID __
-
-static const char kMappedFileUnsafePrefix[] = "/dev/";
-static const char kDeletedSuffix[] = " (deleted)";
-static const char kReservedFlags[] = " ---p";
-
-inline static bool IsMappedFileOpenUnsafe(
-    const google_breakpad::MappingInfo& mapping) {
-  // It is unsafe to attempt to open a mapped file that lives under /dev,
-  // because the semantics of the open may be driver-specific so we'd risk
-  // hanging the crash dumper. And a file in /dev/ almost certainly has no
-  // ELF file identifier anyways.
-  return my_strncmp(mapping.name,
-                    kMappedFileUnsafePrefix,
-                    sizeof(kMappedFileUnsafePrefix) - 1) == 0;
-}
-
-namespace google_breakpad {
-
-// All interesting auvx entry types are below AT_SYSINFO_EHDR
-#define AT_MAX AT_SYSINFO_EHDR
-
-LinuxDumper::LinuxDumper(pid_t pid)
-    : pid_(pid),
-      crash_address_(0),
-      crash_signal_(0),
-      crash_thread_(pid),
-      threads_(&allocator_, 8),
-      mappings_(&allocator_),
-      auxv_(&allocator_, AT_MAX + 1) {
-  // The passed-in size to the constructor (above) is only a hint.
-  // Must call .resize() to do actual initialization of the elements.
-  auxv_.resize(AT_MAX + 1);
-}
-
-LinuxDumper::~LinuxDumper() {
-}
-
-bool LinuxDumper::Init() {
-  return ReadAuxv() && EnumerateThreads() && EnumerateMappings();
-}
-
-bool LinuxDumper::LateInit() {
-#if defined(__ANDROID__)
-  LatePostprocessMappings();
-#endif
-  return true;
-}
-
-bool
-LinuxDumper::ElfFileIdentifierForMapping(const MappingInfo& mapping,
-                                         bool member,
-                                         unsigned int mapping_id,
-                                         uint8_t identifier[sizeof(MDGUID)]) {
-  assert(!member || mapping_id < mappings_.size());
-  my_memset(identifier, 0, sizeof(MDGUID));
-  if (IsMappedFileOpenUnsafe(mapping))
-    return false;
-
-  // Special-case linux-gate because it's not a real file.
-  if (my_strcmp(mapping.name, kLinuxGateLibraryName) == 0) {
-    void* linux_gate = NULL;
-    if (pid_ == sys_getpid()) {
-      linux_gate = reinterpret_cast<void*>(mapping.start_addr);
-    } else {
-      linux_gate = allocator_.Alloc(mapping.size);
-      CopyFromProcess(linux_gate, pid_,
-                      reinterpret_cast<const void*>(mapping.start_addr),
-                      mapping.size);
-    }
-    return FileID::ElfFileIdentifierFromMappedFile(linux_gate, identifier);
-  }
-
-  char filename[NAME_MAX];
-  size_t filename_len = my_strlen(mapping.name);
-  if (filename_len >= NAME_MAX) {
-    assert(false);
-    return false;
-  }
-  my_memcpy(filename, mapping.name, filename_len);
-  filename[filename_len] = '\0';
-  bool filename_modified = HandleDeletedFileInMapping(filename);
-
-  MemoryMappedFile mapped_file(filename, mapping.offset);
-  if (!mapped_file.data() || mapped_file.size() < SELFMAG)
-    return false;
-
-  bool success =
-      FileID::ElfFileIdentifierFromMappedFile(mapped_file.data(), identifier);
-  if (success && member && filename_modified) {
-    mappings_[mapping_id]->name[filename_len -
-                                sizeof(kDeletedSuffix) + 1] = '\0';
-  }
-
-  return success;
-}
-
-namespace {
-bool ElfFileSoNameFromMappedFile(
-    const void* elf_base, char* soname, size_t soname_size) {
-  if (!IsValidElf(elf_base)) {
-    // Not ELF
-    return false;
-  }
-
-  const void* segment_start;
-  size_t segment_size;
-  int elf_class;
-  if (!FindElfSection(elf_base, ".dynamic", SHT_DYNAMIC,
-                      &segment_start, &segment_size, &elf_class)) {
-    // No dynamic section
-    return false;
-  }
-
-  const void* dynstr_start;
-  size_t dynstr_size;
-  if (!FindElfSection(elf_base, ".dynstr", SHT_STRTAB,
-                      &dynstr_start, &dynstr_size, &elf_class)) {
-    // No dynstr section
-    return false;
-  }
-
-  const ElfW(Dyn)* dynamic = static_cast<const ElfW(Dyn)*>(segment_start);
-  size_t dcount = segment_size / sizeof(ElfW(Dyn));
-  for (const ElfW(Dyn)* dyn = dynamic; dyn < dynamic + dcount; ++dyn) {
-    if (dyn->d_tag == DT_SONAME) {
-      const char* dynstr = static_cast<const char*>(dynstr_start);
-      if (dyn->d_un.d_val >= dynstr_size) {
-        // Beyond the end of the dynstr section
-        return false;
-      }
-      const char* str = dynstr + dyn->d_un.d_val;
-      const size_t maxsize = dynstr_size - dyn->d_un.d_val;
-      my_strlcpy(soname, str, maxsize < soname_size ? maxsize : soname_size);
-      return true;
-    }
-  }
-
-  // Did not find SONAME
-  return false;
-}
-
-// Find the shared object name (SONAME) by examining the ELF information
-// for |mapping|. If the SONAME is found copy it into the passed buffer
-// |soname| and return true. The size of the buffer is |soname_size|.
-// The SONAME will be truncated if it is too long to fit in the buffer.
-bool ElfFileSoName(
-    const MappingInfo& mapping, char* soname, size_t soname_size) {
-  if (IsMappedFileOpenUnsafe(mapping)) {
-    // Not safe
-    return false;
-  }
-
-  char filename[NAME_MAX];
-  size_t filename_len = my_strlen(mapping.name);
-  if (filename_len >= NAME_MAX) {
-    assert(false);
-    // name too long
-    return false;
-  }
-
-  my_memcpy(filename, mapping.name, filename_len);
-  filename[filename_len] = '\0';
-
-  MemoryMappedFile mapped_file(filename, mapping.offset);
-  if (!mapped_file.data() || mapped_file.size() < SELFMAG) {
-    // mmap failed
-    return false;
-  }
-
-  return ElfFileSoNameFromMappedFile(mapped_file.data(), soname, soname_size);
-}
-
-}  // namespace
-
-
-// static
-void LinuxDumper::GetMappingEffectiveNameAndPath(const MappingInfo& mapping,
-                                                 char* file_path,
-                                                 size_t file_path_size,
-                                                 char* file_name,
-                                                 size_t file_name_size) {
-  my_strlcpy(file_path, mapping.name, file_path_size);
-
-  // If an executable is mapped from a non-zero offset, this is likely because
-  // the executable was loaded directly from inside an archive file (e.g., an
-  // apk on Android). We try to find the name of the shared object (SONAME) by
-  // looking in the file for ELF sections.
-  bool mapped_from_archive = false;
-  if (mapping.exec && mapping.offset != 0)
-    mapped_from_archive = ElfFileSoName(mapping, file_name, file_name_size);
-
-  if (mapped_from_archive) {
-    // Some tools (e.g., stackwalk) extract the basename from the pathname. In
-    // this case, we append the file_name to the mapped archive path as follows:
-    //   file_name := libname.so
-    //   file_path := /path/to/ARCHIVE.APK/libname.so
-    if (my_strlen(file_path) + 1 + my_strlen(file_name) < file_path_size) {
-      my_strlcat(file_path, "/", file_path_size);
-      my_strlcat(file_path, file_name, file_path_size);
-    }
-  } else {
-    // Common case:
-    //   file_path := /path/to/libname.so
-    //   file_name := libname.so
-    const char* basename = my_strrchr(file_path, '/');
-    basename = basename == NULL ? file_path : (basename + 1);
-    my_strlcpy(file_name, basename, file_name_size);
-  }
-}
-
-bool LinuxDumper::ReadAuxv() {
-  char auxv_path[NAME_MAX];
-  if (!BuildProcPath(auxv_path, pid_, "auxv")) {
-    return false;
-  }
-
-  int fd = sys_open(auxv_path, O_RDONLY, 0);
-  if (fd < 0) {
-    return false;
-  }
-
-  elf_aux_entry one_aux_entry;
-  bool res = false;
-  while (sys_read(fd,
-                  &one_aux_entry,
-                  sizeof(elf_aux_entry)) == sizeof(elf_aux_entry) &&
-         one_aux_entry.a_type != AT_NULL) {
-    if (one_aux_entry.a_type <= AT_MAX) {
-      auxv_[one_aux_entry.a_type] = one_aux_entry.a_un.a_val;
-      res = true;
-    }
-  }
-  sys_close(fd);
-  return res;
-}
-
-bool LinuxDumper::EnumerateMappings() {
-  char maps_path[NAME_MAX];
-  if (!BuildProcPath(maps_path, pid_, "maps"))
-    return false;
-
-  // linux_gate_loc is the beginning of the kernel's mapping of
-  // linux-gate.so in the process.  It doesn't actually show up in the
-  // maps list as a filename, but it can be found using the AT_SYSINFO_EHDR
-  // aux vector entry, which gives the information necessary to special
-  // case its entry when creating the list of mappings.
-  // See http://www.trilithium.com/johan/2005/08/linux-gate/ for more
-  // information.
-  const void* linux_gate_loc =
-      reinterpret_cast<void *>(auxv_[AT_SYSINFO_EHDR]);
-  // Although the initial executable is usually the first mapping, it's not
-  // guaranteed (see http://crosbug.com/25355); therefore, try to use the
-  // actual entry point to find the mapping.
-  const void* entry_point_loc = reinterpret_cast<void *>(auxv_[AT_ENTRY]);
-
-  const int fd = sys_open(maps_path, O_RDONLY, 0);
-  if (fd < 0)
-    return false;
-  LineReader* const line_reader = new(allocator_) LineReader(fd);
-
-  const char* line;
-  unsigned line_len;
-  while (line_reader->GetNextLine(&line, &line_len)) {
-    uintptr_t start_addr, end_addr, offset;
-
-    const char* i1 = my_read_hex_ptr(&start_addr, line);
-    if (*i1 == '-') {
-      const char* i2 = my_read_hex_ptr(&end_addr, i1 + 1);
-      if (*i2 == ' ') {
-        bool exec = (*(i2 + 3) == 'x');
-        const char* i3 = my_read_hex_ptr(&offset, i2 + 6 /* skip ' rwxp ' */);
-        if (*i3 == ' ') {
-          const char* name = NULL;
-          // Only copy name if the name is a valid path name, or if
-          // it's the VDSO image.
-          if (((name = my_strchr(line, '/')) == NULL) &&
-              linux_gate_loc &&
-              reinterpret_cast<void*>(start_addr) == linux_gate_loc) {
-            name = kLinuxGateLibraryName;
-            offset = 0;
-          }
-          // Merge adjacent mappings with the same name into one module,
-          // assuming they're a single library mapped by the dynamic linker
-          if (name && !mappings_.empty()) {
-            MappingInfo* module = mappings_.back();
-            if ((start_addr == module->start_addr + module->size) &&
-                (my_strlen(name) == my_strlen(module->name)) &&
-                (my_strncmp(name, module->name, my_strlen(name)) == 0)) {
-              module->size = end_addr - module->start_addr;
-              line_reader->PopLine(line_len);
-              continue;
-            }
-          }
-          // Also merge mappings that result from address ranges that the
-          // linker reserved but which a loaded library did not use. These
-          // appear as an anonymous private mapping with no access flags set
-          // and which directly follow an executable mapping.
-          if (!name && !mappings_.empty()) {
-            MappingInfo* module = mappings_.back();
-            if ((start_addr == module->start_addr + module->size) &&
-                module->exec &&
-                module->name[0] == '/' &&
-                offset == 0 && my_strncmp(i2,
-                                          kReservedFlags,
-                                          sizeof(kReservedFlags) - 1) == 0) {
-              module->size = end_addr - module->start_addr;
-              line_reader->PopLine(line_len);
-              continue;
-            }
-          }
-          MappingInfo* const module = new(allocator_) MappingInfo;
-          my_memset(module, 0, sizeof(MappingInfo));
-          module->start_addr = start_addr;
-          module->size = end_addr - start_addr;
-          module->offset = offset;
-          module->exec = exec;
-          if (name != NULL) {
-            const unsigned l = my_strlen(name);
-            if (l < sizeof(module->name))
-              my_memcpy(module->name, name, l);
-          }
-          // If this is the entry-point mapping, and it's not already the
-          // first one, then we need to make it be first.  This is because
-          // the minidump format assumes the first module is the one that
-          // corresponds to the main executable (as codified in
-          // processor/minidump.cc:MinidumpModuleList::GetMainModule()).
-          if (entry_point_loc &&
-              (entry_point_loc >=
-                  reinterpret_cast<void*>(module->start_addr)) &&
-              (entry_point_loc <
-                  reinterpret_cast<void*>(module->start_addr+module->size)) &&
-              !mappings_.empty()) {
-            // push the module onto the front of the list.
-            mappings_.resize(mappings_.size() + 1);
-            for (size_t idx = mappings_.size() - 1; idx > 0; idx--)
-              mappings_[idx] = mappings_[idx - 1];
-            mappings_[0] = module;
-          } else {
-            mappings_.push_back(module);
-          }
-        }
-      }
-    }
-    line_reader->PopLine(line_len);
-  }
-
-  sys_close(fd);
-
-  return !mappings_.empty();
-}
-
-#if defined(__ANDROID__)
-
-bool LinuxDumper::GetLoadedElfHeader(uintptr_t start_addr, ElfW(Ehdr)* ehdr) {
-  CopyFromProcess(ehdr, pid_,
-                  reinterpret_cast<const void*>(start_addr),
-                  sizeof(*ehdr));
-  return my_memcmp(&ehdr->e_ident, ELFMAG, SELFMAG) == 0;
-}
-
-void LinuxDumper::ParseLoadedElfProgramHeaders(ElfW(Ehdr)* ehdr,
-                                               uintptr_t start_addr,
-                                               uintptr_t* min_vaddr_ptr,
-                                               uintptr_t* dyn_vaddr_ptr,
-                                               size_t* dyn_count_ptr) {
-  uintptr_t phdr_addr = start_addr + ehdr->e_phoff;
-
-  const uintptr_t max_addr = UINTPTR_MAX;
-  uintptr_t min_vaddr = max_addr;
-  uintptr_t dyn_vaddr = 0;
-  size_t dyn_count = 0;
-
-  for (size_t i = 0; i < ehdr->e_phnum; ++i) {
-    ElfW(Phdr) phdr;
-    CopyFromProcess(&phdr, pid_,
-                    reinterpret_cast<const void*>(phdr_addr),
-                    sizeof(phdr));
-    if (phdr.p_type == PT_LOAD && phdr.p_vaddr < min_vaddr) {
-      min_vaddr = phdr.p_vaddr;
-    }
-    if (phdr.p_type == PT_DYNAMIC) {
-      dyn_vaddr = phdr.p_vaddr;
-      dyn_count = phdr.p_memsz / sizeof(ElfW(Dyn));
-    }
-    phdr_addr += sizeof(phdr);
-  }
-
-  *min_vaddr_ptr = min_vaddr;
-  *dyn_vaddr_ptr = dyn_vaddr;
-  *dyn_count_ptr = dyn_count;
-}
-
-bool LinuxDumper::HasAndroidPackedRelocations(uintptr_t load_bias,
-                                              uintptr_t dyn_vaddr,
-                                              size_t dyn_count) {
-  uintptr_t dyn_addr = load_bias + dyn_vaddr;
-  for (size_t i = 0; i < dyn_count; ++i) {
-    ElfW(Dyn) dyn;
-    CopyFromProcess(&dyn, pid_,
-                    reinterpret_cast<const void*>(dyn_addr),
-                    sizeof(dyn));
-    if (dyn.d_tag == DT_ANDROID_REL || dyn.d_tag == DT_ANDROID_RELA) {
-      return true;
-    }
-    dyn_addr += sizeof(dyn);
-  }
-  return false;
-}
-
-uintptr_t LinuxDumper::GetEffectiveLoadBias(ElfW(Ehdr)* ehdr,
-                                            uintptr_t start_addr) {
-  uintptr_t min_vaddr = 0;
-  uintptr_t dyn_vaddr = 0;
-  size_t dyn_count = 0;
-  ParseLoadedElfProgramHeaders(ehdr, start_addr,
-                               &min_vaddr, &dyn_vaddr, &dyn_count);
-  // If |min_vaddr| is non-zero and we find Android packed relocation tags,
-  // return the effective load bias.
-  if (min_vaddr != 0) {
-    const uintptr_t load_bias = start_addr - min_vaddr;
-    if (HasAndroidPackedRelocations(load_bias, dyn_vaddr, dyn_count)) {
-      return load_bias;
-    }
-  }
-  // Either |min_vaddr| is zero, or it is non-zero but we did not find the
-  // expected Android packed relocations tags.
-  return start_addr;
-}
-
-void LinuxDumper::LatePostprocessMappings() {
-  for (size_t i = 0; i < mappings_.size(); ++i) {
-    // Only consider exec mappings that indicate a file path was mapped, and
-    // where the ELF header indicates a mapped shared library.
-    MappingInfo* mapping = mappings_[i];
-    if (!(mapping->exec && mapping->name[0] == '/')) {
-      continue;
-    }
-    ElfW(Ehdr) ehdr;
-    if (!GetLoadedElfHeader(mapping->start_addr, &ehdr)) {
-      continue;
-    }
-    if (ehdr.e_type == ET_DYN) {
-      // Compute the effective load bias for this mapped library, and update
-      // the mapping to hold that rather than |start_addr|, at the same time
-      // adjusting |size| to account for the change in |start_addr|. Where
-      // the library does not contain Android packed relocations,
-      // GetEffectiveLoadBias() returns |start_addr| and the mapping entry
-      // is not changed.
-      const uintptr_t load_bias = GetEffectiveLoadBias(&ehdr,
-                                                       mapping->start_addr);
-      mapping->size += mapping->start_addr - load_bias;
-      mapping->start_addr = load_bias;
-    }
-  }
-}
-
-#endif  // __ANDROID__
-
-// Get information about the stack, given the stack pointer. We don't try to
-// walk the stack since we might not have all the information needed to do
-// unwind. So we just grab, up to, 32k of stack.
-bool LinuxDumper::GetStackInfo(const void** stack, size_t* stack_len,
-                               uintptr_t int_stack_pointer) {
-  // Move the stack pointer to the bottom of the page that it's in.
-  const uintptr_t page_size = getpagesize();
-
-  uint8_t* const stack_pointer =
-      reinterpret_cast<uint8_t*>(int_stack_pointer & ~(page_size - 1));
-
-  // The number of bytes of stack which we try to capture.
-  static const ptrdiff_t kStackToCapture = 32 * 1024;
-
-  const MappingInfo* mapping = FindMapping(stack_pointer);
-  if (!mapping)
-    return false;
-  const ptrdiff_t offset = stack_pointer -
-      reinterpret_cast<uint8_t*>(mapping->start_addr);
-  const ptrdiff_t distance_to_end =
-      static_cast<ptrdiff_t>(mapping->size) - offset;
-  *stack_len = distance_to_end > kStackToCapture ?
-      kStackToCapture : distance_to_end;
-  *stack = stack_pointer;
-  return true;
-}
-
-// Find the mapping which the given memory address falls in.
-const MappingInfo* LinuxDumper::FindMapping(const void* address) const {
-  const uintptr_t addr = (uintptr_t) address;
-
-  for (size_t i = 0; i < mappings_.size(); ++i) {
-    const uintptr_t start = static_cast<uintptr_t>(mappings_[i]->start_addr);
-    if (addr >= start && addr - start < mappings_[i]->size)
-      return mappings_[i];
-  }
-
-  return NULL;
-}
-
-bool LinuxDumper::HandleDeletedFileInMapping(char* path) const {
-  static const size_t kDeletedSuffixLen = sizeof(kDeletedSuffix) - 1;
-
-  // Check for ' (deleted)' in |path|.
-  // |path| has to be at least as long as "/x (deleted)".
-  const size_t path_len = my_strlen(path);
-  if (path_len < kDeletedSuffixLen + 2)
-    return false;
-  if (my_strncmp(path + path_len - kDeletedSuffixLen, kDeletedSuffix,
-                 kDeletedSuffixLen) != 0) {
-    return false;
-  }
-
-  // Check |path| against the /proc/pid/exe 'symlink'.
-  char exe_link[NAME_MAX];
-  char new_path[NAME_MAX];
-  if (!BuildProcPath(exe_link, pid_, "exe"))
-    return false;
-  if (!SafeReadLink(exe_link, new_path))
-    return false;
-  if (my_strcmp(path, new_path) != 0)
-    return false;
-
-  // Check to see if someone actually named their executable 'foo (deleted)'.
-  struct kernel_stat exe_stat;
-  struct kernel_stat new_path_stat;
-  if (sys_stat(exe_link, &exe_stat) == 0 &&
-      sys_stat(new_path, &new_path_stat) == 0 &&
-      exe_stat.st_dev == new_path_stat.st_dev &&
-      exe_stat.st_ino == new_path_stat.st_ino) {
-    return false;
-  }
-
-  my_memcpy(path, exe_link, NAME_MAX);
-  return true;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.h
deleted file mode 100644
index 6a3a100f3..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_dumper.h
+++ /dev/null
@@ -1,254 +0,0 @@
-// Copyright (c) 2010, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// linux_dumper.h: Define the google_breakpad::LinuxDumper class, which
-// is a base class for extracting information of a crashed process. It
-// was originally a complete implementation using the ptrace API, but
-// has been refactored to allow derived implementations supporting both
-// ptrace and core dump. A portion of the original implementation is now
-// in google_breakpad::LinuxPtraceDumper (see linux_ptrace_dumper.h for
-// details).
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_LINUX_DUMPER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_LINUX_DUMPER_H_
-
-#include <elf.h>
-#if defined(__ANDROID__)
-#include <link.h>
-#endif
-#include <linux/limits.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <sys/user.h>
-
-#include "client/linux/dump_writer_common/mapping_info.h"
-#include "client/linux/dump_writer_common/thread_info.h"
-#include "common/memory.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-// Typedef for our parsing of the auxv variables in /proc/pid/auxv.
-#if defined(__i386) || defined(__ARM_EABI__) || \
- (defined(__mips__) && _MIPS_SIM == _ABIO32)
-typedef Elf32_auxv_t elf_aux_entry;
-#elif defined(__x86_64) || defined(__aarch64__) || \
-     (defined(__mips__) && _MIPS_SIM != _ABIO32)
-typedef Elf64_auxv_t elf_aux_entry;
-#endif
-
-typedef __typeof__(((elf_aux_entry*) 0)->a_un.a_val) elf_aux_val_t;
-
-// When we find the VDSO mapping in the process's address space, this
-// is the name we use for it when writing it to the minidump.
-// This should always be less than NAME_MAX!
-const char kLinuxGateLibraryName[] = "linux-gate.so";
-
-class LinuxDumper {
- public:
-  explicit LinuxDumper(pid_t pid);
-
-  virtual ~LinuxDumper();
-
-  // Parse the data for |threads| and |mappings|.
-  virtual bool Init();
-
-  // Take any actions that could not be taken in Init(). LateInit() is
-  // called after all other caller's initialization is complete, and in
-  // particular after it has called ThreadsSuspend(), so that ptrace is
-  // available.
-  virtual bool LateInit();
-
-  // Return true if the dumper performs a post-mortem dump.
-  virtual bool IsPostMortem() const = 0;
-
-  // Suspend/resume all threads in the given process.
-  virtual bool ThreadsSuspend() = 0;
-  virtual bool ThreadsResume() = 0;
-
-  // Read information about the |index|-th thread of |threads_|.
-  // Returns true on success. One must have called |ThreadsSuspend| first.
-  virtual bool GetThreadInfoByIndex(size_t index, ThreadInfo* info) = 0;
-
-  // These are only valid after a call to |Init|.
-  const wasteful_vector<pid_t> &threads() { return threads_; }
-  const wasteful_vector<MappingInfo*> &mappings() { return mappings_; }
-  const MappingInfo* FindMapping(const void* address) const;
-  const wasteful_vector<elf_aux_val_t>& auxv() { return auxv_; }
-
-  // Find a block of memory to take as the stack given the top of stack pointer.
-  //   stack: (output) the lowest address in the memory area
-  //   stack_len: (output) the length of the memory area
-  //   stack_top: the current top of the stack
-  bool GetStackInfo(const void** stack, size_t* stack_len, uintptr_t stack_top);
-
-  PageAllocator* allocator() { return &allocator_; }
-
-  // Copy content of |length| bytes from a given process |child|,
-  // starting from |src|, into |dest|. Returns true on success.
-  virtual bool CopyFromProcess(void* dest, pid_t child, const void* src,
-                               size_t length) = 0;
-
-  // Builds a proc path for a certain pid for a node (/proc/<pid>/<node>).
-  // |path| is a character array of at least NAME_MAX bytes to return the
-  // result.|node| is the final node without any slashes. Returns true on
-  // success.
-  virtual bool BuildProcPath(char* path, pid_t pid, const char* node) const = 0;
-
-  // Generate a File ID from the .text section of a mapped entry.
-  // If not a member, mapping_id is ignored. This method can also manipulate the
-  // |mapping|.name to truncate "(deleted)" from the file name if necessary.
-  bool ElfFileIdentifierForMapping(const MappingInfo& mapping,
-                                   bool member,
-                                   unsigned int mapping_id,
-                                   uint8_t identifier[sizeof(MDGUID)]);
-
-  uintptr_t crash_address() const { return crash_address_; }
-  void set_crash_address(uintptr_t crash_address) {
-    crash_address_ = crash_address;
-  }
-
-  int crash_signal() const { return crash_signal_; }
-  void set_crash_signal(int crash_signal) { crash_signal_ = crash_signal; }
-
-  pid_t crash_thread() const { return crash_thread_; }
-  void set_crash_thread(pid_t crash_thread) { crash_thread_ = crash_thread; }
-
-  // Extracts the effective path and file name of from |mapping|. In most cases
-  // the effective name/path are just the mapping's path and basename. In some
-  // other cases, however, a library can be mapped from an archive (e.g., when
-  // loading .so libs from an apk on Android) and this method is able to
-  // reconstruct the original file name.
-  static void GetMappingEffectiveNameAndPath(const MappingInfo& mapping,
-                                             char* file_path,
-                                             size_t file_path_size,
-                                             char* file_name,
-                                             size_t file_name_size);
-
- protected:
-  bool ReadAuxv();
-
-  virtual bool EnumerateMappings();
-
-  virtual bool EnumerateThreads() = 0;
-
-  // For the case where a running program has been deleted, it'll show up in
-  // /proc/pid/maps as "/path/to/program (deleted)". If this is the case, then
-  // see if '/path/to/program (deleted)' matches /proc/pid/exe and return
-  // /proc/pid/exe in |path| so ELF identifier generation works correctly. This
-  // also checks to see if '/path/to/program (deleted)' exists, so it does not
-  // get fooled by a poorly named binary.
-  // For programs that don't end with ' (deleted)', this is a no-op.
-  // This assumes |path| is a buffer with length NAME_MAX.
-  // Returns true if |path| is modified.
-  bool HandleDeletedFileInMapping(char* path) const;
-
-   // ID of the crashed process.
-  const pid_t pid_;
-
-  // Virtual address at which the process crashed.
-  uintptr_t crash_address_;
-
-  // Signal that terminated the crashed process.
-  int crash_signal_;
-
-  // ID of the crashed thread.
-  pid_t crash_thread_;
-
-  mutable PageAllocator allocator_;
-
-  // IDs of all the threads.
-  wasteful_vector<pid_t> threads_;
-
-  // Info from /proc/<pid>/maps.
-  wasteful_vector<MappingInfo*> mappings_;
-
-  // Info from /proc/<pid>/auxv
-  wasteful_vector<elf_aux_val_t> auxv_;
-
-#if defined(__ANDROID__)
- private:
-  // Android M and later support packed ELF relocations in shared libraries.
-  // Packing relocations changes the vaddr of the LOAD segments, such that
-  // the effective load bias is no longer the same as the start address of
-  // the memory mapping containing the executable parts of the library. The
-  // packing is applied to the stripped library run on the target, but not to
-  // any other library, and in particular not to the library used to generate
-  // breakpad symbols. As a result, we need to adjust the |start_addr| for
-  // any mapping that results from a shared library that contains Android
-  // packed relocations, so that it properly represents the effective library
-  // load bias. The following functions support this adjustment.
-
-  // Check that a given mapping at |start_addr| is for an ELF shared library.
-  // If it is, place the ELF header in |ehdr| and return true.
-  // The first LOAD segment in an ELF shared library has offset zero, so the
-  // ELF file header is at the start of this map entry, and in already mapped
-  // memory.
-  bool GetLoadedElfHeader(uintptr_t start_addr, ElfW(Ehdr)* ehdr);
-
-  // For the ELF file mapped at |start_addr|, iterate ELF program headers to
-  // find the min vaddr of all program header LOAD segments, the vaddr for
-  // the DYNAMIC segment, and a count of DYNAMIC entries. Return values in
-  // |min_vaddr_ptr|, |dyn_vaddr_ptr|, and |dyn_count_ptr|.
-  // The program header table is also in already mapped memory.
-  void ParseLoadedElfProgramHeaders(ElfW(Ehdr)* ehdr,
-                                    uintptr_t start_addr,
-                                    uintptr_t* min_vaddr_ptr,
-                                    uintptr_t* dyn_vaddr_ptr,
-                                    size_t* dyn_count_ptr);
-
-  // Search the DYNAMIC tags for the ELF file with the given |load_bias|, and
-  // return true if the tags indicate that the file contains Android packed
-  // relocations. Dynamic tags are found at |dyn_vaddr| past the |load_bias|.
-  bool HasAndroidPackedRelocations(uintptr_t load_bias,
-                                   uintptr_t dyn_vaddr,
-                                   size_t dyn_count);
-
-  // If the ELF file mapped at |start_addr| contained Android packed
-  // relocations, return the load bias that the system linker (or Chromium
-  // crazy linker) will have used. If the file did not contain Android
-  // packed relocations, returns |start_addr|, indicating that no adjustment
-  // is necessary.
-  // The effective load bias is |start_addr| adjusted downwards by the
-  // min vaddr in the library LOAD segments.
-  uintptr_t GetEffectiveLoadBias(ElfW(Ehdr)* ehdr, uintptr_t start_addr);
-
-  // Called from LateInit(). Iterates |mappings_| and rewrites the |start_addr|
-  // field of any that represent ELF shared libraries with Android packed
-  // relocations, so that |start_addr| is the load bias that the system linker
-  // (or Chromium crazy linker) used. This value matches the addresses produced
-  // when the non-relocation-packed library is used for breakpad symbol
-  // generation.
-  void LatePostprocessMappings();
-#endif  // __ANDROID__
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_HANDLER_LINUX_DUMPER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc
deleted file mode 100644
index c35e0e958..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ /dev/null
@@ -1,355 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// linux_ptrace_dumper.cc: Implement google_breakpad::LinuxPtraceDumper.
-// See linux_ptrace_dumper.h for detals.
-// This class was originally splitted from google_breakpad::LinuxDumper.
-
-// This code deals with the mechanics of getting information about a crashed
-// process. Since this code may run in a compromised address space, the same
-// rules apply as detailed at the top of minidump_writer.h: no libc calls and
-// use the alternative allocator.
-
-#include "client/linux/minidump_writer/linux_ptrace_dumper.h"
-
-#include <asm/ptrace.h>
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ptrace.h>
-#include <sys/uio.h>
-#include <sys/wait.h>
-
-#if defined(__i386)
-#include <cpuid.h>
-#endif
-
-#include "client/linux/minidump_writer/directory_reader.h"
-#include "client/linux/minidump_writer/line_reader.h"
-#include "common/linux/linux_libc_support.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-// Suspends a thread by attaching to it.
-static bool SuspendThread(pid_t pid) {
-  // This may fail if the thread has just died or debugged.
-  errno = 0;
-  if (sys_ptrace(PTRACE_ATTACH, pid, NULL, NULL) != 0 &&
-      errno != 0) {
-    return false;
-  }
-  while (sys_waitpid(pid, NULL, __WALL) < 0) {
-    if (errno != EINTR) {
-      sys_ptrace(PTRACE_DETACH, pid, NULL, NULL);
-      return false;
-    }
-  }
-#if defined(__i386) || defined(__x86_64)
-  // On x86, the stack pointer is NULL or -1, when executing trusted code in
-  // the seccomp sandbox. Not only does this cause difficulties down the line
-  // when trying to dump the thread's stack, it also results in the minidumps
-  // containing information about the trusted threads. This information is
-  // generally completely meaningless and just pollutes the minidumps.
-  // We thus test the stack pointer and exclude any threads that are part of
-  // the seccomp sandbox's trusted code.
-  user_regs_struct regs;
-  if (sys_ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1 ||
-#if defined(__i386)
-      !regs.esp
-#elif defined(__x86_64)
-      !regs.rsp
-#endif
-      ) {
-    sys_ptrace(PTRACE_DETACH, pid, NULL, NULL);
-    return false;
-  }
-#endif
-  return true;
-}
-
-// Resumes a thread by detaching from it.
-static bool ResumeThread(pid_t pid) {
-  return sys_ptrace(PTRACE_DETACH, pid, NULL, NULL) >= 0;
-}
-
-namespace google_breakpad {
-
-LinuxPtraceDumper::LinuxPtraceDumper(pid_t pid)
-    : LinuxDumper(pid),
-      threads_suspended_(false) {
-}
-
-bool LinuxPtraceDumper::BuildProcPath(char* path, pid_t pid,
-                                      const char* node) const {
-  if (!path || !node || pid <= 0)
-    return false;
-
-  size_t node_len = my_strlen(node);
-  if (node_len == 0)
-    return false;
-
-  const unsigned pid_len = my_uint_len(pid);
-  const size_t total_length = 6 + pid_len + 1 + node_len;
-  if (total_length >= NAME_MAX)
-    return false;
-
-  my_memcpy(path, "/proc/", 6);
-  my_uitos(path + 6, pid, pid_len);
-  path[6 + pid_len] = '/';
-  my_memcpy(path + 6 + pid_len + 1, node, node_len);
-  path[total_length] = '\0';
-  return true;
-}
-
-bool LinuxPtraceDumper::CopyFromProcess(void* dest, pid_t child,
-                                        const void* src, size_t length) {
-  unsigned long tmp = 55;
-  size_t done = 0;
-  static const size_t word_size = sizeof(tmp);
-  uint8_t* const local = (uint8_t*) dest;
-  uint8_t* const remote = (uint8_t*) src;
-
-  while (done < length) {
-    const size_t l = (length - done > word_size) ? word_size : (length - done);
-    if (sys_ptrace(PTRACE_PEEKDATA, child, remote + done, &tmp) == -1) {
-      tmp = 0;
-    }
-    my_memcpy(local + done, &tmp, l);
-    done += l;
-  }
-  return true;
-}
-
-// Read thread info from /proc/$pid/status.
-// Fill out the |tgid|, |ppid| and |pid| members of |info|. If unavailable,
-// these members are set to -1. Returns true iff all three members are
-// available.
-bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
-  if (index >= threads_.size())
-    return false;
-
-  pid_t tid = threads_[index];
-
-  assert(info != NULL);
-  char status_path[NAME_MAX];
-  if (!BuildProcPath(status_path, tid, "status"))
-    return false;
-
-  const int fd = sys_open(status_path, O_RDONLY, 0);
-  if (fd < 0)
-    return false;
-
-  LineReader* const line_reader = new(allocator_) LineReader(fd);
-  const char* line;
-  unsigned line_len;
-
-  info->ppid = info->tgid = -1;
-
-  while (line_reader->GetNextLine(&line, &line_len)) {
-    if (my_strncmp("Tgid:\t", line, 6) == 0) {
-      my_strtoui(&info->tgid, line + 6);
-    } else if (my_strncmp("PPid:\t", line, 6) == 0) {
-      my_strtoui(&info->ppid, line + 6);
-    }
-
-    line_reader->PopLine(line_len);
-  }
-  sys_close(fd);
-
-  if (info->ppid == -1 || info->tgid == -1)
-    return false;
-
-#ifdef PTRACE_GETREGSET
-  struct iovec io;
-  info->GetGeneralPurposeRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
-    return false;
-  }
-
-  info->GetFloatingPointRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
-    return false;
-  }
-#else  // PTRACE_GETREGSET
-  void* gp_addr;
-  info->GetGeneralPurposeRegisters(&gp_addr, NULL);
-  if (sys_ptrace(PTRACE_GETREGS, tid, NULL, gp_addr) == -1) {
-    return false;
-  }
-
-#if !(defined(__ANDROID__) && defined(__ARM_EABI__))
-  // When running an arm build on an arm64 device, attempting to get the
-  // floating point registers fails. On Android, the floating point registers
-  // aren't written to the cpu context anyway, so just don't get them here.
-  // See http://crbug.com/508324
-  void* fp_addr;
-  info->GetFloatingPointRegisters(&fp_addr, NULL);
-  if (sys_ptrace(PTRACE_GETFPREGS, tid, NULL, fp_addr) == -1) {
-    return false;
-  }
-#endif
-#endif  // PTRACE_GETREGSET
-
-#if defined(__i386)
-#if !defined(bit_FXSAVE)  // e.g. Clang
-#define bit_FXSAVE bit_FXSR
-#endif
-  // Detect if the CPU supports the FXSAVE/FXRSTOR instructions
-  int eax, ebx, ecx, edx;
-  __cpuid(1, eax, ebx, ecx, edx);
-  if (edx & bit_FXSAVE) {
-    if (sys_ptrace(PTRACE_GETFPXREGS, tid, NULL, &info->fpxregs) == -1) {
-      return false;
-    }
-  } else {
-    memset(&info->fpxregs, 0, sizeof(info->fpxregs));
-  }
-#endif  // defined(__i386)
-
-#if defined(__i386) || defined(__x86_64)
-  for (unsigned i = 0; i < ThreadInfo::kNumDebugRegisters; ++i) {
-    if (sys_ptrace(
-        PTRACE_PEEKUSER, tid,
-        reinterpret_cast<void*> (offsetof(struct user,
-                                          u_debugreg[0]) + i *
-                                 sizeof(debugreg_t)),
-        &info->dregs[i]) == -1) {
-      return false;
-    }
-  }
-#endif
-
-#if defined(__mips__)
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE), &info->mcontext.hi1);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE + 1), &info->mcontext.lo1);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE + 2), &info->mcontext.hi2);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE + 3), &info->mcontext.lo2);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE + 4), &info->mcontext.hi3);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_BASE + 5), &info->mcontext.lo3);
-  sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_CONTROL), &info->mcontext.dsp);
-#endif
-
-  const uint8_t* stack_pointer;
-#if defined(__i386)
-  my_memcpy(&stack_pointer, &info->regs.esp, sizeof(info->regs.esp));
-#elif defined(__x86_64)
-  my_memcpy(&stack_pointer, &info->regs.rsp, sizeof(info->regs.rsp));
-#elif defined(__ARM_EABI__)
-  my_memcpy(&stack_pointer, &info->regs.ARM_sp, sizeof(info->regs.ARM_sp));
-#elif defined(__aarch64__)
-  my_memcpy(&stack_pointer, &info->regs.sp, sizeof(info->regs.sp));
-#elif defined(__mips__)
-  stack_pointer =
-      reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
-#else
-#error "This code hasn't been ported to your platform yet."
-#endif
-  info->stack_pointer = reinterpret_cast<uintptr_t>(stack_pointer);
-
-  return true;
-}
-
-bool LinuxPtraceDumper::IsPostMortem() const {
-  return false;
-}
-
-bool LinuxPtraceDumper::ThreadsSuspend() {
-  if (threads_suspended_)
-    return true;
-  for (size_t i = 0; i < threads_.size(); ++i) {
-    if (!SuspendThread(threads_[i])) {
-      // If the thread either disappeared before we could attach to it, or if
-      // it was part of the seccomp sandbox's trusted code, it is OK to
-      // silently drop it from the minidump.
-      if (i < threads_.size() - 1) {
-        my_memmove(&threads_[i], &threads_[i + 1],
-                   (threads_.size() - i - 1) * sizeof(threads_[i]));
-      }
-      threads_.resize(threads_.size() - 1);
-      --i;
-    }
-  }
-  threads_suspended_ = true;
-  return threads_.size() > 0;
-}
-
-bool LinuxPtraceDumper::ThreadsResume() {
-  if (!threads_suspended_)
-    return false;
-  bool good = true;
-  for (size_t i = 0; i < threads_.size(); ++i)
-    good &= ResumeThread(threads_[i]);
-  threads_suspended_ = false;
-  return good;
-}
-
-// Parse /proc/$pid/task to list all the threads of the process identified by
-// pid.
-bool LinuxPtraceDumper::EnumerateThreads() {
-  char task_path[NAME_MAX];
-  if (!BuildProcPath(task_path, pid_, "task"))
-    return false;
-
-  const int fd = sys_open(task_path, O_RDONLY | O_DIRECTORY, 0);
-  if (fd < 0)
-    return false;
-  DirectoryReader* dir_reader = new(allocator_) DirectoryReader(fd);
-
-  // The directory may contain duplicate entries which we filter by assuming
-  // that they are consecutive.
-  int last_tid = -1;
-  const char* dent_name;
-  while (dir_reader->GetNextEntry(&dent_name)) {
-    if (my_strcmp(dent_name, ".") &&
-        my_strcmp(dent_name, "..")) {
-      int tid = 0;
-      if (my_strtoui(&tid, dent_name) &&
-          last_tid != tid) {
-        last_tid = tid;
-        threads_.push_back(tid);
-      }
-    }
-    dir_reader->PopEntry();
-  }
-
-  sys_close(fd);
-  return true;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h
deleted file mode 100644
index 2ce834b0f..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// linux_ptrace_dumper.h: Define the google_breakpad::LinuxPtraceDumper
-// class, which is derived from google_breakpad::LinuxDumper to extract
-// information from a crashed process via ptrace.
-// This class was originally splitted from google_breakpad::LinuxDumper.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_LINUX_PTRACE_DUMPER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_LINUX_PTRACE_DUMPER_H_
-
-#include "client/linux/minidump_writer/linux_dumper.h"
-
-namespace google_breakpad {
-
-class LinuxPtraceDumper : public LinuxDumper {
- public:
-  // Constructs a dumper for extracting information of a given process
-  // with a process ID of |pid|.
-  explicit LinuxPtraceDumper(pid_t pid);
-
-  // Implements LinuxDumper::BuildProcPath().
-  // Builds a proc path for a certain pid for a node (/proc/<pid>/<node>).
-  // |path| is a character array of at least NAME_MAX bytes to return the
-  // result. |node| is the final node without any slashes. Returns true on
-  // success.
-  virtual bool BuildProcPath(char* path, pid_t pid, const char* node) const;
-
-  // Implements LinuxDumper::CopyFromProcess().
-  // Copies content of |length| bytes from a given process |child|,
-  // starting from |src|, into |dest|. This method uses ptrace to extract
-  // the content from the target process. Always returns true.
-  virtual bool CopyFromProcess(void* dest, pid_t child, const void* src,
-                               size_t length);
-
-  // Implements LinuxDumper::GetThreadInfoByIndex().
-  // Reads information about the |index|-th thread of |threads_|.
-  // Returns true on success. One must have called |ThreadsSuspend| first.
-  virtual bool GetThreadInfoByIndex(size_t index, ThreadInfo* info);
-
-  // Implements LinuxDumper::IsPostMortem().
-  // Always returns false to indicate this dumper performs a dump of
-  // a crashed process via ptrace.
-  virtual bool IsPostMortem() const;
-
-  // Implements LinuxDumper::ThreadsSuspend().
-  // Suspends all threads in the given process. Returns true on success.
-  virtual bool ThreadsSuspend();
-
-  // Implements LinuxDumper::ThreadsResume().
-  // Resumes all threads in the given process. Returns true on success.
-  virtual bool ThreadsResume();
-
- protected:
-  // Implements LinuxDumper::EnumerateThreads().
-  // Enumerates all threads of the given process into |threads_|.
-  virtual bool EnumerateThreads();
-
- private:
-  // Set to true if all threads of the crashed process are suspended.
-  bool threads_suspended_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_HANDLER_LINUX_PTRACE_DUMPER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.cc b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.cc
deleted file mode 100644
index 4b1e6f878..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.cc
+++ /dev/null
@@ -1,1367 +0,0 @@
-// Copyright (c) 2010, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// This code writes out minidump files:
-//   http://msdn.microsoft.com/en-us/library/ms680378(VS.85,loband).aspx
-//
-// Minidumps are a Microsoft format which Breakpad uses for recording crash
-// dumps. This code has to run in a compromised environment (the address space
-// may have received SIGSEGV), thus the following rules apply:
-//   * You may not enter the dynamic linker. This means that we cannot call
-//     any symbols in a shared library (inc libc). Because of this we replace
-//     libc functions in linux_libc_support.h.
-//   * You may not call syscalls via the libc wrappers. This rule is a subset
-//     of the first rule but it bears repeating. We have direct wrappers
-//     around the system calls in linux_syscall_support.h.
-//   * You may not malloc. There's an alternative allocator in memory.h and
-//     a canonical instance in the LinuxDumper object. We use the placement
-//     new form to allocate objects and we don't delete them.
-
-#include "client/linux/handler/minidump_descriptor.h"
-#include "client/linux/minidump_writer/minidump_writer.h"
-#include "client/minidump_file_writer-inl.h"
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <link.h>
-#include <stdio.h>
-#if defined(__ANDROID__)
-#include <sys/system_properties.h>
-#endif
-#include <sys/types.h>
-#include <sys/ucontext.h>
-#include <sys/user.h>
-#include <sys/utsname.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <algorithm>
-
-#include "client/linux/dump_writer_common/thread_info.h"
-#include "client/linux/dump_writer_common/ucontext_reader.h"
-#include "client/linux/handler/exception_handler.h"
-#include "client/linux/minidump_writer/cpu_set.h"
-#include "client/linux/minidump_writer/line_reader.h"
-#include "client/linux/minidump_writer/linux_dumper.h"
-#include "client/linux/minidump_writer/linux_ptrace_dumper.h"
-#include "client/linux/minidump_writer/proc_cpuinfo_reader.h"
-#include "client/minidump_file_writer.h"
-#include "common/linux/linux_libc_support.h"
-#include "common/minidump_type_helper.h"
-#include "google_breakpad/common/minidump_format.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace {
-
-using google_breakpad::AppMemoryList;
-using google_breakpad::ExceptionHandler;
-using google_breakpad::CpuSet;
-using google_breakpad::LineReader;
-using google_breakpad::LinuxDumper;
-using google_breakpad::LinuxPtraceDumper;
-using google_breakpad::MDTypeHelper;
-using google_breakpad::MappingEntry;
-using google_breakpad::MappingInfo;
-using google_breakpad::MappingList;
-using google_breakpad::MinidumpFileWriter;
-using google_breakpad::PageAllocator;
-using google_breakpad::ProcCpuInfoReader;
-using google_breakpad::RawContextCPU;
-using google_breakpad::ThreadInfo;
-using google_breakpad::TypedMDRVA;
-using google_breakpad::UContextReader;
-using google_breakpad::UntypedMDRVA;
-using google_breakpad::wasteful_vector;
-
-typedef MDTypeHelper<sizeof(void*)>::MDRawDebug MDRawDebug;
-typedef MDTypeHelper<sizeof(void*)>::MDRawLinkMap MDRawLinkMap;
-
-class MinidumpWriter {
- public:
-  // The following kLimit* constants are for when minidump_size_limit_ is set
-  // and the minidump size might exceed it.
-  //
-  // Estimate for how big each thread's stack will be (in bytes).
-  static const unsigned kLimitAverageThreadStackLength = 8 * 1024;
-  // Number of threads whose stack size we don't want to limit.  These base
-  // threads will simply be the first N threads returned by the dumper (although
-  // the crashing thread will never be limited).  Threads beyond this count are
-  // the extra threads.
-  static const unsigned kLimitBaseThreadCount = 20;
-  // Maximum stack size to dump for any extra thread (in bytes).
-  static const unsigned kLimitMaxExtraThreadStackLen = 2 * 1024;
-  // Make sure this number of additional bytes can fit in the minidump
-  // (exclude the stack data).
-  static const unsigned kLimitMinidumpFudgeFactor = 64 * 1024;
-
-  MinidumpWriter(const char* minidump_path,
-                 int minidump_fd,
-                 const ExceptionHandler::CrashContext* context,
-                 const MappingList& mappings,
-                 const AppMemoryList& appmem,
-                 LinuxDumper* dumper)
-      : fd_(minidump_fd),
-        path_(minidump_path),
-        ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-        float_state_(context ? &context->float_state : NULL),
-#endif
-        dumper_(dumper),
-        minidump_size_limit_(-1),
-        memory_blocks_(dumper_->allocator()),
-        mapping_list_(mappings),
-        app_memory_list_(appmem) {
-    // Assert there should be either a valid fd or a valid path, not both.
-    assert(fd_ != -1 || minidump_path);
-    assert(fd_ == -1 || !minidump_path);
-  }
-
-  bool Init() {
-    if (!dumper_->Init())
-      return false;
-
-    if (fd_ != -1)
-      minidump_writer_.SetFile(fd_);
-    else if (!minidump_writer_.Open(path_))
-      return false;
-
-    return dumper_->ThreadsSuspend() && dumper_->LateInit();
-  }
-
-  ~MinidumpWriter() {
-    // Don't close the file descriptor when it's been provided explicitly.
-    // Callers might still need to use it.
-    if (fd_ == -1)
-      minidump_writer_.Close();
-    dumper_->ThreadsResume();
-  }
-
-  bool Dump() {
-    // A minidump file contains a number of tagged streams. This is the number
-    // of stream which we write.
-    unsigned kNumWriters = 13;
-
-    TypedMDRVA<MDRawHeader> header(&minidump_writer_);
-    TypedMDRVA<MDRawDirectory> dir(&minidump_writer_);
-    if (!header.Allocate())
-      return false;
-    if (!dir.AllocateArray(kNumWriters))
-      return false;
-    my_memset(header.get(), 0, sizeof(MDRawHeader));
-
-    header.get()->signature = MD_HEADER_SIGNATURE;
-    header.get()->version = MD_HEADER_VERSION;
-    header.get()->time_date_stamp = time(NULL);
-    header.get()->stream_count = kNumWriters;
-    header.get()->stream_directory_rva = dir.position();
-
-    unsigned dir_index = 0;
-    MDRawDirectory dirent;
-
-    if (!WriteThreadListStream(&dirent))
-      return false;
-    dir.CopyIndex(dir_index++, &dirent);
-
-    if (!WriteMappings(&dirent))
-      return false;
-    dir.CopyIndex(dir_index++, &dirent);
-
-    if (!WriteAppMemory())
-      return false;
-
-    if (!WriteMemoryListStream(&dirent))
-      return false;
-    dir.CopyIndex(dir_index++, &dirent);
-
-    if (!WriteExceptionStream(&dirent))
-      return false;
-    dir.CopyIndex(dir_index++, &dirent);
-
-    if (!WriteSystemInfoStream(&dirent))
-      return false;
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_CPU_INFO;
-    if (!WriteFile(&dirent.location, "/proc/cpuinfo"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_PROC_STATUS;
-    if (!WriteProcFile(&dirent.location, GetCrashThread(), "status"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_LSB_RELEASE;
-    if (!WriteFile(&dirent.location, "/etc/lsb-release"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_CMD_LINE;
-    if (!WriteProcFile(&dirent.location, GetCrashThread(), "cmdline"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_ENVIRON;
-    if (!WriteProcFile(&dirent.location, GetCrashThread(), "environ"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_AUXV;
-    if (!WriteProcFile(&dirent.location, GetCrashThread(), "auxv"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_MAPS;
-    if (!WriteProcFile(&dirent.location, GetCrashThread(), "maps"))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    dirent.stream_type = MD_LINUX_DSO_DEBUG;
-    if (!WriteDSODebugStream(&dirent))
-      NullifyDirectoryEntry(&dirent);
-    dir.CopyIndex(dir_index++, &dirent);
-
-    // If you add more directory entries, don't forget to update kNumWriters,
-    // above.
-
-    dumper_->ThreadsResume();
-    return true;
-  }
-
-  bool FillThreadStack(MDRawThread* thread, uintptr_t stack_pointer,
-                       int max_stack_len, uint8_t** stack_copy) {
-    *stack_copy = NULL;
-    const void* stack;
-    size_t stack_len;
-    if (dumper_->GetStackInfo(&stack, &stack_len, stack_pointer)) {
-      UntypedMDRVA memory(&minidump_writer_);
-      if (max_stack_len >= 0 &&
-          stack_len > static_cast<unsigned int>(max_stack_len)) {
-        stack_len = max_stack_len;
-      }
-      if (!memory.Allocate(stack_len))
-        return false;
-      *stack_copy = reinterpret_cast<uint8_t*>(Alloc(stack_len));
-      dumper_->CopyFromProcess(*stack_copy, thread->thread_id, stack,
-                               stack_len);
-      memory.Copy(*stack_copy, stack_len);
-      thread->stack.start_of_memory_range =
-          reinterpret_cast<uintptr_t>(stack);
-      thread->stack.memory = memory.location();
-      memory_blocks_.push_back(thread->stack);
-    } else {
-      thread->stack.start_of_memory_range = stack_pointer;
-      thread->stack.memory.data_size = 0;
-      thread->stack.memory.rva = minidump_writer_.position();
-    }
-    return true;
-  }
-
-  // Write information about the threads.
-  bool WriteThreadListStream(MDRawDirectory* dirent) {
-    const unsigned num_threads = dumper_->threads().size();
-
-    TypedMDRVA<uint32_t> list(&minidump_writer_);
-    if (!list.AllocateObjectAndArray(num_threads, sizeof(MDRawThread)))
-      return false;
-
-    dirent->stream_type = MD_THREAD_LIST_STREAM;
-    dirent->location = list.location();
-
-    *list.get() = num_threads;
-
-    // If there's a minidump size limit, check if it might be exceeded.  Since
-    // most of the space is filled with stack data, just check against that.
-    // If this expects to exceed the limit, set extra_thread_stack_len such
-    // that any thread beyond the first kLimitBaseThreadCount threads will
-    // have only kLimitMaxExtraThreadStackLen bytes dumped.
-    int extra_thread_stack_len = -1;  // default to no maximum
-    if (minidump_size_limit_ >= 0) {
-      const unsigned estimated_total_stack_size = num_threads *
-          kLimitAverageThreadStackLength;
-      const off_t estimated_minidump_size = minidump_writer_.position() +
-          estimated_total_stack_size + kLimitMinidumpFudgeFactor;
-      if (estimated_minidump_size > minidump_size_limit_)
-        extra_thread_stack_len = kLimitMaxExtraThreadStackLen;
-    }
-
-    for (unsigned i = 0; i < num_threads; ++i) {
-      MDRawThread thread;
-      my_memset(&thread, 0, sizeof(thread));
-      thread.thread_id = dumper_->threads()[i];
-
-      // We have a different source of information for the crashing thread. If
-      // we used the actual state of the thread we would find it running in the
-      // signal handler with the alternative stack, which would be deeply
-      // unhelpful.
-      if (static_cast<pid_t>(thread.thread_id) == GetCrashThread() &&
-          ucontext_ &&
-          !dumper_->IsPostMortem()) {
-        uint8_t* stack_copy;
-        const uintptr_t stack_ptr = UContextReader::GetStackPointer(ucontext_);
-        if (!FillThreadStack(&thread, stack_ptr, -1, &stack_copy))
-          return false;
-
-        // Copy 256 bytes around crashing instruction pointer to minidump.
-        const size_t kIPMemorySize = 256;
-        uint64_t ip = UContextReader::GetInstructionPointer(ucontext_);
-        // Bound it to the upper and lower bounds of the memory map
-        // it's contained within. If it's not in mapped memory,
-        // don't bother trying to write it.
-        bool ip_is_mapped = false;
-        MDMemoryDescriptor ip_memory_d;
-        for (unsigned j = 0; j < dumper_->mappings().size(); ++j) {
-          const MappingInfo& mapping = *dumper_->mappings()[j];
-          if (ip >= mapping.start_addr &&
-              ip < mapping.start_addr + mapping.size) {
-            ip_is_mapped = true;
-            // Try to get 128 bytes before and after the IP, but
-            // settle for whatever's available.
-            ip_memory_d.start_of_memory_range =
-              std::max(mapping.start_addr,
-                       uintptr_t(ip - (kIPMemorySize / 2)));
-            uintptr_t end_of_range =
-              std::min(uintptr_t(ip + (kIPMemorySize / 2)),
-                       uintptr_t(mapping.start_addr + mapping.size));
-            ip_memory_d.memory.data_size =
-              end_of_range - ip_memory_d.start_of_memory_range;
-            break;
-          }
-        }
-
-        if (ip_is_mapped) {
-          UntypedMDRVA ip_memory(&minidump_writer_);
-          if (!ip_memory.Allocate(ip_memory_d.memory.data_size))
-            return false;
-          uint8_t* memory_copy =
-              reinterpret_cast<uint8_t*>(Alloc(ip_memory_d.memory.data_size));
-          dumper_->CopyFromProcess(
-              memory_copy,
-              thread.thread_id,
-              reinterpret_cast<void*>(ip_memory_d.start_of_memory_range),
-              ip_memory_d.memory.data_size);
-          ip_memory.Copy(memory_copy, ip_memory_d.memory.data_size);
-          ip_memory_d.memory = ip_memory.location();
-          memory_blocks_.push_back(ip_memory_d);
-        }
-
-        TypedMDRVA<RawContextCPU> cpu(&minidump_writer_);
-        if (!cpu.Allocate())
-          return false;
-        my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-        UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
-#else
-        UContextReader::FillCPUContext(cpu.get(), ucontext_);
-#endif
-        thread.thread_context = cpu.location();
-        crashing_thread_context_ = cpu.location();
-      } else {
-        ThreadInfo info;
-        if (!dumper_->GetThreadInfoByIndex(i, &info))
-          return false;
-
-        uint8_t* stack_copy;
-        int max_stack_len = -1;  // default to no maximum for this thread
-        if (minidump_size_limit_ >= 0 && i >= kLimitBaseThreadCount)
-          max_stack_len = extra_thread_stack_len;
-        if (!FillThreadStack(&thread, info.stack_pointer, max_stack_len,
-            &stack_copy))
-          return false;
-
-        TypedMDRVA<RawContextCPU> cpu(&minidump_writer_);
-        if (!cpu.Allocate())
-          return false;
-        my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-        info.FillCPUContext(cpu.get());
-        thread.thread_context = cpu.location();
-        if (dumper_->threads()[i] == GetCrashThread()) {
-          crashing_thread_context_ = cpu.location();
-          if (!dumper_->IsPostMortem()) {
-            // This is the crashing thread of a live process, but
-            // no context was provided, so set the crash address
-            // while the instruction pointer is already here.
-            dumper_->set_crash_address(info.GetInstructionPointer());
-          }
-        }
-      }
-
-      list.CopyIndexAfterObject(i, &thread, sizeof(thread));
-    }
-
-    return true;
-  }
-
-  // Write application-provided memory regions.
-  bool WriteAppMemory() {
-    for (AppMemoryList::const_iterator iter = app_memory_list_.begin();
-         iter != app_memory_list_.end();
-         ++iter) {
-      uint8_t* data_copy =
-        reinterpret_cast<uint8_t*>(dumper_->allocator()->Alloc(iter->length));
-      dumper_->CopyFromProcess(data_copy, GetCrashThread(), iter->ptr,
-                               iter->length);
-
-      UntypedMDRVA memory(&minidump_writer_);
-      if (!memory.Allocate(iter->length)) {
-        return false;
-      }
-      memory.Copy(data_copy, iter->length);
-      MDMemoryDescriptor desc;
-      desc.start_of_memory_range = reinterpret_cast<uintptr_t>(iter->ptr);
-      desc.memory = memory.location();
-      memory_blocks_.push_back(desc);
-    }
-
-    return true;
-  }
-
-  static bool ShouldIncludeMapping(const MappingInfo& mapping) {
-    if (mapping.name[0] == 0 ||  // only want modules with filenames.
-        // Only want to include one mapping per shared lib.
-        // Avoid filtering executable mappings.
-        (mapping.offset != 0 && !mapping.exec) ||
-        mapping.size < 4096) {  // too small to get a signature for.
-      return false;
-    }
-
-    return true;
-  }
-
-  // If there is caller-provided information about this mapping
-  // in the mapping_list_ list, return true. Otherwise, return false.
-  bool HaveMappingInfo(const MappingInfo& mapping) {
-    for (MappingList::const_iterator iter = mapping_list_.begin();
-         iter != mapping_list_.end();
-         ++iter) {
-      // Ignore any mappings that are wholly contained within
-      // mappings in the mapping_info_ list.
-      if (mapping.start_addr >= iter->first.start_addr &&
-          (mapping.start_addr + mapping.size) <=
-          (iter->first.start_addr + iter->first.size)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  // Write information about the mappings in effect. Because we are using the
-  // minidump format, the information about the mappings is pretty limited.
-  // Because of this, we also include the full, unparsed, /proc/$x/maps file in
-  // another stream in the file.
-  bool WriteMappings(MDRawDirectory* dirent) {
-    const unsigned num_mappings = dumper_->mappings().size();
-    unsigned num_output_mappings = mapping_list_.size();
-
-    for (unsigned i = 0; i < dumper_->mappings().size(); ++i) {
-      const MappingInfo& mapping = *dumper_->mappings()[i];
-      if (ShouldIncludeMapping(mapping) && !HaveMappingInfo(mapping))
-        num_output_mappings++;
-    }
-
-    TypedMDRVA<uint32_t> list(&minidump_writer_);
-    if (num_output_mappings) {
-      if (!list.AllocateObjectAndArray(num_output_mappings, MD_MODULE_SIZE))
-        return false;
-    } else {
-      // Still create the module list stream, although it will have zero
-      // modules.
-      if (!list.Allocate())
-        return false;
-    }
-
-    dirent->stream_type = MD_MODULE_LIST_STREAM;
-    dirent->location = list.location();
-    *list.get() = num_output_mappings;
-
-    // First write all the mappings from the dumper
-    unsigned int j = 0;
-    for (unsigned i = 0; i < num_mappings; ++i) {
-      const MappingInfo& mapping = *dumper_->mappings()[i];
-      if (!ShouldIncludeMapping(mapping) || HaveMappingInfo(mapping))
-        continue;
-
-      MDRawModule mod;
-      if (!FillRawModule(mapping, true, i, mod, NULL))
-        return false;
-      list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
-    }
-    // Next write all the mappings provided by the caller
-    for (MappingList::const_iterator iter = mapping_list_.begin();
-         iter != mapping_list_.end();
-         ++iter) {
-      MDRawModule mod;
-      if (!FillRawModule(iter->first, false, 0, mod, iter->second))
-        return false;
-      list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
-    }
-
-    return true;
-  }
-
-  // Fill the MDRawModule |mod| with information about the provided
-  // |mapping|. If |identifier| is non-NULL, use it instead of calculating
-  // a file ID from the mapping.
-  bool FillRawModule(const MappingInfo& mapping,
-                     bool member,
-                     unsigned int mapping_id,
-                     MDRawModule& mod,
-                     const uint8_t* identifier) {
-    my_memset(&mod, 0, MD_MODULE_SIZE);
-
-    mod.base_of_image = mapping.start_addr;
-    mod.size_of_image = mapping.size;
-
-    uint8_t cv_buf[MDCVInfoPDB70_minsize + NAME_MAX];
-    uint8_t* cv_ptr = cv_buf;
-
-    const uint32_t cv_signature = MD_CVINFOPDB70_SIGNATURE;
-    my_memcpy(cv_ptr, &cv_signature, sizeof(cv_signature));
-    cv_ptr += sizeof(cv_signature);
-    uint8_t* signature = cv_ptr;
-    cv_ptr += sizeof(MDGUID);
-    if (identifier) {
-      // GUID was provided by caller.
-      my_memcpy(signature, identifier, sizeof(MDGUID));
-    } else {
-      // Note: ElfFileIdentifierForMapping() can manipulate the |mapping.name|.
-      dumper_->ElfFileIdentifierForMapping(mapping, member,
-                                           mapping_id, signature);
-    }
-    my_memset(cv_ptr, 0, sizeof(uint32_t));  // Set age to 0 on Linux.
-    cv_ptr += sizeof(uint32_t);
-
-    char file_name[NAME_MAX];
-    char file_path[NAME_MAX];
-    LinuxDumper::GetMappingEffectiveNameAndPath(
-        mapping, file_path, sizeof(file_path), file_name, sizeof(file_name));
-
-    const size_t file_name_len = my_strlen(file_name);
-    UntypedMDRVA cv(&minidump_writer_);
-    if (!cv.Allocate(MDCVInfoPDB70_minsize + file_name_len + 1))
-      return false;
-
-    // Write pdb_file_name
-    my_memcpy(cv_ptr, file_name, file_name_len + 1);
-    cv.Copy(cv_buf, MDCVInfoPDB70_minsize + file_name_len + 1);
-
-    mod.cv_record = cv.location();
-
-    MDLocationDescriptor ld;
-    if (!minidump_writer_.WriteString(file_path, my_strlen(file_path), &ld))
-      return false;
-    mod.module_name_rva = ld.rva;
-    return true;
-  }
-
-  bool WriteMemoryListStream(MDRawDirectory* dirent) {
-    TypedMDRVA<uint32_t> list(&minidump_writer_);
-    if (memory_blocks_.size()) {
-      if (!list.AllocateObjectAndArray(memory_blocks_.size(),
-                                       sizeof(MDMemoryDescriptor)))
-        return false;
-    } else {
-      // Still create the memory list stream, although it will have zero
-      // memory blocks.
-      if (!list.Allocate())
-        return false;
-    }
-
-    dirent->stream_type = MD_MEMORY_LIST_STREAM;
-    dirent->location = list.location();
-
-    *list.get() = memory_blocks_.size();
-
-    for (size_t i = 0; i < memory_blocks_.size(); ++i) {
-      list.CopyIndexAfterObject(i, &memory_blocks_[i],
-                                sizeof(MDMemoryDescriptor));
-    }
-    return true;
-  }
-
-  bool WriteExceptionStream(MDRawDirectory* dirent) {
-    TypedMDRVA<MDRawExceptionStream> exc(&minidump_writer_);
-    if (!exc.Allocate())
-      return false;
-    my_memset(exc.get(), 0, sizeof(MDRawExceptionStream));
-
-    dirent->stream_type = MD_EXCEPTION_STREAM;
-    dirent->location = exc.location();
-
-    exc.get()->thread_id = GetCrashThread();
-    exc.get()->exception_record.exception_code = dumper_->crash_signal();
-    exc.get()->exception_record.exception_address = dumper_->crash_address();
-    exc.get()->thread_context = crashing_thread_context_;
-
-    return true;
-  }
-
-  bool WriteSystemInfoStream(MDRawDirectory* dirent) {
-    TypedMDRVA<MDRawSystemInfo> si(&minidump_writer_);
-    if (!si.Allocate())
-      return false;
-    my_memset(si.get(), 0, sizeof(MDRawSystemInfo));
-
-    dirent->stream_type = MD_SYSTEM_INFO_STREAM;
-    dirent->location = si.location();
-
-    WriteCPUInformation(si.get());
-    WriteOSInformation(si.get());
-
-    return true;
-  }
-
-  bool WriteDSODebugStream(MDRawDirectory* dirent) {
-    ElfW(Phdr)* phdr = reinterpret_cast<ElfW(Phdr) *>(dumper_->auxv()[AT_PHDR]);
-    char* base;
-    int phnum = dumper_->auxv()[AT_PHNUM];
-    if (!phnum || !phdr)
-      return false;
-
-    // Assume the program base is at the beginning of the same page as the PHDR
-    base = reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(phdr) & ~0xfff);
-
-    // Search for the program PT_DYNAMIC segment
-    ElfW(Addr) dyn_addr = 0;
-    for (; phnum >= 0; phnum--, phdr++) {
-      ElfW(Phdr) ph;
-      if (!dumper_->CopyFromProcess(&ph, GetCrashThread(), phdr, sizeof(ph)))
-        return false;
-
-      // Adjust base address with the virtual address of the PT_LOAD segment
-      // corresponding to offset 0
-      if (ph.p_type == PT_LOAD && ph.p_offset == 0) {
-        base -= ph.p_vaddr;
-      }
-      if (ph.p_type == PT_DYNAMIC) {
-        dyn_addr = ph.p_vaddr;
-      }
-    }
-    if (!dyn_addr)
-      return false;
-
-    ElfW(Dyn) *dynamic = reinterpret_cast<ElfW(Dyn) *>(dyn_addr + base);
-
-    // The dynamic linker makes information available that helps gdb find all
-    // DSOs loaded into the program. If this information is indeed available,
-    // dump it to a MD_LINUX_DSO_DEBUG stream.
-    struct r_debug* r_debug = NULL;
-    uint32_t dynamic_length = 0;
-
-    for (int i = 0; ; ++i) {
-      ElfW(Dyn) dyn;
-      dynamic_length += sizeof(dyn);
-      if (!dumper_->CopyFromProcess(&dyn, GetCrashThread(), dynamic + i,
-                                    sizeof(dyn))) {
-        return false;
-      }
-
-#ifdef __mips__
-      if (dyn.d_tag == DT_MIPS_RLD_MAP) {
-        r_debug = reinterpret_cast<struct r_debug*>(dyn.d_un.d_ptr);
-        continue;
-      }
-#else
-      if (dyn.d_tag == DT_DEBUG) {
-        r_debug = reinterpret_cast<struct r_debug*>(dyn.d_un.d_ptr);
-        continue;
-      }
-#endif
-      else if (dyn.d_tag == DT_NULL) {
-        break;
-      }
-    }
-
-    // The "r_map" field of that r_debug struct contains a linked list of all
-    // loaded DSOs.
-    // Our list of DSOs potentially is different from the ones in the crashing
-    // process. So, we have to be careful to never dereference pointers
-    // directly. Instead, we use CopyFromProcess() everywhere.
-    // See <link.h> for a more detailed discussion of the how the dynamic
-    // loader communicates with debuggers.
-
-    // Count the number of loaded DSOs
-    int dso_count = 0;
-    struct r_debug debug_entry;
-    if (!dumper_->CopyFromProcess(&debug_entry, GetCrashThread(), r_debug,
-                                  sizeof(debug_entry))) {
-      return false;
-    }
-    for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
-      struct link_map map;
-      if (!dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map)))
-        return false;
-
-      ptr = map.l_next;
-      dso_count++;
-    }
-
-    MDRVA linkmap_rva = minidump_writer_.kInvalidMDRVA;
-    if (dso_count > 0) {
-      // If we have at least one DSO, create an array of MDRawLinkMap
-      // entries in the minidump file.
-      TypedMDRVA<MDRawLinkMap> linkmap(&minidump_writer_);
-      if (!linkmap.AllocateArray(dso_count))
-        return false;
-      linkmap_rva = linkmap.location().rva;
-      int idx = 0;
-
-      // Iterate over DSOs and write their information to mini dump
-      for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
-        struct link_map map;
-        if (!dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map)))
-          return  false;
-
-        ptr = map.l_next;
-        char filename[257] = { 0 };
-        if (map.l_name) {
-          dumper_->CopyFromProcess(filename, GetCrashThread(), map.l_name,
-                                   sizeof(filename) - 1);
-        }
-        MDLocationDescriptor location;
-        if (!minidump_writer_.WriteString(filename, 0, &location))
-          return false;
-        MDRawLinkMap entry;
-        entry.name = location.rva;
-        entry.addr = map.l_addr;
-        entry.ld = reinterpret_cast<uintptr_t>(map.l_ld);
-        linkmap.CopyIndex(idx++, &entry);
-      }
-    }
-
-    // Write MD_LINUX_DSO_DEBUG record
-    TypedMDRVA<MDRawDebug> debug(&minidump_writer_);
-    if (!debug.AllocateObjectAndArray(1, dynamic_length))
-      return false;
-    my_memset(debug.get(), 0, sizeof(MDRawDebug));
-    dirent->stream_type = MD_LINUX_DSO_DEBUG;
-    dirent->location = debug.location();
-
-    debug.get()->version = debug_entry.r_version;
-    debug.get()->map = linkmap_rva;
-    debug.get()->dso_count = dso_count;
-    debug.get()->brk = debug_entry.r_brk;
-    debug.get()->ldbase = debug_entry.r_ldbase;
-    debug.get()->dynamic = reinterpret_cast<uintptr_t>(dynamic);
-
-    wasteful_vector<char> dso_debug_data(dumper_->allocator(), dynamic_length);
-    // The passed-in size to the constructor (above) is only a hint.
-    // Must call .resize() to do actual initialization of the elements.
-    dso_debug_data.resize(dynamic_length);
-    dumper_->CopyFromProcess(&dso_debug_data[0], GetCrashThread(), dynamic,
-                             dynamic_length);
-    debug.CopyIndexAfterObject(0, &dso_debug_data[0], dynamic_length);
-
-    return true;
-  }
-
-  void set_minidump_size_limit(off_t limit) { minidump_size_limit_ = limit; }
-
- private:
-  void* Alloc(unsigned bytes) {
-    return dumper_->allocator()->Alloc(bytes);
-  }
-
-  pid_t GetCrashThread() const {
-    return dumper_->crash_thread();
-  }
-
-  void NullifyDirectoryEntry(MDRawDirectory* dirent) {
-    dirent->stream_type = 0;
-    dirent->location.data_size = 0;
-    dirent->location.rva = 0;
-  }
-
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
-  bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
-    char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
-    static const char vendor_id_name[] = "vendor_id";
-
-    struct CpuInfoEntry {
-      const char* info_name;
-      int value;
-      bool found;
-    } cpu_info_table[] = {
-      { "processor", -1, false },
-#if defined(__i386__) || defined(__x86_64__)
-      { "model", 0, false },
-      { "stepping",  0, false },
-      { "cpu family", 0, false },
-#endif
-    };
-
-    // processor_architecture should always be set, do this first
-    sys_info->processor_architecture =
-#if defined(__mips__)
-        MD_CPU_ARCHITECTURE_MIPS;
-#elif defined(__i386__)
-        MD_CPU_ARCHITECTURE_X86;
-#else
-        MD_CPU_ARCHITECTURE_AMD64;
-#endif
-
-    const int fd = sys_open("/proc/cpuinfo", O_RDONLY, 0);
-    if (fd < 0)
-      return false;
-
-    {
-      PageAllocator allocator;
-      ProcCpuInfoReader* const reader = new(allocator) ProcCpuInfoReader(fd);
-      const char* field;
-      while (reader->GetNextField(&field)) {
-        for (size_t i = 0;
-             i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
-             i++) {
-          CpuInfoEntry* entry = &cpu_info_table[i];
-          if (i > 0 && entry->found) {
-            // except for the 'processor' field, ignore repeated values.
-            continue;
-          }
-          if (!my_strcmp(field, entry->info_name)) {
-            size_t value_len;
-            const char* value = reader->GetValueAndLen(&value_len);
-            if (value_len == 0)
-              continue;
-
-            uintptr_t val;
-            if (my_read_decimal_ptr(&val, value) == value)
-              continue;
-
-            entry->value = static_cast<int>(val);
-            entry->found = true;
-          }
-        }
-
-        // special case for vendor_id
-        if (!my_strcmp(field, vendor_id_name)) {
-          size_t value_len;
-          const char* value = reader->GetValueAndLen(&value_len);
-          if (value_len > 0)
-            my_strlcpy(vendor_id, value, sizeof(vendor_id));
-        }
-      }
-      sys_close(fd);
-    }
-
-    // make sure we got everything we wanted
-    for (size_t i = 0;
-         i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
-         i++) {
-      if (!cpu_info_table[i].found) {
-        return false;
-      }
-    }
-    // cpu_info_table[0] holds the last cpu id listed in /proc/cpuinfo,
-    // assuming this is the highest id, change it to the number of CPUs
-    // by adding one.
-    cpu_info_table[0].value++;
-
-    sys_info->number_of_processors = cpu_info_table[0].value;
-#if defined(__i386__) || defined(__x86_64__)
-    sys_info->processor_level      = cpu_info_table[3].value;
-    sys_info->processor_revision   = cpu_info_table[1].value << 8 |
-                                     cpu_info_table[2].value;
-#endif
-
-    if (vendor_id[0] != '\0') {
-      my_memcpy(sys_info->cpu.x86_cpu_info.vendor_id, vendor_id,
-                sizeof(sys_info->cpu.x86_cpu_info.vendor_id));
-    }
-    return true;
-  }
-#elif defined(__arm__) || defined(__aarch64__)
-  bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
-    // The CPUID value is broken up in several entries in /proc/cpuinfo.
-    // This table is used to rebuild it from the entries.
-    const struct CpuIdEntry {
-      const char* field;
-      char        format;
-      char        bit_lshift;
-      char        bit_length;
-    } cpu_id_entries[] = {
-      { "CPU implementer", 'x', 24, 8 },
-      { "CPU variant", 'x', 20, 4 },
-      { "CPU part", 'x', 4, 12 },
-      { "CPU revision", 'd', 0, 4 },
-    };
-
-    // The ELF hwcaps are listed in the "Features" entry as textual tags.
-    // This table is used to rebuild them.
-    const struct CpuFeaturesEntry {
-      const char* tag;
-      uint32_t hwcaps;
-    } cpu_features_entries[] = {
-#if defined(__arm__)
-      { "swp",  MD_CPU_ARM_ELF_HWCAP_SWP },
-      { "half", MD_CPU_ARM_ELF_HWCAP_HALF },
-      { "thumb", MD_CPU_ARM_ELF_HWCAP_THUMB },
-      { "26bit", MD_CPU_ARM_ELF_HWCAP_26BIT },
-      { "fastmult", MD_CPU_ARM_ELF_HWCAP_FAST_MULT },
-      { "fpa", MD_CPU_ARM_ELF_HWCAP_FPA },
-      { "vfp", MD_CPU_ARM_ELF_HWCAP_VFP },
-      { "edsp", MD_CPU_ARM_ELF_HWCAP_EDSP },
-      { "java", MD_CPU_ARM_ELF_HWCAP_JAVA },
-      { "iwmmxt", MD_CPU_ARM_ELF_HWCAP_IWMMXT },
-      { "crunch", MD_CPU_ARM_ELF_HWCAP_CRUNCH },
-      { "thumbee", MD_CPU_ARM_ELF_HWCAP_THUMBEE },
-      { "neon", MD_CPU_ARM_ELF_HWCAP_NEON },
-      { "vfpv3", MD_CPU_ARM_ELF_HWCAP_VFPv3 },
-      { "vfpv3d16", MD_CPU_ARM_ELF_HWCAP_VFPv3D16 },
-      { "tls", MD_CPU_ARM_ELF_HWCAP_TLS },
-      { "vfpv4", MD_CPU_ARM_ELF_HWCAP_VFPv4 },
-      { "idiva", MD_CPU_ARM_ELF_HWCAP_IDIVA },
-      { "idivt", MD_CPU_ARM_ELF_HWCAP_IDIVT },
-      { "idiv", MD_CPU_ARM_ELF_HWCAP_IDIVA | MD_CPU_ARM_ELF_HWCAP_IDIVT },
-#elif defined(__aarch64__)
-      // No hwcaps on aarch64.
-#endif
-    };
-
-    // processor_architecture should always be set, do this first
-    sys_info->processor_architecture =
-#if defined(__aarch64__)
-        MD_CPU_ARCHITECTURE_ARM64;
-#else
-        MD_CPU_ARCHITECTURE_ARM;
-#endif
-
-    // /proc/cpuinfo is not readable under various sandboxed environments
-    // (e.g. Android services with the android:isolatedProcess attribute)
-    // prepare for this by setting default values now, which will be
-    // returned when this happens.
-    //
-    // Note: Bogus values are used to distinguish between failures (to
-    //       read /sys and /proc files) and really badly configured kernels.
-    sys_info->number_of_processors = 0;
-    sys_info->processor_level = 1U;  // There is no ARMv1
-    sys_info->processor_revision = 42;
-    sys_info->cpu.arm_cpu_info.cpuid = 0;
-    sys_info->cpu.arm_cpu_info.elf_hwcaps = 0;
-
-    // Counting the number of CPUs involves parsing two sysfs files,
-    // because the content of /proc/cpuinfo will only mirror the number
-    // of 'online' cores, and thus will vary with time.
-    // See http://www.kernel.org/doc/Documentation/cputopology.txt
-    {
-      CpuSet cpus_present;
-      CpuSet cpus_possible;
-
-      int fd = sys_open("/sys/devices/system/cpu/present", O_RDONLY, 0);
-      if (fd >= 0) {
-        cpus_present.ParseSysFile(fd);
-        sys_close(fd);
-
-        fd = sys_open("/sys/devices/system/cpu/possible", O_RDONLY, 0);
-        if (fd >= 0) {
-          cpus_possible.ParseSysFile(fd);
-          sys_close(fd);
-
-          cpus_present.IntersectWith(cpus_possible);
-          int cpu_count = cpus_present.GetCount();
-          if (cpu_count > 255)
-            cpu_count = 255;
-          sys_info->number_of_processors = static_cast<uint8_t>(cpu_count);
-        }
-      }
-    }
-
-    // Parse /proc/cpuinfo to reconstruct the CPUID value, as well
-    // as the ELF hwcaps field. For the latter, it would be easier to
-    // read /proc/self/auxv but unfortunately, this file is not always
-    // readable from regular Android applications on later versions
-    // (>= 4.1) of the Android platform.
-    const int fd = sys_open("/proc/cpuinfo", O_RDONLY, 0);
-    if (fd < 0) {
-      // Do not return false here to allow the minidump generation
-      // to happen properly.
-      return true;
-    }
-
-    {
-      PageAllocator allocator;
-      ProcCpuInfoReader* const reader =
-          new(allocator) ProcCpuInfoReader(fd);
-      const char* field;
-      while (reader->GetNextField(&field)) {
-        for (size_t i = 0;
-             i < sizeof(cpu_id_entries)/sizeof(cpu_id_entries[0]);
-             ++i) {
-          const CpuIdEntry* entry = &cpu_id_entries[i];
-          if (my_strcmp(entry->field, field) != 0)
-            continue;
-          uintptr_t result = 0;
-          const char* value = reader->GetValue();
-          const char* p = value;
-          if (value[0] == '0' && value[1] == 'x') {
-            p = my_read_hex_ptr(&result, value+2);
-          } else if (entry->format == 'x') {
-            p = my_read_hex_ptr(&result, value);
-          } else {
-            p = my_read_decimal_ptr(&result, value);
-          }
-          if (p == value)
-            continue;
-
-          result &= (1U << entry->bit_length)-1;
-          result <<= entry->bit_lshift;
-          sys_info->cpu.arm_cpu_info.cpuid |=
-              static_cast<uint32_t>(result);
-        }
-#if defined(__arm__)
-        // Get the architecture version from the "Processor" field.
-        // Note that it is also available in the "CPU architecture" field,
-        // however, some existing kernels are misconfigured and will report
-        // invalid values here (e.g. 6, while the CPU is ARMv7-A based).
-        // The "Processor" field doesn't have this issue.
-        if (!my_strcmp(field, "Processor")) {
-          size_t value_len;
-          const char* value = reader->GetValueAndLen(&value_len);
-          // Expected format: <text> (v<level><endian>)
-          // Where <text> is some text like "ARMv7 Processor rev 2"
-          // and <level> is a decimal corresponding to the ARM
-          // architecture number. <endian> is either 'l' or 'b'
-          // and corresponds to the endianess, it is ignored here.
-          while (value_len > 0 && my_isspace(value[value_len-1]))
-            value_len--;
-
-          size_t nn = value_len;
-          while (nn > 0 && value[nn-1] != '(')
-            nn--;
-          if (nn > 0 && value[nn] == 'v') {
-            uintptr_t arch_level = 5;
-            my_read_decimal_ptr(&arch_level, value + nn + 1);
-            sys_info->processor_level = static_cast<uint16_t>(arch_level);
-          }
-        }
-#elif defined(__aarch64__)
-        // The aarch64 architecture does not provide the architecture level
-        // in the Processor field, so we instead check the "CPU architecture"
-        // field.
-        if (!my_strcmp(field, "CPU architecture")) {
-          uintptr_t arch_level = 0;
-          const char* value = reader->GetValue();
-          const char* p = value;
-          p = my_read_decimal_ptr(&arch_level, value);
-          if (p == value)
-            continue;
-          sys_info->processor_level = static_cast<uint16_t>(arch_level);
-        }
-#endif
-        // Rebuild the ELF hwcaps from the 'Features' field.
-        if (!my_strcmp(field, "Features")) {
-          size_t value_len;
-          const char* value = reader->GetValueAndLen(&value_len);
-
-          // Parse each space-separated tag.
-          while (value_len > 0) {
-            const char* tag = value;
-            size_t tag_len = value_len;
-            const char* p = my_strchr(tag, ' ');
-            if (p != NULL) {
-              tag_len = static_cast<size_t>(p - tag);
-              value += tag_len + 1;
-              value_len -= tag_len + 1;
-            } else {
-              tag_len = strlen(tag);
-              value_len = 0;
-            }
-            for (size_t i = 0;
-                i < sizeof(cpu_features_entries)/
-                    sizeof(cpu_features_entries[0]);
-                ++i) {
-              const CpuFeaturesEntry* entry = &cpu_features_entries[i];
-              if (tag_len == strlen(entry->tag) &&
-                  !memcmp(tag, entry->tag, tag_len)) {
-                sys_info->cpu.arm_cpu_info.elf_hwcaps |= entry->hwcaps;
-                break;
-              }
-            }
-          }
-        }
-      }
-      sys_close(fd);
-    }
-
-    return true;
-  }
-#else
-#  error "Unsupported CPU"
-#endif
-
-  bool WriteFile(MDLocationDescriptor* result, const char* filename) {
-    const int fd = sys_open(filename, O_RDONLY, 0);
-    if (fd < 0)
-      return false;
-
-    // We can't stat the files because several of the files that we want to
-    // read are kernel seqfiles, which always have a length of zero. So we have
-    // to read as much as we can into a buffer.
-    static const unsigned kBufSize = 1024 - 2*sizeof(void*);
-    struct Buffers {
-      Buffers* next;
-      size_t len;
-      uint8_t data[kBufSize];
-    } *buffers = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
-    buffers->next = NULL;
-    buffers->len = 0;
-
-    size_t total = 0;
-    for (Buffers* bufptr = buffers;;) {
-      ssize_t r;
-      do {
-        r = sys_read(fd, &bufptr->data[bufptr->len], kBufSize - bufptr->len);
-      } while (r == -1 && errno == EINTR);
-
-      if (r < 1)
-        break;
-
-      total += r;
-      bufptr->len += r;
-      if (bufptr->len == kBufSize) {
-        bufptr->next = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
-        bufptr = bufptr->next;
-        bufptr->next = NULL;
-        bufptr->len = 0;
-      }
-    }
-    sys_close(fd);
-
-    if (!total)
-      return false;
-
-    UntypedMDRVA memory(&minidump_writer_);
-    if (!memory.Allocate(total))
-      return false;
-    for (MDRVA pos = memory.position(); buffers; buffers = buffers->next) {
-      // Check for special case of a zero-length buffer.  This should only
-      // occur if a file's size happens to be a multiple of the buffer's
-      // size, in which case the final sys_read() will have resulted in
-      // zero bytes being read after the final buffer was just allocated.
-      if (buffers->len == 0) {
-        // This can only occur with final buffer.
-        assert(buffers->next == NULL);
-        continue;
-      }
-      memory.Copy(pos, &buffers->data, buffers->len);
-      pos += buffers->len;
-    }
-    *result = memory.location();
-    return true;
-  }
-
-  bool WriteOSInformation(MDRawSystemInfo* sys_info) {
-#if defined(__ANDROID__)
-    sys_info->platform_id = MD_OS_ANDROID;
-#else
-    sys_info->platform_id = MD_OS_LINUX;
-#endif
-
-    struct utsname uts;
-    if (uname(&uts))
-      return false;
-
-    static const size_t buf_len = 512;
-    char buf[buf_len] = {0};
-    size_t space_left = buf_len - 1;
-    const char* info_table[] = {
-      uts.sysname,
-      uts.release,
-      uts.version,
-      uts.machine,
-      NULL
-    };
-    bool first_item = true;
-    for (const char** cur_info = info_table; *cur_info; cur_info++) {
-      static const char separator[] = " ";
-      size_t separator_len = sizeof(separator) - 1;
-      size_t info_len = my_strlen(*cur_info);
-      if (info_len == 0)
-        continue;
-
-      if (space_left < info_len + (first_item ? 0 : separator_len))
-        break;
-
-      if (!first_item) {
-        my_strlcat(buf, separator, sizeof(buf));
-        space_left -= separator_len;
-      }
-
-      first_item = false;
-      my_strlcat(buf, *cur_info, sizeof(buf));
-      space_left -= info_len;
-    }
-
-    MDLocationDescriptor location;
-    if (!minidump_writer_.WriteString(buf, 0, &location))
-      return false;
-    sys_info->csd_version_rva = location.rva;
-
-    return true;
-  }
-
-  bool WriteProcFile(MDLocationDescriptor* result, pid_t pid,
-                     const char* filename) {
-    char buf[NAME_MAX];
-    if (!dumper_->BuildProcPath(buf, pid, filename))
-      return false;
-    return WriteFile(result, buf);
-  }
-
-  // Only one of the 2 member variables below should be set to a valid value.
-  const int fd_;  // File descriptor where the minidum should be written.
-  const char* path_;  // Path to the file where the minidum should be written.
-
-  const struct ucontext* const ucontext_;  // also from the signal handler
-#if !defined(__ARM_EABI__) && !defined(__mips__)
-  const google_breakpad::fpstate_t* const float_state_;  // ditto
-#endif
-  LinuxDumper* dumper_;
-  MinidumpFileWriter minidump_writer_;
-  off_t minidump_size_limit_;
-  MDLocationDescriptor crashing_thread_context_;
-  // Blocks of memory written to the dump. These are all currently
-  // written while writing the thread list stream, but saved here
-  // so a memory list stream can be written afterwards.
-  wasteful_vector<MDMemoryDescriptor> memory_blocks_;
-  // Additional information about some mappings provided by the caller.
-  const MappingList& mapping_list_;
-  // Additional memory regions to be included in the dump,
-  // provided by the caller.
-  const AppMemoryList& app_memory_list_;
-};
-
-
-bool WriteMinidumpImpl(const char* minidump_path,
-                       int minidump_fd,
-                       off_t minidump_size_limit,
-                       pid_t crashing_process,
-                       const void* blob, size_t blob_size,
-                       const MappingList& mappings,
-                       const AppMemoryList& appmem) {
-  LinuxPtraceDumper dumper(crashing_process);
-  const ExceptionHandler::CrashContext* context = NULL;
-  if (blob) {
-    if (blob_size != sizeof(ExceptionHandler::CrashContext))
-      return false;
-    context = reinterpret_cast<const ExceptionHandler::CrashContext*>(blob);
-    dumper.set_crash_address(
-        reinterpret_cast<uintptr_t>(context->siginfo.si_addr));
-    dumper.set_crash_signal(context->siginfo.si_signo);
-    dumper.set_crash_thread(context->tid);
-  }
-  MinidumpWriter writer(minidump_path, minidump_fd, context, mappings,
-                        appmem, &dumper);
-  // Set desired limit for file size of minidump (-1 means no limit).
-  writer.set_minidump_size_limit(minidump_size_limit);
-  if (!writer.Init())
-    return false;
-  return writer.Dump();
-}
-
-}  // namespace
-
-namespace google_breakpad {
-
-bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size) {
-  return WriteMinidumpImpl(minidump_path, -1, -1,
-                           crashing_process, blob, blob_size,
-                           MappingList(), AppMemoryList());
-}
-
-bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size) {
-  return WriteMinidumpImpl(NULL, minidump_fd, -1,
-                           crashing_process, blob, blob_size,
-                           MappingList(), AppMemoryList());
-}
-
-bool WriteMinidump(const char* minidump_path, pid_t process,
-                   pid_t process_blamed_thread) {
-  LinuxPtraceDumper dumper(process);
-  // MinidumpWriter will set crash address
-  dumper.set_crash_signal(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED);
-  dumper.set_crash_thread(process_blamed_thread);
-  MinidumpWriter writer(minidump_path, -1, NULL, MappingList(),
-                        AppMemoryList(), &dumper);
-  if (!writer.Init())
-    return false;
-  return writer.Dump();
-}
-
-bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appmem) {
-  return WriteMinidumpImpl(minidump_path, -1, -1, crashing_process,
-                           blob, blob_size,
-                           mappings, appmem);
-}
-
-bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appmem) {
-  return WriteMinidumpImpl(NULL, minidump_fd, -1, crashing_process,
-                           blob, blob_size,
-                           mappings, appmem);
-}
-
-bool WriteMinidump(const char* minidump_path, off_t minidump_size_limit,
-                   pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appmem) {
-  return WriteMinidumpImpl(minidump_path, -1, minidump_size_limit,
-                           crashing_process, blob, blob_size,
-                           mappings, appmem);
-}
-
-bool WriteMinidump(int minidump_fd, off_t minidump_size_limit,
-                   pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appmem) {
-  return WriteMinidumpImpl(NULL, minidump_fd, minidump_size_limit,
-                           crashing_process, blob, blob_size,
-                           mappings, appmem);
-}
-
-bool WriteMinidump(const char* filename,
-                   const MappingList& mappings,
-                   const AppMemoryList& appmem,
-                   LinuxDumper* dumper) {
-  MinidumpWriter writer(filename, -1, NULL, mappings, appmem, dumper);
-  if (!writer.Init())
-    return false;
-  return writer.Dump();
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.h
deleted file mode 100644
index d13fb120b..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/minidump_writer.h
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright (c) 2009, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_MINIDUMP_WRITER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_MINIDUMP_WRITER_H_
-
-#include <stdint.h>
-#include <sys/types.h>
-#include <sys/ucontext.h>
-#include <unistd.h>
-
-#include <list>
-#include <utility>
-
-#include "client/linux/minidump_writer/linux_dumper.h"
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-class ExceptionHandler;
-
-#if defined(__aarch64__)
-typedef struct fpsimd_context fpstate_t;
-#elif !defined(__ARM_EABI__) && !defined(__mips__)
-typedef struct _libc_fpstate fpstate_t;
-#endif
-
-// These entries store a list of memory regions that the client wants included
-// in the minidump.
-struct AppMemory {
-  void* ptr;
-  size_t length;
-
-  bool operator==(const struct AppMemory& other) const {
-    return ptr == other.ptr;
-  }
-
-  bool operator==(const void* other) const {
-    return ptr == other;
-  }
-};
-typedef std::list<AppMemory> AppMemoryList;
-
-// Writes a minidump to the filesystem. These functions do not malloc nor use
-// libc functions which may. Thus, it can be used in contexts where the state
-// of the heap may be corrupt.
-//   minidump_path: the path to the file to write to. This is opened O_EXCL and
-//     fails open fails.
-//   crashing_process: the pid of the crashing process. This must be trusted.
-//   blob: a blob of data from the crashing process. See exception_handler.h
-//   blob_size: the length of |blob|, in bytes
-//
-// Returns true iff successful.
-bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size);
-// Same as above but takes an open file descriptor instead of a path.
-bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size);
-
-// Alternate form of WriteMinidump() that works with processes that
-// are not expected to have crashed.  If |process_blamed_thread| is
-// meaningful, it will be the one from which a crash signature is
-// extracted.  It is not expected that this function will be called
-// from a compromised context, but it is safe to do so.
-bool WriteMinidump(const char* minidump_path, pid_t process,
-                   pid_t process_blamed_thread);
-
-// These overloads also allow passing a list of known mappings and
-// a list of additional memory regions to be included in the minidump.
-bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appdata);
-bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appdata);
-
-// These overloads also allow passing a file size limit for the minidump.
-bool WriteMinidump(const char* minidump_path, off_t minidump_size_limit,
-                   pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appdata);
-bool WriteMinidump(int minidump_fd, off_t minidump_size_limit,
-                   pid_t crashing_process,
-                   const void* blob, size_t blob_size,
-                   const MappingList& mappings,
-                   const AppMemoryList& appdata);
-
-bool WriteMinidump(const char* filename,
-                   const MappingList& mappings,
-                   const AppMemoryList& appdata,
-                   LinuxDumper* dumper);
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_MINIDUMP_WRITER_H_
diff --git a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/proc_cpuinfo_reader.h b/TMessagesProj/jni/breakpad/client/linux/minidump_writer/proc_cpuinfo_reader.h
deleted file mode 100644
index d9461bf30..000000000
--- a/TMessagesProj/jni/breakpad/client/linux/minidump_writer/proc_cpuinfo_reader.h
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright (c) 2013, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef CLIENT_LINUX_MINIDUMP_WRITER_PROC_CPUINFO_READER_H_
-#define CLIENT_LINUX_MINIDUMP_WRITER_PROC_CPUINFO_READER_H_
-
-#include <stdint.h>
-#include <assert.h>
-#include <string.h>
-
-#include "client/linux/minidump_writer/line_reader.h"
-#include "common/linux/linux_libc_support.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-// A class for reading /proc/cpuinfo without using fopen/fgets or other
-// functions which may allocate memory.
-class ProcCpuInfoReader {
-public:
-  ProcCpuInfoReader(int fd)
-    : line_reader_(fd), pop_count_(-1) {
-  }
-
-  // Return the next field name, or NULL in case of EOF.
-  // field: (output) Pointer to zero-terminated field name.
-  // Returns true on success, or false on EOF or error (line too long).
-  bool GetNextField(const char** field) {
-    for (;;) {
-      const char* line;
-      unsigned line_len;
-
-      // Try to read next line.
-      if (pop_count_ >= 0) {
-        line_reader_.PopLine(pop_count_);
-        pop_count_ = -1;
-      }
-
-      if (!line_reader_.GetNextLine(&line, &line_len))
-        return false;
-
-      pop_count_ = static_cast<int>(line_len);
-
-      const char* line_end = line + line_len;
-
-      // Expected format: <field-name> <space>+ ':' <space> <value>
-      // Note that:
-      //   - empty lines happen.
-      //   - <field-name> can contain spaces.
-      //   - some fields have an empty <value>
-      char* sep = static_cast<char*>(my_memchr(line, ':', line_len));
-      if (sep == NULL)
-        continue;
-
-      // Record the value. Skip leading space after the column to get
-      // its start.
-      const char* val = sep+1;
-      while (val < line_end && my_isspace(*val))
-        val++;
-
-      value_ = val;
-      value_len_ = static_cast<size_t>(line_end - val);
-
-      // Remove trailing spaces before the column to properly 0-terminate
-      // the field name.
-      while (sep > line && my_isspace(sep[-1]))
-        sep--;
-
-      if (sep == line)
-        continue;
-
-      // zero-terminate field name.
-      *sep = '\0';
-
-      *field = line;
-      return true;
-    }
-  }
-
-  // Return the field value. This must be called after a succesful
-  // call to GetNextField().
-  const char* GetValue() {
-    assert(value_);
-    return value_;
-  }
-
-  // Same as GetValue(), but also returns the length in characters of
-  // the value.
-  const char* GetValueAndLen(size_t* length) {
-    assert(value_);
-    *length = value_len_;
-    return value_;
-  }
-
-private:
-  LineReader line_reader_;
-  int pop_count_;
-  const char* value_;
-  size_t value_len_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_LINUX_MINIDUMP_WRITER_PROC_CPUINFO_READER_H_
diff --git a/TMessagesProj/jni/breakpad/client/minidump_file_writer-inl.h b/TMessagesProj/jni/breakpad/client/minidump_file_writer-inl.h
deleted file mode 100644
index 0e12e00b6..000000000
--- a/TMessagesProj/jni/breakpad/client/minidump_file_writer-inl.h
+++ /dev/null
@@ -1,97 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// minidump_file_writer-inl.h: Minidump file writer implementation.
-//
-// See minidump_file_writer.h for documentation.
-
-#ifndef CLIENT_MINIDUMP_FILE_WRITER_INL_H__
-#define CLIENT_MINIDUMP_FILE_WRITER_INL_H__
-
-#include <assert.h>
-
-#include "client/minidump_file_writer.h"
-#include "google_breakpad/common/minidump_size.h"
-
-namespace google_breakpad {
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::Allocate() {
-  allocation_state_ = SINGLE_OBJECT;
-  return UntypedMDRVA::Allocate(minidump_size<MDType>::size());
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::Allocate(size_t additional) {
-  allocation_state_ = SINGLE_OBJECT;
-  return UntypedMDRVA::Allocate(minidump_size<MDType>::size() + additional);
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::AllocateArray(size_t count) {
-  assert(count);
-  allocation_state_ = ARRAY;
-  return UntypedMDRVA::Allocate(minidump_size<MDType>::size() * count);
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::AllocateObjectAndArray(size_t count,
-                                                       size_t length) {
-  assert(count && length);
-  allocation_state_ = SINGLE_OBJECT_WITH_ARRAY;
-  return UntypedMDRVA::Allocate(minidump_size<MDType>::size() + count * length);
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::CopyIndex(unsigned int index, MDType *item) {
-  assert(allocation_state_ == ARRAY);
-  return writer_->Copy(
-      static_cast<MDRVA>(position_ + index * minidump_size<MDType>::size()), 
-      item, minidump_size<MDType>::size());
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::CopyIndexAfterObject(unsigned int index,
-                                                     const void *src, 
-                                                     size_t length) {
-  assert(allocation_state_ == SINGLE_OBJECT_WITH_ARRAY);
-  return writer_->Copy(
-      static_cast<MDRVA>(position_ + minidump_size<MDType>::size() 
-                         + index * length),
-      src, length);
-}
-
-template<typename MDType>
-inline bool TypedMDRVA<MDType>::Flush() {
-  return writer_->Copy(position_, &data_, minidump_size<MDType>::size());
-}
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_MINIDUMP_FILE_WRITER_INL_H__
diff --git a/TMessagesProj/jni/breakpad/client/minidump_file_writer.cc b/TMessagesProj/jni/breakpad/client/minidump_file_writer.cc
deleted file mode 100644
index 9e9053353..000000000
--- a/TMessagesProj/jni/breakpad/client/minidump_file_writer.cc
+++ /dev/null
@@ -1,284 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// minidump_file_writer.cc: Minidump file writer implementation.
-//
-// See minidump_file_writer.h for documentation.
-
-#include <fcntl.h>
-#include <limits.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "client/minidump_file_writer-inl.h"
-#include "common/linux/linux_libc_support.h"
-#include "common/string_conversion.h"
-#if defined(__linux__) && __linux__
-#include "third_party/lss/linux_syscall_support.h"
-#endif
-
-namespace google_breakpad {
-
-const MDRVA MinidumpFileWriter::kInvalidMDRVA = static_cast<MDRVA>(-1);
-
-MinidumpFileWriter::MinidumpFileWriter()
-    : file_(-1),
-      close_file_when_destroyed_(true),
-      position_(0),
-      size_(0) {
-}
-
-MinidumpFileWriter::~MinidumpFileWriter() {
-  if (close_file_when_destroyed_)
-    Close();
-}
-
-bool MinidumpFileWriter::Open(const char *path) {
-  assert(file_ == -1);
-#if defined(__linux__) && __linux__
-  file_ = sys_open(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
-#else
-  file_ = open(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
-#endif
-
-  return file_ != -1;
-}
-
-void MinidumpFileWriter::SetFile(const int file) {
-  assert(file_ == -1);
-  file_ = file;
-  close_file_when_destroyed_ = false;
-}
-
-bool MinidumpFileWriter::Close() {
-  bool result = true;
-
-  if (file_ != -1) {
-    if (-1 == ftruncate(file_, position_)) {
-       return false;
-    }
-#if defined(__linux__) && __linux__
-    result = (sys_close(file_) == 0);
-#else
-    result = (close(file_) == 0);
-#endif
-    file_ = -1;
-  }
-
-  return result;
-}
-
-bool MinidumpFileWriter::CopyStringToMDString(const wchar_t *str,
-                                              unsigned int length,
-                                              TypedMDRVA<MDString> *mdstring) {
-  bool result = true;
-  if (sizeof(wchar_t) == sizeof(uint16_t)) {
-    // Shortcut if wchar_t is the same size as MDString's buffer
-    result = mdstring->Copy(str, mdstring->get()->length);
-  } else {
-    uint16_t out[2];
-    int out_idx = 0;
-
-    // Copy the string character by character
-    while (length && result) {
-      UTF32ToUTF16Char(*str, out);
-      if (!out[0])
-        return false;
-
-      // Process one character at a time
-      --length;
-      ++str;
-
-      // Append the one or two UTF-16 characters.  The first one will be non-
-      // zero, but the second one may be zero, depending on the conversion from
-      // UTF-32.
-      int out_count = out[1] ? 2 : 1;
-      size_t out_size = sizeof(uint16_t) * out_count;
-      result = mdstring->CopyIndexAfterObject(out_idx, out, out_size);
-      out_idx += out_count;
-    }
-  }
-  return result;
-}
-
-bool MinidumpFileWriter::CopyStringToMDString(const char *str,
-                                              unsigned int length,
-                                              TypedMDRVA<MDString> *mdstring) {
-  bool result = true;
-  uint16_t out[2];
-  int out_idx = 0;
-
-  // Copy the string character by character
-  while (length && result) {
-    int conversion_count = UTF8ToUTF16Char(str, length, out);
-    if (!conversion_count)
-      return false;
-
-    // Move the pointer along based on the nubmer of converted characters
-    length -= conversion_count;
-    str += conversion_count;
-
-    // Append the one or two UTF-16 characters
-    int out_count = out[1] ? 2 : 1;
-    size_t out_size = sizeof(uint16_t) * out_count;
-    result = mdstring->CopyIndexAfterObject(out_idx, out, out_size);
-    out_idx += out_count;
-  }
-  return result;
-}
-
-template <typename CharType>
-bool MinidumpFileWriter::WriteStringCore(const CharType *str,
-                                         unsigned int length,
-                                         MDLocationDescriptor *location) {
-  assert(str);
-  assert(location);
-  // Calculate the mdstring length by either limiting to |length| as passed in
-  // or by finding the location of the NULL character.
-  unsigned int mdstring_length = 0;
-  if (!length)
-    length = INT_MAX;
-  for (; mdstring_length < length && str[mdstring_length]; ++mdstring_length)
-    ;
-
-  // Allocate the string buffer
-  TypedMDRVA<MDString> mdstring(this);
-  if (!mdstring.AllocateObjectAndArray(mdstring_length + 1, sizeof(uint16_t)))
-    return false;
-
-  // Set length excluding the NULL and copy the string
-  mdstring.get()->length =
-      static_cast<uint32_t>(mdstring_length * sizeof(uint16_t));
-  bool result = CopyStringToMDString(str, mdstring_length, &mdstring);
-
-  // NULL terminate
-  if (result) {
-    uint16_t ch = 0;
-    result = mdstring.CopyIndexAfterObject(mdstring_length, &ch, sizeof(ch));
-
-    if (result)
-      *location = mdstring.location();
-  }
-
-  return result;
-}
-
-bool MinidumpFileWriter::WriteString(const wchar_t *str, unsigned int length,
-                 MDLocationDescriptor *location) {
-  return WriteStringCore(str, length, location);
-}
-
-bool MinidumpFileWriter::WriteString(const char *str, unsigned int length,
-                 MDLocationDescriptor *location) {
-  return WriteStringCore(str, length, location);
-}
-
-bool MinidumpFileWriter::WriteMemory(const void *src, size_t size,
-                                     MDMemoryDescriptor *output) {
-  assert(src);
-  assert(output);
-  UntypedMDRVA mem(this);
-
-  if (!mem.Allocate(size))
-    return false;
-  if (!mem.Copy(src, mem.size()))
-    return false;
-
-  output->start_of_memory_range = reinterpret_cast<uint64_t>(src);
-  output->memory = mem.location();
-
-  return true;
-}
-
-MDRVA MinidumpFileWriter::Allocate(size_t size) {
-  assert(size);
-  assert(file_ != -1);
-  size_t aligned_size = (size + 7) & ~7;  // 64-bit alignment
-
-  if (position_ + aligned_size > size_) {
-    size_t growth = aligned_size;
-    size_t minimal_growth = getpagesize();
-
-    // Ensure that the file grows by at least the size of a memory page
-    if (growth < minimal_growth)
-      growth = minimal_growth;
-
-    size_t new_size = size_ + growth;
-    if (ftruncate(file_, new_size) != 0)
-      return kInvalidMDRVA;
-
-    size_ = new_size;
-  }
-
-  MDRVA current_position = position_;
-  position_ += static_cast<MDRVA>(aligned_size);
-
-  return current_position;
-}
-
-bool MinidumpFileWriter::Copy(MDRVA position, const void *src, ssize_t size) {
-  assert(src);
-  assert(size);
-  assert(file_ != -1);
-
-  // Ensure that the data will fit in the allocated space
-  if (static_cast<size_t>(size + position) > size_)
-    return false;
-
-  // Seek and write the data
-#if defined(__linux__) && __linux__
-  if (sys_lseek(file_, position, SEEK_SET) == static_cast<off_t>(position)) {
-    if (sys_write(file_, src, size) == size) {
-#else
-  if (lseek(file_, position, SEEK_SET) == static_cast<off_t>(position)) {
-    if (write(file_, src, size) == size) {
-#endif
-      return true;
-    }
-  }
-
-  return false;
-}
-
-bool UntypedMDRVA::Allocate(size_t size) {
-  assert(size_ == 0);
-  size_ = size;
-  position_ = writer_->Allocate(size_);
-  return position_ != MinidumpFileWriter::kInvalidMDRVA;
-}
-
-bool UntypedMDRVA::Copy(MDRVA pos, const void *src, size_t size) {
-  assert(src);
-  assert(size);
-  assert(pos + size <= position_ + size_);
-  return writer_->Copy(pos, src, size);
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/client/minidump_file_writer.h b/TMessagesProj/jni/breakpad/client/minidump_file_writer.h
deleted file mode 100644
index ce32b6d08..000000000
--- a/TMessagesProj/jni/breakpad/client/minidump_file_writer.h
+++ /dev/null
@@ -1,272 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// minidump_file_writer.h:  Implements file-based minidump generation.  It's
-// intended to be used with the Google Breakpad open source crash handling
-// project.
-
-#ifndef CLIENT_MINIDUMP_FILE_WRITER_H__
-#define CLIENT_MINIDUMP_FILE_WRITER_H__
-
-#include <string>
-
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-class UntypedMDRVA;
-template<typename MDType> class TypedMDRVA;
-
-// The user of this class can Open() a file and add minidump streams, data, and
-// strings using the definitions in minidump_format.h.  Since this class is
-// expected to be used in a situation where the current process may be
-// damaged, it will not allocate heap memory.
-// Sample usage:
-// MinidumpFileWriter writer;
-// writer.Open("/tmp/minidump.dmp");
-// TypedMDRVA<MDRawHeader> header(&writer_);
-// header.Allocate();
-// header->get()->signature = MD_HEADER_SIGNATURE;
-//  :
-// writer.Close();
-//
-// An alternative is to use SetFile and provide a file descriptor:
-// MinidumpFileWriter writer;
-// writer.SetFile(minidump_fd);
-// TypedMDRVA<MDRawHeader> header(&writer_);
-// header.Allocate();
-// header->get()->signature = MD_HEADER_SIGNATURE;
-//  :
-// writer.Close();
-
-class MinidumpFileWriter {
-public:
-  // Invalid MDRVA (Minidump Relative Virtual Address)
-  // returned on failed allocation
-  static const MDRVA kInvalidMDRVA;
-
-  MinidumpFileWriter();
-  ~MinidumpFileWriter();
-
-  // Open |path| as the destination of the minidump data. If |path| already
-  // exists, then Open() will fail.
-  // Return true on success, or false on failure.
-  bool Open(const char *path);
-
-  // Sets the file descriptor |file| as the destination of the minidump data.
-  // Can be used as an alternative to Open() when a file descriptor is
-  // available.
-  // Note that |fd| is not closed when the instance of MinidumpFileWriter is
-  // destroyed.
-  void SetFile(const int file);
-
-  // Close the current file (that was either created when Open was called, or
-  // specified with SetFile).
-  // Return true on success, or false on failure.
-  bool Close();
-
-  // Copy the contents of |str| to a MDString and write it to the file.
-  // |str| is expected to be either UTF-16 or UTF-32 depending on the size
-  // of wchar_t.
-  // Maximum |length| of characters to copy from |str|, or specify 0 to use the
-  // entire NULL terminated string.  Copying will stop at the first NULL.
-  // |location| the allocated location
-  // Return true on success, or false on failure
-  bool WriteString(const wchar_t *str, unsigned int length,
-                   MDLocationDescriptor *location);
-
-  // Same as above, except with |str| as a UTF-8 string
-  bool WriteString(const char *str, unsigned int length,
-                   MDLocationDescriptor *location);
-
-  // Write |size| bytes starting at |src| into the current position.
-  // Return true on success and set |output| to position, or false on failure
-  bool WriteMemory(const void *src, size_t size, MDMemoryDescriptor *output);
-
-  // Copies |size| bytes from |src| to |position|
-  // Return true on success, or false on failure
-  bool Copy(MDRVA position, const void *src, ssize_t size);
-
-  // Return the current position for writing to the minidump
-  inline MDRVA position() const { return position_; }
-
- private:
-  friend class UntypedMDRVA;
-
-  // Allocates an area of |size| bytes.
-  // Returns the position of the allocation, or kInvalidMDRVA if it was
-  // unable to allocate the bytes.
-  MDRVA Allocate(size_t size);
-
-  // The file descriptor for the output file.
-  int file_;
-
-  // Whether |file_| should be closed when the instance is destroyed.
-  bool close_file_when_destroyed_;
-
-  // Current position in buffer
-  MDRVA position_;
-
-  // Current allocated size
-  size_t size_;
-
-  // Copy |length| characters from |str| to |mdstring|.  These are distinct
-  // because the underlying MDString is a UTF-16 based string.  The wchar_t
-  // variant may need to create a MDString that has more characters than the
-  // source |str|, whereas the UTF-8 variant may coalesce characters to form
-  // a single UTF-16 character.
-  bool CopyStringToMDString(const wchar_t *str, unsigned int length,
-                            TypedMDRVA<MDString> *mdstring);
-  bool CopyStringToMDString(const char *str, unsigned int length,
-                            TypedMDRVA<MDString> *mdstring);
-
-  // The common templated code for writing a string
-  template <typename CharType>
-  bool WriteStringCore(const CharType *str, unsigned int length,
-                       MDLocationDescriptor *location);
-};
-
-// Represents an untyped allocated chunk
-class UntypedMDRVA {
- public:
-  explicit UntypedMDRVA(MinidumpFileWriter *writer)
-      : writer_(writer),
-        position_(writer->position()),
-        size_(0) {}
-
-  // Allocates |size| bytes.  Must not call more than once.
-  // Return true on success, or false on failure
-  bool Allocate(size_t size);
-
-  // Returns the current position or kInvalidMDRVA if allocation failed
-  inline MDRVA position() const { return position_; }
-
-  // Number of bytes allocated
-  inline size_t size() const { return size_; }
-
-  // Return size and position
-  inline MDLocationDescriptor location() const {
-    MDLocationDescriptor location = { static_cast<uint32_t>(size_),
-                                      position_ };
-    return location;
-  }
-
-  // Copy |size| bytes starting at |src| into the minidump at |position|
-  // Return true on success, or false on failure
-  bool Copy(MDRVA position, const void *src, size_t size);
-
-  // Copy |size| bytes from |src| to the current position
-  inline bool Copy(const void *src, size_t size) {
-    return Copy(position_, src, size);
-  }
-
- protected:
-  // Writer we associate with
-  MinidumpFileWriter *writer_;
-
-  // Position of the start of the data
-  MDRVA position_;
-
-  // Allocated size
-  size_t size_;
-};
-
-// Represents a Minidump object chunk.  Additional memory can be allocated at
-// the end of the object as a:
-// - single allocation
-// - Array of MDType objects
-// - A MDType object followed by an array
-template<typename MDType>
-class TypedMDRVA : public UntypedMDRVA {
- public:
-  // Constructs an unallocated MDRVA
-  explicit TypedMDRVA(MinidumpFileWriter *writer)
-      : UntypedMDRVA(writer),
-        data_(),
-        allocation_state_(UNALLOCATED) {}
-
-  inline ~TypedMDRVA() {
-    // Ensure that the data_ object is written out
-    if (allocation_state_ != ARRAY)
-      Flush();
-  }
-
-  // Address of object data_ of MDType.  This is not declared const as the
-  // typical usage will be to access the underlying |data_| object as to
-  // alter its contents.
-  MDType *get() { return &data_; }
-
-  // Allocates minidump_size<MDType>::size() bytes.
-  // Must not call more than once.
-  // Return true on success, or false on failure
-  bool Allocate();
-
-  // Allocates minidump_size<MDType>::size() + |additional| bytes.
-  // Must not call more than once.
-  // Return true on success, or false on failure
-  bool Allocate(size_t additional);
-
-  // Allocate an array of |count| elements of MDType.
-  // Must not call more than once.
-  // Return true on success, or false on failure
-  bool AllocateArray(size_t count);
-
-  // Allocate an array of |count| elements of |size| after object of MDType
-  // Must not call more than once.
-  // Return true on success, or false on failure
-  bool AllocateObjectAndArray(size_t count, size_t size);
-
-  // Copy |item| to |index|
-  // Must have been allocated using AllocateArray().
-  // Return true on success, or false on failure
-  bool CopyIndex(unsigned int index, MDType *item);
-
-  // Copy |size| bytes starting at |str| to |index|
-  // Must have been allocated using AllocateObjectAndArray().
-  // Return true on success, or false on failure
-  bool CopyIndexAfterObject(unsigned int index, const void *src, size_t size);
-
-  // Write data_
-  bool Flush();
-
- private:
-  enum AllocationState {
-    UNALLOCATED = 0,
-    SINGLE_OBJECT,
-    ARRAY,
-    SINGLE_OBJECT_WITH_ARRAY
-  };
-
-  MDType data_;
-  AllocationState allocation_state_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // CLIENT_MINIDUMP_FILE_WRITER_H__
diff --git a/TMessagesProj/jni/breakpad/common/android/breakpad_getcontext.S b/TMessagesProj/jni/breakpad/common/android/breakpad_getcontext.S
deleted file mode 100644
index fd6326adf..000000000
--- a/TMessagesProj/jni/breakpad/common/android/breakpad_getcontext.S
+++ /dev/null
@@ -1,489 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// A minimalistic implementation of getcontext() to be used by
-// Google Breakpad on Android.
-
-#include "common/android/ucontext_constants.h"
-
-/* int getcontext (ucontext_t *ucp) */
-
-#if defined(__arm__)
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .type breakpad_getcontext, #function
-  .align 0
-  .fnstart
-breakpad_getcontext:
-
-  /* First, save r4-r11 */
-  add   r1, r0, #(MCONTEXT_GREGS_OFFSET + 4*4)
-  stm   r1, {r4-r11}
-
-  /* r12 is a scratch register, don't save it */
-
-  /* Save sp and lr explicitly. */
-  /* - sp can't be stored with stmia in Thumb-2 */
-  /* - STM instructions that store sp and pc are deprecated in ARM */
-  str   sp, [r0, #(MCONTEXT_GREGS_OFFSET + 13*4)]
-  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
-
-  /* Save the caller's address in 'pc' */
-  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 15*4)]
-
-  /* Save ucontext_t* pointer across next call */
-  mov   r4, r0
-
-  /* Call sigprocmask(SIG_BLOCK, NULL, &(ucontext->uc_sigmask)) */
-  mov   r0, #0  /* SIG_BLOCK */
-  mov   r1, #0  /* NULL */
-  add   r2, r4, #UCONTEXT_SIGMASK_OFFSET
-  bl    sigprocmask(PLT)
-
-  /* Intentionally do not save the FPU state here. This is because on
-   * Linux/ARM, one should instead use ptrace(PTRACE_GETFPREGS) or
-   * ptrace(PTRACE_GETVFPREGS) to get it.
-   *
-   * Note that a real implementation of getcontext() would need to save
-   * this here to allow setcontext()/swapcontext() to work correctly.
-   */
-
-  /* Restore the values of r4 and lr */
-  mov   r0, r4
-  ldr   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
-  ldr   r4, [r0, #(MCONTEXT_GREGS_OFFSET +  4*4)]
-
-  /* Return 0 */
-  mov   r0, #0
-  bx    lr
-
-  .fnend
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#elif defined(__aarch64__)
-
-#define  _NSIG                       64
-#define  __NR_rt_sigprocmask         135
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .type breakpad_getcontext, #function
-  .align 4
-  .cfi_startproc
-breakpad_getcontext:
-
-  /* The saved context will return to the getcontext() call point
-     with a return value of 0 */
-  str     xzr,      [x0, MCONTEXT_GREGS_OFFSET +  0 * REGISTER_SIZE]
-
-  stp     x18, x19, [x0, MCONTEXT_GREGS_OFFSET + 18 * REGISTER_SIZE]
-  stp     x20, x21, [x0, MCONTEXT_GREGS_OFFSET + 20 * REGISTER_SIZE]
-  stp     x22, x23, [x0, MCONTEXT_GREGS_OFFSET + 22 * REGISTER_SIZE]
-  stp     x24, x25, [x0, MCONTEXT_GREGS_OFFSET + 24 * REGISTER_SIZE]
-  stp     x26, x27, [x0, MCONTEXT_GREGS_OFFSET + 26 * REGISTER_SIZE]
-  stp     x28, x29, [x0, MCONTEXT_GREGS_OFFSET + 28 * REGISTER_SIZE]
-  str     x30,      [x0, MCONTEXT_GREGS_OFFSET + 30 * REGISTER_SIZE]
-
-  /* Place LR into the saved PC, this will ensure that when
-     switching to this saved context with setcontext() control
-     will pass back to the caller of getcontext(), we have
-     already arranged to return the appropriate return value in x0
-     above.  */
-  str     x30, [x0, MCONTEXT_PC_OFFSET]
-
-  /* Save the current SP */
-  mov     x2, sp
-  str     x2, [x0, MCONTEXT_SP_OFFSET]
-
-  /* Initialize the pstate.  */
-  str     xzr, [x0, MCONTEXT_PSTATE_OFFSET]
-
-  /* Figure out where to place the first context extension
-     block.  */
-  add     x2, x0, #MCONTEXT_EXTENSION_OFFSET
-
-  /* Write the context extension fpsimd header.  */
-  mov     w3, #(FPSIMD_MAGIC & 0xffff)
-  movk    w3, #(FPSIMD_MAGIC >> 16), lsl #16
-  str     w3, [x2, #FPSIMD_CONTEXT_MAGIC_OFFSET]
-  mov     w3, #FPSIMD_CONTEXT_SIZE
-  str     w3, [x2, #FPSIMD_CONTEXT_SIZE_OFFSET]
-
-  /* Fill in the FP SIMD context.  */
-  add     x3, x2, #(FPSIMD_CONTEXT_VREGS_OFFSET + 8 * SIMD_REGISTER_SIZE)
-  stp     d8,  d9, [x3], #(2 * SIMD_REGISTER_SIZE)
-  stp     d10, d11, [x3], #(2 * SIMD_REGISTER_SIZE)
-  stp     d12, d13, [x3], #(2 * SIMD_REGISTER_SIZE)
-  stp     d14, d15, [x3], #(2 * SIMD_REGISTER_SIZE)
-
-  add     x3, x2, FPSIMD_CONTEXT_FPSR_OFFSET
-
-  mrs     x4, fpsr
-  str     w4, [x3]
-
-  mrs     x4, fpcr
-  str     w4, [x3, FPSIMD_CONTEXT_FPCR_OFFSET - FPSIMD_CONTEXT_FPSR_OFFSET]
-
-  /* Write the termination context extension header.  */
-  add     x2, x2, #FPSIMD_CONTEXT_SIZE
-
-  str     xzr, [x2, #FPSIMD_CONTEXT_MAGIC_OFFSET]
-  str     xzr, [x2, #FPSIMD_CONTEXT_SIZE_OFFSET]
-
-  /* Grab the signal mask */
-  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
-  add     x2, x0, #UCONTEXT_SIGMASK_OFFSET
-  mov     x0, #0  /* SIG_BLOCK */
-  mov     x1, #0  /* NULL */
-  mov     x3, #(_NSIG / 8)
-  mov     x8, #__NR_rt_sigprocmask
-  svc     0
-
-  /* Return x0 for success */
-  mov     x0, 0
-  ret
-
-  .cfi_endproc
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#elif defined(__i386__)
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .align 4
-  .type breakpad_getcontext, @function
-
-breakpad_getcontext:
-
-  movl 4(%esp), %eax   /* eax = uc */
-
-  /* Save register values */
-  movl %ecx, MCONTEXT_ECX_OFFSET(%eax)
-  movl %edx, MCONTEXT_EDX_OFFSET(%eax)
-  movl %ebx, MCONTEXT_EBX_OFFSET(%eax)
-  movl %edi, MCONTEXT_EDI_OFFSET(%eax)
-  movl %esi, MCONTEXT_ESI_OFFSET(%eax)
-  movl %ebp, MCONTEXT_EBP_OFFSET(%eax)
-
-  movl (%esp), %edx   /* return address */
-  lea  4(%esp), %ecx  /* exclude return address from stack */
-  mov  %edx, MCONTEXT_EIP_OFFSET(%eax)
-  mov  %ecx, MCONTEXT_ESP_OFFSET(%eax)
-
-  xorl %ecx, %ecx
-  movw %fs, %cx
-  mov  %ecx, MCONTEXT_FS_OFFSET(%eax)
-
-  movl $0, MCONTEXT_EAX_OFFSET(%eax)
-
-  /* Save floating point state to fpregstate, then update
-   * the fpregs pointer to point to it */
-  leal UCONTEXT_FPREGS_MEM_OFFSET(%eax), %ecx
-  fnstenv (%ecx)
-  fldenv  (%ecx)
-  mov %ecx, UCONTEXT_FPREGS_OFFSET(%eax)
-
-  /* Save signal mask: sigprocmask(SIGBLOCK, NULL, &uc->uc_sigmask) */
-  leal UCONTEXT_SIGMASK_OFFSET(%eax), %edx
-  xorl %ecx, %ecx
-  push %edx   /* &uc->uc_sigmask */
-  push %ecx   /* NULL */
-  push %ecx   /* SIGBLOCK == 0 on i386 */
-  call sigprocmask@PLT
-  addl $12, %esp
-
-  movl $0, %eax
-  ret
-
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#elif defined(__mips__)
-
-// This implementation is inspired by implementation of getcontext in glibc.
-#if _MIPS_SIM == _ABIO32
-#include <asm/asm.h>
-#include <asm/regdef.h>
-#include <asm/fpregdef.h>
-#else
-#include <machine/asm.h>
-#include <machine/regdef.h>
-#endif
-
-// from asm/asm.h
-#if _MIPS_SIM == _ABIO32
-#define ALSZ 7
-#define ALMASK ~7
-#define SZREG 4
-#else // _MIPS_SIM != _ABIO32
-#define ALSZ 15
-#define ALMASK ~15
-#define SZREG 8
-#endif
-
-#include <asm/unistd.h> // for __NR_rt_sigprocmask
-
-#define _NSIG8 128 / 8
-#define SIG_BLOCK 1
-
-
-  .text
-LOCALS_NUM = 1 // save gp on stack
-FRAME_SIZE = ((LOCALS_NUM * SZREG) + ALSZ) & ALMASK
-
-GP_FRAME_OFFSET = FRAME_SIZE - (1 * SZREG)
-MCONTEXT_REG_SIZE = 8
-
-#if _MIPS_SIM == _ABIO32
-
-NESTED (breakpad_getcontext, FRAME_SIZE, ra)
-  .mask	0x00000000, 0
-  .fmask 0x00000000, 0
-
-  .set noreorder
-  .cpload t9
-  .set reorder
-
-  move a2, sp
-#define _SP a2
-
-  addiu sp, -FRAME_SIZE
-  .cprestore GP_FRAME_OFFSET
-
-  sw s0, (16 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s1, (17 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s2, (18 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s3, (19 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s4, (20 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s5, (21 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s6, (22 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s7, (23 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw _SP, (29 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw fp, (30 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw ra, (31 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw ra, MCONTEXT_PC_OFFSET(a0)
-
-#ifdef __mips_hard_float
-  s.d fs0, (20 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs1, (22 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs2, (24 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs3, (26 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs4, (28 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs5, (30 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-
-  cfc1 v1, fcr31
-  sw v1, MCONTEXT_FPC_CSR(a0)
-#endif  // __mips_hard_float
-
-  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
-  li a3, _NSIG8
-  addu a2, a0, UCONTEXT_SIGMASK_OFFSET
-  move a1, zero
-  li a0, SIG_BLOCK
-  li v0, __NR_rt_sigprocmask
-  syscall
-
-  addiu sp, FRAME_SIZE
-  jr ra
-
-END (breakpad_getcontext)
-#else
-
-#ifndef NESTED
-/*
- * NESTED - declare nested routine entry point
- */
-#define NESTED(symbol, framesize, rpc)  \
-    .globl  symbol;                     \
-    .align  2;                          \
-    .type symbol,@function;             \
-    .ent  symbol,0;                     \
-symbol:   .frame  sp, framesize, rpc;
-#endif
-
-/*
- * END - mark end of function
- */
-#ifndef END
-# define END(function)                  \
-    .end  function;                     \
-    .size function,.-function
-#endif
-
-/* int getcontext (ucontext_t *ucp) */
-
-NESTED (breakpad_getcontext, FRAME_SIZE, ra)
-  .mask   0x10000000, 0
-  .fmask  0x00000000, 0
-
-  move  a2, sp
-#define _SP a2
-  move  a3, gp
-#define _GP a3
-
-  daddiu sp, -FRAME_SIZE
-  .cpsetup $25, GP_FRAME_OFFSET, breakpad_getcontext
-
-  /* Store a magic flag.  */
-  li  v1, 1
-  sd v1, (0 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)  /* zero */
-
-  sd s0, (16 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s1, (17 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s2, (18 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s3, (19 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s4, (20 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s5, (21 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s6, (22 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s7, (23 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd _GP, (28 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd _SP, (29 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd s8, (30 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd ra, (31 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sd ra, MCONTEXT_PC_OFFSET(a0)
-
-#ifdef __mips_hard_float
-  s.d $f24, (24 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f25, (25 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f26, (26 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f27, (27 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f28, (28 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f29, (29 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f30, (30 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d $f31, (31 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-
-  cfc1  v1, $31
-  sw  v1, MCONTEXT_FPC_CSR(a0)
-#endif /* __mips_hard_float */
-
-/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
-  li  a3, _NSIG8
-  daddu a2, a0, UCONTEXT_SIGMASK_OFFSET
-  move  a1, zero
-  li  a0, SIG_BLOCK
-
-  li  v0, __NR_rt_sigprocmask
-  syscall
-
-  .cpreturn
-  daddiu sp, FRAME_SIZE
-  move  v0, zero
-  jr  ra
-
-END (breakpad_getcontext)
-#endif // _MIPS_SIM == _ABIO32
-
-#elif defined(__x86_64__)
-/* The x64 implementation of breakpad_getcontext was derived in part
-   from the implementation of libunwind which requires the following
-   notice. */
-/* libunwind - a platform-independent unwind library
-   Copyright (C) 2008 Google, Inc
-	Contributed by Paul Pluzhnikov <ppluzhnikov@google.com>
-   Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
-
-This file is part of libunwind.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .align 4
-  .type breakpad_getcontext, @function
-
-breakpad_getcontext:
-  .cfi_startproc
-
-  /* Callee saved: RBX, RBP, R12-R15  */
-  movq %r12, MCONTEXT_GREGS_R12(%rdi)
-  movq %r13, MCONTEXT_GREGS_R13(%rdi)
-  movq %r14, MCONTEXT_GREGS_R14(%rdi)
-  movq %r15, MCONTEXT_GREGS_R15(%rdi)
-  movq %rbp, MCONTEXT_GREGS_RBP(%rdi)
-  movq %rbx, MCONTEXT_GREGS_RBX(%rdi)
-
-  /* Save argument registers (not strictly needed, but setcontext
-     restores them, so don't restore garbage).  */
-  movq %r8,  MCONTEXT_GREGS_R8(%rdi)
-  movq %r9,  MCONTEXT_GREGS_R9(%rdi)
-  movq %rdi, MCONTEXT_GREGS_RDI(%rdi)
-  movq %rsi, MCONTEXT_GREGS_RSI(%rdi)
-  movq %rdx, MCONTEXT_GREGS_RDX(%rdi)
-  movq %rax, MCONTEXT_GREGS_RAX(%rdi)
-  movq %rcx, MCONTEXT_GREGS_RCX(%rdi)
-
-  /* Save fp state (not needed, except for setcontext not
-     restoring garbage).  */
-  leaq MCONTEXT_FPREGS_MEM(%rdi),%r8
-  movq %r8, MCONTEXT_FPREGS_PTR(%rdi)
-  fnstenv (%r8)
-  stmxcsr FPREGS_OFFSET_MXCSR(%r8)
-
-  leaq 8(%rsp), %rax /* exclude this call.  */
-  movq %rax, MCONTEXT_GREGS_RSP(%rdi)
-
-  movq 0(%rsp), %rax
-  movq %rax, MCONTEXT_GREGS_RIP(%rdi)
-
-  /* Save signal mask: sigprocmask(SIGBLOCK, NULL, &uc->uc_sigmask) */
-  leaq UCONTEXT_SIGMASK_OFFSET(%rdi), %rdx  // arg3
-  xorq %rsi, %rsi  // arg2 NULL
-  xorq %rdi, %rdi  // arg1 SIGBLOCK == 0
-  call sigprocmask@PLT
-
-  /* Always return 0 for success, even if sigprocmask failed. */
-  xorl %eax, %eax
-  ret
-  .cfi_endproc
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#else
-#error "This file has not been ported for your CPU!"
-#endif
diff --git a/TMessagesProj/jni/breakpad/common/android/include/elf.h b/TMessagesProj/jni/breakpad/common/android/include/elf.h
deleted file mode 100644
index b2a28df44..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/elf.h
+++ /dev/null
@@ -1,168 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ELF_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ELF_H
-
-#include <stdint.h>
-#include <libgen.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-// The Android <elf.h> provides BSD-based definitions for the ElfXX_Nhdr
-// types
-// always source-compatible with the GLibc/kernel ones. To overcome this
-// issue without modifying a lot of code in Breakpad, use an ugly macro
-// renaming trick with #include_next
-
-// Avoid conflict with BSD-based definition of ElfXX_Nhdr.
-// Unfortunately, their field member names do not use a 'n_' prefix.
-#define Elf32_Nhdr   __bsd_Elf32_Nhdr
-#define Elf64_Nhdr   __bsd_Elf64_Nhdr
-
-// In case they are defined by the NDK version
-#define Elf32_auxv_t  __bionic_Elf32_auxv_t
-#define Elf64_auxv_t  __bionic_Elf64_auxv_t
-
-#define Elf32_Dyn     __bionic_Elf32_Dyn
-#define Elf64_Dyn     __bionic_Elf64_Dyn
-
-#include_next <elf.h>
-
-#undef Elf32_Nhdr
-#undef Elf64_Nhdr
-
-typedef struct {
-  Elf32_Word n_namesz;
-  Elf32_Word n_descsz;
-  Elf32_Word n_type;
-} Elf32_Nhdr;
-
-typedef struct {
-  Elf64_Word n_namesz;
-  Elf64_Word n_descsz;
-  Elf64_Word n_type;
-} Elf64_Nhdr;
-
-#undef Elf32_auxv_t
-#undef Elf64_auxv_t
-
-typedef struct {
-    uint32_t a_type;
-    union {
-      uint32_t a_val;
-    } a_un;
-} Elf32_auxv_t;
-
-typedef struct {
-    uint64_t a_type;
-    union {
-      uint64_t a_val;
-    } a_un;
-} Elf64_auxv_t;
-
-#undef Elf32_Dyn
-#undef Elf64_Dyn
-
-typedef struct {
-  Elf32_Sword   d_tag;
-  union {
-    Elf32_Word  d_val;
-    Elf32_Addr  d_ptr;
-  } d_un;
-} Elf32_Dyn;
-
-typedef struct {
-  Elf64_Sxword   d_tag;
-  union {
-    Elf64_Xword  d_val;
-    Elf64_Addr   d_ptr;
-  } d_un;
-} Elf64_Dyn;
-
-
-// __WORDSIZE is GLibc-specific and used by Google Breakpad on Linux.
-#ifndef __WORDSIZE
-#if defined(__i386__) ||  defined(__ARM_EABI__) || defined(__mips__)
-#define __WORDSIZE 32
-#elif defined(__x86_64__) || defined(__aarch64__)
-#define __WORDSIZE 64
-#else
-#error "Unsupported Android CPU ABI"
-#endif
-#endif
-
-// The Android headers don't always define this constant.
-#ifndef EM_X86_64
-#define EM_X86_64  62
-#endif
-
-#ifndef EM_PPC64
-#define EM_PPC64   21
-#endif
-
-#ifndef EM_S390
-#define EM_S390    22
-#endif
-
-#if !defined(AT_SYSINFO_EHDR)
-#define AT_SYSINFO_EHDR 33
-#endif
-
-#if !defined(NT_PRSTATUS)
-#define NT_PRSTATUS 1
-#endif
-
-#if !defined(NT_PRPSINFO)
-#define NT_PRPSINFO 3
-#endif
-
-#if !defined(NT_AUXV)
-#define NT_AUXV   6
-#endif
-
-#if !defined(NT_PRXFPREG)
-#define NT_PRXFPREG 0x46e62b7f
-#endif
-
-#if !defined(NT_FPREGSET)
-#define NT_FPREGSET 2
-#endif
-
-#if !defined(SHT_MIPS_DWARF)
-#define SHT_MIPS_DWARF 0x7000001e
-#endif
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ELF_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/link.h b/TMessagesProj/jni/breakpad/common/android/include/link.h
deleted file mode 100644
index e7ff8e2d8..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/link.h
+++ /dev/null
@@ -1,71 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H
-#define GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H
-
-/* Android doesn't provide all the data-structures required in its <link.h>.
-   Provide custom version here. */
-#include_next <link.h>
-
-// TODO(rmcilroy): Remove this file once the ndk is updated for other
-// architectures - crbug.com/358831
-#if !defined(__aarch64__) && !defined(__x86_64__) && \
-    !(defined(__mips__) && _MIPS_SIM == _ABI64)
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-struct r_debug {
-  int              r_version;
-  struct link_map* r_map;
-  ElfW(Addr)       r_brk;
-  enum {
-    RT_CONSISTENT,
-    RT_ADD,
-    RT_DELETE }    r_state;
-  ElfW(Addr)       r_ldbase;
-};
-
-struct link_map {
-  ElfW(Addr)       l_addr;
-  char*            l_name;
-  ElfW(Dyn)*       l_ld;
-  struct link_map* l_next;
-  struct link_map* l_prev;
-};
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // !defined(__aarch64__) && !defined(__x86_64__)
-
-#endif /* GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H */
diff --git a/TMessagesProj/jni/breakpad/common/android/include/sgidefs.h b/TMessagesProj/jni/breakpad/common/android/include/sgidefs.h
deleted file mode 100644
index 33796dcf7..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/sgidefs.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright (c) 2013, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
-#define GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
-
-#ifdef __mips__
-
-// Android doesn't contain sgidefs.h, but does have <asm/sgidefs.h> which
-// contains what we need.
-#include <asm/sgidefs.h>
-
-#endif  // __mips__
-
-#endif  // GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/stab.h b/TMessagesProj/jni/breakpad/common/android/include/stab.h
deleted file mode 100644
index cd9290215..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/stab.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_STAB_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_STAB_H
-
-#include <sys/cdefs.h>
-
-#ifdef __BIONIC_HAVE_STAB_H
-#include <stab.h>
-#else
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-#define _STAB_CODE_LIST       \
-  _STAB_CODE_DEF(UNDF,0x00)   \
-  _STAB_CODE_DEF(GSYM,0x20)   \
-  _STAB_CODE_DEF(FNAME,0x22)  \
-  _STAB_CODE_DEF(FUN,0x24)    \
-  _STAB_CODE_DEF(STSYM,0x26)  \
-  _STAB_CODE_DEF(LCSYM,0x28)  \
-  _STAB_CODE_DEF(MAIN,0x2a)   \
-  _STAB_CODE_DEF(PC,0x30)     \
-  _STAB_CODE_DEF(NSYMS,0x32)  \
-  _STAB_CODE_DEF(NOMAP,0x34)  \
-  _STAB_CODE_DEF(OBJ,0x38)    \
-  _STAB_CODE_DEF(OPT,0x3c)    \
-  _STAB_CODE_DEF(RSYM,0x40)   \
-  _STAB_CODE_DEF(M2C,0x42)    \
-  _STAB_CODE_DEF(SLINE,0x44)  \
-  _STAB_CODE_DEF(DSLINE,0x46) \
-  _STAB_CODE_DEF(BSLINE,0x48) \
-  _STAB_CODE_DEF(BROWS,0x48)  \
-  _STAB_CODE_DEF(DEFD,0x4a)   \
-  _STAB_CODE_DEF(EHDECL,0x50) \
-  _STAB_CODE_DEF(MOD2,0x50)   \
-  _STAB_CODE_DEF(CATCH,0x54)  \
-  _STAB_CODE_DEF(SSYM,0x60)   \
-  _STAB_CODE_DEF(SO,0x64)     \
-  _STAB_CODE_DEF(LSYM,0x80)   \
-  _STAB_CODE_DEF(BINCL,0x82)  \
-  _STAB_CODE_DEF(SOL,0x84)    \
-  _STAB_CODE_DEF(PSYM,0xa0)   \
-  _STAB_CODE_DEF(EINCL,0xa2)  \
-  _STAB_CODE_DEF(ENTRY,0xa4)  \
-  _STAB_CODE_DEF(LBRAC,0xc0)  \
-  _STAB_CODE_DEF(EXCL,0xc2)   \
-  _STAB_CODE_DEF(SCOPE,0xc4)  \
-  _STAB_CODE_DEF(RBRAC,0xe0)  \
-  _STAB_CODE_DEF(BCOMM,0xe2)  \
-  _STAB_CODE_DEF(ECOMM,0xe4)  \
-  _STAB_CODE_DEF(ECOML,0xe8)  \
-  _STAB_CODE_DEF(NBTEXT,0xf0) \
-  _STAB_CODE_DEF(NBDATA,0xf2) \
-  _STAB_CODE_DEF(NBBSS,0xf4)  \
-  _STAB_CODE_DEF(NBSTS,0xf6)  \
-  _STAB_CODE_DEF(NBLCS,0xf8)  \
-  _STAB_CODE_DEF(LENG,0xfe)
-
-enum __stab_debug_code {
-#define _STAB_CODE_DEF(x,y)  N_##x = y,
-_STAB_CODE_LIST
-#undef _STAB_CODE_DEF
-};
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // __BIONIC_HAVE_STAB_H
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_STAB_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/sys/procfs.h b/TMessagesProj/jni/breakpad/common/android/include/sys/procfs.h
deleted file mode 100644
index 27223ea34..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/sys/procfs.h
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_SYS_PROCFS_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_SYS_PROCFS_H
-
-#ifdef __BIONIC_HAVE_SYS_PROCFS_H
-
-#include_next <sys/procfs.h>
-
-#else
-
-#include <asm/ptrace.h>
-#include <sys/cdefs.h>
-#if defined (__mips__)
-#include <sys/types.h>
-#endif
-#include <sys/user.h>
-#include <unistd.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-#if defined(__x86_64__) || defined(__aarch64__)
-typedef unsigned long long elf_greg_t;
-#else
-typedef unsigned long  elf_greg_t;
-#endif
-
-#ifdef __arm__
-#define ELF_NGREG (sizeof(struct user_regs) / sizeof(elf_greg_t))
-#elif defined(__aarch64__)
-#define ELF_NGREG (sizeof(struct user_pt_regs) / sizeof(elf_greg_t))
-#elif defined(__mips__)
-#define ELF_NGREG 45
-#else
-#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
-#endif
-
-typedef elf_greg_t elf_gregset_t[ELF_NGREG];
-
-struct elf_siginfo {
-  int si_signo;
-  int si_code;
-  int si_errno;
-};
-
-struct elf_prstatus {
-  struct elf_siginfo pr_info;
-  short              pr_cursig;
-  unsigned long      pr_sigpend;
-  unsigned long      pr_sighold;
-  pid_t              pr_pid;
-  pid_t              pr_ppid;
-  pid_t              pr_pgrp;
-  pid_t              pd_sid;
-  struct timeval     pr_utime;
-  struct timeval     pr_stime;
-  struct timeval     pr_cutime;
-  struct timeval     pr_cstime;
-  elf_gregset_t      pr_reg;
-  int                pr_fpvalid;
-};
-
-#define ELF_PRARGSZ 80
-
-struct elf_prpsinfo {
-  char           pr_state;
-  char           pr_sname;
-  char           pr_zomb;
-  char           pr_nice;
-  unsigned long  pr_flags;
-#ifdef __x86_64__
-  unsigned int   pr_uid;
-  unsigned int   pr_gid;
-#elif defined(__mips__)
-  unsigned long  pr_uid;
-  unsigned long  pr_gid;
-#else
-  unsigned short pr_uid;
-  unsigned short pr_gid;
-#endif
-  int pr_pid;
-  int pr_ppid;
-  int pr_pgrp;
-  int pr_sid;
-  char pr_fname[16];
-  char pr_psargs[ELF_PRARGSZ];
-};
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // __BIONIC_HAVE_SYS_PROCFS_H
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_SYS_PROCFS_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/sys/signal.h b/TMessagesProj/jni/breakpad/common/android/include/sys/signal.h
deleted file mode 100644
index 20c81e937..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/sys/signal.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
-
-#include <signal.h>
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/sys/user.h b/TMessagesProj/jni/breakpad/common/android/include/sys/user.h
deleted file mode 100644
index 5f0360475..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/sys/user.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_USER_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_USER_H
-
-// The purpose of this file is to glue the mismatching headers (Android NDK vs
-// glibc) and therefore avoid doing otherwise awkward #ifdefs in the code.
-// The following quirks are currently handled by this file:
-// - i386: Use the Android NDK but alias user_fxsr_struct > user_fpxregs_struct.
-// - aarch64: Add missing user_regs_struct and user_fpsimd_struct structs.
-// - Other platforms: Just use the Android NDK unchanged.
-
-// TODO(primiano): remove these changes after Chromium has stably rolled to
-// an NDK with the appropriate fixes.
-
-#include_next <sys/user.h>
-
-#ifdef __i386__
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-typedef struct user_fxsr_struct user_fpxregs_struct;
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-#endif  // __i386__
-
-#ifdef __aarch64__
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-struct user_regs_struct {
- __u64 regs[31];
- __u64 sp;
- __u64 pc;
- __u64 pstate;
-};
-struct user_fpsimd_struct {
- __uint128_t vregs[32];
- __u32 fpsr;
- __u32 fpcr;
-};
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-#endif  // __aarch64__
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_USER_H
diff --git a/TMessagesProj/jni/breakpad/common/android/include/ucontext.h b/TMessagesProj/jni/breakpad/common/android/include/ucontext.h
deleted file mode 100644
index 29db8adee..000000000
--- a/TMessagesProj/jni/breakpad/common/android/include/ucontext.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
-
-#include <sys/cdefs.h>
-
-#ifdef __BIONIC_UCONTEXT_H
-#include <ucontext.h>
-#else
-
-#include <sys/ucontext.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-// Provided by src/android/common/breakpad_getcontext.S
-int breakpad_getcontext(ucontext_t* ucp);
-
-#define getcontext(x)   breakpad_getcontext(x)
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // __BIONIC_UCONTEXT_H
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
diff --git a/TMessagesProj/jni/breakpad/common/android/ucontext_constants.h b/TMessagesProj/jni/breakpad/common/android/ucontext_constants.h
deleted file mode 100644
index 1932d5739..000000000
--- a/TMessagesProj/jni/breakpad/common/android/ucontext_constants.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// This header can be included either from a C, C++ or Assembly file.
-// Its purpose is to contain constants that must match the offsets of
-// various fields in ucontext_t.
-//
-// They should match the definitions from
-// src/common/android/include/sys/ucontext.h
-//
-// Used by src/common/android/breakpad_getcontext.S
-// Tested by src/common/android/testing/breakpad_getcontext_unittest.cc
-
-#ifndef GOOGLEBREAKPAD_COMMON_ANDROID_UCONTEXT_CONSTANTS_H
-#define GOOGLEBREAKPAD_COMMON_ANDROID_UCONTEXT_CONSTANTS_H
-
-#if defined(__arm__)
-
-#define  MCONTEXT_GREGS_OFFSET     32
-#define  UCONTEXT_SIGMASK_OFFSET   104
-
-#elif defined(__aarch64__)
-
-#define  UCONTEXT_SIGMASK_OFFSET     40
-
-#define  MCONTEXT_GREGS_OFFSET       184
-#define  MCONTEXT_SP_OFFSET          432
-#define  MCONTEXT_PC_OFFSET          440
-#define  MCONTEXT_PSTATE_OFFSET      448
-#define  MCONTEXT_EXTENSION_OFFSET   464
-
-#define  FPSIMD_MAGIC                0x46508001
-
-#define  FPSIMD_CONTEXT_MAGIC_OFFSET 0
-#define  FPSIMD_CONTEXT_SIZE_OFFSET  4
-#define  FPSIMD_CONTEXT_FPSR_OFFSET  8
-#define  FPSIMD_CONTEXT_FPCR_OFFSET  12
-#define  FPSIMD_CONTEXT_VREGS_OFFSET 16
-#define  FPSIMD_CONTEXT_SIZE         528
-
-#define  REGISTER_SIZE               8
-#define  SIMD_REGISTER_SIZE          16
-
-#elif defined(__i386__)
-
-#define  MCONTEXT_GREGS_OFFSET     20
-#define  MCONTEXT_GS_OFFSET        (MCONTEXT_GREGS_OFFSET + 0*4)
-#define  MCONTEXT_FS_OFFSET        (MCONTEXT_GREGS_OFFSET + 1*4)
-#define  MCONTEXT_ES_OFFSET        (MCONTEXT_GREGS_OFFSET + 2*4)
-#define  MCONTEXT_DS_OFFSET        (MCONTEXT_GREGS_OFFSET + 3*4)
-#define  MCONTEXT_EDI_OFFSET       (MCONTEXT_GREGS_OFFSET + 4*4)
-#define  MCONTEXT_ESI_OFFSET       (MCONTEXT_GREGS_OFFSET + 5*4)
-#define  MCONTEXT_EBP_OFFSET       (MCONTEXT_GREGS_OFFSET + 6*4)
-#define  MCONTEXT_ESP_OFFSET       (MCONTEXT_GREGS_OFFSET + 7*4)
-#define  MCONTEXT_EBX_OFFSET       (MCONTEXT_GREGS_OFFSET + 8*4)
-#define  MCONTEXT_EDX_OFFSET       (MCONTEXT_GREGS_OFFSET + 9*4)
-#define  MCONTEXT_ECX_OFFSET       (MCONTEXT_GREGS_OFFSET + 10*4)
-#define  MCONTEXT_EAX_OFFSET       (MCONTEXT_GREGS_OFFSET + 11*4)
-#define  MCONTEXT_TRAPNO_OFFSET    (MCONTEXT_GREGS_OFFSET + 12*4)
-#define  MCONTEXT_ERR_OFFSET       (MCONTEXT_GREGS_OFFSET + 13*4)
-#define  MCONTEXT_EIP_OFFSET       (MCONTEXT_GREGS_OFFSET + 14*4)
-#define  MCONTEXT_CS_OFFSET        (MCONTEXT_GREGS_OFFSET + 15*4)
-#define  MCONTEXT_EFL_OFFSET       (MCONTEXT_GREGS_OFFSET + 16*4)
-#define  MCONTEXT_UESP_OFFSET      (MCONTEXT_GREGS_OFFSET + 17*4)
-#define  MCONTEXT_SS_OFFSET        (MCONTEXT_GREGS_OFFSET + 18*4)
-
-#define  UCONTEXT_SIGMASK_OFFSET   108
-
-#define  UCONTEXT_FPREGS_OFFSET       96
-#define  UCONTEXT_FPREGS_MEM_OFFSET   116
-
-#elif defined(__mips__)
-
-#if _MIPS_SIM == _ABIO32
-#define  MCONTEXT_PC_OFFSET        32
-#define  MCONTEXT_GREGS_OFFSET     40
-#define  MCONTEXT_FPREGS_OFFSET    296
-#define  MCONTEXT_FPC_CSR          556
-#define  UCONTEXT_SIGMASK_OFFSET   616
-#else
-#define  MCONTEXT_GREGS_OFFSET     40
-#define  MCONTEXT_FPREGS_OFFSET    296
-#define  MCONTEXT_PC_OFFSET        616
-#define  MCONTEXT_FPC_CSR          624
-#define  UCONTEXT_SIGMASK_OFFSET   640
-#endif
-
-#elif defined(__x86_64__)
-
-#define MCONTEXT_GREGS_OFFSET     40
-#define UCONTEXT_SIGMASK_OFFSET   296
-
-#define MCONTEXT_GREGS_R8    40
-#define MCONTEXT_GREGS_R9    48
-#define MCONTEXT_GREGS_R10   56
-#define MCONTEXT_GREGS_R11   64
-#define MCONTEXT_GREGS_R12   72
-#define MCONTEXT_GREGS_R13   80
-#define MCONTEXT_GREGS_R14   88
-#define MCONTEXT_GREGS_R15   96
-#define MCONTEXT_GREGS_RDI   104
-#define MCONTEXT_GREGS_RSI   112
-#define MCONTEXT_GREGS_RBP   120
-#define MCONTEXT_GREGS_RBX   128
-#define MCONTEXT_GREGS_RDX   136
-#define MCONTEXT_GREGS_RAX   144
-#define MCONTEXT_GREGS_RCX   152
-#define MCONTEXT_GREGS_RSP   160
-#define MCONTEXT_GREGS_RIP   168
-#define MCONTEXT_FPREGS_PTR  224
-#define MCONTEXT_FPREGS_MEM  304
-#define FPREGS_OFFSET_MXCSR  24
-
-#else
-#error "This header has not been ported for your CPU"
-#endif
-
-#endif  // GOOGLEBREAKPAD_COMMON_ANDROID_UCONTEXT_CONSTANTS_H
diff --git a/TMessagesProj/jni/breakpad/common/basictypes.h b/TMessagesProj/jni/breakpad/common/basictypes.h
deleted file mode 100644
index 9426c1f6c..000000000
--- a/TMessagesProj/jni/breakpad/common/basictypes.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright (c) 2011 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_BASICTYPES_H_
-#define COMMON_BASICTYPES_H_
-
-// A macro to disallow the copy constructor and operator= functions
-// This should be used in the private: declarations for a class
-#ifndef DISALLOW_COPY_AND_ASSIGN
-#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
-  TypeName(const TypeName&);               \
-  void operator=(const TypeName&)
-#endif  // DISALLOW_COPY_AND_ASSIGN
-
-namespace google_breakpad {
-
-// Used to explicitly mark the return value of a function as unused. If you are
-// really sure you don't want to do anything with the return value of a function
-// that has been marked with __attribute__((warn_unused_result)), wrap it with
-// this. Example:
-//
-//   scoped_ptr<MyType> my_var = ...;
-//   if (TakeOwnership(my_var.get()) == SUCCESS)
-//     ignore_result(my_var.release());
-//
-template<typename T>
-inline void ignore_result(const T&) {
-}
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_BASICTYPES_H_
diff --git a/TMessagesProj/jni/breakpad/common/byte_cursor.h b/TMessagesProj/jni/breakpad/common/byte_cursor.h
deleted file mode 100644
index accd54e0a..000000000
--- a/TMessagesProj/jni/breakpad/common/byte_cursor.h
+++ /dev/null
@@ -1,265 +0,0 @@
-// -*- mode: c++ -*-
-
-// Copyright (c) 2010, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Original author: Jim Blandy <jimb@mozilla.com> <jimb@red-bean.com>
-
-// byte_cursor.h: Classes for parsing values from a buffer of bytes.
-// The ByteCursor class provides a convenient interface for reading
-// fixed-size integers of arbitrary endianness, being thorough about
-// checking for buffer overruns.
-
-#ifndef COMMON_BYTE_CURSOR_H_
-#define COMMON_BYTE_CURSOR_H_
-
-#include <assert.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <string>
-
-#include "common/using_std_string.h"
-
-namespace google_breakpad {
-
-// A buffer holding a series of bytes.
-struct ByteBuffer {
-  ByteBuffer() : start(0), end(0) { }
-  ByteBuffer(const uint8_t *set_start, size_t set_size)
-      : start(set_start), end(set_start + set_size) { }
-  ~ByteBuffer() { };
-
-  // Equality operators. Useful in unit tests, and when we're using
-  // ByteBuffers to refer to regions of a larger buffer.
-  bool operator==(const ByteBuffer &that) const {
-    return start == that.start && end == that.end;
-  }
-  bool operator!=(const ByteBuffer &that) const {
-    return start != that.start || end != that.end;
-  }
-
-  // Not C++ style guide compliant, but this definitely belongs here.
-  size_t Size() const {
-    assert(start <= end);
-    return end - start;
-  }
-
-  const uint8_t *start, *end;
-};
-
-// A cursor pointing into a ByteBuffer that can parse numbers of various
-// widths and representations, strings, and data blocks, advancing through
-// the buffer as it goes. All ByteCursor operations check that accesses
-// haven't gone beyond the end of the enclosing ByteBuffer.
-class ByteCursor {
- public:
-  // Create a cursor reading bytes from the start of BUFFER. By default, the
-  // cursor reads multi-byte values in little-endian form.
-  ByteCursor(const ByteBuffer *buffer, bool big_endian = false)
-      : buffer_(buffer), here_(buffer->start), 
-        big_endian_(big_endian), complete_(true) { }
-
-  // Accessor and setter for this cursor's endianness flag.
-  bool big_endian() const { return big_endian_; }
-  void set_big_endian(bool big_endian) { big_endian_ = big_endian; }
-
-  // Accessor and setter for this cursor's current position. The setter
-  // returns a reference to this cursor.
-  const uint8_t *here() const { return here_; }
-  ByteCursor &set_here(const uint8_t *here) {
-    assert(buffer_->start <= here && here <= buffer_->end);
-    here_ = here;
-    return *this;
-  }
-
-  // Return the number of bytes available to read at the cursor.
-  size_t Available() const { return size_t(buffer_->end - here_); }
-
-  // Return true if this cursor is at the end of its buffer.
-  bool AtEnd() const { return Available() == 0; }
-
-  // When used as a boolean value this cursor converts to true if all
-  // prior reads have been completed, or false if we ran off the end
-  // of the buffer.
-  operator bool() const { return complete_; }
-
-  // Read a SIZE-byte integer at this cursor, signed if IS_SIGNED is true,
-  // unsigned otherwise, using the cursor's established endianness, and set
-  // *RESULT to the number. If we read off the end of our buffer, clear
-  // this cursor's complete_ flag, and store a dummy value in *RESULT.
-  // Return a reference to this cursor.
-  template<typename T>
-  ByteCursor &Read(size_t size, bool is_signed, T *result) {
-    if (CheckAvailable(size)) {
-      T v = 0;
-      if (big_endian_) {
-        for (size_t i = 0; i < size; i++)
-          v = (v << 8) + here_[i];
-      } else {
-        // This loop condition looks weird, but size_t is unsigned, so
-        // decrementing i after it is zero yields the largest size_t value.
-        for (size_t i = size - 1; i < size; i--)
-          v = (v << 8) + here_[i];
-      }
-      if (is_signed && size < sizeof(T)) {
-        size_t sign_bit = (T)1 << (size * 8 - 1);
-        v = (v ^ sign_bit) - sign_bit;
-      }
-      here_ += size;
-      *result = v;
-    } else {
-      *result = (T) 0xdeadbeef;
-    }
-    return *this;
-  }
-
-  // Read an integer, using the cursor's established endianness and
-  // *RESULT's size and signedness, and set *RESULT to the number. If we
-  // read off the end of our buffer, clear this cursor's complete_ flag.
-  // Return a reference to this cursor.
-  template<typename T>
-  ByteCursor &operator>>(T &result) {
-    bool T_is_signed = (T)-1 < 0;
-    return Read(sizeof(T), T_is_signed, &result); 
-  }
-
-  // Copy the SIZE bytes at the cursor to BUFFER, and advance this
-  // cursor to the end of them. If we read off the end of our buffer,
-  // clear this cursor's complete_ flag, and set *POINTER to NULL.
-  // Return a reference to this cursor.
-  ByteCursor &Read(uint8_t *buffer, size_t size) {
-    if (CheckAvailable(size)) {
-      memcpy(buffer, here_, size);
-      here_ += size;
-    }
-    return *this;
-  }
-
-  // Set STR to a copy of the '\0'-terminated string at the cursor. If the
-  // byte buffer does not contain a terminating zero, clear this cursor's
-  // complete_ flag, and set STR to the empty string. Return a reference to
-  // this cursor.
-  ByteCursor &CString(string *str) {
-    const uint8_t *end
-      = static_cast<const uint8_t *>(memchr(here_, '\0', Available()));
-    if (end) {
-      str->assign(reinterpret_cast<const char *>(here_), end - here_);
-      here_ = end + 1;
-    } else {
-      str->clear();
-      here_ = buffer_->end;
-      complete_ = false;
-    }
-    return *this;
-  }
-
-  // Like CString(STR), but extract the string from a fixed-width buffer
-  // LIMIT bytes long, which may or may not contain a terminating '\0'
-  // byte. Specifically:
-  //
-  // - If there are not LIMIT bytes available at the cursor, clear the
-  //   cursor's complete_ flag and set STR to the empty string.
-  //
-  // - Otherwise, if the LIMIT bytes at the cursor contain any '\0'
-  //   characters, set *STR to a copy of the bytes before the first '\0',
-  //   and advance the cursor by LIMIT bytes.
-  //   
-  // - Otherwise, set *STR to a copy of those LIMIT bytes, and advance the
-  //   cursor by LIMIT bytes.
-  ByteCursor &CString(string *str, size_t limit) {
-    if (CheckAvailable(limit)) {
-      const uint8_t *end
-        = static_cast<const uint8_t *>(memchr(here_, '\0', limit));
-      if (end)
-        str->assign(reinterpret_cast<const char *>(here_), end - here_);
-      else
-        str->assign(reinterpret_cast<const char *>(here_), limit);
-      here_ += limit;
-    } else {
-      str->clear();
-    }
-    return *this;
-  }
-
-  // Set *POINTER to point to the SIZE bytes at the cursor, and advance
-  // this cursor to the end of them. If SIZE is omitted, don't move the
-  // cursor. If we read off the end of our buffer, clear this cursor's
-  // complete_ flag, and set *POINTER to NULL. Return a reference to this
-  // cursor.
-  ByteCursor &PointTo(const uint8_t **pointer, size_t size = 0) {
-    if (CheckAvailable(size)) {
-      *pointer = here_;
-      here_ += size;
-    } else {
-      *pointer = NULL;
-    }
-    return *this;
-  }
-
-  // Skip SIZE bytes at the cursor. If doing so would advance us off
-  // the end of our buffer, clear this cursor's complete_ flag, and
-  // set *POINTER to NULL. Return a reference to this cursor.
-  ByteCursor &Skip(size_t size) {
-    if (CheckAvailable(size))
-      here_ += size;
-    return *this;
-  }
-
- private:
-  // If there are at least SIZE bytes available to read from the buffer,
-  // return true. Otherwise, set here_ to the end of the buffer, set
-  // complete_ to false, and return false.
-  bool CheckAvailable(size_t size) {
-    if (Available() >= size) {
-      return true;
-    } else {
-      here_ = buffer_->end;
-      complete_ = false;
-      return false;
-    }
-  }
-
-  // The buffer we're reading bytes from.
-  const ByteBuffer *buffer_;
-
-  // The next byte within buffer_ that we'll read.
-  const uint8_t *here_;
-
-  // True if we should read numbers in big-endian form; false if we
-  // should read in little-endian form.
-  bool big_endian_;
-
-  // True if we've been able to read all we've been asked to.
-  bool complete_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_BYTE_CURSOR_H_
diff --git a/TMessagesProj/jni/breakpad/common/convert_UTF.c b/TMessagesProj/jni/breakpad/common/convert_UTF.c
deleted file mode 100644
index 12a3c8917..000000000
--- a/TMessagesProj/jni/breakpad/common/convert_UTF.c
+++ /dev/null
@@ -1,554 +0,0 @@
-/*
- * Copyright  1991-2015 Unicode, Inc. All rights reserved.
- * Distributed under the Terms of Use in 
- * http://www.unicode.org/copyright.html.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of the Unicode data files and any associated documentation
- * (the "Data Files") or Unicode software and any associated documentation
- * (the "Software") to deal in the Data Files or Software
- * without restriction, including without limitation the rights to use,
- * copy, modify, merge, publish, distribute, and/or sell copies of
- * the Data Files or Software, and to permit persons to whom the Data Files
- * or Software are furnished to do so, provided that
- * (a) this copyright and permission notice appear with all copies 
- * of the Data Files or Software,
- * (b) this copyright and permission notice appear in associated 
- * documentation, and
- * (c) there is clear notice in each modified Data File or in the Software
- * as well as in the documentation associated with the Data File(s) or
- * Software that the data or software has been modified.
- *
- * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
- * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
- * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT OF THIRD PARTY RIGHTS.
- * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
- * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
- * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THE DATA FILES OR SOFTWARE.
- *
- * Except as contained in this notice, the name of a copyright holder
- * shall not be used in advertising or otherwise to promote the sale,
- * use or other dealings in these Data Files or Software without prior
- * written authorization of the copyright holder.
- */
-
-/* ---------------------------------------------------------------------
-
-Conversions between UTF32, UTF-16, and UTF-8. Source code file.
-Author: Mark E. Davis, 1994.
-Rev History: Rick McGowan, fixes & updates May 2001.
-Sept 2001: fixed const & error conditions per
-mods suggested by S. Parent & A. Lillich.
-June 2002: Tim Dodd added detection and handling of incomplete
-source sequences, enhanced error detection, added casts
-to eliminate compiler warnings.
-July 2003: slight mods to back out aggressive FFFE detection.
-Jan 2004: updated switches in from-UTF8 conversions.
-Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
-
-See the header file "ConvertUTF.h" for complete documentation.
-
------------------------------------------------------------------------- */
-
-
-#include "convert_UTF.h"
-#ifdef CVTUTF_DEBUG
-#include <stdio.h>
-#endif
-
-static const int halfShift  = 10; /* used for shifting by 10 bits */
-
-static const UTF32 halfBase = 0x0010000UL;
-static const UTF32 halfMask = 0x3FFUL;
-
-#define UNI_SUR_HIGH_START  (UTF32)0xD800
-#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
-#define UNI_SUR_LOW_START   (UTF32)0xDC00
-#define UNI_SUR_LOW_END     (UTF32)0xDFFF
-
-#ifndef false
-#define false	   0
-#endif
-#ifndef true
-#define true	    1
-#endif
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* sourceEnd,
-                                      UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF32* source = *sourceStart;
-  UTF16* target = *targetStart;
-  while (source < sourceEnd) {
-    UTF32 ch;
-    if (target >= targetEnd) {
-	    result = targetExhausted; break;
-    }
-    ch = *source++;
-    if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
-	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
-	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
-        if (flags == strictConversion) {
-          --source; /* return to the illegal value itself */
-          result = sourceIllegal;
-          break;
-        } else {
-          *target++ = UNI_REPLACEMENT_CHAR;
-        }
-	    } else {
-        *target++ = (UTF16)ch; /* normal case */
-	    }
-    } else if (ch > UNI_MAX_LEGAL_UTF32) {
-	    if (flags == strictConversion) {
-        result = sourceIllegal;
-	    } else {
-        *target++ = UNI_REPLACEMENT_CHAR;
-	    }
-    } else {
-	    /* target is a character in range 0xFFFF - 0x10FFFF. */
-	    if (target + 1 >= targetEnd) {
-        --source; /* Back up source pointer! */
-        result = targetExhausted; break;
-	    }
-	    ch -= halfBase;
-	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
-	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
-    }
-  }
-*sourceStart = source;
-*targetStart = target;
-return result;
-}
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* sourceEnd,
-                                      UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF16* source = *sourceStart;
-  UTF32* target = *targetStart;
-  UTF32 ch, ch2;
-  while (source < sourceEnd) {
-    const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
-    ch = *source++;
-    /* If we have a surrogate pair, convert to UTF32 first. */
-    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
-	    /* If the 16 bits following the high surrogate are in the source buffer... */
-	    if (source < sourceEnd) {
-        ch2 = *source;
-        /* If it's a low surrogate, convert to UTF32. */
-        if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
-          ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
-          + (ch2 - UNI_SUR_LOW_START) + halfBase;
-          ++source;
-        } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
-          --source; /* return to the illegal value itself */
-          result = sourceIllegal;
-          break;
-        }
-	    } else { /* We don't have the 16 bits following the high surrogate. */
-        --source; /* return to the high surrogate */
-        result = sourceExhausted;
-        break;
-	    }
-    } else if (flags == strictConversion) {
-	    /* UTF-16 surrogate values are illegal in UTF-32 */
-	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
-        --source; /* return to the illegal value itself */
-        result = sourceIllegal;
-        break;
-	    }
-    }
-    if (target >= targetEnd) {
-	    source = oldSource; /* Back up source pointer! */
-	    result = targetExhausted; break;
-    }
-    *target++ = ch;
-  }
-  *sourceStart = source;
-  *targetStart = target;
-#ifdef CVTUTF_DEBUG
-  if (result == sourceIllegal) {
-    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
-    fflush(stderr);
-  }
-#endif
-  return result;
-}
-
-/* --------------------------------------------------------------------- */
-
-/*
- * Index into the table below with the first byte of a UTF-8 sequence to
- * get the number of trailing bytes that are supposed to follow it.
- * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
- * left as-is for anyone who may want to do such conversion, which was
- * allowed in earlier algorithms.
- */
-static const char trailingBytesForUTF8[256] = {
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
-};
-
-/*
- * Magic values subtracted from a buffer value during UTF8 conversion.
- * This table contains as many values as there might be trailing bytes
- * in a UTF-8 sequence.
- */
-static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
-  0x03C82080UL, 0xFA082080UL, 0x82082080UL };
-
-/*
- * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
- * into the first byte, depending on how many bytes follow.  There are
- * as many entries in this table as there are UTF-8 sequence types.
- * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
- * for *legal* UTF-8 will be 4 or fewer bytes total.
- */
-static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-
-/* --------------------------------------------------------------------- */
-
-/* The interface converts a whole buffer to avoid function-call overhead.
-* Constants have been gathered. Loops & conditionals have been removed as
-* much as possible for efficiency, in favor of drop-through switches.
-* (See "Note A" at the bottom of the file for equivalent code.)
-* If your compiler supports it, the "isLegalUTF8" call can be turned
-* into an inline function.
-*/
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF16toUTF8 (const UTF16** sourceStart, const UTF16* sourceEnd,
-                                     UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF16* source = *sourceStart;
-  UTF8* target = *targetStart;
-  while (source < sourceEnd) {
-    UTF32 ch;
-    unsigned short bytesToWrite = 0;
-    const UTF32 byteMask = 0xBF;
-    const UTF32 byteMark = 0x80;
-    const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
-    ch = *source++;
-    /* If we have a surrogate pair, convert to UTF32 first. */
-    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
-	    /* If the 16 bits following the high surrogate are in the source buffer... */
-	    if (source < sourceEnd) {
-        UTF32 ch2 = *source;
-        /* If it's a low surrogate, convert to UTF32. */
-        if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
-          ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
-          + (ch2 - UNI_SUR_LOW_START) + halfBase;
-          ++source;
-        } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
-          --source; /* return to the illegal value itself */
-          result = sourceIllegal;
-          break;
-        }
-	    } else { /* We don't have the 16 bits following the high surrogate. */
-        --source; /* return to the high surrogate */
-        result = sourceExhausted;
-        break;
-	    }
-    } else if (flags == strictConversion) {
-	    /* UTF-16 surrogate values are illegal in UTF-32 */
-	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
-        --source; /* return to the illegal value itself */
-        result = sourceIllegal;
-        break;
-	    }
-    }
-    /* Figure out how many bytes the result will require */
-    if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
-    } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
-    } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
-    } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
-    } else {			    bytesToWrite = 3;
-      ch = UNI_REPLACEMENT_CHAR;
-    }
-
-    target += bytesToWrite;
-    if (target > targetEnd) {
-	    source = oldSource; /* Back up source pointer! */
-	    target -= bytesToWrite; result = targetExhausted; break;
-    }
-    switch (bytesToWrite) { /* note: everything falls through. */
-	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
-    }
-    target += bytesToWrite;
-  }
-*sourceStart = source;
-*targetStart = target;
-return result;
-}
-
-/* --------------------------------------------------------------------- */
-
-/*
- * Utility routine to tell whether a sequence of bytes is legal UTF-8.
- * This must be called with the length pre-determined by the first byte.
- * If not calling this from ConvertUTF8to*, then the length can be set by:
- *  length = trailingBytesForUTF8[*source]+1;
- * and the sequence is illegal right away if there aren't that many bytes
- * available.
- * If presented with a length > 4, this returns false.  The Unicode
- * definition of UTF-8 goes up to 4-byte sequences.
- */
-
-static Boolean isLegalUTF8(const UTF8 *source, int length) {
-  UTF8 a;
-  const UTF8 *srcptr = source+length;
-  switch (length) {
-    default: return false;
-      /* Everything else falls through when "true"... */
-    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
-
-      switch (*source) {
-        /* no fall-through in this inner switch */
-        case 0xE0: if (a < 0xA0) return false; break;
-        case 0xED: if (a > 0x9F) return false; break;
-        case 0xF0: if (a < 0x90) return false; break;
-        case 0xF4: if (a > 0x8F) return false; break;
-        default:   if (a < 0x80) return false;
-      }
-
-      case 1: if (*source >= 0x80 && *source < 0xC2) return false;
-  }
-  if (*source > 0xF4) return false;
-  return true;
-}
-
-/* --------------------------------------------------------------------- */
-
-/*
- * Exported function to return whether a UTF-8 sequence is legal or not.
- * This is not used here; it's just exported.
- */
-Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
-  int length = trailingBytesForUTF8[*source]+1;
-  if (source+length > sourceEnd) {
-    return false;
-  }
-  return isLegalUTF8(source, length);
-}
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF8toUTF16 (const UTF8** sourceStart, const UTF8* sourceEnd,
-                                     UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF8* source = *sourceStart;
-  UTF16* target = *targetStart;
-  while (source < sourceEnd) {
-    UTF32 ch = 0;
-    unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
-    if (source + extraBytesToRead >= sourceEnd) {
-	    result = sourceExhausted; break;
-    }
-    /* Do this check whether lenient or strict */
-    if (! isLegalUTF8(source, extraBytesToRead+1)) {
-	    result = sourceIllegal;
-	    break;
-    }
-    /*
-     * The cases all fall through. See "Note A" below.
-     */
-    switch (extraBytesToRead) {
-	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
-	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
-	    case 3: ch += *source++; ch <<= 6;
-	    case 2: ch += *source++; ch <<= 6;
-	    case 1: ch += *source++; ch <<= 6;
-	    case 0: ch += *source++;
-    }
-    ch -= offsetsFromUTF8[extraBytesToRead];
-
-    if (target >= targetEnd) {
-	    source -= (extraBytesToRead+1); /* Back up source pointer! */
-	    result = targetExhausted; break;
-    }
-    if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
-	    /* UTF-16 surrogate values are illegal in UTF-32 */
-	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
-        if (flags == strictConversion) {
-          source -= (extraBytesToRead+1); /* return to the illegal value itself */
-          result = sourceIllegal;
-          break;
-        } else {
-          *target++ = UNI_REPLACEMENT_CHAR;
-        }
-	    } else {
-        *target++ = (UTF16)ch; /* normal case */
-	    }
-    } else if (ch > UNI_MAX_UTF16) {
-	    if (flags == strictConversion) {
-        result = sourceIllegal;
-        source -= (extraBytesToRead+1); /* return to the start */
-        break; /* Bail out; shouldn't continue */
-	    } else {
-        *target++ = UNI_REPLACEMENT_CHAR;
-	    }
-    } else {
-	    /* target is a character in range 0xFFFF - 0x10FFFF. */
-	    if (target + 1 >= targetEnd) {
-        source -= (extraBytesToRead+1); /* Back up source pointer! */
-        result = targetExhausted; break;
-	    }
-	    ch -= halfBase;
-	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
-	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
-    }
-  }
-*sourceStart = source;
-*targetStart = target;
-return result;
-}
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF32toUTF8 (const UTF32** sourceStart, const UTF32* sourceEnd,
-                                     UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF32* source = *sourceStart;
-  UTF8* target = *targetStart;
-  while (source < sourceEnd) {
-    UTF32 ch;
-    unsigned short bytesToWrite = 0;
-    const UTF32 byteMask = 0xBF;
-    const UTF32 byteMark = 0x80;
-    ch = *source++;
-    if (flags == strictConversion ) {
-	    /* UTF-16 surrogate values are illegal in UTF-32 */
-	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
-        --source; /* return to the illegal value itself */
-        result = sourceIllegal;
-        break;
-	    }
-    }
-    /*
-     * Figure out how many bytes the result will require. Turn any
-     * illegally large UTF32 things (> Plane 17) into replacement chars.
-     */
-    if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
-    } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
-    } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
-    } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
-    } else {			    bytesToWrite = 3;
-      ch = UNI_REPLACEMENT_CHAR;
-      result = sourceIllegal;
-    }
-
-    target += bytesToWrite;
-    if (target > targetEnd) {
-	    --source; /* Back up source pointer! */
-	    target -= bytesToWrite; result = targetExhausted; break;
-    }
-    switch (bytesToWrite) { /* note: everything falls through. */
-	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
-    }
-    target += bytesToWrite;
-  }
-*sourceStart = source;
-*targetStart = target;
-return result;
-}
-
-/* --------------------------------------------------------------------- */
-
-ConversionResult ConvertUTF8toUTF32 (const UTF8** sourceStart, const UTF8* sourceEnd,
-                                     UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
-  ConversionResult result = conversionOK;
-  const UTF8* source = *sourceStart;
-  UTF32* target = *targetStart;
-  while (source < sourceEnd) {
-    UTF32 ch = 0;
-    unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
-    if (source + extraBytesToRead >= sourceEnd) {
-	    result = sourceExhausted; break;
-    }
-    /* Do this check whether lenient or strict */
-    if (! isLegalUTF8(source, extraBytesToRead+1)) {
-	    result = sourceIllegal;
-	    break;
-    }
-    /*
-     * The cases all fall through. See "Note A" below.
-     */
-    switch (extraBytesToRead) {
-	    case 5: ch += *source++; ch <<= 6;
-	    case 4: ch += *source++; ch <<= 6;
-	    case 3: ch += *source++; ch <<= 6;
-	    case 2: ch += *source++; ch <<= 6;
-	    case 1: ch += *source++; ch <<= 6;
-	    case 0: ch += *source++;
-    }
-    ch -= offsetsFromUTF8[extraBytesToRead];
-
-    if (target >= targetEnd) {
-	    source -= (extraBytesToRead+1); /* Back up the source pointer! */
-	    result = targetExhausted; break;
-    }
-    if (ch <= UNI_MAX_LEGAL_UTF32) {
-	    /*
-	     * UTF-16 surrogate values are illegal in UTF-32, and anything
-	     * over Plane 17 (> 0x10FFFF) is illegal.
-	     */
-	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
-        if (flags == strictConversion) {
-          source -= (extraBytesToRead+1); /* return to the illegal value itself */
-          result = sourceIllegal;
-          break;
-        } else {
-          *target++ = UNI_REPLACEMENT_CHAR;
-        }
-	    } else {
-        *target++ = ch;
-	    }
-    } else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
-	    result = sourceIllegal;
-	    *target++ = UNI_REPLACEMENT_CHAR;
-    }
-  }
-  *sourceStart = source;
-  *targetStart = target;
-  return result;
-}
-
-/* ---------------------------------------------------------------------
-
-Note A.
-The fall-through switches in UTF-8 reading code save a
-temp variable, some decrements & conditionals.  The switches
-are equivalent to the following loop:
-{
-  int tmpBytesToRead = extraBytesToRead+1;
-  do {
-		ch += *source++;
-		--tmpBytesToRead;
-		if (tmpBytesToRead) ch <<= 6;
-  } while (tmpBytesToRead > 0);
-}
-In UTF-8 writing code, the switches on "bytesToWrite" are
-similarly unrolled loops.
-
---------------------------------------------------------------------- */
diff --git a/TMessagesProj/jni/breakpad/common/convert_UTF.h b/TMessagesProj/jni/breakpad/common/convert_UTF.h
deleted file mode 100644
index 644d09950..000000000
--- a/TMessagesProj/jni/breakpad/common/convert_UTF.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright  1991-2015 Unicode, Inc. All rights reserved.
- * Distributed under the Terms of Use in 
- * http://www.unicode.org/copyright.html.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of the Unicode data files and any associated documentation
- * (the "Data Files") or Unicode software and any associated documentation
- * (the "Software") to deal in the Data Files or Software
- * without restriction, including without limitation the rights to use,
- * copy, modify, merge, publish, distribute, and/or sell copies of
- * the Data Files or Software, and to permit persons to whom the Data Files
- * or Software are furnished to do so, provided that
- * (a) this copyright and permission notice appear with all copies 
- * of the Data Files or Software,
- * (b) this copyright and permission notice appear in associated 
- * documentation, and
- * (c) there is clear notice in each modified Data File or in the Software
- * as well as in the documentation associated with the Data File(s) or
- * Software that the data or software has been modified.
- *
- * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
- * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
- * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT OF THIRD PARTY RIGHTS.
- * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
- * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
- * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THE DATA FILES OR SOFTWARE.
- *
- * Except as contained in this notice, the name of a copyright holder
- * shall not be used in advertising or otherwise to promote the sale,
- * use or other dealings in these Data Files or Software without prior
- * written authorization of the copyright holder.
- */
-
-#ifndef COMMON_CONVERT_UTF_H_
-#define COMMON_CONVERT_UTF_H_
-
-/* ---------------------------------------------------------------------
-
-Conversions between UTF32, UTF-16, and UTF-8.  Header file.
-
-Several funtions are included here, forming a complete set of
-conversions between the three formats.  UTF-7 is not included
-here, but is handled in a separate source file.
-
-Each of these routines takes pointers to input buffers and output
-buffers.  The input buffers are const.
-
-Each routine converts the text between *sourceStart and sourceEnd,
-putting the result into the buffer between *targetStart and
-targetEnd. Note: the end pointers are *after* the last item: e.g.
-*(sourceEnd - 1) is the last item.
-
-The return result indicates whether the conversion was successful,
-and if not, whether the problem was in the source or target buffers.
-(Only the first encountered problem is indicated.)
-
-After the conversion, *sourceStart and *targetStart are both
-updated to point to the end of last text successfully converted in
-the respective buffers.
-
-Input parameters:
-sourceStart - pointer to a pointer to the source buffer.
-The contents of this are modified on return so that
-it points at the next thing to be converted.
-targetStart - similarly, pointer to pointer to the target buffer.
-sourceEnd, targetEnd - respectively pointers to the ends of the
-two buffers, for overflow checking only.
-
-These conversion functions take a ConversionFlags argument. When this
-flag is set to strict, both irregular sequences and isolated surrogates
-will cause an error.  When the flag is set to lenient, both irregular
-sequences and isolated surrogates are converted.
-
-Whether the flag is strict or lenient, all illegal sequences will cause
-an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
-or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
-must check for illegal sequences.
-
-When the flag is set to lenient, characters over 0x10FFFF are converted
-to the replacement character; otherwise (when the flag is set to strict)
-they constitute an error.
-
-Output parameters:
-The value "sourceIllegal" is returned from some routines if the input
-sequence is malformed.  When "sourceIllegal" is returned, the source
-value will point to the illegal value that caused the problem. E.g.,
-in UTF-8 when a sequence is malformed, it points to the start of the
-malformed sequence.
-
-Author: Mark E. Davis, 1994.
-Rev History: Rick McGowan, fixes & updates May 2001.
-Fixes & updates, Sept 2001.
-
------------------------------------------------------------------------- */
-
-/* ---------------------------------------------------------------------
-The following 4 definitions are compiler-specific.
-The C standard does not guarantee that wchar_t has at least
-16 bits, so wchar_t is no less portable than unsigned short!
-All should be unsigned values to avoid sign extension during
-bit mask & shift operations.
------------------------------------------------------------------------- */
-
-typedef unsigned long	UTF32;	/* at least 32 bits */
-typedef unsigned short	UTF16;	/* at least 16 bits */
-typedef unsigned char	UTF8;	/* typically 8 bits */
-typedef unsigned char	Boolean; /* 0 or 1 */
-
-/* Some fundamental constants */
-#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
-#define UNI_MAX_BMP (UTF32)0x0000FFFF
-#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
-#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
-#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
-
-typedef enum {
-	conversionOK, 		/* conversion successful */
-	sourceExhausted,	/* partial character in source, but hit end */
-	targetExhausted,	/* insuff. room in target for conversion */
-	sourceIllegal		/* source sequence is illegal/malformed */
-} ConversionResult;
-
-typedef enum {
-	strictConversion = 0,
-	lenientConversion
-} ConversionFlags;
-
-/* This is for C++ and does no harm in C */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ConversionResult ConvertUTF8toUTF16 (const UTF8** sourceStart, const UTF8* sourceEnd,
-                                     UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
-
-ConversionResult ConvertUTF16toUTF8 (const UTF16** sourceStart, const UTF16* sourceEnd,
-                                     UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
-
-ConversionResult ConvertUTF8toUTF32 (const UTF8** sourceStart, const UTF8* sourceEnd,
-                                     UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
-
-ConversionResult ConvertUTF32toUTF8 (const UTF32** sourceStart, const UTF32* sourceEnd,
-                                     UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
-
-ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* sourceEnd,
-                                      UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
-
-ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* sourceEnd,
-                                      UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
-
-Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
-
-#ifdef __cplusplus
-}
-#endif
-
-/* --------------------------------------------------------------------- */
-
-#endif  // COMMON_CONVERT_UTF_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/eintr_wrapper.h b/TMessagesProj/jni/breakpad/common/linux/eintr_wrapper.h
deleted file mode 100644
index 3f1d18481..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/eintr_wrapper.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_LINUX_EINTR_WRAPPER_H_
-#define COMMON_LINUX_EINTR_WRAPPER_H_
-
-#include <errno.h>
-
-// This provides a wrapper around system calls which may be interrupted by a
-// signal and return EINTR. See man 7 signal.
-//
-
-#define HANDLE_EINTR(x) ({ \
-  __typeof__(x) eintr_wrapper_result; \
-  do { \
-    eintr_wrapper_result = (x); \
-  } while (eintr_wrapper_result == -1 && errno == EINTR); \
-  eintr_wrapper_result; \
-})
-
-#define IGNORE_EINTR(x) ({ \
-  __typeof__(x) eintr_wrapper_result; \
-  do { \
-    eintr_wrapper_result = (x); \
-    if (eintr_wrapper_result == -1 && errno == EINTR) { \
-      eintr_wrapper_result = 0; \
-    } \
-  } while (0); \
-  eintr_wrapper_result; \
-})
-
-#endif  // COMMON_LINUX_EINTR_WRAPPER_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/elf_gnu_compat.h b/TMessagesProj/jni/breakpad/common/linux/elf_gnu_compat.h
deleted file mode 100644
index f870cbc7d..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/elf_gnu_compat.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// -*- mode: C++ -*-
-
-// Copyright (c) 2013, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Original author: Lei Zhang <thestig@google.com>
-
-// elf_gnu_compat.h: #defines unique to glibc's elf.h.
-
-#ifndef COMMON_LINUX_ELF_GNU_COMPAT_H_
-#define COMMON_LINUX_ELF_GNU_COMPAT_H_
-
-#include <elf.h>
-
-// A note type on GNU systems corresponding to the .note.gnu.build-id section.
-#ifndef NT_GNU_BUILD_ID
-#define NT_GNU_BUILD_ID 3
-#endif
-
-#endif  // COMMON_LINUX_ELF_GNU_COMPAT_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/elfutils-inl.h b/TMessagesProj/jni/breakpad/common/linux/elfutils-inl.h
deleted file mode 100644
index e56b37a9f..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/elfutils-inl.h
+++ /dev/null
@@ -1,74 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_LINUX_ELFUTILS_INL_H__
-#define COMMON_LINUX_ELFUTILS_INL_H__
-
-#include "common/linux/linux_libc_support.h"
-#include "elfutils.h"
-
-namespace google_breakpad {
-
-template<typename ElfClass, typename T>
-const T* GetOffset(const typename ElfClass::Ehdr* elf_header,
-                   typename ElfClass::Off offset) {
-  return reinterpret_cast<const T*>(reinterpret_cast<uintptr_t>(elf_header) +
-                                    offset);
-}
-
-template<typename ElfClass>
-const typename ElfClass::Shdr* FindElfSectionByName(
-    const char* name,
-    typename ElfClass::Word section_type,
-    const typename ElfClass::Shdr* sections,
-    const char* section_names,
-    const char* names_end,
-    int nsection) {
-  assert(name != NULL);
-  assert(sections != NULL);
-  assert(nsection > 0);
-
-  int name_len = my_strlen(name);
-  if (name_len == 0)
-    return NULL;
-
-  for (int i = 0; i < nsection; ++i) {
-    const char* section_name = section_names + sections[i].sh_name;
-    if (sections[i].sh_type == section_type &&
-        names_end - section_name >= name_len + 1 &&
-        my_strcmp(name, section_name) == 0) {
-      return sections + i;
-    }
-  }
-  return NULL;
-}
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_LINUX_ELFUTILS_INL_H__
diff --git a/TMessagesProj/jni/breakpad/common/linux/elfutils.cc b/TMessagesProj/jni/breakpad/common/linux/elfutils.cc
deleted file mode 100644
index a79391c13..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/elfutils.cc
+++ /dev/null
@@ -1,194 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "common/linux/elfutils.h"
-
-#include <assert.h>
-#include <string.h>
-
-#include "common/linux/linux_libc_support.h"
-#include "common/linux/elfutils-inl.h"
-
-namespace google_breakpad {
-
-namespace {
-
-template<typename ElfClass>
-void FindElfClassSection(const char *elf_base,
-                         const char *section_name,
-                         typename ElfClass::Word section_type,
-                         const void **section_start,
-                         size_t *section_size) {
-  typedef typename ElfClass::Ehdr Ehdr;
-  typedef typename ElfClass::Shdr Shdr;
-
-  assert(elf_base);
-  assert(section_start);
-  assert(section_size);
-
-  assert(my_strncmp(elf_base, ELFMAG, SELFMAG) == 0);
-
-  const Ehdr* elf_header = reinterpret_cast<const Ehdr*>(elf_base);
-  assert(elf_header->e_ident[EI_CLASS] == ElfClass::kClass);
-
-  const Shdr* sections =
-    GetOffset<ElfClass, Shdr>(elf_header, elf_header->e_shoff);
-  const Shdr* section_names = sections + elf_header->e_shstrndx;
-  const char* names =
-    GetOffset<ElfClass, char>(elf_header, section_names->sh_offset);
-  const char *names_end = names + section_names->sh_size;
-
-  const Shdr* section =
-    FindElfSectionByName<ElfClass>(section_name, section_type,
-                                   sections, names, names_end,
-                                   elf_header->e_shnum);
-
-  if (section != NULL && section->sh_size > 0) {
-    *section_start = elf_base + section->sh_offset;
-    *section_size = section->sh_size;
-  }
-}
-
-template<typename ElfClass>
-void FindElfClassSegment(const char *elf_base,
-                         typename ElfClass::Word segment_type,
-                         const void **segment_start,
-                         size_t *segment_size) {
-  typedef typename ElfClass::Ehdr Ehdr;
-  typedef typename ElfClass::Phdr Phdr;
-
-  assert(elf_base);
-  assert(segment_start);
-  assert(segment_size);
-
-  assert(my_strncmp(elf_base, ELFMAG, SELFMAG) == 0);
-
-  const Ehdr* elf_header = reinterpret_cast<const Ehdr*>(elf_base);
-  assert(elf_header->e_ident[EI_CLASS] == ElfClass::kClass);
-
-  const Phdr* phdrs =
-    GetOffset<ElfClass, Phdr>(elf_header, elf_header->e_phoff);
-
-  for (int i = 0; i < elf_header->e_phnum; ++i) {
-    if (phdrs[i].p_type == segment_type) {
-      *segment_start = elf_base + phdrs[i].p_offset;
-      *segment_size = phdrs[i].p_filesz;
-      return;
-    }
-  }
-}
-
-}  // namespace
-
-bool IsValidElf(const void* elf_base) {
-  return my_strncmp(reinterpret_cast<const char*>(elf_base),
-                    ELFMAG, SELFMAG) == 0;
-}
-
-int ElfClass(const void* elf_base) {
-  const ElfW(Ehdr)* elf_header =
-    reinterpret_cast<const ElfW(Ehdr)*>(elf_base);
-
-  return elf_header->e_ident[EI_CLASS];
-}
-
-bool FindElfSection(const void *elf_mapped_base,
-                    const char *section_name,
-                    uint32_t section_type,
-                    const void **section_start,
-                    size_t *section_size,
-                    int *elfclass) {
-  assert(elf_mapped_base);
-  assert(section_start);
-  assert(section_size);
-
-  *section_start = NULL;
-  *section_size = 0;
-
-  if (!IsValidElf(elf_mapped_base))
-    return false;
-
-  int cls = ElfClass(elf_mapped_base);
-  if (elfclass) {
-    *elfclass = cls;
-  }
-
-  const char* elf_base =
-    static_cast<const char*>(elf_mapped_base);
-
-  if (cls == ELFCLASS32) {
-    FindElfClassSection<ElfClass32>(elf_base, section_name, section_type,
-                                    section_start, section_size);
-    return *section_start != NULL;
-  } else if (cls == ELFCLASS64) {
-    FindElfClassSection<ElfClass64>(elf_base, section_name, section_type,
-                                    section_start, section_size);
-    return *section_start != NULL;
-  }
-
-  return false;
-}
-
-bool FindElfSegment(const void *elf_mapped_base,
-                    uint32_t segment_type,
-                    const void **segment_start,
-                    size_t *segment_size,
-                    int *elfclass) {
-  assert(elf_mapped_base);
-  assert(segment_start);
-  assert(segment_size);
-
-  *segment_start = NULL;
-  *segment_size = 0;
-
-  if (!IsValidElf(elf_mapped_base))
-    return false;
-
-  int cls = ElfClass(elf_mapped_base);
-  if (elfclass) {
-    *elfclass = cls;
-  }
-
-  const char* elf_base =
-    static_cast<const char*>(elf_mapped_base);
-
-  if (cls == ELFCLASS32) {
-    FindElfClassSegment<ElfClass32>(elf_base, segment_type,
-                                    segment_start, segment_size);
-    return *segment_start != NULL;
-  } else if (cls == ELFCLASS64) {
-    FindElfClassSegment<ElfClass64>(elf_base, segment_type,
-                                    segment_start, segment_size);
-    return *segment_start != NULL;
-  }
-
-  return false;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/common/linux/elfutils.h b/TMessagesProj/jni/breakpad/common/linux/elfutils.h
deleted file mode 100644
index dccdc235e..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/elfutils.h
+++ /dev/null
@@ -1,118 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// elfutils.h: Utilities for dealing with ELF files.
-//
-
-#ifndef COMMON_LINUX_ELFUTILS_H_
-#define COMMON_LINUX_ELFUTILS_H_
-
-#include <elf.h>
-#include <link.h>
-#include <stdint.h>
-
-namespace google_breakpad {
-
-// Traits classes so consumers can write templatized code to deal
-// with specific ELF bits.
-struct ElfClass32 {
-  typedef Elf32_Addr Addr;
-  typedef Elf32_Ehdr Ehdr;
-  typedef Elf32_Nhdr Nhdr;
-  typedef Elf32_Phdr Phdr;
-  typedef Elf32_Shdr Shdr;
-  typedef Elf32_Half Half;
-  typedef Elf32_Off Off;
-  typedef Elf32_Word Word;
-  static const int kClass = ELFCLASS32;
-  static const size_t kAddrSize = sizeof(Elf32_Addr);
-};
-
-struct ElfClass64 {
-  typedef Elf64_Addr Addr;
-  typedef Elf64_Ehdr Ehdr;
-  typedef Elf64_Nhdr Nhdr;
-  typedef Elf64_Phdr Phdr;
-  typedef Elf64_Shdr Shdr;
-  typedef Elf64_Half Half;
-  typedef Elf64_Off Off;
-  typedef Elf64_Word Word;
-  static const int kClass = ELFCLASS64;
-  static const size_t kAddrSize = sizeof(Elf64_Addr);
-};
-
-bool IsValidElf(const void* elf_header);
-int ElfClass(const void* elf_base);
-
-// Attempt to find a section named |section_name| of type |section_type|
-// in the ELF binary data at |elf_mapped_base|. On success, returns true
-// and sets |*section_start| to point to the start of the section data,
-// and |*section_size| to the size of the section's data. If |elfclass|
-// is not NULL, set |*elfclass| to the ELF file class.
-bool FindElfSection(const void *elf_mapped_base,
-                    const char *section_name,
-                    uint32_t section_type,
-                    const void **section_start,
-                    size_t *section_size,
-                    int *elfclass);
-
-// Internal helper method, exposed for convenience for callers
-// that already have more info.
-template<typename ElfClass>
-const typename ElfClass::Shdr*
-FindElfSectionByName(const char* name,
-                     typename ElfClass::Word section_type,
-                     const typename ElfClass::Shdr* sections,
-                     const char* section_names,
-                     const char* names_end,
-                     int nsection);
-
-// Attempt to find the first segment of type |segment_type| in the ELF
-// binary data at |elf_mapped_base|. On success, returns true and sets
-// |*segment_start| to point to the start of the segment data, and
-// and |*segment_size| to the size of the segment's data. If |elfclass|
-// is not NULL, set |*elfclass| to the ELF file class.
-bool FindElfSegment(const void *elf_mapped_base,
-                    uint32_t segment_type,
-                    const void **segment_start,
-                    size_t *segment_size,
-                    int *elfclass);
-
-// Convert an offset from an Elf header into a pointer to the mapped
-// address in the current process. Takes an extra template parameter
-// to specify the return type to avoid having to dynamic_cast the
-// result.
-template<typename ElfClass, typename T>
-const T*
-GetOffset(const typename ElfClass::Ehdr* elf_header,
-          typename ElfClass::Off offset);
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_LINUX_ELFUTILS_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/file_id.cc b/TMessagesProj/jni/breakpad/common/linux/file_id.cc
deleted file mode 100644
index 00b37313a..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/file_id.cc
+++ /dev/null
@@ -1,191 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// file_id.cc: Return a unique identifier for a file
-//
-// See file_id.h for documentation
-//
-
-#include "common/linux/file_id.h"
-
-#include <arpa/inet.h>
-#include <assert.h>
-#include <string.h>
-
-#include <algorithm>
-
-#include "common/linux/elf_gnu_compat.h"
-#include "common/linux/elfutils.h"
-#include "common/linux/linux_libc_support.h"
-#include "common/linux/memory_mapped_file.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-FileID::FileID(const char* path) : path_(path) {}
-
-// ELF note name and desc are 32-bits word padded.
-#define NOTE_PADDING(a) ((a + 3) & ~3)
-
-// These functions are also used inside the crashed process, so be safe
-// and use the syscall/libc wrappers instead of direct syscalls or libc.
-
-template<typename ElfClass>
-static bool ElfClassBuildIDNoteIdentifier(const void *section, size_t length,
-                                          uint8_t identifier[kMDGUIDSize]) {
-  typedef typename ElfClass::Nhdr Nhdr;
-
-  const void* section_end = reinterpret_cast<const char*>(section) + length;
-  const Nhdr* note_header = reinterpret_cast<const Nhdr*>(section);
-  while (reinterpret_cast<const void *>(note_header) < section_end) {
-    if (note_header->n_type == NT_GNU_BUILD_ID)
-      break;
-    note_header = reinterpret_cast<const Nhdr*>(
-                  reinterpret_cast<const char*>(note_header) + sizeof(Nhdr) +
-                  NOTE_PADDING(note_header->n_namesz) +
-                  NOTE_PADDING(note_header->n_descsz));
-  }
-  if (reinterpret_cast<const void *>(note_header) >= section_end ||
-      note_header->n_descsz == 0) {
-    return false;
-  }
-
-  const char* build_id = reinterpret_cast<const char*>(note_header) +
-    sizeof(Nhdr) + NOTE_PADDING(note_header->n_namesz);
-  // Copy as many bits of the build ID as will fit
-  // into the GUID space.
-  my_memset(identifier, 0, kMDGUIDSize);
-  memcpy(identifier, build_id,
-         std::min(kMDGUIDSize, (size_t)note_header->n_descsz));
-
-  return true;
-}
-
-// Attempt to locate a .note.gnu.build-id section in an ELF binary
-// and copy as many bytes of it as will fit into |identifier|.
-static bool FindElfBuildIDNote(const void *elf_mapped_base,
-                               uint8_t identifier[kMDGUIDSize]) {
-  void* note_section;
-  size_t note_size;
-  int elfclass;
-  if ((!FindElfSegment(elf_mapped_base, PT_NOTE,
-                       (const void**)&note_section, &note_size, &elfclass) ||
-      note_size == 0)  &&
-      (!FindElfSection(elf_mapped_base, ".note.gnu.build-id", SHT_NOTE,
-                       (const void**)&note_section, &note_size, &elfclass) ||
-      note_size == 0)) {
-    return false;
-  }
-
-  if (elfclass == ELFCLASS32) {
-    return ElfClassBuildIDNoteIdentifier<ElfClass32>(note_section, note_size,
-                                                     identifier);
-  } else if (elfclass == ELFCLASS64) {
-    return ElfClassBuildIDNoteIdentifier<ElfClass64>(note_section, note_size,
-                                                     identifier);
-  }
-
-  return false;
-}
-
-// Attempt to locate the .text section of an ELF binary and generate
-// a simple hash by XORing the first page worth of bytes into |identifier|.
-static bool HashElfTextSection(const void *elf_mapped_base,
-                               uint8_t identifier[kMDGUIDSize]) {
-  void* text_section;
-  size_t text_size;
-  if (!FindElfSection(elf_mapped_base, ".text", SHT_PROGBITS,
-                      (const void**)&text_section, &text_size, NULL) ||
-      text_size == 0) {
-    return false;
-  }
-
-  my_memset(identifier, 0, kMDGUIDSize);
-  const uint8_t* ptr = reinterpret_cast<const uint8_t*>(text_section);
-  const uint8_t* ptr_end = ptr + std::min(text_size, static_cast<size_t>(4096));
-  while (ptr < ptr_end) {
-    for (unsigned i = 0; i < kMDGUIDSize; i++)
-      identifier[i] ^= ptr[i];
-    ptr += kMDGUIDSize;
-  }
-  return true;
-}
-
-// static
-bool FileID::ElfFileIdentifierFromMappedFile(const void* base,
-                                             uint8_t identifier[kMDGUIDSize]) {
-  // Look for a build id note first.
-  if (FindElfBuildIDNote(base, identifier))
-    return true;
-
-  // Fall back on hashing the first page of the text section.
-  return HashElfTextSection(base, identifier);
-}
-
-bool FileID::ElfFileIdentifier(uint8_t identifier[kMDGUIDSize]) {
-  MemoryMappedFile mapped_file(path_.c_str(), 0);
-  if (!mapped_file.data())  // Should probably check if size >= ElfW(Ehdr)?
-    return false;
-
-  return ElfFileIdentifierFromMappedFile(mapped_file.data(), identifier);
-}
-
-// static
-void FileID::ConvertIdentifierToString(const uint8_t identifier[kMDGUIDSize],
-                                       char* buffer, int buffer_length) {
-  uint8_t identifier_swapped[kMDGUIDSize];
-
-  // Endian-ness swap to match dump processor expectation.
-  memcpy(identifier_swapped, identifier, kMDGUIDSize);
-  uint32_t* data1 = reinterpret_cast<uint32_t*>(identifier_swapped);
-  *data1 = htonl(*data1);
-  uint16_t* data2 = reinterpret_cast<uint16_t*>(identifier_swapped + 4);
-  *data2 = htons(*data2);
-  uint16_t* data3 = reinterpret_cast<uint16_t*>(identifier_swapped + 6);
-  *data3 = htons(*data3);
-
-  int buffer_idx = 0;
-  for (unsigned int idx = 0;
-       (buffer_idx < buffer_length) && (idx < kMDGUIDSize);
-       ++idx) {
-    int hi = (identifier_swapped[idx] >> 4) & 0x0F;
-    int lo = (identifier_swapped[idx]) & 0x0F;
-
-    if (idx == 4 || idx == 6 || idx == 8 || idx == 10)
-      buffer[buffer_idx++] = '-';
-
-    buffer[buffer_idx++] = (hi >= 10) ? 'A' + hi - 10 : '0' + hi;
-    buffer[buffer_idx++] = (lo >= 10) ? 'A' + lo - 10 : '0' + lo;
-  }
-
-  // NULL terminate
-  buffer[(buffer_idx < buffer_length) ? buffer_idx : buffer_idx - 1] = 0;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/common/linux/file_id.h b/TMessagesProj/jni/breakpad/common/linux/file_id.h
deleted file mode 100644
index 2642722a6..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/file_id.h
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// file_id.h: Return a unique identifier for a file
-//
-
-#ifndef COMMON_LINUX_FILE_ID_H__
-#define COMMON_LINUX_FILE_ID_H__
-
-#include <limits.h>
-#include <string>
-
-#include "common/linux/guid_creator.h"
-
-namespace google_breakpad {
-
-static const size_t kMDGUIDSize = sizeof(MDGUID);
-
-class FileID {
- public:
-  explicit FileID(const char* path);
-  ~FileID() {}
-
-  // Load the identifier for the elf file path specified in the constructor into
-  // |identifier|.  Return false if the identifier could not be created for the
-  // file.
-  // The current implementation will look for a .note.gnu.build-id
-  // section and use that as the file id, otherwise it falls back to
-  // XORing the first 4096 bytes of the .text section to generate an identifier.
-  bool ElfFileIdentifier(uint8_t identifier[kMDGUIDSize]);
-
-  // Load the identifier for the elf file mapped into memory at |base| into
-  // |identifier|.  Return false if the identifier could not be created for the
-  // file.
-  static bool ElfFileIdentifierFromMappedFile(const void* base,
-                                              uint8_t identifier[kMDGUIDSize]);
-
-  // Convert the |identifier| data to a NULL terminated string.  The string will
-  // be formatted as a UUID (e.g., 22F065BB-FC9C-49F7-80FE-26A7CEBD7BCE).
-  // The |buffer| should be at least 37 bytes long to receive all of the data
-  // and termination.  Shorter buffers will contain truncated data.
-  static void ConvertIdentifierToString(const uint8_t identifier[kMDGUIDSize],
-                                        char* buffer, int buffer_length);
-
- private:
-  // Storage for the path specified
-  std::string path_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_LINUX_FILE_ID_H__
diff --git a/TMessagesProj/jni/breakpad/common/linux/guid_creator.cc b/TMessagesProj/jni/breakpad/common/linux/guid_creator.cc
deleted file mode 100644
index bfb308ee2..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/guid_creator.cc
+++ /dev/null
@@ -1,104 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include "common/linux/guid_creator.h"
-
-#include <assert.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-#include <unistd.h>
-
-//
-// GUIDGenerator
-//
-// This class is used to generate random GUID.
-// Currently use random number to generate a GUID since Linux has
-// no native GUID generator. This should be OK since we don't expect
-// crash to happen very offen.
-//
-class GUIDGenerator {
- public:
-  static uint32_t BytesToUInt32(const uint8_t bytes[]) {
-    return ((uint32_t) bytes[0]
-            | ((uint32_t) bytes[1] << 8)
-            | ((uint32_t) bytes[2] << 16)
-            | ((uint32_t) bytes[3] << 24));
-  }
-
-  static void UInt32ToBytes(uint8_t bytes[], uint32_t n) {
-    bytes[0] = n & 0xff;
-    bytes[1] = (n >> 8) & 0xff;
-    bytes[2] = (n >> 16) & 0xff;
-    bytes[3] = (n >> 24) & 0xff;
-  }
-
-  static bool CreateGUID(GUID *guid) {
-    InitOnce();
-    guid->data1 = random();
-    guid->data2 = (uint16_t)(random());
-    guid->data3 = (uint16_t)(random());
-    UInt32ToBytes(&guid->data4[0], random());
-    UInt32ToBytes(&guid->data4[4], random());
-    return true;
-  }
-
- private:
-  static void InitOnce() {
-    pthread_once(&once_control, &InitOnceImpl);
-  }
-
-  static void InitOnceImpl() {
-    srandom(time(NULL));
-  }
-
-  static pthread_once_t once_control;
-};
-
-pthread_once_t GUIDGenerator::once_control = PTHREAD_ONCE_INIT;
-
-bool CreateGUID(GUID *guid) {
-  return GUIDGenerator::CreateGUID(guid);
-}
-
-// Parse guid to string.
-bool GUIDToString(const GUID *guid, char *buf, int buf_len) {
-  // Should allow more space the the max length of GUID.
-  assert(buf_len > kGUIDStringLength);
-  int num = snprintf(buf, buf_len, kGUIDFormatString,
-                     guid->data1, guid->data2, guid->data3,
-                     GUIDGenerator::BytesToUInt32(&(guid->data4[0])),
-                     GUIDGenerator::BytesToUInt32(&(guid->data4[4])));
-  if (num != kGUIDStringLength)
-    return false;
-
-  buf[num] = '\0';
-  return true;
-}
diff --git a/TMessagesProj/jni/breakpad/common/linux/guid_creator.h b/TMessagesProj/jni/breakpad/common/linux/guid_creator.h
deleted file mode 100644
index c86d856c4..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/guid_creator.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_LINUX_GUID_CREATOR_H__
-#define COMMON_LINUX_GUID_CREATOR_H__
-
-#include "google_breakpad/common/minidump_format.h"
-
-typedef MDGUID GUID;
-
-// Format string for parsing GUID.
-#define kGUIDFormatString "%08x-%04x-%04x-%08x-%08x"
-// Length of GUID string. Don't count the ending '\0'.
-#define kGUIDStringLength 36
-
-// Create a guid.
-bool CreateGUID(GUID *guid);
-
-// Get the string from guid.
-bool GUIDToString(const GUID *guid, char *buf, int buf_len);
-
-#endif
diff --git a/TMessagesProj/jni/breakpad/common/linux/ignore_ret.h b/TMessagesProj/jni/breakpad/common/linux/ignore_ret.h
deleted file mode 100644
index f60384bba..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/ignore_ret.h
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright (c) 2012 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_LINUX_IGNORE_RET_H_
-#define COMMON_LINUX_IGNORE_RET_H_
-
-// Some compilers are prone to warn about unused return values. In cases where
-// either a) the call cannot fail, or b) there is nothing that can be done when
-// the call fails, IGNORE_RET() can be used to mark the return code as ignored.
-// This avoids spurious compiler warnings.
-
-#define IGNORE_RET(x) do { if (x); } while (0)
-
-#endif  // COMMON_LINUX_IGNORE_RET_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.cc b/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.cc
deleted file mode 100644
index 08b0325e6..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.cc
+++ /dev/null
@@ -1,237 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// This source file provides replacements for libc functions that we need. If
-// we call the libc functions directly we risk crashing in the dynamic linker
-// as it tries to resolve uncached PLT entries.
-
-#include "common/linux/linux_libc_support.h"
-
-#include <stddef.h>
-
-extern "C" {
-
-size_t my_strlen(const char* s) {
-  size_t len = 0;
-  while (*s++) len++;
-  return len;
-}
-
-int my_strcmp(const char* a, const char* b) {
-  for (;;) {
-    if (*a < *b)
-      return -1;
-    else if (*a > *b)
-      return 1;
-    else if (*a == 0)
-      return 0;
-    a++;
-    b++;
-  }
-}
-
-int my_strncmp(const char* a, const char* b, size_t len) {
-  for (size_t i = 0; i < len; ++i) {
-    if (*a < *b)
-      return -1;
-    else if (*a > *b)
-      return 1;
-    else if (*a == 0)
-      return 0;
-    a++;
-    b++;
-  }
-
-  return 0;
-}
-
-// Parse a non-negative integer.
-//   result: (output) the resulting non-negative integer
-//   s: a NUL terminated string
-// Return true iff successful.
-bool my_strtoui(int* result, const char* s) {
-  if (*s == 0)
-    return false;
-  int r = 0;
-  for (;; s++) {
-    if (*s == 0)
-      break;
-    const int old_r = r;
-    r *= 10;
-    if (*s < '0' || *s > '9')
-      return false;
-    r += *s - '0';
-    if (r < old_r)
-      return false;
-  }
-
-  *result = r;
-  return true;
-}
-
-// Return the length of the given unsigned integer when expressed in base 10.
-unsigned my_uint_len(uintmax_t i) {
-  if (!i)
-    return 1;
-
-  int len = 0;
-  while (i) {
-    len++;
-    i /= 10;
-  }
-
-  return len;
-}
-
-// Convert an unsigned integer to a string
-//   output: (output) the resulting string is written here. This buffer must be
-//     large enough to hold the resulting string. Call |my_uint_len| to get the
-//     required length.
-//   i: the unsigned integer to serialise.
-//   i_len: the length of the integer in base 10 (see |my_uint_len|).
-void my_uitos(char* output, uintmax_t i, unsigned i_len) {
-  for (unsigned index = i_len; index; --index, i /= 10)
-    output[index - 1] = '0' + (i % 10);
-}
-
-const char* my_strchr(const char* haystack, char needle) {
-  while (*haystack && *haystack != needle)
-    haystack++;
-  if (*haystack == needle)
-    return haystack;
-  return (const char*) 0;
-}
-
-const char* my_strrchr(const char* haystack, char needle) {
-  const char* ret = NULL;
-  while (*haystack) {
-    if (*haystack == needle)
-      ret = haystack;
-    haystack++;
-  }
-  return ret;
-}
-
-void* my_memchr(const void* src, int needle, size_t src_len) {
-  const unsigned char* p = (const unsigned char*)src;
-  const unsigned char* p_end = p + src_len;
-  for (; p < p_end; ++p) {
-    if (*p == needle)
-      return (void*)p;
-  }
-  return NULL;
-}
-
-// Read a hex value
-//   result: (output) the resulting value
-//   s: a string
-// Returns a pointer to the first invalid charactor.
-const char* my_read_hex_ptr(uintptr_t* result, const char* s) {
-  uintptr_t r = 0;
-
-  for (;; ++s) {
-    if (*s >= '0' && *s <= '9') {
-      r <<= 4;
-      r += *s - '0';
-    } else if (*s >= 'a' && *s <= 'f') {
-      r <<= 4;
-      r += (*s - 'a') + 10;
-    } else if (*s >= 'A' && *s <= 'F') {
-      r <<= 4;
-      r += (*s - 'A') + 10;
-    } else {
-      break;
-    }
-  }
-
-  *result = r;
-  return s;
-}
-
-const char* my_read_decimal_ptr(uintptr_t* result, const char* s) {
-  uintptr_t r = 0;
-
-  for (;; ++s) {
-    if (*s >= '0' && *s <= '9') {
-      r *= 10;
-      r += *s - '0';
-    } else {
-      break;
-    }
-  }
-  *result = r;
-  return s;
-}
-
-void my_memset(void* ip, char c, size_t len) {
-  char* p = (char *) ip;
-  while (len--)
-    *p++ = c;
-}
-
-size_t my_strlcpy(char* s1, const char* s2, size_t len) {
-  size_t pos1 = 0;
-  size_t pos2 = 0;
-
-  while (s2[pos2] != '\0') {
-    if (pos1 + 1 < len) {
-      s1[pos1] = s2[pos2];
-      pos1++;
-    }
-    pos2++;
-  }
-  if (len > 0)
-    s1[pos1] = '\0';
-
-  return pos2;
-}
-
-size_t my_strlcat(char* s1, const char* s2, size_t len) {
-  size_t pos1 = 0;
-
-  while (pos1 < len && s1[pos1] != '\0')
-    pos1++;
-
-  if (pos1 == len)
-    return pos1;
-
-  return pos1 + my_strlcpy(s1 + pos1, s2, len - pos1);
-}
-
-int my_isspace(int ch) {
-  // Matches the C locale.
-  const char spaces[] = " \t\f\n\r\t\v";
-  for (size_t i = 0; i < sizeof(spaces); i++) {
-    if (ch == spaces[i])
-      return 1;
-  }
-  return 0;
-}
-
-}  // extern "C"
diff --git a/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.h b/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.h
deleted file mode 100644
index ec5a8d6b6..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/linux_libc_support.h
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright (c) 2009, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// This header provides replacements for libc functions that we need. We if
-// call the libc functions directly we risk crashing in the dynamic linker as
-// it tries to resolve uncached PLT entries.
-
-#ifndef CLIENT_LINUX_LINUX_LIBC_SUPPORT_H_
-#define CLIENT_LINUX_LINUX_LIBC_SUPPORT_H_
-
-#include <stdint.h>
-#include <limits.h>
-#include <sys/types.h>
-
-extern "C" {
-
-extern size_t my_strlen(const char* s);
-
-extern int my_strcmp(const char* a, const char* b);
-
-extern int my_strncmp(const char* a, const char* b, size_t len);
-
-// Parse a non-negative integer.
-//   result: (output) the resulting non-negative integer
-//   s: a NUL terminated string
-// Return true iff successful.
-extern bool my_strtoui(int* result, const char* s);
-
-// Return the length of the given unsigned integer when expressed in base 10.
-extern unsigned my_uint_len(uintmax_t i);
-
-// Convert an unsigned integer to a string
-//   output: (output) the resulting string is written here. This buffer must be
-//     large enough to hold the resulting string. Call |my_uint_len| to get the
-//     required length.
-//   i: the unsigned integer to serialise.
-//   i_len: the length of the integer in base 10 (see |my_uint_len|).
-extern void my_uitos(char* output, uintmax_t i, unsigned i_len);
-
-extern const char* my_strchr(const char* haystack, char needle);
-
-extern const char* my_strrchr(const char* haystack, char needle);
-
-// Read a hex value
-//   result: (output) the resulting value
-//   s: a string
-// Returns a pointer to the first invalid charactor.
-extern const char* my_read_hex_ptr(uintptr_t* result, const char* s);
-
-extern const char* my_read_decimal_ptr(uintptr_t* result, const char* s);
-
-extern void my_memset(void* ip, char c, size_t len);
-
-extern void* my_memchr(const void* src, int c, size_t len);
-
-// The following are considered safe to use in a compromised environment.
-// Besides, this gives the compiler an opportunity to optimize their calls.
-#define my_memcpy  memcpy
-#define my_memmove memmove
-#define my_memcmp  memcmp
-
-extern size_t my_strlcpy(char* s1, const char* s2, size_t len);
-
-extern size_t my_strlcat(char* s1, const char* s2, size_t len);
-
-extern int my_isspace(int ch);
-
-}  // extern "C"
-
-#endif  // CLIENT_LINUX_LINUX_LIBC_SUPPORT_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.cc b/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.cc
deleted file mode 100644
index 592b66c8d..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.cc
+++ /dev/null
@@ -1,118 +0,0 @@
-// Copyright (c) 2011, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// memory_mapped_file.cc: Implement google_breakpad::MemoryMappedFile.
-// See memory_mapped_file.h for details.
-
-#include "common/linux/memory_mapped_file.h"
-
-#include <fcntl.h>
-#include <sys/mman.h>
-#if defined(__ANDROID__)
-#include <sys/stat.h>
-#endif
-#include <unistd.h>
-
-#include "common/memory_range.h"
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-MemoryMappedFile::MemoryMappedFile() {}
-
-MemoryMappedFile::MemoryMappedFile(const char* path, size_t offset) {
-  Map(path, offset);
-}
-
-MemoryMappedFile::~MemoryMappedFile() {
-  Unmap();
-}
-
-#include <unistd.h>
-
-bool MemoryMappedFile::Map(const char* path, size_t offset) {
-  Unmap();
-
-  int fd = sys_open(path, O_RDONLY, 0);
-  if (fd == -1) {
-    return false;
-  }
-
-#if defined(__x86_64__) || defined(__aarch64__) || \
-   (defined(__mips__) && _MIPS_SIM == _ABI64)
-
-  struct kernel_stat st;
-  if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
-#else
-  struct kernel_stat64 st;
-  if (sys_fstat64(fd, &st) == -1 || st.st_size < 0) {
-#endif
-    sys_close(fd);
-    return false;
-  }
-
-  // Strangely file size can be negative, but we check above that it is not.
-  size_t file_len = static_cast<size_t>(st.st_size);
-  // If the file does not extend beyond the offset, simply use an empty
-  // MemoryRange and return true. Don't bother to call mmap()
-  // even though mmap() can handle an empty file on some platforms.
-  if (offset >= file_len) {
-    sys_close(fd);
-    return true;
-  }
-
-#if defined(__x86_64__) || defined(__aarch64__) || \
-   (defined(__mips__) && _MIPS_SIM == _ABI64)
-  void* data = sys_mmap(NULL, file_len, PROT_READ, MAP_PRIVATE, fd, offset);
-#else
-  if ((offset & 4095) != 0) {
-    // Not page aligned.
-    sys_close(fd);
-    return false;
-  }
-  void* data = sys_mmap2(
-      NULL, file_len, PROT_READ, MAP_PRIVATE, fd, offset >> 12);
-#endif
-  sys_close(fd);
-  if (data == MAP_FAILED) {
-    return false;
-  }
-
-  content_.Set(data, file_len - offset);
-  return true;
-}
-
-void MemoryMappedFile::Unmap() {
-  if (content_.data()) {
-    sys_munmap(const_cast<uint8_t*>(content_.data()), content_.length());
-    content_.Set(NULL, 0);
-  }
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.h b/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.h
deleted file mode 100644
index fa660cc91..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/memory_mapped_file.h
+++ /dev/null
@@ -1,87 +0,0 @@
-// Copyright (c) 2011, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// memory_mapped_file.h: Define the google_breakpad::MemoryMappedFile
-// class, which maps a file into memory for read-only access.
-
-#ifndef COMMON_LINUX_MEMORY_MAPPED_FILE_H_
-#define COMMON_LINUX_MEMORY_MAPPED_FILE_H_
-
-#include <stddef.h>
-#include "common/basictypes.h"
-#include "common/memory_range.h"
-
-namespace google_breakpad {
-
-// A utility class for mapping a file into memory for read-only access of
-// the file content. Its implementation avoids calling into libc functions
-// by directly making system calls for open, close, mmap, and munmap.
-class MemoryMappedFile {
- public:
-  MemoryMappedFile();
-
-  // Constructor that calls Map() to map a file at |path| into memory.
-  // If Map() fails, the object behaves as if it is default constructed.
-  MemoryMappedFile(const char* path, size_t offset);
-
-  ~MemoryMappedFile();
-
-  // Maps a file at |path| into memory, which can then be accessed via
-  // content() as a MemoryRange object or via data(), and returns true on
-  // success. Mapping an empty file will succeed but with data() and size()
-  // returning NULL and 0, respectively. An existing mapping is unmapped
-  // before a new mapping is created.
-  bool Map(const char* path, size_t offset);
-
-  // Unmaps the memory for the mapped file. It's a no-op if no file is
-  // mapped.
-  void Unmap();
-
-  // Returns a MemoryRange object that covers the memory for the mapped
-  // file. The MemoryRange object is empty if no file is mapped.
-  const MemoryRange& content() const { return content_; }
-
-  // Returns a pointer to the beginning of the memory for the mapped file.
-  // or NULL if no file is mapped or the mapped file is empty.
-  const void* data() const { return content_.data(); }
-
-  // Returns the size in bytes of the mapped file, or zero if no file
-  // is mapped.
-  size_t size() const { return content_.length(); }
-
- private:
-  // Mapped file content as a MemoryRange object.
-  MemoryRange content_;
-
-  DISALLOW_COPY_AND_ASSIGN(MemoryMappedFile);
-};
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_LINUX_MEMORY_MAPPED_FILE_H_
diff --git a/TMessagesProj/jni/breakpad/common/linux/safe_readlink.cc b/TMessagesProj/jni/breakpad/common/linux/safe_readlink.cc
deleted file mode 100644
index 870c28af3..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/safe_readlink.cc
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (c) 2011, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// safe_readlink.cc: Implement google_breakpad::SafeReadLink.
-// See safe_readlink.h for details.
-
-#include <stddef.h>
-
-#include "third_party/lss/linux_syscall_support.h"
-
-namespace google_breakpad {
-
-bool SafeReadLink(const char* path, char* buffer, size_t buffer_size) {
-  // sys_readlink() does not add a NULL byte to |buffer|. In order to return
-  // a NULL-terminated string in |buffer|, |buffer_size| should be at least
-  // one byte longer than the expected path length. Also, sys_readlink()
-  // returns the actual path length on success, which does not count the
-  // NULL byte, so |result_size| should be less than |buffer_size|.
-  ssize_t result_size = sys_readlink(path, buffer, buffer_size);
-  if (result_size >= 0 && static_cast<size_t>(result_size) < buffer_size) {
-    buffer[result_size] = '\0';
-    return true;
-  }
-  return false;
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/common/linux/safe_readlink.h b/TMessagesProj/jni/breakpad/common/linux/safe_readlink.h
deleted file mode 100644
index 4ae131b58..000000000
--- a/TMessagesProj/jni/breakpad/common/linux/safe_readlink.h
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright (c) 2011, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// safe_readlink.h: Define the google_breakpad::SafeReadLink function,
-// which wraps sys_readlink and gurantees the result is NULL-terminated.
-
-#ifndef COMMON_LINUX_SAFE_READLINK_H_
-#define COMMON_LINUX_SAFE_READLINK_H_
-
-#include <stddef.h>
-
-namespace google_breakpad {
-
-// This function wraps sys_readlink() and performs the same functionalty,
-// but guarantees |buffer| is NULL-terminated if sys_readlink() returns
-// no error. It takes the same arguments as sys_readlink(), but unlike
-// sys_readlink(), it returns true on success.
-//
-// |buffer_size| specifies the size of |buffer| in bytes. As this function
-// always NULL-terminates |buffer| on success, |buffer_size| should be
-// at least one byte longer than the expected path length (e.g. PATH_MAX,
-// which is typically defined as the maximum length of a path name
-// including the NULL byte).
-//
-// The implementation of this function calls sys_readlink() instead of
-// readlink(), it can thus be used in the context where calling to libc
-// functions is discouraged.
-bool SafeReadLink(const char* path, char* buffer, size_t buffer_size);
-
-// Same as the three-argument version of SafeReadLink() but deduces the
-// size of |buffer| if it is a char array of known size.
-template <size_t N>
-bool SafeReadLink(const char* path, char (&buffer)[N]) {
-  return SafeReadLink(path, buffer, sizeof(buffer));
-}
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_LINUX_SAFE_READLINK_H_
diff --git a/TMessagesProj/jni/breakpad/common/md5.cc b/TMessagesProj/jni/breakpad/common/md5.cc
deleted file mode 100644
index a0d9a1bdd..000000000
--- a/TMessagesProj/jni/breakpad/common/md5.cc
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * written by Colin Plumb in 1993, no copyright is claimed.
- * This code is in the public domain; do with it what you wish.
- *
- * Equivalent code is available from RSA Data Security, Inc.
- * This code has been tested against that, and is equivalent,
- * except that you don't need to include two pages of legalese
- * with every copy.
- *
- * To compute the message digest of a chunk of bytes, declare an
- * MD5Context structure, pass it to MD5Init, call MD5Update as
- * needed on buffers full of bytes, and then call MD5Final, which
- * will fill a supplied 16-byte array with the digest.
- */
-
-#include <string.h>
-
-#include "common/md5.h"
-
-namespace google_breakpad {
-
-#ifndef WORDS_BIGENDIAN
-#define byteReverse(buf, len)   /* Nothing */
-#else
-/*
- * Note: this code is harmless on little-endian machines.
- */
-static void byteReverse(unsigned char *buf, unsigned longs)
-{
-  u32 t;
-  do {
-    t = (u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
-      ((unsigned) buf[1] << 8 | buf[0]);
-    *(u32 *) buf = t;
-    buf += 4;
-  } while (--longs);
-}
-#endif
-
-static void MD5Transform(u32 buf[4], u32 const in[16]);
-
-/*
- * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
- * initialization constants.
- */
-void MD5Init(struct MD5Context *ctx)
-{
-  ctx->buf[0] = 0x67452301;
-  ctx->buf[1] = 0xefcdab89;
-  ctx->buf[2] = 0x98badcfe;
-  ctx->buf[3] = 0x10325476;
-
-  ctx->bits[0] = 0;
-  ctx->bits[1] = 0;
-}
-
-/*
- * Update context to reflect the concatenation of another buffer full
- * of bytes.
- */
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, size_t len)
-{
-  u32 t;
-
-  /* Update bitcount */
-
-  t = ctx->bits[0];
-  if ((ctx->bits[0] = t + ((u32) len << 3)) < t)
-    ctx->bits[1]++;         /* Carry from low to high */
-  ctx->bits[1] += len >> 29;
-
-  t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
-
-  /* Handle any leading odd-sized chunks */
-
-  if (t) {
-    unsigned char *p = (unsigned char *) ctx->in + t;
-
-    t = 64 - t;
-    if (len < t) {
-      memcpy(p, buf, len);
-      return;
-    }
-    memcpy(p, buf, t);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-    buf += t;
-    len -= t;
-  }
-  /* Process data in 64-byte chunks */
-
-  while (len >= 64) {
-    memcpy(ctx->in, buf, 64);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-    buf += 64;
-    len -= 64;
-  }
-
-  /* Handle any remaining bytes of data. */
-
-  memcpy(ctx->in, buf, len);
-}
-
-/*
- * Final wrapup - pad to 64-byte boundary with the bit pattern
- * 1 0* (64-bit count of bits processed, MSB-first)
- */
-void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
-{
-  unsigned count;
-  unsigned char *p;
-
-  /* Compute number of bytes mod 64 */
-  count = (ctx->bits[0] >> 3) & 0x3F;
-
-  /* Set the first char of padding to 0x80.  This is safe since there is
-     always at least one byte free */
-  p = ctx->in + count;
-  *p++ = 0x80;
-
-  /* Bytes of padding needed to make 64 bytes */
-  count = 64 - 1 - count;
-
-  /* Pad out to 56 mod 64 */
-  if (count < 8) {
-    /* Two lots of padding:  Pad the first block to 64 bytes */
-    memset(p, 0, count);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-
-    /* Now fill the next block with 56 bytes */
-    memset(ctx->in, 0, 56);
-  } else {
-    /* Pad block to 56 bytes */
-    memset(p, 0, count - 8);
-  }
-  byteReverse(ctx->in, 14);
-
-  /* Append length in bits and transform */
-  ((u32 *) ctx->in)[14] = ctx->bits[0];
-  ((u32 *) ctx->in)[15] = ctx->bits[1];
-
-  MD5Transform(ctx->buf, (u32 *) ctx->in);
-  byteReverse((unsigned char *) ctx->buf, 4);
-  memcpy(digest, ctx->buf, 16);
-  memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
-}
-
-/* The four core functions - F1 is optimized somewhat */
-
-/* #define F1(x, y, z) (x & y | ~x & z) */
-#define F1(x, y, z) (z ^ (x & (y ^ z)))
-#define F2(x, y, z) F1(z, x, y)
-#define F3(x, y, z) (x ^ y ^ z)
-#define F4(x, y, z) (y ^ (x | ~z))
-
-/* This is the central step in the MD5 algorithm. */
-#define MD5STEP(f, w, x, y, z, data, s) \
-  ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-/*
- * The core of the MD5 algorithm, this alters an existing MD5 hash to
- * reflect the addition of 16 longwords of new data.  MD5Update blocks
- * the data and converts bytes into longwords for this routine.
- */
-static void MD5Transform(u32 buf[4], u32 const in[16])
-{
-  u32 a, b, c, d;
-
-  a = buf[0];
-  b = buf[1];
-  c = buf[2];
-  d = buf[3];
-
-  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
-  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
-  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
-  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
-  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
-  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
-  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
-  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
-  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
-  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
-  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
-  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
-  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
-  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
-  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
-  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
-
-  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
-  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
-  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
-  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
-  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
-  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
-  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
-  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
-  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
-  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
-  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
-  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
-  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
-  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
-  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
-  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
-
-  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
-  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
-  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
-  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
-  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
-  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
-  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
-  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
-  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
-  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
-  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
-  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
-  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
-  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
-  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
-  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
-
-  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
-  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
-  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
-  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
-  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
-  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
-  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
-  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
-  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
-  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
-  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
-  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
-  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
-  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
-  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
-  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
-
-  buf[0] += a;
-  buf[1] += b;
-  buf[2] += c;
-  buf[3] += d;
-}
-
-}  // namespace google_breakpad
-
diff --git a/TMessagesProj/jni/breakpad/common/md5.h b/TMessagesProj/jni/breakpad/common/md5.h
deleted file mode 100644
index 2ab0ab95a..000000000
--- a/TMessagesProj/jni/breakpad/common/md5.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2007 Google Inc. All Rights Reserved.
-// Author: liuli@google.com (Liu Li)
-#ifndef COMMON_MD5_H__
-#define COMMON_MD5_H__
-
-#include <stdint.h>
-
-namespace google_breakpad {
-
-typedef uint32_t u32;
-typedef uint8_t u8;
-
-struct MD5Context {
-  u32 buf[4];
-  u32 bits[2];
-  u8 in[64];
-};
-
-void MD5Init(struct MD5Context *ctx);
-
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, size_t len);
-
-void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_MD5_H__
diff --git a/TMessagesProj/jni/breakpad/common/memory.h b/TMessagesProj/jni/breakpad/common/memory.h
deleted file mode 100644
index d6aa137d3..000000000
--- a/TMessagesProj/jni/breakpad/common/memory.h
+++ /dev/null
@@ -1,212 +0,0 @@
-// Copyright (c) 2009, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MEMORY_H_
-#define GOOGLE_BREAKPAD_COMMON_MEMORY_H_
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include <memory>
-#include <vector>
-
-#if defined(MEMORY_SANITIZER)
-#include <sanitizer/msan_interface.h>
-#endif
-
-#ifdef __APPLE__
-#define sys_mmap mmap
-#define sys_mmap2 mmap
-#define sys_munmap munmap
-#define MAP_ANONYMOUS MAP_ANON
-#else
-#include "third_party/lss/linux_syscall_support.h"
-#endif
-
-namespace google_breakpad {
-
-// This is very simple allocator which fetches pages from the kernel directly.
-// Thus, it can be used even when the heap may be corrupted.
-//
-// There is no free operation. The pages are only freed when the object is
-// destroyed.
-class PageAllocator {
- public:
-  PageAllocator()
-      : page_size_(getpagesize()),
-        last_(NULL),
-        current_page_(NULL),
-        page_offset_(0) {
-  }
-
-  ~PageAllocator() {
-    FreeAll();
-  }
-
-  void *Alloc(size_t bytes) {
-    if (!bytes)
-      return NULL;
-
-    if (current_page_ && page_size_ - page_offset_ >= bytes) {
-      uint8_t *const ret = current_page_ + page_offset_;
-      page_offset_ += bytes;
-      if (page_offset_ == page_size_) {
-        page_offset_ = 0;
-        current_page_ = NULL;
-      }
-
-      return ret;
-    }
-
-    const size_t pages =
-        (bytes + sizeof(PageHeader) + page_size_ - 1) / page_size_;
-    uint8_t *const ret = GetNPages(pages);
-    if (!ret)
-      return NULL;
-
-    page_offset_ =
-        (page_size_ - (page_size_ * pages - (bytes + sizeof(PageHeader)))) %
-        page_size_;
-    current_page_ = page_offset_ ? ret + page_size_ * (pages - 1) : NULL;
-
-    return ret + sizeof(PageHeader);
-  }
-
-  // Checks whether the page allocator owns the passed-in pointer.
-  // This method exists for testing pursposes only.
-  bool OwnsPointer(const void* p) {
-    for (PageHeader* header = last_; header; header = header->next) {
-      const char* current = reinterpret_cast<char*>(header);
-      if ((p >= current) && (p < current + header->num_pages * page_size_))
-        return true;
-    }
-
-    return false;
-  }
-
- private:
-  uint8_t *GetNPages(size_t num_pages) {
-#if defined(__x86_64__) || defined(__aarch64__) || defined(__aarch64__) || \
-    ((defined(__mips__) && _MIPS_SIM == _ABI64))
-    void *a = sys_mmap(NULL, page_size_ * num_pages, PROT_READ | PROT_WRITE,
-                       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-#else
-    void *a = sys_mmap2(NULL, page_size_ * num_pages, PROT_READ | PROT_WRITE,
-                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-#endif
-    if (a == MAP_FAILED)
-      return NULL;
-
-#if defined(MEMORY_SANITIZER)
-    // We need to indicate to MSan that memory allocated through sys_mmap is
-    // initialized, since linux_syscall_support.h doesn't have MSan hooks.
-    __msan_unpoison(a, page_size_ * num_pages);
-#endif
-
-    struct PageHeader *header = reinterpret_cast<PageHeader*>(a);
-    header->next = last_;
-    header->num_pages = num_pages;
-    last_ = header;
-
-    return reinterpret_cast<uint8_t*>(a);
-  }
-
-  void FreeAll() {
-    PageHeader *next;
-
-    for (PageHeader *cur = last_; cur; cur = next) {
-      next = cur->next;
-      sys_munmap(cur, cur->num_pages * page_size_);
-    }
-  }
-
-  struct PageHeader {
-    PageHeader *next;  // pointer to the start of the next set of pages.
-    size_t num_pages;  // the number of pages in this set.
-  };
-
-  const size_t page_size_;
-  PageHeader *last_;
-  uint8_t *current_page_;
-  size_t page_offset_;
-};
-
-// Wrapper to use with STL containers
-template <typename T>
-struct PageStdAllocator : public std::allocator<T> {
-  typedef typename std::allocator<T>::pointer pointer;
-  typedef typename std::allocator<T>::size_type size_type;
-
-  explicit PageStdAllocator(PageAllocator& allocator): allocator_(allocator) {}
-  template <class Other> PageStdAllocator(const PageStdAllocator<Other>& other)
-      : allocator_(other.allocator_) {}
-
-  inline pointer allocate(size_type n, const void* = 0) {
-    return static_cast<pointer>(allocator_.Alloc(sizeof(T) * n));
-  }
-
-  inline void deallocate(pointer, size_type) {
-    // The PageAllocator doesn't free.
-  }
-
-  template <typename U> struct rebind {
-    typedef PageStdAllocator<U> other;
-  };
-
- private:
-  // Silly workaround for the gcc from Android's ndk (gcc 4.6), which will
-  // otherwise complain that `other.allocator_` is private in the constructor
-  // code.
-  template<typename Other> friend struct PageStdAllocator;
-
-  PageAllocator& allocator_;
-};
-
-// A wasteful vector is a std::vector, except that it allocates memory from a
-// PageAllocator. It's wasteful because, when resizing, it always allocates a
-// whole new array since the PageAllocator doesn't support realloc.
-template<class T>
-class wasteful_vector : public std::vector<T, PageStdAllocator<T> > {
- public:
-  wasteful_vector(PageAllocator* allocator, unsigned size_hint = 16)
-      : std::vector<T, PageStdAllocator<T> >(PageStdAllocator<T>(*allocator)) {
-    std::vector<T, PageStdAllocator<T> >::reserve(size_hint);
-  }
-};
-
-}  // namespace google_breakpad
-
-inline void* operator new(size_t nbytes,
-                          google_breakpad::PageAllocator& allocator) {
-  return allocator.Alloc(nbytes);
-}
-
-#endif  // GOOGLE_BREAKPAD_COMMON_MEMORY_H_
diff --git a/TMessagesProj/jni/breakpad/common/memory_range.h b/TMessagesProj/jni/breakpad/common/memory_range.h
deleted file mode 100644
index 41dd2da62..000000000
--- a/TMessagesProj/jni/breakpad/common/memory_range.h
+++ /dev/null
@@ -1,145 +0,0 @@
-// Copyright (c) 2011, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// memory_range.h: Define the google_breakpad::MemoryRange class, which
-// is a lightweight wrapper with a pointer and a length to encapsulate
-// a contiguous range of memory.
-
-#ifndef COMMON_MEMORY_RANGE_H_
-#define COMMON_MEMORY_RANGE_H_
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-
-// A lightweight wrapper with a pointer and a length to encapsulate a
-// contiguous range of memory. It provides helper methods for checked
-// access of a subrange of the memory. Its implemementation does not
-// allocate memory or call into libc functions, and is thus safer to use
-// in a crashed environment.
-class MemoryRange {
- public:
-  MemoryRange() : data_(NULL), length_(0) {}
-
-  MemoryRange(const void* data, size_t length) {
-    Set(data, length);
-  }
-
-  // Returns true if this memory range contains no data.
-  bool IsEmpty() const {
-    // Set() guarantees that |length_| is zero if |data_| is NULL.
-    return length_ == 0;
-  }
-
-  // Resets to an empty range.
-  void Reset() {
-    data_ = NULL;
-    length_ = 0;
-  }
-
-  // Sets this memory range to point to |data| and its length to |length|.
-  void Set(const void* data, size_t length) {
-    data_ = reinterpret_cast<const uint8_t*>(data);
-    // Always set |length_| to zero if |data_| is NULL.
-    length_ = data ? length : 0;
-  }
-
-  // Returns true if this range covers a subrange of |sub_length| bytes
-  // at |sub_offset| bytes of this memory range, or false otherwise.
-  bool Covers(size_t sub_offset, size_t sub_length) const {
-    // The following checks verify that:
-    // 1. sub_offset is within [ 0 .. length_ - 1 ]
-    // 2. sub_offset + sub_length is within
-    //    [ sub_offset .. length_ ]
-    return sub_offset < length_ &&
-           sub_offset + sub_length >= sub_offset &&
-           sub_offset + sub_length <= length_;
-  }
-
-  // Returns a raw data pointer to a subrange of |sub_length| bytes at
-  // |sub_offset| bytes of this memory range, or NULL if the subrange
-  // is out of bounds.
-  const void* GetData(size_t sub_offset, size_t sub_length) const {
-    return Covers(sub_offset, sub_length) ? (data_ + sub_offset) : NULL;
-  }
-
-  // Same as the two-argument version of GetData() but uses sizeof(DataType)
-  // as the subrange length and returns an |DataType| pointer for convenience.
-  template <typename DataType>
-  const DataType* GetData(size_t sub_offset) const {
-    return reinterpret_cast<const DataType*>(
-        GetData(sub_offset, sizeof(DataType)));
-  }
-
-  // Returns a raw pointer to the |element_index|-th element of an array
-  // of elements of length |element_size| starting at |sub_offset| bytes
-  // of this memory range, or NULL if the element is out of bounds.
-  const void* GetArrayElement(size_t element_offset,
-                              size_t element_size,
-                              unsigned element_index) const {
-    size_t sub_offset = element_offset + element_index * element_size;
-    return GetData(sub_offset, element_size);
-  }
-
-  // Same as the three-argument version of GetArrayElement() but deduces
-  // the element size using sizeof(ElementType) and returns an |ElementType|
-  // pointer for convenience.
-  template <typename ElementType>
-  const ElementType* GetArrayElement(size_t element_offset,
-                                     unsigned element_index) const {
-    return reinterpret_cast<const ElementType*>(
-        GetArrayElement(element_offset, sizeof(ElementType), element_index));
-  }
-
-  // Returns a subrange of |sub_length| bytes at |sub_offset| bytes of
-  // this memory range, or an empty range if the subrange is out of bounds.
-  MemoryRange Subrange(size_t sub_offset, size_t sub_length) const {
-    return Covers(sub_offset, sub_length) ?
-        MemoryRange(data_ + sub_offset, sub_length) : MemoryRange();
-  }
-
-  // Returns a pointer to the beginning of this memory range.
-  const uint8_t* data() const { return data_; }
-
-  // Returns the length, in bytes, of this memory range.
-  size_t length() const { return length_; }
-
- private:
-  // Pointer to the beginning of this memory range.
-  const uint8_t* data_;
-
-  // Length, in bytes, of this memory range.
-  size_t length_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_MEMORY_RANGE_H_
diff --git a/TMessagesProj/jni/breakpad/common/minidump_type_helper.h b/TMessagesProj/jni/breakpad/common/minidump_type_helper.h
deleted file mode 100644
index 5a7d5a6a8..000000000
--- a/TMessagesProj/jni/breakpad/common/minidump_type_helper.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
-
-#include <stdint.h>
-
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-template <size_t>
-struct MDTypeHelper;
-
-template <>
-struct MDTypeHelper<sizeof(uint32_t)> {
-  typedef MDRawDebug32 MDRawDebug;
-  typedef MDRawLinkMap32 MDRawLinkMap;
-};
-
-template <>
-struct MDTypeHelper<sizeof(uint64_t)> {
-  typedef MDRawDebug64 MDRawDebug;
-  typedef MDRawLinkMap64 MDRawLinkMap;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
diff --git a/TMessagesProj/jni/breakpad/common/scoped_ptr.h b/TMessagesProj/jni/breakpad/common/scoped_ptr.h
deleted file mode 100644
index d137c1868..000000000
--- a/TMessagesProj/jni/breakpad/common/scoped_ptr.h
+++ /dev/null
@@ -1,404 +0,0 @@
-// Copyright 2013 Google Inc. All Rights Reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Scopers help you manage ownership of a pointer, helping you easily manage the
-// a pointer within a scope, and automatically destroying the pointer at the
-// end of a scope.  There are two main classes you will use, which correspond
-// to the operators new/delete and new[]/delete[].
-//
-// Example usage (scoped_ptr):
-//   {
-//     scoped_ptr<Foo> foo(new Foo("wee"));
-//   }  // foo goes out of scope, releasing the pointer with it.
-//
-//   {
-//     scoped_ptr<Foo> foo;          // No pointer managed.
-//     foo.reset(new Foo("wee"));    // Now a pointer is managed.
-//     foo.reset(new Foo("wee2"));   // Foo("wee") was destroyed.
-//     foo.reset(new Foo("wee3"));   // Foo("wee2") was destroyed.
-//     foo->Method();                // Foo::Method() called.
-//     foo.get()->Method();          // Foo::Method() called.
-//     SomeFunc(foo.release());      // SomeFunc takes ownership, foo no longer
-//                                   // manages a pointer.
-//     foo.reset(new Foo("wee4"));   // foo manages a pointer again.
-//     foo.reset();                  // Foo("wee4") destroyed, foo no longer
-//                                   // manages a pointer.
-//   }  // foo wasn't managing a pointer, so nothing was destroyed.
-//
-// Example usage (scoped_array):
-//   {
-//     scoped_array<Foo> foo(new Foo[100]);
-//     foo.get()->Method();  // Foo::Method on the 0th element.
-//     foo[10].Method();     // Foo::Method on the 10th element.
-//   }
-
-#ifndef COMMON_SCOPED_PTR_H_
-#define COMMON_SCOPED_PTR_H_
-
-// This is an implementation designed to match the anticipated future TR2
-// implementation of the scoped_ptr class, and its closely-related brethren,
-// scoped_array, scoped_ptr_malloc.
-
-#include <assert.h>
-#include <stddef.h>
-#include <stdlib.h>
-
-namespace google_breakpad {
-
-// A scoped_ptr<T> is like a T*, except that the destructor of scoped_ptr<T>
-// automatically deletes the pointer it holds (if any).
-// That is, scoped_ptr<T> owns the T object that it points to.
-// Like a T*, a scoped_ptr<T> may hold either NULL or a pointer to a T object.
-// Also like T*, scoped_ptr<T> is thread-compatible, and once you
-// dereference it, you get the threadsafety guarantees of T.
-//
-// The size of a scoped_ptr is small:
-// sizeof(scoped_ptr<C>) == sizeof(C*)
-template <class C>
-class scoped_ptr {
- public:
-
-  // The element type
-  typedef C element_type;
-
-  // Constructor.  Defaults to initializing with NULL.
-  // There is no way to create an uninitialized scoped_ptr.
-  // The input parameter must be allocated with new.
-  explicit scoped_ptr(C* p = NULL) : ptr_(p) { }
-
-  // Destructor.  If there is a C object, delete it.
-  // We don't need to test ptr_ == NULL because C++ does that for us.
-  ~scoped_ptr() {
-    enum { type_must_be_complete = sizeof(C) };
-    delete ptr_;
-  }
-
-  // Reset.  Deletes the current owned object, if any.
-  // Then takes ownership of a new object, if given.
-  // this->reset(this->get()) works.
-  void reset(C* p = NULL) {
-    if (p != ptr_) {
-      enum { type_must_be_complete = sizeof(C) };
-      delete ptr_;
-      ptr_ = p;
-    }
-  }
-
-  // Accessors to get the owned object.
-  // operator* and operator-> will assert() if there is no current object.
-  C& operator*() const {
-    assert(ptr_ != NULL);
-    return *ptr_;
-  }
-  C* operator->() const  {
-    assert(ptr_ != NULL);
-    return ptr_;
-  }
-  C* get() const { return ptr_; }
-
-  // Comparison operators.
-  // These return whether two scoped_ptr refer to the same object, not just to
-  // two different but equal objects.
-  bool operator==(C* p) const { return ptr_ == p; }
-  bool operator!=(C* p) const { return ptr_ != p; }
-
-  // Swap two scoped pointers.
-  void swap(scoped_ptr& p2) {
-    C* tmp = ptr_;
-    ptr_ = p2.ptr_;
-    p2.ptr_ = tmp;
-  }
-
-  // Release a pointer.
-  // The return value is the current pointer held by this object.
-  // If this object holds a NULL pointer, the return value is NULL.
-  // After this operation, this object will hold a NULL pointer,
-  // and will not own the object any more.
-  C* release() {
-    C* retVal = ptr_;
-    ptr_ = NULL;
-    return retVal;
-  }
-
- private:
-  C* ptr_;
-
-  // Forbid comparison of scoped_ptr types.  If C2 != C, it totally doesn't
-  // make sense, and if C2 == C, it still doesn't make sense because you should
-  // never have the same object owned by two different scoped_ptrs.
-  template <class C2> bool operator==(scoped_ptr<C2> const& p2) const;
-  template <class C2> bool operator!=(scoped_ptr<C2> const& p2) const;
-
-  // Disallow evil constructors
-  scoped_ptr(const scoped_ptr&);
-  void operator=(const scoped_ptr&);
-};
-
-// Free functions
-template <class C>
-void swap(scoped_ptr<C>& p1, scoped_ptr<C>& p2) {
-  p1.swap(p2);
-}
-
-template <class C>
-bool operator==(C* p1, const scoped_ptr<C>& p2) {
-  return p1 == p2.get();
-}
-
-template <class C>
-bool operator!=(C* p1, const scoped_ptr<C>& p2) {
-  return p1 != p2.get();
-}
-
-// scoped_array<C> is like scoped_ptr<C>, except that the caller must allocate
-// with new [] and the destructor deletes objects with delete [].
-//
-// As with scoped_ptr<C>, a scoped_array<C> either points to an object
-// or is NULL.  A scoped_array<C> owns the object that it points to.
-// scoped_array<T> is thread-compatible, and once you index into it,
-// the returned objects have only the threadsafety guarantees of T.
-//
-// Size: sizeof(scoped_array<C>) == sizeof(C*)
-template <class C>
-class scoped_array {
- public:
-
-  // The element type
-  typedef C element_type;
-
-  // Constructor.  Defaults to intializing with NULL.
-  // There is no way to create an uninitialized scoped_array.
-  // The input parameter must be allocated with new [].
-  explicit scoped_array(C* p = NULL) : array_(p) { }
-
-  // Destructor.  If there is a C object, delete it.
-  // We don't need to test ptr_ == NULL because C++ does that for us.
-  ~scoped_array() {
-    enum { type_must_be_complete = sizeof(C) };
-    delete[] array_;
-  }
-
-  // Reset.  Deletes the current owned object, if any.
-  // Then takes ownership of a new object, if given.
-  // this->reset(this->get()) works.
-  void reset(C* p = NULL) {
-    if (p != array_) {
-      enum { type_must_be_complete = sizeof(C) };
-      delete[] array_;
-      array_ = p;
-    }
-  }
-
-  // Get one element of the current object.
-  // Will assert() if there is no current object, or index i is negative.
-  C& operator[](ptrdiff_t i) const {
-    assert(i >= 0);
-    assert(array_ != NULL);
-    return array_[i];
-  }
-
-  // Get a pointer to the zeroth element of the current object.
-  // If there is no current object, return NULL.
-  C* get() const {
-    return array_;
-  }
-
-  // Comparison operators.
-  // These return whether two scoped_array refer to the same object, not just to
-  // two different but equal objects.
-  bool operator==(C* p) const { return array_ == p; }
-  bool operator!=(C* p) const { return array_ != p; }
-
-  // Swap two scoped arrays.
-  void swap(scoped_array& p2) {
-    C* tmp = array_;
-    array_ = p2.array_;
-    p2.array_ = tmp;
-  }
-
-  // Release an array.
-  // The return value is the current pointer held by this object.
-  // If this object holds a NULL pointer, the return value is NULL.
-  // After this operation, this object will hold a NULL pointer,
-  // and will not own the object any more.
-  C* release() {
-    C* retVal = array_;
-    array_ = NULL;
-    return retVal;
-  }
-
- private:
-  C* array_;
-
-  // Forbid comparison of different scoped_array types.
-  template <class C2> bool operator==(scoped_array<C2> const& p2) const;
-  template <class C2> bool operator!=(scoped_array<C2> const& p2) const;
-
-  // Disallow evil constructors
-  scoped_array(const scoped_array&);
-  void operator=(const scoped_array&);
-};
-
-// Free functions
-template <class C>
-void swap(scoped_array<C>& p1, scoped_array<C>& p2) {
-  p1.swap(p2);
-}
-
-template <class C>
-bool operator==(C* p1, const scoped_array<C>& p2) {
-  return p1 == p2.get();
-}
-
-template <class C>
-bool operator!=(C* p1, const scoped_array<C>& p2) {
-  return p1 != p2.get();
-}
-
-// This class wraps the c library function free() in a class that can be
-// passed as a template argument to scoped_ptr_malloc below.
-class ScopedPtrMallocFree {
- public:
-  inline void operator()(void* x) const {
-    free(x);
-  }
-};
-
-// scoped_ptr_malloc<> is similar to scoped_ptr<>, but it accepts a
-// second template argument, the functor used to free the object.
-
-template<class C, class FreeProc = ScopedPtrMallocFree>
-class scoped_ptr_malloc {
- public:
-
-  // The element type
-  typedef C element_type;
-
-  // Constructor.  Defaults to initializing with NULL.
-  // There is no way to create an uninitialized scoped_ptr.
-  // The input parameter must be allocated with an allocator that matches the
-  // Free functor.  For the default Free functor, this is malloc, calloc, or
-  // realloc.
-  explicit scoped_ptr_malloc(C* p = NULL): ptr_(p) {}
-
-  // Destructor.  If there is a C object, call the Free functor.
-  ~scoped_ptr_malloc() {
-    reset();
-  }
-
-  // Reset.  Calls the Free functor on the current owned object, if any.
-  // Then takes ownership of a new object, if given.
-  // this->reset(this->get()) works.
-  void reset(C* p = NULL) {
-    if (ptr_ != p) {
-      FreeProc free_proc;
-      free_proc(ptr_);
-      ptr_ = p;
-    }
-  }
-
-  // Get the current object.
-  // operator* and operator-> will cause an assert() failure if there is
-  // no current object.
-  C& operator*() const {
-    assert(ptr_ != NULL);
-    return *ptr_;
-  }
-
-  C* operator->() const {
-    assert(ptr_ != NULL);
-    return ptr_;
-  }
-
-  C* get() const {
-    return ptr_;
-  }
-
-  // Comparison operators.
-  // These return whether a scoped_ptr_malloc and a plain pointer refer
-  // to the same object, not just to two different but equal objects.
-  // For compatibility with the boost-derived implementation, these
-  // take non-const arguments.
-  bool operator==(C* p) const {
-    return ptr_ == p;
-  }
-
-  bool operator!=(C* p) const {
-    return ptr_ != p;
-  }
-
-  // Swap two scoped pointers.
-  void swap(scoped_ptr_malloc & b) {
-    C* tmp = b.ptr_;
-    b.ptr_ = ptr_;
-    ptr_ = tmp;
-  }
-
-  // Release a pointer.
-  // The return value is the current pointer held by this object.
-  // If this object holds a NULL pointer, the return value is NULL.
-  // After this operation, this object will hold a NULL pointer,
-  // and will not own the object any more.
-  C* release() {
-    C* tmp = ptr_;
-    ptr_ = NULL;
-    return tmp;
-  }
-
- private:
-  C* ptr_;
-
-  // no reason to use these: each scoped_ptr_malloc should have its own object
-  template <class C2, class GP>
-  bool operator==(scoped_ptr_malloc<C2, GP> const& p) const;
-  template <class C2, class GP>
-  bool operator!=(scoped_ptr_malloc<C2, GP> const& p) const;
-
-  // Disallow evil constructors
-  scoped_ptr_malloc(const scoped_ptr_malloc&);
-  void operator=(const scoped_ptr_malloc&);
-};
-
-template<class C, class FP> inline
-void swap(scoped_ptr_malloc<C, FP>& a, scoped_ptr_malloc<C, FP>& b) {
-  a.swap(b);
-}
-
-template<class C, class FP> inline
-bool operator==(C* p, const scoped_ptr_malloc<C, FP>& b) {
-  return p == b.get();
-}
-
-template<class C, class FP> inline
-bool operator!=(C* p, const scoped_ptr_malloc<C, FP>& b) {
-  return p != b.get();
-}
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_SCOPED_PTR_H_
diff --git a/TMessagesProj/jni/breakpad/common/string_conversion.cc b/TMessagesProj/jni/breakpad/common/string_conversion.cc
deleted file mode 100644
index 9c0d623fc..000000000
--- a/TMessagesProj/jni/breakpad/common/string_conversion.cc
+++ /dev/null
@@ -1,155 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include <string.h>
-
-#include "common/convert_UTF.h"
-#include "common/scoped_ptr.h"
-#include "common/string_conversion.h"
-#include "common/using_std_string.h"
-
-namespace google_breakpad {
-
-using std::vector;
-
-void UTF8ToUTF16(const char *in, vector<uint16_t> *out) {
-  size_t source_length = strlen(in);
-  const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
-  const UTF8 *source_end_ptr = source_ptr + source_length;
-  // Erase the contents and zero fill to the expected size
-  out->clear();
-  out->insert(out->begin(), source_length, 0);
-  uint16_t *target_ptr = &(*out)[0];
-  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
-  ConversionResult result = ConvertUTF8toUTF16(&source_ptr, source_end_ptr,
-                                               &target_ptr, target_end_ptr,
-                                               strictConversion);
-
-  // Resize to be the size of the # of converted characters + NULL
-  out->resize(result == conversionOK ? target_ptr - &(*out)[0] + 1: 0);
-}
-
-int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]) {
-  const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
-  const UTF8 *source_end_ptr = source_ptr + sizeof(char);
-  uint16_t *target_ptr = out;
-  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
-  out[0] = out[1] = 0;
-
-  // Process one character at a time
-  while (1) {
-    ConversionResult result = ConvertUTF8toUTF16(&source_ptr, source_end_ptr,
-                                                 &target_ptr, target_end_ptr,
-                                                 strictConversion);
-
-    if (result == conversionOK)
-      return static_cast<int>(source_ptr - reinterpret_cast<const UTF8 *>(in));
-
-    // Add another character to the input stream and try again
-    source_ptr = reinterpret_cast<const UTF8 *>(in);
-    ++source_end_ptr;
-
-    if (source_end_ptr > reinterpret_cast<const UTF8 *>(in) + in_length)
-      break;
-  }
-
-  return 0;
-}
-
-void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out) {
-  size_t source_length = wcslen(in);
-  const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(in);
-  const UTF32 *source_end_ptr = source_ptr + source_length;
-  // Erase the contents and zero fill to the expected size
-  out->clear();
-  out->insert(out->begin(), source_length, 0);
-  uint16_t *target_ptr = &(*out)[0];
-  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
-  ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
-                                                &target_ptr, target_end_ptr,
-                                                strictConversion);
-
-  // Resize to be the size of the # of converted characters + NULL
-  out->resize(result == conversionOK ? target_ptr - &(*out)[0] + 1: 0);
-}
-
-void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]) {
-  const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(&in);
-  const UTF32 *source_end_ptr = source_ptr + 1;
-  uint16_t *target_ptr = out;
-  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
-  out[0] = out[1] = 0;
-  ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
-                                                &target_ptr, target_end_ptr,
-                                                strictConversion);
-
-  if (result != conversionOK) {
-    out[0] = out[1] = 0;
-  }
-}
-
-static inline uint16_t Swap(uint16_t value) {
-  return (value >> 8) | static_cast<uint16_t>(value << 8);
-}
-
-string UTF16ToUTF8(const vector<uint16_t> &in, bool swap) {
-  const UTF16 *source_ptr = &in[0];
-  scoped_array<uint16_t> source_buffer;
-
-  // If we're to swap, we need to make a local copy and swap each byte pair
-  if (swap) {
-    int idx = 0;
-    source_buffer.reset(new uint16_t[in.size()]);
-    UTF16 *source_buffer_ptr = source_buffer.get();
-    for (vector<uint16_t>::const_iterator it = in.begin();
-         it != in.end(); ++it, ++idx)
-      source_buffer_ptr[idx] = Swap(*it);
-
-    source_ptr = source_buffer.get();
-  }
-
-  // The maximum expansion would be 4x the size of the input string.
-  const UTF16 *source_end_ptr = source_ptr + in.size();
-  size_t target_capacity = in.size() * 4;
-  scoped_array<UTF8> target_buffer(new UTF8[target_capacity]);
-  UTF8 *target_ptr = target_buffer.get();
-  UTF8 *target_end_ptr = target_ptr + target_capacity;
-  ConversionResult result = ConvertUTF16toUTF8(&source_ptr, source_end_ptr,
-                                               &target_ptr, target_end_ptr,
-                                               strictConversion);
-
-  if (result == conversionOK) {
-    const char *targetPtr = reinterpret_cast<const char *>(target_buffer.get());
-    return targetPtr;
-  }
-
-  return "";
-}
-
-}  // namespace google_breakpad
diff --git a/TMessagesProj/jni/breakpad/common/string_conversion.h b/TMessagesProj/jni/breakpad/common/string_conversion.h
deleted file mode 100644
index b9ba96a2e..000000000
--- a/TMessagesProj/jni/breakpad/common/string_conversion.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// string_conversion.h: Conversion between different UTF-8/16/32 encodings.
-
-#ifndef COMMON_STRING_CONVERSION_H__
-#define COMMON_STRING_CONVERSION_H__
-
-#include <string>
-#include <vector>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-  
-using std::vector;
-
-// Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
-// conversion failed, |out| will be zero length.
-void UTF8ToUTF16(const char *in, vector<uint16_t> *out);
-
-// Convert at least one character (up to a maximum of |in_length|) from |in|
-// to UTF-16 into |out|.  Return the number of characters consumed from |in|.
-// Any unused characters in |out| will be initialized to 0.  No memory will
-// be allocated by this routine.
-int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]);
-
-// Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
-// conversion failed, |out| will be zero length.
-void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out);
-
-// Convert |in| to UTF-16 into |out|.  Any unused characters in |out| will be
-// initialized to 0.  No memory will be allocated by this routine.
-void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]);
-
-// Convert |in| to UTF-8.  If |swap| is true, swap bytes before converting.
-string UTF16ToUTF8(const vector<uint16_t> &in, bool swap);
-
-}  // namespace google_breakpad
-
-#endif  // COMMON_STRING_CONVERSION_H__
diff --git a/TMessagesProj/jni/breakpad/common/symbol_data.h b/TMessagesProj/jni/breakpad/common/symbol_data.h
deleted file mode 100644
index 2cf15a855..000000000
--- a/TMessagesProj/jni/breakpad/common/symbol_data.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// -*- mode: c++ -*-
-
-// Copyright (c) 2013 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef COMMON_SYMBOL_DATA_H_
-#define COMMON_SYMBOL_DATA_H_
-
-// Control what data is used from the symbol file.
-enum SymbolData {
-  ALL_SYMBOL_DATA,
-  NO_CFI,
-  ONLY_CFI
-};
-
-#endif  // COMMON_SYMBOL_DATA_H_
diff --git a/TMessagesProj/jni/breakpad/common/unordered.h b/TMessagesProj/jni/breakpad/common/unordered.h
deleted file mode 100644
index ec665cc02..000000000
--- a/TMessagesProj/jni/breakpad/common/unordered.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Include this file to use unordered_map and unordered_set.  If tr1
-// or C++11 is not available, you can switch to using hash_set and
-// hash_map by defining BP_USE_HASH_SET.
-
-#ifndef COMMON_UNORDERED_H_
-#define COMMON_UNORDERED_H_
-
-#if defined(BP_USE_HASH_SET)
-#include <hash_map>
-#include <hash_set>
-
-// For hash<string>.
-#include "util/hash/hash.h"
-
-template <class T, class U, class H = __gnu_cxx::hash<T> >
-struct unordered_map : public hash_map<T, U, H> {};
-template <class T, class H = __gnu_cxx::hash<T> >
-struct unordered_set : public hash_set<T, H> {};
-
-#elif defined(_LIBCPP_VERSION)  // c++11
-#include <unordered_map>
-#include <unordered_set>
-using std::unordered_map;
-using std::unordered_set;
-
-#else  // Fallback to tr1::unordered
-#include <tr1/unordered_map>
-#include <tr1/unordered_set>
-using std::tr1::unordered_map;
-using std::tr1::unordered_set;
-#endif
-
-#endif  // COMMON_UNORDERED_H_
diff --git a/TMessagesProj/jni/breakpad/common/using_std_string.h b/TMessagesProj/jni/breakpad/common/using_std_string.h
deleted file mode 100644
index 13c1da59c..000000000
--- a/TMessagesProj/jni/breakpad/common/using_std_string.h
+++ /dev/null
@@ -1,65 +0,0 @@
-// -*- mode: C++ -*-
-
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Original author: Ivan Penkov
-
-// using_std_string.h: Allows building this code in environments where
-//                     global string (::string) exists.
-//
-// The problem:
-// -------------
-// Let's say you want to build this code in an environment where a global
-// string type is defined (i.e. ::string).  Now, let's suppose that ::string
-// is different that std::string and you'd like to have the option to easily
-// choose between the two string types.  Ideally you'd like to control which
-// string type is chosen by simply #defining an identifier.
-//
-// The solution:
-// -------------
-// #define HAS_GLOBAL_STRING somewhere in a global header file and then
-// globally replace std::string with string.  Then include this header
-// file everywhere where string is used.  If you want to revert back to
-// using std::string, simply remove the #define (HAS_GLOBAL_STRING).
-
-#ifndef THIRD_PARTY_BREAKPAD_SRC_COMMON_USING_STD_STRING_H_
-#define THIRD_PARTY_BREAKPAD_SRC_COMMON_USING_STD_STRING_H_
-
-#ifdef HAS_GLOBAL_STRING
-  typedef ::string google_breakpad_string;
-#else
-  using std::string;
-  typedef std::string google_breakpad_string;
-#endif
-
-// Inicates that type google_breakpad_string is defined
-#define HAS_GOOGLE_BREAKPAD_STRING
-
-#endif  // THIRD_PARTY_BREAKPAD_SRC_COMMON_USING_STD_STRING_H_
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/breakpad_types.h b/TMessagesProj/jni/breakpad/google_breakpad/common/breakpad_types.h
deleted file mode 100644
index e92436ff2..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/breakpad_types.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* breakpad_types.h: Precise-width types
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file ensures that types uintN_t are defined for N = 8, 16, 32, and
- * 64.  Types of precise widths are crucial to the task of writing data
- * structures on one platform and reading them on another.
- *
- * Author: Mark Mentovai */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
-#define GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
-
-#ifndef _WIN32
-
-#ifndef __STDC_FORMAT_MACROS
-#define __STDC_FORMAT_MACROS
-#endif  /* __STDC_FORMAT_MACROS */
-#include <inttypes.h>
-
-#else  /* !_WIN32 */
-
-#if _MSC_VER >= 1600
-#include <stdint.h>
-#elif defined(BREAKPAD_CUSTOM_STDINT_H)
-/* Visual C++ Pre-2010 did not ship a stdint.h, so allow
- * consumers of this library to provide their own because
- * there are often subtle type incompatibilities.
- */
-#include BREAKPAD_CUSTOM_STDINT_H
-#else
-#include <wtypes.h>
-
-typedef unsigned __int8  uint8_t;
-typedef unsigned __int16 uint16_t;
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
-typedef unsigned __int64 uint64_t;
-#endif
-
-#endif  /* !_WIN32 */
-
-typedef struct {
-  uint64_t high;
-  uint64_t low;
-} uint128_struct;
-
-typedef uint64_t breakpad_time_t;
-
-/* Try to get PRIx64 from inttypes.h, but if it's not defined, fall back to
- * llx, which is the format string for "long long" - this is a 64-bit
- * integral type on many systems. */
-#ifndef PRIx64
-#define PRIx64 "llx"
-#endif  /* !PRIx64 */
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_amd64.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_amd64.h
deleted file mode 100644
index 4256706d7..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_amd64.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on amd64.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by ensuring
- * ensuring that all members are aligned on their natural boundaries.  In
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Mark Mentovai
- * Change to split into its own file: Neal Sidhwaney */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_AMD64_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_AMD64_H__
-
-
-/*
- * AMD64 support, see WINNT.H
- */
-
-typedef struct {
-  uint16_t       control_word;
-  uint16_t       status_word;
-  uint8_t        tag_word;
-  uint8_t        reserved1;
-  uint16_t       error_opcode;
-  uint32_t       error_offset;
-  uint16_t       error_selector;
-  uint16_t       reserved2;
-  uint32_t       data_offset;
-  uint16_t       data_selector;
-  uint16_t       reserved3;
-  uint32_t       mx_csr;
-  uint32_t       mx_csr_mask;
-  uint128_struct float_registers[8];
-  uint128_struct xmm_registers[16];
-  uint8_t        reserved4[96];
-} MDXmmSaveArea32AMD64;  /* XMM_SAVE_AREA32 */
-
-#define MD_CONTEXT_AMD64_VR_COUNT 26
-
-typedef struct {
-  /*
-   * Register parameter home addresses.
-   */
-  uint64_t  p1_home;
-  uint64_t  p2_home;
-  uint64_t  p3_home;
-  uint64_t  p4_home;
-  uint64_t  p5_home;
-  uint64_t  p6_home;
-
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated */
-  uint32_t  context_flags;
-  uint32_t  mx_csr;
-
-  /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  uint16_t  cs;
-
-  /* The next 4 registers are included with MD_CONTEXT_AMD64_SEGMENTS */
-  uint16_t  ds;
-  uint16_t  es;
-  uint16_t  fs;
-  uint16_t  gs;
-
-  /* The next 2 registers are included with MD_CONTEXT_AMD64_CONTROL */
-  uint16_t  ss;
-  uint32_t  eflags;
-
-  /* The next 6 registers are included with MD_CONTEXT_AMD64_DEBUG_REGISTERS */
-  uint64_t  dr0;
-  uint64_t  dr1;
-  uint64_t  dr2;
-  uint64_t  dr3;
-  uint64_t  dr6;
-  uint64_t  dr7;
-
-  /* The next 4 registers are included with MD_CONTEXT_AMD64_INTEGER */
-  uint64_t  rax;
-  uint64_t  rcx;
-  uint64_t  rdx;
-  uint64_t  rbx;
-
-  /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  uint64_t  rsp;
-
-  /* The next 11 registers are included with MD_CONTEXT_AMD64_INTEGER */
-  uint64_t  rbp;
-  uint64_t  rsi;
-  uint64_t  rdi;
-  uint64_t  r8;
-  uint64_t  r9;
-  uint64_t  r10;
-  uint64_t  r11;
-  uint64_t  r12;
-  uint64_t  r13;
-  uint64_t  r14;
-  uint64_t  r15;
-
-  /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  uint64_t  rip;
-
-  /* The next set of registers are included with
-   * MD_CONTEXT_AMD64_FLOATING_POINT
-   */
-  union {
-    MDXmmSaveArea32AMD64 flt_save;
-    struct {
-      uint128_struct header[2];
-      uint128_struct legacy[8];
-      uint128_struct xmm0;
-      uint128_struct xmm1;
-      uint128_struct xmm2;
-      uint128_struct xmm3;
-      uint128_struct xmm4;
-      uint128_struct xmm5;
-      uint128_struct xmm6;
-      uint128_struct xmm7;
-      uint128_struct xmm8;
-      uint128_struct xmm9;
-      uint128_struct xmm10;
-      uint128_struct xmm11;
-      uint128_struct xmm12;
-      uint128_struct xmm13;
-      uint128_struct xmm14;
-      uint128_struct xmm15;
-    } sse_registers;
-  };
-
-  uint128_struct vector_register[MD_CONTEXT_AMD64_VR_COUNT];
-  uint64_t       vector_control;
-
-  /* The next 5 registers are included with MD_CONTEXT_AMD64_DEBUG_REGISTERS */
-  uint64_t debug_control;
-  uint64_t last_branch_to_rip;
-  uint64_t last_branch_from_rip;
-  uint64_t last_exception_to_rip;
-  uint64_t last_exception_from_rip;
-
-} MDRawContextAMD64;  /* CONTEXT */
-
-/* For (MDRawContextAMD64).context_flags.  These values indicate the type of
- * context stored in the structure.  The high 24 bits identify the CPU, the
- * low 8 bits identify the type of context saved. */
-#define MD_CONTEXT_AMD64 0x00100000  /* CONTEXT_AMD64 */
-#define MD_CONTEXT_AMD64_CONTROL         (MD_CONTEXT_AMD64 | 0x00000001)
-     /* CONTEXT_CONTROL */
-#define MD_CONTEXT_AMD64_INTEGER         (MD_CONTEXT_AMD64 | 0x00000002)
-     /* CONTEXT_INTEGER */
-#define MD_CONTEXT_AMD64_SEGMENTS        (MD_CONTEXT_AMD64 | 0x00000004)
-     /* CONTEXT_SEGMENTS */
-#define MD_CONTEXT_AMD64_FLOATING_POINT  (MD_CONTEXT_AMD64 | 0x00000008)
-     /* CONTEXT_FLOATING_POINT */
-#define MD_CONTEXT_AMD64_DEBUG_REGISTERS (MD_CONTEXT_AMD64 | 0x00000010)
-     /* CONTEXT_DEBUG_REGISTERS */
-#define MD_CONTEXT_AMD64_XSTATE          (MD_CONTEXT_AMD64 | 0x00000040)
-     /* CONTEXT_XSTATE */
-
-/* WinNT.h refers to CONTEXT_MMX_REGISTERS but doesn't appear to define it
- * I think it really means CONTEXT_FLOATING_POINT.
- */
-
-#define MD_CONTEXT_AMD64_FULL            (MD_CONTEXT_AMD64_CONTROL | \
-                                          MD_CONTEXT_AMD64_INTEGER | \
-                                          MD_CONTEXT_AMD64_FLOATING_POINT)
-     /* CONTEXT_FULL */
-
-#define MD_CONTEXT_AMD64_ALL             (MD_CONTEXT_AMD64_FULL | \
-                                          MD_CONTEXT_AMD64_SEGMENTS | \
-                                          MD_CONTEXT_X86_DEBUG_REGISTERS)
-     /* CONTEXT_ALL */
-
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_AMD64_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm.h
deleted file mode 100644
index 6a7113833..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/* Copyright (c) 2009, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on ARM.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by
- * ensuring that all members are aligned on their natural boundaries.
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.
- *
- * Author: Julian Seward
- */
-
-/*
- * ARM support
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM_H__
-
-#define MD_FLOATINGSAVEAREA_ARM_FPR_COUNT 32
-#define MD_FLOATINGSAVEAREA_ARM_FPEXTRA_COUNT 8
-
-/*
- * Note that these structures *do not* map directly to the CONTEXT
- * structure defined in WinNT.h in the Windows Mobile SDK. That structure
- * does not accomodate VFPv3, and I'm unsure if it was ever used in the
- * wild anyway, as Windows CE only seems to produce "cedumps" which
- * are not exactly minidumps.
- */
-typedef struct {
-  uint64_t      fpscr;      /* FPU status register */
-
-  /* 32 64-bit floating point registers, d0 .. d31. */
-  uint64_t      regs[MD_FLOATINGSAVEAREA_ARM_FPR_COUNT];
-
-  /* Miscellaneous control words */
-  uint32_t     extra[MD_FLOATINGSAVEAREA_ARM_FPEXTRA_COUNT];
-} MDFloatingSaveAreaARM;
-
-#define MD_CONTEXT_ARM_GPR_COUNT 16
-
-typedef struct {
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated
-   */
-  uint32_t      context_flags;
-
-  /* 16 32-bit integer registers, r0 .. r15
-   * Note the following fixed uses:
-   *   r13 is the stack pointer
-   *   r14 is the link register
-   *   r15 is the program counter
-   */
-  uint32_t     iregs[MD_CONTEXT_ARM_GPR_COUNT];
-
-  /* CPSR (flags, basically): 32 bits:
-        bit 31 - N (negative)
-        bit 30 - Z (zero)
-        bit 29 - C (carry)
-        bit 28 - V (overflow)
-        bit 27 - Q (saturation flag, sticky)
-     All other fields -- ignore */
-  uint32_t    cpsr;
-
-  /* The next field is included with MD_CONTEXT_ARM_FLOATING_POINT */
-  MDFloatingSaveAreaARM float_save;
-
-} MDRawContextARM;
-
-/* Indices into iregs for registers with a dedicated or conventional
- * purpose.
- */
-enum MDARMRegisterNumbers {
-  MD_CONTEXT_ARM_REG_IOS_FP = 7,
-  MD_CONTEXT_ARM_REG_FP     = 11,
-  MD_CONTEXT_ARM_REG_SP     = 13,
-  MD_CONTEXT_ARM_REG_LR     = 14,
-  MD_CONTEXT_ARM_REG_PC     = 15
-};
-
-/* For (MDRawContextARM).context_flags.  These values indicate the type of
- * context stored in the structure. */
-/* CONTEXT_ARM from the Windows CE 5.0 SDK. This value isn't correct
- * because this bit can be used for flags. Presumably this value was
- * never actually used in minidumps, but only in "CEDumps" which
- * are a whole parallel minidump file format for Windows CE.
- * Therefore, Breakpad defines its own value for ARM CPUs.
- */
-#define MD_CONTEXT_ARM_OLD               0x00000040
-/* This value was chosen to avoid likely conflicts with MD_CONTEXT_*
- * for other CPUs. */
-#define MD_CONTEXT_ARM                   0x40000000
-#define MD_CONTEXT_ARM_INTEGER           (MD_CONTEXT_ARM | 0x00000002)
-#define MD_CONTEXT_ARM_FLOATING_POINT    (MD_CONTEXT_ARM | 0x00000004)
-
-#define MD_CONTEXT_ARM_FULL              (MD_CONTEXT_ARM_INTEGER | \
-                                          MD_CONTEXT_ARM_FLOATING_POINT)
-
-#define MD_CONTEXT_ARM_ALL               (MD_CONTEXT_ARM_INTEGER | \
-                                          MD_CONTEXT_ARM_FLOATING_POINT)
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm64.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm64.h
deleted file mode 100644
index 5ace0d9de..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_arm64.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/* Copyright 2013 Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on ARM.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by
- * ensuring that all members are aligned on their natural boundaries.
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.
- *
- * Author: Colin Blundell
- */
-
-/*
- * ARM64 support
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__
-
-#define MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT 32
-
-typedef struct {
-  uint32_t       fpsr;      /* FPU status register */
-  uint32_t       fpcr;      /* FPU control register */
-
-  /* 32 128-bit floating point registers, d0 .. d31. */
-  uint128_struct regs[MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT];
-} MDFloatingSaveAreaARM64;
-
-#define MD_CONTEXT_ARM64_GPR_COUNT 33
-
-/* Use the same 32-bit alignment when accessing this structure from 64-bit code
- * as is used natively in 32-bit code. */
-#pragma pack(push, 4)
-
-typedef struct {
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated
-   */
-  uint64_t      context_flags;
-
-  /* 33 64-bit integer registers, x0 .. x31 + the PC
-   * Note the following fixed uses:
-   *   x29 is the frame pointer
-   *   x30 is the link register
-   *   x31 is the stack pointer
-   *   The PC is effectively x32.
-   */
-  uint64_t     iregs[MD_CONTEXT_ARM64_GPR_COUNT];
-
-  /* CPSR (flags, basically): 32 bits:
-        bit 31 - N (negative)
-        bit 30 - Z (zero)
-        bit 29 - C (carry)
-        bit 28 - V (overflow)
-        bit 27 - Q (saturation flag, sticky)
-     All other fields -- ignore */
-  uint32_t    cpsr;
-
-  /* The next field is included with MD_CONTEXT64_ARM_FLOATING_POINT */
-  MDFloatingSaveAreaARM64 float_save;
-
-} MDRawContextARM64;
-
-#pragma pack(pop)
-
-/* Indices into iregs for registers with a dedicated or conventional
- * purpose.
- */
-enum MDARM64RegisterNumbers {
-  MD_CONTEXT_ARM64_REG_FP     = 29,
-  MD_CONTEXT_ARM64_REG_LR     = 30,
-  MD_CONTEXT_ARM64_REG_SP     = 31,
-  MD_CONTEXT_ARM64_REG_PC     = 32
-};
-
-/* For (MDRawContextARM64).context_flags.  These values indicate the type of
- * context stored in the structure. MD_CONTEXT_ARM64 is Breakpad-defined.
- * This value was chosen to avoid likely conflicts with MD_CONTEXT_*
- * for other CPUs. */
-#define MD_CONTEXT_ARM64                   0x80000000
-#define MD_CONTEXT_ARM64_INTEGER           (MD_CONTEXT_ARM64 | 0x00000002)
-#define MD_CONTEXT_ARM64_FLOATING_POINT    (MD_CONTEXT_ARM64 | 0x00000004)
-
-#define MD_CONTEXT_ARM64_FULL              (MD_CONTEXT_ARM64_INTEGER | \
-                                          MD_CONTEXT_ARM64_FLOATING_POINT)
-
-#define MD_CONTEXT_ARM64_ALL               (MD_CONTEXT_ARM64_INTEGER | \
-                                          MD_CONTEXT_ARM64_FLOATING_POINT)
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_mips.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_mips.h
deleted file mode 100644
index 6cbe3023f..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_mips.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/* Copyright (c) 2013, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on MIPS.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by
- * ensuring that all members are aligned on their natural boundaries.
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.
- *
- * Author: Chris Dearman
- */
-
-/*
- * MIPS support
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
-
-#define MD_CONTEXT_MIPS_GPR_COUNT 32
-#define MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT 32
-#define MD_CONTEXT_MIPS_DSP_COUNT 3
-
-/*
- * Note that these structures *do not* map directly to the CONTEXT
- * structure defined in WinNT.h in the Windows Mobile SDK. That structure
- * does not accomodate VFPv3, and I'm unsure if it was ever used in the
- * wild anyway, as Windows CE only seems to produce "cedumps" which
- * are not exactly minidumps.
- */
-typedef struct {
-  /* 32 64-bit floating point registers, f0..f31 */
-  uint64_t regs[MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT];
-
-  uint32_t fpcsr; /* FPU status register. */
-  uint32_t fir; /* FPU implementation register. */
-} MDFloatingSaveAreaMIPS;
-
-typedef struct {
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated.
-   */
-  uint32_t context_flags;
-  uint32_t _pad0;
-
-  /* 32 64-bit integer registers, r0..r31.
-   * Note the following fixed uses:
-   *   r29 is the stack pointer.
-   *   r31 is the return address.
-   */
-  uint64_t iregs[MD_CONTEXT_MIPS_GPR_COUNT];
-
-  /* multiply/divide result. */
-  uint64_t mdhi, mdlo;
-
-  /* DSP accumulators. */
-  uint32_t hi[MD_CONTEXT_MIPS_DSP_COUNT];
-  uint32_t lo[MD_CONTEXT_MIPS_DSP_COUNT];
-  uint32_t dsp_control;
-  uint32_t _pad1;
-
-  uint64_t epc;
-  uint64_t badvaddr;
-  uint32_t status;
-  uint32_t cause;
-
-  /* The next field is included with MD_CONTEXT_MIPS_FLOATING_POINT. */
-  MDFloatingSaveAreaMIPS float_save;
-
-} MDRawContextMIPS;
-
-/* Indices into iregs for registers with a dedicated or conventional
- * purpose.
- */
-enum MDMIPSRegisterNumbers {
-  MD_CONTEXT_MIPS_REG_S0     = 16,
-  MD_CONTEXT_MIPS_REG_S1     = 17,
-  MD_CONTEXT_MIPS_REG_S2     = 18,
-  MD_CONTEXT_MIPS_REG_S3     = 19,
-  MD_CONTEXT_MIPS_REG_S4     = 20,
-  MD_CONTEXT_MIPS_REG_S5     = 21,
-  MD_CONTEXT_MIPS_REG_S6     = 22,
-  MD_CONTEXT_MIPS_REG_S7     = 23,
-  MD_CONTEXT_MIPS_REG_GP     = 28,
-  MD_CONTEXT_MIPS_REG_SP     = 29,
-  MD_CONTEXT_MIPS_REG_FP     = 30,
-  MD_CONTEXT_MIPS_REG_RA     = 31,
-};
-
-/* For (MDRawContextMIPS).context_flags.  These values indicate the type of
- * context stored in the structure. */
-/* CONTEXT_MIPS from the Windows CE 5.0 SDK. This value isn't correct
- * because this bit can be used for flags. Presumably this value was
- * never actually used in minidumps, but only in "CEDumps" which
- * are a whole parallel minidump file format for Windows CE.
- * Therefore, Breakpad defines its own value for MIPS CPUs.
- */
-#define MD_CONTEXT_MIPS  0x00040000
-#define MD_CONTEXT_MIPS_INTEGER           (MD_CONTEXT_MIPS | 0x00000002)
-#define MD_CONTEXT_MIPS_FLOATING_POINT    (MD_CONTEXT_MIPS | 0x00000004)
-#define MD_CONTEXT_MIPS_DSP               (MD_CONTEXT_MIPS | 0x00000008)
-
-#define MD_CONTEXT_MIPS_FULL              (MD_CONTEXT_MIPS_INTEGER | \
-                                           MD_CONTEXT_MIPS_FLOATING_POINT | \
-                                           MD_CONTEXT_MIPS_DSP)
-
-#define MD_CONTEXT_MIPS_ALL               (MD_CONTEXT_MIPS_INTEGER | \
-                                           MD_CONTEXT_MIPS_FLOATING_POINT \
-                                           MD_CONTEXT_MIPS_DSP)
-
-#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc.h
deleted file mode 100644
index b24cc4243..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on ppc.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by ensuring
- * ensuring that all members are aligned on their natural boundaries.  In
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Mark Mentovai 
- * Change to split into its own file: Neal Sidhwaney */
-
-/*
- * Breakpad minidump extension for PowerPC support.  Based on Darwin/Mac OS X'
- * mach/ppc/_types.h
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC_H__
-
-#define MD_FLOATINGSAVEAREA_PPC_FPR_COUNT 32
-
-typedef struct {
-  /* fpregs is a double[32] in mach/ppc/_types.h, but a uint64_t is used
-   * here for precise sizing. */
-  uint64_t fpregs[MD_FLOATINGSAVEAREA_PPC_FPR_COUNT];
-  uint32_t fpscr_pad;
-  uint32_t fpscr;      /* Status/control */
-} MDFloatingSaveAreaPPC;  /* Based on ppc_float_state */
-
-
-#define MD_VECTORSAVEAREA_PPC_VR_COUNT 32
-
-typedef struct {
-  /* Vector registers (including vscr) are 128 bits, but mach/ppc/_types.h
-   * exposes them as four 32-bit quantities. */
-  uint128_struct save_vr[MD_VECTORSAVEAREA_PPC_VR_COUNT];
-  uint128_struct save_vscr;  /* Status/control */
-  uint32_t       save_pad5[4];
-  uint32_t       save_vrvalid;  /* Indicates which vector registers are saved */
-  uint32_t       save_pad6[7];
-} MDVectorSaveAreaPPC;  /* ppc_vector_state */
-
-
-#define MD_CONTEXT_PPC_GPR_COUNT 32
-
-/* Use the same 32-bit alignment when accessing this structure from 64-bit code
- * as is used natively in 32-bit code.  #pragma pack is a MSVC extension
- * supported by gcc. */
-#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-#pragma pack(4)
-#else
-#pragma pack(push, 4)
-#endif
-
-typedef struct {
-  /* context_flags is not present in ppc_thread_state, but it aids
-   * identification of MDRawContextPPC among other raw context types,
-   * and it guarantees alignment when we get to float_save. */
-  uint32_t              context_flags;
-
-  uint32_t              srr0;    /* Machine status save/restore: stores pc
-                                  * (instruction) */
-  uint32_t              srr1;    /* Machine status save/restore: stores msr
-                                  * (ps, program/machine state) */
-  /* ppc_thread_state contains 32 fields, r0 .. r31.  Here, an array is
-   * used for brevity. */
-  uint32_t              gpr[MD_CONTEXT_PPC_GPR_COUNT];
-  uint32_t              cr;      /* Condition */
-  uint32_t              xer;     /* Integer (fiXed-point) exception */
-  uint32_t              lr;      /* Link */
-  uint32_t              ctr;     /* Count */
-  uint32_t              mq;      /* Multiply/Quotient (PPC 601, POWER only) */
-  uint32_t              vrsave;  /* Vector save */
-
-  /* float_save and vector_save aren't present in ppc_thread_state, but
-   * are represented in separate structures that still define a thread's
-   * context. */
-  MDFloatingSaveAreaPPC float_save;
-  MDVectorSaveAreaPPC   vector_save;
-} MDRawContextPPC;  /* Based on ppc_thread_state */
-
-/* Indices into gpr for registers with a dedicated or conventional purpose. */
-enum MDPPCRegisterNumbers {
-  MD_CONTEXT_PPC_REG_SP = 1
-};
-
-#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-#pragma pack(0)
-#else
-#pragma pack(pop)
-#endif
-
-/* For (MDRawContextPPC).context_flags.  These values indicate the type of
- * context stored in the structure.  MD_CONTEXT_PPC is Breakpad-defined.  Its
- * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
- * CPUs. */
-#define MD_CONTEXT_PPC                0x20000000
-#define MD_CONTEXT_PPC_BASE           (MD_CONTEXT_PPC | 0x00000001)
-#define MD_CONTEXT_PPC_FLOATING_POINT (MD_CONTEXT_PPC | 0x00000008)
-#define MD_CONTEXT_PPC_VECTOR         (MD_CONTEXT_PPC | 0x00000020)
-
-#define MD_CONTEXT_PPC_FULL           MD_CONTEXT_PPC_BASE
-#define MD_CONTEXT_PPC_ALL            (MD_CONTEXT_PPC_FULL | \
-                                       MD_CONTEXT_PPC_FLOATING_POINT | \
-                                       MD_CONTEXT_PPC_VECTOR)
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc64.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc64.h
deleted file mode 100644
index 61f419386..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_ppc64.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* Copyright (c) 2008, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on ppc64.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by ensuring
- * ensuring that all members are aligned on their natural boundaries.  In
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Neal Sidhwaney */
-
-
-/*
- * Breakpad minidump extension for PPC64 support.  Based on Darwin/Mac OS X'
- * mach/ppc/_types.h
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC64_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC64_H__
-
-#include "minidump_cpu_ppc.h"
-
-// these types are the same in ppc64 & ppc
-typedef MDFloatingSaveAreaPPC MDFloatingSaveAreaPPC64;
-typedef MDVectorSaveAreaPPC MDVectorSaveAreaPPC64;
-
-#define MD_CONTEXT_PPC64_GPR_COUNT MD_CONTEXT_PPC_GPR_COUNT
-
-typedef struct {
-  /* context_flags is not present in ppc_thread_state, but it aids
-   * identification of MDRawContextPPC among other raw context types,
-   * and it guarantees alignment when we get to float_save. */
-  uint64_t              context_flags;
-
-  uint64_t              srr0;    /* Machine status save/restore: stores pc
-                                  * (instruction) */
-  uint64_t              srr1;    /* Machine status save/restore: stores msr
-                                  * (ps, program/machine state) */
-  /* ppc_thread_state contains 32 fields, r0 .. r31.  Here, an array is
-   * used for brevity. */
-  uint64_t              gpr[MD_CONTEXT_PPC64_GPR_COUNT];
-  uint64_t              cr;      /* Condition */
-  uint64_t              xer;     /* Integer (fiXed-point) exception */
-  uint64_t              lr;      /* Link */
-  uint64_t              ctr;     /* Count */
-  uint64_t              vrsave;  /* Vector save */
-
-  /* float_save and vector_save aren't present in ppc_thread_state, but
-   * are represented in separate structures that still define a thread's
-   * context. */
-  MDFloatingSaveAreaPPC float_save;
-  MDVectorSaveAreaPPC   vector_save;
-} MDRawContextPPC64;  /* Based on ppc_thread_state */
-
-/* Indices into gpr for registers with a dedicated or conventional purpose. */
-enum MDPPC64RegisterNumbers {
-  MD_CONTEXT_PPC64_REG_SP = 1
-};
-
-/* For (MDRawContextPPC).context_flags.  These values indicate the type of
- * context stored in the structure.  MD_CONTEXT_PPC is Breakpad-defined.  Its
- * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
- * CPUs. */
-#define MD_CONTEXT_PPC64                0x01000000
-#define MD_CONTEXT_PPC64_BASE           (MD_CONTEXT_PPC64 | 0x00000001)
-#define MD_CONTEXT_PPC64_FLOATING_POINT (MD_CONTEXT_PPC64 | 0x00000008)
-#define MD_CONTEXT_PPC64_VECTOR         (MD_CONTEXT_PPC64 | 0x00000020)
-
-#define MD_CONTEXT_PPC64_FULL           MD_CONTEXT_PPC64_BASE
-#define MD_CONTEXT_PPC64_ALL            (MD_CONTEXT_PPC64_FULL | \
-                                         MD_CONTEXT_PPC64_FLOATING_POINT | \
-                                         MD_CONTEXT_PPC64_VECTOR)
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC64_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_sparc.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_sparc.h
deleted file mode 100644
index 95c08b174..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_sparc.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on sparc.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by ensuring
- * ensuring that all members are aligned on their natural boundaries.  In
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Mark Mentovai
- * Change to split into its own file: Neal Sidhwaney */
-
-/*
- * SPARC support, see (solaris)sys/procfs_isa.h also
- */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_SPARC_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_SPARC_H__
-
-#define MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT 32
-
-typedef struct {
-
-  /* FPU floating point regs */
-  uint64_t      regs[MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT];
-
-  uint64_t      filler;
-  uint64_t      fsr;        /* FPU status register */
-} MDFloatingSaveAreaSPARC;  /* FLOATING_SAVE_AREA */
-
-#define MD_CONTEXT_SPARC_GPR_COUNT 32
-
-typedef struct {
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated
-   */
-  uint32_t      context_flags;
-  uint32_t      flag_pad;
-  /*
-   * General register access (SPARC).
-   * Don't confuse definitions here with definitions in <sys/regset.h>.
-   * Registers are 32 bits for ILP32, 64 bits for LP64.
-   * SPARC V7/V8 is for 32bit, SPARC V9 is for 64bit
-   */
-
-  /* 32 Integer working registers */
-
-  /* g_r[0-7]   global registers(g0-g7)
-   * g_r[8-15]  out registers(o0-o7)
-   * g_r[16-23] local registers(l0-l7)
-   * g_r[24-31] in registers(i0-i7)
-   */
-  uint64_t     g_r[MD_CONTEXT_SPARC_GPR_COUNT];
-
-  /* several control registers */
-
-  /* Processor State register(PSR) for SPARC V7/V8
-   * Condition Code register (CCR) for SPARC V9
-   */
-  uint64_t     ccr;
-
-  uint64_t     pc;     /* Program Counter register (PC) */
-  uint64_t     npc;    /* Next Program Counter register (nPC) */
-  uint64_t     y;      /* Y register (Y) */
-
-  /* Address Space Identifier register (ASI) for SPARC V9
-   * WIM for SPARC V7/V8
-   */
-  uint64_t     asi;
-
-  /* Floating-Point Registers State register (FPRS) for SPARC V9
-   * TBR for for SPARC V7/V8
-   */
-  uint64_t     fprs;
-
-  /* The next field is included with MD_CONTEXT_SPARC_FLOATING_POINT */
-  MDFloatingSaveAreaSPARC float_save;
-
-} MDRawContextSPARC;  /* CONTEXT_SPARC */
-
-/* Indices into g_r for registers with a dedicated or conventional purpose. */
-enum MDSPARCRegisterNumbers {
-  MD_CONTEXT_SPARC_REG_SP = 14
-};
-
-/* For (MDRawContextSPARC).context_flags.  These values indicate the type of
- * context stored in the structure.  MD_CONTEXT_SPARC is Breakpad-defined.  Its
- * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
- * CPUs. */
-#define MD_CONTEXT_SPARC                 0x10000000
-#define MD_CONTEXT_SPARC_CONTROL         (MD_CONTEXT_SPARC | 0x00000001)
-#define MD_CONTEXT_SPARC_INTEGER         (MD_CONTEXT_SPARC | 0x00000002)
-#define MD_CONTEXT_SAPARC_FLOATING_POINT (MD_CONTEXT_SPARC | 0x00000004)
-#define MD_CONTEXT_SAPARC_EXTRA          (MD_CONTEXT_SPARC | 0x00000008)
-
-#define MD_CONTEXT_SPARC_FULL            (MD_CONTEXT_SPARC_CONTROL | \
-                                          MD_CONTEXT_SPARC_INTEGER)
-
-#define MD_CONTEXT_SPARC_ALL             (MD_CONTEXT_SPARC_FULL | \
-                                          MD_CONTEXT_SAPARC_FLOATING_POINT | \
-                                          MD_CONTEXT_SAPARC_EXTRA)
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_SPARC_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_x86.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_x86.h
deleted file mode 100644
index e09cb7cb5..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_cpu_x86.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * This file contains the necessary definitions to read minidump files
- * produced on x86.  These files may be read on any platform provided
- * that the alignments of these structures on the processing system are
- * identical to the alignments of these structures on the producing system.
- * For this reason, precise-sized types are used.  The structures defined
- * by this file have been laid out to minimize alignment problems by ensuring
- * ensuring that all members are aligned on their natural boundaries.  In
- * In some cases, tail-padding may be significant when different ABIs specify
- * different tail-padding behaviors.  To avoid problems when reading or
- * writing affected structures, MD_*_SIZE macros are provided where needed,
- * containing the useful size of the structures without padding.
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Mark Mentovai */
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_X86_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_X86_H__
-
-#define MD_FLOATINGSAVEAREA_X86_REGISTERAREA_SIZE 80
-     /* SIZE_OF_80387_REGISTERS */
-
-typedef struct {
-  uint32_t control_word;
-  uint32_t status_word;
-  uint32_t tag_word;
-  uint32_t error_offset;
-  uint32_t error_selector;
-  uint32_t data_offset;
-  uint32_t data_selector;
-
-  /* register_area contains eight 80-bit (x87 "long double") quantities for
-   * floating-point registers %st0 (%mm0) through %st7 (%mm7). */
-  uint8_t  register_area[MD_FLOATINGSAVEAREA_X86_REGISTERAREA_SIZE];
-  uint32_t cr0_npx_state;
-} MDFloatingSaveAreaX86;  /* FLOATING_SAVE_AREA */
-
-
-#define MD_CONTEXT_X86_EXTENDED_REGISTERS_SIZE 512
-     /* MAXIMUM_SUPPORTED_EXTENSION */
-
-typedef struct {
-  /* The next field determines the layout of the structure, and which parts
-   * of it are populated */
-  uint32_t             context_flags;
-
-  /* The next 6 registers are included with MD_CONTEXT_X86_DEBUG_REGISTERS */
-  uint32_t             dr0;
-  uint32_t             dr1;
-  uint32_t             dr2;
-  uint32_t             dr3;
-  uint32_t             dr6;
-  uint32_t             dr7;
-
-  /* The next field is included with MD_CONTEXT_X86_FLOATING_POINT */
-  MDFloatingSaveAreaX86 float_save;
-
-  /* The next 4 registers are included with MD_CONTEXT_X86_SEGMENTS */
-  uint32_t             gs; 
-  uint32_t             fs;
-  uint32_t             es;
-  uint32_t             ds;
-  /* The next 6 registers are included with MD_CONTEXT_X86_INTEGER */
-  uint32_t             edi;
-  uint32_t             esi;
-  uint32_t             ebx;
-  uint32_t             edx;
-  uint32_t             ecx;
-  uint32_t             eax;
-
-  /* The next 6 registers are included with MD_CONTEXT_X86_CONTROL */
-  uint32_t             ebp;
-  uint32_t             eip;
-  uint32_t             cs;      /* WinNT.h says "must be sanitized" */
-  uint32_t             eflags;  /* WinNT.h says "must be sanitized" */
-  uint32_t             esp;
-  uint32_t             ss;
-
-  /* The next field is included with MD_CONTEXT_X86_EXTENDED_REGISTERS.
-   * It contains vector (MMX/SSE) registers.  It it laid out in the
-   * format used by the fxsave and fsrstor instructions, so it includes
-   * a copy of the x87 floating-point registers as well.  See FXSAVE in
-   * "Intel Architecture Software Developer's Manual, Volume 2." */
-  uint8_t              extended_registers[
-                         MD_CONTEXT_X86_EXTENDED_REGISTERS_SIZE];
-} MDRawContextX86;  /* CONTEXT */
-
-/* For (MDRawContextX86).context_flags.  These values indicate the type of
- * context stored in the structure.  The high 24 bits identify the CPU, the
- * low 8 bits identify the type of context saved. */
-#define MD_CONTEXT_X86                    0x00010000
-     /* CONTEXT_i386, CONTEXT_i486: identifies CPU */
-#define MD_CONTEXT_X86_CONTROL            (MD_CONTEXT_X86 | 0x00000001)
-     /* CONTEXT_CONTROL */
-#define MD_CONTEXT_X86_INTEGER            (MD_CONTEXT_X86 | 0x00000002)
-     /* CONTEXT_INTEGER */
-#define MD_CONTEXT_X86_SEGMENTS           (MD_CONTEXT_X86 | 0x00000004)
-     /* CONTEXT_SEGMENTS */
-#define MD_CONTEXT_X86_FLOATING_POINT     (MD_CONTEXT_X86 | 0x00000008)
-     /* CONTEXT_FLOATING_POINT */
-#define MD_CONTEXT_X86_DEBUG_REGISTERS    (MD_CONTEXT_X86 | 0x00000010)
-     /* CONTEXT_DEBUG_REGISTERS */
-#define MD_CONTEXT_X86_EXTENDED_REGISTERS (MD_CONTEXT_X86 | 0x00000020)
-     /* CONTEXT_EXTENDED_REGISTERS */
-#define MD_CONTEXT_X86_XSTATE             (MD_CONTEXT_X86 | 0x00000040)
-     /* CONTEXT_XSTATE */
-
-#define MD_CONTEXT_X86_FULL              (MD_CONTEXT_X86_CONTROL | \
-                                          MD_CONTEXT_X86_INTEGER | \
-                                          MD_CONTEXT_X86_SEGMENTS)
-     /* CONTEXT_FULL */
-
-#define MD_CONTEXT_X86_ALL               (MD_CONTEXT_X86_FULL | \
-                                          MD_CONTEXT_X86_FLOATING_POINT | \
-                                          MD_CONTEXT_X86_DEBUG_REGISTERS | \
-                                          MD_CONTEXT_X86_EXTENDED_REGISTERS)
-     /* CONTEXT_ALL */
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_X86_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_linux.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_linux.h
deleted file mode 100644
index 9e7e4f1e1..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_linux.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_exception_linux.h: A definition of exception codes for
- * Linux
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * Author: Mark Mentovai
- * Split into its own file: Neal Sidhwaney */
- 
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_LINUX_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_LINUX_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-
-/* For (MDException).exception_code.  These values come from bits/signum.h.
- */
-typedef enum {
-  MD_EXCEPTION_CODE_LIN_SIGHUP = 1,      /* Hangup (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGINT = 2,      /* Interrupt (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGQUIT = 3,     /* Quit (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGILL = 4,      /* Illegal instruction (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGTRAP = 5,     /* Trace trap (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGABRT = 6,     /* Abort (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGBUS = 7,      /* BUS error (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGFPE = 8,      /* Floating-point exception (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGKILL = 9,     /* Kill, unblockable (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGUSR1 = 10,    /* User-defined signal 1 (POSIX).  */
-  MD_EXCEPTION_CODE_LIN_SIGSEGV = 11,    /* Segmentation violation (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGUSR2 = 12,    /* User-defined signal 2 (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGPIPE = 13,    /* Broken pipe (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGALRM = 14,    /* Alarm clock (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGTERM = 15,    /* Termination (ANSI) */
-  MD_EXCEPTION_CODE_LIN_SIGSTKFLT = 16,  /* Stack faultd */
-  MD_EXCEPTION_CODE_LIN_SIGCHLD = 17,    /* Child status has changed (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGCONT = 18,    /* Continue (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGSTOP = 19,    /* Stop, unblockable (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGTSTP = 20,    /* Keyboard stop (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGTTIN = 21,    /* Background read from tty (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGTTOU = 22,    /* Background write to tty (POSIX) */
-  MD_EXCEPTION_CODE_LIN_SIGURG = 23,
-    /* Urgent condition on socket (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGXCPU = 24,    /* CPU limit exceeded (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGXFSZ = 25,
-    /* File size limit exceeded (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGVTALRM = 26,  /* Virtual alarm clock (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGPROF = 27,    /* Profiling alarm clock (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGWINCH = 28,   /* Window size change (4.3 BSD, Sun) */
-  MD_EXCEPTION_CODE_LIN_SIGIO = 29,      /* I/O now possible (4.2 BSD) */
-  MD_EXCEPTION_CODE_LIN_SIGPWR = 30,     /* Power failure restart (System V) */
-  MD_EXCEPTION_CODE_LIN_SIGSYS = 31,     /* Bad system call */
-  MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED = 0xFFFFFFFF /* No exception,
-                                                       dump requested. */
-} MDExceptionCodeLinux;
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_LINUX_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_mac.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_mac.h
deleted file mode 100644
index 91c1c0974..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_mac.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_exception_mac.h: A definition of exception codes for Mac
- * OS X
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * Author: Mark Mentovai
- * Split into its own file: Neal Sidhwaney */
- 
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_MAC_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_MAC_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-/* For (MDException).exception_code.  Breakpad minidump extension for Mac OS X
- * support.  Based on Darwin/Mac OS X' mach/exception_types.h.  This is
- * what Mac OS X calls an "exception", not a "code". */
-typedef enum {
-  /* Exception code.  The high 16 bits of exception_code contains one of
-   * these values. */
-  MD_EXCEPTION_MAC_BAD_ACCESS      = 1,  /* code can be a kern_return_t */
-      /* EXC_BAD_ACCESS */
-  MD_EXCEPTION_MAC_BAD_INSTRUCTION = 2,  /* code is CPU-specific */
-      /* EXC_BAD_INSTRUCTION */
-  MD_EXCEPTION_MAC_ARITHMETIC      = 3,  /* code is CPU-specific */
-      /* EXC_ARITHMETIC */
-  MD_EXCEPTION_MAC_EMULATION       = 4,  /* code is CPU-specific */
-      /* EXC_EMULATION */
-  MD_EXCEPTION_MAC_SOFTWARE        = 5,
-      /* EXC_SOFTWARE */
-  MD_EXCEPTION_MAC_BREAKPOINT      = 6,  /* code is CPU-specific */
-      /* EXC_BREAKPOINT */
-  MD_EXCEPTION_MAC_SYSCALL         = 7,
-      /* EXC_SYSCALL */
-  MD_EXCEPTION_MAC_MACH_SYSCALL    = 8,
-      /* EXC_MACH_SYSCALL */
-  MD_EXCEPTION_MAC_RPC_ALERT       = 9
-      /* EXC_RPC_ALERT */
-} MDExceptionMac;
-
-/* For (MDException).exception_flags.  Breakpad minidump extension for Mac OS X
- * support.  Based on Darwin/Mac OS X' mach/ppc/exception.h and
- * mach/i386/exception.h.  This is what Mac OS X calls a "code". */
-typedef enum {
-  /* With MD_EXCEPTION_BAD_ACCESS.  These are relevant kern_return_t values
-   * from mach/kern_return.h. */
-  MD_EXCEPTION_CODE_MAC_INVALID_ADDRESS    =  1,
-      /* KERN_INVALID_ADDRESS */
-  MD_EXCEPTION_CODE_MAC_PROTECTION_FAILURE =  2,
-      /* KERN_PROTECTION_FAILURE */
-  MD_EXCEPTION_CODE_MAC_NO_ACCESS          =  8,
-      /* KERN_NO_ACCESS */
-  MD_EXCEPTION_CODE_MAC_MEMORY_FAILURE     =  9,
-      /* KERN_MEMORY_FAILURE */
-  MD_EXCEPTION_CODE_MAC_MEMORY_ERROR       = 10,
-      /* KERN_MEMORY_ERROR */
-
-  /* With MD_EXCEPTION_SOFTWARE */
-  MD_EXCEPTION_CODE_MAC_BAD_SYSCALL  = 0x00010000,  /* Mach SIGSYS */
-  MD_EXCEPTION_CODE_MAC_BAD_PIPE     = 0x00010001,  /* Mach SIGPIPE */
-  MD_EXCEPTION_CODE_MAC_ABORT        = 0x00010002,  /* Mach SIGABRT */
-  /* Custom values */
-  MD_EXCEPTION_CODE_MAC_NS_EXCEPTION = 0xDEADC0DE,  /* uncaught NSException */
-
-  /* With MD_EXCEPTION_MAC_BAD_ACCESS on arm */
-  MD_EXCEPTION_CODE_MAC_ARM_DA_ALIGN = 0x0101,  /* EXC_ARM_DA_ALIGN */
-  MD_EXCEPTION_CODE_MAC_ARM_DA_DEBUG = 0x0102,  /* EXC_ARM_DA_DEBUG */
-
-  /* With MD_EXCEPTION_MAC_BAD_INSTRUCTION on arm */
-  MD_EXCEPTION_CODE_MAC_ARM_UNDEFINED = 1,  /* EXC_ARM_UNDEFINED */
-
-  /* With MD_EXCEPTION_MAC_BREAKPOINT on arm */
-  MD_EXCEPTION_CODE_MAC_ARM_BREAKPOINT = 1, /* EXC_ARM_BREAKPOINT */
-
-  /* With MD_EXCEPTION_MAC_BAD_ACCESS on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_VM_PROT_READ = 0x0101,
-      /* EXC_PPC_VM_PROT_READ */
-  MD_EXCEPTION_CODE_MAC_PPC_BADSPACE     = 0x0102,
-      /* EXC_PPC_BADSPACE */
-  MD_EXCEPTION_CODE_MAC_PPC_UNALIGNED    = 0x0103,
-      /* EXC_PPC_UNALIGNED */
-
-  /* With MD_EXCEPTION_MAC_BAD_INSTRUCTION on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_INVALID_SYSCALL           = 1,
-      /* EXC_PPC_INVALID_SYSCALL */
-  MD_EXCEPTION_CODE_MAC_PPC_UNIMPLEMENTED_INSTRUCTION = 2,
-      /* EXC_PPC_UNIPL_INST */
-  MD_EXCEPTION_CODE_MAC_PPC_PRIVILEGED_INSTRUCTION    = 3,
-      /* EXC_PPC_PRIVINST */
-  MD_EXCEPTION_CODE_MAC_PPC_PRIVILEGED_REGISTER       = 4,
-      /* EXC_PPC_PRIVREG */
-  MD_EXCEPTION_CODE_MAC_PPC_TRACE                     = 5,
-      /* EXC_PPC_TRACE */
-  MD_EXCEPTION_CODE_MAC_PPC_PERFORMANCE_MONITOR       = 6,
-      /* EXC_PPC_PERFMON */
-
-  /* With MD_EXCEPTION_MAC_ARITHMETIC on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_OVERFLOW           = 1,
-      /* EXC_PPC_OVERFLOW */
-  MD_EXCEPTION_CODE_MAC_PPC_ZERO_DIVIDE        = 2,
-      /* EXC_PPC_ZERO_DIVIDE */
-  MD_EXCEPTION_CODE_MAC_PPC_FLOAT_INEXACT      = 3,
-      /* EXC_FLT_INEXACT */
-  MD_EXCEPTION_CODE_MAC_PPC_FLOAT_ZERO_DIVIDE  = 4,
-      /* EXC_PPC_FLT_ZERO_DIVIDE */
-  MD_EXCEPTION_CODE_MAC_PPC_FLOAT_UNDERFLOW    = 5,
-      /* EXC_PPC_FLT_UNDERFLOW */
-  MD_EXCEPTION_CODE_MAC_PPC_FLOAT_OVERFLOW     = 6,
-      /* EXC_PPC_FLT_OVERFLOW */
-  MD_EXCEPTION_CODE_MAC_PPC_FLOAT_NOT_A_NUMBER = 7,
-      /* EXC_PPC_FLT_NOT_A_NUMBER */
-
-  /* With MD_EXCEPTION_MAC_EMULATION on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_NO_EMULATION   = 8,
-      /* EXC_PPC_NOEMULATION */
-  MD_EXCEPTION_CODE_MAC_PPC_ALTIVEC_ASSIST = 9,
-      /* EXC_PPC_ALTIVECASSIST */
-
-  /* With MD_EXCEPTION_MAC_SOFTWARE on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_TRAP    = 0x00000001,  /* EXC_PPC_TRAP */
-  MD_EXCEPTION_CODE_MAC_PPC_MIGRATE = 0x00010100,  /* EXC_PPC_MIGRATE */
-
-  /* With MD_EXCEPTION_MAC_BREAKPOINT on ppc */
-  MD_EXCEPTION_CODE_MAC_PPC_BREAKPOINT = 1,  /* EXC_PPC_BREAKPOINT */
-
-  /* With MD_EXCEPTION_MAC_BAD_INSTRUCTION on x86, see also x86 interrupt
-   * values below. */
-  MD_EXCEPTION_CODE_MAC_X86_INVALID_OPERATION = 1,  /* EXC_I386_INVOP */
-
-  /* With MD_EXCEPTION_MAC_ARITHMETIC on x86 */
-  MD_EXCEPTION_CODE_MAC_X86_DIV       = 1,  /* EXC_I386_DIV */
-  MD_EXCEPTION_CODE_MAC_X86_INTO      = 2,  /* EXC_I386_INTO */
-  MD_EXCEPTION_CODE_MAC_X86_NOEXT     = 3,  /* EXC_I386_NOEXT */
-  MD_EXCEPTION_CODE_MAC_X86_EXTOVR    = 4,  /* EXC_I386_EXTOVR */
-  MD_EXCEPTION_CODE_MAC_X86_EXTERR    = 5,  /* EXC_I386_EXTERR */
-  MD_EXCEPTION_CODE_MAC_X86_EMERR     = 6,  /* EXC_I386_EMERR */
-  MD_EXCEPTION_CODE_MAC_X86_BOUND     = 7,  /* EXC_I386_BOUND */
-  MD_EXCEPTION_CODE_MAC_X86_SSEEXTERR = 8,  /* EXC_I386_SSEEXTERR */
-
-  /* With MD_EXCEPTION_MAC_BREAKPOINT on x86 */
-  MD_EXCEPTION_CODE_MAC_X86_SGL = 1,  /* EXC_I386_SGL */
-  MD_EXCEPTION_CODE_MAC_X86_BPT = 2,  /* EXC_I386_BPT */
-
-  /* With MD_EXCEPTION_MAC_BAD_INSTRUCTION on x86.  These are the raw
-   * x86 interrupt codes.  Most of these are mapped to other Mach
-   * exceptions and codes, are handled, or should not occur in user space.
-   * A few of these will do occur with MD_EXCEPTION_MAC_BAD_INSTRUCTION. */
-  /* EXC_I386_DIVERR    =  0: mapped to EXC_ARITHMETIC/EXC_I386_DIV */
-  /* EXC_I386_SGLSTP    =  1: mapped to EXC_BREAKPOINT/EXC_I386_SGL */
-  /* EXC_I386_NMIFLT    =  2: should not occur in user space */
-  /* EXC_I386_BPTFLT    =  3: mapped to EXC_BREAKPOINT/EXC_I386_BPT */
-  /* EXC_I386_INTOFLT   =  4: mapped to EXC_ARITHMETIC/EXC_I386_INTO */
-  /* EXC_I386_BOUNDFLT  =  5: mapped to EXC_ARITHMETIC/EXC_I386_BOUND */
-  /* EXC_I386_INVOPFLT  =  6: mapped to EXC_BAD_INSTRUCTION/EXC_I386_INVOP */
-  /* EXC_I386_NOEXTFLT  =  7: should be handled by the kernel */
-  /* EXC_I386_DBLFLT    =  8: should be handled (if possible) by the kernel */
-  /* EXC_I386_EXTOVRFLT =  9: mapped to EXC_BAD_ACCESS/(PROT_READ|PROT_EXEC) */
-  MD_EXCEPTION_CODE_MAC_X86_INVALID_TASK_STATE_SEGMENT = 10,
-      /* EXC_INVTSSFLT */
-  MD_EXCEPTION_CODE_MAC_X86_SEGMENT_NOT_PRESENT        = 11,
-      /* EXC_SEGNPFLT */
-  MD_EXCEPTION_CODE_MAC_X86_STACK_FAULT                = 12,
-      /* EXC_STKFLT */
-  MD_EXCEPTION_CODE_MAC_X86_GENERAL_PROTECTION_FAULT   = 13,
-      /* EXC_GPFLT */
-  /* EXC_I386_PGFLT     = 14: should not occur in user space */
-  /* EXC_I386_EXTERRFLT = 16: mapped to EXC_ARITHMETIC/EXC_I386_EXTERR */
-  MD_EXCEPTION_CODE_MAC_X86_ALIGNMENT_FAULT            = 17
-      /* EXC_ALIGNFLT (for vector operations) */
-  /* EXC_I386_ENOEXTFLT = 32: should be handled by the kernel */
-  /* EXC_I386_ENDPERR   = 33: should not occur */
-} MDExceptionCodeMac;
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_MAC_OSX_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_ps3.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_ps3.h
deleted file mode 100644
index adff5a6bb..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_ps3.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* Copyright (c) 2013, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_exception_ps3.h: A definition of exception codes for
- * PS3 */
-
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_PS3_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_PS3_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-typedef enum {
-  MD_EXCEPTION_CODE_PS3_UNKNOWN = 0,
-  MD_EXCEPTION_CODE_PS3_TRAP_EXCEP = 1,
-  MD_EXCEPTION_CODE_PS3_PRIV_INSTR = 2,
-  MD_EXCEPTION_CODE_PS3_ILLEGAL_INSTR = 3,
-  MD_EXCEPTION_CODE_PS3_INSTR_STORAGE = 4,
-  MD_EXCEPTION_CODE_PS3_INSTR_SEGMENT = 5,
-  MD_EXCEPTION_CODE_PS3_DATA_STORAGE = 6,
-  MD_EXCEPTION_CODE_PS3_DATA_SEGMENT = 7,
-  MD_EXCEPTION_CODE_PS3_FLOAT_POINT = 8,
-  MD_EXCEPTION_CODE_PS3_DABR_MATCH = 9,
-  MD_EXCEPTION_CODE_PS3_ALIGN_EXCEP = 10,
-  MD_EXCEPTION_CODE_PS3_MEMORY_ACCESS = 11,
-  MD_EXCEPTION_CODE_PS3_COPRO_ALIGN = 12,
-  MD_EXCEPTION_CODE_PS3_COPRO_INVALID_COM = 13,
-  MD_EXCEPTION_CODE_PS3_COPRO_ERR = 14,
-  MD_EXCEPTION_CODE_PS3_COPRO_FIR = 15,
-  MD_EXCEPTION_CODE_PS3_COPRO_DATA_SEGMENT = 16,
-  MD_EXCEPTION_CODE_PS3_COPRO_DATA_STORAGE = 17,
-  MD_EXCEPTION_CODE_PS3_COPRO_STOP_INSTR = 18,
-  MD_EXCEPTION_CODE_PS3_COPRO_HALT_INSTR = 19,
-  MD_EXCEPTION_CODE_PS3_COPRO_HALTINST_UNKNOWN = 20,
-  MD_EXCEPTION_CODE_PS3_COPRO_MEMORY_ACCESS = 21,
-  MD_EXCEPTION_CODE_PS3_GRAPHIC = 22
-} MDExceptionCodePS3;
-
-#endif /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_PS3_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_solaris.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_solaris.h
deleted file mode 100644
index f18ddf424..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_solaris.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_exception_solaris.h: A definition of exception codes for
- * Solaris
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * Author: Mark Mentovai
- * Split into its own file: Neal Sidhwaney */
-
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_SOLARIS_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_SOLARIS_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-/* For (MDException).exception_code.  These values come from sys/iso/signal_iso.h
- */
-typedef enum {
-  MD_EXCEPTION_CODE_SOL_SIGHUP = 1,      /* Hangup */
-  MD_EXCEPTION_CODE_SOL_SIGINT = 2,      /* interrupt (rubout) */
-  MD_EXCEPTION_CODE_SOL_SIGQUIT = 3,     /* quit (ASCII FS) */
-  MD_EXCEPTION_CODE_SOL_SIGILL = 4,      /* illegal instruction (not reset when caught) */
-  MD_EXCEPTION_CODE_SOL_SIGTRAP = 5,     /* trace trap (not reset when caught) */
-  MD_EXCEPTION_CODE_SOL_SIGIOT = 6,      /* IOT instruction */
-  MD_EXCEPTION_CODE_SOL_SIGABRT = 6,     /* used by abort, replace SIGIOT in the future */
-  MD_EXCEPTION_CODE_SOL_SIGEMT = 7,      /* EMT instruction */
-  MD_EXCEPTION_CODE_SOL_SIGFPE = 8,      /* floating point exception */
-  MD_EXCEPTION_CODE_SOL_SIGKILL = 9,     /* kill (cannot be caught or ignored) */
-  MD_EXCEPTION_CODE_SOL_SIGBUS = 10,     /* bus error */
-  MD_EXCEPTION_CODE_SOL_SIGSEGV = 11,    /* segmentation violation */
-  MD_EXCEPTION_CODE_SOL_SIGSYS = 12,     /* bad argument to system call */
-  MD_EXCEPTION_CODE_SOL_SIGPIPE = 13,    /* write on a pipe with no one to read it */
-  MD_EXCEPTION_CODE_SOL_SIGALRM = 14,    /* alarm clock */
-  MD_EXCEPTION_CODE_SOL_SIGTERM = 15,    /* software termination signal from kill */
-  MD_EXCEPTION_CODE_SOL_SIGUSR1 = 16,    /* user defined signal 1 */
-  MD_EXCEPTION_CODE_SOL_SIGUSR2 = 17,    /* user defined signal 2 */
-  MD_EXCEPTION_CODE_SOL_SIGCLD = 18,     /* child status change */
-  MD_EXCEPTION_CODE_SOL_SIGCHLD = 18,    /* child status change alias (POSIX) */
-  MD_EXCEPTION_CODE_SOL_SIGPWR = 19,     /* power-fail restart */
-  MD_EXCEPTION_CODE_SOL_SIGWINCH = 20,   /* window size change */
-  MD_EXCEPTION_CODE_SOL_SIGURG = 21,     /* urgent socket condition */
-  MD_EXCEPTION_CODE_SOL_SIGPOLL = 22,    /* pollable event occurred */
-  MD_EXCEPTION_CODE_SOL_SIGIO = 22,      /* socket I/O possible (SIGPOLL alias) */
-  MD_EXCEPTION_CODE_SOL_SIGSTOP = 23,    /* stop (cannot be caught or ignored) */
-  MD_EXCEPTION_CODE_SOL_SIGTSTP = 24,    /* user stop requested from tty */
-  MD_EXCEPTION_CODE_SOL_SIGCONT = 25,    /* stopped process has been continued */
-  MD_EXCEPTION_CODE_SOL_SIGTTIN = 26,    /* background tty read attempted */
-  MD_EXCEPTION_CODE_SOL_SIGTTOU = 27,    /* background tty write attempted */
-  MD_EXCEPTION_CODE_SOL_SIGVTALRM = 28,  /* virtual timer expired */
-  MD_EXCEPTION_CODE_SOL_SIGPROF = 29,    /* profiling timer expired */
-  MD_EXCEPTION_CODE_SOL_SIGXCPU = 30,    /* exceeded cpu limit */
-  MD_EXCEPTION_CODE_SOL_SIGXFSZ = 31,    /* exceeded file size limit */
-  MD_EXCEPTION_CODE_SOL_SIGWAITING = 32, /* reserved signal no longer used by threading code */
-  MD_EXCEPTION_CODE_SOL_SIGLWP = 33,     /* reserved signal no longer used by threading code */
-  MD_EXCEPTION_CODE_SOL_SIGFREEZE = 34,  /* special signal used by CPR */
-  MD_EXCEPTION_CODE_SOL_SIGTHAW = 35,    /* special signal used by CPR */
-  MD_EXCEPTION_CODE_SOL_SIGCANCEL = 36,  /* reserved signal for thread cancellation */
-  MD_EXCEPTION_CODE_SOL_SIGLOST = 37,    /* resource lost (eg, record-lock lost) */
-  MD_EXCEPTION_CODE_SOL_SIGXRES = 38,    /* resource control exceeded */
-  MD_EXCEPTION_CODE_SOL_SIGJVM1 = 39,    /* reserved signal for Java Virtual Machine */
-  MD_EXCEPTION_CODE_SOL_SIGJVM2 = 40     /* reserved signal for Java Virtual Machine */
-} MDExceptionCodeSolaris;
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_SOLARIS_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_win32.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_win32.h
deleted file mode 100644
index e4cd59edd..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_exception_win32.h
+++ /dev/null
@@ -1,2261 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_exception_win32.h: Definitions of exception codes for
- * Win32 platform
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * Author: Mark Mentovai
- * Split into its own file: Neal Sidhwaney */
-
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_WIN32_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_WIN32_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-
-/* For (MDException).exception_code.  These values come from WinBase.h
- * and WinNT.h (names beginning with EXCEPTION_ are in WinBase.h,
- * they are STATUS_ in WinNT.h). */
-typedef enum {
-  MD_EXCEPTION_CODE_WIN_CONTROL_C                = 0x40010005,
-      /* DBG_CONTROL_C */
-  MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION     = 0x80000001,
-      /* EXCEPTION_GUARD_PAGE */
-  MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT    = 0x80000002,
-      /* EXCEPTION_DATATYPE_MISALIGNMENT */
-  MD_EXCEPTION_CODE_WIN_BREAKPOINT               = 0x80000003,
-      /* EXCEPTION_BREAKPOINT */
-  MD_EXCEPTION_CODE_WIN_SINGLE_STEP              = 0x80000004,
-      /* EXCEPTION_SINGLE_STEP */
-  MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION         = 0xc0000005,
-      /* EXCEPTION_ACCESS_VIOLATION */
-  MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR            = 0xc0000006,
-      /* EXCEPTION_IN_PAGE_ERROR */
-  MD_EXCEPTION_CODE_WIN_INVALID_HANDLE           = 0xc0000008,
-      /* EXCEPTION_INVALID_HANDLE */
-  MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION      = 0xc000001d,
-      /* EXCEPTION_ILLEGAL_INSTRUCTION */
-  MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION = 0xc0000025,
-      /* EXCEPTION_NONCONTINUABLE_EXCEPTION */
-  MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION      = 0xc0000026,
-      /* EXCEPTION_INVALID_DISPOSITION */
-  MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED    = 0xc000008c,
-      /* EXCEPTION_BOUNDS_EXCEEDED */
-  MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND   = 0xc000008d,
-      /* EXCEPTION_FLT_DENORMAL_OPERAND */
-  MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO     = 0xc000008e,
-      /* EXCEPTION_FLT_DIVIDE_BY_ZERO */
-  MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT     = 0xc000008f,
-      /* EXCEPTION_FLT_INEXACT_RESULT */
-  MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION  = 0xc0000090,
-      /* EXCEPTION_FLT_INVALID_OPERATION */
-  MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW           = 0xc0000091,
-      /* EXCEPTION_FLT_OVERFLOW */
-  MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK        = 0xc0000092,
-      /* EXCEPTION_FLT_STACK_CHECK */
-  MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW          = 0xc0000093,
-      /* EXCEPTION_FLT_UNDERFLOW */
-  MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO   = 0xc0000094,
-      /* EXCEPTION_INT_DIVIDE_BY_ZERO */
-  MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW         = 0xc0000095,
-      /* EXCEPTION_INT_OVERFLOW */
-  MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION   = 0xc0000096,
-      /* EXCEPTION_PRIV_INSTRUCTION */
-  MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW           = 0xc00000fd,
-      /* EXCEPTION_STACK_OVERFLOW */
-  MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK        = 0xc0000194,
-      /* EXCEPTION_POSSIBLE_DEADLOCK */
-  MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN     = 0xc0000409,
-      /* STATUS_STACK_BUFFER_OVERRUN */
-  MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION          = 0xc0000374,
-      /* STATUS_HEAP_CORRUPTION */
-  MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION  = 0xe06d7363
-      /* Per http://support.microsoft.com/kb/185294,
-         generated by Visual C++ compiler */
-} MDExceptionCodeWin;
-
-
-/* For (MDException).exception_information[2], when (MDException).exception_code
- * is MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR. This describes the underlying reason
- * for the error. These values come from ntstatus.h.
- *
- * The content of this enum was created from ntstatus.h in the 8.1 SDK with
- *
- * egrep '#define [A-Z_0-9]+\s+\(\(NTSTATUS\)0xC[0-9A-F]+L\)' ntstatus.h
- * | tr -d '\r'
- * | sed -r 's@#define ([A-Z_0-9]+)\s+\(\(NTSTATUS\)(0xC[0-9A-F]+)L\).*@\2 \1@'
- * | sort
- * | sed -r 's@(0xC[0-9A-F]+) ([A-Z_0-9]+)@  MD_NTSTATUS_WIN_\2 = \1,@'
- *
- * With easy copy to clipboard with
- * | xclip -selection c  # on linux
- * | clip  # on windows
- * | pbcopy  # on mac
- *
- * and then the last comma manually removed. */
-typedef enum {
-  MD_NTSTATUS_WIN_STATUS_UNSUCCESSFUL = 0xC0000001,
-  MD_NTSTATUS_WIN_STATUS_NOT_IMPLEMENTED = 0xC0000002,
-  MD_NTSTATUS_WIN_STATUS_INVALID_INFO_CLASS = 0xC0000003,
-  MD_NTSTATUS_WIN_STATUS_INFO_LENGTH_MISMATCH = 0xC0000004,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_VIOLATION = 0xC0000005,
-  MD_NTSTATUS_WIN_STATUS_IN_PAGE_ERROR = 0xC0000006,
-  MD_NTSTATUS_WIN_STATUS_PAGEFILE_QUOTA = 0xC0000007,
-  MD_NTSTATUS_WIN_STATUS_INVALID_HANDLE = 0xC0000008,
-  MD_NTSTATUS_WIN_STATUS_BAD_INITIAL_STACK = 0xC0000009,
-  MD_NTSTATUS_WIN_STATUS_BAD_INITIAL_PC = 0xC000000A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_CID = 0xC000000B,
-  MD_NTSTATUS_WIN_STATUS_TIMER_NOT_CANCELED = 0xC000000C,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER = 0xC000000D,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_DEVICE = 0xC000000E,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_FILE = 0xC000000F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_REQUEST = 0xC0000010,
-  MD_NTSTATUS_WIN_STATUS_END_OF_FILE = 0xC0000011,
-  MD_NTSTATUS_WIN_STATUS_WRONG_VOLUME = 0xC0000012,
-  MD_NTSTATUS_WIN_STATUS_NO_MEDIA_IN_DEVICE = 0xC0000013,
-  MD_NTSTATUS_WIN_STATUS_UNRECOGNIZED_MEDIA = 0xC0000014,
-  MD_NTSTATUS_WIN_STATUS_NONEXISTENT_SECTOR = 0xC0000015,
-  MD_NTSTATUS_WIN_STATUS_MORE_PROCESSING_REQUIRED = 0xC0000016,
-  MD_NTSTATUS_WIN_STATUS_NO_MEMORY = 0xC0000017,
-  MD_NTSTATUS_WIN_STATUS_CONFLICTING_ADDRESSES = 0xC0000018,
-  MD_NTSTATUS_WIN_STATUS_NOT_MAPPED_VIEW = 0xC0000019,
-  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_FREE_VM = 0xC000001A,
-  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_DELETE_SECTION = 0xC000001B,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SYSTEM_SERVICE = 0xC000001C,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_INSTRUCTION = 0xC000001D,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LOCK_SEQUENCE = 0xC000001E,
-  MD_NTSTATUS_WIN_STATUS_INVALID_VIEW_SIZE = 0xC000001F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_FILE_FOR_SECTION = 0xC0000020,
-  MD_NTSTATUS_WIN_STATUS_ALREADY_COMMITTED = 0xC0000021,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DENIED = 0xC0000022,
-  MD_NTSTATUS_WIN_STATUS_BUFFER_TOO_SMALL = 0xC0000023,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_TYPE_MISMATCH = 0xC0000024,
-  MD_NTSTATUS_WIN_STATUS_NONCONTINUABLE_EXCEPTION = 0xC0000025,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DISPOSITION = 0xC0000026,
-  MD_NTSTATUS_WIN_STATUS_UNWIND = 0xC0000027,
-  MD_NTSTATUS_WIN_STATUS_BAD_STACK = 0xC0000028,
-  MD_NTSTATUS_WIN_STATUS_INVALID_UNWIND_TARGET = 0xC0000029,
-  MD_NTSTATUS_WIN_STATUS_NOT_LOCKED = 0xC000002A,
-  MD_NTSTATUS_WIN_STATUS_PARITY_ERROR = 0xC000002B,
-  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_DECOMMIT_VM = 0xC000002C,
-  MD_NTSTATUS_WIN_STATUS_NOT_COMMITTED = 0xC000002D,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PORT_ATTRIBUTES = 0xC000002E,
-  MD_NTSTATUS_WIN_STATUS_PORT_MESSAGE_TOO_LONG = 0xC000002F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_MIX = 0xC0000030,
-  MD_NTSTATUS_WIN_STATUS_INVALID_QUOTA_LOWER = 0xC0000031,
-  MD_NTSTATUS_WIN_STATUS_DISK_CORRUPT_ERROR = 0xC0000032,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_INVALID = 0xC0000033,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_COLLISION = 0xC0000035,
-  MD_NTSTATUS_WIN_STATUS_PORT_DISCONNECTED = 0xC0000037,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_ALREADY_ATTACHED = 0xC0000038,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_INVALID = 0xC0000039,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_SYNTAX_BAD = 0xC000003B,
-  MD_NTSTATUS_WIN_STATUS_DATA_OVERRUN = 0xC000003C,
-  MD_NTSTATUS_WIN_STATUS_DATA_LATE_ERROR = 0xC000003D,
-  MD_NTSTATUS_WIN_STATUS_DATA_ERROR = 0xC000003E,
-  MD_NTSTATUS_WIN_STATUS_CRC_ERROR = 0xC000003F,
-  MD_NTSTATUS_WIN_STATUS_SECTION_TOO_BIG = 0xC0000040,
-  MD_NTSTATUS_WIN_STATUS_PORT_CONNECTION_REFUSED = 0xC0000041,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PORT_HANDLE = 0xC0000042,
-  MD_NTSTATUS_WIN_STATUS_SHARING_VIOLATION = 0xC0000043,
-  MD_NTSTATUS_WIN_STATUS_QUOTA_EXCEEDED = 0xC0000044,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PAGE_PROTECTION = 0xC0000045,
-  MD_NTSTATUS_WIN_STATUS_MUTANT_NOT_OWNED = 0xC0000046,
-  MD_NTSTATUS_WIN_STATUS_SEMAPHORE_LIMIT_EXCEEDED = 0xC0000047,
-  MD_NTSTATUS_WIN_STATUS_PORT_ALREADY_SET = 0xC0000048,
-  MD_NTSTATUS_WIN_STATUS_SECTION_NOT_IMAGE = 0xC0000049,
-  MD_NTSTATUS_WIN_STATUS_SUSPEND_COUNT_EXCEEDED = 0xC000004A,
-  MD_NTSTATUS_WIN_STATUS_THREAD_IS_TERMINATING = 0xC000004B,
-  MD_NTSTATUS_WIN_STATUS_BAD_WORKING_SET_LIMIT = 0xC000004C,
-  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_FILE_MAP = 0xC000004D,
-  MD_NTSTATUS_WIN_STATUS_SECTION_PROTECTION = 0xC000004E,
-  MD_NTSTATUS_WIN_STATUS_EAS_NOT_SUPPORTED = 0xC000004F,
-  MD_NTSTATUS_WIN_STATUS_EA_TOO_LARGE = 0xC0000050,
-  MD_NTSTATUS_WIN_STATUS_NONEXISTENT_EA_ENTRY = 0xC0000051,
-  MD_NTSTATUS_WIN_STATUS_NO_EAS_ON_FILE = 0xC0000052,
-  MD_NTSTATUS_WIN_STATUS_EA_CORRUPT_ERROR = 0xC0000053,
-  MD_NTSTATUS_WIN_STATUS_FILE_LOCK_CONFLICT = 0xC0000054,
-  MD_NTSTATUS_WIN_STATUS_LOCK_NOT_GRANTED = 0xC0000055,
-  MD_NTSTATUS_WIN_STATUS_DELETE_PENDING = 0xC0000056,
-  MD_NTSTATUS_WIN_STATUS_CTL_FILE_NOT_SUPPORTED = 0xC0000057,
-  MD_NTSTATUS_WIN_STATUS_UNKNOWN_REVISION = 0xC0000058,
-  MD_NTSTATUS_WIN_STATUS_REVISION_MISMATCH = 0xC0000059,
-  MD_NTSTATUS_WIN_STATUS_INVALID_OWNER = 0xC000005A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PRIMARY_GROUP = 0xC000005B,
-  MD_NTSTATUS_WIN_STATUS_NO_IMPERSONATION_TOKEN = 0xC000005C,
-  MD_NTSTATUS_WIN_STATUS_CANT_DISABLE_MANDATORY = 0xC000005D,
-  MD_NTSTATUS_WIN_STATUS_NO_LOGON_SERVERS = 0xC000005E,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_LOGON_SESSION = 0xC000005F,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_PRIVILEGE = 0xC0000060,
-  MD_NTSTATUS_WIN_STATUS_PRIVILEGE_NOT_HELD = 0xC0000061,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ACCOUNT_NAME = 0xC0000062,
-  MD_NTSTATUS_WIN_STATUS_USER_EXISTS = 0xC0000063,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_USER = 0xC0000064,
-  MD_NTSTATUS_WIN_STATUS_GROUP_EXISTS = 0xC0000065,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_GROUP = 0xC0000066,
-  MD_NTSTATUS_WIN_STATUS_MEMBER_IN_GROUP = 0xC0000067,
-  MD_NTSTATUS_WIN_STATUS_MEMBER_NOT_IN_GROUP = 0xC0000068,
-  MD_NTSTATUS_WIN_STATUS_LAST_ADMIN = 0xC0000069,
-  MD_NTSTATUS_WIN_STATUS_WRONG_PASSWORD = 0xC000006A,
-  MD_NTSTATUS_WIN_STATUS_ILL_FORMED_PASSWORD = 0xC000006B,
-  MD_NTSTATUS_WIN_STATUS_PASSWORD_RESTRICTION = 0xC000006C,
-  MD_NTSTATUS_WIN_STATUS_LOGON_FAILURE = 0xC000006D,
-  MD_NTSTATUS_WIN_STATUS_ACCOUNT_RESTRICTION = 0xC000006E,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LOGON_HOURS = 0xC000006F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_WORKSTATION = 0xC0000070,
-  MD_NTSTATUS_WIN_STATUS_PASSWORD_EXPIRED = 0xC0000071,
-  MD_NTSTATUS_WIN_STATUS_ACCOUNT_DISABLED = 0xC0000072,
-  MD_NTSTATUS_WIN_STATUS_NONE_MAPPED = 0xC0000073,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_LUIDS_REQUESTED = 0xC0000074,
-  MD_NTSTATUS_WIN_STATUS_LUIDS_EXHAUSTED = 0xC0000075,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SUB_AUTHORITY = 0xC0000076,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ACL = 0xC0000077,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SID = 0xC0000078,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SECURITY_DESCR = 0xC0000079,
-  MD_NTSTATUS_WIN_STATUS_PROCEDURE_NOT_FOUND = 0xC000007A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_FORMAT = 0xC000007B,
-  MD_NTSTATUS_WIN_STATUS_NO_TOKEN = 0xC000007C,
-  MD_NTSTATUS_WIN_STATUS_BAD_INHERITANCE_ACL = 0xC000007D,
-  MD_NTSTATUS_WIN_STATUS_RANGE_NOT_LOCKED = 0xC000007E,
-  MD_NTSTATUS_WIN_STATUS_DISK_FULL = 0xC000007F,
-  MD_NTSTATUS_WIN_STATUS_SERVER_DISABLED = 0xC0000080,
-  MD_NTSTATUS_WIN_STATUS_SERVER_NOT_DISABLED = 0xC0000081,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_GUIDS_REQUESTED = 0xC0000082,
-  MD_NTSTATUS_WIN_STATUS_GUIDS_EXHAUSTED = 0xC0000083,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ID_AUTHORITY = 0xC0000084,
-  MD_NTSTATUS_WIN_STATUS_AGENTS_EXHAUSTED = 0xC0000085,
-  MD_NTSTATUS_WIN_STATUS_INVALID_VOLUME_LABEL = 0xC0000086,
-  MD_NTSTATUS_WIN_STATUS_SECTION_NOT_EXTENDED = 0xC0000087,
-  MD_NTSTATUS_WIN_STATUS_NOT_MAPPED_DATA = 0xC0000088,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_DATA_NOT_FOUND = 0xC0000089,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_TYPE_NOT_FOUND = 0xC000008A,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_NAME_NOT_FOUND = 0xC000008B,
-  MD_NTSTATUS_WIN_STATUS_ARRAY_BOUNDS_EXCEEDED = 0xC000008C,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_DENORMAL_OPERAND = 0xC000008D,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_DIVIDE_BY_ZERO = 0xC000008E,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_INEXACT_RESULT = 0xC000008F,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_INVALID_OPERATION = 0xC0000090,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_OVERFLOW = 0xC0000091,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_STACK_CHECK = 0xC0000092,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_UNDERFLOW = 0xC0000093,
-  MD_NTSTATUS_WIN_STATUS_INTEGER_DIVIDE_BY_ZERO = 0xC0000094,
-  MD_NTSTATUS_WIN_STATUS_INTEGER_OVERFLOW = 0xC0000095,
-  MD_NTSTATUS_WIN_STATUS_PRIVILEGED_INSTRUCTION = 0xC0000096,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_PAGING_FILES = 0xC0000097,
-  MD_NTSTATUS_WIN_STATUS_FILE_INVALID = 0xC0000098,
-  MD_NTSTATUS_WIN_STATUS_ALLOTTED_SPACE_EXCEEDED = 0xC0000099,
-  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_RESOURCES = 0xC000009A,
-  MD_NTSTATUS_WIN_STATUS_DFS_EXIT_PATH_FOUND = 0xC000009B,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_DATA_ERROR = 0xC000009C,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_CONNECTED = 0xC000009D,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_POWER_FAILURE = 0xC000009E,
-  MD_NTSTATUS_WIN_STATUS_FREE_VM_NOT_AT_BASE = 0xC000009F,
-  MD_NTSTATUS_WIN_STATUS_MEMORY_NOT_ALLOCATED = 0xC00000A0,
-  MD_NTSTATUS_WIN_STATUS_WORKING_SET_QUOTA = 0xC00000A1,
-  MD_NTSTATUS_WIN_STATUS_MEDIA_WRITE_PROTECTED = 0xC00000A2,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_READY = 0xC00000A3,
-  MD_NTSTATUS_WIN_STATUS_INVALID_GROUP_ATTRIBUTES = 0xC00000A4,
-  MD_NTSTATUS_WIN_STATUS_BAD_IMPERSONATION_LEVEL = 0xC00000A5,
-  MD_NTSTATUS_WIN_STATUS_CANT_OPEN_ANONYMOUS = 0xC00000A6,
-  MD_NTSTATUS_WIN_STATUS_BAD_VALIDATION_CLASS = 0xC00000A7,
-  MD_NTSTATUS_WIN_STATUS_BAD_TOKEN_TYPE = 0xC00000A8,
-  MD_NTSTATUS_WIN_STATUS_BAD_MASTER_BOOT_RECORD = 0xC00000A9,
-  MD_NTSTATUS_WIN_STATUS_INSTRUCTION_MISALIGNMENT = 0xC00000AA,
-  MD_NTSTATUS_WIN_STATUS_INSTANCE_NOT_AVAILABLE = 0xC00000AB,
-  MD_NTSTATUS_WIN_STATUS_PIPE_NOT_AVAILABLE = 0xC00000AC,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PIPE_STATE = 0xC00000AD,
-  MD_NTSTATUS_WIN_STATUS_PIPE_BUSY = 0xC00000AE,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_FUNCTION = 0xC00000AF,
-  MD_NTSTATUS_WIN_STATUS_PIPE_DISCONNECTED = 0xC00000B0,
-  MD_NTSTATUS_WIN_STATUS_PIPE_CLOSING = 0xC00000B1,
-  MD_NTSTATUS_WIN_STATUS_PIPE_CONNECTED = 0xC00000B2,
-  MD_NTSTATUS_WIN_STATUS_PIPE_LISTENING = 0xC00000B3,
-  MD_NTSTATUS_WIN_STATUS_INVALID_READ_MODE = 0xC00000B4,
-  MD_NTSTATUS_WIN_STATUS_IO_TIMEOUT = 0xC00000B5,
-  MD_NTSTATUS_WIN_STATUS_FILE_FORCED_CLOSED = 0xC00000B6,
-  MD_NTSTATUS_WIN_STATUS_PROFILING_NOT_STARTED = 0xC00000B7,
-  MD_NTSTATUS_WIN_STATUS_PROFILING_NOT_STOPPED = 0xC00000B8,
-  MD_NTSTATUS_WIN_STATUS_COULD_NOT_INTERPRET = 0xC00000B9,
-  MD_NTSTATUS_WIN_STATUS_FILE_IS_A_DIRECTORY = 0xC00000BA,
-  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED = 0xC00000BB,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_NOT_LISTENING = 0xC00000BC,
-  MD_NTSTATUS_WIN_STATUS_DUPLICATE_NAME = 0xC00000BD,
-  MD_NTSTATUS_WIN_STATUS_BAD_NETWORK_PATH = 0xC00000BE,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_BUSY = 0xC00000BF,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_DOES_NOT_EXIST = 0xC00000C0,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_COMMANDS = 0xC00000C1,
-  MD_NTSTATUS_WIN_STATUS_ADAPTER_HARDWARE_ERROR = 0xC00000C2,
-  MD_NTSTATUS_WIN_STATUS_INVALID_NETWORK_RESPONSE = 0xC00000C3,
-  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_NETWORK_ERROR = 0xC00000C4,
-  MD_NTSTATUS_WIN_STATUS_BAD_REMOTE_ADAPTER = 0xC00000C5,
-  MD_NTSTATUS_WIN_STATUS_PRINT_QUEUE_FULL = 0xC00000C6,
-  MD_NTSTATUS_WIN_STATUS_NO_SPOOL_SPACE = 0xC00000C7,
-  MD_NTSTATUS_WIN_STATUS_PRINT_CANCELLED = 0xC00000C8,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_NAME_DELETED = 0xC00000C9,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_ACCESS_DENIED = 0xC00000CA,
-  MD_NTSTATUS_WIN_STATUS_BAD_DEVICE_TYPE = 0xC00000CB,
-  MD_NTSTATUS_WIN_STATUS_BAD_NETWORK_NAME = 0xC00000CC,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_NAMES = 0xC00000CD,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SESSIONS = 0xC00000CE,
-  MD_NTSTATUS_WIN_STATUS_SHARING_PAUSED = 0xC00000CF,
-  MD_NTSTATUS_WIN_STATUS_REQUEST_NOT_ACCEPTED = 0xC00000D0,
-  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_PAUSED = 0xC00000D1,
-  MD_NTSTATUS_WIN_STATUS_NET_WRITE_FAULT = 0xC00000D2,
-  MD_NTSTATUS_WIN_STATUS_PROFILING_AT_LIMIT = 0xC00000D3,
-  MD_NTSTATUS_WIN_STATUS_NOT_SAME_DEVICE = 0xC00000D4,
-  MD_NTSTATUS_WIN_STATUS_FILE_RENAMED = 0xC00000D5,
-  MD_NTSTATUS_WIN_STATUS_VIRTUAL_CIRCUIT_CLOSED = 0xC00000D6,
-  MD_NTSTATUS_WIN_STATUS_NO_SECURITY_ON_OBJECT = 0xC00000D7,
-  MD_NTSTATUS_WIN_STATUS_CANT_WAIT = 0xC00000D8,
-  MD_NTSTATUS_WIN_STATUS_PIPE_EMPTY = 0xC00000D9,
-  MD_NTSTATUS_WIN_STATUS_CANT_ACCESS_DOMAIN_INFO = 0xC00000DA,
-  MD_NTSTATUS_WIN_STATUS_CANT_TERMINATE_SELF = 0xC00000DB,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SERVER_STATE = 0xC00000DC,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DOMAIN_STATE = 0xC00000DD,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DOMAIN_ROLE = 0xC00000DE,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_DOMAIN = 0xC00000DF,
-  MD_NTSTATUS_WIN_STATUS_DOMAIN_EXISTS = 0xC00000E0,
-  MD_NTSTATUS_WIN_STATUS_DOMAIN_LIMIT_EXCEEDED = 0xC00000E1,
-  MD_NTSTATUS_WIN_STATUS_OPLOCK_NOT_GRANTED = 0xC00000E2,
-  MD_NTSTATUS_WIN_STATUS_INVALID_OPLOCK_PROTOCOL = 0xC00000E3,
-  MD_NTSTATUS_WIN_STATUS_INTERNAL_DB_CORRUPTION = 0xC00000E4,
-  MD_NTSTATUS_WIN_STATUS_INTERNAL_ERROR = 0xC00000E5,
-  MD_NTSTATUS_WIN_STATUS_GENERIC_NOT_MAPPED = 0xC00000E6,
-  MD_NTSTATUS_WIN_STATUS_BAD_DESCRIPTOR_FORMAT = 0xC00000E7,
-  MD_NTSTATUS_WIN_STATUS_INVALID_USER_BUFFER = 0xC00000E8,
-  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_IO_ERROR = 0xC00000E9,
-  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_CREATE_ERR = 0xC00000EA,
-  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_MAP_ERROR = 0xC00000EB,
-  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_EXTEND_ERR = 0xC00000EC,
-  MD_NTSTATUS_WIN_STATUS_NOT_LOGON_PROCESS = 0xC00000ED,
-  MD_NTSTATUS_WIN_STATUS_LOGON_SESSION_EXISTS = 0xC00000EE,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_1 = 0xC00000EF,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_2 = 0xC00000F0,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_3 = 0xC00000F1,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_4 = 0xC00000F2,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_5 = 0xC00000F3,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_6 = 0xC00000F4,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_7 = 0xC00000F5,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_8 = 0xC00000F6,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_9 = 0xC00000F7,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_10 = 0xC00000F8,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_11 = 0xC00000F9,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_12 = 0xC00000FA,
-  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_NOT_STARTED = 0xC00000FB,
-  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_STARTED = 0xC00000FC,
-  MD_NTSTATUS_WIN_STATUS_STACK_OVERFLOW = 0xC00000FD,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_PACKAGE = 0xC00000FE,
-  MD_NTSTATUS_WIN_STATUS_BAD_FUNCTION_TABLE = 0xC00000FF,
-  MD_NTSTATUS_WIN_STATUS_VARIABLE_NOT_FOUND = 0xC0000100,
-  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_EMPTY = 0xC0000101,
-  MD_NTSTATUS_WIN_STATUS_FILE_CORRUPT_ERROR = 0xC0000102,
-  MD_NTSTATUS_WIN_STATUS_NOT_A_DIRECTORY = 0xC0000103,
-  MD_NTSTATUS_WIN_STATUS_BAD_LOGON_SESSION_STATE = 0xC0000104,
-  MD_NTSTATUS_WIN_STATUS_LOGON_SESSION_COLLISION = 0xC0000105,
-  MD_NTSTATUS_WIN_STATUS_NAME_TOO_LONG = 0xC0000106,
-  MD_NTSTATUS_WIN_STATUS_FILES_OPEN = 0xC0000107,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_IN_USE = 0xC0000108,
-  MD_NTSTATUS_WIN_STATUS_MESSAGE_NOT_FOUND = 0xC0000109,
-  MD_NTSTATUS_WIN_STATUS_PROCESS_IS_TERMINATING = 0xC000010A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LOGON_TYPE = 0xC000010B,
-  MD_NTSTATUS_WIN_STATUS_NO_GUID_TRANSLATION = 0xC000010C,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_IMPERSONATE = 0xC000010D,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_ALREADY_LOADED = 0xC000010E,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_NOT_PRESENT = 0xC000010F,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_LID_NOT_EXIST = 0xC0000110,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_LID_ALREADY_OWNED = 0xC0000111,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_NOT_LID_OWNER = 0xC0000112,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_COMMAND = 0xC0000113,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_LID = 0xC0000114,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = 0xC0000115,
-  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_SELECTOR = 0xC0000116,
-  MD_NTSTATUS_WIN_STATUS_NO_LDT = 0xC0000117,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_SIZE = 0xC0000118,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_OFFSET = 0xC0000119,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_DESCRIPTOR = 0xC000011A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_NE_FORMAT = 0xC000011B,
-  MD_NTSTATUS_WIN_STATUS_RXACT_INVALID_STATE = 0xC000011C,
-  MD_NTSTATUS_WIN_STATUS_RXACT_COMMIT_FAILURE = 0xC000011D,
-  MD_NTSTATUS_WIN_STATUS_MAPPED_FILE_SIZE_ZERO = 0xC000011E,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_OPENED_FILES = 0xC000011F,
-  MD_NTSTATUS_WIN_STATUS_CANCELLED = 0xC0000120,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_DELETE = 0xC0000121,
-  MD_NTSTATUS_WIN_STATUS_INVALID_COMPUTER_NAME = 0xC0000122,
-  MD_NTSTATUS_WIN_STATUS_FILE_DELETED = 0xC0000123,
-  MD_NTSTATUS_WIN_STATUS_SPECIAL_ACCOUNT = 0xC0000124,
-  MD_NTSTATUS_WIN_STATUS_SPECIAL_GROUP = 0xC0000125,
-  MD_NTSTATUS_WIN_STATUS_SPECIAL_USER = 0xC0000126,
-  MD_NTSTATUS_WIN_STATUS_MEMBERS_PRIMARY_GROUP = 0xC0000127,
-  MD_NTSTATUS_WIN_STATUS_FILE_CLOSED = 0xC0000128,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_THREADS = 0xC0000129,
-  MD_NTSTATUS_WIN_STATUS_THREAD_NOT_IN_PROCESS = 0xC000012A,
-  MD_NTSTATUS_WIN_STATUS_TOKEN_ALREADY_IN_USE = 0xC000012B,
-  MD_NTSTATUS_WIN_STATUS_PAGEFILE_QUOTA_EXCEEDED = 0xC000012C,
-  MD_NTSTATUS_WIN_STATUS_COMMITMENT_LIMIT = 0xC000012D,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_LE_FORMAT = 0xC000012E,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_NOT_MZ = 0xC000012F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_PROTECT = 0xC0000130,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_16 = 0xC0000131,
-  MD_NTSTATUS_WIN_STATUS_LOGON_SERVER_CONFLICT = 0xC0000132,
-  MD_NTSTATUS_WIN_STATUS_TIME_DIFFERENCE_AT_DC = 0xC0000133,
-  MD_NTSTATUS_WIN_STATUS_SYNCHRONIZATION_REQUIRED = 0xC0000134,
-  MD_NTSTATUS_WIN_STATUS_DLL_NOT_FOUND = 0xC0000135,
-  MD_NTSTATUS_WIN_STATUS_OPEN_FAILED = 0xC0000136,
-  MD_NTSTATUS_WIN_STATUS_IO_PRIVILEGE_FAILED = 0xC0000137,
-  MD_NTSTATUS_WIN_STATUS_ORDINAL_NOT_FOUND = 0xC0000138,
-  MD_NTSTATUS_WIN_STATUS_ENTRYPOINT_NOT_FOUND = 0xC0000139,
-  MD_NTSTATUS_WIN_STATUS_CONTROL_C_EXIT = 0xC000013A,
-  MD_NTSTATUS_WIN_STATUS_LOCAL_DISCONNECT = 0xC000013B,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_DISCONNECT = 0xC000013C,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_RESOURCES = 0xC000013D,
-  MD_NTSTATUS_WIN_STATUS_LINK_FAILED = 0xC000013E,
-  MD_NTSTATUS_WIN_STATUS_LINK_TIMEOUT = 0xC000013F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_CONNECTION = 0xC0000140,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS = 0xC0000141,
-  MD_NTSTATUS_WIN_STATUS_DLL_INIT_FAILED = 0xC0000142,
-  MD_NTSTATUS_WIN_STATUS_MISSING_SYSTEMFILE = 0xC0000143,
-  MD_NTSTATUS_WIN_STATUS_UNHANDLED_EXCEPTION = 0xC0000144,
-  MD_NTSTATUS_WIN_STATUS_APP_INIT_FAILURE = 0xC0000145,
-  MD_NTSTATUS_WIN_STATUS_PAGEFILE_CREATE_FAILED = 0xC0000146,
-  MD_NTSTATUS_WIN_STATUS_NO_PAGEFILE = 0xC0000147,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LEVEL = 0xC0000148,
-  MD_NTSTATUS_WIN_STATUS_WRONG_PASSWORD_CORE = 0xC0000149,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_FLOAT_CONTEXT = 0xC000014A,
-  MD_NTSTATUS_WIN_STATUS_PIPE_BROKEN = 0xC000014B,
-  MD_NTSTATUS_WIN_STATUS_REGISTRY_CORRUPT = 0xC000014C,
-  MD_NTSTATUS_WIN_STATUS_REGISTRY_IO_FAILED = 0xC000014D,
-  MD_NTSTATUS_WIN_STATUS_NO_EVENT_PAIR = 0xC000014E,
-  MD_NTSTATUS_WIN_STATUS_UNRECOGNIZED_VOLUME = 0xC000014F,
-  MD_NTSTATUS_WIN_STATUS_SERIAL_NO_DEVICE_INITED = 0xC0000150,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_ALIAS = 0xC0000151,
-  MD_NTSTATUS_WIN_STATUS_MEMBER_NOT_IN_ALIAS = 0xC0000152,
-  MD_NTSTATUS_WIN_STATUS_MEMBER_IN_ALIAS = 0xC0000153,
-  MD_NTSTATUS_WIN_STATUS_ALIAS_EXISTS = 0xC0000154,
-  MD_NTSTATUS_WIN_STATUS_LOGON_NOT_GRANTED = 0xC0000155,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SECRETS = 0xC0000156,
-  MD_NTSTATUS_WIN_STATUS_SECRET_TOO_LONG = 0xC0000157,
-  MD_NTSTATUS_WIN_STATUS_INTERNAL_DB_ERROR = 0xC0000158,
-  MD_NTSTATUS_WIN_STATUS_FULLSCREEN_MODE = 0xC0000159,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_CONTEXT_IDS = 0xC000015A,
-  MD_NTSTATUS_WIN_STATUS_LOGON_TYPE_NOT_GRANTED = 0xC000015B,
-  MD_NTSTATUS_WIN_STATUS_NOT_REGISTRY_FILE = 0xC000015C,
-  MD_NTSTATUS_WIN_STATUS_NT_CROSS_ENCRYPTION_REQUIRED = 0xC000015D,
-  MD_NTSTATUS_WIN_STATUS_DOMAIN_CTRLR_CONFIG_ERROR = 0xC000015E,
-  MD_NTSTATUS_WIN_STATUS_FT_MISSING_MEMBER = 0xC000015F,
-  MD_NTSTATUS_WIN_STATUS_ILL_FORMED_SERVICE_ENTRY = 0xC0000160,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_CHARACTER = 0xC0000161,
-  MD_NTSTATUS_WIN_STATUS_UNMAPPABLE_CHARACTER = 0xC0000162,
-  MD_NTSTATUS_WIN_STATUS_UNDEFINED_CHARACTER = 0xC0000163,
-  MD_NTSTATUS_WIN_STATUS_FLOPPY_VOLUME = 0xC0000164,
-  MD_NTSTATUS_WIN_STATUS_FLOPPY_ID_MARK_NOT_FOUND = 0xC0000165,
-  MD_NTSTATUS_WIN_STATUS_FLOPPY_WRONG_CYLINDER = 0xC0000166,
-  MD_NTSTATUS_WIN_STATUS_FLOPPY_UNKNOWN_ERROR = 0xC0000167,
-  MD_NTSTATUS_WIN_STATUS_FLOPPY_BAD_REGISTERS = 0xC0000168,
-  MD_NTSTATUS_WIN_STATUS_DISK_RECALIBRATE_FAILED = 0xC0000169,
-  MD_NTSTATUS_WIN_STATUS_DISK_OPERATION_FAILED = 0xC000016A,
-  MD_NTSTATUS_WIN_STATUS_DISK_RESET_FAILED = 0xC000016B,
-  MD_NTSTATUS_WIN_STATUS_SHARED_IRQ_BUSY = 0xC000016C,
-  MD_NTSTATUS_WIN_STATUS_FT_ORPHANING = 0xC000016D,
-  MD_NTSTATUS_WIN_STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = 0xC000016E,
-  MD_NTSTATUS_WIN_STATUS_PARTITION_FAILURE = 0xC0000172,
-  MD_NTSTATUS_WIN_STATUS_INVALID_BLOCK_LENGTH = 0xC0000173,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_PARTITIONED = 0xC0000174,
-  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_LOCK_MEDIA = 0xC0000175,
-  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_UNLOAD_MEDIA = 0xC0000176,
-  MD_NTSTATUS_WIN_STATUS_EOM_OVERFLOW = 0xC0000177,
-  MD_NTSTATUS_WIN_STATUS_NO_MEDIA = 0xC0000178,
-  MD_NTSTATUS_WIN_STATUS_NO_SUCH_MEMBER = 0xC000017A,
-  MD_NTSTATUS_WIN_STATUS_INVALID_MEMBER = 0xC000017B,
-  MD_NTSTATUS_WIN_STATUS_KEY_DELETED = 0xC000017C,
-  MD_NTSTATUS_WIN_STATUS_NO_LOG_SPACE = 0xC000017D,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SIDS = 0xC000017E,
-  MD_NTSTATUS_WIN_STATUS_LM_CROSS_ENCRYPTION_REQUIRED = 0xC000017F,
-  MD_NTSTATUS_WIN_STATUS_KEY_HAS_CHILDREN = 0xC0000180,
-  MD_NTSTATUS_WIN_STATUS_CHILD_MUST_BE_VOLATILE = 0xC0000181,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_CONFIGURATION_ERROR = 0xC0000182,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_INTERNAL_ERROR = 0xC0000183,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_STATE = 0xC0000184,
-  MD_NTSTATUS_WIN_STATUS_IO_DEVICE_ERROR = 0xC0000185,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_PROTOCOL_ERROR = 0xC0000186,
-  MD_NTSTATUS_WIN_STATUS_BACKUP_CONTROLLER = 0xC0000187,
-  MD_NTSTATUS_WIN_STATUS_LOG_FILE_FULL = 0xC0000188,
-  MD_NTSTATUS_WIN_STATUS_TOO_LATE = 0xC0000189,
-  MD_NTSTATUS_WIN_STATUS_NO_TRUST_LSA_SECRET = 0xC000018A,
-  MD_NTSTATUS_WIN_STATUS_NO_TRUST_SAM_ACCOUNT = 0xC000018B,
-  MD_NTSTATUS_WIN_STATUS_TRUSTED_DOMAIN_FAILURE = 0xC000018C,
-  MD_NTSTATUS_WIN_STATUS_TRUSTED_RELATIONSHIP_FAILURE = 0xC000018D,
-  MD_NTSTATUS_WIN_STATUS_EVENTLOG_FILE_CORRUPT = 0xC000018E,
-  MD_NTSTATUS_WIN_STATUS_EVENTLOG_CANT_START = 0xC000018F,
-  MD_NTSTATUS_WIN_STATUS_TRUST_FAILURE = 0xC0000190,
-  MD_NTSTATUS_WIN_STATUS_MUTANT_LIMIT_EXCEEDED = 0xC0000191,
-  MD_NTSTATUS_WIN_STATUS_NETLOGON_NOT_STARTED = 0xC0000192,
-  MD_NTSTATUS_WIN_STATUS_ACCOUNT_EXPIRED = 0xC0000193,
-  MD_NTSTATUS_WIN_STATUS_POSSIBLE_DEADLOCK = 0xC0000194,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_CREDENTIAL_CONFLICT = 0xC0000195,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_SESSION_LIMIT = 0xC0000196,
-  MD_NTSTATUS_WIN_STATUS_EVENTLOG_FILE_CHANGED = 0xC0000197,
-  MD_NTSTATUS_WIN_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0xC0000198,
-  MD_NTSTATUS_WIN_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 0xC0000199,
-  MD_NTSTATUS_WIN_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = 0xC000019A,
-  MD_NTSTATUS_WIN_STATUS_DOMAIN_TRUST_INCONSISTENT = 0xC000019B,
-  MD_NTSTATUS_WIN_STATUS_FS_DRIVER_REQUIRED = 0xC000019C,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_ALREADY_LOADED_AS_DLL = 0xC000019D,
-  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0xC000019E,
-  MD_NTSTATUS_WIN_STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0xC000019F,
-  MD_NTSTATUS_WIN_STATUS_SECURITY_STREAM_IS_INCONSISTENT = 0xC00001A0,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LOCK_RANGE = 0xC00001A1,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ACE_CONDITION = 0xC00001A2,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = 0xC00001A3,
-  MD_NTSTATUS_WIN_STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = 0xC00001A4,
-  MD_NTSTATUS_WIN_STATUS_INVALID_EXCEPTION_HANDLER = 0xC00001A5,
-  MD_NTSTATUS_WIN_STATUS_DUPLICATE_PRIVILEGES = 0xC00001A6,
-  MD_NTSTATUS_WIN_STATUS_NOT_ALLOWED_ON_SYSTEM_FILE = 0xC00001A7,
-  MD_NTSTATUS_WIN_STATUS_REPAIR_NEEDED = 0xC00001A8,
-  MD_NTSTATUS_WIN_STATUS_QUOTA_NOT_ENABLED = 0xC00001A9,
-  MD_NTSTATUS_WIN_STATUS_NO_APPLICATION_PACKAGE = 0xC00001AA,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_OPEN_RESTRICTION = 0xC0000201,
-  MD_NTSTATUS_WIN_STATUS_NO_USER_SESSION_KEY = 0xC0000202,
-  MD_NTSTATUS_WIN_STATUS_USER_SESSION_DELETED = 0xC0000203,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_LANG_NOT_FOUND = 0xC0000204,
-  MD_NTSTATUS_WIN_STATUS_INSUFF_SERVER_RESOURCES = 0xC0000205,
-  MD_NTSTATUS_WIN_STATUS_INVALID_BUFFER_SIZE = 0xC0000206,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS_COMPONENT = 0xC0000207,
-  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS_WILDCARD = 0xC0000208,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_ADDRESSES = 0xC0000209,
-  MD_NTSTATUS_WIN_STATUS_ADDRESS_ALREADY_EXISTS = 0xC000020A,
-  MD_NTSTATUS_WIN_STATUS_ADDRESS_CLOSED = 0xC000020B,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_DISCONNECTED = 0xC000020C,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_RESET = 0xC000020D,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_NODES = 0xC000020E,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ABORTED = 0xC000020F,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_TIMED_OUT = 0xC0000210,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_RELEASE = 0xC0000211,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_MATCH = 0xC0000212,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RESPONDED = 0xC0000213,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_ID = 0xC0000214,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_TYPE = 0xC0000215,
-  MD_NTSTATUS_WIN_STATUS_NOT_SERVER_SESSION = 0xC0000216,
-  MD_NTSTATUS_WIN_STATUS_NOT_CLIENT_SESSION = 0xC0000217,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_LOAD_REGISTRY_FILE = 0xC0000218,
-  MD_NTSTATUS_WIN_STATUS_DEBUG_ATTACH_FAILED = 0xC0000219,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_PROCESS_TERMINATED = 0xC000021A,
-  MD_NTSTATUS_WIN_STATUS_DATA_NOT_ACCEPTED = 0xC000021B,
-  MD_NTSTATUS_WIN_STATUS_NO_BROWSER_SERVERS_FOUND = 0xC000021C,
-  MD_NTSTATUS_WIN_STATUS_VDM_HARD_ERROR = 0xC000021D,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_CANCEL_TIMEOUT = 0xC000021E,
-  MD_NTSTATUS_WIN_STATUS_REPLY_MESSAGE_MISMATCH = 0xC000021F,
-  MD_NTSTATUS_WIN_STATUS_MAPPED_ALIGNMENT = 0xC0000220,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_CHECKSUM_MISMATCH = 0xC0000221,
-  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA = 0xC0000222,
-  MD_NTSTATUS_WIN_STATUS_CLIENT_SERVER_PARAMETERS_INVALID = 0xC0000223,
-  MD_NTSTATUS_WIN_STATUS_PASSWORD_MUST_CHANGE = 0xC0000224,
-  MD_NTSTATUS_WIN_STATUS_NOT_FOUND = 0xC0000225,
-  MD_NTSTATUS_WIN_STATUS_NOT_TINY_STREAM = 0xC0000226,
-  MD_NTSTATUS_WIN_STATUS_RECOVERY_FAILURE = 0xC0000227,
-  MD_NTSTATUS_WIN_STATUS_STACK_OVERFLOW_READ = 0xC0000228,
-  MD_NTSTATUS_WIN_STATUS_FAIL_CHECK = 0xC0000229,
-  MD_NTSTATUS_WIN_STATUS_DUPLICATE_OBJECTID = 0xC000022A,
-  MD_NTSTATUS_WIN_STATUS_OBJECTID_EXISTS = 0xC000022B,
-  MD_NTSTATUS_WIN_STATUS_CONVERT_TO_LARGE = 0xC000022C,
-  MD_NTSTATUS_WIN_STATUS_RETRY = 0xC000022D,
-  MD_NTSTATUS_WIN_STATUS_FOUND_OUT_OF_SCOPE = 0xC000022E,
-  MD_NTSTATUS_WIN_STATUS_ALLOCATE_BUCKET = 0xC000022F,
-  MD_NTSTATUS_WIN_STATUS_PROPSET_NOT_FOUND = 0xC0000230,
-  MD_NTSTATUS_WIN_STATUS_MARSHALL_OVERFLOW = 0xC0000231,
-  MD_NTSTATUS_WIN_STATUS_INVALID_VARIANT = 0xC0000232,
-  MD_NTSTATUS_WIN_STATUS_DOMAIN_CONTROLLER_NOT_FOUND = 0xC0000233,
-  MD_NTSTATUS_WIN_STATUS_ACCOUNT_LOCKED_OUT = 0xC0000234,
-  MD_NTSTATUS_WIN_STATUS_HANDLE_NOT_CLOSABLE = 0xC0000235,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_REFUSED = 0xC0000236,
-  MD_NTSTATUS_WIN_STATUS_GRACEFUL_DISCONNECT = 0xC0000237,
-  MD_NTSTATUS_WIN_STATUS_ADDRESS_ALREADY_ASSOCIATED = 0xC0000238,
-  MD_NTSTATUS_WIN_STATUS_ADDRESS_NOT_ASSOCIATED = 0xC0000239,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_INVALID = 0xC000023A,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_ACTIVE = 0xC000023B,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_UNREACHABLE = 0xC000023C,
-  MD_NTSTATUS_WIN_STATUS_HOST_UNREACHABLE = 0xC000023D,
-  MD_NTSTATUS_WIN_STATUS_PROTOCOL_UNREACHABLE = 0xC000023E,
-  MD_NTSTATUS_WIN_STATUS_PORT_UNREACHABLE = 0xC000023F,
-  MD_NTSTATUS_WIN_STATUS_REQUEST_ABORTED = 0xC0000240,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_ABORTED = 0xC0000241,
-  MD_NTSTATUS_WIN_STATUS_BAD_COMPRESSION_BUFFER = 0xC0000242,
-  MD_NTSTATUS_WIN_STATUS_USER_MAPPED_FILE = 0xC0000243,
-  MD_NTSTATUS_WIN_STATUS_AUDIT_FAILED = 0xC0000244,
-  MD_NTSTATUS_WIN_STATUS_TIMER_RESOLUTION_NOT_SET = 0xC0000245,
-  MD_NTSTATUS_WIN_STATUS_CONNECTION_COUNT_LIMIT = 0xC0000246,
-  MD_NTSTATUS_WIN_STATUS_LOGIN_TIME_RESTRICTION = 0xC0000247,
-  MD_NTSTATUS_WIN_STATUS_LOGIN_WKSTA_RESTRICTION = 0xC0000248,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_MP_UP_MISMATCH = 0xC0000249,
-  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_LOGON_INFO = 0xC0000250,
-  MD_NTSTATUS_WIN_STATUS_BAD_DLL_ENTRYPOINT = 0xC0000251,
-  MD_NTSTATUS_WIN_STATUS_BAD_SERVICE_ENTRYPOINT = 0xC0000252,
-  MD_NTSTATUS_WIN_STATUS_LPC_REPLY_LOST = 0xC0000253,
-  MD_NTSTATUS_WIN_STATUS_IP_ADDRESS_CONFLICT1 = 0xC0000254,
-  MD_NTSTATUS_WIN_STATUS_IP_ADDRESS_CONFLICT2 = 0xC0000255,
-  MD_NTSTATUS_WIN_STATUS_REGISTRY_QUOTA_LIMIT = 0xC0000256,
-  MD_NTSTATUS_WIN_STATUS_PATH_NOT_COVERED = 0xC0000257,
-  MD_NTSTATUS_WIN_STATUS_NO_CALLBACK_ACTIVE = 0xC0000258,
-  MD_NTSTATUS_WIN_STATUS_LICENSE_QUOTA_EXCEEDED = 0xC0000259,
-  MD_NTSTATUS_WIN_STATUS_PWD_TOO_SHORT = 0xC000025A,
-  MD_NTSTATUS_WIN_STATUS_PWD_TOO_RECENT = 0xC000025B,
-  MD_NTSTATUS_WIN_STATUS_PWD_HISTORY_CONFLICT = 0xC000025C,
-  MD_NTSTATUS_WIN_STATUS_PLUGPLAY_NO_DEVICE = 0xC000025E,
-  MD_NTSTATUS_WIN_STATUS_UNSUPPORTED_COMPRESSION = 0xC000025F,
-  MD_NTSTATUS_WIN_STATUS_INVALID_HW_PROFILE = 0xC0000260,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PLUGPLAY_DEVICE_PATH = 0xC0000261,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_ORDINAL_NOT_FOUND = 0xC0000262,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = 0xC0000263,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_NOT_OWNED = 0xC0000264,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_LINKS = 0xC0000265,
-  MD_NTSTATUS_WIN_STATUS_QUOTA_LIST_INCONSISTENT = 0xC0000266,
-  MD_NTSTATUS_WIN_STATUS_FILE_IS_OFFLINE = 0xC0000267,
-  MD_NTSTATUS_WIN_STATUS_EVALUATION_EXPIRATION = 0xC0000268,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_DLL_RELOCATION = 0xC0000269,
-  MD_NTSTATUS_WIN_STATUS_LICENSE_VIOLATION = 0xC000026A,
-  MD_NTSTATUS_WIN_STATUS_DLL_INIT_FAILED_LOGOFF = 0xC000026B,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_UNABLE_TO_LOAD = 0xC000026C,
-  MD_NTSTATUS_WIN_STATUS_DFS_UNAVAILABLE = 0xC000026D,
-  MD_NTSTATUS_WIN_STATUS_VOLUME_DISMOUNTED = 0xC000026E,
-  MD_NTSTATUS_WIN_STATUS_WX86_INTERNAL_ERROR = 0xC000026F,
-  MD_NTSTATUS_WIN_STATUS_WX86_FLOAT_STACK_CHECK = 0xC0000270,
-  MD_NTSTATUS_WIN_STATUS_VALIDATE_CONTINUE = 0xC0000271,
-  MD_NTSTATUS_WIN_STATUS_NO_MATCH = 0xC0000272,
-  MD_NTSTATUS_WIN_STATUS_NO_MORE_MATCHES = 0xC0000273,
-  MD_NTSTATUS_WIN_STATUS_NOT_A_REPARSE_POINT = 0xC0000275,
-  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_INVALID = 0xC0000276,
-  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_MISMATCH = 0xC0000277,
-  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_DATA_INVALID = 0xC0000278,
-  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_NOT_HANDLED = 0xC0000279,
-  MD_NTSTATUS_WIN_STATUS_PWD_TOO_LONG = 0xC000027A,
-  MD_NTSTATUS_WIN_STATUS_STOWED_EXCEPTION = 0xC000027B,
-  MD_NTSTATUS_WIN_STATUS_REPARSE_POINT_NOT_RESOLVED = 0xC0000280,
-  MD_NTSTATUS_WIN_STATUS_DIRECTORY_IS_A_REPARSE_POINT = 0xC0000281,
-  MD_NTSTATUS_WIN_STATUS_RANGE_LIST_CONFLICT = 0xC0000282,
-  MD_NTSTATUS_WIN_STATUS_SOURCE_ELEMENT_EMPTY = 0xC0000283,
-  MD_NTSTATUS_WIN_STATUS_DESTINATION_ELEMENT_FULL = 0xC0000284,
-  MD_NTSTATUS_WIN_STATUS_ILLEGAL_ELEMENT_ADDRESS = 0xC0000285,
-  MD_NTSTATUS_WIN_STATUS_MAGAZINE_NOT_PRESENT = 0xC0000286,
-  MD_NTSTATUS_WIN_STATUS_REINITIALIZATION_NEEDED = 0xC0000287,
-  MD_NTSTATUS_WIN_STATUS_ENCRYPTION_FAILED = 0xC000028A,
-  MD_NTSTATUS_WIN_STATUS_DECRYPTION_FAILED = 0xC000028B,
-  MD_NTSTATUS_WIN_STATUS_RANGE_NOT_FOUND = 0xC000028C,
-  MD_NTSTATUS_WIN_STATUS_NO_RECOVERY_POLICY = 0xC000028D,
-  MD_NTSTATUS_WIN_STATUS_NO_EFS = 0xC000028E,
-  MD_NTSTATUS_WIN_STATUS_WRONG_EFS = 0xC000028F,
-  MD_NTSTATUS_WIN_STATUS_NO_USER_KEYS = 0xC0000290,
-  MD_NTSTATUS_WIN_STATUS_FILE_NOT_ENCRYPTED = 0xC0000291,
-  MD_NTSTATUS_WIN_STATUS_NOT_EXPORT_FORMAT = 0xC0000292,
-  MD_NTSTATUS_WIN_STATUS_FILE_ENCRYPTED = 0xC0000293,
-  MD_NTSTATUS_WIN_STATUS_WMI_GUID_NOT_FOUND = 0xC0000295,
-  MD_NTSTATUS_WIN_STATUS_WMI_INSTANCE_NOT_FOUND = 0xC0000296,
-  MD_NTSTATUS_WIN_STATUS_WMI_ITEMID_NOT_FOUND = 0xC0000297,
-  MD_NTSTATUS_WIN_STATUS_WMI_TRY_AGAIN = 0xC0000298,
-  MD_NTSTATUS_WIN_STATUS_SHARED_POLICY = 0xC0000299,
-  MD_NTSTATUS_WIN_STATUS_POLICY_OBJECT_NOT_FOUND = 0xC000029A,
-  MD_NTSTATUS_WIN_STATUS_POLICY_ONLY_IN_DS = 0xC000029B,
-  MD_NTSTATUS_WIN_STATUS_VOLUME_NOT_UPGRADED = 0xC000029C,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_STORAGE_NOT_ACTIVE = 0xC000029D,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_STORAGE_MEDIA_ERROR = 0xC000029E,
-  MD_NTSTATUS_WIN_STATUS_NO_TRACKING_SERVICE = 0xC000029F,
-  MD_NTSTATUS_WIN_STATUS_SERVER_SID_MISMATCH = 0xC00002A0,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_ATTRIBUTE_OR_VALUE = 0xC00002A1,
-  MD_NTSTATUS_WIN_STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = 0xC00002A2,
-  MD_NTSTATUS_WIN_STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = 0xC00002A3,
-  MD_NTSTATUS_WIN_STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0xC00002A4,
-  MD_NTSTATUS_WIN_STATUS_DS_BUSY = 0xC00002A5,
-  MD_NTSTATUS_WIN_STATUS_DS_UNAVAILABLE = 0xC00002A6,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_RIDS_ALLOCATED = 0xC00002A7,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_MORE_RIDS = 0xC00002A8,
-  MD_NTSTATUS_WIN_STATUS_DS_INCORRECT_ROLE_OWNER = 0xC00002A9,
-  MD_NTSTATUS_WIN_STATUS_DS_RIDMGR_INIT_ERROR = 0xC00002AA,
-  MD_NTSTATUS_WIN_STATUS_DS_OBJ_CLASS_VIOLATION = 0xC00002AB,
-  MD_NTSTATUS_WIN_STATUS_DS_CANT_ON_NON_LEAF = 0xC00002AC,
-  MD_NTSTATUS_WIN_STATUS_DS_CANT_ON_RDN = 0xC00002AD,
-  MD_NTSTATUS_WIN_STATUS_DS_CANT_MOD_OBJ_CLASS = 0xC00002AE,
-  MD_NTSTATUS_WIN_STATUS_DS_CROSS_DOM_MOVE_FAILED = 0xC00002AF,
-  MD_NTSTATUS_WIN_STATUS_DS_GC_NOT_AVAILABLE = 0xC00002B0,
-  MD_NTSTATUS_WIN_STATUS_DIRECTORY_SERVICE_REQUIRED = 0xC00002B1,
-  MD_NTSTATUS_WIN_STATUS_REPARSE_ATTRIBUTE_CONFLICT = 0xC00002B2,
-  MD_NTSTATUS_WIN_STATUS_CANT_ENABLE_DENY_ONLY = 0xC00002B3,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_MULTIPLE_FAULTS = 0xC00002B4,
-  MD_NTSTATUS_WIN_STATUS_FLOAT_MULTIPLE_TRAPS = 0xC00002B5,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_REMOVED = 0xC00002B6,
-  MD_NTSTATUS_WIN_STATUS_JOURNAL_DELETE_IN_PROGRESS = 0xC00002B7,
-  MD_NTSTATUS_WIN_STATUS_JOURNAL_NOT_ACTIVE = 0xC00002B8,
-  MD_NTSTATUS_WIN_STATUS_NOINTERFACE = 0xC00002B9,
-  MD_NTSTATUS_WIN_STATUS_DS_RIDMGR_DISABLED = 0xC00002BA,
-  MD_NTSTATUS_WIN_STATUS_DS_ADMIN_LIMIT_EXCEEDED = 0xC00002C1,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_FAILED_SLEEP = 0xC00002C2,
-  MD_NTSTATUS_WIN_STATUS_MUTUAL_AUTHENTICATION_FAILED = 0xC00002C3,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_SYSTEM_FILE = 0xC00002C4,
-  MD_NTSTATUS_WIN_STATUS_DATATYPE_MISALIGNMENT_ERROR = 0xC00002C5,
-  MD_NTSTATUS_WIN_STATUS_WMI_READ_ONLY = 0xC00002C6,
-  MD_NTSTATUS_WIN_STATUS_WMI_SET_FAILURE = 0xC00002C7,
-  MD_NTSTATUS_WIN_STATUS_COMMITMENT_MINIMUM = 0xC00002C8,
-  MD_NTSTATUS_WIN_STATUS_REG_NAT_CONSUMPTION = 0xC00002C9,
-  MD_NTSTATUS_WIN_STATUS_TRANSPORT_FULL = 0xC00002CA,
-  MD_NTSTATUS_WIN_STATUS_DS_SAM_INIT_FAILURE = 0xC00002CB,
-  MD_NTSTATUS_WIN_STATUS_ONLY_IF_CONNECTED = 0xC00002CC,
-  MD_NTSTATUS_WIN_STATUS_DS_SENSITIVE_GROUP_VIOLATION = 0xC00002CD,
-  MD_NTSTATUS_WIN_STATUS_PNP_RESTART_ENUMERATION = 0xC00002CE,
-  MD_NTSTATUS_WIN_STATUS_JOURNAL_ENTRY_DELETED = 0xC00002CF,
-  MD_NTSTATUS_WIN_STATUS_DS_CANT_MOD_PRIMARYGROUPID = 0xC00002D0,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = 0xC00002D1,
-  MD_NTSTATUS_WIN_STATUS_PNP_REBOOT_REQUIRED = 0xC00002D2,
-  MD_NTSTATUS_WIN_STATUS_POWER_STATE_INVALID = 0xC00002D3,
-  MD_NTSTATUS_WIN_STATUS_DS_INVALID_GROUP_TYPE = 0xC00002D4,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0xC00002D5,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 0xC00002D6,
-  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D7,
-  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0xC00002D8,
-  MD_NTSTATUS_WIN_STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D9,
-  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0xC00002DA,
-  MD_NTSTATUS_WIN_STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 0xC00002DB,
-  MD_NTSTATUS_WIN_STATUS_DS_HAVE_PRIMARY_MEMBERS = 0xC00002DC,
-  MD_NTSTATUS_WIN_STATUS_WMI_NOT_SUPPORTED = 0xC00002DD,
-  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_POWER = 0xC00002DE,
-  MD_NTSTATUS_WIN_STATUS_SAM_NEED_BOOTKEY_PASSWORD = 0xC00002DF,
-  MD_NTSTATUS_WIN_STATUS_SAM_NEED_BOOTKEY_FLOPPY = 0xC00002E0,
-  MD_NTSTATUS_WIN_STATUS_DS_CANT_START = 0xC00002E1,
-  MD_NTSTATUS_WIN_STATUS_DS_INIT_FAILURE = 0xC00002E2,
-  MD_NTSTATUS_WIN_STATUS_SAM_INIT_FAILURE = 0xC00002E3,
-  MD_NTSTATUS_WIN_STATUS_DS_GC_REQUIRED = 0xC00002E4,
-  MD_NTSTATUS_WIN_STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0xC00002E5,
-  MD_NTSTATUS_WIN_STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 0xC00002E6,
-  MD_NTSTATUS_WIN_STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 0xC00002E7,
-  MD_NTSTATUS_WIN_STATUS_MULTIPLE_FAULT_VIOLATION = 0xC00002E8,
-  MD_NTSTATUS_WIN_STATUS_CURRENT_DOMAIN_NOT_ALLOWED = 0xC00002E9,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_MAKE = 0xC00002EA,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_SHUTDOWN = 0xC00002EB,
-  MD_NTSTATUS_WIN_STATUS_DS_INIT_FAILURE_CONSOLE = 0xC00002EC,
-  MD_NTSTATUS_WIN_STATUS_DS_SAM_INIT_FAILURE_CONSOLE = 0xC00002ED,
-  MD_NTSTATUS_WIN_STATUS_UNFINISHED_CONTEXT_DELETED = 0xC00002EE,
-  MD_NTSTATUS_WIN_STATUS_NO_TGT_REPLY = 0xC00002EF,
-  MD_NTSTATUS_WIN_STATUS_OBJECTID_NOT_FOUND = 0xC00002F0,
-  MD_NTSTATUS_WIN_STATUS_NO_IP_ADDRESSES = 0xC00002F1,
-  MD_NTSTATUS_WIN_STATUS_WRONG_CREDENTIAL_HANDLE = 0xC00002F2,
-  MD_NTSTATUS_WIN_STATUS_CRYPTO_SYSTEM_INVALID = 0xC00002F3,
-  MD_NTSTATUS_WIN_STATUS_MAX_REFERRALS_EXCEEDED = 0xC00002F4,
-  MD_NTSTATUS_WIN_STATUS_MUST_BE_KDC = 0xC00002F5,
-  MD_NTSTATUS_WIN_STATUS_STRONG_CRYPTO_NOT_SUPPORTED = 0xC00002F6,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_PRINCIPALS = 0xC00002F7,
-  MD_NTSTATUS_WIN_STATUS_NO_PA_DATA = 0xC00002F8,
-  MD_NTSTATUS_WIN_STATUS_PKINIT_NAME_MISMATCH = 0xC00002F9,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_LOGON_REQUIRED = 0xC00002FA,
-  MD_NTSTATUS_WIN_STATUS_KDC_INVALID_REQUEST = 0xC00002FB,
-  MD_NTSTATUS_WIN_STATUS_KDC_UNABLE_TO_REFER = 0xC00002FC,
-  MD_NTSTATUS_WIN_STATUS_KDC_UNKNOWN_ETYPE = 0xC00002FD,
-  MD_NTSTATUS_WIN_STATUS_SHUTDOWN_IN_PROGRESS = 0xC00002FE,
-  MD_NTSTATUS_WIN_STATUS_SERVER_SHUTDOWN_IN_PROGRESS = 0xC00002FF,
-  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED_ON_SBS = 0xC0000300,
-  MD_NTSTATUS_WIN_STATUS_WMI_GUID_DISCONNECTED = 0xC0000301,
-  MD_NTSTATUS_WIN_STATUS_WMI_ALREADY_DISABLED = 0xC0000302,
-  MD_NTSTATUS_WIN_STATUS_WMI_ALREADY_ENABLED = 0xC0000303,
-  MD_NTSTATUS_WIN_STATUS_MFT_TOO_FRAGMENTED = 0xC0000304,
-  MD_NTSTATUS_WIN_STATUS_COPY_PROTECTION_FAILURE = 0xC0000305,
-  MD_NTSTATUS_WIN_STATUS_CSS_AUTHENTICATION_FAILURE = 0xC0000306,
-  MD_NTSTATUS_WIN_STATUS_CSS_KEY_NOT_PRESENT = 0xC0000307,
-  MD_NTSTATUS_WIN_STATUS_CSS_KEY_NOT_ESTABLISHED = 0xC0000308,
-  MD_NTSTATUS_WIN_STATUS_CSS_SCRAMBLED_SECTOR = 0xC0000309,
-  MD_NTSTATUS_WIN_STATUS_CSS_REGION_MISMATCH = 0xC000030A,
-  MD_NTSTATUS_WIN_STATUS_CSS_RESETS_EXHAUSTED = 0xC000030B,
-  MD_NTSTATUS_WIN_STATUS_PASSWORD_CHANGE_REQUIRED = 0xC000030C,
-  MD_NTSTATUS_WIN_STATUS_PKINIT_FAILURE = 0xC0000320,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_SUBSYSTEM_FAILURE = 0xC0000321,
-  MD_NTSTATUS_WIN_STATUS_NO_KERB_KEY = 0xC0000322,
-  MD_NTSTATUS_WIN_STATUS_HOST_DOWN = 0xC0000350,
-  MD_NTSTATUS_WIN_STATUS_UNSUPPORTED_PREAUTH = 0xC0000351,
-  MD_NTSTATUS_WIN_STATUS_EFS_ALG_BLOB_TOO_BIG = 0xC0000352,
-  MD_NTSTATUS_WIN_STATUS_PORT_NOT_SET = 0xC0000353,
-  MD_NTSTATUS_WIN_STATUS_DEBUGGER_INACTIVE = 0xC0000354,
-  MD_NTSTATUS_WIN_STATUS_DS_VERSION_CHECK_FAILURE = 0xC0000355,
-  MD_NTSTATUS_WIN_STATUS_AUDITING_DISABLED = 0xC0000356,
-  MD_NTSTATUS_WIN_STATUS_PRENT4_MACHINE_ACCOUNT = 0xC0000357,
-  MD_NTSTATUS_WIN_STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0xC0000358,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_32 = 0xC0000359,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_64 = 0xC000035A,
-  MD_NTSTATUS_WIN_STATUS_BAD_BINDINGS = 0xC000035B,
-  MD_NTSTATUS_WIN_STATUS_NETWORK_SESSION_EXPIRED = 0xC000035C,
-  MD_NTSTATUS_WIN_STATUS_APPHELP_BLOCK = 0xC000035D,
-  MD_NTSTATUS_WIN_STATUS_ALL_SIDS_FILTERED = 0xC000035E,
-  MD_NTSTATUS_WIN_STATUS_NOT_SAFE_MODE_DRIVER = 0xC000035F,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = 0xC0000361,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_PATH = 0xC0000362,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = 0xC0000363,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = 0xC0000364,
-  MD_NTSTATUS_WIN_STATUS_FAILED_DRIVER_ENTRY = 0xC0000365,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_ENUMERATION_ERROR = 0xC0000366,
-  MD_NTSTATUS_WIN_STATUS_MOUNT_POINT_NOT_RESOLVED = 0xC0000368,
-  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_OBJECT_PARAMETER = 0xC0000369,
-  MD_NTSTATUS_WIN_STATUS_MCA_OCCURED = 0xC000036A,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_BLOCKED_CRITICAL = 0xC000036B,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_BLOCKED = 0xC000036C,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_DATABASE_ERROR = 0xC000036D,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_HIVE_TOO_LARGE = 0xC000036E,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMPORT_OF_NON_DLL = 0xC000036F,
-  MD_NTSTATUS_WIN_STATUS_NO_SECRETS = 0xC0000371,
-  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 0xC0000372,
-  MD_NTSTATUS_WIN_STATUS_FAILED_STACK_SWITCH = 0xC0000373,
-  MD_NTSTATUS_WIN_STATUS_HEAP_CORRUPTION = 0xC0000374,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_WRONG_PIN = 0xC0000380,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CARD_BLOCKED = 0xC0000381,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = 0xC0000382,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_CARD = 0xC0000383,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_KEY_CONTAINER = 0xC0000384,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_CERTIFICATE = 0xC0000385,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_KEYSET = 0xC0000386,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_IO_ERROR = 0xC0000387,
-  MD_NTSTATUS_WIN_STATUS_DOWNGRADE_DETECTED = 0xC0000388,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CERT_REVOKED = 0xC0000389,
-  MD_NTSTATUS_WIN_STATUS_ISSUING_CA_UNTRUSTED = 0xC000038A,
-  MD_NTSTATUS_WIN_STATUS_REVOCATION_OFFLINE_C = 0xC000038B,
-  MD_NTSTATUS_WIN_STATUS_PKINIT_CLIENT_FAILURE = 0xC000038C,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CERT_EXPIRED = 0xC000038D,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_FAILED_PRIOR_UNLOAD = 0xC000038E,
-  MD_NTSTATUS_WIN_STATUS_SMARTCARD_SILENT_CONTEXT = 0xC000038F,
-  MD_NTSTATUS_WIN_STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = 0xC0000401,
-  MD_NTSTATUS_WIN_STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = 0xC0000402,
-  MD_NTSTATUS_WIN_STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = 0xC0000403,
-  MD_NTSTATUS_WIN_STATUS_DS_NAME_NOT_UNIQUE = 0xC0000404,
-  MD_NTSTATUS_WIN_STATUS_DS_DUPLICATE_ID_FOUND = 0xC0000405,
-  MD_NTSTATUS_WIN_STATUS_DS_GROUP_CONVERSION_ERROR = 0xC0000406,
-  MD_NTSTATUS_WIN_STATUS_VOLSNAP_PREPARE_HIBERNATE = 0xC0000407,
-  MD_NTSTATUS_WIN_STATUS_USER2USER_REQUIRED = 0xC0000408,
-  MD_NTSTATUS_WIN_STATUS_STACK_BUFFER_OVERRUN = 0xC0000409,
-  MD_NTSTATUS_WIN_STATUS_NO_S4U_PROT_SUPPORT = 0xC000040A,
-  MD_NTSTATUS_WIN_STATUS_CROSSREALM_DELEGATION_FAILURE = 0xC000040B,
-  MD_NTSTATUS_WIN_STATUS_REVOCATION_OFFLINE_KDC = 0xC000040C,
-  MD_NTSTATUS_WIN_STATUS_ISSUING_CA_UNTRUSTED_KDC = 0xC000040D,
-  MD_NTSTATUS_WIN_STATUS_KDC_CERT_EXPIRED = 0xC000040E,
-  MD_NTSTATUS_WIN_STATUS_KDC_CERT_REVOKED = 0xC000040F,
-  MD_NTSTATUS_WIN_STATUS_PARAMETER_QUOTA_EXCEEDED = 0xC0000410,
-  MD_NTSTATUS_WIN_STATUS_HIBERNATION_FAILURE = 0xC0000411,
-  MD_NTSTATUS_WIN_STATUS_DELAY_LOAD_FAILED = 0xC0000412,
-  MD_NTSTATUS_WIN_STATUS_AUTHENTICATION_FIREWALL_FAILED = 0xC0000413,
-  MD_NTSTATUS_WIN_STATUS_VDM_DISALLOWED = 0xC0000414,
-  MD_NTSTATUS_WIN_STATUS_HUNG_DISPLAY_DRIVER_THREAD = 0xC0000415,
-  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0xC0000416,
-  MD_NTSTATUS_WIN_STATUS_INVALID_CRUNTIME_PARAMETER = 0xC0000417,
-  MD_NTSTATUS_WIN_STATUS_NTLM_BLOCKED = 0xC0000418,
-  MD_NTSTATUS_WIN_STATUS_DS_SRC_SID_EXISTS_IN_FOREST = 0xC0000419,
-  MD_NTSTATUS_WIN_STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 0xC000041A,
-  MD_NTSTATUS_WIN_STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = 0xC000041B,
-  MD_NTSTATUS_WIN_STATUS_INVALID_USER_PRINCIPAL_NAME = 0xC000041C,
-  MD_NTSTATUS_WIN_STATUS_FATAL_USER_CALLBACK_EXCEPTION = 0xC000041D,
-  MD_NTSTATUS_WIN_STATUS_ASSERTION_FAILURE = 0xC0000420,
-  MD_NTSTATUS_WIN_STATUS_VERIFIER_STOP = 0xC0000421,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_POP_STACK = 0xC0000423,
-  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_DRIVER_BLOCKED = 0xC0000424,
-  MD_NTSTATUS_WIN_STATUS_HIVE_UNLOADED = 0xC0000425,
-  MD_NTSTATUS_WIN_STATUS_COMPRESSION_DISABLED = 0xC0000426,
-  MD_NTSTATUS_WIN_STATUS_FILE_SYSTEM_LIMITATION = 0xC0000427,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_HASH = 0xC0000428,
-  MD_NTSTATUS_WIN_STATUS_NOT_CAPABLE = 0xC0000429,
-  MD_NTSTATUS_WIN_STATUS_REQUEST_OUT_OF_SEQUENCE = 0xC000042A,
-  MD_NTSTATUS_WIN_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B,
-  MD_NTSTATUS_WIN_STATUS_ELEVATION_REQUIRED = 0xC000042C,
-  MD_NTSTATUS_WIN_STATUS_NO_SECURITY_CONTEXT = 0xC000042D,
-  MD_NTSTATUS_WIN_STATUS_PKU2U_CERT_FAILURE = 0xC000042F,
-  MD_NTSTATUS_WIN_STATUS_BEYOND_VDL = 0xC0000432,
-  MD_NTSTATUS_WIN_STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = 0xC0000433,
-  MD_NTSTATUS_WIN_STATUS_PTE_CHANGED = 0xC0000434,
-  MD_NTSTATUS_WIN_STATUS_PURGE_FAILED = 0xC0000435,
-  MD_NTSTATUS_WIN_STATUS_CRED_REQUIRES_CONFIRMATION = 0xC0000440,
-  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 0xC0000441,
-  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = 0xC0000442,
-  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0xC0000443,
-  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 0xC0000444,
-  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_FILE_NOT_CSE = 0xC0000445,
-  MD_NTSTATUS_WIN_STATUS_INVALID_LABEL = 0xC0000446,
-  MD_NTSTATUS_WIN_STATUS_DRIVER_PROCESS_TERMINATED = 0xC0000450,
-  MD_NTSTATUS_WIN_STATUS_AMBIGUOUS_SYSTEM_DEVICE = 0xC0000451,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_DEVICE_NOT_FOUND = 0xC0000452,
-  MD_NTSTATUS_WIN_STATUS_RESTART_BOOT_APPLICATION = 0xC0000453,
-  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_NVRAM_RESOURCES = 0xC0000454,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SESSION = 0xC0000455,
-  MD_NTSTATUS_WIN_STATUS_THREAD_ALREADY_IN_SESSION = 0xC0000456,
-  MD_NTSTATUS_WIN_STATUS_THREAD_NOT_IN_SESSION = 0xC0000457,
-  MD_NTSTATUS_WIN_STATUS_INVALID_WEIGHT = 0xC0000458,
-  MD_NTSTATUS_WIN_STATUS_REQUEST_PAUSED = 0xC0000459,
-  MD_NTSTATUS_WIN_STATUS_NO_RANGES_PROCESSED = 0xC0000460,
-  MD_NTSTATUS_WIN_STATUS_DISK_RESOURCES_EXHAUSTED = 0xC0000461,
-  MD_NTSTATUS_WIN_STATUS_NEEDS_REMEDIATION = 0xC0000462,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_FEATURE_NOT_SUPPORTED = 0xC0000463,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_UNREACHABLE = 0xC0000464,
-  MD_NTSTATUS_WIN_STATUS_INVALID_TOKEN = 0xC0000465,
-  MD_NTSTATUS_WIN_STATUS_SERVER_UNAVAILABLE = 0xC0000466,
-  MD_NTSTATUS_WIN_STATUS_FILE_NOT_AVAILABLE = 0xC0000467,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_INSUFFICIENT_RESOURCES = 0xC0000468,
-  MD_NTSTATUS_WIN_STATUS_PACKAGE_UPDATING = 0xC0000469,
-  MD_NTSTATUS_WIN_STATUS_NOT_READ_FROM_COPY = 0xC000046A,
-  MD_NTSTATUS_WIN_STATUS_FT_WRITE_FAILURE = 0xC000046B,
-  MD_NTSTATUS_WIN_STATUS_FT_DI_SCAN_REQUIRED = 0xC000046C,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_NOT_EXTERNALLY_BACKED = 0xC000046D,
-  MD_NTSTATUS_WIN_STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 0xC000046E,
-  MD_NTSTATUS_WIN_STATUS_DATA_CHECKSUM_ERROR = 0xC0000470,
-  MD_NTSTATUS_WIN_STATUS_INTERMIXED_KERNEL_EA_OPERATION = 0xC0000471,
-  MD_NTSTATUS_WIN_STATUS_TRIM_READ_ZERO_NOT_SUPPORTED = 0xC0000472,
-  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SEGMENT_DESCRIPTORS = 0xC0000473,
-  MD_NTSTATUS_WIN_STATUS_INVALID_OFFSET_ALIGNMENT = 0xC0000474,
-  MD_NTSTATUS_WIN_STATUS_INVALID_FIELD_IN_PARAMETER_LIST = 0xC0000475,
-  MD_NTSTATUS_WIN_STATUS_OPERATION_IN_PROGRESS = 0xC0000476,
-  MD_NTSTATUS_WIN_STATUS_INVALID_INITIATOR_TARGET_PATH = 0xC0000477,
-  MD_NTSTATUS_WIN_STATUS_SCRUB_DATA_DISABLED = 0xC0000478,
-  MD_NTSTATUS_WIN_STATUS_NOT_REDUNDANT_STORAGE = 0xC0000479,
-  MD_NTSTATUS_WIN_STATUS_RESIDENT_FILE_NOT_SUPPORTED = 0xC000047A,
-  MD_NTSTATUS_WIN_STATUS_COMPRESSED_FILE_NOT_SUPPORTED = 0xC000047B,
-  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_SUPPORTED = 0xC000047C,
-  MD_NTSTATUS_WIN_STATUS_IO_OPERATION_TIMEOUT = 0xC000047D,
-  MD_NTSTATUS_WIN_STATUS_SYSTEM_NEEDS_REMEDIATION = 0xC000047E,
-  MD_NTSTATUS_WIN_STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN = 0xC000047F,
-  MD_NTSTATUS_WIN_STATUS_SHARE_UNAVAILABLE = 0xC0000480,
-  MD_NTSTATUS_WIN_STATUS_APISET_NOT_HOSTED = 0xC0000481,
-  MD_NTSTATUS_WIN_STATUS_APISET_NOT_PRESENT = 0xC0000482,
-  MD_NTSTATUS_WIN_STATUS_DEVICE_HARDWARE_ERROR = 0xC0000483,
-  MD_NTSTATUS_WIN_STATUS_INVALID_TASK_NAME = 0xC0000500,
-  MD_NTSTATUS_WIN_STATUS_INVALID_TASK_INDEX = 0xC0000501,
-  MD_NTSTATUS_WIN_STATUS_THREAD_ALREADY_IN_TASK = 0xC0000502,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_BYPASS = 0xC0000503,
-  MD_NTSTATUS_WIN_STATUS_UNDEFINED_SCOPE = 0xC0000504,
-  MD_NTSTATUS_WIN_STATUS_INVALID_CAP = 0xC0000505,
-  MD_NTSTATUS_WIN_STATUS_NOT_GUI_PROCESS = 0xC0000506,
-  MD_NTSTATUS_WIN_STATUS_FAIL_FAST_EXCEPTION = 0xC0000602,
-  MD_NTSTATUS_WIN_STATUS_IMAGE_CERT_REVOKED = 0xC0000603,
-  MD_NTSTATUS_WIN_STATUS_DYNAMIC_CODE_BLOCKED = 0xC0000604,
-  MD_NTSTATUS_WIN_STATUS_PORT_CLOSED = 0xC0000700,
-  MD_NTSTATUS_WIN_STATUS_MESSAGE_LOST = 0xC0000701,
-  MD_NTSTATUS_WIN_STATUS_INVALID_MESSAGE = 0xC0000702,
-  MD_NTSTATUS_WIN_STATUS_REQUEST_CANCELED = 0xC0000703,
-  MD_NTSTATUS_WIN_STATUS_RECURSIVE_DISPATCH = 0xC0000704,
-  MD_NTSTATUS_WIN_STATUS_LPC_RECEIVE_BUFFER_EXPECTED = 0xC0000705,
-  MD_NTSTATUS_WIN_STATUS_LPC_INVALID_CONNECTION_USAGE = 0xC0000706,
-  MD_NTSTATUS_WIN_STATUS_LPC_REQUESTS_NOT_ALLOWED = 0xC0000707,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_IN_USE = 0xC0000708,
-  MD_NTSTATUS_WIN_STATUS_HARDWARE_MEMORY_ERROR = 0xC0000709,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_HANDLE_EXCEPTION = 0xC000070A,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = 0xC000070B,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = 0xC000070C,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = 0xC000070D,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = 0xC000070E,
-  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASED_DURING_OPERATION = 0xC000070F,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = 0xC0000710,
-  MD_NTSTATUS_WIN_STATUS_APC_RETURNED_WHILE_IMPERSONATING = 0xC0000711,
-  MD_NTSTATUS_WIN_STATUS_PROCESS_IS_PROTECTED = 0xC0000712,
-  MD_NTSTATUS_WIN_STATUS_MCA_EXCEPTION = 0xC0000713,
-  MD_NTSTATUS_WIN_STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = 0xC0000714,
-  MD_NTSTATUS_WIN_STATUS_SYMLINK_CLASS_DISABLED = 0xC0000715,
-  MD_NTSTATUS_WIN_STATUS_INVALID_IDN_NORMALIZATION = 0xC0000716,
-  MD_NTSTATUS_WIN_STATUS_NO_UNICODE_TRANSLATION = 0xC0000717,
-  MD_NTSTATUS_WIN_STATUS_ALREADY_REGISTERED = 0xC0000718,
-  MD_NTSTATUS_WIN_STATUS_CONTEXT_MISMATCH = 0xC0000719,
-  MD_NTSTATUS_WIN_STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = 0xC000071A,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = 0xC000071B,
-  MD_NTSTATUS_WIN_STATUS_INVALID_THREAD = 0xC000071C,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_TRANSACTION = 0xC000071D,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_LDR_LOCK = 0xC000071E,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_LANG = 0xC000071F,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_PRI_BACK = 0xC0000720,
-  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = 0xC0000721,
-  MD_NTSTATUS_WIN_STATUS_DISK_REPAIR_DISABLED = 0xC0000800,
-  MD_NTSTATUS_WIN_STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = 0xC0000801,
-  MD_NTSTATUS_WIN_STATUS_DISK_QUOTA_EXCEEDED = 0xC0000802,
-  MD_NTSTATUS_WIN_STATUS_CONTENT_BLOCKED = 0xC0000804,
-  MD_NTSTATUS_WIN_STATUS_BAD_CLUSTERS = 0xC0000805,
-  MD_NTSTATUS_WIN_STATUS_VOLUME_DIRTY = 0xC0000806,
-  MD_NTSTATUS_WIN_STATUS_DISK_REPAIR_UNSUCCESSFUL = 0xC0000808,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_OVERFULL = 0xC0000809,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_CORRUPTED = 0xC000080A,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_UNAVAILABLE = 0xC000080B,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_DELETED_FULL = 0xC000080C,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_CLEARED = 0xC000080D,
-  MD_NTSTATUS_WIN_STATUS_ORPHAN_NAME_EXHAUSTED = 0xC000080E,
-  MD_NTSTATUS_WIN_STATUS_PROACTIVE_SCAN_IN_PROGRESS = 0xC000080F,
-  MD_NTSTATUS_WIN_STATUS_ENCRYPTED_IO_NOT_POSSIBLE = 0xC0000810,
-  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_UPLEVEL_RECORDS = 0xC0000811,
-  MD_NTSTATUS_WIN_STATUS_FILE_CHECKED_OUT = 0xC0000901,
-  MD_NTSTATUS_WIN_STATUS_CHECKOUT_REQUIRED = 0xC0000902,
-  MD_NTSTATUS_WIN_STATUS_BAD_FILE_TYPE = 0xC0000903,
-  MD_NTSTATUS_WIN_STATUS_FILE_TOO_LARGE = 0xC0000904,
-  MD_NTSTATUS_WIN_STATUS_FORMS_AUTH_REQUIRED = 0xC0000905,
-  MD_NTSTATUS_WIN_STATUS_VIRUS_INFECTED = 0xC0000906,
-  MD_NTSTATUS_WIN_STATUS_VIRUS_DELETED = 0xC0000907,
-  MD_NTSTATUS_WIN_STATUS_BAD_MCFG_TABLE = 0xC0000908,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_BREAK_OPLOCK = 0xC0000909,
-  MD_NTSTATUS_WIN_STATUS_BAD_KEY = 0xC000090A,
-  MD_NTSTATUS_WIN_STATUS_BAD_DATA = 0xC000090B,
-  MD_NTSTATUS_WIN_STATUS_NO_KEY = 0xC000090C,
-  MD_NTSTATUS_WIN_STATUS_FILE_HANDLE_REVOKED = 0xC0000910,
-  MD_NTSTATUS_WIN_STATUS_WOW_ASSERTION = 0xC0009898,
-  MD_NTSTATUS_WIN_STATUS_INVALID_SIGNATURE = 0xC000A000,
-  MD_NTSTATUS_WIN_STATUS_HMAC_NOT_SUPPORTED = 0xC000A001,
-  MD_NTSTATUS_WIN_STATUS_AUTH_TAG_MISMATCH = 0xC000A002,
-  MD_NTSTATUS_WIN_STATUS_INVALID_STATE_TRANSITION = 0xC000A003,
-  MD_NTSTATUS_WIN_STATUS_INVALID_KERNEL_INFO_VERSION = 0xC000A004,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PEP_INFO_VERSION = 0xC000A005,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_QUEUE_OVERFLOW = 0xC000A010,
-  MD_NTSTATUS_WIN_STATUS_ND_QUEUE_OVERFLOW = 0xC000A011,
-  MD_NTSTATUS_WIN_STATUS_HOPLIMIT_EXCEEDED = 0xC000A012,
-  MD_NTSTATUS_WIN_STATUS_PROTOCOL_NOT_SUPPORTED = 0xC000A013,
-  MD_NTSTATUS_WIN_STATUS_FASTPATH_REJECTED = 0xC000A014,
-  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 0xC000A080,
-  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 0xC000A081,
-  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 0xC000A082,
-  MD_NTSTATUS_WIN_STATUS_XML_PARSE_ERROR = 0xC000A083,
-  MD_NTSTATUS_WIN_STATUS_XMLDSIG_ERROR = 0xC000A084,
-  MD_NTSTATUS_WIN_STATUS_WRONG_COMPARTMENT = 0xC000A085,
-  MD_NTSTATUS_WIN_STATUS_AUTHIP_FAILURE = 0xC000A086,
-  MD_NTSTATUS_WIN_STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 0xC000A087,
-  MD_NTSTATUS_WIN_STATUS_DS_OID_NOT_FOUND = 0xC000A088,
-  MD_NTSTATUS_WIN_STATUS_INCORRECT_ACCOUNT_TYPE = 0xC000A089,
-  MD_NTSTATUS_WIN_STATUS_HASH_NOT_SUPPORTED = 0xC000A100,
-  MD_NTSTATUS_WIN_STATUS_HASH_NOT_PRESENT = 0xC000A101,
-  MD_NTSTATUS_WIN_STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED = 0xC000A121,
-  MD_NTSTATUS_WIN_STATUS_GPIO_CLIENT_INFORMATION_INVALID = 0xC000A122,
-  MD_NTSTATUS_WIN_STATUS_GPIO_VERSION_NOT_SUPPORTED = 0xC000A123,
-  MD_NTSTATUS_WIN_STATUS_GPIO_INVALID_REGISTRATION_PACKET = 0xC000A124,
-  MD_NTSTATUS_WIN_STATUS_GPIO_OPERATION_DENIED = 0xC000A125,
-  MD_NTSTATUS_WIN_STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE = 0xC000A126,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_SWITCH_RUNLEVEL = 0xC000A141,
-  MD_NTSTATUS_WIN_STATUS_INVALID_RUNLEVEL_SETTING = 0xC000A142,
-  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_TIMEOUT = 0xC000A143,
-  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 0xC000A145,
-  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_IN_PROGRESS = 0xC000A146,
-  MD_NTSTATUS_WIN_STATUS_NOT_APPCONTAINER = 0xC000A200,
-  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED_IN_APPCONTAINER = 0xC000A201,
-  MD_NTSTATUS_WIN_STATUS_INVALID_PACKAGE_SID_LENGTH = 0xC000A202,
-  MD_NTSTATUS_WIN_STATUS_APP_DATA_NOT_FOUND = 0xC000A281,
-  MD_NTSTATUS_WIN_STATUS_APP_DATA_EXPIRED = 0xC000A282,
-  MD_NTSTATUS_WIN_STATUS_APP_DATA_CORRUPT = 0xC000A283,
-  MD_NTSTATUS_WIN_STATUS_APP_DATA_LIMIT_EXCEEDED = 0xC000A284,
-  MD_NTSTATUS_WIN_STATUS_APP_DATA_REBOOT_REQUIRED = 0xC000A285,
-  MD_NTSTATUS_WIN_STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED = 0xC000A2A1,
-  MD_NTSTATUS_WIN_STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 0xC000A2A2,
-  MD_NTSTATUS_WIN_STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED = 0xC000A2A3,
-  MD_NTSTATUS_WIN_STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 0xC000A2A4,
-  MD_NTSTATUS_WIN_DBG_NO_STATE_CHANGE = 0xC0010001,
-  MD_NTSTATUS_WIN_DBG_APP_NOT_IDLE = 0xC0010002,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_STRING_BINDING = 0xC0020001,
-  MD_NTSTATUS_WIN_RPC_NT_WRONG_KIND_OF_BINDING = 0xC0020002,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_BINDING = 0xC0020003,
-  MD_NTSTATUS_WIN_RPC_NT_PROTSEQ_NOT_SUPPORTED = 0xC0020004,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_RPC_PROTSEQ = 0xC0020005,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_STRING_UUID = 0xC0020006,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_ENDPOINT_FORMAT = 0xC0020007,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_NET_ADDR = 0xC0020008,
-  MD_NTSTATUS_WIN_RPC_NT_NO_ENDPOINT_FOUND = 0xC0020009,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_TIMEOUT = 0xC002000A,
-  MD_NTSTATUS_WIN_RPC_NT_OBJECT_NOT_FOUND = 0xC002000B,
-  MD_NTSTATUS_WIN_RPC_NT_ALREADY_REGISTERED = 0xC002000C,
-  MD_NTSTATUS_WIN_RPC_NT_TYPE_ALREADY_REGISTERED = 0xC002000D,
-  MD_NTSTATUS_WIN_RPC_NT_ALREADY_LISTENING = 0xC002000E,
-  MD_NTSTATUS_WIN_RPC_NT_NO_PROTSEQS_REGISTERED = 0xC002000F,
-  MD_NTSTATUS_WIN_RPC_NT_NOT_LISTENING = 0xC0020010,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_MGR_TYPE = 0xC0020011,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_IF = 0xC0020012,
-  MD_NTSTATUS_WIN_RPC_NT_NO_BINDINGS = 0xC0020013,
-  MD_NTSTATUS_WIN_RPC_NT_NO_PROTSEQS = 0xC0020014,
-  MD_NTSTATUS_WIN_RPC_NT_CANT_CREATE_ENDPOINT = 0xC0020015,
-  MD_NTSTATUS_WIN_RPC_NT_OUT_OF_RESOURCES = 0xC0020016,
-  MD_NTSTATUS_WIN_RPC_NT_SERVER_UNAVAILABLE = 0xC0020017,
-  MD_NTSTATUS_WIN_RPC_NT_SERVER_TOO_BUSY = 0xC0020018,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_NETWORK_OPTIONS = 0xC0020019,
-  MD_NTSTATUS_WIN_RPC_NT_NO_CALL_ACTIVE = 0xC002001A,
-  MD_NTSTATUS_WIN_RPC_NT_CALL_FAILED = 0xC002001B,
-  MD_NTSTATUS_WIN_RPC_NT_CALL_FAILED_DNE = 0xC002001C,
-  MD_NTSTATUS_WIN_RPC_NT_PROTOCOL_ERROR = 0xC002001D,
-  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_TRANS_SYN = 0xC002001F,
-  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_TYPE = 0xC0020021,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_TAG = 0xC0020022,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_BOUND = 0xC0020023,
-  MD_NTSTATUS_WIN_RPC_NT_NO_ENTRY_NAME = 0xC0020024,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_NAME_SYNTAX = 0xC0020025,
-  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_NAME_SYNTAX = 0xC0020026,
-  MD_NTSTATUS_WIN_RPC_NT_UUID_NO_ADDRESS = 0xC0020028,
-  MD_NTSTATUS_WIN_RPC_NT_DUPLICATE_ENDPOINT = 0xC0020029,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_TYPE = 0xC002002A,
-  MD_NTSTATUS_WIN_RPC_NT_MAX_CALLS_TOO_SMALL = 0xC002002B,
-  MD_NTSTATUS_WIN_RPC_NT_STRING_TOO_LONG = 0xC002002C,
-  MD_NTSTATUS_WIN_RPC_NT_PROTSEQ_NOT_FOUND = 0xC002002D,
-  MD_NTSTATUS_WIN_RPC_NT_PROCNUM_OUT_OF_RANGE = 0xC002002E,
-  MD_NTSTATUS_WIN_RPC_NT_BINDING_HAS_NO_AUTH = 0xC002002F,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_SERVICE = 0xC0020030,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_LEVEL = 0xC0020031,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_AUTH_IDENTITY = 0xC0020032,
-  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHZ_SERVICE = 0xC0020033,
-  MD_NTSTATUS_WIN_EPT_NT_INVALID_ENTRY = 0xC0020034,
-  MD_NTSTATUS_WIN_EPT_NT_CANT_PERFORM_OP = 0xC0020035,
-  MD_NTSTATUS_WIN_EPT_NT_NOT_REGISTERED = 0xC0020036,
-  MD_NTSTATUS_WIN_RPC_NT_NOTHING_TO_EXPORT = 0xC0020037,
-  MD_NTSTATUS_WIN_RPC_NT_INCOMPLETE_NAME = 0xC0020038,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_VERS_OPTION = 0xC0020039,
-  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_MEMBERS = 0xC002003A,
-  MD_NTSTATUS_WIN_RPC_NT_NOT_ALL_OBJS_UNEXPORTED = 0xC002003B,
-  MD_NTSTATUS_WIN_RPC_NT_INTERFACE_NOT_FOUND = 0xC002003C,
-  MD_NTSTATUS_WIN_RPC_NT_ENTRY_ALREADY_EXISTS = 0xC002003D,
-  MD_NTSTATUS_WIN_RPC_NT_ENTRY_NOT_FOUND = 0xC002003E,
-  MD_NTSTATUS_WIN_RPC_NT_NAME_SERVICE_UNAVAILABLE = 0xC002003F,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_NAF_ID = 0xC0020040,
-  MD_NTSTATUS_WIN_RPC_NT_CANNOT_SUPPORT = 0xC0020041,
-  MD_NTSTATUS_WIN_RPC_NT_NO_CONTEXT_AVAILABLE = 0xC0020042,
-  MD_NTSTATUS_WIN_RPC_NT_INTERNAL_ERROR = 0xC0020043,
-  MD_NTSTATUS_WIN_RPC_NT_ZERO_DIVIDE = 0xC0020044,
-  MD_NTSTATUS_WIN_RPC_NT_ADDRESS_ERROR = 0xC0020045,
-  MD_NTSTATUS_WIN_RPC_NT_FP_DIV_ZERO = 0xC0020046,
-  MD_NTSTATUS_WIN_RPC_NT_FP_UNDERFLOW = 0xC0020047,
-  MD_NTSTATUS_WIN_RPC_NT_FP_OVERFLOW = 0xC0020048,
-  MD_NTSTATUS_WIN_RPC_NT_CALL_IN_PROGRESS = 0xC0020049,
-  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_BINDINGS = 0xC002004A,
-  MD_NTSTATUS_WIN_RPC_NT_GROUP_MEMBER_NOT_FOUND = 0xC002004B,
-  MD_NTSTATUS_WIN_EPT_NT_CANT_CREATE = 0xC002004C,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_OBJECT = 0xC002004D,
-  MD_NTSTATUS_WIN_RPC_NT_NO_INTERFACES = 0xC002004F,
-  MD_NTSTATUS_WIN_RPC_NT_CALL_CANCELLED = 0xC0020050,
-  MD_NTSTATUS_WIN_RPC_NT_BINDING_INCOMPLETE = 0xC0020051,
-  MD_NTSTATUS_WIN_RPC_NT_COMM_FAILURE = 0xC0020052,
-  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_AUTHN_LEVEL = 0xC0020053,
-  MD_NTSTATUS_WIN_RPC_NT_NO_PRINC_NAME = 0xC0020054,
-  MD_NTSTATUS_WIN_RPC_NT_NOT_RPC_ERROR = 0xC0020055,
-  MD_NTSTATUS_WIN_RPC_NT_SEC_PKG_ERROR = 0xC0020057,
-  MD_NTSTATUS_WIN_RPC_NT_NOT_CANCELLED = 0xC0020058,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_ASYNC_HANDLE = 0xC0020062,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_ASYNC_CALL = 0xC0020063,
-  MD_NTSTATUS_WIN_RPC_NT_PROXY_ACCESS_DENIED = 0xC0020064,
-  MD_NTSTATUS_WIN_RPC_NT_COOKIE_AUTH_FAILED = 0xC0020065,
-  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_ENTRIES = 0xC0030001,
-  MD_NTSTATUS_WIN_RPC_NT_SS_CHAR_TRANS_OPEN_FAIL = 0xC0030002,
-  MD_NTSTATUS_WIN_RPC_NT_SS_CHAR_TRANS_SHORT_FILE = 0xC0030003,
-  MD_NTSTATUS_WIN_RPC_NT_SS_IN_NULL_CONTEXT = 0xC0030004,
-  MD_NTSTATUS_WIN_RPC_NT_SS_CONTEXT_MISMATCH = 0xC0030005,
-  MD_NTSTATUS_WIN_RPC_NT_SS_CONTEXT_DAMAGED = 0xC0030006,
-  MD_NTSTATUS_WIN_RPC_NT_SS_HANDLES_MISMATCH = 0xC0030007,
-  MD_NTSTATUS_WIN_RPC_NT_SS_CANNOT_GET_CALL_HANDLE = 0xC0030008,
-  MD_NTSTATUS_WIN_RPC_NT_NULL_REF_POINTER = 0xC0030009,
-  MD_NTSTATUS_WIN_RPC_NT_ENUM_VALUE_OUT_OF_RANGE = 0xC003000A,
-  MD_NTSTATUS_WIN_RPC_NT_BYTE_COUNT_TOO_SMALL = 0xC003000B,
-  MD_NTSTATUS_WIN_RPC_NT_BAD_STUB_DATA = 0xC003000C,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_ES_ACTION = 0xC0030059,
-  MD_NTSTATUS_WIN_RPC_NT_WRONG_ES_VERSION = 0xC003005A,
-  MD_NTSTATUS_WIN_RPC_NT_WRONG_STUB_VERSION = 0xC003005B,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_PIPE_OBJECT = 0xC003005C,
-  MD_NTSTATUS_WIN_RPC_NT_INVALID_PIPE_OPERATION = 0xC003005D,
-  MD_NTSTATUS_WIN_RPC_NT_WRONG_PIPE_VERSION = 0xC003005E,
-  MD_NTSTATUS_WIN_RPC_NT_PIPE_CLOSED = 0xC003005F,
-  MD_NTSTATUS_WIN_RPC_NT_PIPE_DISCIPLINE_ERROR = 0xC0030060,
-  MD_NTSTATUS_WIN_RPC_NT_PIPE_EMPTY = 0xC0030061,
-  MD_NTSTATUS_WIN_STATUS_PNP_BAD_MPS_TABLE = 0xC0040035,
-  MD_NTSTATUS_WIN_STATUS_PNP_TRANSLATION_FAILED = 0xC0040036,
-  MD_NTSTATUS_WIN_STATUS_PNP_IRQ_TRANSLATION_FAILED = 0xC0040037,
-  MD_NTSTATUS_WIN_STATUS_PNP_INVALID_ID = 0xC0040038,
-  MD_NTSTATUS_WIN_STATUS_IO_REISSUE_AS_CACHED = 0xC0040039,
-  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NAME_INVALID = 0xC00A0001,
-  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_PD = 0xC00A0002,
-  MD_NTSTATUS_WIN_STATUS_CTX_PD_NOT_FOUND = 0xC00A0003,
-  MD_NTSTATUS_WIN_STATUS_CTX_CLOSE_PENDING = 0xC00A0006,
-  MD_NTSTATUS_WIN_STATUS_CTX_NO_OUTBUF = 0xC00A0007,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_INF_NOT_FOUND = 0xC00A0008,
-  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_MODEMNAME = 0xC00A0009,
-  MD_NTSTATUS_WIN_STATUS_CTX_RESPONSE_ERROR = 0xC00A000A,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_TIMEOUT = 0xC00A000B,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = 0xC00A000C,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = 0xC00A000D,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_BUSY = 0xC00A000E,
-  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_VOICE = 0xC00A000F,
-  MD_NTSTATUS_WIN_STATUS_CTX_TD_ERROR = 0xC00A0010,
-  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_CLIENT_INVALID = 0xC00A0012,
-  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_NOT_AVAILABLE = 0xC00A0013,
-  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_EXPIRED = 0xC00A0014,
-  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NOT_FOUND = 0xC00A0015,
-  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NAME_COLLISION = 0xC00A0016,
-  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_BUSY = 0xC00A0017,
-  MD_NTSTATUS_WIN_STATUS_CTX_BAD_VIDEO_MODE = 0xC00A0018,
-  MD_NTSTATUS_WIN_STATUS_CTX_GRAPHICS_INVALID = 0xC00A0022,
-  MD_NTSTATUS_WIN_STATUS_CTX_NOT_CONSOLE = 0xC00A0024,
-  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_QUERY_TIMEOUT = 0xC00A0026,
-  MD_NTSTATUS_WIN_STATUS_CTX_CONSOLE_DISCONNECT = 0xC00A0027,
-  MD_NTSTATUS_WIN_STATUS_CTX_CONSOLE_CONNECT = 0xC00A0028,
-  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_DENIED = 0xC00A002A,
-  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_ACCESS_DENIED = 0xC00A002B,
-  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_WD = 0xC00A002E,
-  MD_NTSTATUS_WIN_STATUS_CTX_WD_NOT_FOUND = 0xC00A002F,
-  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_INVALID = 0xC00A0030,
-  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_DISABLED = 0xC00A0031,
-  MD_NTSTATUS_WIN_STATUS_RDP_PROTOCOL_ERROR = 0xC00A0032,
-  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_LICENSE_NOT_SET = 0xC00A0033,
-  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_LICENSE_IN_USE = 0xC00A0034,
-  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0xC00A0035,
-  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_NOT_RUNNING = 0xC00A0036,
-  MD_NTSTATUS_WIN_STATUS_CTX_LOGON_DISABLED = 0xC00A0037,
-  MD_NTSTATUS_WIN_STATUS_CTX_SECURITY_LAYER_ERROR = 0xC00A0038,
-  MD_NTSTATUS_WIN_STATUS_TS_INCOMPATIBLE_SESSIONS = 0xC00A0039,
-  MD_NTSTATUS_WIN_STATUS_TS_VIDEO_SUBSYSTEM_ERROR = 0xC00A003A,
-  MD_NTSTATUS_WIN_STATUS_MUI_FILE_NOT_FOUND = 0xC00B0001,
-  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_FILE = 0xC00B0002,
-  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_RC_CONFIG = 0xC00B0003,
-  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_LOCALE_NAME = 0xC00B0004,
-  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = 0xC00B0005,
-  MD_NTSTATUS_WIN_STATUS_MUI_FILE_NOT_LOADED = 0xC00B0006,
-  MD_NTSTATUS_WIN_STATUS_RESOURCE_ENUM_USER_STOP = 0xC00B0007,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NODE = 0xC0130001,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_EXISTS = 0xC0130002,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_JOIN_IN_PROGRESS = 0xC0130003,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_FOUND = 0xC0130004,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = 0xC0130005,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_EXISTS = 0xC0130006,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_NOT_FOUND = 0xC0130007,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETINTERFACE_EXISTS = 0xC0130008,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = 0xC0130009,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_REQUEST = 0xC013000A,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = 0xC013000B,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_DOWN = 0xC013000C,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_UNREACHABLE = 0xC013000D,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_MEMBER = 0xC013000E,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = 0xC013000F,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NETWORK = 0xC0130010,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NO_NET_ADAPTERS = 0xC0130011,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_UP = 0xC0130012,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_PAUSED = 0xC0130013,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_PAUSED = 0xC0130014,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NO_SECURITY_CONTEXT = 0xC0130015,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_NOT_INTERNAL = 0xC0130016,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_POISONED = 0xC0130017,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_NON_CSV_PATH = 0xC0130018,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL = 0xC0130019,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS = 0xC0130020,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR = 0xC0130021,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_REDIRECTED = 0xC0130022,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_NOT_REDIRECTED = 0xC0130023,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_DRAINING = 0xC0130024,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS = 0xC0130025,
-  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL = 0xC0130026,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_OPCODE = 0xC0140001,
-  MD_NTSTATUS_WIN_STATUS_ACPI_STACK_OVERFLOW = 0xC0140002,
-  MD_NTSTATUS_WIN_STATUS_ACPI_ASSERT_FAILED = 0xC0140003,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_INDEX = 0xC0140004,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ARGUMENT = 0xC0140005,
-  MD_NTSTATUS_WIN_STATUS_ACPI_FATAL = 0xC0140006,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_SUPERNAME = 0xC0140007,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ARGTYPE = 0xC0140008,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_OBJTYPE = 0xC0140009,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_TARGETTYPE = 0xC014000A,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = 0xC014000B,
-  MD_NTSTATUS_WIN_STATUS_ACPI_ADDRESS_NOT_MAPPED = 0xC014000C,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_EVENTTYPE = 0xC014000D,
-  MD_NTSTATUS_WIN_STATUS_ACPI_HANDLER_COLLISION = 0xC014000E,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_DATA = 0xC014000F,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_REGION = 0xC0140010,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ACCESS_SIZE = 0xC0140011,
-  MD_NTSTATUS_WIN_STATUS_ACPI_ACQUIRE_GLOBAL_LOCK = 0xC0140012,
-  MD_NTSTATUS_WIN_STATUS_ACPI_ALREADY_INITIALIZED = 0xC0140013,
-  MD_NTSTATUS_WIN_STATUS_ACPI_NOT_INITIALIZED = 0xC0140014,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_MUTEX_LEVEL = 0xC0140015,
-  MD_NTSTATUS_WIN_STATUS_ACPI_MUTEX_NOT_OWNED = 0xC0140016,
-  MD_NTSTATUS_WIN_STATUS_ACPI_MUTEX_NOT_OWNER = 0xC0140017,
-  MD_NTSTATUS_WIN_STATUS_ACPI_RS_ACCESS = 0xC0140018,
-  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_TABLE = 0xC0140019,
-  MD_NTSTATUS_WIN_STATUS_ACPI_REG_HANDLER_FAILED = 0xC0140020,
-  MD_NTSTATUS_WIN_STATUS_ACPI_POWER_REQUEST_FAILED = 0xC0140021,
-  MD_NTSTATUS_WIN_STATUS_SXS_SECTION_NOT_FOUND = 0xC0150001,
-  MD_NTSTATUS_WIN_STATUS_SXS_CANT_GEN_ACTCTX = 0xC0150002,
-  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = 0xC0150003,
-  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_NOT_FOUND = 0xC0150004,
-  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_FORMAT_ERROR = 0xC0150005,
-  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_PARSE_ERROR = 0xC0150006,
-  MD_NTSTATUS_WIN_STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = 0xC0150007,
-  MD_NTSTATUS_WIN_STATUS_SXS_KEY_NOT_FOUND = 0xC0150008,
-  MD_NTSTATUS_WIN_STATUS_SXS_VERSION_CONFLICT = 0xC0150009,
-  MD_NTSTATUS_WIN_STATUS_SXS_WRONG_SECTION_TYPE = 0xC015000A,
-  MD_NTSTATUS_WIN_STATUS_SXS_THREAD_QUERIES_DISABLED = 0xC015000B,
-  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_MISSING = 0xC015000C,
-  MD_NTSTATUS_WIN_STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = 0xC015000E,
-  MD_NTSTATUS_WIN_STATUS_SXS_EARLY_DEACTIVATION = 0xC015000F,
-  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_DEACTIVATION = 0xC0150010,
-  MD_NTSTATUS_WIN_STATUS_SXS_MULTIPLE_DEACTIVATION = 0xC0150011,
-  MD_NTSTATUS_WIN_STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 0xC0150012,
-  MD_NTSTATUS_WIN_STATUS_SXS_PROCESS_TERMINATION_REQUESTED = 0xC0150013,
-  MD_NTSTATUS_WIN_STATUS_SXS_CORRUPT_ACTIVATION_STACK = 0xC0150014,
-  MD_NTSTATUS_WIN_STATUS_SXS_CORRUPTION = 0xC0150015,
-  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0xC0150016,
-  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 0xC0150017,
-  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 0xC0150018,
-  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITY_PARSE_ERROR = 0xC0150019,
-  MD_NTSTATUS_WIN_STATUS_SXS_COMPONENT_STORE_CORRUPT = 0xC015001A,
-  MD_NTSTATUS_WIN_STATUS_SXS_FILE_HASH_MISMATCH = 0xC015001B,
-  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0xC015001C,
-  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITIES_DIFFERENT = 0xC015001D,
-  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0xC015001E,
-  MD_NTSTATUS_WIN_STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = 0xC015001F,
-  MD_NTSTATUS_WIN_STATUS_ADVANCED_INSTALLER_FAILED = 0xC0150020,
-  MD_NTSTATUS_WIN_STATUS_XML_ENCODING_MISMATCH = 0xC0150021,
-  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_TOO_BIG = 0xC0150022,
-  MD_NTSTATUS_WIN_STATUS_SXS_SETTING_NOT_REGISTERED = 0xC0150023,
-  MD_NTSTATUS_WIN_STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0xC0150024,
-  MD_NTSTATUS_WIN_STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = 0xC0150025,
-  MD_NTSTATUS_WIN_STATUS_GENERIC_COMMAND_FAILED = 0xC0150026,
-  MD_NTSTATUS_WIN_STATUS_SXS_FILE_HASH_MISSING = 0xC0150027,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONAL_CONFLICT = 0xC0190001,
-  MD_NTSTATUS_WIN_STATUS_INVALID_TRANSACTION = 0xC0190002,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ACTIVE = 0xC0190003,
-  MD_NTSTATUS_WIN_STATUS_TM_INITIALIZATION_FAILED = 0xC0190004,
-  MD_NTSTATUS_WIN_STATUS_RM_NOT_ACTIVE = 0xC0190005,
-  MD_NTSTATUS_WIN_STATUS_RM_METADATA_CORRUPT = 0xC0190006,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_JOINED = 0xC0190007,
-  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_RM = 0xC0190008,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = 0xC019000A,
-  MD_NTSTATUS_WIN_STATUS_LOG_RESIZE_INVALID_SIZE = 0xC019000B,
-  MD_NTSTATUS_WIN_STATUS_REMOTE_FILE_VERSION_MISMATCH = 0xC019000C,
-  MD_NTSTATUS_WIN_STATUS_CRM_PROTOCOL_ALREADY_EXISTS = 0xC019000F,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_PROPAGATION_FAILED = 0xC0190010,
-  MD_NTSTATUS_WIN_STATUS_CRM_PROTOCOL_NOT_FOUND = 0xC0190011,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_SUPERIOR_EXISTS = 0xC0190012,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_REQUEST_NOT_VALID = 0xC0190013,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_REQUESTED = 0xC0190014,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ALREADY_ABORTED = 0xC0190015,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ALREADY_COMMITTED = 0xC0190016,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = 0xC0190017,
-  MD_NTSTATUS_WIN_STATUS_CURRENT_TRANSACTION_NOT_VALID = 0xC0190018,
-  MD_NTSTATUS_WIN_STATUS_LOG_GROWTH_FAILED = 0xC0190019,
-  MD_NTSTATUS_WIN_STATUS_OBJECT_NO_LONGER_EXISTS = 0xC0190021,
-  MD_NTSTATUS_WIN_STATUS_STREAM_MINIVERSION_NOT_FOUND = 0xC0190022,
-  MD_NTSTATUS_WIN_STATUS_STREAM_MINIVERSION_NOT_VALID = 0xC0190023,
-  MD_NTSTATUS_WIN_STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 0xC0190024,
-  MD_NTSTATUS_WIN_STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 0xC0190025,
-  MD_NTSTATUS_WIN_STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 0xC0190026,
-  MD_NTSTATUS_WIN_STATUS_HANDLE_NO_LONGER_VALID = 0xC0190028,
-  MD_NTSTATUS_WIN_STATUS_LOG_CORRUPTION_DETECTED = 0xC0190030,
-  MD_NTSTATUS_WIN_STATUS_RM_DISCONNECTED = 0xC0190032,
-  MD_NTSTATUS_WIN_STATUS_ENLISTMENT_NOT_SUPERIOR = 0xC0190033,
-  MD_NTSTATUS_WIN_STATUS_FILE_IDENTITY_NOT_PERSISTENT = 0xC0190036,
-  MD_NTSTATUS_WIN_STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 0xC0190037,
-  MD_NTSTATUS_WIN_STATUS_CANT_CROSS_RM_BOUNDARY = 0xC0190038,
-  MD_NTSTATUS_WIN_STATUS_TXF_DIR_NOT_EMPTY = 0xC0190039,
-  MD_NTSTATUS_WIN_STATUS_INDOUBT_TRANSACTIONS_EXIST = 0xC019003A,
-  MD_NTSTATUS_WIN_STATUS_TM_VOLATILE = 0xC019003B,
-  MD_NTSTATUS_WIN_STATUS_ROLLBACK_TIMER_EXPIRED = 0xC019003C,
-  MD_NTSTATUS_WIN_STATUS_TXF_ATTRIBUTE_CORRUPT = 0xC019003D,
-  MD_NTSTATUS_WIN_STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = 0xC019003E,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = 0xC019003F,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 0xC0190040,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_REQUIRED_PROMOTION = 0xC0190043,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 0xC0190044,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONS_NOT_FROZEN = 0xC0190045,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_FREEZE_IN_PROGRESS = 0xC0190046,
-  MD_NTSTATUS_WIN_STATUS_NOT_SNAPSHOT_VOLUME = 0xC0190047,
-  MD_NTSTATUS_WIN_STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = 0xC0190048,
-  MD_NTSTATUS_WIN_STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 0xC0190049,
-  MD_NTSTATUS_WIN_STATUS_TM_IDENTITY_MISMATCH = 0xC019004A,
-  MD_NTSTATUS_WIN_STATUS_FLOATED_SECTION = 0xC019004B,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = 0xC019004C,
-  MD_NTSTATUS_WIN_STATUS_CANNOT_ABORT_TRANSACTIONS = 0xC019004D,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_FOUND = 0xC019004E,
-  MD_NTSTATUS_WIN_STATUS_RESOURCEMANAGER_NOT_FOUND = 0xC019004F,
-  MD_NTSTATUS_WIN_STATUS_ENLISTMENT_NOT_FOUND = 0xC0190050,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_NOT_FOUND = 0xC0190051,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_NOT_ONLINE = 0xC0190052,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 0xC0190053,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ROOT = 0xC0190054,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_OBJECT_EXPIRED = 0xC0190055,
-  MD_NTSTATUS_WIN_STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 0xC0190056,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = 0xC0190057,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RECORD_TOO_LONG = 0xC0190058,
-  MD_NTSTATUS_WIN_STATUS_NO_LINK_TRACKING_IN_TRANSACTION = 0xC0190059,
-  MD_NTSTATUS_WIN_STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 0xC019005A,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INTEGRITY_VIOLATED = 0xC019005B,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 0xC019005C,
-  MD_NTSTATUS_WIN_STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 0xC019005D,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_MUST_WRITETHROUGH = 0xC019005E,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_SUPERIOR = 0xC019005F,
-  MD_NTSTATUS_WIN_STATUS_EXPIRED_HANDLE = 0xC0190060,
-  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ENLISTED = 0xC0190061,
-  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_INVALID = 0xC01A0001,
-  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_PARITY_INVALID = 0xC01A0002,
-  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_REMAPPED = 0xC01A0003,
-  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_INCOMPLETE = 0xC01A0004,
-  MD_NTSTATUS_WIN_STATUS_LOG_INVALID_RANGE = 0xC01A0005,
-  MD_NTSTATUS_WIN_STATUS_LOG_BLOCKS_EXHAUSTED = 0xC01A0006,
-  MD_NTSTATUS_WIN_STATUS_LOG_READ_CONTEXT_INVALID = 0xC01A0007,
-  MD_NTSTATUS_WIN_STATUS_LOG_RESTART_INVALID = 0xC01A0008,
-  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_VERSION = 0xC01A0009,
-  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_INVALID = 0xC01A000A,
-  MD_NTSTATUS_WIN_STATUS_LOG_READ_MODE_INVALID = 0xC01A000B,
-  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_CORRUPT = 0xC01A000D,
-  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_INVALID = 0xC01A000E,
-  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_INCONSISTENT = 0xC01A000F,
-  MD_NTSTATUS_WIN_STATUS_LOG_RESERVATION_INVALID = 0xC01A0010,
-  MD_NTSTATUS_WIN_STATUS_LOG_CANT_DELETE = 0xC01A0011,
-  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = 0xC01A0012,
-  MD_NTSTATUS_WIN_STATUS_LOG_START_OF_LOG = 0xC01A0013,
-  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_ALREADY_INSTALLED = 0xC01A0014,
-  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_NOT_INSTALLED = 0xC01A0015,
-  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_INVALID = 0xC01A0016,
-  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_CONFLICT = 0xC01A0017,
-  MD_NTSTATUS_WIN_STATUS_LOG_PINNED_ARCHIVE_TAIL = 0xC01A0018,
-  MD_NTSTATUS_WIN_STATUS_LOG_RECORD_NONEXISTENT = 0xC01A0019,
-  MD_NTSTATUS_WIN_STATUS_LOG_RECORDS_RESERVED_INVALID = 0xC01A001A,
-  MD_NTSTATUS_WIN_STATUS_LOG_SPACE_RESERVED_INVALID = 0xC01A001B,
-  MD_NTSTATUS_WIN_STATUS_LOG_TAIL_INVALID = 0xC01A001C,
-  MD_NTSTATUS_WIN_STATUS_LOG_FULL = 0xC01A001D,
-  MD_NTSTATUS_WIN_STATUS_LOG_MULTIPLEXED = 0xC01A001E,
-  MD_NTSTATUS_WIN_STATUS_LOG_DEDICATED = 0xC01A001F,
-  MD_NTSTATUS_WIN_STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = 0xC01A0020,
-  MD_NTSTATUS_WIN_STATUS_LOG_ARCHIVE_IN_PROGRESS = 0xC01A0021,
-  MD_NTSTATUS_WIN_STATUS_LOG_EPHEMERAL = 0xC01A0022,
-  MD_NTSTATUS_WIN_STATUS_LOG_NOT_ENOUGH_CONTAINERS = 0xC01A0023,
-  MD_NTSTATUS_WIN_STATUS_LOG_CLIENT_ALREADY_REGISTERED = 0xC01A0024,
-  MD_NTSTATUS_WIN_STATUS_LOG_CLIENT_NOT_REGISTERED = 0xC01A0025,
-  MD_NTSTATUS_WIN_STATUS_LOG_FULL_HANDLER_IN_PROGRESS = 0xC01A0026,
-  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_READ_FAILED = 0xC01A0027,
-  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_WRITE_FAILED = 0xC01A0028,
-  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_OPEN_FAILED = 0xC01A0029,
-  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_STATE_INVALID = 0xC01A002A,
-  MD_NTSTATUS_WIN_STATUS_LOG_STATE_INVALID = 0xC01A002B,
-  MD_NTSTATUS_WIN_STATUS_LOG_PINNED = 0xC01A002C,
-  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_FLUSH_FAILED = 0xC01A002D,
-  MD_NTSTATUS_WIN_STATUS_LOG_INCONSISTENT_SECURITY = 0xC01A002E,
-  MD_NTSTATUS_WIN_STATUS_LOG_APPENDED_FLUSH_FAILED = 0xC01A002F,
-  MD_NTSTATUS_WIN_STATUS_LOG_PINNED_RESERVATION = 0xC01A0030,
-  MD_NTSTATUS_WIN_STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = 0xC01B00EA,
-  MD_NTSTATUS_WIN_STATUS_FLT_NO_HANDLER_DEFINED = 0xC01C0001,
-  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALREADY_DEFINED = 0xC01C0002,
-  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = 0xC01C0003,
-  MD_NTSTATUS_WIN_STATUS_FLT_DISALLOW_FAST_IO = 0xC01C0004,
-  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_NAME_REQUEST = 0xC01C0005,
-  MD_NTSTATUS_WIN_STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = 0xC01C0006,
-  MD_NTSTATUS_WIN_STATUS_FLT_NOT_INITIALIZED = 0xC01C0007,
-  MD_NTSTATUS_WIN_STATUS_FLT_FILTER_NOT_READY = 0xC01C0008,
-  MD_NTSTATUS_WIN_STATUS_FLT_POST_OPERATION_CLEANUP = 0xC01C0009,
-  MD_NTSTATUS_WIN_STATUS_FLT_INTERNAL_ERROR = 0xC01C000A,
-  MD_NTSTATUS_WIN_STATUS_FLT_DELETING_OBJECT = 0xC01C000B,
-  MD_NTSTATUS_WIN_STATUS_FLT_MUST_BE_NONPAGED_POOL = 0xC01C000C,
-  MD_NTSTATUS_WIN_STATUS_FLT_DUPLICATE_ENTRY = 0xC01C000D,
-  MD_NTSTATUS_WIN_STATUS_FLT_CBDQ_DISABLED = 0xC01C000E,
-  MD_NTSTATUS_WIN_STATUS_FLT_DO_NOT_ATTACH = 0xC01C000F,
-  MD_NTSTATUS_WIN_STATUS_FLT_DO_NOT_DETACH = 0xC01C0010,
-  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = 0xC01C0011,
-  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_NAME_COLLISION = 0xC01C0012,
-  MD_NTSTATUS_WIN_STATUS_FLT_FILTER_NOT_FOUND = 0xC01C0013,
-  MD_NTSTATUS_WIN_STATUS_FLT_VOLUME_NOT_FOUND = 0xC01C0014,
-  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_NOT_FOUND = 0xC01C0015,
-  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = 0xC01C0016,
-  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_CONTEXT_REGISTRATION = 0xC01C0017,
-  MD_NTSTATUS_WIN_STATUS_FLT_NAME_CACHE_MISS = 0xC01C0018,
-  MD_NTSTATUS_WIN_STATUS_FLT_NO_DEVICE_OBJECT = 0xC01C0019,
-  MD_NTSTATUS_WIN_STATUS_FLT_VOLUME_ALREADY_MOUNTED = 0xC01C001A,
-  MD_NTSTATUS_WIN_STATUS_FLT_ALREADY_ENLISTED = 0xC01C001B,
-  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALREADY_LINKED = 0xC01C001C,
-  MD_NTSTATUS_WIN_STATUS_FLT_NO_WAITER_FOR_REPLY = 0xC01C0020,
-  MD_NTSTATUS_WIN_STATUS_FLT_REGISTRATION_BUSY = 0xC01C0023,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_NO_DESCRIPTOR = 0xC01D0001,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = 0xC01D0002,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = 0xC01D0003,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = 0xC01D0004,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = 0xC01D0005,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = 0xC01D0006,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = 0xC01D0007,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = 0xC01D0008,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = 0xC01D0009,
-  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_MANUFACTURE_DATE = 0xC01D000A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = 0xC01E0000,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = 0xC01E0001,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = 0xC01E0002,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_WAS_RESET = 0xC01E0003,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_DRIVER_MODEL = 0xC01E0004,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_MODE_CHANGED = 0xC01E0005,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_OCCLUDED = 0xC01E0006,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_DENIED = 0xC01E0007,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANNOTCOLORCONVERT = 0xC01E0008,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DRIVER_MISMATCH = 0xC01E0009,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = 0xC01E000B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_UNOCCLUDED = 0xC01E000C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE = 0xC01E000D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = 0xC01E000E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_VIDEO_MEMORY = 0xC01E0100,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_LOCK_MEMORY = 0xC01E0101,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_BUSY = 0xC01E0102,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TOO_MANY_REFERENCES = 0xC01E0103,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TRY_AGAIN_LATER = 0xC01E0104,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TRY_AGAIN_NOW = 0xC01E0105,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_INVALID = 0xC01E0106,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = 0xC01E0107,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = 0xC01E0108,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = 0xC01E0109,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = 0xC01E0110,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = 0xC01E0111,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_CLOSED = 0xC01E0112,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = 0xC01E0113,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = 0xC01E0114,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = 0xC01E0115,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = 0xC01E0116,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = 0xC01E0200,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = 0xC01E0300,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = 0xC01E0301,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = 0xC01E0302,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN = 0xC01E0303,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = 0xC01E0304,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = 0xC01E0305,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = 0xC01E0306,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = 0xC01E0308,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = 0xC01E0309,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_FREQUENCY = 0xC01E030A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ACTIVE_REGION = 0xC01E030B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_TOTAL_REGION = 0xC01E030C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = 0xC01E0310,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = 0xC01E0311,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = 0xC01E0312,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = 0xC01E0313,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = 0xC01E0314,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = 0xC01E0315,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = 0xC01E0316,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = 0xC01E0317,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = 0xC01E0318,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = 0xC01E0319,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = 0xC01E031A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = 0xC01E031B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = 0xC01E031C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = 0xC01E031D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = 0xC01E031F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_STALE_MODESET = 0xC01E0320,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = 0xC01E0321,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = 0xC01E0322,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = 0xC01E0323,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = 0xC01E0324,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = 0xC01E0325,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = 0xC01E0326,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = 0xC01E0327,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = 0xC01E0328,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = 0xC01E0329,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = 0xC01E032A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = 0xC01E032B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = 0xC01E032C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = 0xC01E032D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = 0xC01E032E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = 0xC01E032F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_RESOURCES_NOT_RELATED = 0xC01E0330,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = 0xC01E0331,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = 0xC01E0332,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = 0xC01E0333,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = 0xC01E0334,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_VIDPNMGR = 0xC01E0335,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_ACTIVE_VIDPN = 0xC01E0336,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = 0xC01E0337,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = 0xC01E0338,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = 0xC01E0339,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = 0xC01E033A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = 0xC01E033B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_STRIDE = 0xC01E033C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PIXELFORMAT = 0xC01E033D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_COLORBASIS = 0xC01E033E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = 0xC01E033F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = 0xC01E0340,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = 0xC01E0341,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = 0xC01E0342,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = 0xC01E0343,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = 0xC01E0344,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = 0xC01E0345,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = 0xC01E0346,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_GAMMA_RAMP = 0xC01E0347,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = 0xC01E0348,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = 0xC01E0349,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_NOT_IN_MODESET = 0xC01E034A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = 0xC01E034D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = 0xC01E034E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = 0xC01E034F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = 0xC01E0350,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = 0xC01E0352,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = 0xC01E0353,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = 0xC01E0354,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = 0xC01E0355,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = 0xC01E0356,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = 0xC01E0357,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = 0xC01E0358,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = 0xC01E0359,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = 0xC01E035A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_CLIENT_TYPE = 0xC01E035B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = 0xC01E035C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = 0xC01E0400,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = 0xC01E0401,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = 0xC01E0430,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = 0xC01E0431,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = 0xC01E0432,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = 0xC01E0433,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = 0xC01E0434,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = 0xC01E0435,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = 0xC01E0436,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = 0xC01E0438,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = 0xC01E043B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_NOT_SUPPORTED = 0xC01E0500,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_COPP_NOT_SUPPORTED = 0xC01E0501,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UAB_NOT_SUPPORTED = 0xC01E0502,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = 0xC01E0503,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = 0xC01E0505,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INTERNAL_ERROR = 0xC01E050B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_HANDLE = 0xC01E050C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = 0xC01E050E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = 0xC01E050F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = 0xC01E0510,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PVP_HFS_FAILED = 0xC01E0511,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_SRM = 0xC01E0512,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = 0xC01E0513,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = 0xC01E0514,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = 0xC01E0515,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = 0xC01E0516,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = 0xC01E0517,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = 0xC01E0518,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = 0xC01E051A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = 0xC01E051C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = 0xC01E051D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = 0xC01E051E,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = 0xC01E051F,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = 0xC01E0520,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = 0xC01E0521,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_NOT_SUPPORTED = 0xC01E0580,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = 0xC01E0581,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = 0xC01E0582,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = 0xC01E0583,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = 0xC01E0584,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_DATA = 0xC01E0585,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = 0xC01E0586,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = 0xC01E0587,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MCA_INTERNAL_ERROR = 0xC01E0588,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = 0xC01E0589,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = 0xC01E058A,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = 0xC01E058B,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = 0xC01E058C,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = 0xC01E058D,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = 0xC01E05E0,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = 0xC01E05E1,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = 0xC01E05E2,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = 0xC01E05E3,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_POINTER = 0xC01E05E4,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = 0xC01E05E5,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = 0xC01E05E6,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INTERNAL_ERROR = 0xC01E05E7,
-  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = 0xC01E05E8,
-  MD_NTSTATUS_WIN_STATUS_FVE_LOCKED_VOLUME = 0xC0210000,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ENCRYPTED = 0xC0210001,
-  MD_NTSTATUS_WIN_STATUS_FVE_BAD_INFORMATION = 0xC0210002,
-  MD_NTSTATUS_WIN_STATUS_FVE_TOO_SMALL = 0xC0210003,
-  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_WRONG_FS = 0xC0210004,
-  MD_NTSTATUS_WIN_STATUS_FVE_BAD_PARTITION_SIZE = 0xC0210005,
-  MD_NTSTATUS_WIN_STATUS_FVE_FS_NOT_EXTENDED = 0xC0210006,
-  MD_NTSTATUS_WIN_STATUS_FVE_FS_MOUNTED = 0xC0210007,
-  MD_NTSTATUS_WIN_STATUS_FVE_NO_LICENSE = 0xC0210008,
-  MD_NTSTATUS_WIN_STATUS_FVE_ACTION_NOT_ALLOWED = 0xC0210009,
-  MD_NTSTATUS_WIN_STATUS_FVE_BAD_DATA = 0xC021000A,
-  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_NOT_BOUND = 0xC021000B,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_DATA_VOLUME = 0xC021000C,
-  MD_NTSTATUS_WIN_STATUS_FVE_CONV_READ_ERROR = 0xC021000D,
-  MD_NTSTATUS_WIN_STATUS_FVE_CONV_WRITE_ERROR = 0xC021000E,
-  MD_NTSTATUS_WIN_STATUS_FVE_OVERLAPPED_UPDATE = 0xC021000F,
-  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_SECTOR_SIZE = 0xC0210010,
-  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_AUTHENTICATION = 0xC0210011,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_OS_VOLUME = 0xC0210012,
-  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_NOT_FOUND = 0xC0210013,
-  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_INVALID = 0xC0210014,
-  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_NO_VMK = 0xC0210015,
-  MD_NTSTATUS_WIN_STATUS_FVE_TPM_DISABLED = 0xC0210016,
-  MD_NTSTATUS_WIN_STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = 0xC0210017,
-  MD_NTSTATUS_WIN_STATUS_FVE_TPM_INVALID_PCR = 0xC0210018,
-  MD_NTSTATUS_WIN_STATUS_FVE_TPM_NO_VMK = 0xC0210019,
-  MD_NTSTATUS_WIN_STATUS_FVE_PIN_INVALID = 0xC021001A,
-  MD_NTSTATUS_WIN_STATUS_FVE_AUTH_INVALID_APPLICATION = 0xC021001B,
-  MD_NTSTATUS_WIN_STATUS_FVE_AUTH_INVALID_CONFIG = 0xC021001C,
-  MD_NTSTATUS_WIN_STATUS_FVE_DEBUGGER_ENABLED = 0xC021001D,
-  MD_NTSTATUS_WIN_STATUS_FVE_DRY_RUN_FAILED = 0xC021001E,
-  MD_NTSTATUS_WIN_STATUS_FVE_BAD_METADATA_POINTER = 0xC021001F,
-  MD_NTSTATUS_WIN_STATUS_FVE_OLD_METADATA_COPY = 0xC0210020,
-  MD_NTSTATUS_WIN_STATUS_FVE_REBOOT_REQUIRED = 0xC0210021,
-  MD_NTSTATUS_WIN_STATUS_FVE_RAW_ACCESS = 0xC0210022,
-  MD_NTSTATUS_WIN_STATUS_FVE_RAW_BLOCKED = 0xC0210023,
-  MD_NTSTATUS_WIN_STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY = 0xC0210024,
-  MD_NTSTATUS_WIN_STATUS_FVE_MOR_FAILED = 0xC0210025,
-  MD_NTSTATUS_WIN_STATUS_FVE_NO_FEATURE_LICENSE = 0xC0210026,
-  MD_NTSTATUS_WIN_STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = 0xC0210027,
-  MD_NTSTATUS_WIN_STATUS_FVE_CONV_RECOVERY_FAILED = 0xC0210028,
-  MD_NTSTATUS_WIN_STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = 0xC0210029,
-  MD_NTSTATUS_WIN_STATUS_FVE_INVALID_DATUM_TYPE = 0xC021002A,
-  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_TOO_SMALL = 0xC0210030,
-  MD_NTSTATUS_WIN_STATUS_FVE_ENH_PIN_INVALID = 0xC0210031,
-  MD_NTSTATUS_WIN_STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210032,
-  MD_NTSTATUS_WIN_STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210033,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK = 0xC0210034,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_ON_CLUSTER = 0xC0210035,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = 0xC0210036,
-  MD_NTSTATUS_WIN_STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE = 0xC0210037,
-  MD_NTSTATUS_WIN_STATUS_FVE_EDRIVE_DRY_RUN_FAILED = 0xC0210038,
-  MD_NTSTATUS_WIN_STATUS_FVE_SECUREBOOT_DISABLED = 0xC0210039,
-  MD_NTSTATUS_WIN_STATUS_FVE_SECUREBOOT_CONFIG_CHANGE = 0xC021003A,
-  MD_NTSTATUS_WIN_STATUS_FVE_DEVICE_LOCKEDOUT = 0xC021003B,
-  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = 0xC021003C,
-  MD_NTSTATUS_WIN_STATUS_FVE_NOT_DE_VOLUME = 0xC021003D,
-  MD_NTSTATUS_WIN_STATUS_FVE_PROTECTION_DISABLED = 0xC021003E,
-  MD_NTSTATUS_WIN_STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED = 0xC021003F,
-  MD_NTSTATUS_WIN_STATUS_FWP_CALLOUT_NOT_FOUND = 0xC0220001,
-  MD_NTSTATUS_WIN_STATUS_FWP_CONDITION_NOT_FOUND = 0xC0220002,
-  MD_NTSTATUS_WIN_STATUS_FWP_FILTER_NOT_FOUND = 0xC0220003,
-  MD_NTSTATUS_WIN_STATUS_FWP_LAYER_NOT_FOUND = 0xC0220004,
-  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_NOT_FOUND = 0xC0220005,
-  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = 0xC0220006,
-  MD_NTSTATUS_WIN_STATUS_FWP_SUBLAYER_NOT_FOUND = 0xC0220007,
-  MD_NTSTATUS_WIN_STATUS_FWP_NOT_FOUND = 0xC0220008,
-  MD_NTSTATUS_WIN_STATUS_FWP_ALREADY_EXISTS = 0xC0220009,
-  MD_NTSTATUS_WIN_STATUS_FWP_IN_USE = 0xC022000A,
-  MD_NTSTATUS_WIN_STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = 0xC022000B,
-  MD_NTSTATUS_WIN_STATUS_FWP_WRONG_SESSION = 0xC022000C,
-  MD_NTSTATUS_WIN_STATUS_FWP_NO_TXN_IN_PROGRESS = 0xC022000D,
-  MD_NTSTATUS_WIN_STATUS_FWP_TXN_IN_PROGRESS = 0xC022000E,
-  MD_NTSTATUS_WIN_STATUS_FWP_TXN_ABORTED = 0xC022000F,
-  MD_NTSTATUS_WIN_STATUS_FWP_SESSION_ABORTED = 0xC0220010,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_TXN = 0xC0220011,
-  MD_NTSTATUS_WIN_STATUS_FWP_TIMEOUT = 0xC0220012,
-  MD_NTSTATUS_WIN_STATUS_FWP_NET_EVENTS_DISABLED = 0xC0220013,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_LAYER = 0xC0220014,
-  MD_NTSTATUS_WIN_STATUS_FWP_KM_CLIENTS_ONLY = 0xC0220015,
-  MD_NTSTATUS_WIN_STATUS_FWP_LIFETIME_MISMATCH = 0xC0220016,
-  MD_NTSTATUS_WIN_STATUS_FWP_BUILTIN_OBJECT = 0xC0220017,
-  MD_NTSTATUS_WIN_STATUS_FWP_TOO_MANY_CALLOUTS = 0xC0220018,
-  MD_NTSTATUS_WIN_STATUS_FWP_NOTIFICATION_DROPPED = 0xC0220019,
-  MD_NTSTATUS_WIN_STATUS_FWP_TRAFFIC_MISMATCH = 0xC022001A,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_SA_STATE = 0xC022001B,
-  MD_NTSTATUS_WIN_STATUS_FWP_NULL_POINTER = 0xC022001C,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_ENUMERATOR = 0xC022001D,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_FLAGS = 0xC022001E,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_NET_MASK = 0xC022001F,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_RANGE = 0xC0220020,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_INTERVAL = 0xC0220021,
-  MD_NTSTATUS_WIN_STATUS_FWP_ZERO_LENGTH_ARRAY = 0xC0220022,
-  MD_NTSTATUS_WIN_STATUS_FWP_NULL_DISPLAY_NAME = 0xC0220023,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_ACTION_TYPE = 0xC0220024,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_WEIGHT = 0xC0220025,
-  MD_NTSTATUS_WIN_STATUS_FWP_MATCH_TYPE_MISMATCH = 0xC0220026,
-  MD_NTSTATUS_WIN_STATUS_FWP_TYPE_MISMATCH = 0xC0220027,
-  MD_NTSTATUS_WIN_STATUS_FWP_OUT_OF_BOUNDS = 0xC0220028,
-  MD_NTSTATUS_WIN_STATUS_FWP_RESERVED = 0xC0220029,
-  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_CONDITION = 0xC022002A,
-  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_KEYMOD = 0xC022002B,
-  MD_NTSTATUS_WIN_STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = 0xC022002C,
-  MD_NTSTATUS_WIN_STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = 0xC022002D,
-  MD_NTSTATUS_WIN_STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = 0xC022002E,
-  MD_NTSTATUS_WIN_STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = 0xC022002F,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = 0xC0220030,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_DH_GROUP = 0xC0220031,
-  MD_NTSTATUS_WIN_STATUS_FWP_EM_NOT_SUPPORTED = 0xC0220032,
-  MD_NTSTATUS_WIN_STATUS_FWP_NEVER_MATCH = 0xC0220033,
-  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = 0xC0220034,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_PARAMETER = 0xC0220035,
-  MD_NTSTATUS_WIN_STATUS_FWP_TOO_MANY_SUBLAYERS = 0xC0220036,
-  MD_NTSTATUS_WIN_STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = 0xC0220037,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_AUTH_TRANSFORM = 0xC0220038,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_CIPHER_TRANSFORM = 0xC0220039,
-  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM = 0xC022003A,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_TRANSFORM_COMBINATION = 0xC022003B,
-  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_AUTH_METHOD = 0xC022003C,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_TUNNEL_ENDPOINT = 0xC022003D,
-  MD_NTSTATUS_WIN_STATUS_FWP_L2_DRIVER_NOT_READY = 0xC022003E,
-  MD_NTSTATUS_WIN_STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED = 0xC022003F,
-  MD_NTSTATUS_WIN_STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL = 0xC0220040,
-  MD_NTSTATUS_WIN_STATUS_FWP_CONNECTIONS_DISABLED = 0xC0220041,
-  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_DNS_NAME = 0xC0220042,
-  MD_NTSTATUS_WIN_STATUS_FWP_STILL_ON = 0xC0220043,
-  MD_NTSTATUS_WIN_STATUS_FWP_IKEEXT_NOT_RUNNING = 0xC0220044,
-  MD_NTSTATUS_WIN_STATUS_FWP_TCPIP_NOT_READY = 0xC0220100,
-  MD_NTSTATUS_WIN_STATUS_FWP_INJECT_HANDLE_CLOSING = 0xC0220101,
-  MD_NTSTATUS_WIN_STATUS_FWP_INJECT_HANDLE_STALE = 0xC0220102,
-  MD_NTSTATUS_WIN_STATUS_FWP_CANNOT_PEND = 0xC0220103,
-  MD_NTSTATUS_WIN_STATUS_FWP_DROP_NOICMP = 0xC0220104,
-  MD_NTSTATUS_WIN_STATUS_NDIS_CLOSING = 0xC0230002,
-  MD_NTSTATUS_WIN_STATUS_NDIS_BAD_VERSION = 0xC0230004,
-  MD_NTSTATUS_WIN_STATUS_NDIS_BAD_CHARACTERISTICS = 0xC0230005,
-  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_NOT_FOUND = 0xC0230006,
-  MD_NTSTATUS_WIN_STATUS_NDIS_OPEN_FAILED = 0xC0230007,
-  MD_NTSTATUS_WIN_STATUS_NDIS_DEVICE_FAILED = 0xC0230008,
-  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_FULL = 0xC0230009,
-  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_EXISTS = 0xC023000A,
-  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_NOT_FOUND = 0xC023000B,
-  MD_NTSTATUS_WIN_STATUS_NDIS_REQUEST_ABORTED = 0xC023000C,
-  MD_NTSTATUS_WIN_STATUS_NDIS_RESET_IN_PROGRESS = 0xC023000D,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PACKET = 0xC023000F,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_DEVICE_REQUEST = 0xC0230010,
-  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_NOT_READY = 0xC0230011,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_LENGTH = 0xC0230014,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_DATA = 0xC0230015,
-  MD_NTSTATUS_WIN_STATUS_NDIS_BUFFER_TOO_SHORT = 0xC0230016,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_OID = 0xC0230017,
-  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_REMOVED = 0xC0230018,
-  MD_NTSTATUS_WIN_STATUS_NDIS_UNSUPPORTED_MEDIA = 0xC0230019,
-  MD_NTSTATUS_WIN_STATUS_NDIS_GROUP_ADDRESS_IN_USE = 0xC023001A,
-  MD_NTSTATUS_WIN_STATUS_NDIS_FILE_NOT_FOUND = 0xC023001B,
-  MD_NTSTATUS_WIN_STATUS_NDIS_ERROR_READING_FILE = 0xC023001C,
-  MD_NTSTATUS_WIN_STATUS_NDIS_ALREADY_MAPPED = 0xC023001D,
-  MD_NTSTATUS_WIN_STATUS_NDIS_RESOURCE_CONFLICT = 0xC023001E,
-  MD_NTSTATUS_WIN_STATUS_NDIS_MEDIA_DISCONNECTED = 0xC023001F,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_ADDRESS = 0xC0230022,
-  MD_NTSTATUS_WIN_STATUS_NDIS_PAUSED = 0xC023002A,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INTERFACE_NOT_FOUND = 0xC023002B,
-  MD_NTSTATUS_WIN_STATUS_NDIS_UNSUPPORTED_REVISION = 0xC023002C,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PORT = 0xC023002D,
-  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PORT_STATE = 0xC023002E,
-  MD_NTSTATUS_WIN_STATUS_NDIS_LOW_POWER_STATE = 0xC023002F,
-  MD_NTSTATUS_WIN_STATUS_NDIS_REINIT_REQUIRED = 0xC0230030,
-  MD_NTSTATUS_WIN_STATUS_NDIS_NOT_SUPPORTED = 0xC02300BB,
-  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_POLICY = 0xC023100F,
-  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = 0xC0231012,
-  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_PATH_REJECTED = 0xC0231013,
-  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = 0xC0232000,
-  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_MEDIA_IN_USE = 0xC0232001,
-  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_POWER_STATE_INVALID = 0xC0232002,
-  MD_NTSTATUS_WIN_STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = 0xC0232003,
-  MD_NTSTATUS_WIN_STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = 0xC0232004,
-  MD_NTSTATUS_WIN_STATUS_TPM_ERROR_MASK = 0xC0290000,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUTHFAIL = 0xC0290001,
-  MD_NTSTATUS_WIN_STATUS_TPM_BADINDEX = 0xC0290002,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PARAMETER = 0xC0290003,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAILURE = 0xC0290004,
-  MD_NTSTATUS_WIN_STATUS_TPM_CLEAR_DISABLED = 0xC0290005,
-  MD_NTSTATUS_WIN_STATUS_TPM_DEACTIVATED = 0xC0290006,
-  MD_NTSTATUS_WIN_STATUS_TPM_DISABLED = 0xC0290007,
-  MD_NTSTATUS_WIN_STATUS_TPM_DISABLED_CMD = 0xC0290008,
-  MD_NTSTATUS_WIN_STATUS_TPM_FAIL = 0xC0290009,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_ORDINAL = 0xC029000A,
-  MD_NTSTATUS_WIN_STATUS_TPM_INSTALL_DISABLED = 0xC029000B,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_KEYHANDLE = 0xC029000C,
-  MD_NTSTATUS_WIN_STATUS_TPM_KEYNOTFOUND = 0xC029000D,
-  MD_NTSTATUS_WIN_STATUS_TPM_INAPPROPRIATE_ENC = 0xC029000E,
-  MD_NTSTATUS_WIN_STATUS_TPM_MIGRATEFAIL = 0xC029000F,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_PCR_INFO = 0xC0290010,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOSPACE = 0xC0290011,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOSRK = 0xC0290012,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOTSEALED_BLOB = 0xC0290013,
-  MD_NTSTATUS_WIN_STATUS_TPM_OWNER_SET = 0xC0290014,
-  MD_NTSTATUS_WIN_STATUS_TPM_RESOURCES = 0xC0290015,
-  MD_NTSTATUS_WIN_STATUS_TPM_SHORTRANDOM = 0xC0290016,
-  MD_NTSTATUS_WIN_STATUS_TPM_SIZE = 0xC0290017,
-  MD_NTSTATUS_WIN_STATUS_TPM_WRONGPCRVAL = 0xC0290018,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PARAM_SIZE = 0xC0290019,
-  MD_NTSTATUS_WIN_STATUS_TPM_SHA_THREAD = 0xC029001A,
-  MD_NTSTATUS_WIN_STATUS_TPM_SHA_ERROR = 0xC029001B,
-  MD_NTSTATUS_WIN_STATUS_TPM_FAILEDSELFTEST = 0xC029001C,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUTH2FAIL = 0xC029001D,
-  MD_NTSTATUS_WIN_STATUS_TPM_BADTAG = 0xC029001E,
-  MD_NTSTATUS_WIN_STATUS_TPM_IOERROR = 0xC029001F,
-  MD_NTSTATUS_WIN_STATUS_TPM_ENCRYPT_ERROR = 0xC0290020,
-  MD_NTSTATUS_WIN_STATUS_TPM_DECRYPT_ERROR = 0xC0290021,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_AUTHHANDLE = 0xC0290022,
-  MD_NTSTATUS_WIN_STATUS_TPM_NO_ENDORSEMENT = 0xC0290023,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_KEYUSAGE = 0xC0290024,
-  MD_NTSTATUS_WIN_STATUS_TPM_WRONG_ENTITYTYPE = 0xC0290025,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_POSTINIT = 0xC0290026,
-  MD_NTSTATUS_WIN_STATUS_TPM_INAPPROPRIATE_SIG = 0xC0290027,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_KEY_PROPERTY = 0xC0290028,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_MIGRATION = 0xC0290029,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_SCHEME = 0xC029002A,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_DATASIZE = 0xC029002B,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_MODE = 0xC029002C,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PRESENCE = 0xC029002D,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_VERSION = 0xC029002E,
-  MD_NTSTATUS_WIN_STATUS_TPM_NO_WRAP_TRANSPORT = 0xC029002F,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAIL_UNSUCCESSFUL = 0xC0290030,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAIL_SUCCESSFUL = 0xC0290031,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOTRESETABLE = 0xC0290032,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOTLOCAL = 0xC0290033,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_TYPE = 0xC0290034,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_RESOURCE = 0xC0290035,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOTFIPS = 0xC0290036,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_FAMILY = 0xC0290037,
-  MD_NTSTATUS_WIN_STATUS_TPM_NO_NV_PERMISSION = 0xC0290038,
-  MD_NTSTATUS_WIN_STATUS_TPM_REQUIRES_SIGN = 0xC0290039,
-  MD_NTSTATUS_WIN_STATUS_TPM_KEY_NOTSUPPORTED = 0xC029003A,
-  MD_NTSTATUS_WIN_STATUS_TPM_AUTH_CONFLICT = 0xC029003B,
-  MD_NTSTATUS_WIN_STATUS_TPM_AREA_LOCKED = 0xC029003C,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_LOCALITY = 0xC029003D,
-  MD_NTSTATUS_WIN_STATUS_TPM_READ_ONLY = 0xC029003E,
-  MD_NTSTATUS_WIN_STATUS_TPM_PER_NOWRITE = 0xC029003F,
-  MD_NTSTATUS_WIN_STATUS_TPM_FAMILYCOUNT = 0xC0290040,
-  MD_NTSTATUS_WIN_STATUS_TPM_WRITE_LOCKED = 0xC0290041,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_ATTRIBUTES = 0xC0290042,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_STRUCTURE = 0xC0290043,
-  MD_NTSTATUS_WIN_STATUS_TPM_KEY_OWNER_CONTROL = 0xC0290044,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_COUNTER = 0xC0290045,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOT_FULLWRITE = 0xC0290046,
-  MD_NTSTATUS_WIN_STATUS_TPM_CONTEXT_GAP = 0xC0290047,
-  MD_NTSTATUS_WIN_STATUS_TPM_MAXNVWRITES = 0xC0290048,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOOPERATOR = 0xC0290049,
-  MD_NTSTATUS_WIN_STATUS_TPM_RESOURCEMISSING = 0xC029004A,
-  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_LOCK = 0xC029004B,
-  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_FAMILY = 0xC029004C,
-  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_ADMIN = 0xC029004D,
-  MD_NTSTATUS_WIN_STATUS_TPM_TRANSPORT_NOTEXCLUSIVE = 0xC029004E,
-  MD_NTSTATUS_WIN_STATUS_TPM_OWNER_CONTROL = 0xC029004F,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_RESOURCES = 0xC0290050,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_INPUT_DATA0 = 0xC0290051,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_INPUT_DATA1 = 0xC0290052,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_ISSUER_SETTINGS = 0xC0290053,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_TPM_SETTINGS = 0xC0290054,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_STAGE = 0xC0290055,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_ISSUER_VALIDITY = 0xC0290056,
-  MD_NTSTATUS_WIN_STATUS_TPM_DAA_WRONG_W = 0xC0290057,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_HANDLE = 0xC0290058,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_DELEGATE = 0xC0290059,
-  MD_NTSTATUS_WIN_STATUS_TPM_BADCONTEXT = 0xC029005A,
-  MD_NTSTATUS_WIN_STATUS_TPM_TOOMANYCONTEXTS = 0xC029005B,
-  MD_NTSTATUS_WIN_STATUS_TPM_MA_TICKET_SIGNATURE = 0xC029005C,
-  MD_NTSTATUS_WIN_STATUS_TPM_MA_DESTINATION = 0xC029005D,
-  MD_NTSTATUS_WIN_STATUS_TPM_MA_SOURCE = 0xC029005E,
-  MD_NTSTATUS_WIN_STATUS_TPM_MA_AUTHORITY = 0xC029005F,
-  MD_NTSTATUS_WIN_STATUS_TPM_PERMANENTEK = 0xC0290061,
-  MD_NTSTATUS_WIN_STATUS_TPM_BAD_SIGNATURE = 0xC0290062,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOCONTEXTSPACE = 0xC0290063,
-  MD_NTSTATUS_WIN_STATUS_TPM_COMMAND_BLOCKED = 0xC0290400,
-  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_HANDLE = 0xC0290401,
-  MD_NTSTATUS_WIN_STATUS_TPM_DUPLICATE_VHANDLE = 0xC0290402,
-  MD_NTSTATUS_WIN_STATUS_TPM_EMBEDDED_COMMAND_BLOCKED = 0xC0290403,
-  MD_NTSTATUS_WIN_STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED = 0xC0290404,
-  MD_NTSTATUS_WIN_STATUS_TPM_RETRY = 0xC0290800,
-  MD_NTSTATUS_WIN_STATUS_TPM_NEEDS_SELFTEST = 0xC0290801,
-  MD_NTSTATUS_WIN_STATUS_TPM_DOING_SELFTEST = 0xC0290802,
-  MD_NTSTATUS_WIN_STATUS_TPM_DEFEND_LOCK_RUNNING = 0xC0290803,
-  MD_NTSTATUS_WIN_STATUS_TPM_COMMAND_CANCELED = 0xC0291001,
-  MD_NTSTATUS_WIN_STATUS_TPM_TOO_MANY_CONTEXTS = 0xC0291002,
-  MD_NTSTATUS_WIN_STATUS_TPM_NOT_FOUND = 0xC0291003,
-  MD_NTSTATUS_WIN_STATUS_TPM_ACCESS_DENIED = 0xC0291004,
-  MD_NTSTATUS_WIN_STATUS_TPM_INSUFFICIENT_BUFFER = 0xC0291005,
-  MD_NTSTATUS_WIN_STATUS_TPM_PPI_FUNCTION_UNSUPPORTED = 0xC0291006,
-  MD_NTSTATUS_WIN_STATUS_PCP_ERROR_MASK = 0xC0292000,
-  MD_NTSTATUS_WIN_STATUS_PCP_DEVICE_NOT_READY = 0xC0292001,
-  MD_NTSTATUS_WIN_STATUS_PCP_INVALID_HANDLE = 0xC0292002,
-  MD_NTSTATUS_WIN_STATUS_PCP_INVALID_PARAMETER = 0xC0292003,
-  MD_NTSTATUS_WIN_STATUS_PCP_FLAG_NOT_SUPPORTED = 0xC0292004,
-  MD_NTSTATUS_WIN_STATUS_PCP_NOT_SUPPORTED = 0xC0292005,
-  MD_NTSTATUS_WIN_STATUS_PCP_BUFFER_TOO_SMALL = 0xC0292006,
-  MD_NTSTATUS_WIN_STATUS_PCP_INTERNAL_ERROR = 0xC0292007,
-  MD_NTSTATUS_WIN_STATUS_PCP_AUTHENTICATION_FAILED = 0xC0292008,
-  MD_NTSTATUS_WIN_STATUS_PCP_AUTHENTICATION_IGNORED = 0xC0292009,
-  MD_NTSTATUS_WIN_STATUS_PCP_POLICY_NOT_FOUND = 0xC029200A,
-  MD_NTSTATUS_WIN_STATUS_PCP_PROFILE_NOT_FOUND = 0xC029200B,
-  MD_NTSTATUS_WIN_STATUS_PCP_VALIDATION_FAILED = 0xC029200C,
-  MD_NTSTATUS_WIN_STATUS_PCP_DEVICE_NOT_FOUND = 0xC029200D,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_HYPERCALL_CODE = 0xC0350002,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_HYPERCALL_INPUT = 0xC0350003,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_ALIGNMENT = 0xC0350004,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARAMETER = 0xC0350005,
-  MD_NTSTATUS_WIN_STATUS_HV_ACCESS_DENIED = 0xC0350006,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARTITION_STATE = 0xC0350007,
-  MD_NTSTATUS_WIN_STATUS_HV_OPERATION_DENIED = 0xC0350008,
-  MD_NTSTATUS_WIN_STATUS_HV_UNKNOWN_PROPERTY = 0xC0350009,
-  MD_NTSTATUS_WIN_STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE = 0xC035000A,
-  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_MEMORY = 0xC035000B,
-  MD_NTSTATUS_WIN_STATUS_HV_PARTITION_TOO_DEEP = 0xC035000C,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARTITION_ID = 0xC035000D,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_VP_INDEX = 0xC035000E,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PORT_ID = 0xC0350011,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_CONNECTION_ID = 0xC0350012,
-  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_BUFFERS = 0xC0350013,
-  MD_NTSTATUS_WIN_STATUS_HV_NOT_ACKNOWLEDGED = 0xC0350014,
-  MD_NTSTATUS_WIN_STATUS_HV_ACKNOWLEDGED = 0xC0350016,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_SAVE_RESTORE_STATE = 0xC0350017,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_SYNIC_STATE = 0xC0350018,
-  MD_NTSTATUS_WIN_STATUS_HV_OBJECT_IN_USE = 0xC0350019,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO = 0xC035001A,
-  MD_NTSTATUS_WIN_STATUS_HV_NO_DATA = 0xC035001B,
-  MD_NTSTATUS_WIN_STATUS_HV_INACTIVE = 0xC035001C,
-  MD_NTSTATUS_WIN_STATUS_HV_NO_RESOURCES = 0xC035001D,
-  MD_NTSTATUS_WIN_STATUS_HV_FEATURE_UNAVAILABLE = 0xC035001E,
-  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_BUFFER = 0xC0350033,
-  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS = 0xC0350038,
-  MD_NTSTATUS_WIN_STATUS_HV_INVALID_LP_INDEX = 0xC0350041,
-  MD_NTSTATUS_WIN_STATUS_HV_NOT_PRESENT = 0xC0351000,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_BAD_SPI = 0xC0360001,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_SA_LIFETIME_EXPIRED = 0xC0360002,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_WRONG_SA = 0xC0360003,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_REPLAY_CHECK_FAILED = 0xC0360004,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_INVALID_PACKET = 0xC0360005,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_INTEGRITY_CHECK_FAILED = 0xC0360006,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_CLEAR_TEXT_DROP = 0xC0360007,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_AUTH_FIREWALL_DROP = 0xC0360008,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_THROTTLE_DROP = 0xC0360009,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_BLOCK = 0xC0368000,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = 0xC0368001,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_INVALID_PACKET = 0xC0368002,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = 0xC0368003,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_MAX_ENTRIES = 0xC0368004,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 0xC0368005,
-  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 0xC0368006,
-  MD_NTSTATUS_WIN_STATUS_VID_DUPLICATE_HANDLER = 0xC0370001,
-  MD_NTSTATUS_WIN_STATUS_VID_TOO_MANY_HANDLERS = 0xC0370002,
-  MD_NTSTATUS_WIN_STATUS_VID_QUEUE_FULL = 0xC0370003,
-  MD_NTSTATUS_WIN_STATUS_VID_HANDLER_NOT_PRESENT = 0xC0370004,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_OBJECT_NAME = 0xC0370005,
-  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_NAME_TOO_LONG = 0xC0370006,
-  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG = 0xC0370007,
-  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_ALREADY_EXISTS = 0xC0370008,
-  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_DOES_NOT_EXIST = 0xC0370009,
-  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_NAME_NOT_FOUND = 0xC037000A,
-  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS = 0xC037000B,
-  MD_NTSTATUS_WIN_STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = 0xC037000C,
-  MD_NTSTATUS_WIN_STATUS_VID_MB_STILL_REFERENCED = 0xC037000D,
-  MD_NTSTATUS_WIN_STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED = 0xC037000E,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_NUMA_SETTINGS = 0xC037000F,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_NUMA_NODE_INDEX = 0xC0370010,
-  MD_NTSTATUS_WIN_STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = 0xC0370011,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE = 0xC0370012,
-  MD_NTSTATUS_WIN_STATUS_VID_PAGE_RANGE_OVERFLOW = 0xC0370013,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE = 0xC0370014,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_GPA_RANGE_HANDLE = 0xC0370015,
-  MD_NTSTATUS_WIN_STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = 0xC0370016,
-  MD_NTSTATUS_WIN_STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = 0xC0370017,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_PPM_HANDLE = 0xC0370018,
-  MD_NTSTATUS_WIN_STATUS_VID_MBPS_ARE_LOCKED = 0xC0370019,
-  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_CLOSED = 0xC037001A,
-  MD_NTSTATUS_WIN_STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = 0xC037001B,
-  MD_NTSTATUS_WIN_STATUS_VID_STOP_PENDING = 0xC037001C,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_PROCESSOR_STATE = 0xC037001D,
-  MD_NTSTATUS_WIN_STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = 0xC037001E,
-  MD_NTSTATUS_WIN_STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED = 0xC037001F,
-  MD_NTSTATUS_WIN_STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET = 0xC0370020,
-  MD_NTSTATUS_WIN_STATUS_VID_MMIO_RANGE_DESTROYED = 0xC0370021,
-  MD_NTSTATUS_WIN_STATUS_VID_INVALID_CHILD_GPA_PAGE_SET = 0xC0370022,
-  MD_NTSTATUS_WIN_STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED = 0xC0370023,
-  MD_NTSTATUS_WIN_STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL = 0xC0370024,
-  MD_NTSTATUS_WIN_STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = 0xC0370025,
-  MD_NTSTATUS_WIN_STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT = 0xC0370026,
-  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_CORRUPT = 0xC0370027,
-  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM = 0xC0370028,
-  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_INCOMPATIBLE = 0xC0370029,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DATABASE_FULL = 0xC0380001,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED = 0xC0380002,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = 0xC0380003,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED = 0xC0380004,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = 0xC0380005,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_DUPLICATE = 0xC0380006,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_DYNAMIC = 0xC0380007,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_ID_INVALID = 0xC0380008,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_INVALID = 0xC0380009,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAST_VOTER = 0xC038000A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_INVALID = 0xC038000B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = 0xC038000C,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = 0xC038000D,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = 0xC038000E,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = 0xC038000F,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = 0xC0380010,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_MISSING = 0xC0380011,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_NOT_EMPTY = 0xC0380012,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE = 0xC0380013,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_REVECTORING_FAILED = 0xC0380014,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID = 0xC0380015,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_SET_NOT_CONTAINED = 0xC0380016,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = 0xC0380017,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = 0xC0380018,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = 0xC0380019,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_ALREADY_USED = 0xC038001A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS = 0xC038001B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = 0xC038001C,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = 0xC038001D,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = 0xC038001E,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = 0xC038001F,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = 0xC0380020,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID = 0xC0380021,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS = 0xC0380022,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_IN_SYNC = 0xC0380023,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE = 0xC0380024,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_INDEX_INVALID = 0xC0380025,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_MISSING = 0xC0380026,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_NOT_DETACHED = 0xC0380027,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_REGENERATING = 0xC0380028,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_ALL_DISKS_FAILED = 0xC0380029,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_REGISTERED_USERS = 0xC038002A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_SUCH_USER = 0xC038002B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NOTIFICATION_RESET = 0xC038002C,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID = 0xC038002D,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID = 0xC038002E,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_DUPLICATE = 0xC038002F,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_ID_INVALID = 0xC0380030,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_INVALID = 0xC0380031,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_NAME_INVALID = 0xC0380032,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_OFFLINE = 0xC0380033,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_HAS_QUORUM = 0xC0380034,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_WITHOUT_QUORUM = 0xC0380035,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PARTITION_STYLE_INVALID = 0xC0380036,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PARTITION_UPDATE_FAILED = 0xC0380037,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_IN_SYNC = 0xC0380038,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_INDEX_DUPLICATE = 0xC0380039,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_INDEX_INVALID = 0xC038003A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_LAST_ACTIVE = 0xC038003B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_MISSING = 0xC038003C,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_REGENERATING = 0xC038003D,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_TYPE_INVALID = 0xC038003E,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_RAID5 = 0xC038003F,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_SIMPLE = 0xC0380040,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_STRUCTURE_SIZE_INVALID = 0xC0380041,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = 0xC0380042,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_TRANSACTION_IN_PROGRESS = 0xC0380043,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = 0xC0380044,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = 0xC0380045,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_ID_INVALID = 0xC0380046,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_LENGTH_INVALID = 0xC0380047,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = 0xC0380048,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_NOT_MIRRORED = 0xC0380049,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_NOT_RETAINED = 0xC038004A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_OFFLINE = 0xC038004B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_RETAINED = 0xC038004C,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID = 0xC038004D,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE = 0xC038004E,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_BAD_BOOT_DISK = 0xC038004F,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_OFFLINE = 0xC0380050,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_ONLINE = 0xC0380051,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NOT_PRIMARY_PACK = 0xC0380052,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED = 0xC0380053,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = 0xC0380054,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = 0xC0380055,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_MIRRORED = 0xC0380056,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = 0xC0380057,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_VALID_LOG_COPIES = 0xC0380058,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_PRIMARY_PACK_PRESENT = 0xC0380059,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID = 0xC038005A,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = 0xC038005B,
-  MD_NTSTATUS_WIN_STATUS_VOLMGR_RAID5_NOT_SUPPORTED = 0xC038005C,
-  MD_NTSTATUS_WIN_STATUS_BCD_TOO_MANY_ELEMENTS = 0xC0390002,
-  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_MISSING = 0xC03A0001,
-  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = 0xC03A0002,
-  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_CORRUPT = 0xC03A0003,
-  MD_NTSTATUS_WIN_STATUS_VHD_FORMAT_UNKNOWN = 0xC03A0004,
-  MD_NTSTATUS_WIN_STATUS_VHD_FORMAT_UNSUPPORTED_VERSION = 0xC03A0005,
-  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = 0xC03A0006,
-  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = 0xC03A0007,
-  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_CORRUPT = 0xC03A0008,
-  MD_NTSTATUS_WIN_STATUS_VHD_BLOCK_ALLOCATION_FAILURE = 0xC03A0009,
-  MD_NTSTATUS_WIN_STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = 0xC03A000A,
-  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_BLOCK_SIZE = 0xC03A000B,
-  MD_NTSTATUS_WIN_STATUS_VHD_BITMAP_MISMATCH = 0xC03A000C,
-  MD_NTSTATUS_WIN_STATUS_VHD_PARENT_VHD_NOT_FOUND = 0xC03A000D,
-  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_ID_MISMATCH = 0xC03A000E,
-  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = 0xC03A000F,
-  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_READ_FAILURE = 0xC03A0010,
-  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_WRITE_FAILURE = 0xC03A0011,
-  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_SIZE = 0xC03A0012,
-  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_FILE_SIZE = 0xC03A0013,
-  MD_NTSTATUS_WIN_STATUS_VIRTDISK_PROVIDER_NOT_FOUND = 0xC03A0014,
-  MD_NTSTATUS_WIN_STATUS_VIRTDISK_NOT_VIRTUAL_DISK = 0xC03A0015,
-  MD_NTSTATUS_WIN_STATUS_VHD_PARENT_VHD_ACCESS_DENIED = 0xC03A0016,
-  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = 0xC03A0017,
-  MD_NTSTATUS_WIN_STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = 0xC03A0018,
-  MD_NTSTATUS_WIN_STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = 0xC03A0019,
-  MD_NTSTATUS_WIN_STATUS_VIRTUAL_DISK_LIMITATION = 0xC03A001A,
-  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_TYPE = 0xC03A001B,
-  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_STATE = 0xC03A001C,
-  MD_NTSTATUS_WIN_STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = 0xC03A001D,
-  MD_NTSTATUS_WIN_STATUS_VIRTDISK_DISK_ALREADY_OWNED = 0xC03A001E,
-  MD_NTSTATUS_WIN_STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE = 0xC03A001F,
-  MD_NTSTATUS_WIN_STATUS_CTLOG_TRACKING_NOT_INITIALIZED = 0xC03A0020,
-  MD_NTSTATUS_WIN_STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = 0xC03A0021,
-  MD_NTSTATUS_WIN_STATUS_CTLOG_VHD_CHANGED_OFFLINE = 0xC03A0022,
-  MD_NTSTATUS_WIN_STATUS_CTLOG_INVALID_TRACKING_STATE = 0xC03A0023,
-  MD_NTSTATUS_WIN_STATUS_CTLOG_INCONSISTENT_TRACKING_FILE = 0xC03A0024,
-  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_FULL = 0xC03A0028,
-  MD_NTSTATUS_WIN_STATUS_RKF_KEY_NOT_FOUND = 0xC0400001,
-  MD_NTSTATUS_WIN_STATUS_RKF_DUPLICATE_KEY = 0xC0400002,
-  MD_NTSTATUS_WIN_STATUS_RKF_BLOB_FULL = 0xC0400003,
-  MD_NTSTATUS_WIN_STATUS_RKF_STORE_FULL = 0xC0400004,
-  MD_NTSTATUS_WIN_STATUS_RKF_FILE_BLOCKED = 0xC0400005,
-  MD_NTSTATUS_WIN_STATUS_RKF_ACTIVE_KEY = 0xC0400006,
-  MD_NTSTATUS_WIN_STATUS_RDBSS_RESTART_OPERATION = 0xC0410001,
-  MD_NTSTATUS_WIN_STATUS_RDBSS_CONTINUE_OPERATION = 0xC0410002,
-  MD_NTSTATUS_WIN_STATUS_RDBSS_POST_OPERATION = 0xC0410003,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_HANDLE = 0xC0420001,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_READ_NOT_PERMITTED = 0xC0420002,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_WRITE_NOT_PERMITTED = 0xC0420003,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_PDU = 0xC0420004,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION = 0xC0420005,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED = 0xC0420006,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_OFFSET = 0xC0420007,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION = 0xC0420008,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_PREPARE_QUEUE_FULL = 0xC0420009,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND = 0xC042000A,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG = 0xC042000B,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = 0xC042000C,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = 0xC042000D,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNLIKELY = 0xC042000E,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION = 0xC042000F,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE = 0xC0420010,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_RESOURCES = 0xC0420011,
-  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNKNOWN_ERROR = 0xC0421000,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_ROLLBACK_DETECTED = 0xC0430001,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_VIOLATION = 0xC0430002,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_INVALID_POLICY = 0xC0430003,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = 0xC0430004,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_NOT_SIGNED = 0xC0430005,
-  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_FILE_REPLACED = 0xC0430007,
-  MD_NTSTATUS_WIN_STATUS_AUDIO_ENGINE_NODE_NOT_FOUND = 0xC0440001,
-  MD_NTSTATUS_WIN_STATUS_HDAUDIO_EMPTY_CONNECTION_LIST = 0xC0440002,
-  MD_NTSTATUS_WIN_STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = 0xC0440003,
-  MD_NTSTATUS_WIN_STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = 0xC0440004,
-  MD_NTSTATUS_WIN_STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY = 0xC0440005,
-  MD_NTSTATUS_WIN_STATUS_VOLSNAP_BOOTFILE_NOT_VALID = 0xC0500003,
-  MD_NTSTATUS_WIN_STATUS_IO_PREEMPTED = 0xC0510001,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_ERROR_STORED = 0xC05C0000,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_ERROR_NOT_AVAILABLE = 0xC05CFF00,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE = 0xC05CFF01,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = 0xC05CFF02,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = 0xC05CFF03,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = 0xC05CFF04,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = 0xC05CFF05,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = 0xC05CFF06,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_RESERVATION_CONFLICT = 0xC05CFF07,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_WRONG_FILE_TYPE = 0xC05CFF08,
-  MD_NTSTATUS_WIN_STATUS_SVHDX_VERSION_MISMATCH = 0xC05CFF09,
-  MD_NTSTATUS_WIN_STATUS_VHD_SHARED = 0xC05CFF0A,
-  MD_NTSTATUS_WIN_STATUS_SPACES_RESILIENCY_TYPE_INVALID = 0xC0E70003,
-  MD_NTSTATUS_WIN_STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID = 0xC0E70004,
-  MD_NTSTATUS_WIN_STATUS_SPACES_INTERLEAVE_LENGTH_INVALID = 0xC0E70009,
-  MD_NTSTATUS_WIN_STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID = 0xC0E7000A,
-  MD_NTSTATUS_WIN_STATUS_SPACES_NOT_ENOUGH_DRIVES = 0xC0E7000B
-} MDNTStatusCodeWin;
-
-// These constants are defined in the MSDN documentation of
-// the EXCEPTION_RECORD structure.
-typedef enum {
-  MD_ACCESS_VIOLATION_WIN_READ  = 0,
-  MD_ACCESS_VIOLATION_WIN_WRITE = 1,
-  MD_ACCESS_VIOLATION_WIN_EXEC  = 8
-} MDAccessViolationTypeWin;
-
-// These constants are defined in the MSDN documentation of
-// the EXCEPTION_RECORD structure.
-typedef enum {
-  MD_IN_PAGE_ERROR_WIN_READ  = 0,
-  MD_IN_PAGE_ERROR_WIN_WRITE = 1,
-  MD_IN_PAGE_ERROR_WIN_EXEC  = 8
-} MDInPageErrorTypeWin;
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_WIN32_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_format.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_format.h
deleted file mode 100644
index 17a5abba3..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_format.h
+++ /dev/null
@@ -1,972 +0,0 @@
-/* Copyright (c) 2006, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-/* minidump_format.h: A cross-platform reimplementation of minidump-related
- * portions of DbgHelp.h from the Windows Platform SDK.
- *
- * (This is C99 source, please don't corrupt it with C++.)
- *
- * Structures that are defined by Microsoft to contain a zero-length array
- * are instead defined here to contain an array with one element, as
- * zero-length arrays are forbidden by standard C and C++.  In these cases,
- * *_minsize constants are provided to be used in place of sizeof.  For a
- * cleaner interface to these sizes when using C++, see minidump_size.h.
- *
- * These structures are also sufficient to populate minidump files.
- *
- * These definitions may be extended to support handling minidump files
- * for other CPUs and other operating systems.
- *
- * Because precise data type sizes are crucial for this implementation to
- * function properly and portably in terms of interoperability with minidumps
- * produced by DbgHelp on Windows, a set of primitive types with known sizes
- * are used as the basis of each structure defined by this file.  DbgHelp
- * on Windows is assumed to be the reference implementation; this file
- * seeks to provide a cross-platform compatible implementation.  To avoid
- * collisions with the types and values defined and used by DbgHelp in the
- * event that this implementation is used on Windows, each type and value
- * defined here is given a new name, beginning with "MD".  Names of the
- * equivalent types and values in the Windows Platform SDK are given in
- * comments.
- *
- * Author: Mark Mentovai */
-
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_FORMAT_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_FORMAT_H__
-
-#include <stddef.h>
-
-#include "google_breakpad/common/breakpad_types.h"
-
-
-#if defined(_MSC_VER)
-/* Disable "zero-sized array in struct/union" warnings when compiling in
- * MSVC.  DbgHelp.h does this too. */
-#pragma warning(push)
-#pragma warning(disable:4200)
-#endif  /* _MSC_VER */
-
-
-/*
- * guiddef.h
- */
-
-typedef struct {
-  uint32_t data1;
-  uint16_t data2;
-  uint16_t data3;
-  uint8_t  data4[8];
-} MDGUID;  /* GUID */
-
-
-/*
- * WinNT.h
- */
-
-/* Non-x86 CPU identifiers found in the high 24 bits of
- * (MDRawContext*).context_flags.  These aren't used by Breakpad, but are
- * defined here for reference, to avoid assigning values that conflict
- * (although some values already conflict). */
-#define MD_CONTEXT_IA64  0x00080000  /* CONTEXT_IA64 */
-/* Additional values from winnt.h in the Windows CE 5.0 SDK: */
-#define MD_CONTEXT_SHX   0x000000c0  /* CONTEXT_SH4 (Super-H, includes SH3) */
-#define MD_CONTEXT_ALPHA 0x00020000  /* CONTEXT_ALPHA */
-
-/* As of Windows 7 SP1, the number of flag bits has increased to
- * include 0x40 (CONTEXT_XSTATE):
- * http://msdn.microsoft.com/en-us/library/hh134238%28v=vs.85%29.aspx */
-#define MD_CONTEXT_CPU_MASK 0xffffff00
-
-
-/* This is a base type for MDRawContextX86 and MDRawContextPPC.  This
- * structure should never be allocated directly.  The actual structure type
- * can be determined by examining the context_flags field. */
-typedef struct {
-  uint32_t context_flags;
-} MDRawContextBase;
-
-#include "minidump_cpu_amd64.h"
-#include "minidump_cpu_arm.h"
-#include "minidump_cpu_arm64.h"
-#include "minidump_cpu_mips.h"
-#include "minidump_cpu_ppc.h"
-#include "minidump_cpu_ppc64.h"
-#include "minidump_cpu_sparc.h"
-#include "minidump_cpu_x86.h"
-
-/*
- * WinVer.h
- */
-
-
-typedef struct {
-  uint32_t signature;
-  uint32_t struct_version;
-  uint32_t file_version_hi;
-  uint32_t file_version_lo;
-  uint32_t product_version_hi;
-  uint32_t product_version_lo;
-  uint32_t file_flags_mask;    /* Identifies valid bits in fileFlags */
-  uint32_t file_flags;
-  uint32_t file_os;
-  uint32_t file_type;
-  uint32_t file_subtype;
-  uint32_t file_date_hi;
-  uint32_t file_date_lo;
-} MDVSFixedFileInfo;  /* VS_FIXEDFILEINFO */
-
-/* For (MDVSFixedFileInfo).signature */
-#define MD_VSFIXEDFILEINFO_SIGNATURE 0xfeef04bd
-     /* VS_FFI_SIGNATURE */
-
-/* For (MDVSFixedFileInfo).version */
-#define MD_VSFIXEDFILEINFO_VERSION 0x00010000
-     /* VS_FFI_STRUCVERSION */
-
-/* For (MDVSFixedFileInfo).file_flags_mask and
- * (MDVSFixedFileInfo).file_flags */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_DEBUG        0x00000001
-     /* VS_FF_DEBUG */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_PRERELEASE   0x00000002
-     /* VS_FF_PRERELEASE */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_PATCHED      0x00000004
-     /* VS_FF_PATCHED */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_PRIVATEBUILD 0x00000008
-     /* VS_FF_PRIVATEBUILD */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_INFOINFERRED 0x00000010
-     /* VS_FF_INFOINFERRED */
-#define MD_VSFIXEDFILEINFO_FILE_FLAGS_SPECIALBUILD 0x00000020
-     /* VS_FF_SPECIALBUILD */
-
-/* For (MDVSFixedFileInfo).file_os: high 16 bits */
-#define MD_VSFIXEDFILEINFO_FILE_OS_UNKNOWN    0          /* VOS_UNKNOWN */
-#define MD_VSFIXEDFILEINFO_FILE_OS_DOS        (1 << 16)  /* VOS_DOS */
-#define MD_VSFIXEDFILEINFO_FILE_OS_OS216      (2 << 16)  /* VOS_OS216 */
-#define MD_VSFIXEDFILEINFO_FILE_OS_OS232      (3 << 16)  /* VOS_OS232 */
-#define MD_VSFIXEDFILEINFO_FILE_OS_NT         (4 << 16)  /* VOS_NT */
-#define MD_VSFIXEDFILEINFO_FILE_OS_WINCE      (5 << 16)  /* VOS_WINCE */
-/* Low 16 bits */
-#define MD_VSFIXEDFILEINFO_FILE_OS__BASE      0          /* VOS__BASE */
-#define MD_VSFIXEDFILEINFO_FILE_OS__WINDOWS16 1          /* VOS__WINDOWS16 */
-#define MD_VSFIXEDFILEINFO_FILE_OS__PM16      2          /* VOS__PM16 */
-#define MD_VSFIXEDFILEINFO_FILE_OS__PM32      3          /* VOS__PM32 */
-#define MD_VSFIXEDFILEINFO_FILE_OS__WINDOWS32 4          /* VOS__WINDOWS32 */
-
-/* For (MDVSFixedFileInfo).file_type */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_UNKNOWN    0  /* VFT_UNKNOWN */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_APP        1  /* VFT_APP */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_DLL        2  /* VFT_DLL */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_DRV        3  /* VFT_DLL */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_FONT       4  /* VFT_FONT */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_VXD        5  /* VFT_VXD */
-#define MD_VSFIXEDFILEINFO_FILE_TYPE_STATIC_LIB 7  /* VFT_STATIC_LIB */
-
-/* For (MDVSFixedFileInfo).file_subtype */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_UNKNOWN                0
-     /* VFT2_UNKNOWN */
-/* with file_type = MD_VSFIXEDFILEINFO_FILETYPE_DRV */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_PRINTER            1
-     /* VFT2_DRV_PRINTER */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_KEYBOARD           2
-     /* VFT2_DRV_KEYBOARD */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_LANGUAGE           3
-     /* VFT2_DRV_LANGUAGE */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_DISPLAY            4
-     /* VFT2_DRV_DISPLAY */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_MOUSE              5
-     /* VFT2_DRV_MOUSE */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_NETWORK            6
-     /* VFT2_DRV_NETWORK */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_SYSTEM             7
-     /* VFT2_DRV_SYSTEM */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_INSTALLABLE        8
-     /* VFT2_DRV_INSTALLABLE */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_SOUND              9
-     /* VFT2_DRV_SOUND */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_COMM              10
-     /* VFT2_DRV_COMM */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_INPUTMETHOD       11
-     /* VFT2_DRV_INPUTMETHOD */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_DRV_VERSIONED_PRINTER 12
-     /* VFT2_DRV_VERSIONED_PRINTER */
-/* with file_type = MD_VSFIXEDFILEINFO_FILETYPE_FONT */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_FONT_RASTER            1
-     /* VFT2_FONT_RASTER */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_FONT_VECTOR            2
-     /* VFT2_FONT_VECTOR */
-#define MD_VSFIXEDFILEINFO_FILE_SUBTYPE_FONT_TRUETYPE          3
-     /* VFT2_FONT_TRUETYPE */
-
-
-/*
- * DbgHelp.h
- */
-
-
-/* An MDRVA is an offset into the minidump file.  The beginning of the
- * MDRawHeader is at offset 0. */
-typedef uint32_t MDRVA;  /* RVA */
-
-typedef struct {
-  uint32_t  data_size;
-  MDRVA     rva;
-} MDLocationDescriptor;  /* MINIDUMP_LOCATION_DESCRIPTOR */
-
-
-typedef struct {
-  /* The base address of the memory range on the host that produced the
-   * minidump. */
-  uint64_t             start_of_memory_range;
-
-  MDLocationDescriptor memory;
-} MDMemoryDescriptor;  /* MINIDUMP_MEMORY_DESCRIPTOR */
-
-
-typedef struct {
-  uint32_t  signature;
-  uint32_t  version;
-  uint32_t  stream_count;
-  MDRVA     stream_directory_rva;  /* A |stream_count|-sized array of
-                                    * MDRawDirectory structures. */
-  uint32_t  checksum;              /* Can be 0.  In fact, that's all that's
-                                    * been found in minidump files. */
-  uint32_t  time_date_stamp;       /* time_t */
-  uint64_t  flags;
-} MDRawHeader;  /* MINIDUMP_HEADER */
-
-/* For (MDRawHeader).signature and (MDRawHeader).version.  Note that only the
- * low 16 bits of (MDRawHeader).version are MD_HEADER_VERSION.  Per the
- * documentation, the high 16 bits are implementation-specific. */
-#define MD_HEADER_SIGNATURE 0x504d444d /* 'PMDM' */
-     /* MINIDUMP_SIGNATURE */
-#define MD_HEADER_VERSION   0x0000a793 /* 42899 */
-     /* MINIDUMP_VERSION */
-
-/* For (MDRawHeader).flags: */
-typedef enum {
-  /* MD_NORMAL is the standard type of minidump.  It includes full
-   * streams for the thread list, module list, exception, system info,
-   * and miscellaneous info.  A memory list stream is also present,
-   * pointing to the same stack memory contained in the thread list,
-   * as well as a 256-byte region around the instruction address that
-   * was executing when the exception occurred.  Stack memory is from
-   * 4 bytes below a thread's stack pointer up to the top of the
-   * memory region encompassing the stack. */
-  MD_NORMAL                            = 0x00000000,
-  MD_WITH_DATA_SEGS                    = 0x00000001,
-  MD_WITH_FULL_MEMORY                  = 0x00000002,
-  MD_WITH_HANDLE_DATA                  = 0x00000004,
-  MD_FILTER_MEMORY                     = 0x00000008,
-  MD_SCAN_MEMORY                       = 0x00000010,
-  MD_WITH_UNLOADED_MODULES             = 0x00000020,
-  MD_WITH_INDIRECTLY_REFERENCED_MEMORY = 0x00000040,
-  MD_FILTER_MODULE_PATHS               = 0x00000080,
-  MD_WITH_PROCESS_THREAD_DATA          = 0x00000100,
-  MD_WITH_PRIVATE_READ_WRITE_MEMORY    = 0x00000200,
-  MD_WITHOUT_OPTIONAL_DATA             = 0x00000400,
-  MD_WITH_FULL_MEMORY_INFO             = 0x00000800,
-  MD_WITH_THREAD_INFO                  = 0x00001000,
-  MD_WITH_CODE_SEGS                    = 0x00002000,
-  MD_WITHOUT_AUXILLIARY_SEGS           = 0x00004000,
-  MD_WITH_FULL_AUXILLIARY_STATE        = 0x00008000,
-  MD_WITH_PRIVATE_WRITE_COPY_MEMORY    = 0x00010000,
-  MD_IGNORE_INACCESSIBLE_MEMORY        = 0x00020000,
-  MD_WITH_TOKEN_INFORMATION            = 0x00040000
-} MDType;  /* MINIDUMP_TYPE */
-
-
-typedef struct {
-  uint32_t             stream_type;
-  MDLocationDescriptor location;
-} MDRawDirectory;  /* MINIDUMP_DIRECTORY */
-
-/* For (MDRawDirectory).stream_type */
-typedef enum {
-  MD_UNUSED_STREAM               =  0,
-  MD_RESERVED_STREAM_0           =  1,
-  MD_RESERVED_STREAM_1           =  2,
-  MD_THREAD_LIST_STREAM          =  3,  /* MDRawThreadList */
-  MD_MODULE_LIST_STREAM          =  4,  /* MDRawModuleList */
-  MD_MEMORY_LIST_STREAM          =  5,  /* MDRawMemoryList */
-  MD_EXCEPTION_STREAM            =  6,  /* MDRawExceptionStream */
-  MD_SYSTEM_INFO_STREAM          =  7,  /* MDRawSystemInfo */
-  MD_THREAD_EX_LIST_STREAM       =  8,
-  MD_MEMORY_64_LIST_STREAM       =  9,
-  MD_COMMENT_STREAM_A            = 10,
-  MD_COMMENT_STREAM_W            = 11,
-  MD_HANDLE_DATA_STREAM          = 12,
-  MD_FUNCTION_TABLE_STREAM       = 13,
-  MD_UNLOADED_MODULE_LIST_STREAM = 14,
-  MD_MISC_INFO_STREAM            = 15,  /* MDRawMiscInfo */
-  MD_MEMORY_INFO_LIST_STREAM     = 16,  /* MDRawMemoryInfoList */
-  MD_THREAD_INFO_LIST_STREAM     = 17,
-  MD_HANDLE_OPERATION_LIST_STREAM = 18,
-  MD_LAST_RESERVED_STREAM        = 0x0000ffff,
-
-  /* Breakpad extension types.  0x4767 = "Gg" */
-  MD_BREAKPAD_INFO_STREAM        = 0x47670001,  /* MDRawBreakpadInfo  */
-  MD_ASSERTION_INFO_STREAM       = 0x47670002,  /* MDRawAssertionInfo */
-  /* These are additional minidump stream values which are specific to
-   * the linux breakpad implementation. */
-  MD_LINUX_CPU_INFO              = 0x47670003,  /* /proc/cpuinfo      */
-  MD_LINUX_PROC_STATUS           = 0x47670004,  /* /proc/$x/status    */
-  MD_LINUX_LSB_RELEASE           = 0x47670005,  /* /etc/lsb-release   */
-  MD_LINUX_CMD_LINE              = 0x47670006,  /* /proc/$x/cmdline   */
-  MD_LINUX_ENVIRON               = 0x47670007,  /* /proc/$x/environ   */
-  MD_LINUX_AUXV                  = 0x47670008,  /* /proc/$x/auxv      */
-  MD_LINUX_MAPS                  = 0x47670009,  /* /proc/$x/maps      */
-  MD_LINUX_DSO_DEBUG             = 0x4767000A   /* MDRawDebug{32,64}  */
-} MDStreamType;  /* MINIDUMP_STREAM_TYPE */
-
-
-typedef struct {
-  uint32_t length;     /* Length of buffer in bytes (not characters),
-                        * excluding 0-terminator */
-  uint16_t buffer[1];  /* UTF-16-encoded, 0-terminated */
-} MDString;  /* MINIDUMP_STRING */
-
-static const size_t MDString_minsize = offsetof(MDString, buffer[0]);
-
-
-typedef struct {
-  uint32_t             thread_id;
-  uint32_t             suspend_count;
-  uint32_t             priority_class;
-  uint32_t             priority;
-  uint64_t             teb;             /* Thread environment block */
-  MDMemoryDescriptor   stack;
-  MDLocationDescriptor thread_context;  /* MDRawContext[CPU] */
-} MDRawThread;  /* MINIDUMP_THREAD */
-
-
-typedef struct {
-  uint32_t    number_of_threads;
-  MDRawThread threads[1];
-} MDRawThreadList;  /* MINIDUMP_THREAD_LIST */
-
-static const size_t MDRawThreadList_minsize = offsetof(MDRawThreadList,
-                                                       threads[0]);
-
-
-typedef struct {
-  uint64_t             base_of_image;
-  uint32_t             size_of_image;
-  uint32_t             checksum;         /* 0 if unknown */
-  uint32_t             time_date_stamp;  /* time_t */
-  MDRVA                module_name_rva;  /* MDString, pathname or filename */
-  MDVSFixedFileInfo    version_info;
-
-  /* The next field stores a CodeView record and is populated when a module's
-   * debug information resides in a PDB file.  It identifies the PDB file. */
-  MDLocationDescriptor cv_record;
-
-  /* The next field is populated when a module's debug information resides
-   * in a DBG file.  It identifies the DBG file.  This field is effectively
-   * obsolete with modules built by recent toolchains. */
-  MDLocationDescriptor misc_record;
-
-  /* Alignment problem: reserved0 and reserved1 are defined by the platform
-   * SDK as 64-bit quantities.  However, that results in a structure whose
-   * alignment is unpredictable on different CPUs and ABIs.  If the ABI
-   * specifies full alignment of 64-bit quantities in structures (as ppc
-   * does), there will be padding between miscRecord and reserved0.  If
-   * 64-bit quantities can be aligned on 32-bit boundaries (as on x86),
-   * this padding will not exist.  (Note that the structure up to this point
-   * contains 1 64-bit member followed by 21 32-bit members.)
-   * As a workaround, reserved0 and reserved1 are instead defined here as
-   * four 32-bit quantities.  This should be harmless, as there are
-   * currently no known uses for these fields. */
-  uint32_t             reserved0[2];
-  uint32_t             reserved1[2];
-} MDRawModule;  /* MINIDUMP_MODULE */
-
-/* The inclusion of a 64-bit type in MINIDUMP_MODULE forces the struct to
- * be tail-padded out to a multiple of 64 bits under some ABIs (such as PPC).
- * This doesn't occur on systems that don't tail-pad in this manner.  Define
- * this macro to be the usable size of the MDRawModule struct, and use it in
- * place of sizeof(MDRawModule). */
-#define MD_MODULE_SIZE 108
-
-
-/* (MDRawModule).cv_record can reference MDCVInfoPDB20 or MDCVInfoPDB70.
- * Ref.: http://www.debuginfo.com/articles/debuginfomatch.html
- * MDCVInfoPDB70 is the expected structure type with recent toolchains. */
-
-typedef struct {
-  uint32_t signature;
-  uint32_t offset;     /* Offset to debug data (expect 0 in minidump) */
-} MDCVHeader;
-
-typedef struct {
-  MDCVHeader cv_header;
-  uint32_t   signature;         /* time_t debug information created */
-  uint32_t   age;               /* revision of PDB file */
-  uint8_t    pdb_file_name[1];  /* Pathname or filename of PDB file */
-} MDCVInfoPDB20;
-
-static const size_t MDCVInfoPDB20_minsize = offsetof(MDCVInfoPDB20,
-                                                     pdb_file_name[0]);
-
-#define MD_CVINFOPDB20_SIGNATURE 0x3031424e  /* cvHeader.signature = '01BN' */
-
-typedef struct {
-  uint32_t  cv_signature;
-  MDGUID    signature;         /* GUID, identifies PDB file */
-  uint32_t  age;               /* Identifies incremental changes to PDB file */
-  uint8_t   pdb_file_name[1];  /* Pathname or filename of PDB file,
-                                * 0-terminated 8-bit character data (UTF-8?) */
-} MDCVInfoPDB70;
-
-static const size_t MDCVInfoPDB70_minsize = offsetof(MDCVInfoPDB70,
-                                                     pdb_file_name[0]);
-
-#define MD_CVINFOPDB70_SIGNATURE 0x53445352  /* cvSignature = 'SDSR' */
-
-typedef struct {
-  uint32_t data1[2];
-  uint32_t data2;
-  uint32_t data3;
-  uint32_t data4;
-  uint32_t data5[3];
-  uint8_t  extra[2];
-} MDCVInfoELF;
-
-/* In addition to the two CodeView record formats above, used for linking
- * to external pdb files, it is possible for debugging data to be carried
- * directly in the CodeView record itself.  These signature values will
- * be found in the first 4 bytes of the CodeView record.  Additional values
- * not commonly experienced in the wild are given by "Microsoft Symbol and
- * Type Information", http://www.x86.org/ftp/manuals/tools/sym.pdf, section
- * 7.2.  An in-depth description of the CodeView 4.1 format is given by
- * "Undocumented Windows 2000 Secrets", Windows 2000 Debugging Support/
- * Microsoft Symbol File Internals/CodeView Subsections,
- * http://www.rawol.com/features/undocumented/sbs-w2k-1-windows-2000-debugging-support.pdf
- */
-#define MD_CVINFOCV41_SIGNATURE 0x3930424e  /* '90BN', CodeView 4.10. */
-#define MD_CVINFOCV50_SIGNATURE 0x3131424e  /* '11BN', CodeView 5.0,
-                                             * MS C7-format (/Z7). */
-
-#define MD_CVINFOUNKNOWN_SIGNATURE 0xffffffff  /* An unlikely value. */
-
-/* (MDRawModule).miscRecord can reference MDImageDebugMisc.  The Windows
- * structure is actually defined in WinNT.h.  This structure is effectively
- * obsolete with modules built by recent toolchains. */
-
-typedef struct {
-  uint32_t  data_type;    /* IMAGE_DEBUG_TYPE_*, not defined here because
-                           * this debug record type is mostly obsolete. */
-  uint32_t  length;       /* Length of entire MDImageDebugMisc structure */
-  uint8_t   unicode;      /* True if data is multibyte */
-  uint8_t   reserved[3];
-  uint8_t   data[1];
-} MDImageDebugMisc;  /* IMAGE_DEBUG_MISC */
-
-static const size_t MDImageDebugMisc_minsize = offsetof(MDImageDebugMisc,
-                                                        data[0]);
-
-
-typedef struct {
-  uint32_t    number_of_modules;
-  MDRawModule modules[1];
-} MDRawModuleList;  /* MINIDUMP_MODULE_LIST */
-
-static const size_t MDRawModuleList_minsize = offsetof(MDRawModuleList,
-                                                       modules[0]);
-
-
-typedef struct {
-  uint32_t           number_of_memory_ranges;
-  MDMemoryDescriptor memory_ranges[1];
-} MDRawMemoryList;  /* MINIDUMP_MEMORY_LIST */
-
-static const size_t MDRawMemoryList_minsize = offsetof(MDRawMemoryList,
-                                                       memory_ranges[0]);
-
-
-#define MD_EXCEPTION_MAXIMUM_PARAMETERS 15
-
-typedef struct {
-  uint32_t  exception_code;     /* Windows: MDExceptionCodeWin,
-                                 * Mac OS X: MDExceptionMac,
-                                 * Linux: MDExceptionCodeLinux. */
-  uint32_t  exception_flags;    /* Windows: 1 if noncontinuable,
-                                   Mac OS X: MDExceptionCodeMac. */
-  uint64_t  exception_record;   /* Address (in the minidump-producing host's
-                                 * memory) of another MDException, for
-                                 * nested exceptions. */
-  uint64_t  exception_address;  /* The address that caused the exception.
-                                 * Mac OS X: exception subcode (which is
-                                 *           typically the address). */
-  uint32_t  number_parameters;  /* Number of valid elements in
-                                 * exception_information. */
-  uint32_t  __align;
-  uint64_t  exception_information[MD_EXCEPTION_MAXIMUM_PARAMETERS];
-} MDException;  /* MINIDUMP_EXCEPTION */
-
-#include "minidump_exception_linux.h"
-#include "minidump_exception_mac.h"
-#include "minidump_exception_ps3.h"
-#include "minidump_exception_solaris.h"
-#include "minidump_exception_win32.h"
-
-typedef struct {
-  uint32_t             thread_id;         /* Thread in which the exception
-                                           * occurred.  Corresponds to
-                                           * (MDRawThread).thread_id. */
-  uint32_t             __align;
-  MDException          exception_record;
-  MDLocationDescriptor thread_context;    /* MDRawContext[CPU] */
-} MDRawExceptionStream;  /* MINIDUMP_EXCEPTION_STREAM */
-
-
-typedef union {
-  struct {
-    uint32_t vendor_id[3];               /* cpuid 0: ebx, edx, ecx */
-    uint32_t version_information;        /* cpuid 1: eax */
-    uint32_t feature_information;        /* cpuid 1: edx */
-    uint32_t amd_extended_cpu_features;  /* cpuid 0x80000001, ebx */
-  } x86_cpu_info;
-  struct {
-    uint32_t cpuid;
-    uint32_t elf_hwcaps;    /* linux specific, 0 otherwise */
-  } arm_cpu_info;
-  struct {
-    uint64_t processor_features[2];
-  } other_cpu_info;
-} MDCPUInformation;  /* CPU_INFORMATION */
-
-/* For (MDCPUInformation).arm_cpu_info.elf_hwcaps.
- * This matches the Linux kernel definitions from <asm/hwcaps.h> */
-typedef enum {
-  MD_CPU_ARM_ELF_HWCAP_SWP       = (1 << 0),
-  MD_CPU_ARM_ELF_HWCAP_HALF      = (1 << 1),
-  MD_CPU_ARM_ELF_HWCAP_THUMB     = (1 << 2),
-  MD_CPU_ARM_ELF_HWCAP_26BIT     = (1 << 3),
-  MD_CPU_ARM_ELF_HWCAP_FAST_MULT = (1 << 4),
-  MD_CPU_ARM_ELF_HWCAP_FPA       = (1 << 5),
-  MD_CPU_ARM_ELF_HWCAP_VFP       = (1 << 6),
-  MD_CPU_ARM_ELF_HWCAP_EDSP      = (1 << 7),
-  MD_CPU_ARM_ELF_HWCAP_JAVA      = (1 << 8),
-  MD_CPU_ARM_ELF_HWCAP_IWMMXT    = (1 << 9),
-  MD_CPU_ARM_ELF_HWCAP_CRUNCH    = (1 << 10),
-  MD_CPU_ARM_ELF_HWCAP_THUMBEE   = (1 << 11),
-  MD_CPU_ARM_ELF_HWCAP_NEON      = (1 << 12),
-  MD_CPU_ARM_ELF_HWCAP_VFPv3     = (1 << 13),
-  MD_CPU_ARM_ELF_HWCAP_VFPv3D16  = (1 << 14),
-  MD_CPU_ARM_ELF_HWCAP_TLS       = (1 << 15),
-  MD_CPU_ARM_ELF_HWCAP_VFPv4     = (1 << 16),
-  MD_CPU_ARM_ELF_HWCAP_IDIVA     = (1 << 17),
-  MD_CPU_ARM_ELF_HWCAP_IDIVT     = (1 << 18),
-} MDCPUInformationARMElfHwCaps;
-
-typedef struct {
-  /* The next 3 fields and numberOfProcessors are from the SYSTEM_INFO
-   * structure as returned by GetSystemInfo */
-  uint16_t         processor_architecture;
-  uint16_t         processor_level;         /* x86: 5 = 586, 6 = 686, ... */
-                                            /* ARM: 6 = ARMv6, 7 = ARMv7 ... */
-  uint16_t         processor_revision;      /* x86: 0xMMSS, where MM=model,
-                                             *      SS=stepping */
-                                            /* ARM: 0 */
-
-  uint8_t          number_of_processors;
-  uint8_t          product_type;            /* Windows: VER_NT_* from WinNT.h */
-
-  /* The next 5 fields are from the OSVERSIONINFO structure as returned
-   * by GetVersionEx */
-  uint32_t         major_version;
-  uint32_t         minor_version;
-  uint32_t         build_number;
-  uint32_t         platform_id;
-  MDRVA            csd_version_rva;  /* MDString further identifying the
-                                      * host OS.
-                                      * Windows: name of the installed OS
-                                      *          service pack.
-                                      * Mac OS X: the Apple OS build number
-                                      *           (sw_vers -buildVersion).
-                                      * Linux: uname -srvmo */
-
-  uint16_t         suite_mask;       /* Windows: VER_SUITE_* from WinNT.h */
-  uint16_t         reserved2;
-
-  MDCPUInformation cpu;
-} MDRawSystemInfo;  /* MINIDUMP_SYSTEM_INFO */
-
-/* For (MDRawSystemInfo).processor_architecture: */
-typedef enum {
-  MD_CPU_ARCHITECTURE_X86       =  0,  /* PROCESSOR_ARCHITECTURE_INTEL */
-  MD_CPU_ARCHITECTURE_MIPS      =  1,  /* PROCESSOR_ARCHITECTURE_MIPS */
-  MD_CPU_ARCHITECTURE_ALPHA     =  2,  /* PROCESSOR_ARCHITECTURE_ALPHA */
-  MD_CPU_ARCHITECTURE_PPC       =  3,  /* PROCESSOR_ARCHITECTURE_PPC */
-  MD_CPU_ARCHITECTURE_SHX       =  4,  /* PROCESSOR_ARCHITECTURE_SHX
-                                        * (Super-H) */
-  MD_CPU_ARCHITECTURE_ARM       =  5,  /* PROCESSOR_ARCHITECTURE_ARM */
-  MD_CPU_ARCHITECTURE_IA64      =  6,  /* PROCESSOR_ARCHITECTURE_IA64 */
-  MD_CPU_ARCHITECTURE_ALPHA64   =  7,  /* PROCESSOR_ARCHITECTURE_ALPHA64 */
-  MD_CPU_ARCHITECTURE_MSIL      =  8,  /* PROCESSOR_ARCHITECTURE_MSIL
-                                        * (Microsoft Intermediate Language) */
-  MD_CPU_ARCHITECTURE_AMD64     =  9,  /* PROCESSOR_ARCHITECTURE_AMD64 */
-  MD_CPU_ARCHITECTURE_X86_WIN64 = 10,
-      /* PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 (WoW64) */
-  MD_CPU_ARCHITECTURE_SPARC     = 0x8001, /* Breakpad-defined value for SPARC */
-  MD_CPU_ARCHITECTURE_PPC64     = 0x8002, /* Breakpad-defined value for PPC64 */
-  MD_CPU_ARCHITECTURE_ARM64     = 0x8003, /* Breakpad-defined value for ARM64 */
-  MD_CPU_ARCHITECTURE_UNKNOWN   = 0xffff  /* PROCESSOR_ARCHITECTURE_UNKNOWN */
-} MDCPUArchitecture;
-
-/* For (MDRawSystemInfo).platform_id: */
-typedef enum {
-  MD_OS_WIN32S        = 0,  /* VER_PLATFORM_WIN32s (Windows 3.1) */
-  MD_OS_WIN32_WINDOWS = 1,  /* VER_PLATFORM_WIN32_WINDOWS (Windows 95-98-Me) */
-  MD_OS_WIN32_NT      = 2,  /* VER_PLATFORM_WIN32_NT (Windows NT, 2000+) */
-  MD_OS_WIN32_CE      = 3,  /* VER_PLATFORM_WIN32_CE, VER_PLATFORM_WIN32_HH
-                             * (Windows CE, Windows Mobile, "Handheld") */
-
-  /* The following values are Breakpad-defined. */
-  MD_OS_UNIX          = 0x8000,  /* Generic Unix-ish */
-  MD_OS_MAC_OS_X      = 0x8101,  /* Mac OS X/Darwin */
-  MD_OS_IOS           = 0x8102,  /* iOS */
-  MD_OS_LINUX         = 0x8201,  /* Linux */
-  MD_OS_SOLARIS       = 0x8202,  /* Solaris */
-  MD_OS_ANDROID       = 0x8203,  /* Android */
-  MD_OS_PS3           = 0x8204,  /* PS3 */
-  MD_OS_NACL          = 0x8205   /* Native Client (NaCl) */
-} MDOSPlatform;
-
-typedef struct {
-  uint16_t year;
-  uint16_t month;
-  uint16_t day_of_week;
-  uint16_t day;
-  uint16_t hour;
-  uint16_t minute;
-  uint16_t second;
-  uint16_t milliseconds;
-} MDSystemTime;  /* SYSTEMTIME */
-
-typedef struct {
-  /* Required field.  The bias is the difference, in minutes, between
-   * Coordinated Universal Time (UTC) and local time.
-   *   Formula: UTC = local time + bias */
-  int32_t bias;
-  /* A description for standard time.  For example, "EST" could indicate Eastern
-   * Standard Time.  In practice this contains the full time zone names.  This
-   * string can be empty. */
-  uint16_t standard_name[32];  /* UTF-16-encoded, 0-terminated */
-  /* A MDSystemTime structure that contains a date and local time when the
-   * transition from daylight saving time to standard time occurs on this
-   * operating system.  If the time zone does not support daylight saving time, 
-   * the month member in the MDSystemTime structure is zero. */
-  MDSystemTime standard_date;
-  /* The bias value to be used during local time translations that occur during
-   * standard time. */
-  int32_t standard_bias;
-  /* A description for daylight saving time.  For example, "PDT" could indicate
-   * Pacific Daylight Time.  In practice this contains the full time zone names.
-   * This string can be empty. */
-  uint16_t daylight_name[32];  /* UTF-16-encoded, 0-terminated */
-  /* A MDSystemTime structure that contains a date and local time when the
-   * transition from standard time to daylight saving time occurs on this
-   * operating system.  If the time zone does not support daylight saving time, 
-   * the month member in the MDSystemTime structure is zero.*/
-  MDSystemTime daylight_date;
-  /* The bias value to be used during local time translations that occur during
-   * daylight saving time. */
-  int32_t daylight_bias;
-} MDTimeZoneInformation;  /* TIME_ZONE_INFORMATION */
-
-/* MAX_PATH from windef.h */
-#define MD_MAX_PATH 260
-
-/* The miscellaneous information stream contains a variety
- * of small pieces of information.  A member is valid if
- * it's within the available size and its corresponding
- * bit is set. */
-typedef struct {
-  uint32_t size_of_info;  /* Length of entire MDRawMiscInfo structure. */
-  uint32_t flags1;
-
-  /* The next field is only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_PROCESS_ID. */
-  uint32_t process_id;
-
-  /* The next 3 fields are only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_PROCESS_TIMES. */
-  uint32_t process_create_time;  /* time_t process started */
-  uint32_t process_user_time;    /* seconds of user CPU time */
-  uint32_t process_kernel_time;  /* seconds of kernel CPU time */
-
-  /* The following fields are not present in MINIDUMP_MISC_INFO but are
-   * in MINIDUMP_MISC_INFO_2.  When this struct is populated, these values
-   * may not be set.  Use flags1 and size_of_info to determine whether these
-   * values are present.  These are only valid when flags1 contains
-   * MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO. */
-  uint32_t processor_max_mhz;
-  uint32_t processor_current_mhz;
-  uint32_t processor_mhz_limit;
-  uint32_t processor_max_idle_state;
-  uint32_t processor_current_idle_state;
-
-  /* The following fields are not present in MINIDUMP_MISC_INFO_2 but are
-   * in MINIDUMP_MISC_INFO_3.  When this struct is populated, these values
-   * may not be set.  Use flags1 and size_of_info to determine whether these
-   * values are present. */
-   
-  /* The following field is only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_PROCESS_INTEGRITY. */
-  uint32_t process_integrity_level;
-
-  /* The following field is only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_PROCESS_EXECUTE_FLAGS. */
-  uint32_t process_execute_flags;
-
-  /* The following field is only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_PROTECTED_PROCESS. */
-  uint32_t protected_process;
-
-  /* The following 2 fields are only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_TIMEZONE. */
-  uint32_t time_zone_id;
-  MDTimeZoneInformation time_zone;
-
-  /* The following fields are not present in MINIDUMP_MISC_INFO_3 but are
-   * in MINIDUMP_MISC_INFO_4.  When this struct is populated, these values
-   * may not be set.  Use flags1 and size_of_info to determine whether these
-   * values are present. */
-
-  /* The following 2 fields are only valid if flags1 contains
-   * MD_MISCINFO_FLAGS1_BUILDSTRING. */
-  uint16_t build_string[MD_MAX_PATH];  /* UTF-16-encoded, 0-terminated */
-  uint16_t dbg_bld_str[40];            /* UTF-16-encoded, 0-terminated */
-} MDRawMiscInfo;  /* MINIDUMP_MISC_INFO, MINIDUMP_MISC_INFO_2,
-                   * MINIDUMP_MISC_INFO_3, MINIDUMP_MISC_INFO_4,
-                   * MINIDUMP_MISC_INFO_N */
-
-static const size_t MD_MISCINFO_SIZE =
-    offsetof(MDRawMiscInfo, processor_max_mhz);
-static const size_t MD_MISCINFO2_SIZE =
-    offsetof(MDRawMiscInfo, process_integrity_level);
-static const size_t MD_MISCINFO3_SIZE =
-    offsetof(MDRawMiscInfo, build_string[0]);
-static const size_t MD_MISCINFO4_SIZE = sizeof(MDRawMiscInfo);
-
-/* For (MDRawMiscInfo).flags1.  These values indicate which fields in the
- * MDRawMiscInfoStructure are valid. */
-typedef enum {
-  MD_MISCINFO_FLAGS1_PROCESS_ID            = 0x00000001,
-      /* MINIDUMP_MISC1_PROCESS_ID */
-  MD_MISCINFO_FLAGS1_PROCESS_TIMES         = 0x00000002,
-      /* MINIDUMP_MISC1_PROCESS_TIMES */
-  MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO  = 0x00000004,
-      /* MINIDUMP_MISC1_PROCESSOR_POWER_INFO */
-  MD_MISCINFO_FLAGS1_PROCESS_INTEGRITY     = 0x00000010,
-      /* MINIDUMP_MISC3_PROCESS_INTEGRITY */
-  MD_MISCINFO_FLAGS1_PROCESS_EXECUTE_FLAGS = 0x00000020,
-      /* MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS */
-  MD_MISCINFO_FLAGS1_TIMEZONE              = 0x00000040,
-      /* MINIDUMP_MISC3_TIMEZONE */
-  MD_MISCINFO_FLAGS1_PROTECTED_PROCESS     = 0x00000080,
-      /* MINIDUMP_MISC3_PROTECTED_PROCESS */
-  MD_MISCINFO_FLAGS1_BUILDSTRING           = 0x00000100,
-      /* MINIDUMP_MISC4_BUILDSTRING */
-} MDMiscInfoFlags1;
-
-/*
- * Around DbgHelp version 6.0, the style of new LIST structures changed
- * from including an array of length 1 at the end of the struct to
- * represent the variable-length data to including explicit
- * "size of header", "size of entry" and "number of entries" fields
- * in the header, presumably to allow backwards-compatibly-extending
- * the structures in the future. The actual list entries follow the
- * header data directly in this case.
- */
-
-typedef struct {
-  uint32_t size_of_header;    /* sizeof(MDRawMemoryInfoList) */
-  uint32_t size_of_entry;     /* sizeof(MDRawMemoryInfo) */
-  uint64_t number_of_entries;
-} MDRawMemoryInfoList;  /* MINIDUMP_MEMORY_INFO_LIST */
-
-typedef struct {
-  uint64_t  base_address;           /* Base address of a region of pages */
-  uint64_t  allocation_base;        /* Base address of a range of pages
-                                     * within this region. */
-  uint32_t  allocation_protection;  /* Memory protection when this region
-                                     * was originally allocated:
-                                     * MDMemoryProtection */
-  uint32_t  __alignment1;
-  uint64_t  region_size;
-  uint32_t  state;                  /* MDMemoryState */
-  uint32_t  protection;             /* MDMemoryProtection */
-  uint32_t  type;                   /* MDMemoryType */
-  uint32_t  __alignment2;
-} MDRawMemoryInfo;  /* MINIDUMP_MEMORY_INFO */
-
-/* For (MDRawMemoryInfo).state */
-typedef enum {
-  MD_MEMORY_STATE_COMMIT   = 0x1000,  /* physical storage has been allocated */
-  MD_MEMORY_STATE_RESERVE  = 0x2000,  /* reserved, but no physical storage */
-  MD_MEMORY_STATE_FREE     = 0x10000  /* available to be allocated */
-} MDMemoryState;
-
-/* For (MDRawMemoryInfo).allocation_protection and .protection */
-typedef enum {
-  MD_MEMORY_PROTECT_NOACCESS          = 0x01,  /* PAGE_NOACCESS */
-  MD_MEMORY_PROTECT_READONLY          = 0x02,  /* PAGE_READONLY */
-  MD_MEMORY_PROTECT_READWRITE         = 0x04,  /* PAGE_READWRITE */
-  MD_MEMORY_PROTECT_WRITECOPY         = 0x08,  /* PAGE_WRITECOPY */
-  MD_MEMORY_PROTECT_EXECUTE           = 0x10,  /* PAGE_EXECUTE */
-  MD_MEMORY_PROTECT_EXECUTE_READ      = 0x20,  /* PAGE_EXECUTE_READ */
-  MD_MEMORY_PROTECT_EXECUTE_READWRITE = 0x40,  /* PAGE_EXECUTE_READWRITE */
-  MD_MEMORY_PROTECT_EXECUTE_WRITECOPY = 0x80,  /* PAGE_EXECUTE_WRITECOPY */
-  /* These options can be combined with the previous flags. */
-  MD_MEMORY_PROTECT_GUARD             = 0x100,  /* PAGE_GUARD */
-  MD_MEMORY_PROTECT_NOCACHE           = 0x200,  /* PAGE_NOCACHE */
-  MD_MEMORY_PROTECT_WRITECOMBINE      = 0x400,  /* PAGE_WRITECOMBINE */
-} MDMemoryProtection;
-
-/* Used to mask the mutually exclusive options from the combinable flags. */
-const uint32_t MD_MEMORY_PROTECTION_ACCESS_MASK = 0xFF;
-
-/* For (MDRawMemoryInfo).type */
-typedef enum {
-  MD_MEMORY_TYPE_PRIVATE = 0x20000,   /* not shared by other processes */
-  MD_MEMORY_TYPE_MAPPED  = 0x40000,   /* mapped into the view of a section */
-  MD_MEMORY_TYPE_IMAGE   = 0x1000000  /* mapped into the view of an image */
-} MDMemoryType;
-
-/*
- * Breakpad extension types
- */
-
-
-typedef struct {
-  /* validity is a bitmask with values from MDBreakpadInfoValidity, indicating
-   * which of the other fields in the structure are valid. */
-  uint32_t validity;
-
-  /* Thread ID of the handler thread.  dump_thread_id should correspond to
-   * the thread_id of an MDRawThread in the minidump's MDRawThreadList if
-   * a dedicated thread in that list was used to produce the minidump.  If
-   * the MDRawThreadList does not contain a dedicated thread used to produce
-   * the minidump, this field should be set to 0 and the validity field
-   * must not contain MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID. */
-  uint32_t dump_thread_id;
-
-  /* Thread ID of the thread that requested the minidump be produced.  As
-   * with dump_thread_id, requesting_thread_id should correspond to the
-   * thread_id of an MDRawThread in the minidump's MDRawThreadList.  For
-   * minidumps produced as a result of an exception, requesting_thread_id
-   * will be the same as the MDRawExceptionStream's thread_id field.  For
-   * minidumps produced "manually" at the program's request,
-   * requesting_thread_id will indicate which thread caused the dump to be
-   * written.  If the minidump was produced at the request of something
-   * other than a thread in the MDRawThreadList, this field should be set
-   * to 0 and the validity field must not contain
-   * MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID. */
-  uint32_t requesting_thread_id;
-} MDRawBreakpadInfo;
-
-/* For (MDRawBreakpadInfo).validity: */
-typedef enum {
-  /* When set, the dump_thread_id field is valid. */
-  MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID       = 1 << 0,
-
-  /* When set, the requesting_thread_id field is valid. */
-  MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID = 1 << 1
-} MDBreakpadInfoValidity;
-
-typedef struct {
-  /* expression, function, and file are 0-terminated UTF-16 strings.  They
-   * may be truncated if necessary, but should always be 0-terminated when
-   * written to a file.
-   * Fixed-length strings are used because MiniDumpWriteDump doesn't offer
-   * a way for user streams to point to arbitrary RVAs for strings. */
-  uint16_t expression[128];  /* Assertion that failed... */
-  uint16_t function[128];    /* ...within this function... */
-  uint16_t file[128];        /* ...in this file... */
-  uint32_t line;             /* ...at this line. */
-  uint32_t type;
-} MDRawAssertionInfo;
-
-/* For (MDRawAssertionInfo).type: */
-typedef enum {
-  MD_ASSERTION_INFO_TYPE_UNKNOWN = 0,
-
-  /* Used for assertions that would be raised by the MSVC CRT but are
-   * directed to an invalid parameter handler instead. */
-  MD_ASSERTION_INFO_TYPE_INVALID_PARAMETER,
-
-  /* Used for assertions that would be raised by the MSVC CRT but are
-   * directed to a pure virtual call handler instead. */
-  MD_ASSERTION_INFO_TYPE_PURE_VIRTUAL_CALL
-} MDAssertionInfoData;
-
-/* These structs are used to store the DSO debug data in Linux minidumps,
- * which is necessary for converting minidumps to usable coredumps.
- * Because of a historical accident, several fields are variably encoded
- * according to client word size, so tools potentially need to support both. */
-
-typedef struct {
-  uint32_t  addr;
-  MDRVA     name;
-  uint32_t  ld;
-} MDRawLinkMap32;
-
-typedef struct {
-  uint32_t  version;
-  MDRVA     map;  /* array of MDRawLinkMap32 */
-  uint32_t  dso_count;
-  uint32_t  brk;
-  uint32_t  ldbase;
-  uint32_t  dynamic;
-} MDRawDebug32;
-
-typedef struct {
-  uint64_t  addr;
-  MDRVA     name;
-  uint64_t  ld;
-} MDRawLinkMap64;
-
-typedef struct {
-  uint32_t  version;
-  MDRVA     map;  /* array of MDRawLinkMap64 */
-  uint32_t  dso_count;
-  uint64_t  brk;
-  uint64_t  ldbase;
-  uint64_t  dynamic;
-} MDRawDebug64;
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif  /* _MSC_VER */
-
-
-#endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_FORMAT_H__ */
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_size.h b/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_size.h
deleted file mode 100644
index 918544b66..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/common/minidump_size.h
+++ /dev/null
@@ -1,107 +0,0 @@
-// Copyright (c) 2007, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
-
-// minidump_size.h: Provides a C++ template for programmatic access to
-// the sizes of various types defined in minidump_format.h.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_SIZE_H__
-#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_SIZE_H__
-
-#include <sys/types.h>
-
-#include "google_breakpad/common/minidump_format.h"
-
-namespace google_breakpad {
-
-template<typename T>
-class minidump_size {
- public:
-  static size_t size() { return sizeof(T); }
-};
-
-// Explicit specializations for variable-length types.  The size returned
-// for these should be the size for an object without its variable-length
-// section.
-
-template<>
-class minidump_size<MDString> {
- public:
-  static size_t size() { return MDString_minsize; }
-};
-
-template<>
-class minidump_size<MDRawThreadList> {
- public:
-  static size_t size() { return MDRawThreadList_minsize; }
-};
-
-template<>
-class minidump_size<MDCVInfoPDB20> {
- public:
-  static size_t size() { return MDCVInfoPDB20_minsize; }
-};
-
-template<>
-class minidump_size<MDCVInfoPDB70> {
- public:
-  static size_t size() { return MDCVInfoPDB70_minsize; }
-};
-
-template<>
-class minidump_size<MDImageDebugMisc> {
- public:
-  static size_t size() { return MDImageDebugMisc_minsize; }
-};
-
-template<>
-class minidump_size<MDRawModuleList> {
- public:
-  static size_t size() { return MDRawModuleList_minsize; }
-};
-
-template<>
-class minidump_size<MDRawMemoryList> {
- public:
-  static size_t size() { return MDRawMemoryList_minsize; }
-};
-
-// Explicit specialization for MDRawModule, for which sizeof may include
-// tail-padding on some architectures but not others.
-
-template<>
-class minidump_size<MDRawModule> {
- public:
-  static size_t size() { return MD_MODULE_SIZE; }
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_SIZE_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/basic_source_line_resolver.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/basic_source_line_resolver.h
deleted file mode 100644
index 6bb6d8639..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/basic_source_line_resolver.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// basic_source_line_resolver.h: BasicSourceLineResolver is derived from
-// SourceLineResolverBase, and is a concrete implementation of
-// SourceLineResolverInterface, using address map files produced by a
-// compatible writer, e.g. PDBSourceLineWriter.
-//
-// see "processor/source_line_resolver_base.h"
-// and "source_line_resolver_interface.h" for more documentation.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__
-
-#include <map>
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/processor/source_line_resolver_base.h"
-
-namespace google_breakpad {
-
-using std::map;
-
-class BasicSourceLineResolver : public SourceLineResolverBase {
- public:
-  BasicSourceLineResolver();
-  virtual ~BasicSourceLineResolver() { }
-
-  using SourceLineResolverBase::LoadModule;
-  using SourceLineResolverBase::LoadModuleUsingMapBuffer;
-  using SourceLineResolverBase::LoadModuleUsingMemoryBuffer;
-  using SourceLineResolverBase::ShouldDeleteMemoryBufferAfterLoadModule;
-  using SourceLineResolverBase::UnloadModule;
-  using SourceLineResolverBase::HasModule;
-  using SourceLineResolverBase::IsModuleCorrupt;
-  using SourceLineResolverBase::FillSourceLineInfo;
-  using SourceLineResolverBase::FindWindowsFrameInfo;
-  using SourceLineResolverBase::FindCFIFrameInfo;
-
- private:
-  // friend declarations:
-  friend class BasicModuleFactory;
-  friend class ModuleComparer;
-  friend class ModuleSerializer;
-  template<class> friend class SimpleSerializer;
-
-  // Function derives from SourceLineResolverBase::Function.
-  struct Function;
-  // Module implements SourceLineResolverBase::Module interface.
-  class Module;
-
-  // Disallow unwanted copy ctor and assignment operator
-  BasicSourceLineResolver(const BasicSourceLineResolver&);
-  void operator=(const BasicSourceLineResolver&);
-};
-
-// Helper class, containing useful methods for parsing of Breakpad symbol files.
-class SymbolParseHelper {
- public:
-  // Parses a |file_line| declaration.  Returns true on success.
-  // Format: FILE <id> <filename>.
-  // Notice, that this method modifies the input |file_line| which is why it
-  // can't be const.  On success, <id>, and <filename> are stored in |*index|,
-  // and |*filename|.  No allocation is done, |*filename| simply points inside
-  // |file_line|.
-  static bool ParseFile(char *file_line,   // in
-                        long *index,       // out
-                        char **filename);  // out
-
-  // Parses a |function_line| declaration.  Returns true on success.
-  // Format:  FUNC <address> <size> <stack_param_size> <name>.
-  // Notice, that this method modifies the input |function_line| which is why it
-  // can't be const.  On success, <address>, <size>, <stack_param_size>, and
-  // <name> are stored in |*address|, |*size|, |*stack_param_size|, and |*name|.
-  // No allocation is done, |*name| simply points inside |function_line|.
-  static bool ParseFunction(char *function_line,     // in
-                            uint64_t *address,       // out
-                            uint64_t *size,          // out
-                            long *stack_param_size,  // out
-                            char **name);            // out
-
-  // Parses a |line| declaration.  Returns true on success.
-  // Format:  <address> <size> <line number> <source file id>
-  // Notice, that this method modifies the input |function_line| which is why
-  // it can't be const.  On success, <address>, <size>, <line number>, and
-  // <source file id> are stored in |*address|, |*size|, |*line_number|, and
-  // |*source_file|.
-  static bool ParseLine(char *line_line,     // in
-                        uint64_t *address,   // out
-                        uint64_t *size,      // out
-                        long *line_number,   // out
-                        long *source_file);  // out
-
-  // Parses a |public_line| declaration.  Returns true on success.
-  // Format:  PUBLIC <address> <stack_param_size> <name>
-  // Notice, that this method modifies the input |function_line| which is why
-  // it can't be const.  On success, <address>, <stack_param_size>, <name>
-  // are stored in |*address|, |*stack_param_size|, and |*name|.
-  // No allocation is done, |*name| simply points inside |public_line|.
-  static bool ParsePublicSymbol(char *public_line,       // in
-                                uint64_t *address,       // out
-                                long *stack_param_size,  // out
-                                char **name);            // out
-
- private:
-  // Used for success checks after strtoull and strtol.
-  static bool IsValidAfterNumber(char *after_number);
-
-  // Only allow static methods.
-  SymbolParseHelper();
-  SymbolParseHelper(const SymbolParseHelper&);
-  void operator=(const SymbolParseHelper&);
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/call_stack.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/call_stack.h
deleted file mode 100644
index 21f595e7b..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/call_stack.h
+++ /dev/null
@@ -1,77 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// call_stack.h: A call stack comprised of stack frames.
-//
-// This class manages a vector of stack frames.  It is used instead of
-// exposing the vector directly to allow the CallStack to own StackFrame
-// pointers without having to publicly export the linked_ptr class.  A
-// CallStack must be composed of pointers instead of objects to allow for
-// CPU-specific StackFrame subclasses.
-//
-// By convention, the stack frame at index 0 is the innermost callee frame,
-// and the frame at the highest index in a call stack is the outermost
-// caller.  CallStack only allows stacks to be built by pushing frames,
-// beginning with the innermost callee frame.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_CALL_STACK_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_CALL_STACK_H__
-
-#include <vector>
-
-namespace google_breakpad {
-
-using std::vector;
-
-struct StackFrame;
-template<typename T> class linked_ptr;
-
-class CallStack {
- public:
-  CallStack() { Clear(); }
-  ~CallStack();
-
-  // Resets the CallStack to its initial empty state
-  void Clear();
-  
-  const vector<StackFrame*>* frames() const { return &frames_; }
-
- private:
-  // Stackwalker is responsible for building the frames_ vector.
-  friend class Stackwalker;
-
-  // Storage for pushed frames.
-  vector<StackFrame*> frames_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCSSOR_CALL_STACK_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/code_module.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/code_module.h
deleted file mode 100644
index 4e8928243..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/code_module.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// code_module.h: Carries information about code modules that are loaded
-// into a process.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULE_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULE_H__
-
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-
-class CodeModule {
- public:
-  virtual ~CodeModule() {}
-
-  // The base address of this code module as it was loaded by the process.
-  // (uint64_t)-1 on error.
-  virtual uint64_t base_address() const = 0;
-
-  // The size of the code module.  0 on error.
-  virtual uint64_t size() const = 0;
-
-  // The path or file name that the code module was loaded from.  Empty on
-  // error.
-  virtual string code_file() const = 0;
-
-  // An identifying string used to discriminate between multiple versions and
-  // builds of the same code module.  This may contain a uuid, timestamp,
-  // version number, or any combination of this or other information, in an
-  // implementation-defined format.  Empty on error.
-  virtual string code_identifier() const = 0;
-
-  // The filename containing debugging information associated with the code
-  // module.  If debugging information is stored in a file separate from the
-  // code module itself (as is the case when .pdb or .dSYM files are used),
-  // this will be different from code_file.  If debugging information is
-  // stored in the code module itself (possibly prior to stripping), this
-  // will be the same as code_file.  Empty on error.
-  virtual string debug_file() const = 0;
-
-  // An identifying string similar to code_identifier, but identifies a
-  // specific version and build of the associated debug file.  This may be
-  // the same as code_identifier when the debug_file and code_file are
-  // identical or when the same identifier is used to identify distinct
-  // debug and code files.
-  virtual string debug_identifier() const = 0;
-
-  // A human-readable representation of the code module's version.  Empty on
-  // error.
-  virtual string version() const = 0;
-
-  // Creates a new copy of this CodeModule object, which the caller takes
-  // ownership of.  The new CodeModule may be of a different concrete class
-  // than the CodeModule being copied, but will behave identically to the
-  // copied CodeModule as far as the CodeModule interface is concerned.
-  virtual const CodeModule* Copy() const = 0;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULE_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/code_modules.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/code_modules.h
deleted file mode 100644
index a38579af6..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/code_modules.h
+++ /dev/null
@@ -1,98 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// code_modules.h: Contains all of the CodeModule objects that were loaded
-// into a single process.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULES_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULES_H__
-
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-
-class CodeModule;
-
-class CodeModules {
- public:
-  virtual ~CodeModules() {}
-
-  // The number of contained CodeModule objects.
-  virtual unsigned int module_count() const = 0;
-
-  // Random access to modules.  Returns the module whose code is present
-  // at the address indicated by |address|.  If no module is present at this
-  // address, returns NULL.  Ownership of the returned CodeModule is retained
-  // by the CodeModules object; pointers returned by this method are valid for
-  // comparison with pointers returned by the other Get methods.
-  virtual const CodeModule* GetModuleForAddress(uint64_t address) const = 0;
-
-  // Returns the module corresponding to the main executable.  If there is
-  // no main executable, returns NULL.  Ownership of the returned CodeModule
-  // is retained by the CodeModules object; pointers returned by this method
-  // are valid for comparison with pointers returned by the other Get
-  // methods.
-  virtual const CodeModule* GetMainModule() const = 0;
-
-  // Sequential access to modules.  A sequence number of 0 corresponds to the
-  // module residing lowest in memory.  If the sequence number is out of
-  // range, returns NULL.  Ownership of the returned CodeModule is retained
-  // by the CodeModules object; pointers returned by this method are valid for
-  // comparison with pointers returned by the other Get methods.
-  virtual const CodeModule* GetModuleAtSequence(
-      unsigned int sequence) const = 0;
-
-  // Sequential access to modules.  This is similar to GetModuleAtSequence,
-  // except no ordering requirement is enforced.  A CodeModules implementation
-  // may return CodeModule objects from GetModuleAtIndex in any order it
-  // wishes, provided that the order remain the same throughout the life of
-  // the CodeModules object.  Typically, GetModuleAtIndex would be used by
-  // a caller to enumerate all CodeModule objects quickly when the enumeration
-  // does not require any ordering.  If the index argument is out of range,
-  // returns NULL.  Ownership of the returned CodeModule is retained by
-  // the CodeModules object; pointers returned by this method are valid for
-  // comparison with pointers returned by the other Get methods.
-  virtual const CodeModule* GetModuleAtIndex(unsigned int index) const = 0;
-
-  // Creates a new copy of this CodeModules object, which the caller takes
-  // ownership of.  The new object will also contain copies of the existing
-  // object's child CodeModule objects.  The new CodeModules object may be of
-  // a different concrete class than the object being copied, but will behave
-  // identically to the copied object as far as the CodeModules and CodeModule
-  // interfaces are concerned, except that the order that GetModuleAtIndex
-  // returns objects in may differ between a copy and the original CodeModules
-  // object.
-  virtual const CodeModules* Copy() const = 0;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULES_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_context.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_context.h
deleted file mode 100644
index df80bf7ef..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_context.h
+++ /dev/null
@@ -1,116 +0,0 @@
-// Copyright (c) 2014 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// dump_context.h: A (mini/micro) dump CPU-specific context.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
-
-#include "google_breakpad/common/minidump_format.h"
-#include "google_breakpad/processor/dump_object.h"
-
-namespace google_breakpad {
-
-// DumpContext carries a CPU-specific MDRawContext structure, which contains CPU
-// context such as register states.
-class DumpContext : public DumpObject {
- public:
-  virtual ~DumpContext();
-
-  // Returns an MD_CONTEXT_* value such as MD_CONTEXT_X86 or MD_CONTEXT_PPC
-  // identifying the CPU type that the context was collected from.  The
-  // returned value will identify the CPU only, and will have any other
-  // MD_CONTEXT_* bits masked out.  Returns 0 on failure.
-  uint32_t GetContextCPU() const;
-
-  // Return the raw value of |context_flags_|
-  uint32_t GetContextFlags() const;
-
-  // Returns raw CPU-specific context data for the named CPU type.  If the
-  // context data does not match the CPU type or does not exist, returns NULL.
-  const MDRawContextAMD64* GetContextAMD64() const;
-  const MDRawContextARM*   GetContextARM() const;
-  const MDRawContextARM64* GetContextARM64() const;
-  const MDRawContextMIPS*  GetContextMIPS() const;
-  const MDRawContextPPC*   GetContextPPC() const;
-  const MDRawContextPPC64* GetContextPPC64() const;
-  const MDRawContextSPARC* GetContextSPARC() const;
-  const MDRawContextX86*   GetContextX86() const;
-
-  // A convenience method to get the instruction pointer out of the
-  // MDRawContext, since it varies per-CPU architecture.
-  bool GetInstructionPointer(uint64_t* ip) const;
-
-  // Similar to the GetInstructionPointer method, this method gets the stack
-  // pointer for all CPU architectures.
-  bool GetStackPointer(uint64_t* sp) const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- protected:
-  DumpContext();
-
-  // Sets row CPU-specific context data for the names CPU type.
-  void SetContextFlags(uint32_t context_flags);
-  void SetContextX86(MDRawContextX86* x86);
-  void SetContextPPC(MDRawContextPPC* ppc);
-  void SetContextPPC64(MDRawContextPPC64* ppc64);
-  void SetContextAMD64(MDRawContextAMD64* amd64);
-  void SetContextSPARC(MDRawContextSPARC* ctx_sparc);
-  void SetContextARM(MDRawContextARM* arm);
-  void SetContextARM64(MDRawContextARM64* arm64);
-  void SetContextMIPS(MDRawContextMIPS* ctx_mips);
-
-  // Free the CPU-specific context structure.
-  void FreeContext();
-
- private:
-  // The CPU-specific context structure.
-  union {
-    MDRawContextBase*  base;
-    MDRawContextX86*   x86;
-    MDRawContextPPC*   ppc;
-    MDRawContextPPC64* ppc64;
-    MDRawContextAMD64* amd64;
-    // on Solaris SPARC, sparc is defined as a numeric constant,
-    // so variables can NOT be named as sparc
-    MDRawContextSPARC* ctx_sparc;
-    MDRawContextARM*   arm;
-    MDRawContextARM64* arm64;
-    MDRawContextMIPS*  ctx_mips;
-  } context_;
-
-  // Store this separately because of the weirdo AMD64 context
-  uint32_t context_flags_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_object.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_object.h
deleted file mode 100644
index 112f687f4..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/dump_object.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (c) 2014 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// dump_object.h: A base class for all mini/micro dump object.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
-
-namespace google_breakpad {
-
-// DumpObject is the base of various mini/micro dump's objects.
-class DumpObject {
- public:
-  DumpObject();
-
-  bool valid() const { return valid_; }
-
- protected:
-  // DumpObjects are not valid when created.  When a subclass populates its own
-  // fields, it can set valid_ to true.  Accessors and mutators may wish to
-  // consider or alter the valid_ state as they interact with objects.
-  bool valid_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/exploitability.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/exploitability.h
deleted file mode 100644
index 014413c94..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/exploitability.h
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// exploitability_engine.h: Generic exploitability engine.
-//
-// The Exploitability class is an abstract base class providing common
-// generic methods that apply to exploitability engines for specific platforms.
-// Specific implementations will extend this class by providing run
-// methods to fill in the exploitability_ enumeration of the ProcessState
-// for a crash.
-//
-// Author: Cris Neckar
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_EXPLOITABILITY_H_
-#define GOOGLE_BREAKPAD_PROCESSOR_EXPLOITABILITY_H_
-
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/minidump.h"
-#include "google_breakpad/processor/process_state.h"
-
-namespace google_breakpad {
-
-class Exploitability {
- public:
-  virtual ~Exploitability() {}
-
-  static Exploitability *ExploitabilityForPlatform(Minidump *dump,
-                                                   ProcessState *process_state);
-
-  // The boolean parameter signals whether the exploitability engine is
-  // enabled to call out to objdump for disassembly. This is disabled by
-  // default. It is used to check the identity of the instruction that
-  // caused the program to crash. This should not be enabled if there are
-  // portability concerns.
-  static Exploitability *ExploitabilityForPlatform(Minidump *dump,
-                                                   ProcessState *process_state,
-                                                   bool enable_objdump);
-
-  ExploitabilityRating CheckExploitability();
-  bool AddressIsAscii(uint64_t);
-
- protected:
-  Exploitability(Minidump *dump,
-                 ProcessState *process_state);
-
-  Minidump *dump_;
-  ProcessState *process_state_;
-  SystemInfo *system_info_;
-
- private:
-  virtual ExploitabilityRating CheckPlatformExploitability() = 0;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_EXPLOITABILITY_H_
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/fast_source_line_resolver.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/fast_source_line_resolver.h
deleted file mode 100644
index fdf910776..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/fast_source_line_resolver.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// fast_source_line_resolver.h: FastSourceLineResolver is derived from
-// SourceLineResolverBase, and is a concrete implementation of
-// SourceLineResolverInterface.
-//
-// FastSourceLineResolver is a sibling class of BasicSourceLineResolver.  The
-// difference is FastSourceLineResolver loads a serialized memory chunk of data
-// which can be used directly a Module without parsing or copying of underlying
-// data.  Therefore loading a symbol in FastSourceLineResolver is much faster
-// and more memory-efficient than BasicSourceLineResolver.
-//
-// See "source_line_resolver_base.h" and
-// "google_breakpad/source_line_resolver_interface.h" for more reference.
-//
-// Author: Siyang Xie (lambxsy@google.com)
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_FAST_SOURCE_LINE_RESOLVER_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_FAST_SOURCE_LINE_RESOLVER_H__
-
-#include <map>
-#include <string>
-
-#include "google_breakpad/processor/source_line_resolver_base.h"
-
-namespace google_breakpad {
-
-using std::map;
-
-class FastSourceLineResolver : public SourceLineResolverBase {
- public:
-  FastSourceLineResolver();
-  virtual ~FastSourceLineResolver() { }
-
-  using SourceLineResolverBase::FillSourceLineInfo;
-  using SourceLineResolverBase::FindCFIFrameInfo;
-  using SourceLineResolverBase::FindWindowsFrameInfo;
-  using SourceLineResolverBase::HasModule;
-  using SourceLineResolverBase::IsModuleCorrupt;
-  using SourceLineResolverBase::LoadModule;
-  using SourceLineResolverBase::LoadModuleUsingMapBuffer;
-  using SourceLineResolverBase::LoadModuleUsingMemoryBuffer;
-  using SourceLineResolverBase::UnloadModule;
-
- private:
-  // Friend declarations.
-  friend class ModuleComparer;
-  friend class ModuleSerializer;
-  friend class FastModuleFactory;
-
-  // Nested types that will derive from corresponding nested types defined in
-  // SourceLineResolverBase.
-  struct Line;
-  struct Function;
-  struct PublicSymbol;
-  class Module;
-
-  // Deserialize raw memory data to construct a WindowsFrameInfo object.
-  static WindowsFrameInfo CopyWFI(const char *raw_memory);
-
-  // FastSourceLineResolver requires the memory buffer stays alive during the
-  // lifetime of a corresponding module, therefore it needs to redefine this
-  // virtual method.
-  virtual bool ShouldDeleteMemoryBufferAfterLoadModule();
-
-  // Disallow unwanted copy ctor and assignment operator
-  FastSourceLineResolver(const FastSourceLineResolver&);
-  void operator=(const FastSourceLineResolver&);
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_FAST_SOURCE_LINE_RESOLVER_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/memory_region.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/memory_region.h
deleted file mode 100644
index 30f88df49..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/memory_region.h
+++ /dev/null
@@ -1,79 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// memory_region.h: Access to memory regions.
-//
-// A MemoryRegion provides virtual access to a range of memory.  It is an
-// abstraction allowing the actual source of memory to be independent of
-// methods which need to access a virtual memory space.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_MEMORY_REGION_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_MEMORY_REGION_H__
-
-
-#include "google_breakpad/common/breakpad_types.h"
-
-
-namespace google_breakpad {
-
-
-class MemoryRegion {
- public:
-  virtual ~MemoryRegion() {}
-
-  // The base address of this memory region.
-  virtual uint64_t GetBase() const = 0;
-
-  // The size of this memory region.
-  virtual uint32_t GetSize() const = 0;
-
-  // Access to data of various sizes within the memory region.  address
-  // is a pointer to read, and it must lie within the memory region as
-  // defined by its base address and size.  The location pointed to by
-  // value is set to the value at address.  Byte-swapping is performed
-  // if necessary so that the value is appropriate for the running
-  // program.  Returns true on success.  Fails and returns false if address
-  // is out of the region's bounds (after considering the width of value),
-  // or for other types of errors.
-  virtual bool GetMemoryAtAddress(uint64_t address, uint8_t*  value) const = 0;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const = 0;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const = 0;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const = 0;
-
-  // Print a human-readable representation of the object to stdout.
-  virtual void Print() const = 0;
-};
-
-
-}  // namespace google_breakpad
-
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_MEMORY_REGION_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump.h
deleted file mode 100644
index abdaecb19..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump.h
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright (c) 2014 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// microdump.h: A microdump reader.  Microdump is a minified variant of a
-// minidump (see minidump.h for documentation) which contains the minimum
-// amount of information required to get a stack trace for the crashing thread.
-// The information contained in a microdump is:
-// - the crashing thread stack
-// - system information (os type / version)
-// - cpu context (state of the registers)
-// - list of mmaps
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
-
-#include <string>
-#include <vector>
-
-#include "common/scoped_ptr.h"
-#include "common/using_std_string.h"
-#include "google_breakpad/processor/dump_context.h"
-#include "google_breakpad/processor/memory_region.h"
-#include "google_breakpad/processor/system_info.h"
-#include "processor/basic_code_modules.h"
-
-namespace google_breakpad {
-
-// MicrodumpModuleList contains all of the loaded code modules for a process
-// in the form of MicrodumpModules.  It maintains a vector of these modules
-// and provides access to a code module corresponding to a specific address.
-class MicrodumpModules : public BasicCodeModules {
- public:
-  // Takes over ownership of |module|.
-  void Add(const CodeModule* module);
-};
-
-// MicrodumpContext carries a CPU-specific context.
-// See dump_context.h for documentation.
-class MicrodumpContext : public DumpContext {
- public:
-  virtual void SetContextARM(MDRawContextARM* arm);
-  virtual void SetContextARM64(MDRawContextARM64* arm64);
-};
-
-// This class provides access to microdump memory regions.
-// See memory_region.h for documentation.
-class MicrodumpMemoryRegion : public MemoryRegion {
- public:
-  MicrodumpMemoryRegion();
-  virtual ~MicrodumpMemoryRegion() {}
-
-  // Set this region's address and contents. If we have placed an
-  // instance of this class in a test fixture class, individual tests
-  // can use this to provide the region's contents.
-  void Init(uint64_t base_address, const std::vector<uint8_t>& contents);
-
-  virtual uint64_t GetBase() const;
-  virtual uint32_t GetSize() const;
-
-  virtual bool GetMemoryAtAddress(uint64_t address, uint8_t* value) const;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const;
-  virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const;
-
-  // Print a human-readable representation of the object to stdout.
-  virtual void Print() const;
-
- private:
-  // Fetch a little-endian value from ADDRESS in contents_ whose size
-  // is BYTES, and store it in *VALUE.  Returns true on success.
-  template<typename ValueType>
-  bool GetMemoryLittleEndian(uint64_t address, ValueType* value) const;
-
-  uint64_t base_address_;
-  std::vector<uint8_t> contents_;
-};
-
-// Microdump is the user's interface to a microdump file.  It provides access to
-// the microdump's context, memory regions and modules.
-class Microdump {
- public:
-  explicit Microdump(const string& contents);
-  virtual ~Microdump() {}
-
-  DumpContext* GetContext() { return context_.get(); }
-  MicrodumpMemoryRegion* GetMemory() { return stack_region_.get(); }
-  MicrodumpModules* GetModules() { return modules_.get(); }
-  SystemInfo* GetSystemInfo() { return system_info_.get(); }
-
- private:
-  scoped_ptr<MicrodumpContext> context_;
-  scoped_ptr<MicrodumpMemoryRegion> stack_region_;
-  scoped_ptr<MicrodumpModules> modules_;
-  scoped_ptr<SystemInfo> system_info_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
-
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump_processor.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump_processor.h
deleted file mode 100644
index 1322a01c7..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/microdump_processor.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// The processor for microdump (a reduced dump containing only the state of the
-// crashing thread). See crbug.com/410294 for more info and design docs.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
-
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/processor/process_result.h"
-
-namespace google_breakpad {
-
-class ProcessState;
-class StackFrameSymbolizer;
- 
-class MicrodumpProcessor {
- public:
-  // Initializes the MicrodumpProcessor with a stack frame symbolizer.
-  // Does not take ownership of frame_symbolizer, which must NOT be NULL.
-  explicit MicrodumpProcessor(StackFrameSymbolizer* frame_symbolizer);
-
-  virtual ~MicrodumpProcessor();
-
-  // Processes the microdump contents and fills process_state with the result.
-  google_breakpad::ProcessResult Process(const string& microdump_contents,
-                                         ProcessState* process_state);
- private:
-  StackFrameSymbolizer* frame_symbolizer_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump.h
deleted file mode 100644
index 2b5025e4f..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump.h
+++ /dev/null
@@ -1,1130 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// minidump.h: A minidump reader.
-//
-// The basic structure of this module tracks the structure of the minidump
-// file itself.  At the top level, a minidump file is represented by a
-// Minidump object.  Like most other classes in this module, Minidump
-// provides a Read method that initializes the object with information from
-// the file.  Most of the classes in this file are wrappers around the
-// "raw" structures found in the minidump file itself, and defined in
-// minidump_format.h.  For example, each thread is represented by a
-// MinidumpThread object, whose parameters are specified in an MDRawThread
-// structure.  A properly byte-swapped MDRawThread can be obtained from a
-// MinidumpThread easily by calling its thread() method.
-//
-// Most of the module lazily reads only the portion of the minidump file
-// necessary to fulfill the user's request.  Calling Minidump::Read
-// only reads the minidump's directory.  The thread list is not read until
-// it is needed, and even once it's read, the memory regions for each
-// thread's stack aren't read until they're needed.  This strategy avoids
-// unnecessary file input, and allocating memory for data in which the user
-// has no interest.  Note that although memory allocations for a typical
-// minidump file are not particularly large, it is possible for legitimate
-// minidumps to be sizable.  A full-memory minidump, for example, contains
-// a snapshot of the entire mapped memory space.  Even a normal minidump,
-// with stack memory only, can be large if, for example, the dump was
-// generated in response to a crash that occurred due to an infinite-
-// recursion bug that caused the stack's limits to be exceeded.  Finally,
-// some users of this library will unfortunately find themselves in the
-// position of having to process potentially-hostile minidumps that might
-// attempt to cause problems by forcing the minidump processor to over-
-// allocate memory.
-//
-// Memory management in this module is based on a strict
-// you-don't-own-anything policy.  The only object owned by the user is
-// the top-level Minidump object, the creation and destruction of which
-// must be the user's own responsibility.  All other objects obtained
-// through interaction with this module are ultimately owned by the
-// Minidump object, and will be freed upon the Minidump object's destruction.
-// Because memory regions can potentially involve large allocations, a
-// FreeMemory method is provided by MinidumpMemoryRegion, allowing the user
-// to release data when it is no longer needed.  Use of this method is
-// optional but recommended.  If freed data is later required, it will
-// be read back in from the minidump file again.
-//
-// There is one exception to this memory management policy:
-// Minidump::ReadString will return a string object to the user, and the user
-// is responsible for its deletion.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
-
-#include <stdint.h>
-
-#ifndef _WIN32
-#include <unistd.h>
-#endif
-
-#include <iostream>
-#include <map>
-#include <string>
-#include <vector>
-
-#include "common/basictypes.h"
-#include "common/using_std_string.h"
-#include "google_breakpad/processor/code_module.h"
-#include "google_breakpad/processor/code_modules.h"
-#include "google_breakpad/processor/dump_context.h"
-#include "google_breakpad/processor/dump_object.h"
-#include "google_breakpad/processor/memory_region.h"
-#include "google_breakpad/processor/proc_maps_linux.h"
-
-
-namespace google_breakpad {
-
-
-using std::map;
-using std::vector;
-
-
-class Minidump;
-template<typename AddressType, typename EntryType> class RangeMap;
-
-
-// MinidumpObject is the base of all Minidump* objects except for Minidump
-// itself.
-class MinidumpObject : public DumpObject {
- public:
-  virtual ~MinidumpObject() {}
-
- protected:
-  explicit MinidumpObject(Minidump* minidump);
-
-  // Refers to the Minidump object that is the ultimate parent of this
-  // Some MinidumpObjects are owned by other MinidumpObjects, but at the
-  // root of the ownership tree is always a Minidump.  The Minidump object
-  // is kept here for access to its seeking and reading facilities, and
-  // for access to data about the minidump file itself, such as whether
-  // it should be byte-swapped.
-  Minidump* minidump_;
-};
-
-
-// This class exists primarily to provide a virtual destructor in a base
-// class common to all objects that might be stored in
-// Minidump::mStreamObjects.  Some object types will never be stored in
-// Minidump::mStreamObjects, but are represented as streams and adhere to the
-// same interface, and may be derived from this class.
-class MinidumpStream : public MinidumpObject {
- public:
-  virtual ~MinidumpStream() {}
-
- protected:
-  explicit MinidumpStream(Minidump* minidump);
-
- private:
-  // Populate (and validate) the MinidumpStream.  minidump_ is expected
-  // to be positioned at the beginning of the stream, so that the next
-  // read from the minidump will be at the beginning of the stream.
-  // expected_size should be set to the stream's length as contained in
-  // the MDRawDirectory record or other identifying record.  A class
-  // that implements MinidumpStream can compare expected_size to a
-  // known size as an integrity check.
-  virtual bool Read(uint32_t expected_size) = 0;
-};
-
-
-// MinidumpContext carries a CPU-specific MDRawContext structure, which
-// contains CPU context such as register states.  Each thread has its
-// own context, and the exception record, if present, also has its own
-// context.  Note that if the exception record is present, the context it
-// refers to is probably what the user wants to use for the exception
-// thread, instead of that thread's own context.  The exception thread's
-// context (as opposed to the exception record's context) will contain
-// context for the exception handler (which performs minidump generation),
-// and not the context that caused the exception (which is probably what the
-// user wants).
-class MinidumpContext : public DumpContext {
- public:
-  virtual ~MinidumpContext();
-
- protected:
-  explicit MinidumpContext(Minidump* minidump);
-
- private:
-  friend class MinidumpThread;
-  friend class MinidumpException;
-
-  bool Read(uint32_t expected_size);
-
-  // If the minidump contains a SYSTEM_INFO_STREAM, makes sure that the
-  // system info stream gives an appropriate CPU type matching the context
-  // CPU type in context_cpu_type.  Returns false if the CPU type does not
-  // match.  Returns true if the CPU type matches or if the minidump does
-  // not contain a system info stream.
-  bool CheckAgainstSystemInfo(uint32_t context_cpu_type);
-
-  // Refers to the Minidump object that is the ultimate parent of this
-  // Some MinidumpObjects are owned by other MinidumpObjects, but at the
-  // root of the ownership tree is always a Minidump.  The Minidump object
-  // is kept here for access to its seeking and reading facilities, and
-  // for access to data about the minidump file itself, such as whether
-  // it should be byte-swapped.
-  Minidump* minidump_;
-};
-
-
-// MinidumpMemoryRegion does not wrap any MDRaw structure, and only contains
-// a reference to an MDMemoryDescriptor.  This object is intended to wrap
-// portions of a minidump file that contain memory dumps.  In normal
-// minidumps, each MinidumpThread owns a MinidumpMemoryRegion corresponding
-// to the thread's stack memory.  MinidumpMemoryList also gives access to
-// memory regions in its list as MinidumpMemoryRegions.  This class
-// adheres to MemoryRegion so that it may be used as a data provider to
-// the Stackwalker family of classes.
-class MinidumpMemoryRegion : public MinidumpObject,
-                             public MemoryRegion {
- public:
-  virtual ~MinidumpMemoryRegion();
-
-  static void set_max_bytes(uint32_t max_bytes) { max_bytes_ = max_bytes; }
-  static uint32_t max_bytes() { return max_bytes_; }
-
-  // Returns a pointer to the base of the memory region.  Returns the
-  // cached value if available, otherwise, reads the minidump file and
-  // caches the memory region.
-  const uint8_t* GetMemory() const;
-
-  // The address of the base of the memory region.
-  uint64_t GetBase() const;
-
-  // The size, in bytes, of the memory region.
-  uint32_t GetSize() const;
-
-  // Frees the cached memory region, if cached.
-  void FreeMemory();
-
-  // Obtains the value of memory at the pointer specified by address.
-  bool GetMemoryAtAddress(uint64_t address, uint8_t*  value) const;
-  bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const;
-  bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const;
-  bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print() const;
-
- protected:
-  explicit MinidumpMemoryRegion(Minidump* minidump);
-
- private:
-  friend class MinidumpThread;
-  friend class MinidumpMemoryList;
-
-  // Identify the base address and size of the memory region, and the
-  // location it may be found in the minidump file.
-  void SetDescriptor(MDMemoryDescriptor* descriptor);
-
-  // Implementation for GetMemoryAtAddress
-  template<typename T> bool GetMemoryAtAddressInternal(uint64_t address,
-                                                       T*        value) const;
-
-  // The largest memory region that will be read from a minidump.  The
-  // default is 1MB.
-  static uint32_t max_bytes_;
-
-  // Base address and size of the memory region, and its position in the
-  // minidump file.
-  MDMemoryDescriptor* descriptor_;
-
-  // Cached memory.
-  mutable vector<uint8_t>* memory_;
-};
-
-
-// MinidumpThread contains information about a thread of execution,
-// including a snapshot of the thread's stack and CPU context.  For
-// the thread that caused an exception, the context carried by
-// MinidumpException is probably desired instead of the CPU context
-// provided here.
-// Note that a MinidumpThread may be valid() even if it does not
-// contain a memory region or context.
-class MinidumpThread : public MinidumpObject {
- public:
-  virtual ~MinidumpThread();
-
-  const MDRawThread* thread() const { return valid_ ? &thread_ : NULL; }
-  // GetMemory may return NULL even if the MinidumpThread is valid,
-  // if the thread memory cannot be read.
-  virtual MinidumpMemoryRegion* GetMemory();
-  // GetContext may return NULL even if the MinidumpThread is valid.
-  virtual MinidumpContext* GetContext();
-
-  // The thread ID is used to determine if a thread is the exception thread,
-  // so a special getter is provided to retrieve this data from the
-  // MDRawThread structure.  Returns false if the thread ID cannot be
-  // determined.
-  virtual bool GetThreadID(uint32_t *thread_id) const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
-  // Returns the start address of the thread stack memory region.  Returns 0 if
-  // MinidumpThread is invalid.  Note that this method can be called even when
-  // the thread memory cannot be read and GetMemory returns NULL.
-  virtual uint64_t GetStartOfStackMemoryRange() const;
-
- protected:
-  explicit MinidumpThread(Minidump* minidump);
-
- private:
-  // These objects are managed by MinidumpThreadList.
-  friend class MinidumpThreadList;
-
-  // This works like MinidumpStream::Read, but is driven by
-  // MinidumpThreadList.  No size checking is done, because
-  // MinidumpThreadList handles that directly.
-  bool Read();
-
-  MDRawThread           thread_;
-  MinidumpMemoryRegion* memory_;
-  MinidumpContext*      context_;
-};
-
-
-// MinidumpThreadList contains all of the threads (as MinidumpThreads) in
-// a process.
-class MinidumpThreadList : public MinidumpStream {
- public:
-  virtual ~MinidumpThreadList();
-
-  static void set_max_threads(uint32_t max_threads) {
-    max_threads_ = max_threads;
-  }
-  static uint32_t max_threads() { return max_threads_; }
-
-  virtual unsigned int thread_count() const {
-    return valid_ ? thread_count_ : 0;
-  }
-
-  // Sequential access to threads.
-  virtual MinidumpThread* GetThreadAtIndex(unsigned int index) const;
-
-  // Random access to threads.
-  MinidumpThread* GetThreadByID(uint32_t thread_id);
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- protected:
-  explicit MinidumpThreadList(Minidump* aMinidump);
-
- private:
-  friend class Minidump;
-
-  typedef map<uint32_t, MinidumpThread*> IDToThreadMap;
-  typedef vector<MinidumpThread> MinidumpThreads;
-
-  static const uint32_t kStreamType = MD_THREAD_LIST_STREAM;
-
-  bool Read(uint32_t aExpectedSize);
-
-  // The largest number of threads that will be read from a minidump.  The
-  // default is 256.
-  static uint32_t max_threads_;
-
-  // Access to threads using the thread ID as the key.
-  IDToThreadMap    id_to_thread_map_;
-
-  // The list of threads.
-  MinidumpThreads* threads_;
-  uint32_t        thread_count_;
-};
-
-
-// MinidumpModule wraps MDRawModule, which contains information about loaded
-// code modules.  Access is provided to various data referenced indirectly
-// by MDRawModule, such as the module's name and a specification for where
-// to locate debugging information for the module.
-class MinidumpModule : public MinidumpObject,
-                       public CodeModule {
- public:
-  virtual ~MinidumpModule();
-
-  static void set_max_cv_bytes(uint32_t max_cv_bytes) {
-    max_cv_bytes_ = max_cv_bytes;
-  }
-  static uint32_t max_cv_bytes() { return max_cv_bytes_; }
-
-  static void set_max_misc_bytes(uint32_t max_misc_bytes) {
-    max_misc_bytes_ = max_misc_bytes;
-  }
-  static uint32_t max_misc_bytes() { return max_misc_bytes_; }
-
-  const MDRawModule* module() const { return valid_ ? &module_ : NULL; }
-
-  // CodeModule implementation
-  virtual uint64_t base_address() const {
-    return valid_ ? module_.base_of_image : static_cast<uint64_t>(-1);
-  }
-  virtual uint64_t size() const { return valid_ ? module_.size_of_image : 0; }
-  virtual string code_file() const;
-  virtual string code_identifier() const;
-  virtual string debug_file() const;
-  virtual string debug_identifier() const;
-  virtual string version() const;
-  virtual const CodeModule* Copy() const;
-
-  // The CodeView record, which contains information to locate the module's
-  // debugging information (pdb).  This is returned as uint8_t* because
-  // the data can be of types MDCVInfoPDB20* or MDCVInfoPDB70*, or it may be
-  // of a type unknown to Breakpad, in which case the raw data will still be
-  // returned but no byte-swapping will have been performed.  Check the
-  // record's signature in the first four bytes to differentiate between
-  // the various types.  Current toolchains generate modules which carry
-  // MDCVInfoPDB70 by default.  Returns a pointer to the CodeView record on
-  // success, and NULL on failure.  On success, the optional |size| argument
-  // is set to the size of the CodeView record.
-  const uint8_t* GetCVRecord(uint32_t* size);
-
-  // The miscellaneous debug record, which is obsolete.  Current toolchains
-  // do not generate this type of debugging information (dbg), and this
-  // field is not expected to be present.  Returns a pointer to the debugging
-  // record on success, and NULL on failure.  On success, the optional |size|
-  // argument is set to the size of the debugging record.
-  const MDImageDebugMisc* GetMiscRecord(uint32_t* size);
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  // These objects are managed by MinidumpModuleList.
-  friend class MinidumpModuleList;
-
-  explicit MinidumpModule(Minidump* minidump);
-
-  // This works like MinidumpStream::Read, but is driven by
-  // MinidumpModuleList.  No size checking is done, because
-  // MinidumpModuleList handles that directly.
-  bool Read();
-
-  // Reads indirectly-referenced data, including the module name, CodeView
-  // record, and miscellaneous debugging record.  This is necessary to allow
-  // MinidumpModuleList to fully construct MinidumpModule objects without
-  // requiring seeks to read a contiguous set of MinidumpModule objects.
-  // All auxiliary data should be available when Read is called, in order to
-  // allow the CodeModule getters to be const methods.
-  bool ReadAuxiliaryData();
-
-  // The largest number of bytes that will be read from a minidump for a
-  // CodeView record or miscellaneous debugging record, respectively.  The
-  // default for each is 1024.
-  static uint32_t max_cv_bytes_;
-  static uint32_t max_misc_bytes_;
-
-  // True after a successful Read.  This is different from valid_, which is
-  // not set true until ReadAuxiliaryData also completes successfully.
-  // module_valid_ is only used by ReadAuxiliaryData and the functions it
-  // calls to determine whether the object is ready for auxiliary data to
-  // be read.
-  bool              module_valid_;
-
-  // True if debug info was read from the module.  Certain modules
-  // may contain debug records in formats we don't support,
-  // so we can just set this to false to ignore them.
-  bool              has_debug_info_;
-
-  MDRawModule       module_;
-
-  // Cached module name.
-  const string*     name_;
-
-  // Cached CodeView record - this is MDCVInfoPDB20 or (likely)
-  // MDCVInfoPDB70, or possibly something else entirely.  Stored as a uint8_t
-  // because the structure contains a variable-sized string and its exact
-  // size cannot be known until it is processed.
-  vector<uint8_t>* cv_record_;
-
-  // If cv_record_ is present, cv_record_signature_ contains a copy of the
-  // CodeView record's first four bytes, for ease of determinining the
-  // type of structure that cv_record_ contains.
-  uint32_t cv_record_signature_;
-
-  // Cached MDImageDebugMisc (usually not present), stored as uint8_t
-  // because the structure contains a variable-sized string and its exact
-  // size cannot be known until it is processed.
-  vector<uint8_t>* misc_record_;
-};
-
-
-// MinidumpModuleList contains all of the loaded code modules for a process
-// in the form of MinidumpModules.  It maintains a map of these modules
-// so that it may easily provide a code module corresponding to a specific
-// address.
-class MinidumpModuleList : public MinidumpStream,
-                           public CodeModules {
- public:
-  virtual ~MinidumpModuleList();
-
-  static void set_max_modules(uint32_t max_modules) {
-    max_modules_ = max_modules;
-  }
-  static uint32_t max_modules() { return max_modules_; }
-
-  // CodeModules implementation.
-  virtual unsigned int module_count() const {
-    return valid_ ? module_count_ : 0;
-  }
-  virtual const MinidumpModule* GetModuleForAddress(uint64_t address) const;
-  virtual const MinidumpModule* GetMainModule() const;
-  virtual const MinidumpModule* GetModuleAtSequence(
-      unsigned int sequence) const;
-  virtual const MinidumpModule* GetModuleAtIndex(unsigned int index) const;
-  virtual const CodeModules* Copy() const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- protected:
-  explicit MinidumpModuleList(Minidump* minidump);
-
- private:
-  friend class Minidump;
-
-  typedef vector<MinidumpModule> MinidumpModules;
-
-  static const uint32_t kStreamType = MD_MODULE_LIST_STREAM;
-
-  bool Read(uint32_t expected_size);
-
-  // The largest number of modules that will be read from a minidump.  The
-  // default is 1024.
-  static uint32_t max_modules_;
-
-  // Access to modules using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
-
-  MinidumpModules *modules_;
-  uint32_t module_count_;
-};
-
-
-// MinidumpMemoryList corresponds to a minidump's MEMORY_LIST_STREAM stream,
-// which references the snapshots of all of the memory regions contained
-// within the minidump.  For a normal minidump, this includes stack memory
-// (also referenced by each MinidumpThread, in fact, the MDMemoryDescriptors
-// here and in MDRawThread both point to exactly the same data in a
-// minidump file, conserving space), as well as a 256-byte snapshot of memory
-// surrounding the instruction pointer in the case of an exception.  Other
-// types of minidumps may contain significantly more memory regions.  Full-
-// memory minidumps contain all of a process' mapped memory.
-class MinidumpMemoryList : public MinidumpStream {
- public:
-  virtual ~MinidumpMemoryList();
-
-  static void set_max_regions(uint32_t max_regions) {
-    max_regions_ = max_regions;
-  }
-  static uint32_t max_regions() { return max_regions_; }
-
-  unsigned int region_count() const { return valid_ ? region_count_ : 0; }
-
-  // Sequential access to memory regions.
-  MinidumpMemoryRegion* GetMemoryRegionAtIndex(unsigned int index);
-
-  // Random access to memory regions.  Returns the region encompassing
-  // the address identified by address.
-  virtual MinidumpMemoryRegion* GetMemoryRegionForAddress(uint64_t address);
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-  friend class MockMinidumpMemoryList;
-
-  typedef vector<MDMemoryDescriptor>   MemoryDescriptors;
-  typedef vector<MinidumpMemoryRegion> MemoryRegions;
-
-  static const uint32_t kStreamType = MD_MEMORY_LIST_STREAM;
-
-  explicit MinidumpMemoryList(Minidump* minidump);
-
-  bool Read(uint32_t expected_size);
-
-  // The largest number of memory regions that will be read from a minidump.
-  // The default is 256.
-  static uint32_t max_regions_;
-
-  // Access to memory regions using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
-
-  // The list of descriptors.  This is maintained separately from the list
-  // of regions, because MemoryRegion doesn't own its MemoryDescriptor, it
-  // maintains a pointer to it.  descriptors_ provides the storage for this
-  // purpose.
-  MemoryDescriptors *descriptors_;
-
-  // The list of regions.
-  MemoryRegions *regions_;
-  uint32_t region_count_;
-};
-
-
-// MinidumpException wraps MDRawExceptionStream, which contains information
-// about the exception that caused the minidump to be generated, if the
-// minidump was generated in an exception handler called as a result of an
-// exception.  It also provides access to a MinidumpContext object, which
-// contains the CPU context for the exception thread at the time the exception
-// occurred.
-class MinidumpException : public MinidumpStream {
- public:
-  virtual ~MinidumpException();
-
-  const MDRawExceptionStream* exception() const {
-    return valid_ ? &exception_ : NULL;
-  }
-
-  // The thread ID is used to determine if a thread is the exception thread,
-  // so a special getter is provided to retrieve this data from the
-  // MDRawExceptionStream structure.  Returns false if the thread ID cannot
-  // be determined.
-  bool GetThreadID(uint32_t *thread_id) const;
-
-  MinidumpContext* GetContext();
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-
-  static const uint32_t kStreamType = MD_EXCEPTION_STREAM;
-
-  explicit MinidumpException(Minidump* minidump);
-
-  bool Read(uint32_t expected_size);
-
-  MDRawExceptionStream exception_;
-  MinidumpContext*     context_;
-};
-
-// MinidumpAssertion wraps MDRawAssertionInfo, which contains information
-// about an assertion that caused the minidump to be generated.
-class MinidumpAssertion : public MinidumpStream {
- public:
-  virtual ~MinidumpAssertion();
-
-  const MDRawAssertionInfo* assertion() const {
-    return valid_ ? &assertion_ : NULL;
-  }
-
-  string expression() const {
-    return valid_ ? expression_ : "";
-  }
-
-  string function() const {
-    return valid_ ? function_ : "";
-  }
-
-  string file() const {
-    return valid_ ? file_ : "";
-  }
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-
-  static const uint32_t kStreamType = MD_ASSERTION_INFO_STREAM;
-
-  explicit MinidumpAssertion(Minidump* minidump);
-
-  bool Read(uint32_t expected_size);
-
-  MDRawAssertionInfo assertion_;
-  string expression_;
-  string function_;
-  string file_;
-};
-
-
-// MinidumpSystemInfo wraps MDRawSystemInfo and provides information about
-// the system on which the minidump was generated.  See also MinidumpMiscInfo.
-class MinidumpSystemInfo : public MinidumpStream {
- public:
-  virtual ~MinidumpSystemInfo();
-
-  const MDRawSystemInfo* system_info() const {
-    return valid_ ? &system_info_ : NULL;
-  }
-
-  // GetOS and GetCPU return textual representations of the operating system
-  // and CPU that produced the minidump.  Unlike most other Minidump* methods,
-  // they return string objects, not weak pointers.  Defined values for
-  // GetOS() are "mac", "windows", and "linux".  Defined values for GetCPU
-  // are "x86" and "ppc".  These methods return an empty string when their
-  // values are unknown.
-  string GetOS();
-  string GetCPU();
-
-  // I don't know what CSD stands for, but this field is documented as
-  // returning a textual representation of the OS service pack.  On other
-  // platforms, this provides additional information about an OS version
-  // level beyond major.minor.micro.  Returns NULL if unknown.
-  const string* GetCSDVersion();
-
-  // If a CPU vendor string can be determined, returns a pointer to it,
-  // otherwise, returns NULL.  CPU vendor strings can be determined from
-  // x86 CPUs with CPUID 0.
-  const string* GetCPUVendor();
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- protected:
-  explicit MinidumpSystemInfo(Minidump* minidump);
-  MDRawSystemInfo system_info_;
-
-  // Textual representation of the OS service pack, for minidumps produced
-  // by MiniDumpWriteDump on Windows.
-  const string* csd_version_;
-
- private:
-  friend class Minidump;
-
-  static const uint32_t kStreamType = MD_SYSTEM_INFO_STREAM;
-
-  bool Read(uint32_t expected_size);
-
-  // A string identifying the CPU vendor, if known.
-  const string* cpu_vendor_;
-};
-
-
-// MinidumpMiscInfo wraps MDRawMiscInfo and provides information about
-// the process that generated the minidump, and optionally additional system
-// information.  See also MinidumpSystemInfo.
-class MinidumpMiscInfo : public MinidumpStream {
- public:
-  const MDRawMiscInfo* misc_info() const {
-    return valid_ ? &misc_info_ : NULL;
-  }
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-  friend class TestMinidumpMiscInfo;
-
-  static const uint32_t kStreamType = MD_MISC_INFO_STREAM;
-
-  explicit MinidumpMiscInfo(Minidump* minidump_);
-
-  bool Read(uint32_t expected_size_);
-
-  MDRawMiscInfo misc_info_;
-
-  // Populated by Read.  Contains the converted strings from the corresponding
-  // UTF-16 fields in misc_info_
-  string standard_name_;
-  string daylight_name_;
-  string build_string_;
-  string dbg_bld_str_;
-};
-
-
-// MinidumpBreakpadInfo wraps MDRawBreakpadInfo, which is an optional stream in
-// a minidump that provides additional information about the process state
-// at the time the minidump was generated.
-class MinidumpBreakpadInfo : public MinidumpStream {
- public:
-  const MDRawBreakpadInfo* breakpad_info() const {
-    return valid_ ? &breakpad_info_ : NULL;
-  }
-
-  // These thread IDs are used to determine if threads deserve special
-  // treatment, so special getters are provided to retrieve this data from
-  // the MDRawBreakpadInfo structure.  The getters return false if the thread
-  // IDs cannot be determined.
-  bool GetDumpThreadID(uint32_t *thread_id) const;
-  bool GetRequestingThreadID(uint32_t *thread_id) const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-
-  static const uint32_t kStreamType = MD_BREAKPAD_INFO_STREAM;
-
-  explicit MinidumpBreakpadInfo(Minidump* minidump_);
-
-  bool Read(uint32_t expected_size_);
-
-  MDRawBreakpadInfo breakpad_info_;
-};
-
-// MinidumpMemoryInfo wraps MDRawMemoryInfo, which provides information
-// about mapped memory regions in a process, including their ranges
-// and protection.
-class MinidumpMemoryInfo : public MinidumpObject {
- public:
-  const MDRawMemoryInfo* info() const { return valid_ ? &memory_info_ : NULL; }
-
-  // The address of the base of the memory region.
-  uint64_t GetBase() const { return valid_ ? memory_info_.base_address : 0; }
-
-  // The size, in bytes, of the memory region.
-  uint64_t GetSize() const { return valid_ ? memory_info_.region_size : 0; }
-
-  // Return true if the memory protection allows execution.
-  bool IsExecutable() const;
-
-  // Return true if the memory protection allows writing.
-  bool IsWritable() const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  // These objects are managed by MinidumpMemoryInfoList.
-  friend class MinidumpMemoryInfoList;
-
-  explicit MinidumpMemoryInfo(Minidump* minidump_);
-
-  // This works like MinidumpStream::Read, but is driven by
-  // MinidumpMemoryInfoList.  No size checking is done, because
-  // MinidumpMemoryInfoList handles that directly.
-  bool Read();
-
-  MDRawMemoryInfo memory_info_;
-};
-
-// MinidumpMemoryInfoList contains a list of information about
-// mapped memory regions for a process in the form of MDRawMemoryInfo.
-// It maintains a map of these structures so that it may easily provide
-// info corresponding to a specific address.
-class MinidumpMemoryInfoList : public MinidumpStream {
- public:
-  virtual ~MinidumpMemoryInfoList();
-
-  unsigned int info_count() const { return valid_ ? info_count_ : 0; }
-
-  const MinidumpMemoryInfo* GetMemoryInfoForAddress(uint64_t address) const;
-  const MinidumpMemoryInfo* GetMemoryInfoAtIndex(unsigned int index) const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  friend class Minidump;
-
-  typedef vector<MinidumpMemoryInfo> MinidumpMemoryInfos;
-
-  static const uint32_t kStreamType = MD_MEMORY_INFO_LIST_STREAM;
-
-  explicit MinidumpMemoryInfoList(Minidump* minidump_);
-
-  bool Read(uint32_t expected_size);
-
-  // Access to memory info using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
-
-  MinidumpMemoryInfos* infos_;
-  uint32_t info_count_;
-};
-
-// MinidumpLinuxMaps wraps information about a single mapped memory region
-// from /proc/self/maps.
-class MinidumpLinuxMaps : public MinidumpObject {
- public:
-  // The memory address of the base of the mapped region.
-  uint64_t GetBase() const { return valid_ ? region_.start : 0; }
-  // The size of the mapped region.
-  uint64_t GetSize() const { return valid_ ? region_.end - region_.start : 0; }
-
-  // The permissions of the mapped region.
-  bool IsReadable() const {
-    return valid_ ? region_.permissions & MappedMemoryRegion::READ : false;
-  }
-  bool IsWriteable() const {
-    return valid_ ? region_.permissions & MappedMemoryRegion::WRITE : false;
-  }
-  bool IsExecutable() const {
-    return valid_ ? region_.permissions & MappedMemoryRegion::EXECUTE : false;
-  }
-  bool IsPrivate() const {
-    return valid_ ? region_.permissions & MappedMemoryRegion::PRIVATE : false;
-  }
-
-  // The offset of the mapped region.
-  uint64_t GetOffset() const { return valid_ ? region_.offset : 0; }
-
-  // The major device number.
-  uint8_t GetMajorDevice() const { return valid_ ? region_.major_device : 0; }
-  // The minor device number.
-  uint8_t GetMinorDevice() const { return valid_ ? region_.minor_device : 0; }
-
-  // The inode of the mapped region.
-  uint64_t GetInode() const { return valid_ ? region_.inode : 0; }
-
-  // The pathname of the mapped region.
-  const string GetPathname() const { return valid_ ? region_.path : ""; }
-
-  // Print the contents of this mapping.
-  void Print() const;
-
- private:
-  // These objects are managed by MinidumpLinuxMapsList.
-  friend class MinidumpLinuxMapsList;
-
-  // This caller owns the pointer.
-  explicit MinidumpLinuxMaps(Minidump *minidump);
-
-  // The memory region struct that this class wraps.
-  MappedMemoryRegion region_;
-
-  DISALLOW_COPY_AND_ASSIGN(MinidumpLinuxMaps);
-};
-
-// MinidumpLinuxMapsList corresponds to the Linux-exclusive MD_LINUX_MAPS
-// stream, which contains the contents of /prod/self/maps, which contains
-// the mapped memory regions and their access permissions.
-class MinidumpLinuxMapsList : public MinidumpStream {
- public:
-  virtual ~MinidumpLinuxMapsList();
-
-  // Get number of mappings.
-  unsigned int get_maps_count() const { return valid_ ? maps_count_ : 0; }
-
-  // Get mapping at the given memory address. The caller owns the pointer.
-  const MinidumpLinuxMaps *GetLinuxMapsForAddress(uint64_t address) const;
-  // Get mapping at the given index. The caller owns the pointer.
-  const MinidumpLinuxMaps *GetLinuxMapsAtIndex(unsigned int index) const;
-
-  // Print the contents of /proc/self/maps to stdout.
-  void Print() const;
-
- private:
-  friend class Minidump;
-
-  typedef vector<MinidumpLinuxMaps *> MinidumpLinuxMappings;
-
-  static const uint32_t kStreamType = MD_LINUX_MAPS;
-
-  // The caller owns the pointer.
-  explicit MinidumpLinuxMapsList(Minidump *minidump);
-
-  // Read and load the contents of the process mapping data.
-  // The stream should have data in the form of /proc/self/maps.
-  // This method returns whether the stream was read successfully.
-  bool Read(uint32_t expected_size);
-
-  // The list of individual mappings.
-  MinidumpLinuxMappings *maps_;
-  // The number of mappings.
-  uint32_t maps_count_;
-
-  DISALLOW_COPY_AND_ASSIGN(MinidumpLinuxMapsList);
-};
-
-// Minidump is the user's interface to a minidump file.  It wraps MDRawHeader
-// and provides access to the minidump's top-level stream directory.
-class Minidump {
- public:
-  // path is the pathname of a file containing the minidump.
-  explicit Minidump(const string& path);
-  // input is an istream wrapping minidump data. Minidump holds a
-  // weak pointer to input, and the caller must ensure that the stream
-  // is valid as long as the Minidump object is.
-  explicit Minidump(std::istream& input);
-
-  virtual ~Minidump();
-
-  // path may be empty if the minidump was not opened from a file
-  virtual string path() const {
-    return path_;
-  }
-  static void set_max_streams(uint32_t max_streams) {
-    max_streams_ = max_streams;
-  }
-  static uint32_t max_streams() { return max_streams_; }
-
-  static void set_max_string_length(uint32_t max_string_length) {
-    max_string_length_ = max_string_length;
-  }
-  static uint32_t max_string_length() { return max_string_length_; }
-
-  virtual const MDRawHeader* header() const { return valid_ ? &header_ : NULL; }
-
-  // Reads the CPU information from the system info stream and generates the
-  // appropriate CPU flags.  The returned context_cpu_flags are the same as
-  // if the CPU type bits were set in the context_flags of a context record.
-  // On success, context_cpu_flags will have the flags that identify the CPU.
-  // If a system info stream is missing, context_cpu_flags will be 0.
-  // Returns true if the current position in the stream was not changed.
-  // Returns false when the current location in the stream was changed and the
-  // attempt to restore the original position failed.
-  bool GetContextCPUFlagsFromSystemInfo(uint32_t* context_cpu_flags);
-
-  // Reads the minidump file's header and top-level stream directory.
-  // The minidump is expected to be positioned at the beginning of the
-  // header.  Read() sets up the stream list and map, and validates the
-  // Minidump object.
-  virtual bool Read();
-
-  // The next set of methods are stubs that call GetStream.  They exist to
-  // force code generation of the templatized API within the module, and
-  // to avoid exposing an ugly API (GetStream needs to accept a garbage
-  // parameter).
-  virtual MinidumpThreadList* GetThreadList();
-  virtual MinidumpModuleList* GetModuleList();
-  virtual MinidumpMemoryList* GetMemoryList();
-  virtual MinidumpException* GetException();
-  virtual MinidumpAssertion* GetAssertion();
-  virtual MinidumpSystemInfo* GetSystemInfo();
-  virtual MinidumpMiscInfo* GetMiscInfo();
-  virtual MinidumpBreakpadInfo* GetBreakpadInfo();
-  virtual MinidumpMemoryInfoList* GetMemoryInfoList();
-
-  // The next method also calls GetStream, but is exclusive for Linux dumps.
-  virtual MinidumpLinuxMapsList *GetLinuxMapsList();
-
-  // The next set of methods are provided for users who wish to access
-  // data in minidump files directly, while leveraging the rest of
-  // this class and related classes to handle the basic minidump
-  // structure and known stream types.
-
-  unsigned int GetDirectoryEntryCount() const {
-    return valid_ ? header_.stream_count : 0;
-  }
-  const MDRawDirectory* GetDirectoryEntryAtIndex(unsigned int index) const;
-
-  // The next 2 methods are lower-level I/O routines.  They use fd_.
-
-  // Reads count bytes from the minidump at the current position into
-  // the storage area pointed to by bytes.  bytes must be of sufficient
-  // size.  After the read, the file position is advanced by count.
-  bool ReadBytes(void* bytes, size_t count);
-
-  // Sets the position of the minidump file to offset.
-  bool SeekSet(off_t offset);
-
-  // Returns the current position of the minidump file.
-  off_t Tell();
-
-  // The next 2 methods are medium-level I/O routines.
-
-  // ReadString returns a string which is owned by the caller!  offset
-  // specifies the offset that a length-encoded string is stored at in the
-  // minidump file.
-  string* ReadString(off_t offset);
-
-  // SeekToStreamType positions the file at the beginning of a stream
-  // identified by stream_type, and informs the caller of the stream's
-  // length by setting *stream_length.  Because stream_map maps each stream
-  // type to only one stream in the file, this might mislead the user into
-  // thinking that the stream that this seeks to is the only stream with
-  // type stream_type.  That can't happen for streams that these classes
-  // deal with directly, because they're only supposed to be present in the
-  // file singly, and that's verified when stream_map_ is built.  Users who
-  // are looking for other stream types should be aware of this
-  // possibility, and consider using GetDirectoryEntryAtIndex (possibly
-  // with GetDirectoryEntryCount) if expecting multiple streams of the same
-  // type in a single minidump file.
-  bool SeekToStreamType(uint32_t stream_type, uint32_t* stream_length);
-
-  bool swap() const { return valid_ ? swap_ : false; }
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
- private:
-  // MinidumpStreamInfo is used in the MinidumpStreamMap.  It lets
-  // the Minidump object locate interesting streams quickly, and
-  // provides a convenient place to stash MinidumpStream objects.
-  struct MinidumpStreamInfo {
-    MinidumpStreamInfo() : stream_index(0), stream(NULL) {}
-    ~MinidumpStreamInfo() { delete stream; }
-
-    // Index into the MinidumpDirectoryEntries vector
-    unsigned int    stream_index;
-
-    // Pointer to the stream if cached, or NULL if not yet populated
-    MinidumpStream* stream;
-  };
-
-  typedef vector<MDRawDirectory> MinidumpDirectoryEntries;
-  typedef map<uint32_t, MinidumpStreamInfo> MinidumpStreamMap;
-
-  template<typename T> T* GetStream(T** stream);
-
-  // Opens the minidump file, or if already open, seeks to the beginning.
-  bool Open();
-
-  // The largest number of top-level streams that will be read from a minidump.
-  // Note that streams are only read (and only consume memory) as needed,
-  // when directed by the caller.  The default is 128.
-  static uint32_t max_streams_;
-
-  // The maximum length of a UTF-16 string that will be read from a minidump
-  // in 16-bit words.  The default is 1024.  UTF-16 strings are converted
-  // to UTF-8 when stored in memory, and each UTF-16 word will be represented
-  // by as many as 3 bytes in UTF-8.
-  static unsigned int max_string_length_;
-
-  MDRawHeader               header_;
-
-  // The list of streams.
-  MinidumpDirectoryEntries* directory_;
-
-  // Access to streams using the stream type as the key.
-  MinidumpStreamMap*        stream_map_;
-
-  // The pathname of the minidump file to process, set in the constructor.
-  // This may be empty if the minidump was opened directly from a stream.
-  const string              path_;
-
-  // The stream for all file I/O.  Used by ReadBytes and SeekSet.
-  // Set based on the path in Open, or directly in the constructor.
-  std::istream*             stream_;
-
-  // swap_ is true if the minidump file should be byte-swapped.  If the
-  // minidump was produced by a CPU that is other-endian than the CPU
-  // processing the minidump, this will be true.  If the two CPUs are
-  // same-endian, this will be false.
-  bool                      swap_;
-
-  // Validity of the Minidump structure, false immediately after
-  // construction or after a failed Read(); true following a successful
-  // Read().
-  bool                      valid_;
-};
-
-
-}  // namespace google_breakpad
-
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump_processor.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump_processor.h
deleted file mode 100644
index 387115ef7..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/minidump_processor.h
+++ /dev/null
@@ -1,147 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_PROCESSOR_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_PROCESSOR_H__
-
-#include <assert.h>
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/process_result.h"
-
-namespace google_breakpad {
-
-class Minidump;
-class ProcessState;
-class StackFrameSymbolizer;
-class SourceLineResolverInterface;
-class SymbolSupplier;
-struct SystemInfo;
-
-class MinidumpProcessor {
- public:
-  // Initializes this MinidumpProcessor.  supplier should be an
-  // implementation of the SymbolSupplier abstract base class.
-  MinidumpProcessor(SymbolSupplier* supplier,
-                    SourceLineResolverInterface* resolver);
-
-  // Initializes the MinidumpProcessor with the option of
-  // enabling the exploitability framework to analyze dumps
-  // for probable security relevance.
-  MinidumpProcessor(SymbolSupplier* supplier,
-                    SourceLineResolverInterface* resolver,
-                    bool enable_exploitability);
-
-  // Initializes the MinidumpProcessor with source line resolver helper, and
-  // the option of enabling the exploitability framework to analyze dumps
-  // for probable security relevance.
-  // Does not take ownership of resolver_helper, which must NOT be NULL.
-  MinidumpProcessor(StackFrameSymbolizer* stack_frame_symbolizer,
-                    bool enable_exploitability);
-
-  ~MinidumpProcessor();
-
-  // Processes the minidump file and fills process_state with the result.
-  ProcessResult Process(const string &minidump_file,
-                        ProcessState* process_state);
-
-  // Processes the minidump structure and fills process_state with the
-  // result.
-  ProcessResult Process(Minidump* minidump,
-                        ProcessState* process_state);
-  // Populates the cpu_* fields of the |info| parameter with textual
-  // representations of the CPU type that the minidump in |dump| was
-  // produced on.  Returns false if this information is not available in
-  // the minidump.
-  static bool GetCPUInfo(Minidump* dump, SystemInfo* info);
-
-  // Populates the os_* fields of the |info| parameter with textual
-  // representations of the operating system that the minidump in |dump|
-  // was produced on.  Returns false if this information is not available in
-  // the minidump.
-  static bool GetOSInfo(Minidump* dump, SystemInfo* info);
-
-  // Populates the |process_create_time| parameter with the create time of the
-  // crashed process.  Returns false if this information is not available in
-  // the minidump |dump|.
-  static bool GetProcessCreateTime(Minidump* dump,
-                                   uint32_t* process_create_time);
-
-  // Returns a textual representation of the reason that a crash occurred,
-  // if the minidump in dump was produced as a result of a crash.  Returns
-  // an empty string if this information cannot be determined.  If address
-  // is non-NULL, it will be set to contain the address that caused the
-  // exception, if this information is available.  This will be a code
-  // address when the crash was caused by problems such as illegal
-  // instructions or divisions by zero, or a data address when the crash
-  // was caused by a memory access violation.
-  static string GetCrashReason(Minidump* dump, uint64_t* address);
-
-  // This function returns true if the passed-in error code is
-  // something unrecoverable(i.e. retry should not happen).  For
-  // instance, if the minidump is corrupt, then it makes no sense to
-  // retry as we won't be able to glean additional information.
-  // However, as an example of the other case, the symbol supplier can
-  // return an error code indicating it was 'interrupted', which can
-  // happen of the symbols are fetched from a remote store, and a
-  // retry might be successful later on.
-  // You should not call this method with PROCESS_OK! Test for
-  // that separately before calling this.
-  static bool IsErrorUnrecoverable(ProcessResult p) {
-    assert(p !=  PROCESS_OK);
-    return (p != PROCESS_SYMBOL_SUPPLIER_INTERRUPTED);
-  }
-
-  // Returns a textual representation of an assertion included
-  // in the minidump.  Returns an empty string if this information
-  // does not exist or cannot be determined.
-  static string GetAssertion(Minidump* dump);
-
-  void set_enable_objdump(bool enabled) { enable_objdump_ = enabled; }
-
- private:
-  StackFrameSymbolizer* frame_symbolizer_;
-  // Indicate whether resolver_helper_ is owned by this instance.
-  bool own_frame_symbolizer_;
-
-  // This flag enables the exploitability scanner which attempts to
-  // guess how likely it is that the crash represents an exploitable
-  // memory corruption issue.
-  bool enable_exploitability_;
-
-  // This flag permits the exploitability scanner to shell out to objdump
-  // for purposes of disassembly.
-  bool enable_objdump_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_PROCESSOR_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/proc_maps_linux.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/proc_maps_linux.h
deleted file mode 100644
index b8e6eb926..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/proc_maps_linux.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef BASE_DEBUG_PROC_MAPS_LINUX_H_
-#define BASE_DEBUG_PROC_MAPS_LINUX_H_
-
-#include <string>
-#include <vector>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-
-// Describes a region of mapped memory and the path of the file mapped.
-struct MappedMemoryRegion {
-  enum Permission {
-    READ = 1 << 0,
-    WRITE = 1 << 1,
-    EXECUTE = 1 << 2,
-    PRIVATE = 1 << 3,  // If set, region is private, otherwise it is shared.
-  };
-
-  // The address range [start,end) of mapped memory.
-  uint64_t start;
-  uint64_t end;
-
-  // Byte offset into |path| of the range mapped into memory.
-  uint64_t offset;
-
-  // Bitmask of read/write/execute/private/shared permissions.
-  uint8_t permissions;
-
-  // Major and minor devices.
-  uint8_t major_device;
-  uint8_t minor_device;
-
-  // Value of the inode.
-  uint64_t inode;
-
-  // Name of the file mapped into memory.
-  //
-  // NOTE: path names aren't guaranteed to point at valid files. For example,
-  // "[heap]" and "[stack]" are used to represent the location of the process'
-  // heap and stack, respectively.
-  string path;
-
-  // The line from /proc/<pid>/maps that this struct represents.
-  string line;
-};
-
-// Parses /proc/<pid>/maps input data and stores in |regions|. Returns true
-// and updates |regions| if and only if all of |input| was successfully parsed.
-bool ParseProcMaps(const std::string& input,
-                   std::vector<MappedMemoryRegion>* regions);
-
-}  // namespace google_breakpad
-
-#endif  // BASE_DEBUG_PROC_MAPS_LINUX_H_
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/process_result.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/process_result.h
deleted file mode 100644
index 15c7213e9..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/process_result.h
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright (c) 2014, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
-
-namespace google_breakpad {
-
-// Return type for MinidumpProcessor or MicrodumpProcessor's Process()
-enum ProcessResult {
-  PROCESS_OK,                                  // The dump was processed
-                                               // successfully.
-
-  PROCESS_ERROR_MINIDUMP_NOT_FOUND,            // The minidump file was not
-                                               // found.
-
-  PROCESS_ERROR_NO_MINIDUMP_HEADER,            // The minidump file had no
-                                               // header.
-
-  PROCESS_ERROR_NO_THREAD_LIST,                // The minidump file has no
-                                               // thread list.
-
-  PROCESS_ERROR_GETTING_THREAD,                // There was an error getting one
-                                               // thread's data from th dump.
-
-  PROCESS_ERROR_GETTING_THREAD_ID,             // There was an error getting a
-                                               // thread id from the thread's
-                                               // data.
-
-  PROCESS_ERROR_DUPLICATE_REQUESTING_THREADS,  // There was more than one
-                                               // requesting thread.
-
-  PROCESS_SYMBOL_SUPPLIER_INTERRUPTED          // The dump processing was
-                                               // interrupted by the
-                                               // SymbolSupplier(not fatal).
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/process_state.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/process_state.h
deleted file mode 100644
index 728656f2b..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/process_state.h
+++ /dev/null
@@ -1,189 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// process_state.h: A snapshot of a process, in a fully-digested state.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_PROCESS_STATE_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_PROCESS_STATE_H__
-
-#include <string>
-#include <vector>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/system_info.h"
-#include "google_breakpad/processor/minidump.h"
-
-namespace google_breakpad {
-
-using std::vector;
-
-class CallStack;
-class CodeModules;
-
-enum ExploitabilityRating {
-  EXPLOITABILITY_HIGH,                 // The crash likely represents
-                                       // a exploitable memory corruption
-                                       // vulnerability.
-
-  EXPLOITABILITY_MEDIUM,               // The crash appears to corrupt
-                                       // memory in a way which may be
-                                       // exploitable in some situations.
-
-  EXPLOITABLITY_MEDIUM = EXPLOITABILITY_MEDIUM,  // an old misspelling
-
-  EXPLOITABILITY_LOW,                  // The crash either does not corrupt
-                                       // memory directly or control over
-                                       // the affected data is limited. The
-                                       // issue may still be exploitable
-                                       // on certain platforms or situations.
-
-  EXPLOITABILITY_INTERESTING,          // The crash does not appear to be
-                                       // directly exploitable. However it
-                                       // represents a condition which should
-                                       // be further analyzed.
-
-  EXPLOITABILITY_NONE,                 // The crash does not appear to represent
-                                       // an exploitable condition.
-
-  EXPLOITABILITY_NOT_ANALYZED,         // The crash was not analyzed for
-                                       // exploitability because the engine
-                                       // was disabled.
-
-  EXPLOITABILITY_ERR_NOENGINE,         // The supplied minidump's platform does
-                                       // not have a exploitability engine
-                                       // associated with it.
-
-  EXPLOITABILITY_ERR_PROCESSING        // An error occured within the
-                                       // exploitability engine and no rating
-                                       // was calculated.
-};
-
-class ProcessState {
- public:
-  ProcessState() : modules_(NULL) { Clear(); }
-  ~ProcessState();
-
-  // Resets the ProcessState to its default values
-  void Clear();
-
-  // Accessors.  See the data declarations below.
-  uint32_t time_date_stamp() const { return time_date_stamp_; }
-  uint32_t process_create_time() const { return process_create_time_; }
-  bool crashed() const { return crashed_; }
-  string crash_reason() const { return crash_reason_; }
-  uint64_t crash_address() const { return crash_address_; }
-  string assertion() const { return assertion_; }
-  int requesting_thread() const { return requesting_thread_; }
-  const vector<CallStack*>* threads() const { return &threads_; }
-  const vector<MemoryRegion*>* thread_memory_regions() const {
-    return &thread_memory_regions_;
-  }
-  const SystemInfo* system_info() const { return &system_info_; }
-  const CodeModules* modules() const { return modules_; }
-  const vector<const CodeModule*>* modules_without_symbols() const {
-    return &modules_without_symbols_;
-  }
-  const vector<const CodeModule*>* modules_with_corrupt_symbols() const {
-    return &modules_with_corrupt_symbols_;
-  }
-  ExploitabilityRating exploitability() const { return exploitability_; }
-
- private:
-  // MinidumpProcessor and MicrodumpProcessor are responsible for building
-  // ProcessState objects.
-  friend class MinidumpProcessor;
-  friend class MicrodumpProcessor;
-
-  // The time-date stamp of the minidump (time_t format)
-  uint32_t time_date_stamp_;
-
-  // The time-date stamp when the process was created (time_t format)
-  uint32_t process_create_time_;
-
-  // True if the process crashed, false if the dump was produced outside
-  // of an exception handler.
-  bool crashed_;
-
-  // If the process crashed, the type of crash.  OS- and possibly CPU-
-  // specific.  For example, "EXCEPTION_ACCESS_VIOLATION" (Windows),
-  // "EXC_BAD_ACCESS / KERN_INVALID_ADDRESS" (Mac OS X), "SIGSEGV"
-  // (other Unix).
-  string crash_reason_;
-
-  // If the process crashed, and if crash_reason implicates memory,
-  // the memory address that caused the crash.  For data access errors,
-  // this will be the data address that caused the fault.  For code errors,
-  // this will be the address of the instruction that caused the fault.
-  uint64_t crash_address_;
-
-  // If there was an assertion that was hit, a textual representation
-  // of that assertion, possibly including the file and line at which
-  // it occurred.
-  string assertion_;
-
-  // The index of the thread that requested a dump be written in the
-  // threads vector.  If a dump was produced as a result of a crash, this
-  // will point to the thread that crashed.  If the dump was produced as
-  // by user code without crashing, and the dump contains extended Breakpad
-  // information, this will point to the thread that requested the dump.
-  // If the dump was not produced as a result of an exception and no
-  // extended Breakpad information is present, this field will be set to -1,
-  // indicating that the dump thread is not available.
-  int requesting_thread_;
-
-  // Stacks for each thread (except possibly the exception handler
-  // thread) at the time of the crash.
-  vector<CallStack*> threads_;
-  vector<MemoryRegion*> thread_memory_regions_;
-
-  // OS and CPU information.
-  SystemInfo system_info_;
-
-  // The modules that were loaded into the process represented by the
-  // ProcessState.
-  const CodeModules *modules_;
-
-  // The modules that didn't have symbols when the report was processed.
-  vector<const CodeModule*> modules_without_symbols_;
-
-  // The modules that had corrupt symbols when the report was processed.
-  vector<const CodeModule*> modules_with_corrupt_symbols_;
-
-  // The exploitability rating as determined by the exploitability
-  // engine. When the exploitability engine is not enabled this
-  // defaults to EXPLOITABILITY_NOT_ANALYZED.
-  ExploitabilityRating exploitability_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_PROCESS_STATE_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_base.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_base.h
deleted file mode 100644
index c720b0c32..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_base.h
+++ /dev/null
@@ -1,128 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// source_line_resolver_base.h: SourceLineResolverBase, an (incomplete)
-// implementation of SourceLineResolverInterface.  It serves as a common base
-// class for concrete implementations: FastSourceLineResolver and
-// BasicSourceLineResolver.  It is designed for refactoring that removes
-// code redundancy in the two concrete source line resolver classes.
-//
-// See "google_breakpad/processor/source_line_resolver_interface.h" for more
-// documentation.
-
-// Author: Siyang Xie (lambxsy@google.com)
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_BASE_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_BASE_H__
-
-#include <map>
-#include <set>
-#include <string>
-
-#include "google_breakpad/processor/source_line_resolver_interface.h"
-
-namespace google_breakpad {
-
-using std::map;
-using std::set;
-
-// Forward declaration.
-// ModuleFactory is a simple factory interface for creating a Module instance
-// at run-time.
-class ModuleFactory;
-
-class SourceLineResolverBase : public SourceLineResolverInterface {
- public:
-  // Read the symbol_data from a file with given file_name.
-  // The part of code was originally in BasicSourceLineResolver::Module's
-  // LoadMap() method.
-  // Place dynamically allocated heap buffer in symbol_data. Caller has the
-  // ownership of the buffer, and should call delete [] to free the buffer.
-  static bool ReadSymbolFile(const string &file_name,
-                             char **symbol_data,
-                             size_t *symbol_data_size);
-
- protected:
-  // Users are not allowed create SourceLineResolverBase instance directly.
-  SourceLineResolverBase(ModuleFactory *module_factory);
-  virtual ~SourceLineResolverBase();
-
-  // Virtual methods inherited from SourceLineResolverInterface.
-  virtual bool LoadModule(const CodeModule *module, const string &map_file);
-  virtual bool LoadModuleUsingMapBuffer(const CodeModule *module,
-                                        const string &map_buffer);
-  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule *module,
-                                           char *memory_buffer,
-                                           size_t memory_buffer_size);
-  virtual bool ShouldDeleteMemoryBufferAfterLoadModule();
-  virtual void UnloadModule(const CodeModule *module);
-  virtual bool HasModule(const CodeModule *module);
-  virtual bool IsModuleCorrupt(const CodeModule *module);
-  virtual void FillSourceLineInfo(StackFrame *frame);
-  virtual WindowsFrameInfo *FindWindowsFrameInfo(const StackFrame *frame);
-  virtual CFIFrameInfo *FindCFIFrameInfo(const StackFrame *frame);
-
-  // Nested structs and classes.
-  struct Line;
-  struct Function;
-  struct PublicSymbol;
-  struct CompareString {
-    bool operator()(const string &s1, const string &s2) const;
-  };
-  // Module is an interface for an in-memory symbol file.
-  class Module;
-  class AutoFileCloser;
-
-  // All of the modules that are loaded.
-  typedef map<string, Module*, CompareString> ModuleMap;
-  ModuleMap *modules_;
-
-  // The loaded modules that were detecting to be corrupt during load.
-  typedef set<string, CompareString> ModuleSet;
-  ModuleSet *corrupt_modules_;
-
-  // All of heap-allocated buffers that are owned locally by resolver.
-  typedef std::map<string, char*, CompareString> MemoryMap;
-  MemoryMap *memory_buffers_;
-
-  // Creates a concrete module at run-time.
-  ModuleFactory *module_factory_;
-
- private:
-  // ModuleFactory needs to have access to protected type Module.
-  friend class ModuleFactory;
-
-  // Disallow unwanted copy ctor and assignment operator
-  SourceLineResolverBase(const SourceLineResolverBase&);
-  void operator=(const SourceLineResolverBase&);
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_BASE_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_interface.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_interface.h
deleted file mode 100644
index a694bf2ea..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/source_line_resolver_interface.h
+++ /dev/null
@@ -1,117 +0,0 @@
-// -*- mode: C++ -*-
-
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Abstract interface to return function/file/line info for a memory address.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_INTERFACE_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_INTERFACE_H__
-
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/code_module.h"
-
-namespace google_breakpad {
-
-struct StackFrame;
-struct WindowsFrameInfo;
-class CFIFrameInfo;
-
-class SourceLineResolverInterface {
- public:
-  typedef uint64_t MemAddr;
-
-  virtual ~SourceLineResolverInterface() {}
-
-  // Adds a module to this resolver, returning true on success.
-  //
-  // module should have at least the code_file, debug_file,
-  // and debug_identifier members populated.
-  //
-  // map_file should contain line/address mappings for this module.
-  virtual bool LoadModule(const CodeModule *module,
-                          const string &map_file) = 0;
-  // Same as above, but takes the contents of a pre-read map buffer
-  virtual bool LoadModuleUsingMapBuffer(const CodeModule *module,
-                                        const string &map_buffer) = 0;
-
-  // Add an interface to load symbol using C-String data instead of string.
-  // This is useful in the optimization design for avoiding unnecessary copying
-  // of symbol data, in order to improve memory efficiency.
-  // LoadModuleUsingMemoryBuffer() does NOT take ownership of memory_buffer.
-  // LoadModuleUsingMemoryBuffer() null terminates the passed in buffer, if
-  // the last character is not a null terminator.
-  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule *module,
-                                           char *memory_buffer,
-                                           size_t memory_buffer_size) = 0;
-
-  // Return true if the memory buffer should be deleted immediately after
-  // LoadModuleUsingMemoryBuffer(). Return false if the memory buffer has to be
-  // alive during the lifetime of the corresponding Module.
-  virtual bool ShouldDeleteMemoryBufferAfterLoadModule() = 0;
-
-  // Request that the specified module be unloaded from this resolver.
-  // A resolver may choose to ignore such a request.
-  virtual void UnloadModule(const CodeModule *module) = 0;
-
-  // Returns true if the module has been loaded.
-  virtual bool HasModule(const CodeModule *module) = 0;
-
-  // Returns true if the module has been loaded and it is corrupt.
-  virtual bool IsModuleCorrupt(const CodeModule *module) = 0;
-
-  // Fills in the function_base, function_name, source_file_name,
-  // and source_line fields of the StackFrame.  The instruction and
-  // module_name fields must already be filled in.
-  virtual void FillSourceLineInfo(StackFrame *frame) = 0;
-
-  // If Windows stack walking information is available covering
-  // FRAME's instruction address, return a WindowsFrameInfo structure
-  // describing it. If the information is not available, returns NULL.
-  // A NULL return value does not indicate an error. The caller takes
-  // ownership of any returned WindowsFrameInfo object.
-  virtual WindowsFrameInfo *FindWindowsFrameInfo(const StackFrame *frame) = 0;
-
-  // If CFI stack walking information is available covering ADDRESS,
-  // return a CFIFrameInfo structure describing it. If the information
-  // is not available, return NULL. The caller takes ownership of any
-  // returned CFIFrameInfo object.
-  virtual CFIFrameInfo *FindCFIFrameInfo(const StackFrame *frame) = 0;
-
- protected:
-  // SourceLineResolverInterface cannot be instantiated except by subclasses
-  SourceLineResolverInterface() {}
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_SOURCE_LINE_RESOLVER_INTERFACE_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame.h
deleted file mode 100644
index b55eb9c75..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_H__
-
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-
-namespace google_breakpad {
-
-class CodeModule;
-
-struct StackFrame {
-  // Indicates how well the instruction pointer derived during
-  // stack walking is trusted. Since the stack walker can resort to
-  // stack scanning, it can wind up with dubious frames.
-  // In rough order of "trust metric".
-  enum FrameTrust {
-    FRAME_TRUST_NONE,      // Unknown
-    FRAME_TRUST_SCAN,      // Scanned the stack, found this
-    FRAME_TRUST_CFI_SCAN,  // Found while scanning stack using call frame info
-    FRAME_TRUST_FP,        // Derived from frame pointer
-    FRAME_TRUST_CFI,       // Derived from call frame info
-    FRAME_TRUST_PREWALKED, // Explicitly provided by some external stack walker.
-    FRAME_TRUST_CONTEXT    // Given as instruction pointer in a context
-  };
-
-  StackFrame()
-      : instruction(),
-        module(NULL),
-        function_name(),
-        function_base(),
-        source_file_name(),
-        source_line(),
-        source_line_base(),
-        trust(FRAME_TRUST_NONE) {}
-  virtual ~StackFrame() {}
-
-  // Return a string describing how this stack frame was found
-  // by the stackwalker.
-  string trust_description() const {
-    switch (trust) {
-      case StackFrame::FRAME_TRUST_CONTEXT:
-        return "given as instruction pointer in context";
-      case StackFrame::FRAME_TRUST_PREWALKED:
-        return "recovered by external stack walker";
-      case StackFrame::FRAME_TRUST_CFI:
-        return "call frame info";
-      case StackFrame::FRAME_TRUST_CFI_SCAN:
-        return "call frame info with scanning";
-      case StackFrame::FRAME_TRUST_FP:
-        return "previous frame's frame pointer";
-      case StackFrame::FRAME_TRUST_SCAN:
-        return "stack scanning";
-      default:
-        return "unknown";
-    }
-  };
-
-  // Return the actual return address, as saved on the stack or in a
-  // register. See the comments for 'instruction', below, for details.
-  virtual uint64_t ReturnAddress() const { return instruction; }
-
-  // The program counter location as an absolute virtual address.
-  //
-  // - For the innermost called frame in a stack, this will be an exact
-  //   program counter or instruction pointer value.
-  //
-  // - For all other frames, this address is within the instruction that
-  //   caused execution to branch to this frame's callee (although it may
-  //   not point to the exact beginning of that instruction). This ensures
-  //   that, when we look up the source code location for this frame, we
-  //   get the source location of the call, not of the point at which
-  //   control will resume when the call returns, which may be on the next
-  //   line. (If the compiler knows the callee never returns, it may even
-  //   place the call instruction at the very end of the caller's machine
-  //   code, such that the "return address" (which will never be used)
-  //   immediately after the call instruction is in an entirely different
-  //   function, perhaps even from a different source file.)
-  //
-  // On some architectures, the return address as saved on the stack or in
-  // a register is fine for looking up the point of the call. On others, it
-  // requires adjustment. ReturnAddress returns the address as saved by the
-  // machine.
-  uint64_t instruction;
-
-  // The module in which the instruction resides.
-  const CodeModule *module;
-
-  // The function name, may be omitted if debug symbols are not available.
-  string function_name;
-
-  // The start address of the function, may be omitted if debug symbols
-  // are not available.
-  uint64_t function_base;
-
-  // The source file name, may be omitted if debug symbols are not available.
-  string source_file_name;
-
-  // The (1-based) source line number, may be omitted if debug symbols are
-  // not available.
-  int source_line;
-
-  // The start address of the source line, may be omitted if debug symbols
-  // are not available.
-  uint64_t source_line_base;
-
-  // Amount of trust the stack walker has in the instruction pointer
-  // of this frame.
-  FrameTrust trust;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_cpu.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_cpu.h
deleted file mode 100644
index dc5d8ae67..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_cpu.h
+++ /dev/null
@@ -1,405 +0,0 @@
-// -*- mode: c++ -*-
-
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// stack_frame_cpu.h: CPU-specific StackFrame extensions.
-//
-// These types extend the StackFrame structure to carry CPU-specific register
-// state.  They are defined in this header instead of stack_frame.h to
-// avoid the need to include minidump_format.h when only the generic
-// StackFrame type is needed.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
-
-#include "google_breakpad/common/minidump_format.h"
-#include "google_breakpad/processor/stack_frame.h"
-
-namespace google_breakpad {
-
-struct WindowsFrameInfo;
-class CFIFrameInfo;
-
-struct StackFrameX86 : public StackFrame {
-  // ContextValidity has one entry for each relevant hardware pointer
-  // register (%eip and %esp) and one entry for each general-purpose
-  // register. It's worthwhile having validity flags for caller-saves
-  // registers: they are valid in the youngest frame, and such a frame
-  // might save a callee-saves register in a caller-saves register, but
-  // SimpleCFIWalker won't touch registers unless they're marked as valid.
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_EIP  = 1 << 0,
-    CONTEXT_VALID_ESP  = 1 << 1,
-    CONTEXT_VALID_EBP  = 1 << 2,
-    CONTEXT_VALID_EAX  = 1 << 3,
-    CONTEXT_VALID_EBX  = 1 << 4,
-    CONTEXT_VALID_ECX  = 1 << 5,
-    CONTEXT_VALID_EDX  = 1 << 6,
-    CONTEXT_VALID_ESI  = 1 << 7,
-    CONTEXT_VALID_EDI  = 1 << 8,
-    CONTEXT_VALID_ALL  = -1
-  };
-
-  StackFrameX86()
-     : context(),
-       context_validity(CONTEXT_VALID_NONE),
-       windows_frame_info(NULL),
-       cfi_frame_info(NULL) {}
-  ~StackFrameX86();
-
-  // Overriden to return the return address as saved on the stack.
-  virtual uint64_t ReturnAddress() const;
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextX86 context;
-
-  // context_validity is actually ContextValidity, but int is used because
-  // the OR operator doesn't work well with enumerated types.  This indicates
-  // which fields in context are valid.
-  int context_validity;
-
-  // Any stack walking information we found describing this.instruction.
-  // These may be NULL if there is no such information for that address.
-  WindowsFrameInfo *windows_frame_info;
-  CFIFrameInfo *cfi_frame_info;
-};
-
-struct StackFramePPC : public StackFrame {
-  // ContextValidity should eventually contain entries for the validity of
-  // other nonvolatile (callee-save) registers as in
-  // StackFrameX86::ContextValidity, but the ppc stackwalker doesn't currently
-  // locate registers other than the ones listed here.
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_SRR0 = 1 << 0,
-    CONTEXT_VALID_GPR1 = 1 << 1,
-    CONTEXT_VALID_ALL  = -1
-  };
-
-  StackFramePPC() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextPPC context;
-
-  // context_validity is actually ContextValidity, but int is used because
-  // the OR operator doesn't work well with enumerated types.  This indicates
-  // which fields in context are valid.
-  int context_validity;
-};
-
-struct StackFramePPC64 : public StackFrame {
-  // ContextValidity should eventually contain entries for the validity of
-  // other nonvolatile (callee-save) registers as in
-  // StackFrameX86::ContextValidity, but the ppc stackwalker doesn't currently
-  // locate registers other than the ones listed here.
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_SRR0 = 1 << 0,
-    CONTEXT_VALID_GPR1 = 1 << 1,
-    CONTEXT_VALID_ALL  = -1
-  };
-
-  StackFramePPC64() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextPPC64 context;
-
-  // context_validity is actually ContextValidity, but int is used because
-  // the OR operator doesn't work well with enumerated types.  This indicates
-  // which fields in context are valid.
-  int context_validity;
-};
-
-struct StackFrameAMD64 : public StackFrame {
-  // ContextValidity has one entry for each register that we might be able
-  // to recover.
-  enum ContextValidity {
-    CONTEXT_VALID_NONE  = 0,
-    CONTEXT_VALID_RAX   = 1 << 0,
-    CONTEXT_VALID_RDX   = 1 << 1,
-    CONTEXT_VALID_RCX   = 1 << 2,
-    CONTEXT_VALID_RBX   = 1 << 3,
-    CONTEXT_VALID_RSI   = 1 << 4,
-    CONTEXT_VALID_RDI   = 1 << 5,
-    CONTEXT_VALID_RBP   = 1 << 6,
-    CONTEXT_VALID_RSP   = 1 << 7,
-    CONTEXT_VALID_R8    = 1 << 8,
-    CONTEXT_VALID_R9    = 1 << 9,
-    CONTEXT_VALID_R10   = 1 << 10,
-    CONTEXT_VALID_R11   = 1 << 11,
-    CONTEXT_VALID_R12   = 1 << 12,
-    CONTEXT_VALID_R13   = 1 << 13,
-    CONTEXT_VALID_R14   = 1 << 14,
-    CONTEXT_VALID_R15   = 1 << 15,
-    CONTEXT_VALID_RIP   = 1 << 16,
-    CONTEXT_VALID_ALL  = -1
-  };
-
-  StackFrameAMD64() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Overriden to return the return address as saved on the stack.
-  virtual uint64_t ReturnAddress() const;
-
-  // Register state. This is only fully valid for the topmost frame in a
-  // stack. In other frames, which registers are present depends on what
-  // debugging information we had available. Refer to context_validity.
-  MDRawContextAMD64 context;
-
-  // For each register in context whose value has been recovered, we set
-  // the corresponding CONTEXT_VALID_ bit in context_validity.
-  //
-  // context_validity's type should actually be ContextValidity, but
-  // we use int instead because the bitwise inclusive or operator
-  // yields an int when applied to enum values, and C++ doesn't
-  // silently convert from ints to enums.
-  int context_validity;
-};
-
-struct StackFrameSPARC : public StackFrame {
-  // to be confirmed
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_PC   = 1 << 0,
-    CONTEXT_VALID_SP   = 1 << 1,
-    CONTEXT_VALID_FP   = 1 << 2,
-    CONTEXT_VALID_ALL  = -1
-  };
-
-  StackFrameSPARC() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextSPARC context;
-
-  // context_validity is actually ContextValidity, but int is used because
-  // the OR operator doesn't work well with enumerated types.  This indicates
-  // which fields in context are valid.
-  int context_validity;
-};
-
-struct StackFrameARM : public StackFrame {
-  // A flag for each register we might know.
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_R0   = 1 << 0,
-    CONTEXT_VALID_R1   = 1 << 1,
-    CONTEXT_VALID_R2   = 1 << 2,
-    CONTEXT_VALID_R3   = 1 << 3,
-    CONTEXT_VALID_R4   = 1 << 4,
-    CONTEXT_VALID_R5   = 1 << 5,
-    CONTEXT_VALID_R6   = 1 << 6,
-    CONTEXT_VALID_R7   = 1 << 7,
-    CONTEXT_VALID_R8   = 1 << 8,
-    CONTEXT_VALID_R9   = 1 << 9,
-    CONTEXT_VALID_R10  = 1 << 10,
-    CONTEXT_VALID_R11  = 1 << 11,
-    CONTEXT_VALID_R12  = 1 << 12,
-    CONTEXT_VALID_R13  = 1 << 13,
-    CONTEXT_VALID_R14  = 1 << 14,
-    CONTEXT_VALID_R15  = 1 << 15,
-    CONTEXT_VALID_ALL  = ~CONTEXT_VALID_NONE,
-
-    // Aliases for registers with dedicated or conventional roles.
-    CONTEXT_VALID_FP   = CONTEXT_VALID_R11,
-    CONTEXT_VALID_SP   = CONTEXT_VALID_R13,
-    CONTEXT_VALID_LR   = CONTEXT_VALID_R14,
-    CONTEXT_VALID_PC   = CONTEXT_VALID_R15
-  };
-
-  StackFrameARM() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Return the ContextValidity flag for register rN.
-  static ContextValidity RegisterValidFlag(int n) {
-    return ContextValidity(1 << n);
-  }
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextARM context;
-
-  // For each register in context whose value has been recovered, we set
-  // the corresponding CONTEXT_VALID_ bit in context_validity.
-  //
-  // context_validity's type should actually be ContextValidity, but
-  // we use int instead because the bitwise inclusive or operator
-  // yields an int when applied to enum values, and C++ doesn't
-  // silently convert from ints to enums.
-  int context_validity;
-};
-
-struct StackFrameARM64 : public StackFrame {
-  // A flag for each register we might know. Note that we can't use an enum
-  // here as there are 33 values to represent.
-  static const uint64_t CONTEXT_VALID_NONE = 0;
-  static const uint64_t CONTEXT_VALID_X0   = 1ULL << 0;
-  static const uint64_t CONTEXT_VALID_X1   = 1ULL << 1;
-  static const uint64_t CONTEXT_VALID_X2   = 1ULL << 2;
-  static const uint64_t CONTEXT_VALID_X3   = 1ULL << 3;
-  static const uint64_t CONTEXT_VALID_X4   = 1ULL << 4;
-  static const uint64_t CONTEXT_VALID_X5   = 1ULL << 5;
-  static const uint64_t CONTEXT_VALID_X6   = 1ULL << 6;
-  static const uint64_t CONTEXT_VALID_X7   = 1ULL << 7;
-  static const uint64_t CONTEXT_VALID_X8   = 1ULL << 8;
-  static const uint64_t CONTEXT_VALID_X9   = 1ULL << 9;
-  static const uint64_t CONTEXT_VALID_X10  = 1ULL << 10;
-  static const uint64_t CONTEXT_VALID_X11  = 1ULL << 11;
-  static const uint64_t CONTEXT_VALID_X12  = 1ULL << 12;
-  static const uint64_t CONTEXT_VALID_X13  = 1ULL << 13;
-  static const uint64_t CONTEXT_VALID_X14  = 1ULL << 14;
-  static const uint64_t CONTEXT_VALID_X15  = 1ULL << 15;
-  static const uint64_t CONTEXT_VALID_X16  = 1ULL << 16;
-  static const uint64_t CONTEXT_VALID_X17  = 1ULL << 17;
-  static const uint64_t CONTEXT_VALID_X18  = 1ULL << 18;
-  static const uint64_t CONTEXT_VALID_X19  = 1ULL << 19;
-  static const uint64_t CONTEXT_VALID_X20  = 1ULL << 20;
-  static const uint64_t CONTEXT_VALID_X21  = 1ULL << 21;
-  static const uint64_t CONTEXT_VALID_X22  = 1ULL << 22;
-  static const uint64_t CONTEXT_VALID_X23  = 1ULL << 23;
-  static const uint64_t CONTEXT_VALID_X24  = 1ULL << 24;
-  static const uint64_t CONTEXT_VALID_X25  = 1ULL << 25;
-  static const uint64_t CONTEXT_VALID_X26  = 1ULL << 26;
-  static const uint64_t CONTEXT_VALID_X27  = 1ULL << 27;
-  static const uint64_t CONTEXT_VALID_X28  = 1ULL << 28;
-  static const uint64_t CONTEXT_VALID_X29  = 1ULL << 29;
-  static const uint64_t CONTEXT_VALID_X30  = 1ULL << 30;
-  static const uint64_t CONTEXT_VALID_X31  = 1ULL << 31;
-  static const uint64_t CONTEXT_VALID_X32  = 1ULL << 32;
-  static const uint64_t CONTEXT_VALID_ALL  = ~CONTEXT_VALID_NONE;
-
-  // Aliases for registers with dedicated or conventional roles.
-  static const uint64_t CONTEXT_VALID_FP   = CONTEXT_VALID_X29;
-  static const uint64_t CONTEXT_VALID_LR   = CONTEXT_VALID_X30;
-  static const uint64_t CONTEXT_VALID_SP   = CONTEXT_VALID_X31;
-  static const uint64_t CONTEXT_VALID_PC   = CONTEXT_VALID_X32;
-
-  StackFrameARM64() : context(),
-                      context_validity(CONTEXT_VALID_NONE) {}
-
-  // Return the validity flag for register xN.
-  static uint64_t RegisterValidFlag(int n) {
-    return 1ULL << n;
-  }
-
-  // Register state.  This is only fully valid for the topmost frame in a
-  // stack.  In other frames, the values of nonvolatile registers may be
-  // present, given sufficient debugging information.  Refer to
-  // context_validity.
-  MDRawContextARM64 context;
-
-  // For each register in context whose value has been recovered, we set
-  // the corresponding CONTEXT_VALID_ bit in context_validity.
-  uint64_t context_validity;
-};
-
-struct StackFrameMIPS : public StackFrame {  
-  // MIPS callee save registers for o32 ABI (32bit registers) are: 
-  // 1. $s0-$s7, 
-  // 2. $sp, $fp
-  // 3. $f20-$f31 
-  // 
-  // The register structure is available at
-  // http://en.wikipedia.org/wiki/MIPS_architecture#Compiler_register_usage
-
-#define INDEX_MIPS_REG_S0 MD_CONTEXT_MIPS_REG_S0  // 16
-#define INDEX_MIPS_REG_S7 MD_CONTEXT_MIPS_REG_S7  // 23
-#define INDEX_MIPS_REG_GP MD_CONTEXT_MIPS_REG_GP  // 28
-#define INDEX_MIPS_REG_RA MD_CONTEXT_MIPS_REG_RA  // 31
-#define INDEX_MIPS_REG_PC 34 
-#define SHIFT_MIPS_REG_S0 0
-#define SHIFT_MIPS_REG_GP 8
-#define SHIFT_MIPS_REG_PC 12 
-
-  enum ContextValidity {
-    CONTEXT_VALID_NONE = 0,
-    CONTEXT_VALID_S0 = 1 << 0,  // $16
-    CONTEXT_VALID_S1 = 1 << 1,  // $17
-    CONTEXT_VALID_S2 = 1 << 2,  // $18
-    CONTEXT_VALID_S3 = 1 << 3,  // $19
-    CONTEXT_VALID_S4 = 1 << 4,  // $20
-    CONTEXT_VALID_S5 = 1 << 5,  // $21
-    CONTEXT_VALID_S6 = 1 << 6,  // $22
-    CONTEXT_VALID_S7 = 1 << 7,  // $23
-    // GP is not calee-save for o32 abi.
-    CONTEXT_VALID_GP = 1 << 8,  // $28
-    CONTEXT_VALID_SP = 1 << 9,  // $29
-    CONTEXT_VALID_FP = 1 << 10,  // $30
-    CONTEXT_VALID_RA = 1 << 11,  // $31  
-    CONTEXT_VALID_PC = 1 << 12,  // $34
-    CONTEXT_VALID_ALL = ~CONTEXT_VALID_NONE
-  };
-  
-  // Return the ContextValidity flag for register rN.
-  static ContextValidity RegisterValidFlag(int n) {
-    if (n >= INDEX_MIPS_REG_S0 && n <= INDEX_MIPS_REG_S7)
-      return ContextValidity(1 << (n - INDEX_MIPS_REG_S0 + SHIFT_MIPS_REG_S0));
-    else if (n >= INDEX_MIPS_REG_GP && n <= INDEX_MIPS_REG_RA)
-      return ContextValidity(1 << (n - INDEX_MIPS_REG_GP + SHIFT_MIPS_REG_GP));
-    else if (n == INDEX_MIPS_REG_PC)
-      return ContextValidity(1 << SHIFT_MIPS_REG_PC);
-
-    return CONTEXT_VALID_NONE;
-  }
-
-  StackFrameMIPS() : context(), context_validity(CONTEXT_VALID_NONE) {}
-
-  // Register state. This is only fully valid for the topmost frame in a
-  // stack. In other frames, which registers are present depends on what
-  // debugging information were available. Refer to 'context_validity' below.
-  MDRawContextMIPS context;   
-
-  // For each register in context whose value has been recovered,
-  // the corresponding CONTEXT_VALID_ bit in 'context_validity' is set.
-  //
-  // context_validity's type should actually be ContextValidity, but
-  // type int is used instead because the bitwise inclusive or operator
-  // yields an int when applied to enum values, and C++ doesn't
-  // silently convert from ints to enums.
-  int context_validity;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_symbolizer.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_symbolizer.h
deleted file mode 100644
index 074907cb1..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/stack_frame_symbolizer.h
+++ /dev/null
@@ -1,108 +0,0 @@
-// -*- mode: C++ -*-
-
-// Copyright (c) 2012 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Helper class that encapsulates the logic of how symbol supplier interacts
-// with source line resolver to fill stack frame information.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_SYMBOLIZER_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_SYMBOLIZER_H__
-
-#include <set>
-#include <string>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/code_module.h"
-
-namespace google_breakpad {
-class CFIFrameInfo;
-class CodeModules;
-class SymbolSupplier;
-class SourceLineResolverInterface;
-struct StackFrame;
-struct SystemInfo;
-struct WindowsFrameInfo;
-
-class StackFrameSymbolizer {
- public:
-  enum SymbolizerResult {
-    // Symbol data was found and successfully loaded in resolver.
-    // This does NOT guarantee source line info is found within symbol file.
-    kNoError,
-    // This indicates non-critical error, such as, no code module found for
-    // frame's instruction, no symbol file, or resolver failed to load symbol.
-    kError,
-    // This indicates error for which stack walk should be interrupted
-    // and retried in future.
-    kInterrupt,
-    // Symbol data was found and loaded in resolver however some corruptions
-    // were detected.
-    kWarningCorruptSymbols,
-  };
-
-  StackFrameSymbolizer(SymbolSupplier* supplier,
-                       SourceLineResolverInterface* resolver);
-
-  virtual ~StackFrameSymbolizer() { }
-
-  // Encapsulate the step of resolving source line info for a stack frame.
-  // "frame" must not be NULL.
-  virtual SymbolizerResult FillSourceLineInfo(const CodeModules* modules,
-                                              const SystemInfo* system_info,
-                                              StackFrame* stack_frame);
-
-  virtual WindowsFrameInfo* FindWindowsFrameInfo(const StackFrame* frame);
-
-  virtual CFIFrameInfo* FindCFIFrameInfo(const StackFrame* frame);
-
-  // Reset internal (locally owned) data as if the helper is re-instantiated.
-  // A typical case is to call Reset() after processing an individual report
-  // before start to process next one, in order to reset internal information
-  // about missing symbols found so far.
-  virtual void Reset() { no_symbol_modules_.clear(); }
-
-  // Returns true if there is valid implementation for stack symbolization.
-  virtual bool HasImplementation() { return resolver_ && supplier_; }
-
-  SourceLineResolverInterface* resolver() { return resolver_; }
-  SymbolSupplier* supplier() { return supplier_; }
-
- protected:
-  SymbolSupplier* supplier_;
-  SourceLineResolverInterface* resolver_;
-  // A list of modules known to have symbols missing. This helps avoid
-  // repeated lookups for the missing symbols within one minidump.
-  std::set<string> no_symbol_modules_;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_SYMBOLIZER_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/stackwalker.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/stackwalker.h
deleted file mode 100644
index a1bd3e7fe..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/stackwalker.h
+++ /dev/null
@@ -1,235 +0,0 @@
-// Copyright (c) 2010 Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// stackwalker.h: Generic stackwalker.
-//
-// The Stackwalker class is an abstract base class providing common generic
-// methods that apply to stacks from all systems.  Specific implementations
-// will extend this class by providing GetContextFrame and GetCallerFrame
-// methods to fill in system-specific data in a StackFrame structure.
-// Stackwalker assembles these StackFrame strucutres into a CallStack.
-//
-// Author: Mark Mentovai
-
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_STACKWALKER_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_STACKWALKER_H__
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "common/using_std_string.h"
-#include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/code_modules.h"
-#include "google_breakpad/processor/memory_region.h"
-#include "google_breakpad/processor/stack_frame_symbolizer.h"
-
-namespace google_breakpad {
-
-class CallStack;
-class DumpContext;
-class StackFrameSymbolizer;
-
-using std::set;
-using std::vector;
-
-class Stackwalker {
- public:
-  virtual ~Stackwalker() {}
-
-  // Populates the given CallStack by calling GetContextFrame and
-  // GetCallerFrame.  The frames are further processed to fill all available
-  // data.  Returns true if the stackwalk completed, or false if it was
-  // interrupted by SymbolSupplier::GetSymbolFile().
-  // Upon return, |modules_without_symbols| will be populated with pointers to
-  // the code modules (CodeModule*) that DON'T have symbols.
-  // |modules_with_corrupt_symbols| will be populated with pointers to the
-  // modules which have corrupt symbols.  |modules_without_symbols| and
-  // |modules_with_corrupt_symbols| DO NOT take ownership of the code modules.
-  // The lifetime of these code modules is the same as the lifetime of the
-  // CodeModules passed to the StackWalker constructor (which currently
-  // happens to be the lifetime of the Breakpad's ProcessingState object).
-  // There is a check for duplicate modules so no duplicates are expected.
-  bool Walk(CallStack* stack,
-            vector<const CodeModule*>* modules_without_symbols,
-            vector<const CodeModule*>* modules_with_corrupt_symbols);
-
-  // Returns a new concrete subclass suitable for the CPU that a stack was
-  // generated on, according to the CPU type indicated by the context
-  // argument.  If no suitable concrete subclass exists, returns NULL.
-  static Stackwalker* StackwalkerForCPU(
-     const SystemInfo* system_info,
-     DumpContext* context,
-     MemoryRegion* memory,
-     const CodeModules* modules,
-     StackFrameSymbolizer* resolver_helper);
-
-  static void set_max_frames(uint32_t max_frames) {
-    max_frames_ = max_frames;
-    max_frames_set_ = true;
-  }
-  static uint32_t max_frames() { return max_frames_; }
-
-  static void set_max_frames_scanned(uint32_t max_frames_scanned) {
-    max_frames_scanned_ = max_frames_scanned;
-  }
-
- protected:
-  // system_info identifies the operating system, NULL or empty if unknown.
-  // memory identifies a MemoryRegion that provides the stack memory
-  // for the stack to walk.  modules, if non-NULL, is a CodeModules
-  // object that is used to look up which code module each stack frame is
-  // associated with.  frame_symbolizer is a StackFrameSymbolizer object that
-  // encapsulates the logic of how source line resolver interacts with symbol
-  // supplier to symbolize stack frame and look up caller frame information
-  // (see stack_frame_symbolizer.h).
-  // frame_symbolizer MUST NOT be NULL (asserted).
-  Stackwalker(const SystemInfo* system_info,
-              MemoryRegion* memory,
-              const CodeModules* modules,
-              StackFrameSymbolizer* frame_symbolizer);
-
-  // This can be used to filter out potential return addresses when
-  // the stack walker resorts to stack scanning.
-  // Returns true if any of:
-  // * This address is within a loaded module, but we don't have symbols
-  //   for that module.
-  // * This address is within a loaded module for which we have symbols,
-  //   and falls inside a function in that module.
-  // Returns false otherwise.
-  bool InstructionAddressSeemsValid(uint64_t address);
-
-  // The default number of words to search through on the stack
-  // for a return address.
-  static const int kRASearchWords;
-
-  template<typename InstructionType>
-  bool ScanForReturnAddress(InstructionType location_start,
-                            InstructionType* location_found,
-                            InstructionType* ip_found,
-                            bool is_context_frame) {
-    // When searching for the caller of the context frame,
-    // allow the scanner to look farther down the stack.
-    const int search_words = is_context_frame ?
-      kRASearchWords * 4 :
-      kRASearchWords;
-
-    return ScanForReturnAddress(location_start, location_found, ip_found,
-                                search_words);
-  }
-
-  // Scan the stack starting at location_start, looking for an address
-  // that looks like a valid instruction pointer. Addresses must
-  // 1) be contained in the current stack memory
-  // 2) pass the checks in InstructionAddressSeemsValid
-  //
-  // Returns true if a valid-looking instruction pointer was found.
-  // When returning true, sets location_found to the address at which
-  // the value was found, and ip_found to the value contained at that
-  // location in memory.
-  template<typename InstructionType>
-  bool ScanForReturnAddress(InstructionType location_start,
-                            InstructionType* location_found,
-                            InstructionType* ip_found,
-                            int searchwords) {
-    for (InstructionType location = location_start;
-         location <= location_start + searchwords * sizeof(InstructionType);
-         location += sizeof(InstructionType)) {
-      InstructionType ip;
-      if (!memory_->GetMemoryAtAddress(location, &ip))
-        break;
-
-      if (modules_ && modules_->GetModuleForAddress(ip) &&
-          InstructionAddressSeemsValid(ip)) {
-        *ip_found = ip;
-        *location_found = location;
-        return true;
-      }
-    }
-    // nothing found
-    return false;
-  }
-
-  // Information about the system that produced the minidump.  Subclasses
-  // and the SymbolSupplier may find this information useful.
-  const SystemInfo* system_info_;
-
-  // The stack memory to walk.  Subclasses will require this region to
-  // get information from the stack.
-  MemoryRegion* memory_;
-
-  // A list of modules, for populating each StackFrame's module information.
-  // This field is optional and may be NULL.
-  const CodeModules* modules_;
-
- protected:
-  // The StackFrameSymbolizer implementation.
-  StackFrameSymbolizer* frame_symbolizer_;
-
- private:
-  // Obtains the context frame, the innermost called procedure in a stack
-  // trace.  Returns NULL on failure.  GetContextFrame allocates a new
-  // StackFrame (or StackFrame subclass), ownership of which is taken by
-  // the caller.
-  virtual StackFrame* GetContextFrame() = 0;
-
-  // Obtains a caller frame.  Each call to GetCallerFrame should return the
-  // frame that called the last frame returned by GetContextFrame or
-  // GetCallerFrame.  To aid this purpose, stack contains the CallStack
-  // made of frames that have already been walked.  GetCallerFrame should
-  // return NULL on failure or when there are no more caller frames (when
-  // the end of the stack has been reached).  GetCallerFrame allocates a new
-  // StackFrame (or StackFrame subclass), ownership of which is taken by
-  // the caller.  |stack_scan_allowed| controls whether stack scanning is
-  // an allowable frame-recovery method, since it is desirable to be able to
-  // disable stack scanning in performance-critical use cases.
-  virtual StackFrame* GetCallerFrame(const CallStack* stack,
-                                     bool stack_scan_allowed) = 0;
-
-  // The maximum number of frames Stackwalker will walk through.
-  // This defaults to 1024 to prevent infinite loops.
-  static uint32_t max_frames_;
-
-  // Keep track of whether max_frames_ has been set by the user, since
-  // it affects whether or not an error message is printed in the case
-  // where an unwind got stopped by the limit.
-  static bool max_frames_set_;
-
-  // The maximum number of stack-scanned and otherwise untrustworthy
-  // frames allowed.  Stack-scanning can be expensive, so the option to
-  // disable or limit it is helpful in cases where unwind performance is
-  // important.  This defaults to 1024, the same as max_frames_.
-  static uint32_t max_frames_scanned_;
-};
-
-}  // namespace google_breakpad
-
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_STACKWALKER_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/symbol_supplier.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/symbol_supplier.h
deleted file mode 100644
index a042081f3..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/symbol_supplier.h
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// The caller may implement the SymbolSupplier abstract base class
-// to provide symbols for a given module.
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_SYMBOL_SUPPLIER_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_SYMBOL_SUPPLIER_H__
-
-#include <string>
-#include "common/using_std_string.h"
-
-namespace google_breakpad {
-
-class CodeModule;
-struct SystemInfo;
-
-class SymbolSupplier {
- public:
-  // Result type for GetSymbolFile
-  enum SymbolResult {
-    // no symbols were found, but continue processing
-    NOT_FOUND,
-
-    // symbols were found, and the path has been placed in symbol_file
-    FOUND,
-
-    // stops processing the minidump immediately
-    INTERRUPT
-  };
-
-  virtual ~SymbolSupplier() {}
-
-  // Retrieves the symbol file for the given CodeModule, placing the
-  // path in symbol_file if successful.  system_info contains strings
-  // identifying the operating system and CPU; SymbolSupplier may use
-  // to help locate the symbol file.  system_info may be NULL or its
-  // fields may be empty if these values are unknown.  symbol_file
-  // must be a pointer to a valid string
-  virtual SymbolResult GetSymbolFile(const CodeModule *module,
-                                     const SystemInfo *system_info,
-                                     string *symbol_file) = 0;
-  // Same as above, except also places symbol data into symbol_data.
-  // If symbol_data is NULL, the data is not returned.
-  // TODO(nealsid) Once we have symbol data caching behavior implemented
-  // investigate making all symbol suppliers implement all methods,
-  // and make this pure virtual
-  virtual SymbolResult GetSymbolFile(const CodeModule *module,
-                                     const SystemInfo *system_info,
-                                     string *symbol_file,
-                                     string *symbol_data) = 0;
-
-  // Same as above, except allocates data buffer on heap and then places the
-  // symbol data into the buffer as C-string.
-  // SymbolSupplier is responsible for deleting the data buffer. After the call
-  // to GetCStringSymbolData(), the caller should call FreeSymbolData(const
-  // Module *module) once the data buffer is no longer needed.
-  // If symbol_data is not NULL, symbol supplier won't return FOUND unless it
-  // returns a valid buffer in symbol_data, e.g., returns INTERRUPT on memory
-  // allocation failure.
-  virtual SymbolResult GetCStringSymbolData(const CodeModule *module,
-                                            const SystemInfo *system_info,
-                                            string *symbol_file,
-                                            char **symbol_data,
-                                            size_t *symbol_data_size) = 0;
-
-  // Frees the data buffer allocated for the module in GetCStringSymbolData.
-  virtual void FreeSymbolData(const CodeModule *module) = 0;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_SYMBOL_SUPPLIER_H__
diff --git a/TMessagesProj/jni/breakpad/google_breakpad/processor/system_info.h b/TMessagesProj/jni/breakpad/google_breakpad/processor/system_info.h
deleted file mode 100644
index 9583d9e89..000000000
--- a/TMessagesProj/jni/breakpad/google_breakpad/processor/system_info.h
+++ /dev/null
@@ -1,98 +0,0 @@
-// Copyright (c) 2006, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// system_info.h: Information about the system that was running a program
-// when a crash report was produced.
-//
-// Author: Mark Mentovai
-
-#ifndef GOOGLE_BREAKPAD_PROCESSOR_SYSTEM_INFO_H__
-#define GOOGLE_BREAKPAD_PROCESSOR_SYSTEM_INFO_H__
-
-#include <string>
-
-#include "common/using_std_string.h"
-
-namespace google_breakpad {
-
-struct SystemInfo {
- public:
-  SystemInfo() : os(), os_short(), os_version(), cpu(), cpu_info(),
-    cpu_count(0) {}
-
-  // Resets the SystemInfo object to its default values.
-  void Clear() {
-    os.clear();
-    os_short.clear();
-    os_version.clear();
-    cpu.clear();
-    cpu_info.clear();
-    cpu_count = 0;
-  }
-
-  // A string identifying the operating system, such as "Windows NT",
-  // "Mac OS X", or "Linux".  If the information is present in the dump but
-  // its value is unknown, this field will contain a numeric value.  If
-  // the information is not present in the dump, this field will be empty.
-  string os;
-
-  // A short form of the os string, using lowercase letters and no spaces,
-  // suitable for use in a filesystem.  Possible values include "windows",
-  // "mac", "linux" and "nacl".  Empty if the information is not present
-  // in the dump or if the OS given by the dump is unknown.  The values
-  // stored in this field should match those used by
-  // MinidumpSystemInfo::GetOS.
-  string os_short;
-
-  // A string identifying the version of the operating system, such as
-  // "5.1.2600 Service Pack 2" or "10.4.8 8L2127".  If the dump does not
-  // contain this information, this field will be empty.
-  string os_version;
-
-  // A string identifying the basic CPU family, such as "x86" or "ppc".
-  // If this information is present in the dump but its value is unknown,
-  // this field will contain a numeric value.  If the information is not
-  // present in the dump, this field will be empty.  The values stored in
-  // this field should match those used by MinidumpSystemInfo::GetCPU.
-  string cpu;
-
-  // A string further identifying the specific CPU, such as
-  // "GenuineIntel level 6 model 13 stepping 8".  If the information is not
-  // present in the dump, or additional identifying information is not
-  // defined for the CPU family, this field will be empty.
-  string cpu_info;
-
-  // The number of processors in the system.  Will be greater than one for
-  // multi-core systems.
-  int cpu_count;
-};
-
-}  // namespace google_breakpad
-
-#endif  // GOOGLE_BREAKPAD_PROCESSOR_SYSTEM_INFO_H__
diff --git a/TMessagesProj/jni/breakpad/third_party/lss/linux_syscall_support.h b/TMessagesProj/jni/breakpad/third_party/lss/linux_syscall_support.h
deleted file mode 100644
index 1fe0ae89e..000000000
--- a/TMessagesProj/jni/breakpad/third_party/lss/linux_syscall_support.h
+++ /dev/null
@@ -1,4029 +0,0 @@
-/* Copyright (c) 2005-2011, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * ---
- * Author: Markus Gutschke
- */
-
-/* This file includes Linux-specific support functions common to the
- * coredumper and the thread lister; primarily, this is a collection
- * of direct system calls, and a couple of symbols missing from
- * standard header files.
- * There are a few options that the including file can set to control
- * the behavior of this file:
- *
- * SYS_CPLUSPLUS:
- *   The entire header file will normally be wrapped in 'extern "C" { }",
- *   making it suitable for compilation as both C and C++ source. If you
- *   do not want to do this, you can set the SYS_CPLUSPLUS macro to inhibit
- *   the wrapping. N.B. doing so will suppress inclusion of all prerequisite
- *   system header files, too. It is the caller's responsibility to provide
- *   the necessary definitions.
- *
- * SYS_ERRNO:
- *   All system calls will update "errno" unless overriden by setting the
- *   SYS_ERRNO macro prior to including this file. SYS_ERRNO should be
- *   an l-value.
- *
- * SYS_INLINE:
- *   New symbols will be defined "static inline", unless overridden by
- *   the SYS_INLINE macro.
- *
- * SYS_LINUX_SYSCALL_SUPPORT_H
- *   This macro is used to avoid multiple inclusions of this header file.
- *   If you need to include this file more than once, make sure to
- *   unset SYS_LINUX_SYSCALL_SUPPORT_H before each inclusion.
- *
- * SYS_PREFIX:
- *   New system calls will have a prefix of "sys_" unless overridden by
- *   the SYS_PREFIX macro. Valid values for this macro are [0..9] which
- *   results in prefixes "sys[0..9]_". It is also possible to set this
- *   macro to -1, which avoids all prefixes.
- *
- * SYS_SYSCALL_ENTRYPOINT:
- *   Some applications (such as sandboxes that filter system calls), need
- *   to be able to run custom-code each time a system call is made. If this
- *   macro is defined, it expands to the name of a "common" symbol. If
- *   this symbol is assigned a non-NULL pointer value, it is used as the
- *   address of the system call entrypoint.
- *   A pointer to this symbol can be obtained by calling
- *   get_syscall_entrypoint()
- *
- * This file defines a few internal symbols that all start with "LSS_".
- * Do not access these symbols from outside this file. They are not part
- * of the supported API.
- */
-#ifndef SYS_LINUX_SYSCALL_SUPPORT_H
-#define SYS_LINUX_SYSCALL_SUPPORT_H
-
-/* We currently only support x86-32, x86-64, ARM, MIPS, and PPC on Linux.
- * Porting to other related platforms should not be difficult.
- */
-#if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) ||   \
-     defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__) || \
-     defined(__aarch64__)) \
-  && (defined(__linux) || defined(__ANDROID__))
-
-#ifndef SYS_CPLUSPLUS
-#ifdef __cplusplus
-/* Some system header files in older versions of gcc neglect to properly
- * handle being included from C++. As it appears to be harmless to have
- * multiple nested 'extern "C"' blocks, just add another one here.
- */
-extern "C" {
-#endif
-
-#include <errno.h>
-#include <fcntl.h>
-#include <sched.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <string.h>
-#include <sys/ptrace.h>
-#include <sys/resource.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#include <linux/unistd.h>
-#include <endian.h>
-
-#ifdef __mips__
-/* Include definitions of the ABI currently in use.                          */
-#include <sgidefs.h>
-#endif
-#endif
-
-/* The Android NDK's <sys/stat.h> #defines these macros as aliases
- * to their non-64 counterparts. To avoid naming conflict, remove them. */
-#ifdef __ANDROID__
-  /* These are restored by the corresponding #pragma pop_macro near
-   * the end of this file. */
-# pragma push_macro("stat64")
-# pragma push_macro("fstat64")
-# pragma push_macro("lstat64")
-# undef stat64
-# undef fstat64
-# undef lstat64
-#endif
-
-/* As glibc often provides subtly incompatible data structures (and implicit
- * wrapper functions that convert them), we provide our own kernel data
- * structures for use by the system calls.
- * These structures have been developed by using Linux 2.6.23 headers for
- * reference. Note though, we do not care about exact API compatibility
- * with the kernel, and in fact the kernel often does not have a single
- * API that works across architectures. Instead, we try to mimic the glibc
- * API where reasonable, and only guarantee ABI compatibility with the
- * kernel headers.
- * Most notably, here are a few changes that were made to the structures
- * defined by kernel headers:
- *
- * - we only define structures, but not symbolic names for kernel data
- *   types. For the latter, we directly use the native C datatype
- *   (i.e. "unsigned" instead of "mode_t").
- * - in a few cases, it is possible to define identical structures for
- *   both 32bit (e.g. i386) and 64bit (e.g. x86-64) platforms by
- *   standardizing on the 64bit version of the data types. In particular,
- *   this means that we use "unsigned" where the 32bit headers say
- *   "unsigned long".
- * - overall, we try to minimize the number of cases where we need to
- *   conditionally define different structures.
- * - the "struct kernel_sigaction" class of structures have been
- *   modified to more closely mimic glibc's API by introducing an
- *   anonymous union for the function pointer.
- * - a small number of field names had to have an underscore appended to
- *   them, because glibc defines a global macro by the same name.
- */
-
-/* include/linux/dirent.h                                                    */
-struct kernel_dirent64 {
-  unsigned long long d_ino;
-  long long          d_off;
-  unsigned short     d_reclen;
-  unsigned char      d_type;
-  char               d_name[256];
-};
-
-/* include/linux/dirent.h                                                    */
-#if defined(__aarch64__)
-// aarch64 only defines dirent64, just uses that for dirent too.
-#define kernel_dirent kernel_dirent64
-#else
-struct kernel_dirent {
-  long               d_ino;
-  long               d_off;
-  unsigned short     d_reclen;
-  char               d_name[256];
-};
-#endif
-
-/* include/linux/uio.h                                                       */
-struct kernel_iovec {
-  void               *iov_base;
-  unsigned long      iov_len;
-};
-
-/* include/linux/socket.h                                                    */
-struct kernel_msghdr {
-  void               *msg_name;
-  int                msg_namelen;
-  struct kernel_iovec*msg_iov;
-  unsigned long      msg_iovlen;
-  void               *msg_control;
-  unsigned long      msg_controllen;
-  unsigned           msg_flags;
-};
-
-/* include/asm-generic/poll.h                                                */
-struct kernel_pollfd {
-  int                fd;
-  short              events;
-  short              revents;
-};
-
-/* include/linux/resource.h                                                  */
-struct kernel_rlimit {
-  unsigned long      rlim_cur;
-  unsigned long      rlim_max;
-};
-
-/* include/linux/time.h                                                      */
-struct kernel_timespec {
-  long               tv_sec;
-  long               tv_nsec;
-};
-
-/* include/linux/time.h                                                      */
-struct kernel_timeval {
-  long               tv_sec;
-  long               tv_usec;
-};
-
-/* include/linux/resource.h                                                  */
-struct kernel_rusage {
-  struct kernel_timeval ru_utime;
-  struct kernel_timeval ru_stime;
-  long               ru_maxrss;
-  long               ru_ixrss;
-  long               ru_idrss;
-  long               ru_isrss;
-  long               ru_minflt;
-  long               ru_majflt;
-  long               ru_nswap;
-  long               ru_inblock;
-  long               ru_oublock;
-  long               ru_msgsnd;
-  long               ru_msgrcv;
-  long               ru_nsignals;
-  long               ru_nvcsw;
-  long               ru_nivcsw;
-};
-
-#if defined(__i386__) || defined(__ARM_EABI__) || defined(__ARM_ARCH_3__) \
-  || defined(__PPC__)
-
-/* include/asm-{arm,i386,mips,ppc}/signal.h                                  */
-struct kernel_old_sigaction {
-  union {
-    void             (*sa_handler_)(int);
-    void             (*sa_sigaction_)(int, siginfo_t *, void *);
-  };
-  unsigned long      sa_mask;
-  unsigned long      sa_flags;
-  void               (*sa_restorer)(void);
-} __attribute__((packed,aligned(4)));
-#elif (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
-  #define kernel_old_sigaction kernel_sigaction
-#elif defined(__aarch64__)
-  // No kernel_old_sigaction defined for arm64.
-#endif
-
-/* Some kernel functions (e.g. sigaction() in 2.6.23) require that the
- * exactly match the size of the signal set, even though the API was
- * intended to be extensible. We define our own KERNEL_NSIG to deal with
- * this.
- * Please note that glibc provides signals [1.._NSIG-1], whereas the
- * kernel (and this header) provides the range [1..KERNEL_NSIG]. The
- * actual number of signals is obviously the same, but the constants
- * differ by one.
- */
-#ifdef __mips__
-#define KERNEL_NSIG 128
-#else
-#define KERNEL_NSIG  64
-#endif
-
-/* include/asm-{arm,aarch64,i386,mips,x86_64}/signal.h                       */
-struct kernel_sigset_t {
-  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)/
-                    (8*sizeof(unsigned long))];
-};
-
-/* include/asm-{arm,i386,mips,x86_64,ppc}/signal.h                           */
-struct kernel_sigaction {
-#ifdef __mips__
-  unsigned long      sa_flags;
-  union {
-    void             (*sa_handler_)(int);
-    void             (*sa_sigaction_)(int, siginfo_t *, void *);
-  };
-  struct kernel_sigset_t sa_mask;
-#else
-  union {
-    void             (*sa_handler_)(int);
-    void             (*sa_sigaction_)(int, siginfo_t *, void *);
-  };
-  unsigned long      sa_flags;
-  void               (*sa_restorer)(void);
-  struct kernel_sigset_t sa_mask;
-#endif
-};
-
-/* include/linux/socket.h                                                    */
-struct kernel_sockaddr {
-  unsigned short     sa_family;
-  char               sa_data[14];
-};
-
-/* include/asm-{arm,aarch64,i386,mips,ppc}/stat.h                            */
-#ifdef __mips__
-#if _MIPS_SIM == _MIPS_SIM_ABI64
-struct kernel_stat {
-#else
-struct kernel_stat64 {
-#endif
-  unsigned           st_dev;
-  unsigned           __pad0[3];
-  unsigned long long st_ino;
-  unsigned           st_mode;
-  unsigned           st_nlink;
-  unsigned           st_uid;
-  unsigned           st_gid;
-  unsigned           st_rdev;
-  unsigned           __pad1[3];
-  long long          st_size;
-  unsigned           st_atime_;
-  unsigned           st_atime_nsec_;
-  unsigned           st_mtime_;
-  unsigned           st_mtime_nsec_;
-  unsigned           st_ctime_;
-  unsigned           st_ctime_nsec_;
-  unsigned           st_blksize;
-  unsigned           __pad2;
-  unsigned long long st_blocks;
-};
-#elif defined __PPC__
-struct kernel_stat64 {
-  unsigned long long st_dev;
-  unsigned long long st_ino;
-  unsigned           st_mode;
-  unsigned           st_nlink;
-  unsigned           st_uid;
-  unsigned           st_gid;
-  unsigned long long st_rdev;
-  unsigned short int __pad2;
-  long long          st_size;
-  long               st_blksize;
-  long long          st_blocks;
-  long               st_atime_;
-  unsigned long      st_atime_nsec_;
-  long               st_mtime_;
-  unsigned long      st_mtime_nsec_;
-  long               st_ctime_;
-  unsigned long      st_ctime_nsec_;
-  unsigned long      __unused4;
-  unsigned long      __unused5;
-};
-#else
-struct kernel_stat64 {
-  unsigned long long st_dev;
-  unsigned char      __pad0[4];
-  unsigned           __st_ino;
-  unsigned           st_mode;
-  unsigned           st_nlink;
-  unsigned           st_uid;
-  unsigned           st_gid;
-  unsigned long long st_rdev;
-  unsigned char      __pad3[4];
-  long long          st_size;
-  unsigned           st_blksize;
-  unsigned long long st_blocks;
-  unsigned           st_atime_;
-  unsigned           st_atime_nsec_;
-  unsigned           st_mtime_;
-  unsigned           st_mtime_nsec_;
-  unsigned           st_ctime_;
-  unsigned           st_ctime_nsec_;
-  unsigned long long st_ino;
-};
-#endif
-
-/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc}/stat.h                     */
-#if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
-struct kernel_stat {
-  /* The kernel headers suggest that st_dev and st_rdev should be 32bit
-   * quantities encoding 12bit major and 20bit minor numbers in an interleaved
-   * format. In reality, we do not see useful data in the top bits. So,
-   * we'll leave the padding in here, until we find a better solution.
-   */
-  unsigned short     st_dev;
-  short              pad1;
-  unsigned           st_ino;
-  unsigned short     st_mode;
-  unsigned short     st_nlink;
-  unsigned short     st_uid;
-  unsigned short     st_gid;
-  unsigned short     st_rdev;
-  short              pad2;
-  unsigned           st_size;
-  unsigned           st_blksize;
-  unsigned           st_blocks;
-  unsigned           st_atime_;
-  unsigned           st_atime_nsec_;
-  unsigned           st_mtime_;
-  unsigned           st_mtime_nsec_;
-  unsigned           st_ctime_;
-  unsigned           st_ctime_nsec_;
-  unsigned           __unused4;
-  unsigned           __unused5;
-};
-#elif defined(__x86_64__)
-struct kernel_stat {
-  uint64_t           st_dev;
-  uint64_t           st_ino;
-  uint64_t           st_nlink;
-  unsigned           st_mode;
-  unsigned           st_uid;
-  unsigned           st_gid;
-  unsigned           __pad0;
-  uint64_t           st_rdev;
-  int64_t            st_size;
-  int64_t            st_blksize;
-  int64_t            st_blocks;
-  uint64_t           st_atime_;
-  uint64_t           st_atime_nsec_;
-  uint64_t           st_mtime_;
-  uint64_t           st_mtime_nsec_;
-  uint64_t           st_ctime_;
-  uint64_t           st_ctime_nsec_;
-  int64_t            __unused4[3];
-};
-#elif defined(__PPC__)
-struct kernel_stat {
-  unsigned           st_dev;
-  unsigned long      st_ino;      // ino_t
-  unsigned long      st_mode;     // mode_t
-  unsigned short     st_nlink;    // nlink_t
-  unsigned           st_uid;      // uid_t
-  unsigned           st_gid;      // gid_t
-  unsigned           st_rdev;
-  long               st_size;     // off_t
-  unsigned long      st_blksize;
-  unsigned long      st_blocks;
-  unsigned long      st_atime_;
-  unsigned long      st_atime_nsec_;
-  unsigned long      st_mtime_;
-  unsigned long      st_mtime_nsec_;
-  unsigned long      st_ctime_;
-  unsigned long      st_ctime_nsec_;
-  unsigned long      __unused4;
-  unsigned long      __unused5;
-};
-#elif (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64)
-struct kernel_stat {
-  unsigned           st_dev;
-  int                st_pad1[3];
-  unsigned           st_ino;
-  unsigned           st_mode;
-  unsigned           st_nlink;
-  unsigned           st_uid;
-  unsigned           st_gid;
-  unsigned           st_rdev;
-  int                st_pad2[2];
-  long               st_size;
-  int                st_pad3;
-  long               st_atime_;
-  long               st_atime_nsec_;
-  long               st_mtime_;
-  long               st_mtime_nsec_;
-  long               st_ctime_;
-  long               st_ctime_nsec_;
-  int                st_blksize;
-  int                st_blocks;
-  int                st_pad4[14];
-};
-#elif defined(__aarch64__)
-struct kernel_stat {
-  unsigned long      st_dev;
-  unsigned long      st_ino;
-  unsigned int       st_mode;
-  unsigned int       st_nlink;
-  unsigned int       st_uid;
-  unsigned int       st_gid;
-  unsigned long      st_rdev;
-  unsigned long      __pad1;
-  long               st_size;
-  int                st_blksize;
-  int                __pad2;
-  long               st_blocks;
-  long               st_atime_;
-  unsigned long      st_atime_nsec_;
-  long               st_mtime_;
-  unsigned long      st_mtime_nsec_;
-  long               st_ctime_;
-  unsigned long      st_ctime_nsec_;
-  unsigned int       __unused4;
-  unsigned int       __unused5;
-};
-#endif
-
-/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc}/statfs.h                   */
-#ifdef __mips__
-#if _MIPS_SIM != _MIPS_SIM_ABI64
-struct kernel_statfs64 {
-  unsigned long      f_type;
-  unsigned long      f_bsize;
-  unsigned long      f_frsize;
-  unsigned long      __pad;
-  unsigned long long f_blocks;
-  unsigned long long f_bfree;
-  unsigned long long f_files;
-  unsigned long long f_ffree;
-  unsigned long long f_bavail;
-  struct { int val[2]; } f_fsid;
-  unsigned long      f_namelen;
-  unsigned long      f_spare[6];
-};
-#endif
-#elif !defined(__x86_64__)
-struct kernel_statfs64 {
-  unsigned long      f_type;
-  unsigned long      f_bsize;
-  unsigned long long f_blocks;
-  unsigned long long f_bfree;
-  unsigned long long f_bavail;
-  unsigned long long f_files;
-  unsigned long long f_ffree;
-  struct { int val[2]; } f_fsid;
-  unsigned long      f_namelen;
-  unsigned long      f_frsize;
-  unsigned long      f_spare[5];
-};
-#endif
-
-/* include/asm-{arm,i386,mips,x86_64,ppc,generic}/statfs.h                   */
-#ifdef __mips__
-struct kernel_statfs {
-  long               f_type;
-  long               f_bsize;
-  long               f_frsize;
-  long               f_blocks;
-  long               f_bfree;
-  long               f_files;
-  long               f_ffree;
-  long               f_bavail;
-  struct { int val[2]; } f_fsid;
-  long               f_namelen;
-  long               f_spare[6];
-};
-#elif defined(__x86_64__)
-struct kernel_statfs {
-  /* x86_64 actually defines all these fields as signed, whereas all other  */
-  /* platforms define them as unsigned. Leaving them at unsigned should not */
-  /* cause any problems. Make sure these are 64-bit even on x32.            */
-  uint64_t           f_type;
-  uint64_t           f_bsize;
-  uint64_t           f_blocks;
-  uint64_t           f_bfree;
-  uint64_t           f_bavail;
-  uint64_t           f_files;
-  uint64_t           f_ffree;
-  struct { int val[2]; } f_fsid;
-  uint64_t           f_namelen;
-  uint64_t           f_frsize;
-  uint64_t           f_spare[5];
-};
-#else
-struct kernel_statfs {
-  unsigned long      f_type;
-  unsigned long      f_bsize;
-  unsigned long      f_blocks;
-  unsigned long      f_bfree;
-  unsigned long      f_bavail;
-  unsigned long      f_files;
-  unsigned long      f_ffree;
-  struct { int val[2]; } f_fsid;
-  unsigned long      f_namelen;
-  unsigned long      f_frsize;
-  unsigned long      f_spare[5];
-};
-#endif
-
-
-/* Definitions missing from the standard header files                        */
-#ifndef O_DIRECTORY
-#if defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || defined(__aarch64__)
-#define O_DIRECTORY             0040000
-#else
-#define O_DIRECTORY             0200000
-#endif
-#endif
-#ifndef NT_PRXFPREG
-#define NT_PRXFPREG             0x46e62b7f
-#endif
-#ifndef PTRACE_GETFPXREGS
-#define PTRACE_GETFPXREGS       ((enum __ptrace_request)18)
-#endif
-#ifndef PR_GET_DUMPABLE
-#define PR_GET_DUMPABLE         3
-#endif
-#ifndef PR_SET_DUMPABLE
-#define PR_SET_DUMPABLE         4
-#endif
-#ifndef PR_GET_SECCOMP
-#define PR_GET_SECCOMP          21
-#endif
-#ifndef PR_SET_SECCOMP
-#define PR_SET_SECCOMP          22
-#endif
-#ifndef AT_FDCWD
-#define AT_FDCWD                (-100)
-#endif
-#ifndef AT_SYMLINK_NOFOLLOW
-#define AT_SYMLINK_NOFOLLOW     0x100
-#endif
-#ifndef AT_REMOVEDIR
-#define AT_REMOVEDIR            0x200
-#endif
-#ifndef MREMAP_FIXED
-#define MREMAP_FIXED            2
-#endif
-#ifndef SA_RESTORER
-#define SA_RESTORER             0x04000000
-#endif
-#ifndef CPUCLOCK_PROF
-#define CPUCLOCK_PROF           0
-#endif
-#ifndef CPUCLOCK_VIRT
-#define CPUCLOCK_VIRT           1
-#endif
-#ifndef CPUCLOCK_SCHED
-#define CPUCLOCK_SCHED          2
-#endif
-#ifndef CPUCLOCK_PERTHREAD_MASK
-#define CPUCLOCK_PERTHREAD_MASK 4
-#endif
-#ifndef MAKE_PROCESS_CPUCLOCK
-#define MAKE_PROCESS_CPUCLOCK(pid, clock)                                     \
-        ((~(int)(pid) << 3) | (int)(clock))
-#endif
-#ifndef MAKE_THREAD_CPUCLOCK
-#define MAKE_THREAD_CPUCLOCK(tid, clock)                                      \
-        ((~(int)(tid) << 3) | (int)((clock) | CPUCLOCK_PERTHREAD_MASK))
-#endif
-
-#ifndef FUTEX_WAIT
-#define FUTEX_WAIT                0
-#endif
-#ifndef FUTEX_WAKE
-#define FUTEX_WAKE                1
-#endif
-#ifndef FUTEX_FD
-#define FUTEX_FD                  2
-#endif
-#ifndef FUTEX_REQUEUE
-#define FUTEX_REQUEUE             3
-#endif
-#ifndef FUTEX_CMP_REQUEUE
-#define FUTEX_CMP_REQUEUE         4
-#endif
-#ifndef FUTEX_WAKE_OP
-#define FUTEX_WAKE_OP             5
-#endif
-#ifndef FUTEX_LOCK_PI
-#define FUTEX_LOCK_PI             6
-#endif
-#ifndef FUTEX_UNLOCK_PI
-#define FUTEX_UNLOCK_PI           7
-#endif
-#ifndef FUTEX_TRYLOCK_PI
-#define FUTEX_TRYLOCK_PI          8
-#endif
-#ifndef FUTEX_PRIVATE_FLAG
-#define FUTEX_PRIVATE_FLAG        128
-#endif
-#ifndef FUTEX_CMD_MASK
-#define FUTEX_CMD_MASK            ~FUTEX_PRIVATE_FLAG
-#endif
-#ifndef FUTEX_WAIT_PRIVATE
-#define FUTEX_WAIT_PRIVATE        (FUTEX_WAIT | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_WAKE_PRIVATE
-#define FUTEX_WAKE_PRIVATE        (FUTEX_WAKE | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_REQUEUE_PRIVATE
-#define FUTEX_REQUEUE_PRIVATE     (FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_CMP_REQUEUE_PRIVATE
-#define FUTEX_CMP_REQUEUE_PRIVATE (FUTEX_CMP_REQUEUE | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_WAKE_OP_PRIVATE
-#define FUTEX_WAKE_OP_PRIVATE     (FUTEX_WAKE_OP | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_LOCK_PI_PRIVATE
-#define FUTEX_LOCK_PI_PRIVATE     (FUTEX_LOCK_PI | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_UNLOCK_PI_PRIVATE
-#define FUTEX_UNLOCK_PI_PRIVATE   (FUTEX_UNLOCK_PI | FUTEX_PRIVATE_FLAG)
-#endif
-#ifndef FUTEX_TRYLOCK_PI_PRIVATE
-#define FUTEX_TRYLOCK_PI_PRIVATE  (FUTEX_TRYLOCK_PI | FUTEX_PRIVATE_FLAG)
-#endif
-
-
-#if defined(__x86_64__)
-#ifndef ARCH_SET_GS
-#define ARCH_SET_GS             0x1001
-#endif
-#ifndef ARCH_GET_GS
-#define ARCH_GET_GS             0x1004
-#endif
-#endif
-
-#if defined(__i386__)
-#ifndef __NR_quotactl
-#define __NR_quotactl           131
-#endif
-#ifndef __NR_setresuid
-#define __NR_setresuid          164
-#define __NR_getresuid          165
-#define __NR_setresgid          170
-#define __NR_getresgid          171
-#endif
-#ifndef __NR_rt_sigaction
-#define __NR_rt_sigreturn       173
-#define __NR_rt_sigaction       174
-#define __NR_rt_sigprocmask     175
-#define __NR_rt_sigpending      176
-#define __NR_rt_sigsuspend      179
-#endif
-#ifndef __NR_pread64
-#define __NR_pread64            180
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64           181
-#endif
-#ifndef __NR_ugetrlimit
-#define __NR_ugetrlimit         191
-#endif
-#ifndef __NR_stat64
-#define __NR_stat64             195
-#endif
-#ifndef __NR_fstat64
-#define __NR_fstat64            197
-#endif
-#ifndef __NR_setresuid32
-#define __NR_setresuid32        208
-#define __NR_getresuid32        209
-#define __NR_setresgid32        210
-#define __NR_getresgid32        211
-#endif
-#ifndef __NR_setfsuid32
-#define __NR_setfsuid32         215
-#define __NR_setfsgid32         216
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64         220
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             224
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          225
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           226
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          227
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           229
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          230
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          232
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         233
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              238
-#endif
-#ifndef __NR_futex
-#define __NR_futex              240
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  241
-#define __NR_sched_getaffinity  242
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    258
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      265
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       266
-#endif
-#ifndef __NR_statfs64
-#define __NR_statfs64           268
-#endif
-#ifndef __NR_fstatfs64
-#define __NR_fstatfs64          269
-#endif
-#ifndef __NR_fadvise64_64
-#define __NR_fadvise64_64       272
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         289
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         290
-#endif
-#ifndef __NR_openat
-#define __NR_openat             295
-#endif
-#ifndef __NR_fstatat64
-#define __NR_fstatat64          300
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           301
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         317
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             318
-#endif
-#ifndef __NR_fallocate
-#define __NR_fallocate          324
-#endif
-/* End of i386 definitions                                                   */
-#elif defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
-#ifndef __NR_setresuid
-#define __NR_setresuid          (__NR_SYSCALL_BASE + 164)
-#define __NR_getresuid          (__NR_SYSCALL_BASE + 165)
-#define __NR_setresgid          (__NR_SYSCALL_BASE + 170)
-#define __NR_getresgid          (__NR_SYSCALL_BASE + 171)
-#endif
-#ifndef __NR_rt_sigaction
-#define __NR_rt_sigreturn       (__NR_SYSCALL_BASE + 173)
-#define __NR_rt_sigaction       (__NR_SYSCALL_BASE + 174)
-#define __NR_rt_sigprocmask     (__NR_SYSCALL_BASE + 175)
-#define __NR_rt_sigpending      (__NR_SYSCALL_BASE + 176)
-#define __NR_rt_sigsuspend      (__NR_SYSCALL_BASE + 179)
-#endif
-#ifndef __NR_pread64
-#define __NR_pread64            (__NR_SYSCALL_BASE + 180)
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64           (__NR_SYSCALL_BASE + 181)
-#endif
-#ifndef __NR_ugetrlimit
-#define __NR_ugetrlimit         (__NR_SYSCALL_BASE + 191)
-#endif
-#ifndef __NR_stat64
-#define __NR_stat64             (__NR_SYSCALL_BASE + 195)
-#endif
-#ifndef __NR_fstat64
-#define __NR_fstat64            (__NR_SYSCALL_BASE + 197)
-#endif
-#ifndef __NR_setresuid32
-#define __NR_setresuid32        (__NR_SYSCALL_BASE + 208)
-#define __NR_getresuid32        (__NR_SYSCALL_BASE + 209)
-#define __NR_setresgid32        (__NR_SYSCALL_BASE + 210)
-#define __NR_getresgid32        (__NR_SYSCALL_BASE + 211)
-#endif
-#ifndef __NR_setfsuid32
-#define __NR_setfsuid32         (__NR_SYSCALL_BASE + 215)
-#define __NR_setfsgid32         (__NR_SYSCALL_BASE + 216)
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64         (__NR_SYSCALL_BASE + 217)
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             (__NR_SYSCALL_BASE + 224)
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          (__NR_SYSCALL_BASE + 225)
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           (__NR_SYSCALL_BASE + 226)
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          (__NR_SYSCALL_BASE + 227)
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           (__NR_SYSCALL_BASE + 229)
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          (__NR_SYSCALL_BASE + 230)
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          (__NR_SYSCALL_BASE + 232)
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         (__NR_SYSCALL_BASE + 233)
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              (__NR_SYSCALL_BASE + 238)
-#endif
-#ifndef __NR_futex
-#define __NR_futex              (__NR_SYSCALL_BASE + 240)
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  (__NR_SYSCALL_BASE + 241)
-#define __NR_sched_getaffinity  (__NR_SYSCALL_BASE + 242)
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    (__NR_SYSCALL_BASE + 256)
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      (__NR_SYSCALL_BASE + 263)
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       (__NR_SYSCALL_BASE + 264)
-#endif
-#ifndef __NR_statfs64
-#define __NR_statfs64           (__NR_SYSCALL_BASE + 266)
-#endif
-#ifndef __NR_fstatfs64
-#define __NR_fstatfs64          (__NR_SYSCALL_BASE + 267)
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         (__NR_SYSCALL_BASE + 314)
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         (__NR_SYSCALL_BASE + 315)
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         (__NR_SYSCALL_BASE + 344)
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             (__NR_SYSCALL_BASE + 345)
-#endif
-/* End of ARM 3/EABI definitions                                                */
-#elif defined(__aarch64__)
-#ifndef __NR_setxattr
-#define __NR_setxattr             5
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr            6
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr             8
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr            9
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr           11
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr          12
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set          30
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get          31
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat            35
-#endif
-#ifndef __NR_fallocate
-#define __NR_fallocate           47
-#endif
-#ifndef __NR_openat
-#define __NR_openat              56
-#endif
-#ifndef __NR_quotactl
-#define __NR_quotactl            60
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64          61
-#endif
-#ifndef __NR_getdents
-#define __NR_getdents            __NR_getdents64
-#endif
-#ifndef __NR_pread64
-#define __NR_pread64             67
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64            68
-#endif
-#ifndef __NR_ppoll
-#define __NR_ppoll               73
-#endif
-#ifndef __NR_readlinkat
-#define __NR_readlinkat          78
-#endif
-#ifndef __NR_newfstatat
-#define __NR_newfstatat          79
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address     96
-#endif
-#ifndef __NR_futex
-#define __NR_futex               98
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      113
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       114
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  122
-#define __NR_sched_getaffinity  123
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              130
-#endif
-#ifndef __NR_setresuid
-#define __NR_setresuid          147
-#define __NR_getresuid          148
-#define __NR_setresgid          149
-#define __NR_getresgid          150
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             178
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          213
-#endif
-#ifndef __NR_fadvise64
-#define __NR_fadvise64          223
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         239
-#endif
-/* End of aarch64 definitions                                                */
-#elif defined(__x86_64__)
-#ifndef __NR_pread64
-#define __NR_pread64             17
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64            18
-#endif
-#ifndef __NR_setresuid
-#define __NR_setresuid          117
-#define __NR_getresuid          118
-#define __NR_setresgid          119
-#define __NR_getresgid          120
-#endif
-#ifndef __NR_quotactl
-#define __NR_quotactl           179
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             186
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          187
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           188
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          189
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           191
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          192
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          194
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         195
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              200
-#endif
-#ifndef __NR_futex
-#define __NR_futex              202
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  203
-#define __NR_sched_getaffinity  204
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64         217
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    218
-#endif
-#ifndef __NR_fadvise64
-#define __NR_fadvise64          221
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      228
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       229
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         251
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         252
-#endif
-#ifndef __NR_openat
-#define __NR_openat             257
-#endif
-#ifndef __NR_newfstatat
-#define __NR_newfstatat         262
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           263
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         279
-#endif
-#ifndef __NR_fallocate
-#define __NR_fallocate          285
-#endif
-/* End of x86-64 definitions                                                 */
-#elif defined(__mips__)
-#if _MIPS_SIM == _MIPS_SIM_ABI32
-#ifndef __NR_setresuid
-#define __NR_setresuid          (__NR_Linux + 185)
-#define __NR_getresuid          (__NR_Linux + 186)
-#define __NR_setresgid          (__NR_Linux + 190)
-#define __NR_getresgid          (__NR_Linux + 191)
-#endif
-#ifndef __NR_rt_sigaction
-#define __NR_rt_sigreturn       (__NR_Linux + 193)
-#define __NR_rt_sigaction       (__NR_Linux + 194)
-#define __NR_rt_sigprocmask     (__NR_Linux + 195)
-#define __NR_rt_sigpending      (__NR_Linux + 196)
-#define __NR_rt_sigsuspend      (__NR_Linux + 199)
-#endif
-#ifndef __NR_pread64
-#define __NR_pread64            (__NR_Linux + 200)
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64           (__NR_Linux + 201)
-#endif
-#ifndef __NR_stat64
-#define __NR_stat64             (__NR_Linux + 213)
-#endif
-#ifndef __NR_fstat64
-#define __NR_fstat64            (__NR_Linux + 215)
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64         (__NR_Linux + 219)
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             (__NR_Linux + 222)
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          (__NR_Linux + 223)
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           (__NR_Linux + 224)
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          (__NR_Linux + 225)
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           (__NR_Linux + 227)
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          (__NR_Linux + 228)
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          (__NR_Linux + 230)
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         (__NR_Linux + 231)
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              (__NR_Linux + 236)
-#endif
-#ifndef __NR_futex
-#define __NR_futex              (__NR_Linux + 238)
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  (__NR_Linux + 239)
-#define __NR_sched_getaffinity  (__NR_Linux + 240)
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    (__NR_Linux + 252)
-#endif
-#ifndef __NR_statfs64
-#define __NR_statfs64           (__NR_Linux + 255)
-#endif
-#ifndef __NR_fstatfs64
-#define __NR_fstatfs64          (__NR_Linux + 256)
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      (__NR_Linux + 263)
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       (__NR_Linux + 264)
-#endif
-#ifndef __NR_openat
-#define __NR_openat             (__NR_Linux + 288)
-#endif
-#ifndef __NR_fstatat
-#define __NR_fstatat            (__NR_Linux + 293)
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           (__NR_Linux + 294)
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         (__NR_Linux + 308)
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             (__NR_Linux + 312)
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         (__NR_Linux + 314)
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         (__NR_Linux + 315)
-#endif
-/* End of MIPS (old 32bit API) definitions */
-#elif  _MIPS_SIM == _MIPS_SIM_ABI64
-#ifndef __NR_pread64
-#define __NR_pread64            (__NR_Linux +  16)
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64           (__NR_Linux +  17)
-#endif
-#ifndef __NR_setresuid
-#define __NR_setresuid          (__NR_Linux + 115)
-#define __NR_getresuid          (__NR_Linux + 116)
-#define __NR_setresgid          (__NR_Linux + 117)
-#define __NR_getresgid          (__NR_Linux + 118)
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             (__NR_Linux + 178)
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          (__NR_Linux + 179)
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           (__NR_Linux + 180)
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          (__NR_Linux + 181)
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           (__NR_Linux + 183)
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          (__NR_Linux + 184)
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          (__NR_Linux + 186)
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         (__NR_Linux + 187)
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              (__NR_Linux + 192)
-#endif
-#ifndef __NR_futex
-#define __NR_futex              (__NR_Linux + 194)
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  (__NR_Linux + 195)
-#define __NR_sched_getaffinity  (__NR_Linux + 196)
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    (__NR_Linux + 212)
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      (__NR_Linux + 222)
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       (__NR_Linux + 223)
-#endif
-#ifndef __NR_openat
-#define __NR_openat             (__NR_Linux + 247)
-#endif
-#ifndef __NR_fstatat
-#define __NR_fstatat            (__NR_Linux + 252)
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           (__NR_Linux + 253)
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         (__NR_Linux + 267)
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             (__NR_Linux + 271)
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         (__NR_Linux + 273)
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         (__NR_Linux + 274)
-#endif
-/* End of MIPS (64bit API) definitions */
-#else
-#ifndef __NR_setresuid
-#define __NR_setresuid          (__NR_Linux + 115)
-#define __NR_getresuid          (__NR_Linux + 116)
-#define __NR_setresgid          (__NR_Linux + 117)
-#define __NR_getresgid          (__NR_Linux + 118)
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             (__NR_Linux + 178)
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          (__NR_Linux + 179)
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           (__NR_Linux + 180)
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          (__NR_Linux + 181)
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           (__NR_Linux + 183)
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          (__NR_Linux + 184)
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          (__NR_Linux + 186)
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         (__NR_Linux + 187)
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              (__NR_Linux + 192)
-#endif
-#ifndef __NR_futex
-#define __NR_futex              (__NR_Linux + 194)
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  (__NR_Linux + 195)
-#define __NR_sched_getaffinity  (__NR_Linux + 196)
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    (__NR_Linux + 213)
-#endif
-#ifndef __NR_statfs64
-#define __NR_statfs64           (__NR_Linux + 217)
-#endif
-#ifndef __NR_fstatfs64
-#define __NR_fstatfs64          (__NR_Linux + 218)
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      (__NR_Linux + 226)
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       (__NR_Linux + 227)
-#endif
-#ifndef __NR_openat
-#define __NR_openat             (__NR_Linux + 251)
-#endif
-#ifndef __NR_fstatat
-#define __NR_fstatat            (__NR_Linux + 256)
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           (__NR_Linux + 257)
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         (__NR_Linux + 271)
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             (__NR_Linux + 275)
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         (__NR_Linux + 277)
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         (__NR_Linux + 278)
-#endif
-/* End of MIPS (new 32bit API) definitions                                   */
-#endif
-/* End of MIPS definitions                                                   */
-#elif defined(__PPC__)
-#ifndef __NR_setfsuid
-#define __NR_setfsuid           138
-#define __NR_setfsgid           139
-#endif
-#ifndef __NR_setresuid
-#define __NR_setresuid          164
-#define __NR_getresuid          165
-#define __NR_setresgid          169
-#define __NR_getresgid          170
-#endif
-#ifndef __NR_rt_sigaction
-#define __NR_rt_sigreturn       172
-#define __NR_rt_sigaction       173
-#define __NR_rt_sigprocmask     174
-#define __NR_rt_sigpending      175
-#define __NR_rt_sigsuspend      178
-#endif
-#ifndef __NR_pread64
-#define __NR_pread64            179
-#endif
-#ifndef __NR_pwrite64
-#define __NR_pwrite64           180
-#endif
-#ifndef __NR_ugetrlimit
-#define __NR_ugetrlimit         190
-#endif
-#ifndef __NR_readahead
-#define __NR_readahead          191
-#endif
-#ifndef __NR_stat64
-#define __NR_stat64             195
-#endif
-#ifndef __NR_fstat64
-#define __NR_fstat64            197
-#endif
-#ifndef __NR_getdents64
-#define __NR_getdents64         202
-#endif
-#ifndef __NR_gettid
-#define __NR_gettid             207
-#endif
-#ifndef __NR_tkill
-#define __NR_tkill              208
-#endif
-#ifndef __NR_setxattr
-#define __NR_setxattr           209
-#endif
-#ifndef __NR_lsetxattr
-#define __NR_lsetxattr          210
-#endif
-#ifndef __NR_getxattr
-#define __NR_getxattr           212
-#endif
-#ifndef __NR_lgetxattr
-#define __NR_lgetxattr          213
-#endif
-#ifndef __NR_listxattr
-#define __NR_listxattr          215
-#endif
-#ifndef __NR_llistxattr
-#define __NR_llistxattr         216
-#endif
-#ifndef __NR_futex
-#define __NR_futex              221
-#endif
-#ifndef __NR_sched_setaffinity
-#define __NR_sched_setaffinity  222
-#define __NR_sched_getaffinity  223
-#endif
-#ifndef __NR_set_tid_address
-#define __NR_set_tid_address    232
-#endif
-#ifndef __NR_clock_gettime
-#define __NR_clock_gettime      246
-#endif
-#ifndef __NR_clock_getres
-#define __NR_clock_getres       247
-#endif
-#ifndef __NR_statfs64
-#define __NR_statfs64           252
-#endif
-#ifndef __NR_fstatfs64
-#define __NR_fstatfs64          253
-#endif
-#ifndef __NR_fadvise64_64
-#define __NR_fadvise64_64       254
-#endif
-#ifndef __NR_ioprio_set
-#define __NR_ioprio_set         273
-#endif
-#ifndef __NR_ioprio_get
-#define __NR_ioprio_get         274
-#endif
-#ifndef __NR_openat
-#define __NR_openat             286
-#endif
-#ifndef __NR_fstatat64
-#define __NR_fstatat64          291
-#endif
-#ifndef __NR_unlinkat
-#define __NR_unlinkat           292
-#endif
-#ifndef __NR_move_pages
-#define __NR_move_pages         301
-#endif
-#ifndef __NR_getcpu
-#define __NR_getcpu             302
-#endif
-/* End of powerpc defininitions                                              */
-#endif
-
-
-/* After forking, we must make sure to only call system calls.               */
-#if defined(__BOUNDED_POINTERS__)
-  #error "Need to port invocations of syscalls for bounded ptrs"
-#else
-  /* The core dumper and the thread lister get executed after threads
-   * have been suspended. As a consequence, we cannot call any functions
-   * that acquire locks. Unfortunately, libc wraps most system calls
-   * (e.g. in order to implement pthread_atfork, and to make calls
-   * cancellable), which means we cannot call these functions. Instead,
-   * we have to call syscall() directly.
-   */
-  #undef LSS_ERRNO
-  #ifdef SYS_ERRNO
-    /* Allow the including file to override the location of errno. This can
-     * be useful when using clone() with the CLONE_VM option.
-     */
-    #define LSS_ERRNO SYS_ERRNO
-  #else
-    #define LSS_ERRNO errno
-  #endif
-
-  #undef LSS_INLINE
-  #ifdef SYS_INLINE
-    #define LSS_INLINE SYS_INLINE
-  #else
-    #define LSS_INLINE static inline
-  #endif
-
-  /* Allow the including file to override the prefix used for all new
-   * system calls. By default, it will be set to "sys_".
-   */
-  #undef LSS_NAME
-  #ifndef SYS_PREFIX
-    #define LSS_NAME(name) sys_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX < 0
-    #define LSS_NAME(name) name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 0
-    #define LSS_NAME(name) sys0_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 1
-    #define LSS_NAME(name) sys1_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 2
-    #define LSS_NAME(name) sys2_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 3
-    #define LSS_NAME(name) sys3_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 4
-    #define LSS_NAME(name) sys4_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 5
-    #define LSS_NAME(name) sys5_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 6
-    #define LSS_NAME(name) sys6_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 7
-    #define LSS_NAME(name) sys7_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 8
-    #define LSS_NAME(name) sys8_##name
-  #elif defined(SYS_PREFIX) && SYS_PREFIX == 9
-    #define LSS_NAME(name) sys9_##name
-  #endif
-
-  #undef  LSS_RETURN
-  #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) \
-       || defined(__ARM_EABI__) || defined(__aarch64__))
-  /* Failing system calls return a negative result in the range of
-   * -1..-4095. These are "errno" values with the sign inverted.
-   */
-  #define LSS_RETURN(type, res)                                               \
-    do {                                                                      \
-      if ((unsigned long)(res) >= (unsigned long)(-4095)) {                   \
-        LSS_ERRNO = -(res);                                                   \
-        res = -1;                                                             \
-      }                                                                       \
-      return (type) (res);                                                    \
-    } while (0)
-  #elif defined(__mips__)
-  /* On MIPS, failing system calls return -1, and set errno in a
-   * separate CPU register.
-   */
-  #define LSS_RETURN(type, res, err)                                          \
-    do {                                                                      \
-      if (err) {                                                              \
-        unsigned long __errnovalue = (res);                                   \
-        LSS_ERRNO = __errnovalue;                                             \
-        res = -1;                                                             \
-      }                                                                       \
-      return (type) (res);                                                    \
-    } while (0)
-  #elif defined(__PPC__)
-  /* On PPC, failing system calls return -1, and set errno in a
-   * separate CPU register. See linux/unistd.h.
-   */
-  #define LSS_RETURN(type, res, err)                                          \
-   do {                                                                       \
-     if (err & 0x10000000 ) {                                                 \
-       LSS_ERRNO = (res);                                                     \
-       res = -1;                                                              \
-     }                                                                        \
-     return (type) (res);                                                     \
-   } while (0)
-  #endif
-  #if defined(__i386__)
-    /* In PIC mode (e.g. when building shared libraries), gcc for i386
-     * reserves ebx. Unfortunately, most distribution ship with implementations
-     * of _syscallX() which clobber ebx.
-     * Also, most definitions of _syscallX() neglect to mark "memory" as being
-     * clobbered. This causes problems with compilers, that do a better job
-     * at optimizing across __asm__ calls.
-     * So, we just have to redefine all of the _syscallX() macros.
-     */
-    #undef LSS_ENTRYPOINT
-    #ifdef SYS_SYSCALL_ENTRYPOINT
-    static inline void (**LSS_NAME(get_syscall_entrypoint)(void))(void) {
-      void (**entrypoint)(void);
-      asm volatile(".bss\n"
-                   ".align 8\n"
-                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
-                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
-                   ".previous\n"
-                   /* This logically does 'lea "SYS_SYSCALL_ENTRYPOINT", %0' */
-                   "call 0f\n"
-                 "0:pop  %0\n"
-                   "add  $_GLOBAL_OFFSET_TABLE_+[.-0b], %0\n"
-                   "mov  " SYS_SYSCALL_ENTRYPOINT "@GOT(%0), %0\n"
-                   : "=r"(entrypoint));
-      return entrypoint;
-    }
-
-    #define LSS_ENTRYPOINT ".bss\n"                                           \
-                           ".align 8\n"                                       \
-                           ".globl " SYS_SYSCALL_ENTRYPOINT "\n"              \
-                           ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"         \
-                           ".previous\n"                                      \
-                           /* Check the SYS_SYSCALL_ENTRYPOINT vector      */ \
-                           "push %%eax\n"                                     \
-                           "call 10000f\n"                                    \
-                     "10000:pop  %%eax\n"                                     \
-                           "add  $_GLOBAL_OFFSET_TABLE_+[.-10000b], %%eax\n"  \
-                           "mov  " SYS_SYSCALL_ENTRYPOINT                     \
-                                 "@GOT(%%eax), %%eax\n"                       \
-                           "mov  0(%%eax), %%eax\n"                           \
-                           "test %%eax, %%eax\n"                              \
-                           "jz   10002f\n"                                    \
-                           "push %%eax\n"                                     \
-                           "call 10001f\n"                                    \
-                     "10001:pop  %%eax\n"                                     \
-                           "add  $(10003f-10001b), %%eax\n"                   \
-                           "xchg 4(%%esp), %%eax\n"                           \
-                           "ret\n"                                            \
-                     "10002:pop  %%eax\n"                                     \
-                           "int $0x80\n"                                      \
-                     "10003:\n"
-    #else
-    #define LSS_ENTRYPOINT "int $0x80\n"
-    #endif
-    #undef  LSS_BODY
-    #define LSS_BODY(type,args...)                                            \
-      long __res;                                                             \
-      __asm__ __volatile__("push %%ebx\n"                                     \
-                           "movl %2,%%ebx\n"                                  \
-                           LSS_ENTRYPOINT                                     \
-                           "pop %%ebx"                                        \
-                           args                                               \
-                           : "esp", "memory");                                \
-      LSS_RETURN(type,__res)
-    #undef  _syscall0
-    #define _syscall0(type,name)                                              \
-      type LSS_NAME(name)(void) {                                             \
-        long __res;                                                           \
-        __asm__ volatile(LSS_ENTRYPOINT                                       \
-                         : "=a" (__res)                                       \
-                         : "0" (__NR_##name)                                  \
-                         : "esp", "memory");                                  \
-        LSS_RETURN(type,__res);                                               \
-      }
-    #undef  _syscall1
-    #define _syscall1(type,name,type1,arg1)                                   \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_BODY(type,                                                        \
-             : "=a" (__res)                                                   \
-             : "0" (__NR_##name), "ri" ((long)(arg1)));                       \
-      }
-    #undef  _syscall2
-    #define _syscall2(type,name,type1,arg1,type2,arg2)                        \
-      type LSS_NAME(name)(type1 arg1,type2 arg2) {                            \
-        LSS_BODY(type,                                                        \
-             : "=a" (__res)                                                   \
-             : "0" (__NR_##name),"ri" ((long)(arg1)), "c" ((long)(arg2)));    \
-      }
-    #undef  _syscall3
-    #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)             \
-      type LSS_NAME(name)(type1 arg1,type2 arg2,type3 arg3) {                 \
-        LSS_BODY(type,                                                        \
-             : "=a" (__res)                                                   \
-             : "0" (__NR_##name), "ri" ((long)(arg1)), "c" ((long)(arg2)),    \
-               "d" ((long)(arg3)));                                           \
-      }
-    #undef  _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_BODY(type,                                                        \
-             : "=a" (__res)                                                   \
-             : "0" (__NR_##name), "ri" ((long)(arg1)), "c" ((long)(arg2)),    \
-               "d" ((long)(arg3)),"S" ((long)(arg4)));                        \
-      }
-    #undef  _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        long __res;                                                           \
-        __asm__ __volatile__("push %%ebx\n"                                   \
-                             "movl %2,%%ebx\n"                                \
-                             "movl %1,%%eax\n"                                \
-                             LSS_ENTRYPOINT                                   \
-                             "pop  %%ebx"                                     \
-                             : "=a" (__res)                                   \
-                             : "i" (__NR_##name), "ri" ((long)(arg1)),        \
-                               "c" ((long)(arg2)), "d" ((long)(arg3)),        \
-                               "S" ((long)(arg4)), "D" ((long)(arg5))         \
-                             : "esp", "memory");                              \
-        LSS_RETURN(type,__res);                                               \
-      }
-    #undef  _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        long __res;                                                           \
-        struct { long __a1; long __a6; } __s = { (long)arg1, (long) arg6 };   \
-        __asm__ __volatile__("push %%ebp\n"                                   \
-                             "push %%ebx\n"                                   \
-                             "movl 4(%2),%%ebp\n"                             \
-                             "movl 0(%2), %%ebx\n"                            \
-                             "movl %1,%%eax\n"                                \
-                             LSS_ENTRYPOINT                                   \
-                             "pop  %%ebx\n"                                   \
-                             "pop  %%ebp"                                     \
-                             : "=a" (__res)                                   \
-                             : "i" (__NR_##name),  "0" ((long)(&__s)),        \
-                               "c" ((long)(arg2)), "d" ((long)(arg3)),        \
-                               "S" ((long)(arg4)), "D" ((long)(arg5))         \
-                             : "esp", "memory");                              \
-        LSS_RETURN(type,__res);                                               \
-      }
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      long __res;
-      __asm__ __volatile__(/* if (fn == NULL)
-                            *   return -EINVAL;
-                            */
-                           "movl   %3,%%ecx\n"
-                           "jecxz  1f\n"
-
-                           /* if (child_stack == NULL)
-                            *   return -EINVAL;
-                            */
-                           "movl   %4,%%ecx\n"
-                           "jecxz  1f\n"
-
-                           /* Set up alignment of the child stack:
-                            * child_stack = (child_stack & ~0xF) - 20;
-                            */
-                           "andl   $-16,%%ecx\n"
-                           "subl   $20,%%ecx\n"
-
-                           /* Push "arg" and "fn" onto the stack that will be
-                            * used by the child.
-                            */
-                           "movl   %6,%%eax\n"
-                           "movl   %%eax,4(%%ecx)\n"
-                           "movl   %3,%%eax\n"
-                           "movl   %%eax,(%%ecx)\n"
-
-                           /* %eax = syscall(%eax = __NR_clone,
-                            *                %ebx = flags,
-                            *                %ecx = child_stack,
-                            *                %edx = parent_tidptr,
-                            *                %esi = newtls,
-                            *                %edi = child_tidptr)
-                            * Also, make sure that %ebx gets preserved as it is
-                            * used in PIC mode.
-                            */
-                           "movl   %8,%%esi\n"
-                           "movl   %7,%%edx\n"
-                           "movl   %5,%%eax\n"
-                           "movl   %9,%%edi\n"
-                           "pushl  %%ebx\n"
-                           "movl   %%eax,%%ebx\n"
-                           "movl   %2,%%eax\n"
-                           LSS_ENTRYPOINT
-
-                           /* In the parent: restore %ebx
-                            * In the child:  move "fn" into %ebx
-                            */
-                           "popl   %%ebx\n"
-
-                           /* if (%eax != 0)
-                            *   return %eax;
-                            */
-                           "test   %%eax,%%eax\n"
-                           "jnz    1f\n"
-
-                           /* In the child, now. Terminate frame pointer chain.
-                            */
-                           "movl   $0,%%ebp\n"
-
-                           /* Call "fn". "arg" is already on the stack.
-                            */
-                           "call   *%%ebx\n"
-
-                           /* Call _exit(%ebx). Unfortunately older versions
-                            * of gcc restrict the number of arguments that can
-                            * be passed to asm(). So, we need to hard-code the
-                            * system call number.
-                            */
-                           "movl   %%eax,%%ebx\n"
-                           "movl   $1,%%eax\n"
-                           LSS_ENTRYPOINT
-
-                           /* Return to parent.
-                            */
-                         "1:\n"
-                           : "=a" (__res)
-                           : "0"(-EINVAL), "i"(__NR_clone),
-                             "m"(fn), "m"(child_stack), "m"(flags), "m"(arg),
-                             "m"(parent_tidptr), "m"(newtls), "m"(child_tidptr)
-                           : "esp", "memory", "ecx", "edx", "esi", "edi");
-      LSS_RETURN(int, __res);
-    }
-
-    #define __NR__fadvise64_64 __NR_fadvise64_64
-    LSS_INLINE _syscall6(int, _fadvise64_64, int, fd,
-                         unsigned, offset_lo, unsigned, offset_hi,
-                         unsigned, len_lo, unsigned, len_hi,
-                         int, advice)
-
-    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
-                                       loff_t len, int advice) {
-      return LSS_NAME(_fadvise64_64)(fd,
-                                     (unsigned)offset, (unsigned)(offset >>32),
-                                     (unsigned)len, (unsigned)(len >> 32),
-                                     advice);
-    }
-
-    #define __NR__fallocate __NR_fallocate
-    LSS_INLINE _syscall6(int, _fallocate, int, fd,
-                         int, mode,
-                         unsigned, offset_lo, unsigned, offset_hi,
-                         unsigned, len_lo, unsigned, len_hi)
-
-    LSS_INLINE int LSS_NAME(fallocate)(int fd, int mode,
-                                       loff_t offset, loff_t len) {
-      union { loff_t off; unsigned w[2]; } o = { offset }, l = { len };
-      return LSS_NAME(_fallocate)(fd, mode, o.w[0], o.w[1], l.w[0], l.w[1]);
-    }
-
-    LSS_INLINE _syscall1(int, set_thread_area, void *, u)
-    LSS_INLINE _syscall1(int, get_thread_area, void *, u)
-
-    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {
-      /* On i386, the kernel does not know how to return from a signal
-       * handler. Instead, it relies on user space to provide a
-       * restorer function that calls the {rt_,}sigreturn() system call.
-       * Unfortunately, we cannot just reference the glibc version of this
-       * function, as glibc goes out of its way to make it inaccessible.
-       */
-      void (*res)(void);
-      __asm__ __volatile__("call   2f\n"
-                         "0:.align 16\n"
-                         "1:movl   %1,%%eax\n"
-                           LSS_ENTRYPOINT
-                         "2:popl   %0\n"
-                           "addl   $(1b-0b),%0\n"
-                           : "=a" (res)
-                           : "i"  (__NR_rt_sigreturn));
-      return res;
-    }
-    LSS_INLINE void (*LSS_NAME(restore)(void))(void) {
-      /* On i386, the kernel does not know how to return from a signal
-       * handler. Instead, it relies on user space to provide a
-       * restorer function that calls the {rt_,}sigreturn() system call.
-       * Unfortunately, we cannot just reference the glibc version of this
-       * function, as glibc goes out of its way to make it inaccessible.
-       */
-      void (*res)(void);
-      __asm__ __volatile__("call   2f\n"
-                         "0:.align 16\n"
-                         "1:pop    %%eax\n"
-                           "movl   %1,%%eax\n"
-                           LSS_ENTRYPOINT
-                         "2:popl   %0\n"
-                           "addl   $(1b-0b),%0\n"
-                           : "=a" (res)
-                           : "i"  (__NR_sigreturn));
-      return res;
-    }
-  #elif defined(__x86_64__)
-    /* There are no known problems with any of the _syscallX() macros
-     * currently shipping for x86_64, but we still need to be able to define
-     * our own version so that we can override the location of the errno
-     * location (e.g. when using the clone() system call with the CLONE_VM
-     * option).
-     */
-    #undef LSS_ENTRYPOINT
-    #ifdef SYS_SYSCALL_ENTRYPOINT
-    static inline void (**LSS_NAME(get_syscall_entrypoint)(void))(void) {
-      void (**entrypoint)(void);
-      asm volatile(".bss\n"
-                   ".align 8\n"
-                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
-                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
-                   ".previous\n"
-                   "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %0\n"
-                   : "=r"(entrypoint));
-      return entrypoint;
-    }
-
-    #define LSS_ENTRYPOINT                                                    \
-              ".bss\n"                                                        \
-              ".align 8\n"                                                    \
-              ".globl " SYS_SYSCALL_ENTRYPOINT "\n"                           \
-              ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"                      \
-              ".previous\n"                                                   \
-              "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %%rcx\n"       \
-              "mov  0(%%rcx), %%rcx\n"                                        \
-              "test %%rcx, %%rcx\n"                                           \
-              "jz   10001f\n"                                                 \
-              "call *%%rcx\n"                                                 \
-              "jmp  10002f\n"                                                 \
-        "10001:syscall\n"                                                     \
-        "10002:\n"
-
-    #else
-    #define LSS_ENTRYPOINT "syscall\n"
-    #endif
-
-    /* The x32 ABI has 32 bit longs, but the syscall interface is 64 bit.
-     * We need to explicitly cast to an unsigned 64 bit type to avoid implicit
-     * sign extension.  We can't cast pointers directly because those are
-     * 32 bits, and gcc will dump ugly warnings about casting from a pointer
-     * to an integer of a different size.
-     */
-    #undef  LSS_SYSCALL_ARG
-    #define LSS_SYSCALL_ARG(a) ((uint64_t)(uintptr_t)(a))
-    #undef  _LSS_RETURN
-    #define _LSS_RETURN(type, res, cast)                                      \
-      do {                                                                    \
-        if ((uint64_t)(res) >= (uint64_t)(-4095)) {                           \
-          LSS_ERRNO = -(res);                                                 \
-          res = -1;                                                           \
-        }                                                                     \
-        return (type)(cast)(res);                                             \
-      } while (0)
-    #undef  LSS_RETURN
-    #define LSS_RETURN(type, res) _LSS_RETURN(type, res, uintptr_t)
-
-    #undef  _LSS_BODY
-    #define _LSS_BODY(nr, type, name, cast, ...)                              \
-          long long __res;                                                    \
-          __asm__ __volatile__(LSS_BODY_ASM##nr LSS_ENTRYPOINT                \
-            : "=a" (__res)                                                    \
-            : "0" (__NR_##name) LSS_BODY_ARG##nr(__VA_ARGS__)                 \
-            : LSS_BODY_CLOBBER##nr "r11", "rcx", "memory");                   \
-          _LSS_RETURN(type, __res, cast)
-    #undef  LSS_BODY
-    #define LSS_BODY(nr, type, name, args...) \
-      _LSS_BODY(nr, type, name, uintptr_t, ## args)
-
-    #undef  LSS_BODY_ASM0
-    #undef  LSS_BODY_ASM1
-    #undef  LSS_BODY_ASM2
-    #undef  LSS_BODY_ASM3
-    #undef  LSS_BODY_ASM4
-    #undef  LSS_BODY_ASM5
-    #undef  LSS_BODY_ASM6
-    #define LSS_BODY_ASM0
-    #define LSS_BODY_ASM1 LSS_BODY_ASM0
-    #define LSS_BODY_ASM2 LSS_BODY_ASM1
-    #define LSS_BODY_ASM3 LSS_BODY_ASM2
-    #define LSS_BODY_ASM4 LSS_BODY_ASM3 "movq %5,%%r10;"
-    #define LSS_BODY_ASM5 LSS_BODY_ASM4 "movq %6,%%r8;"
-    #define LSS_BODY_ASM6 LSS_BODY_ASM5 "movq %7,%%r9;"
-
-    #undef  LSS_BODY_CLOBBER0
-    #undef  LSS_BODY_CLOBBER1
-    #undef  LSS_BODY_CLOBBER2
-    #undef  LSS_BODY_CLOBBER3
-    #undef  LSS_BODY_CLOBBER4
-    #undef  LSS_BODY_CLOBBER5
-    #undef  LSS_BODY_CLOBBER6
-    #define LSS_BODY_CLOBBER0
-    #define LSS_BODY_CLOBBER1 LSS_BODY_CLOBBER0
-    #define LSS_BODY_CLOBBER2 LSS_BODY_CLOBBER1
-    #define LSS_BODY_CLOBBER3 LSS_BODY_CLOBBER2
-    #define LSS_BODY_CLOBBER4 LSS_BODY_CLOBBER3 "r10",
-    #define LSS_BODY_CLOBBER5 LSS_BODY_CLOBBER4 "r8",
-    #define LSS_BODY_CLOBBER6 LSS_BODY_CLOBBER5 "r9",
-
-    #undef  LSS_BODY_ARG0
-    #undef  LSS_BODY_ARG1
-    #undef  LSS_BODY_ARG2
-    #undef  LSS_BODY_ARG3
-    #undef  LSS_BODY_ARG4
-    #undef  LSS_BODY_ARG5
-    #undef  LSS_BODY_ARG6
-    #define LSS_BODY_ARG0()
-    #define LSS_BODY_ARG1(arg1) \
-      LSS_BODY_ARG0(), "D" (arg1)
-    #define LSS_BODY_ARG2(arg1, arg2) \
-      LSS_BODY_ARG1(arg1), "S" (arg2)
-    #define LSS_BODY_ARG3(arg1, arg2, arg3) \
-      LSS_BODY_ARG2(arg1, arg2), "d" (arg3)
-    #define LSS_BODY_ARG4(arg1, arg2, arg3, arg4) \
-      LSS_BODY_ARG3(arg1, arg2, arg3), "r" (arg4)
-    #define LSS_BODY_ARG5(arg1, arg2, arg3, arg4, arg5) \
-      LSS_BODY_ARG4(arg1, arg2, arg3, arg4), "r" (arg5)
-    #define LSS_BODY_ARG6(arg1, arg2, arg3, arg4, arg5, arg6) \
-      LSS_BODY_ARG5(arg1, arg2, arg3, arg4, arg5), "r" (arg6)
-
-    #undef _syscall0
-    #define _syscall0(type,name)                                              \
-      type LSS_NAME(name)(void) {                                             \
-        LSS_BODY(0, type, name);                                              \
-      }
-    #undef _syscall1
-    #define _syscall1(type,name,type1,arg1)                                   \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_BODY(1, type, name, LSS_SYSCALL_ARG(arg1));                       \
-      }
-    #undef _syscall2
-    #define _syscall2(type,name,type1,arg1,type2,arg2)                        \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        LSS_BODY(2, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2));\
-      }
-    #undef _syscall3
-    #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        LSS_BODY(3, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
-                                LSS_SYSCALL_ARG(arg3));                       \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_BODY(4, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
-                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4));\
-      }
-    #undef _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_BODY(5, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
-                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4), \
-                                LSS_SYSCALL_ARG(arg5));                       \
-      }
-    #undef _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_BODY(6, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
-                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4), \
-                                LSS_SYSCALL_ARG(arg5), LSS_SYSCALL_ARG(arg6));\
-      }
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      long long __res;
-      {
-        __asm__ __volatile__(/* if (fn == NULL)
-                              *   return -EINVAL;
-                              */
-                             "testq  %4,%4\n"
-                             "jz     1f\n"
-
-                             /* if (child_stack == NULL)
-                              *   return -EINVAL;
-                              */
-                             "testq  %5,%5\n"
-                             "jz     1f\n"
-
-                             /* childstack -= 2*sizeof(void *);
-                              */
-                             "subq   $16,%5\n"
-
-                             /* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "movq   %7,8(%5)\n"
-                             "movq   %4,0(%5)\n"
-
-                             /* %rax = syscall(%rax = __NR_clone,
-                              *                %rdi = flags,
-                              *                %rsi = child_stack,
-                              *                %rdx = parent_tidptr,
-                              *                %r8  = new_tls,
-                              *                %r10 = child_tidptr)
-                              */
-                             "movq   %2,%%rax\n"
-                             "movq   %9,%%r8\n"
-                             "movq   %10,%%r10\n"
-                             LSS_ENTRYPOINT
-
-                             /* if (%rax != 0)
-                              *   return;
-                              */
-                             "testq  %%rax,%%rax\n"
-                             "jnz    1f\n"
-
-                             /* In the child. Terminate frame pointer chain.
-                              */
-                             "xorq   %%rbp,%%rbp\n"
-
-                             /* Call "fn(arg)".
-                              */
-                             "popq   %%rax\n"
-                             "popq   %%rdi\n"
-                             "call   *%%rax\n"
-
-                             /* Call _exit(%ebx).
-                              */
-                             "movq   %%rax,%%rdi\n"
-                             "movq   %3,%%rax\n"
-                             LSS_ENTRYPOINT
-
-                             /* Return to parent.
-                              */
-                           "1:\n"
-                             : "=a" (__res)
-                             : "0"(-EINVAL), "i"(__NR_clone), "i"(__NR_exit),
-                               "r"(LSS_SYSCALL_ARG(fn)),
-                               "S"(LSS_SYSCALL_ARG(child_stack)),
-                               "D"(LSS_SYSCALL_ARG(flags)),
-                               "r"(LSS_SYSCALL_ARG(arg)),
-                               "d"(LSS_SYSCALL_ARG(parent_tidptr)),
-                               "r"(LSS_SYSCALL_ARG(newtls)),
-                               "r"(LSS_SYSCALL_ARG(child_tidptr))
-                             : "rsp", "memory", "r8", "r10", "r11", "rcx");
-      }
-      LSS_RETURN(int, __res);
-    }
-    LSS_INLINE _syscall2(int, arch_prctl, int, c, void *, a)
-
-    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset, loff_t len,
-                                       int advice) {
-      LSS_BODY(4, int, fadvise64, LSS_SYSCALL_ARG(fd), (uint64_t)(offset),
-                                  (uint64_t)(len), LSS_SYSCALL_ARG(advice));
-    }
-
-    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {
-      /* On x86-64, the kernel does not know how to return from
-       * a signal handler. Instead, it relies on user space to provide a
-       * restorer function that calls the rt_sigreturn() system call.
-       * Unfortunately, we cannot just reference the glibc version of this
-       * function, as glibc goes out of its way to make it inaccessible.
-       */
-      long long res;
-      __asm__ __volatile__("jmp    2f\n"
-                           ".align 16\n"
-                         "1:movq   %1,%%rax\n"
-                           LSS_ENTRYPOINT
-                         "2:leaq   1b(%%rip),%0\n"
-                           : "=r" (res)
-                           : "i"  (__NR_rt_sigreturn));
-      return (void (*)(void))(uintptr_t)res;
-    }
-  #elif defined(__ARM_ARCH_3__)
-    /* Most definitions of _syscallX() neglect to mark "memory" as being
-     * clobbered. This causes problems with compilers, that do a better job
-     * at optimizing across __asm__ calls.
-     * So, we just have to redefine all of the _syscallX() macros.
-     */
-    #undef LSS_REG
-    #define LSS_REG(r,a) register long __r##r __asm__("r"#r) = (long)a
-    #undef  LSS_BODY
-    #define LSS_BODY(type,name,args...)                                       \
-          register long __res_r0 __asm__("r0");                               \
-          long __res;                                                         \
-          __asm__ __volatile__ (__syscall(name)                               \
-                                : "=r"(__res_r0) : args : "lr", "memory");    \
-          __res = __res_r0;                                                   \
-          LSS_RETURN(type, __res)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-      type LSS_NAME(name)(void) {                                             \
-        LSS_BODY(type, name);                                                 \
-      }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
-      }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
-      }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4);                                                     \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
-      }
-    #undef _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4));                                      \
-      }
-    #undef _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4), "r"(__r5));                           \
-      }
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      long __res;
-      {
-        register int   __flags __asm__("r0") = flags;
-        register void *__stack __asm__("r1") = child_stack;
-        register void *__ptid  __asm__("r2") = parent_tidptr;
-        register void *__tls   __asm__("r3") = newtls;
-        register int  *__ctid  __asm__("r4") = child_tidptr;
-        __asm__ __volatile__(/* if (fn == NULL || child_stack == NULL)
-                              *   return -EINVAL;
-                              */
-                             "cmp   %2,#0\n"
-                             "cmpne %3,#0\n"
-                             "moveq %0,%1\n"
-                             "beq   1f\n"
-
-                             /* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "str   %5,[%3,#-4]!\n"
-                             "str   %2,[%3,#-4]!\n"
-
-                             /* %r0 = syscall(%r0 = flags,
-                              *               %r1 = child_stack,
-                              *               %r2 = parent_tidptr,
-                              *               %r3 = newtls,
-                              *               %r4 = child_tidptr)
-                              */
-                             __syscall(clone)"\n"
-
-                             /* if (%r0 != 0)
-                              *   return %r0;
-                              */
-                             "movs  %0,r0\n"
-                             "bne   1f\n"
-
-                             /* In the child, now. Call "fn(arg)".
-                              */
-                             "ldr   r0,[sp, #4]\n"
-                             "mov   lr,pc\n"
-                             "ldr   pc,[sp]\n"
-
-                             /* Call _exit(%r0).
-                              */
-                             __syscall(exit)"\n"
-                           "1:\n"
-                             : "=r" (__res)
-                             : "i"(-EINVAL),
-                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__tls), "r"(__ctid)
-                             : "cc", "lr", "memory");
-      }
-      LSS_RETURN(int, __res);
-    }
-  #elif defined(__ARM_EABI__)
-    /* Most definitions of _syscallX() neglect to mark "memory" as being
-     * clobbered. This causes problems with compilers, that do a better job
-     * at optimizing across __asm__ calls.
-     * So, we just have to redefine all fo the _syscallX() macros.
-     */
-    #undef LSS_REG
-    #define LSS_REG(r,a) register long __r##r __asm__("r"#r) = (long)a
-    #undef  LSS_BODY
-    #define LSS_BODY(type,name,args...)                                       \
-          register long __res_r0 __asm__("r0");                               \
-          long __res;                                                         \
-          __asm__ __volatile__ ("push {r7}\n"                                 \
-                                "mov r7, %1\n"                                \
-                                "swi 0x0\n"                                   \
-                                "pop {r7}\n"                                  \
-                                : "=r"(__res_r0)                              \
-                                : "i"(__NR_##name) , ## args                  \
-                                : "lr", "memory");                            \
-          __res = __res_r0;                                                   \
-          LSS_RETURN(type, __res)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-      type LSS_NAME(name)(void) {                                             \
-        LSS_BODY(type, name);                                                 \
-      }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
-      }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
-      }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4);                                                     \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
-      }
-    #undef _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4));                                      \
-      }
-    #undef _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4), "r"(__r5));                           \
-      }
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      long __res;
-      {
-        register int   __flags __asm__("r0") = flags;
-        register void *__stack __asm__("r1") = child_stack;
-        register void *__ptid  __asm__("r2") = parent_tidptr;
-        register void *__tls   __asm__("r3") = newtls;
-        register int  *__ctid  __asm__("r4") = child_tidptr;
-        __asm__ __volatile__(/* if (fn == NULL || child_stack == NULL)
-                              *   return -EINVAL;
-                              */
-#ifdef __thumb2__
-                             "push  {r7}\n"
-#endif
-                             "cmp   %2,#0\n"
-                             "it    ne\n"
-                             "cmpne %3,#0\n"
-                             "it    eq\n"
-                             "moveq %0,%1\n"
-                             "beq   1f\n"
-
-                             /* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "str   %5,[%3,#-4]!\n"
-                             "str   %2,[%3,#-4]!\n"
-
-                             /* %r0 = syscall(%r0 = flags,
-                              *               %r1 = child_stack,
-                              *               %r2 = parent_tidptr,
-                              *               %r3 = newtls,
-                              *               %r4 = child_tidptr)
-                              */
-                             "mov r7, %9\n"
-                             "swi 0x0\n"
-
-                             /* if (%r0 != 0)
-                              *   return %r0;
-                              */
-                             "movs  %0,r0\n"
-                             "bne   1f\n"
-
-                             /* In the child, now. Call "fn(arg)".
-                              */
-                             "ldr   r0,[sp, #4]\n"
-
-                             /* When compiling for Thumb-2 the "MOV LR,PC" here
-                              * won't work because it loads PC+4 into LR,
-                              * whereas the LDR is a 4-byte instruction.
-                              * This results in the child thread always
-                              * crashing with an "Illegal Instruction" when it
-                              * returned into the middle of the LDR instruction
-                              * The instruction sequence used instead was
-                              * recommended by
-                              * "https://wiki.edubuntu.org/ARM/Thumb2PortingHowto#Quick_Reference".
-                              */
-                           #ifdef __thumb2__
-                             "ldr   r7,[sp]\n"
-                             "blx   r7\n"
-                           #else
-                             "mov   lr,pc\n"
-                             "ldr   pc,[sp]\n"
-                           #endif
-
-                             /* Call _exit(%r0).
-                              */
-                             "mov r7, %10\n"
-                             "swi 0x0\n"
-                           "1:\n"
-#ifdef __thumb2__
-                             "pop {r7}"
-#endif
-                             : "=r" (__res)
-                             : "i"(-EINVAL),
-                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__tls), "r"(__ctid),
-                               "i"(__NR_clone), "i"(__NR_exit)
-#ifdef __thumb2__
-                             : "cc", "lr", "memory");
-#else
-                             : "cc", "r7", "lr", "memory");
-#endif
-      }
-      LSS_RETURN(int, __res);
-    }
-  #elif defined(__aarch64__)
-    /* Most definitions of _syscallX() neglect to mark "memory" as being
-     * clobbered. This causes problems with compilers, that do a better job
-     * at optimizing across __asm__ calls.
-     * So, we just have to redefine all of the _syscallX() macros.
-     */
-    #undef LSS_REG
-    #define LSS_REG(r,a) register int64_t __r##r __asm__("x"#r) = (int64_t)a
-    #undef  LSS_BODY
-    #define LSS_BODY(type,name,args...)                                       \
-          register int64_t __res_x0 __asm__("x0");                            \
-          int64_t __res;                                                      \
-          __asm__ __volatile__ ("mov x8, %1\n"                                \
-                                "svc 0x0\n"                                   \
-                                : "=r"(__res_x0)                              \
-                                : "i"(__NR_##name) , ## args                  \
-                                : "x8", "memory");                            \
-          __res = __res_x0;                                                   \
-          LSS_RETURN(type, __res)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-      type LSS_NAME(name)(void) {                                             \
-        LSS_BODY(type, name);                                                 \
-      }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
-      }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
-      }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4);                                                     \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
-      }
-    #undef _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4));                                      \
-      }
-    #undef _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4), "r"(__r5));                           \
-      }
-
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      int64_t __res;
-      {
-        register uint64_t __flags __asm__("x0") = flags;
-        register void *__stack __asm__("x1") = child_stack;
-        register void *__ptid  __asm__("x2") = parent_tidptr;
-        register void *__tls   __asm__("x3") = newtls;
-        register int  *__ctid  __asm__("x4") = child_tidptr;
-        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "stp     %1, %4, [%2, #-16]!\n"
-
-                             /* %x0 = syscall(%x0 = flags,
-                              *               %x1 = child_stack,
-                              *               %x2 = parent_tidptr,
-                              *               %x3 = newtls,
-                              *               %x4 = child_tidptr)
-                              */
-                             "mov     x8, %8\n"
-                             "svc     0x0\n"
-
-                             /* if (%r0 != 0)
-                              *   return %r0;
-                              */
-                             "mov     %0, x0\n"
-                             "cbnz    x0, 1f\n"
-
-                             /* In the child, now. Call "fn(arg)".
-                              */
-                             "ldp     x1, x0, [sp], #16\n"
-                             "blr     x1\n"
-
-                             /* Call _exit(%r0).
-                              */
-                             "mov     x8, %9\n"
-                             "svc     0x0\n"
-                           "1:\n"
-                             : "=r" (__res)
-                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__tls), "r"(__ctid),
-                               "i"(__NR_clone), "i"(__NR_exit)
-                             : "cc", "x8", "memory");
-      }
-      LSS_RETURN(int, __res);
-    }
-  #elif defined(__mips__)
-    #undef LSS_REG
-    #define LSS_REG(r,a) register unsigned long __r##r __asm__("$"#r) =       \
-                                 (unsigned long)(a)
-    #undef  LSS_BODY
-    #undef LSS_SYSCALL_CLOBBERS
-    #if _MIPS_SIM == _MIPS_SIM_ABI32
-    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$8", "$9", "$10",               \
-                                 "$11", "$12", "$13", "$14", "$15",           \
-                                 "$24", "$25", "hi", "lo", "memory"
-    #else
-    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$10", "$11", "$12",             \
-                                 "$13", "$14", "$15", "$24", "$25",           \
-                                 "hi", "lo", "memory"
-    #endif
-    #define LSS_BODY(type,name,r7,...)                                        \
-          register unsigned long __v0 __asm__("$2") = __NR_##name;            \
-          __asm__ __volatile__ ("syscall\n"                                   \
-                                : "+r"(__v0), r7 (__r7)                       \
-                                : "0"(__v0), ##__VA_ARGS__                    \
-                                : LSS_SYSCALL_CLOBBERS);                      \
-          LSS_RETURN(type, __v0, __r7)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-      type LSS_NAME(name)(void) {                                             \
-        register unsigned long __r7 __asm__("$7");                            \
-        LSS_BODY(type, name, "=r");                                           \
-      }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        register unsigned long __r7 __asm__("$7");                            \
-        LSS_REG(4, arg1); LSS_BODY(type, name, "=r", "r"(__r4));              \
-      }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        register unsigned long __r7 __asm__("$7");                            \
-        LSS_REG(4, arg1); LSS_REG(5, arg2);                                   \
-        LSS_BODY(type, name, "=r", "r"(__r4), "r"(__r5));                     \
-      }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        register unsigned long __r7 __asm__("$7");                            \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_BODY(type, name, "=r", "r"(__r4), "r"(__r5), "r"(__r6));          \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_REG(7, arg4);                                                     \
-        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6));          \
-      }
-    #undef _syscall5
-    #if _MIPS_SIM == _MIPS_SIM_ABI32
-    /* The old 32bit MIPS system call API passes the fifth and sixth argument
-     * on the stack, whereas the new APIs use registers "r8" and "r9".
-     */
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_REG(7, arg4);                                                     \
-        register unsigned long __v0 __asm__("$2") = __NR_##name;              \
-        __asm__ __volatile__ (".set noreorder\n"                              \
-                              "subu  $29, 32\n"                               \
-                              "sw    %5, 16($29)\n"                           \
-                              "syscall\n"                                     \
-                              "addiu $29, 32\n"                               \
-                              ".set reorder\n"                                \
-                              : "+r"(__v0), "+r" (__r7)                       \
-                              : "r"(__r4), "r"(__r5),                         \
-                                "r"(__r6), "r" ((unsigned long)arg5)          \
-                              : "$8", "$9", "$10", "$11", "$12",              \
-                                "$13", "$14", "$15", "$24", "$25",            \
-                                "memory");                                    \
-        LSS_RETURN(type, __v0, __r7);                                         \
-      }
-    #else
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_REG(7, arg4); LSS_REG(8, arg5);                                   \
-        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6),           \
-                 "r"(__r8));                                                  \
-      }
-    #endif
-    #undef _syscall6
-    #if _MIPS_SIM == _MIPS_SIM_ABI32
-    /* The old 32bit MIPS system call API passes the fifth and sixth argument
-     * on the stack, whereas the new APIs use registers "r8" and "r9".
-     */
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_REG(7, arg4);                                                     \
-        register unsigned long __v0 __asm__("$2") = __NR_##name;              \
-        __asm__ __volatile__ (".set noreorder\n"                              \
-                              "subu  $29, 32\n"                               \
-                              "sw    %5, 16($29)\n"                           \
-                              "sw    %6, 20($29)\n"                           \
-                              "syscall\n"                                     \
-                              "addiu $29, 32\n"                               \
-                              ".set reorder\n"                                \
-                              : "+r"(__v0), "+r" (__r7)                       \
-                              : "r"(__r4), "r"(__r5),                         \
-                                "r"(__r6), "r" ((unsigned long)arg5),         \
-                                "r" ((unsigned long)arg6)                     \
-                              : "$8", "$9", "$10", "$11", "$12",              \
-                                "$13", "$14", "$15", "$24", "$25",            \
-                                "memory");                                    \
-        LSS_RETURN(type, __v0, __r7);                                         \
-      }
-    #else
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5,type6 arg6) {                            \
-        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
-        LSS_REG(7, arg4); LSS_REG(8, arg5); LSS_REG(9, arg6);                 \
-        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6),           \
-                 "r"(__r8), "r"(__r9));                                       \
-      }
-    #endif
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      register unsigned long __v0 __asm__("$2");
-      register unsigned long __r7 __asm__("$7") = (unsigned long)newtls;
-      {
-        register int   __flags __asm__("$4") = flags;
-        register void *__stack __asm__("$5") = child_stack;
-        register void *__ptid  __asm__("$6") = parent_tidptr;
-        register int  *__ctid  __asm__("$8") = child_tidptr;
-        __asm__ __volatile__(
-          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
-                             "subu  $29,24\n"
-          #elif _MIPS_SIM == _MIPS_SIM_NABI32
-                             "sub   $29,16\n"
-          #else
-                             "dsubu $29,16\n"
-          #endif
-
-                             /* if (fn == NULL || child_stack == NULL)
-                              *   return -EINVAL;
-                              */
-                             "li    %0,%2\n"
-                             "beqz  %5,1f\n"
-                             "beqz  %6,1f\n"
-
-                             /* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
-                             "subu  %6,32\n"
-                             "sw    %5,0(%6)\n"
-                             "sw    %8,4(%6)\n"
-          #elif _MIPS_SIM == _MIPS_SIM_NABI32
-                             "sub   %6,32\n"
-                             "sw    %5,0(%6)\n"
-                             "sw    %8,8(%6)\n"
-          #else
-                             "dsubu %6,32\n"
-                             "sd    %5,0(%6)\n"
-                             "sd    %8,8(%6)\n"
-          #endif
-
-                             /* $7 = syscall($4 = flags,
-                              *              $5 = child_stack,
-                              *              $6 = parent_tidptr,
-                              *              $7 = newtls,
-                              *              $8 = child_tidptr)
-                              */
-                             "li    $2,%3\n"
-                             "syscall\n"
-
-                             /* if ($7 != 0)
-                              *   return $2;
-                              */
-                             "bnez  $7,1f\n"
-                             "bnez  $2,1f\n"
-
-                             /* In the child, now. Call "fn(arg)".
-                              */
-          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
-                            "lw    $25,0($29)\n"
-                            "lw    $4,4($29)\n"
-          #elif _MIPS_SIM == _MIPS_SIM_NABI32
-                            "lw    $25,0($29)\n"
-                            "lw    $4,8($29)\n"
-          #else
-                            "ld    $25,0($29)\n"
-                            "ld    $4,8($29)\n"
-          #endif
-                            "jalr  $25\n"
-
-                             /* Call _exit($2)
-                              */
-                            "move  $4,$2\n"
-                            "li    $2,%4\n"
-                            "syscall\n"
-
-                           "1:\n"
-          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
-                             "addu  $29, 24\n"
-          #elif _MIPS_SIM == _MIPS_SIM_NABI32
-                             "add   $29, 16\n"
-          #else
-                             "daddu $29,16\n"
-          #endif
-                             : "+r" (__v0), "+r" (__r7)
-                             : "i"(-EINVAL), "i"(__NR_clone), "i"(__NR_exit),
-                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__r7), "r"(__ctid)
-                             : "$9", "$10", "$11", "$12", "$13", "$14", "$15",
-                               "$24", "$25", "memory");
-      }
-      LSS_RETURN(int, __v0, __r7);
-    }
-  #elif defined (__PPC__)
-    #undef  LSS_LOADARGS_0
-    #define LSS_LOADARGS_0(name, dummy...)                                    \
-        __sc_0 = __NR_##name
-    #undef  LSS_LOADARGS_1
-    #define LSS_LOADARGS_1(name, arg1)                                        \
-            LSS_LOADARGS_0(name);                                             \
-            __sc_3 = (unsigned long) (arg1)
-    #undef  LSS_LOADARGS_2
-    #define LSS_LOADARGS_2(name, arg1, arg2)                                  \
-            LSS_LOADARGS_1(name, arg1);                                       \
-            __sc_4 = (unsigned long) (arg2)
-    #undef  LSS_LOADARGS_3
-    #define LSS_LOADARGS_3(name, arg1, arg2, arg3)                            \
-            LSS_LOADARGS_2(name, arg1, arg2);                                 \
-            __sc_5 = (unsigned long) (arg3)
-    #undef  LSS_LOADARGS_4
-    #define LSS_LOADARGS_4(name, arg1, arg2, arg3, arg4)                      \
-            LSS_LOADARGS_3(name, arg1, arg2, arg3);                           \
-            __sc_6 = (unsigned long) (arg4)
-    #undef  LSS_LOADARGS_5
-    #define LSS_LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5)                \
-            LSS_LOADARGS_4(name, arg1, arg2, arg3, arg4);                     \
-            __sc_7 = (unsigned long) (arg5)
-    #undef  LSS_LOADARGS_6
-    #define LSS_LOADARGS_6(name, arg1, arg2, arg3, arg4, arg5, arg6)          \
-            LSS_LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5);               \
-            __sc_8 = (unsigned long) (arg6)
-    #undef  LSS_ASMINPUT_0
-    #define LSS_ASMINPUT_0 "0" (__sc_0)
-    #undef  LSS_ASMINPUT_1
-    #define LSS_ASMINPUT_1 LSS_ASMINPUT_0, "1" (__sc_3)
-    #undef  LSS_ASMINPUT_2
-    #define LSS_ASMINPUT_2 LSS_ASMINPUT_1, "2" (__sc_4)
-    #undef  LSS_ASMINPUT_3
-    #define LSS_ASMINPUT_3 LSS_ASMINPUT_2, "3" (__sc_5)
-    #undef  LSS_ASMINPUT_4
-    #define LSS_ASMINPUT_4 LSS_ASMINPUT_3, "4" (__sc_6)
-    #undef  LSS_ASMINPUT_5
-    #define LSS_ASMINPUT_5 LSS_ASMINPUT_4, "5" (__sc_7)
-    #undef  LSS_ASMINPUT_6
-    #define LSS_ASMINPUT_6 LSS_ASMINPUT_5, "6" (__sc_8)
-    #undef  LSS_BODY
-    #define LSS_BODY(nr, type, name, args...)                                 \
-        long __sc_ret, __sc_err;                                              \
-        {                                                                     \
-                        register unsigned long __sc_0 __asm__ ("r0");         \
-                        register unsigned long __sc_3 __asm__ ("r3");         \
-                        register unsigned long __sc_4 __asm__ ("r4");         \
-                        register unsigned long __sc_5 __asm__ ("r5");         \
-                        register unsigned long __sc_6 __asm__ ("r6");         \
-                        register unsigned long __sc_7 __asm__ ("r7");         \
-                        register unsigned long __sc_8 __asm__ ("r8");         \
-                                                                              \
-            LSS_LOADARGS_##nr(name, args);                                    \
-            __asm__ __volatile__                                              \
-                ("sc\n\t"                                                     \
-                 "mfcr %0"                                                    \
-                 : "=&r" (__sc_0),                                            \
-                   "=&r" (__sc_3), "=&r" (__sc_4),                            \
-                   "=&r" (__sc_5), "=&r" (__sc_6),                            \
-                   "=&r" (__sc_7), "=&r" (__sc_8)                             \
-                 : LSS_ASMINPUT_##nr                                          \
-                 : "cr0", "ctr", "memory",                                    \
-                   "r9", "r10", "r11", "r12");                                \
-            __sc_ret = __sc_3;                                                \
-            __sc_err = __sc_0;                                                \
-        }                                                                     \
-        LSS_RETURN(type, __sc_ret, __sc_err)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-       type LSS_NAME(name)(void) {                                            \
-          LSS_BODY(0, type, name);                                            \
-       }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-       type LSS_NAME(name)(type1 arg1) {                                      \
-          LSS_BODY(1, type, name, arg1);                                      \
-       }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-       type LSS_NAME(name)(type1 arg1, type2 arg2) {                          \
-          LSS_BODY(2, type, name, arg1, arg2);                                \
-       }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {              \
-          LSS_BODY(3, type, name, arg1, arg2, arg3);                          \
-       }
-    #undef _syscall4
-    #define _syscall4(type, name, type1, arg1, type2, arg2, type3, arg3,      \
-                                  type4, arg4)                                \
-       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {  \
-          LSS_BODY(4, type, name, arg1, arg2, arg3, arg4);                    \
-       }
-    #undef _syscall5
-    #define _syscall5(type, name, type1, arg1, type2, arg2, type3, arg3,      \
-                                  type4, arg4, type5, arg5)                   \
-       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,    \
-                                               type5 arg5) {                  \
-          LSS_BODY(5, type, name, arg1, arg2, arg3, arg4, arg5);              \
-       }
-    #undef _syscall6
-    #define _syscall6(type, name, type1, arg1, type2, arg2, type3, arg3,      \
-                                  type4, arg4, type5, arg5, type6, arg6)      \
-       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,    \
-                                               type5 arg5, type6 arg6) {      \
-          LSS_BODY(6, type, name, arg1, arg2, arg3, arg4, arg5, arg6);        \
-       }
-    /* clone function adapted from glibc 2.3.6 clone.S                       */
-    /* TODO(csilvers): consider wrapping some args up in a struct, like we
-     * do for i386's _syscall6, so we can compile successfully on gcc 2.95
-     */
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      long __ret, __err;
-      {
-        register int (*__fn)(void *)    __asm__ ("r8")  = fn;
-        register void *__cstack                 __asm__ ("r4")  = child_stack;
-        register int __flags                    __asm__ ("r3")  = flags;
-        register void * __arg                   __asm__ ("r9")  = arg;
-        register int * __ptidptr                __asm__ ("r5")  = parent_tidptr;
-        register void * __newtls                __asm__ ("r6")  = newtls;
-        register int * __ctidptr                __asm__ ("r7")  = child_tidptr;
-        __asm__ __volatile__(
-            /* check for fn == NULL
-             * and child_stack == NULL
-             */
-            "cmpwi cr0, %6, 0\n\t"
-            "cmpwi cr1, %7, 0\n\t"
-            "cror cr0*4+eq, cr1*4+eq, cr0*4+eq\n\t"
-            "beq- cr0, 1f\n\t"
-
-            /* set up stack frame for child                                  */
-            "clrrwi %7, %7, 4\n\t"
-            "li 0, 0\n\t"
-            "stwu 0, -16(%7)\n\t"
-
-            /* fn, arg, child_stack are saved across the syscall: r28-30     */
-            "mr 28, %6\n\t"
-            "mr 29, %7\n\t"
-            "mr 27, %9\n\t"
-
-            /* syscall                                                       */
-            "li 0, %4\n\t"
-            /* flags already in r3
-             * child_stack already in r4
-             * ptidptr already in r5
-             * newtls already in r6
-             * ctidptr already in r7
-             */
-            "sc\n\t"
-
-            /* Test if syscall was successful                                */
-            "cmpwi cr1, 3, 0\n\t"
-            "crandc cr1*4+eq, cr1*4+eq, cr0*4+so\n\t"
-            "bne- cr1, 1f\n\t"
-
-            /* Do the function call                                          */
-            "mtctr 28\n\t"
-            "mr 3, 27\n\t"
-            "bctrl\n\t"
-
-            /* Call _exit(r3)                                                */
-            "li 0, %5\n\t"
-            "sc\n\t"
-
-            /* Return to parent                                              */
-            "1:\n"
-            "mfcr %1\n\t"
-            "mr %0, 3\n\t"
-              : "=r" (__ret), "=r" (__err)
-              : "0" (-1), "1" (EINVAL),
-                "i" (__NR_clone), "i" (__NR_exit),
-                "r" (__fn), "r" (__cstack), "r" (__flags),
-                "r" (__arg), "r" (__ptidptr), "r" (__newtls),
-                "r" (__ctidptr)
-              : "cr0", "cr1", "memory", "ctr",
-                "r0", "r29", "r27", "r28");
-      }
-      LSS_RETURN(int, __ret, __err);
-    }
-  #endif
-  #define __NR__exit   __NR_exit
-  #define __NR__gettid __NR_gettid
-  #define __NR__mremap __NR_mremap
-  LSS_INLINE _syscall1(void *,  brk,             void *,      e)
-  LSS_INLINE _syscall1(int,     chdir,           const char *,p)
-  LSS_INLINE _syscall1(int,     close,           int,         f)
-  LSS_INLINE _syscall2(int,     clock_getres,    int,         c,
-                       struct kernel_timespec*, t)
-  LSS_INLINE _syscall2(int,     clock_gettime,   int,         c,
-                       struct kernel_timespec*, t)
-  LSS_INLINE _syscall1(int,     dup,             int,         f)
-  #if !defined(__aarch64__)
-    // The dup2 syscall has been deprecated on aarch64. We polyfill it below.
-    LSS_INLINE _syscall2(int,     dup2,            int,         s,
-                         int,            d)
-  #endif
-  LSS_INLINE _syscall3(int,     execve,          const char*, f,
-                       const char*const*,a,const char*const*, e)
-  LSS_INLINE _syscall1(int,     _exit,           int,         e)
-  LSS_INLINE _syscall1(int,     exit_group,      int,         e)
-  LSS_INLINE _syscall3(int,     fcntl,           int,         f,
-                       int,            c, long,   a)
-  #if !defined(__aarch64__)
-    // The fork syscall has been deprecated on aarch64. We polyfill it below.
-    LSS_INLINE _syscall0(pid_t,   fork)
-  #endif
-  LSS_INLINE _syscall2(int,     fstat,           int,         f,
-                      struct kernel_stat*,   b)
-  LSS_INLINE _syscall2(int,     fstatfs,         int,         f,
-                      struct kernel_statfs*, b)
-  #if defined(__x86_64__)
-    /* Need to make sure off_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE int LSS_NAME(ftruncate)(int f, off_t l) {
-      LSS_BODY(2, int, ftruncate, LSS_SYSCALL_ARG(f), (uint64_t)(l));
-    }
-  #else
-    LSS_INLINE _syscall2(int, ftruncate,           int,         f,
-                         off_t,          l)
-  #endif
-  LSS_INLINE _syscall4(int,     futex,           int*,        a,
-                       int,            o, int,    v,
-                      struct kernel_timespec*, t)
-  LSS_INLINE _syscall3(int,     getdents,        int,         f,
-                       struct kernel_dirent*, d, int,    c)
-  LSS_INLINE _syscall3(int,     getdents64,      int,         f,
-                      struct kernel_dirent64*, d, int,    c)
-  LSS_INLINE _syscall0(gid_t,   getegid)
-  LSS_INLINE _syscall0(uid_t,   geteuid)
-  #if !defined(__aarch64__)
-    // The getgprp syscall has been deprecated on aarch64.
-    LSS_INLINE _syscall0(pid_t,   getpgrp)
-  #endif
-  LSS_INLINE _syscall0(pid_t,   getpid)
-  LSS_INLINE _syscall0(pid_t,   getppid)
-  LSS_INLINE _syscall2(int,     getpriority,     int,         a,
-                       int,            b)
-  LSS_INLINE _syscall3(int,     getresgid,       gid_t *,     r,
-                       gid_t *,         e,       gid_t *,     s)
-  LSS_INLINE _syscall3(int,     getresuid,       uid_t *,     r,
-                       uid_t *,         e,       uid_t *,     s)
-#if !defined(__ARM_EABI__)
-  LSS_INLINE _syscall2(int,     getrlimit,       int,         r,
-                      struct kernel_rlimit*, l)
-#endif
-  LSS_INLINE _syscall1(pid_t,   getsid,          pid_t,       p)
-  LSS_INLINE _syscall0(pid_t,   _gettid)
-  LSS_INLINE _syscall2(pid_t,   gettimeofday,    struct kernel_timeval*, t,
-                       void*, tz)
-  LSS_INLINE _syscall5(int,     setxattr,        const char *,p,
-                       const char *,   n,        const void *,v,
-                       size_t,         s,        int,         f)
-  LSS_INLINE _syscall5(int,     lsetxattr,       const char *,p,
-                       const char *,   n,        const void *,v,
-                       size_t,         s,        int,         f)
-  LSS_INLINE _syscall4(ssize_t, getxattr,        const char *,p,
-                       const char *,   n,        void *,      v, size_t, s)
-  LSS_INLINE _syscall4(ssize_t, lgetxattr,       const char *,p,
-                       const char *,   n,        void *,      v, size_t, s)
-  LSS_INLINE _syscall3(ssize_t, listxattr,       const char *,p,
-                       char *,   l,              size_t,      s)
-  LSS_INLINE _syscall3(ssize_t, llistxattr,      const char *,p,
-                       char *,   l,              size_t,      s)
-  LSS_INLINE _syscall3(int,     ioctl,           int,         d,
-                       int,     r,               void *,      a)
-  LSS_INLINE _syscall2(int,     ioprio_get,      int,         which,
-                       int,     who)
-  LSS_INLINE _syscall3(int,     ioprio_set,      int,         which,
-                       int,     who,             int,         ioprio)
-  LSS_INLINE _syscall2(int,     kill,            pid_t,       p,
-                       int,            s)
-  #if defined(__x86_64__)
-    /* Need to make sure off_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE off_t LSS_NAME(lseek)(int f, off_t o, int w) {
-      _LSS_BODY(3, off_t, lseek, off_t, LSS_SYSCALL_ARG(f), (uint64_t)(o),
-                                        LSS_SYSCALL_ARG(w));
-    }
-  #else
-    LSS_INLINE _syscall3(off_t,   lseek,           int,         f,
-                         off_t,          o, int,    w)
-  #endif
-  LSS_INLINE _syscall2(int,     munmap,          void*,       s,
-                       size_t,         l)
-  LSS_INLINE _syscall6(long,    move_pages,      pid_t,       p,
-                       unsigned long,  n, void **,g, int *,   d,
-                       int *,          s, int,    f)
-  LSS_INLINE _syscall3(int,     mprotect,        const void *,a,
-                       size_t,         l,        int,         p)
-  LSS_INLINE _syscall5(void*,   _mremap,         void*,       o,
-                       size_t,         os,       size_t,      ns,
-                       unsigned long,  f, void *, a)
-  #if !defined(__aarch64__)
-    // The open and poll syscalls have been deprecated on aarch64. We polyfill
-    // them below.
-    LSS_INLINE _syscall3(int,     open,            const char*, p,
-                         int,            f, int,    m)
-    LSS_INLINE _syscall3(int,     poll,           struct kernel_pollfd*, u,
-                         unsigned int,   n, int,    t)
-  #endif
-  LSS_INLINE _syscall5(int,     prctl,           int,         option,
-                       unsigned long,  arg2,
-                       unsigned long,  arg3,
-                       unsigned long,  arg4,
-                       unsigned long,  arg5)
-  LSS_INLINE _syscall4(long,    ptrace,          int,         r,
-                       pid_t,          p, void *, a, void *, d)
-  #if defined(__NR_quotactl)
-    // Defined on x86_64 / i386 only
-    LSS_INLINE _syscall4(int,  quotactl,  int,  cmd,  const char *, special,
-                         int, id, caddr_t, addr)
-  #endif
-  LSS_INLINE _syscall3(ssize_t, read,            int,         f,
-                       void *,         b, size_t, c)
-  #if !defined(__aarch64__)
-    // The readlink syscall has been deprecated on aarch64. We polyfill below.
-    LSS_INLINE _syscall3(int,     readlink,        const char*, p,
-                         char*,          b, size_t, s)
-  #endif
-  LSS_INLINE _syscall4(int,     rt_sigaction,    int,         s,
-                       const struct kernel_sigaction*, a,
-                       struct kernel_sigaction*, o, size_t,   c)
-  LSS_INLINE _syscall2(int, rt_sigpending, struct kernel_sigset_t *, s,
-                       size_t,         c)
-  LSS_INLINE _syscall4(int, rt_sigprocmask,      int,         h,
-                       const struct kernel_sigset_t*,  s,
-                       struct kernel_sigset_t*,        o, size_t, c)
-  LSS_INLINE _syscall2(int, rt_sigsuspend,
-                       const struct kernel_sigset_t*, s,  size_t, c)
-  LSS_INLINE _syscall3(int,     sched_getaffinity,pid_t,      p,
-                       unsigned int,   l, unsigned long *, m)
-  LSS_INLINE _syscall3(int,     sched_setaffinity,pid_t,      p,
-                       unsigned int,   l, unsigned long *, m)
-  LSS_INLINE _syscall0(int,     sched_yield)
-  LSS_INLINE _syscall1(long,    set_tid_address, int *,       t)
-  LSS_INLINE _syscall1(int,     setfsgid,        gid_t,       g)
-  LSS_INLINE _syscall1(int,     setfsuid,        uid_t,       u)
-  LSS_INLINE _syscall1(int,     setuid,          uid_t,       u)
-  LSS_INLINE _syscall1(int,     setgid,          gid_t,       g)
-  LSS_INLINE _syscall2(int,     setpgid,         pid_t,       p,
-                       pid_t,          g)
-  LSS_INLINE _syscall3(int,     setpriority,     int,         a,
-                       int,            b, int,    p)
-  LSS_INLINE _syscall3(int,     setresgid,       gid_t,       r,
-                       gid_t,          e, gid_t,  s)
-  LSS_INLINE _syscall3(int,     setresuid,       uid_t,       r,
-                       uid_t,          e, uid_t,  s)
-  LSS_INLINE _syscall2(int,     setrlimit,       int,         r,
-                       const struct kernel_rlimit*, l)
-  LSS_INLINE _syscall0(pid_t,    setsid)
-  LSS_INLINE _syscall2(int,     sigaltstack,     const stack_t*, s,
-                       const stack_t*, o)
-  #if defined(__NR_sigreturn)
-    LSS_INLINE _syscall1(int,     sigreturn,       unsigned long, u)
-  #endif
-  #if !defined(__aarch64__)
-    // The stat syscall has been deprecated on aarch64. We polyfill it below.
-    LSS_INLINE _syscall2(int,     stat,            const char*, f,
-                        struct kernel_stat*,   b)
-  #endif
-  LSS_INLINE _syscall2(int,     statfs,          const char*, f,
-                      struct kernel_statfs*, b)
-  LSS_INLINE _syscall3(int,     tgkill,          pid_t,       p,
-                       pid_t,          t, int,            s)
-  LSS_INLINE _syscall2(int,     tkill,           pid_t,       p,
-                       int,            s)
-  #if !defined(__aarch64__)
-    // The unlink syscall has been deprecated on aarch64. We polyfill it below.
-    LSS_INLINE _syscall1(int,     unlink,           const char*, f)
-  #endif
-  LSS_INLINE _syscall3(ssize_t, write,            int,        f,
-                       const void *,   b, size_t, c)
-  LSS_INLINE _syscall3(ssize_t, writev,           int,        f,
-                       const struct kernel_iovec*, v, size_t, c)
-  #if defined(__NR_getcpu)
-    LSS_INLINE _syscall3(long, getcpu, unsigned *, cpu,
-                         unsigned *, node, void *, unused)
-  #endif
-  #if defined(__x86_64__) ||                                                  \
-     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI32)
-    LSS_INLINE _syscall3(int, recvmsg,            int,   s,
-                        struct kernel_msghdr*,     m, int, f)
-    LSS_INLINE _syscall3(int, sendmsg,            int,   s,
-                         const struct kernel_msghdr*, m, int, f)
-    LSS_INLINE _syscall6(int, sendto,             int,   s,
-                         const void*,             m, size_t, l,
-                         int,                     f,
-                         const struct kernel_sockaddr*, a, int, t)
-    LSS_INLINE _syscall2(int, shutdown,           int,   s,
-                         int,                     h)
-    LSS_INLINE _syscall3(int, socket,             int,   d,
-                         int,                     t, int,       p)
-    LSS_INLINE _syscall4(int, socketpair,         int,   d,
-                         int,                     t, int,       p, int*, s)
-  #endif
-  #if defined(__x86_64__)
-    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE int LSS_NAME(fallocate)(int f, int mode, loff_t offset,
-                                       loff_t len) {
-      LSS_BODY(4, int, fallocate, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(mode),
-                                  (uint64_t)(offset), (uint64_t)(len));
-    }
-
-    LSS_INLINE int LSS_NAME(getresgid32)(gid_t *rgid,
-                                         gid_t *egid,
-                                         gid_t *sgid) {
-      return LSS_NAME(getresgid)(rgid, egid, sgid);
-    }
-
-    LSS_INLINE int LSS_NAME(getresuid32)(uid_t *ruid,
-                                         uid_t *euid,
-                                         uid_t *suid) {
-      return LSS_NAME(getresuid)(ruid, euid, suid);
-    }
-
-    /* Need to make sure __off64_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
-                                    int64_t o) {
-      LSS_BODY(6, void*, mmap, LSS_SYSCALL_ARG(s), LSS_SYSCALL_ARG(l),
-                               LSS_SYSCALL_ARG(p), LSS_SYSCALL_ARG(f),
-                               LSS_SYSCALL_ARG(d), (uint64_t)(o));
-    }
-
-    LSS_INLINE _syscall4(int, newfstatat,         int,   d,
-                         const char *,            p,
-                        struct kernel_stat*,       b, int, f)
-
-    LSS_INLINE int LSS_NAME(setfsgid32)(gid_t gid) {
-      return LSS_NAME(setfsgid)(gid);
-    }
-
-    LSS_INLINE int LSS_NAME(setfsuid32)(uid_t uid) {
-      return LSS_NAME(setfsuid)(uid);
-    }
-
-    LSS_INLINE int LSS_NAME(setresgid32)(gid_t rgid, gid_t egid, gid_t sgid) {
-      return LSS_NAME(setresgid)(rgid, egid, sgid);
-    }
-
-    LSS_INLINE int LSS_NAME(setresuid32)(uid_t ruid, uid_t euid, uid_t suid) {
-      return LSS_NAME(setresuid)(ruid, euid, suid);
-    }
-
-    LSS_INLINE int LSS_NAME(sigaction)(int signum,
-                                       const struct kernel_sigaction *act,
-                                       struct kernel_sigaction *oldact) {
-      /* On x86_64, the kernel requires us to always set our own
-       * SA_RESTORER in order to be able to return from a signal handler.
-       * This function must have a "magic" signature that the "gdb"
-       * (and maybe the kernel?) can recognize.
-       */
-      if (act != NULL && !(act->sa_flags & SA_RESTORER)) {
-        struct kernel_sigaction a = *act;
-        a.sa_flags   |= SA_RESTORER;
-        a.sa_restorer = LSS_NAME(restore_rt)();
-        return LSS_NAME(rt_sigaction)(signum, &a, oldact,
-                                      (KERNEL_NSIG+7)/8);
-      } else {
-        return LSS_NAME(rt_sigaction)(signum, act, oldact,
-                                      (KERNEL_NSIG+7)/8);
-      }
-    }
-
-    LSS_INLINE int LSS_NAME(sigpending)(struct kernel_sigset_t *set) {
-      return LSS_NAME(rt_sigpending)(set, (KERNEL_NSIG+7)/8);
-    }
-
-    LSS_INLINE int LSS_NAME(sigprocmask)(int how,
-                                         const struct kernel_sigset_t *set,
-                                         struct kernel_sigset_t *oldset) {
-      return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
-    }
-
-    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
-      return LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
-    }
-  #endif
-  #if defined(__x86_64__) || defined(__ARM_ARCH_3__) ||                       \
-      defined(__ARM_EABI__) || defined(__aarch64__) ||                        \
-     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI32)
-    LSS_INLINE _syscall4(pid_t, wait4,            pid_t, p,
-                         int*,                    s, int,       o,
-                        struct kernel_rusage*,     r)
-
-    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){
-      return LSS_NAME(wait4)(pid, status, options, 0);
-    }
-  #endif
-  #if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)
-    LSS_INLINE _syscall4(int, openat, int, d, const char *, p, int, f, int, m)
-    LSS_INLINE _syscall3(int, unlinkat, int, d, const char *, p, int, f)
-  #endif
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
-    #define __NR__getresgid32 __NR_getresgid32
-    #define __NR__getresuid32 __NR_getresuid32
-    #define __NR__setfsgid32  __NR_setfsgid32
-    #define __NR__setfsuid32  __NR_setfsuid32
-    #define __NR__setresgid32 __NR_setresgid32
-    #define __NR__setresuid32 __NR_setresuid32
-#if defined(__ARM_EABI__)
-    LSS_INLINE _syscall2(int,   ugetrlimit,        int,          r,
-                        struct kernel_rlimit*, l)
-#endif
-    LSS_INLINE _syscall3(int,     _getresgid32,    gid_t *,      r,
-                         gid_t *,            e,    gid_t *,      s)
-    LSS_INLINE _syscall3(int,     _getresuid32,    uid_t *,      r,
-                         uid_t *,            e,    uid_t *,      s)
-    LSS_INLINE _syscall1(int,     _setfsgid32,     gid_t,        f)
-    LSS_INLINE _syscall1(int,     _setfsuid32,     uid_t,        f)
-    LSS_INLINE _syscall3(int,     _setresgid32,    gid_t,        r,
-                         gid_t,              e,    gid_t,        s)
-    LSS_INLINE _syscall3(int,     _setresuid32,    uid_t,        r,
-                         uid_t,              e,    uid_t,        s)
-
-    LSS_INLINE int LSS_NAME(getresgid32)(gid_t *rgid,
-                                         gid_t *egid,
-                                         gid_t *sgid) {
-      int rc;
-      if ((rc = LSS_NAME(_getresgid32)(rgid, egid, sgid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((rgid == NULL) || (egid == NULL) || (sgid == NULL)) {
-          return EFAULT;
-        }
-        // Clear the high bits first, since getresgid only sets 16 bits
-        *rgid = *egid = *sgid = 0;
-        rc = LSS_NAME(getresgid)(rgid, egid, sgid);
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(getresuid32)(uid_t *ruid,
-                                         uid_t *euid,
-                                         uid_t *suid) {
-      int rc;
-      if ((rc = LSS_NAME(_getresuid32)(ruid, euid, suid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((ruid == NULL) || (euid == NULL) || (suid == NULL)) {
-          return EFAULT;
-        }
-        // Clear the high bits first, since getresuid only sets 16 bits
-        *ruid = *euid = *suid = 0;
-        rc = LSS_NAME(getresuid)(ruid, euid, suid);
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(setfsgid32)(gid_t gid) {
-      int rc;
-      if ((rc = LSS_NAME(_setfsgid32)(gid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((unsigned int)gid & ~0xFFFFu) {
-          rc = EINVAL;
-        } else {
-          rc = LSS_NAME(setfsgid)(gid);
-        }
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(setfsuid32)(uid_t uid) {
-      int rc;
-      if ((rc = LSS_NAME(_setfsuid32)(uid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((unsigned int)uid & ~0xFFFFu) {
-          rc = EINVAL;
-        } else {
-          rc = LSS_NAME(setfsuid)(uid);
-        }
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(setresgid32)(gid_t rgid, gid_t egid, gid_t sgid) {
-      int rc;
-      if ((rc = LSS_NAME(_setresgid32)(rgid, egid, sgid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((unsigned int)rgid & ~0xFFFFu ||
-            (unsigned int)egid & ~0xFFFFu ||
-            (unsigned int)sgid & ~0xFFFFu) {
-          rc = EINVAL;
-        } else {
-          rc = LSS_NAME(setresgid)(rgid, egid, sgid);
-        }
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(setresuid32)(uid_t ruid, uid_t euid, uid_t suid) {
-      int rc;
-      if ((rc = LSS_NAME(_setresuid32)(ruid, euid, suid)) < 0 &&
-          LSS_ERRNO == ENOSYS) {
-        if ((unsigned int)ruid & ~0xFFFFu ||
-            (unsigned int)euid & ~0xFFFFu ||
-            (unsigned int)suid & ~0xFFFFu) {
-          rc = EINVAL;
-        } else {
-          rc = LSS_NAME(setresuid)(ruid, euid, suid);
-        }
-      }
-      return rc;
-    }
-  #endif
-  LSS_INLINE int LSS_NAME(sigemptyset)(struct kernel_sigset_t *set) {
-    memset(&set->sig, 0, sizeof(set->sig));
-    return 0;
-  }
-
-  LSS_INLINE int LSS_NAME(sigfillset)(struct kernel_sigset_t *set) {
-    memset(&set->sig, -1, sizeof(set->sig));
-    return 0;
-  }
-
-  LSS_INLINE int LSS_NAME(sigaddset)(struct kernel_sigset_t *set,
-                                     int signum) {
-    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
-      LSS_ERRNO = EINVAL;
-      return -1;
-    } else {
-      set->sig[(signum - 1)/(8*sizeof(set->sig[0]))]
-          |= 1UL << ((signum - 1) % (8*sizeof(set->sig[0])));
-      return 0;
-    }
-  }
-
-  LSS_INLINE int LSS_NAME(sigdelset)(struct kernel_sigset_t *set,
-                                        int signum) {
-    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
-      LSS_ERRNO = EINVAL;
-      return -1;
-    } else {
-      set->sig[(signum - 1)/(8*sizeof(set->sig[0]))]
-          &= ~(1UL << ((signum - 1) % (8*sizeof(set->sig[0]))));
-      return 0;
-    }
-  }
-
-  LSS_INLINE int LSS_NAME(sigismember)(struct kernel_sigset_t *set,
-                                          int signum) {
-    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
-      LSS_ERRNO = EINVAL;
-      return -1;
-    } else {
-      return !!(set->sig[(signum - 1)/(8*sizeof(set->sig[0]))] &
-                (1UL << ((signum - 1) % (8*sizeof(set->sig[0])))));
-    }
-  }
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      defined(__ARM_EABI__) ||                                             \
-     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) || defined(__PPC__)
-    #define __NR__sigaction   __NR_sigaction
-    #define __NR__sigpending  __NR_sigpending
-    #define __NR__sigprocmask __NR_sigprocmask
-    #define __NR__sigsuspend  __NR_sigsuspend
-    #define __NR__socketcall  __NR_socketcall
-    LSS_INLINE _syscall2(int, fstat64,             int, f,
-                         struct kernel_stat64 *, b)
-    LSS_INLINE _syscall5(int, _llseek,     uint, fd,
-                         unsigned long, hi, unsigned long, lo,
-                         loff_t *, res, uint, wh)
-#if !defined(__ARM_EABI__)
-    LSS_INLINE _syscall1(void*, mmap,              void*, a)
-#endif
-    LSS_INLINE _syscall6(void*, mmap2,             void*, s,
-                         size_t,                   l, int,               p,
-                         int,                      f, int,               d,
-                         off_t,                o)
-    LSS_INLINE _syscall3(int,   _sigaction,        int,   s,
-                         const struct kernel_old_sigaction*,  a,
-                         struct kernel_old_sigaction*,        o)
-    LSS_INLINE _syscall1(int,   _sigpending, unsigned long*, s)
-    LSS_INLINE _syscall3(int,   _sigprocmask,      int,   h,
-                         const unsigned long*,     s,
-                         unsigned long*,           o)
-    #ifdef __PPC__
-    LSS_INLINE _syscall1(int, _sigsuspend,         unsigned long, s)
-    #else
-    LSS_INLINE _syscall3(int, _sigsuspend,         const void*, a,
-                         int,                      b,
-                         unsigned long,            s)
-    #endif
-    LSS_INLINE _syscall2(int, stat64,              const char *, p,
-                         struct kernel_stat64 *, b)
-
-    LSS_INLINE int LSS_NAME(sigaction)(int signum,
-                                       const struct kernel_sigaction *act,
-                                       struct kernel_sigaction *oldact) {
-      int old_errno = LSS_ERRNO;
-      int rc;
-      struct kernel_sigaction a;
-      if (act != NULL) {
-        a             = *act;
-        #ifdef __i386__
-        /* On i386, the kernel requires us to always set our own
-         * SA_RESTORER when using realtime signals. Otherwise, it does not
-         * know how to return from a signal handler. This function must have
-         * a "magic" signature that the "gdb" (and maybe the kernel?) can
-         * recognize.
-         * Apparently, a SA_RESTORER is implicitly set by the kernel, when
-         * using non-realtime signals.
-         *
-         * TODO: Test whether ARM needs a restorer
-         */
-        if (!(a.sa_flags & SA_RESTORER)) {
-          a.sa_flags   |= SA_RESTORER;
-          a.sa_restorer = (a.sa_flags & SA_SIGINFO)
-                          ? LSS_NAME(restore_rt)() : LSS_NAME(restore)();
-        }
-        #endif
-      }
-      rc = LSS_NAME(rt_sigaction)(signum, act ? &a : act, oldact,
-                                  (KERNEL_NSIG+7)/8);
-      if (rc < 0 && LSS_ERRNO == ENOSYS) {
-        struct kernel_old_sigaction oa, ooa, *ptr_a = &oa, *ptr_oa = &ooa;
-        if (!act) {
-          ptr_a            = NULL;
-        } else {
-          oa.sa_handler_   = act->sa_handler_;
-          memcpy(&oa.sa_mask, &act->sa_mask, sizeof(oa.sa_mask));
-          #ifndef __mips__
-          oa.sa_restorer   = act->sa_restorer;
-          #endif
-          oa.sa_flags      = act->sa_flags;
-        }
-        if (!oldact) {
-          ptr_oa           = NULL;
-        }
-        LSS_ERRNO = old_errno;
-        rc = LSS_NAME(_sigaction)(signum, ptr_a, ptr_oa);
-        if (rc == 0 && oldact) {
-          if (act) {
-            memcpy(oldact, act, sizeof(*act));
-          } else {
-            memset(oldact, 0, sizeof(*oldact));
-          }
-          oldact->sa_handler_    = ptr_oa->sa_handler_;
-          oldact->sa_flags       = ptr_oa->sa_flags;
-          memcpy(&oldact->sa_mask, &ptr_oa->sa_mask, sizeof(ptr_oa->sa_mask));
-          #ifndef __mips__
-          oldact->sa_restorer    = ptr_oa->sa_restorer;
-          #endif
-        }
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(sigpending)(struct kernel_sigset_t *set) {
-      int old_errno = LSS_ERRNO;
-      int rc = LSS_NAME(rt_sigpending)(set, (KERNEL_NSIG+7)/8);
-      if (rc < 0 && LSS_ERRNO == ENOSYS) {
-        LSS_ERRNO = old_errno;
-        LSS_NAME(sigemptyset)(set);
-        rc = LSS_NAME(_sigpending)(&set->sig[0]);
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(sigprocmask)(int how,
-                                         const struct kernel_sigset_t *set,
-                                         struct kernel_sigset_t *oldset) {
-      int olderrno = LSS_ERRNO;
-      int rc = LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
-      if (rc < 0 && LSS_ERRNO == ENOSYS) {
-        LSS_ERRNO = olderrno;
-        if (oldset) {
-          LSS_NAME(sigemptyset)(oldset);
-        }
-        rc = LSS_NAME(_sigprocmask)(how,
-                                    set ? &set->sig[0] : NULL,
-                                    oldset ? &oldset->sig[0] : NULL);
-      }
-      return rc;
-    }
-
-    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
-      int olderrno = LSS_ERRNO;
-      int rc = LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
-      if (rc < 0 && LSS_ERRNO == ENOSYS) {
-        LSS_ERRNO = olderrno;
-        rc = LSS_NAME(_sigsuspend)(
-        #ifndef __PPC__
-                                   set, 0,
-        #endif
-                                   set->sig[0]);
-      }
-      return rc;
-    }
-  #endif
-  #if defined(__PPC__)
-    #undef LSS_SC_LOADARGS_0
-    #define LSS_SC_LOADARGS_0(dummy...)
-    #undef LSS_SC_LOADARGS_1
-    #define LSS_SC_LOADARGS_1(arg1)                                           \
-        __sc_4  = (unsigned long) (arg1)
-    #undef LSS_SC_LOADARGS_2
-    #define LSS_SC_LOADARGS_2(arg1, arg2)                                     \
-        LSS_SC_LOADARGS_1(arg1);                                              \
-        __sc_5  = (unsigned long) (arg2)
-    #undef LSS_SC_LOADARGS_3
-    #define LSS_SC_LOADARGS_3(arg1, arg2, arg3)                               \
-        LSS_SC_LOADARGS_2(arg1, arg2);                                        \
-        __sc_6  = (unsigned long) (arg3)
-    #undef LSS_SC_LOADARGS_4
-    #define LSS_SC_LOADARGS_4(arg1, arg2, arg3, arg4)                         \
-        LSS_SC_LOADARGS_3(arg1, arg2, arg3);                                  \
-        __sc_7  = (unsigned long) (arg4)
-    #undef LSS_SC_LOADARGS_5
-    #define LSS_SC_LOADARGS_5(arg1, arg2, arg3, arg4, arg5)                   \
-        LSS_SC_LOADARGS_4(arg1, arg2, arg3, arg4);                            \
-        __sc_8  = (unsigned long) (arg5)
-    #undef LSS_SC_BODY
-    #define LSS_SC_BODY(nr, type, opt, args...)                               \
-        long __sc_ret, __sc_err;                                              \
-        {                                                                     \
-          register unsigned long __sc_0 __asm__ ("r0") = __NR_socketcall;     \
-          register unsigned long __sc_3 __asm__ ("r3") = opt;                 \
-          register unsigned long __sc_4 __asm__ ("r4");                       \
-          register unsigned long __sc_5 __asm__ ("r5");                       \
-          register unsigned long __sc_6 __asm__ ("r6");                       \
-          register unsigned long __sc_7 __asm__ ("r7");                       \
-          register unsigned long __sc_8 __asm__ ("r8");                       \
-          LSS_SC_LOADARGS_##nr(args);                                         \
-          __asm__ __volatile__                                                \
-              ("stwu 1, -48(1)\n\t"                                           \
-               "stw 4, 20(1)\n\t"                                             \
-               "stw 5, 24(1)\n\t"                                             \
-               "stw 6, 28(1)\n\t"                                             \
-               "stw 7, 32(1)\n\t"                                             \
-               "stw 8, 36(1)\n\t"                                             \
-               "addi 4, 1, 20\n\t"                                            \
-               "sc\n\t"                                                       \
-               "mfcr %0"                                                      \
-                 : "=&r" (__sc_0),                                            \
-                   "=&r" (__sc_3), "=&r" (__sc_4),                            \
-                   "=&r" (__sc_5), "=&r" (__sc_6),                            \
-                   "=&r" (__sc_7), "=&r" (__sc_8)                             \
-                 : LSS_ASMINPUT_##nr                                          \
-                 : "cr0", "ctr", "memory");                                   \
-          __sc_ret = __sc_3;                                                  \
-          __sc_err = __sc_0;                                                  \
-        }                                                                     \
-        LSS_RETURN(type, __sc_ret, __sc_err)
-
-    LSS_INLINE ssize_t LSS_NAME(recvmsg)(int s,struct kernel_msghdr *msg,
-                                         int flags){
-      LSS_SC_BODY(3, ssize_t, 17, s, msg, flags);
-    }
-
-    LSS_INLINE ssize_t LSS_NAME(sendmsg)(int s,
-                                         const struct kernel_msghdr *msg,
-                                         int flags) {
-      LSS_SC_BODY(3, ssize_t, 16, s, msg, flags);
-    }
-
-    // TODO(csilvers): why is this ifdef'ed out?
-#if 0
-    LSS_INLINE ssize_t LSS_NAME(sendto)(int s, const void *buf, size_t len,
-                                        int flags,
-                                        const struct kernel_sockaddr *to,
-                                        unsigned int tolen) {
-      LSS_BODY(6, ssize_t, 11, s, buf, len, flags, to, tolen);
-    }
-#endif
-
-    LSS_INLINE int LSS_NAME(shutdown)(int s, int how) {
-      LSS_SC_BODY(2, int, 13, s, how);
-    }
-
-    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {
-      LSS_SC_BODY(3, int, 1, domain, type, protocol);
-    }
-
-    LSS_INLINE int LSS_NAME(socketpair)(int d, int type, int protocol,
-                                        int sv[2]) {
-      LSS_SC_BODY(4, int, 8, d, type, protocol, sv);
-    }
-  #endif
-  #if defined(__ARM_EABI__) || defined (__aarch64__)
-    LSS_INLINE _syscall3(ssize_t, recvmsg, int, s, struct kernel_msghdr*, msg,
-                         int, flags)
-    LSS_INLINE _syscall3(ssize_t, sendmsg, int, s, const struct kernel_msghdr*,
-                         msg, int, flags)
-    LSS_INLINE _syscall6(ssize_t, sendto, int, s, const void*, buf, size_t,len,
-                         int, flags, const struct kernel_sockaddr*, to,
-                         unsigned int, tolen)
-    LSS_INLINE _syscall2(int, shutdown, int, s, int, how)
-    LSS_INLINE _syscall3(int, socket, int, domain, int, type, int, protocol)
-    LSS_INLINE _syscall4(int, socketpair, int, d, int, type, int, protocol,
-                         int*, sv)
-  #endif
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
-    #define __NR__socketcall  __NR_socketcall
-    LSS_INLINE _syscall2(int,      _socketcall,    int,   c,
-                         va_list,                  a)
-    LSS_INLINE int LSS_NAME(socketcall)(int op, ...) {
-      int rc;
-      va_list ap;
-      va_start(ap, op);
-      rc = LSS_NAME(_socketcall)(op, ap);
-      va_end(ap);
-      return rc;
-    }
-
-    LSS_INLINE ssize_t LSS_NAME(recvmsg)(int s,struct kernel_msghdr *msg,
-                                         int flags){
-      return (ssize_t)LSS_NAME(socketcall)(17, s, msg, flags);
-    }
-
-    LSS_INLINE ssize_t LSS_NAME(sendmsg)(int s,
-                                         const struct kernel_msghdr *msg,
-                                         int flags) {
-      return (ssize_t)LSS_NAME(socketcall)(16, s, msg, flags);
-    }
-
-    LSS_INLINE ssize_t LSS_NAME(sendto)(int s, const void *buf, size_t len,
-                                        int flags,
-                                        const struct kernel_sockaddr *to,
-                                        unsigned int tolen) {
-      return (ssize_t)LSS_NAME(socketcall)(11, s, buf, len, flags, to, tolen);
-    }
-
-    LSS_INLINE int LSS_NAME(shutdown)(int s, int how) {
-      return LSS_NAME(socketcall)(13, s, how);
-    }
-
-    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {
-      return LSS_NAME(socketcall)(1, domain, type, protocol);
-    }
-
-    LSS_INLINE int LSS_NAME(socketpair)(int d, int type, int protocol,
-                                        int sv[2]) {
-      return LSS_NAME(socketcall)(8, d, type, protocol, sv);
-    }
-  #endif
-  #if defined(__i386__) || defined(__PPC__)
-    LSS_INLINE _syscall4(int,   fstatat64,        int,   d,
-                         const char *,      p,
-                         struct kernel_stat64 *,   b,    int,   f)
-  #endif
-  #if defined(__i386__) || defined(__PPC__) ||                                \
-     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
-    LSS_INLINE _syscall3(pid_t, waitpid,          pid_t, p,
-                         int*,              s,    int,   o)
-  #endif
-  #if defined(__mips__)
-    /* sys_pipe() on MIPS has non-standard calling conventions, as it returns
-     * both file handles through CPU registers.
-     */
-    LSS_INLINE int LSS_NAME(pipe)(int *p) {
-      register unsigned long __v0 __asm__("$2") = __NR_pipe;
-      register unsigned long __v1 __asm__("$3");
-      register unsigned long __r7 __asm__("$7");
-      __asm__ __volatile__ ("syscall\n"
-                            : "+r"(__v0), "=r"(__v1), "=r" (__r7)
-                            : "0"(__v0)
-                            : "$8", "$9", "$10", "$11", "$12",
-                              "$13", "$14", "$15", "$24", "$25", "memory");
-      if (__r7) {
-        unsigned long __errnovalue = __v0;
-        LSS_ERRNO = __errnovalue;
-        return -1;
-      } else {
-        p[0] = __v0;
-        p[1] = __v1;
-        return 0;
-      }
-    }
-  #elif !defined(__aarch64__)
-    // The unlink syscall has been deprecated on aarch64. We polyfill it below.
-    LSS_INLINE _syscall1(int,     pipe,           int *, p)
-  #endif
-  /* TODO(csilvers): see if ppc can/should support this as well              */
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      defined(__ARM_EABI__) ||                                             \
-     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64)
-    #define __NR__statfs64  __NR_statfs64
-    #define __NR__fstatfs64 __NR_fstatfs64
-    LSS_INLINE _syscall3(int, _statfs64,     const char*, p,
-                         size_t, s,struct kernel_statfs64*, b)
-    LSS_INLINE _syscall3(int, _fstatfs64,          int,   f,
-                         size_t, s,struct kernel_statfs64*, b)
-    LSS_INLINE int LSS_NAME(statfs64)(const char *p,
-                                     struct kernel_statfs64 *b) {
-      return LSS_NAME(_statfs64)(p, sizeof(*b), b);
-    }
-    LSS_INLINE int LSS_NAME(fstatfs64)(int f,struct kernel_statfs64 *b) {
-      return LSS_NAME(_fstatfs64)(f, sizeof(*b), b);
-    }
-  #endif
-
-  LSS_INLINE int LSS_NAME(execv)(const char *path, const char *const argv[]) {
-    extern char **environ;
-    return LSS_NAME(execve)(path, argv, (const char *const *)environ);
-  }
-
-  LSS_INLINE pid_t LSS_NAME(gettid)(void) {
-    pid_t tid = LSS_NAME(_gettid)();
-    if (tid != -1) {
-      return tid;
-    }
-    return LSS_NAME(getpid)();
-  }
-
-  LSS_INLINE void *LSS_NAME(mremap)(void *old_address, size_t old_size,
-                                    size_t new_size, int flags, ...) {
-    va_list ap;
-    void *new_address, *rc;
-    va_start(ap, flags);
-    new_address = va_arg(ap, void *);
-    rc = LSS_NAME(_mremap)(old_address, old_size, new_size,
-                           flags, new_address);
-    va_end(ap);
-    return rc;
-  }
-
-  LSS_INLINE int LSS_NAME(ptrace_detach)(pid_t pid) {
-    /* PTRACE_DETACH can sometimes forget to wake up the tracee and it
-     * then sends job control signals to the real parent, rather than to
-     * the tracer. We reduce the risk of this happening by starting a
-     * whole new time slice, and then quickly sending a SIGCONT signal
-     * right after detaching from the tracee.
-     *
-     * We use tkill to ensure that we only issue a wakeup for the thread being
-     * detached.  Large multi threaded apps can take a long time in the kernel
-     * processing SIGCONT.
-     */
-    int rc, err;
-    LSS_NAME(sched_yield)();
-    rc = LSS_NAME(ptrace)(PTRACE_DETACH, pid, (void *)0, (void *)0);
-    err = LSS_ERRNO;
-    LSS_NAME(tkill)(pid, SIGCONT);
-    /* Old systems don't have tkill */
-    if (LSS_ERRNO == ENOSYS)
-      LSS_NAME(kill)(pid, SIGCONT);
-    LSS_ERRNO = err;
-    return rc;
-  }
-
-  LSS_INLINE int LSS_NAME(raise)(int sig) {
-    return LSS_NAME(kill)(LSS_NAME(getpid)(), sig);
-  }
-
-  LSS_INLINE int LSS_NAME(setpgrp)(void) {
-    return LSS_NAME(setpgid)(0, 0);
-  }
-
-  LSS_INLINE int LSS_NAME(sysconf)(int name) {
-    extern int __getpagesize(void);
-    switch (name) {
-      case _SC_OPEN_MAX: {
-        struct kernel_rlimit limit;
-#if defined(__ARM_EABI__)
-        return LSS_NAME(ugetrlimit)(RLIMIT_NOFILE, &limit) < 0
-            ? 8192 : limit.rlim_cur;
-#else
-        return LSS_NAME(getrlimit)(RLIMIT_NOFILE, &limit) < 0
-            ? 8192 : limit.rlim_cur;
-#endif
-      }
-      case _SC_PAGESIZE:
-        return __getpagesize();
-      default:
-        LSS_ERRNO = ENOSYS;
-        return -1;
-    }
-  }
-  #if defined(__x86_64__)
-    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE ssize_t LSS_NAME(pread64)(int f, void *b, size_t c, loff_t o) {
-      LSS_BODY(4, ssize_t, pread64, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(b),
-                                    LSS_SYSCALL_ARG(c), (uint64_t)(o));
-    }
-
-    LSS_INLINE ssize_t LSS_NAME(pwrite64)(int f, const void *b, size_t c,
-                                          loff_t o) {
-      LSS_BODY(4, ssize_t, pwrite64, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(b),
-                                     LSS_SYSCALL_ARG(c), (uint64_t)(o));
-    }
-
-    LSS_INLINE int LSS_NAME(readahead)(int f, loff_t o, unsigned c) {
-      LSS_BODY(3, int, readahead, LSS_SYSCALL_ARG(f), (uint64_t)(o),
-                                  LSS_SYSCALL_ARG(c));
-    }
-  #elif defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI64
-    LSS_INLINE _syscall4(ssize_t, pread64,        int,         f,
-                         void *,         b, size_t,   c,
-                         loff_t,         o)
-    LSS_INLINE _syscall4(ssize_t, pwrite64,       int,         f,
-                         const void *,   b, size_t,   c,
-                         loff_t,         o)
-    LSS_INLINE _syscall3(int,     readahead,      int,         f,
-                         loff_t,         o, unsigned, c)
-  #else
-    #define __NR__pread64   __NR_pread64
-    #define __NR__pwrite64  __NR_pwrite64
-    #define __NR__readahead __NR_readahead
-    #if defined(__ARM_EABI__) || defined(__mips__)
-      /* On ARM and MIPS, a 64-bit parameter has to be in an even-odd register
-       * pair. Hence these calls ignore their fourth argument (r3) so that their
-       * fifth and sixth make such a pair (r4,r5).
-       */
-      #define LSS_LLARG_PAD 0,
-      LSS_INLINE _syscall6(ssize_t, _pread64,        int,         f,
-                           void *,         b, size_t, c,
-                           unsigned, skip, unsigned, o1, unsigned, o2)
-      LSS_INLINE _syscall6(ssize_t, _pwrite64,       int,         f,
-                           const void *,   b, size_t, c,
-                           unsigned, skip, unsigned, o1, unsigned, o2)
-      LSS_INLINE _syscall5(int, _readahead,          int,         f,
-                           unsigned,     skip,
-                           unsigned,       o1, unsigned, o2, size_t, c)
-    #else
-      #define LSS_LLARG_PAD
-      LSS_INLINE _syscall5(ssize_t, _pread64,        int,         f,
-                           void *,         b, size_t, c, unsigned, o1,
-                           unsigned, o2)
-      LSS_INLINE _syscall5(ssize_t, _pwrite64,       int,         f,
-                           const void *,   b, size_t, c, unsigned, o1,
-                           long, o2)
-      LSS_INLINE _syscall4(int, _readahead,          int,         f,
-                           unsigned,       o1, unsigned, o2, size_t, c)
-    #endif
-    /* We force 64bit-wide parameters onto the stack, then access each
-     * 32-bit component individually. This guarantees that we build the
-     * correct parameters independent of the native byte-order of the
-     * underlying architecture.
-     */
-    LSS_INLINE ssize_t LSS_NAME(pread64)(int fd, void *buf, size_t count,
-                                         loff_t off) {
-      union { loff_t off; unsigned arg[2]; } o = { off };
-      return LSS_NAME(_pread64)(fd, buf, count,
-                                LSS_LLARG_PAD o.arg[0], o.arg[1]);
-    }
-    LSS_INLINE ssize_t LSS_NAME(pwrite64)(int fd, const void *buf,
-                                          size_t count, loff_t off) {
-      union { loff_t off; unsigned arg[2]; } o = { off };
-      return LSS_NAME(_pwrite64)(fd, buf, count,
-                                 LSS_LLARG_PAD o.arg[0], o.arg[1]);
-    }
-    LSS_INLINE int LSS_NAME(readahead)(int fd, loff_t off, int len) {
-      union { loff_t off; unsigned arg[2]; } o = { off };
-      return LSS_NAME(_readahead)(fd, LSS_LLARG_PAD o.arg[0], o.arg[1], len);
-    }
-  #endif
-#endif
-
-#if defined(__aarch64__)
-  LSS_INLINE _syscall3(int, dup3,  int, s, int, d, int, f)
-  LSS_INLINE _syscall6(void *, mmap, void *, addr, size_t, length, int, prot,
-                       int, flags, int, fd, int64_t, offset)
-  LSS_INLINE _syscall4(int, newfstatat, int, dirfd, const char *, pathname,
-                       struct kernel_stat *, buf, int, flags)
-  LSS_INLINE _syscall2(int, pipe2, int *, pipefd, int, flags)
-  LSS_INLINE _syscall5(int, ppoll, struct kernel_pollfd *, u,
-                       unsigned int, n, const struct kernel_timespec *, t,
-                       const kernel_sigset_t *, sigmask, size_t, s)
-  LSS_INLINE _syscall4(int, readlinkat, int, d, const char *, p, char *, b,
-                       size_t, s)
-#endif
-
-/*
- * Polyfills for deprecated syscalls.
- */
-
-#if defined(__aarch64__)
-  LSS_INLINE int LSS_NAME(dup2)(int s, int d) {
-    return LSS_NAME(dup3)(s, d, 0);
-  }
-
-  LSS_INLINE int LSS_NAME(open)(const char *pathname, int flags, int mode) {
-    return LSS_NAME(openat)(AT_FDCWD, pathname, flags, mode);
-  }
-
-  LSS_INLINE int LSS_NAME(unlink)(const char *pathname) {
-    return LSS_NAME(unlinkat)(AT_FDCWD, pathname, 0);
-  }
-
-  LSS_INLINE int LSS_NAME(readlink)(const char *pathname, char *buffer,
-                                    size_t size) {
-    return LSS_NAME(readlinkat)(AT_FDCWD, pathname, buffer, size);
-  }
-
-  LSS_INLINE pid_t LSS_NAME(pipe)(int *pipefd) {
-    return LSS_NAME(pipe2)(pipefd, 0);
-  }
-
-  LSS_INLINE int LSS_NAME(poll)(struct kernel_pollfd *fds, unsigned int nfds,
-                                int timeout) {
-   struct kernel_timespec timeout_ts;
-   struct kernel_timespec *timeout_ts_p = NULL;
-
-    if (timeout >= 0) {
-      timeout_ts.tv_sec = timeout / 1000;
-      timeout_ts.tv_nsec = (timeout % 1000) * 1000000;
-      timeout_ts_p = &timeout_ts;
-    }
-    return LSS_NAME(ppoll)(fds, nfds, timeout_ts_p, NULL, 0);
-  }
-
-  LSS_INLINE int LSS_NAME(stat)(const char *pathname,
-                                struct kernel_stat *buf) {
-    return LSS_NAME(newfstatat)(AT_FDCWD, pathname, buf, 0);
-  }
-
-  LSS_INLINE pid_t LSS_NAME(fork)(void) {
-    // No fork syscall on aarch64 - implement by means of the clone syscall.
-    // Note that this does not reset glibc's cached view of the PID/TID, so
-    // some glibc interfaces might go wrong in the forked subprocess.
-    int flags = SIGCHLD;
-    void *child_stack = NULL;
-    void *parent_tidptr = NULL;
-    void *newtls = NULL;
-    void *child_tidptr = NULL;
-
-    LSS_REG(0, flags);
-    LSS_REG(1, child_stack);
-    LSS_REG(2, parent_tidptr);
-    LSS_REG(3, newtls);
-    LSS_REG(4, child_tidptr);
-    LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
-             "r"(__r4));
-  }
-#endif
-
-#ifdef __ANDROID__
-  /* These restore the original values of these macros saved by the
-   * corresponding #pragma push_macro near the top of this file. */
-# pragma pop_macro("stat64")
-# pragma pop_macro("fstat64")
-# pragma pop_macro("lstat64")
-#endif
-
-#if defined(__cplusplus) && !defined(SYS_CPLUSPLUS)
-}
-#endif
-
-#endif
-#endif
diff --git a/TMessagesProj/jni/emoji/emoji_suggestions.cpp b/TMessagesProj/jni/emoji/emoji_suggestions.cpp
new file mode 100644
index 000000000..6b87dc8e1
--- /dev/null
+++ b/TMessagesProj/jni/emoji/emoji_suggestions.cpp
@@ -0,0 +1,452 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop version of Telegram messaging app, see https://telegram.org
+
+Telegram Desktop is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+It is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+In addition, as a special exception, the copyright holders give permission
+to link the code of portions of this program with the OpenSSL library.
+
+Full license: https://github.com/telegramdesktop/tdesktop/blob/master/LICENSE
+Copyright (c) 2014-2017 John Preston, https://desktop.telegram.org
+*/
+
+#include "emoji_suggestions.h"
+
+#include <jni.h>
+#include <algorithm>
+#include "emoji_suggestions_data.h"
+
+checksum Crc32Table[256];
+class Crc32Initializer {
+public:
+	Crc32Initializer() {
+		checksum poly = 0x04C11DB7U;
+		for (auto i = 0; i != 256; ++i) {
+			Crc32Table[i] = reflect(i, 8) << 24;
+			for (auto j = 0; j != 8; ++j) {
+				Crc32Table[i] = (Crc32Table[i] << 1) ^ (Crc32Table[i] & (1 << 31) ? poly : 0);
+			}
+			Crc32Table[i] = reflect(Crc32Table[i], 32);
+		}
+	}
+
+private:
+	checksum reflect(checksum val, char ch) {
+		checksum result = 0;
+		for (int i = 1; i < (ch + 1); ++i) {
+			if (val & 1) {
+				result |= 1 << (ch - i);
+			}
+			val >>= 1;
+		}
+		return result;
+	}
+
+};
+
+checksum countChecksum(const void *data, std::size_t size) {
+	static Crc32Initializer InitTable;
+
+	auto buffer = static_cast<const unsigned char*>(data);
+	auto result = checksum(0xFFFFFFFFU);
+	for (auto i = std::size_t(0); i != size; ++i) {
+		result = (result >> 8) ^ Crc32Table[(result & 0xFFU) ^ buffer[i]];
+	}
+	return (result ^ 0xFFFFFFFFU);
+}
+
+class string_span {
+public:
+	string_span() = default;
+	string_span(const utf16string *data, std::size_t size) : begin_(data), size_(size) {
+	}
+	string_span(const std::vector<utf16string> &data) : begin_(data.data()), size_(data.size()) {
+	}
+	string_span(const string_span &other) = default;
+	string_span &operator=(const string_span &other) = default;
+
+	const utf16string *begin() const {
+		return begin_;
+	}
+	const utf16string *end() const {
+		return begin_ + size_;
+	}
+	std::size_t size() const {
+		return size_;
+	}
+
+	string_span subspan(std::size_t offset, std::size_t size) {
+		return string_span(begin_ + offset, size);
+	}
+
+private:
+	const utf16string *begin_ = nullptr;
+	std::size_t size_ = 0;
+
+};
+
+bool IsNumber(utf16char ch) {
+	return (ch >= '0' && ch <= '9');
+}
+
+bool IsLetterOrNumber(utf16char ch) {
+	return (ch >= 'a' && ch <= 'z') || IsNumber(ch);
+}
+
+using Replacement = Replacement;
+
+class Completer {
+public:
+	Completer(utf16string query);
+
+	std::vector<Suggestion> resolve();
+
+private:
+	struct Result {
+		const Replacement *replacement;
+		int wordsUsed;
+	};
+
+	static std::vector<utf16char> NormalizeQuery(utf16string query);
+	void addResult(const Replacement *replacement);
+	bool isDuplicateOfLastResult(const Replacement *replacement) const;
+	bool isBetterThanLastResult(const Replacement *replacement) const;
+	void processInitialList();
+	void filterInitialList();
+	void initWordsTracking();
+	bool matchQueryForCurrentItem();
+	bool matchQueryTailStartingFrom(int position);
+	string_span findWordsStartingWith(utf16char ch);
+	int findEqualCharsCount(int position, const utf16string *word);
+	std::vector<Suggestion> prepareResult();
+	bool startsWithQuery(utf16string word);
+	bool isExactMatch(utf16string replacement);
+
+	std::vector<Result> _result;
+
+	utf16string _initialQuery;
+	const std::vector<utf16char> _query;
+	const utf16char *_queryBegin = nullptr;
+	int _querySize = 0;
+
+	const std::vector<const Replacement*> *_initialList = nullptr;
+
+	string_span _currentItemWords;
+	int _currentItemWordsUsedCount = 0;
+
+	class UsedWordGuard {
+	public:
+		UsedWordGuard(std::vector<small> &map, int index);
+		UsedWordGuard(const UsedWordGuard &other) = delete;
+		UsedWordGuard(UsedWordGuard &&other);
+		UsedWordGuard &operator=(const UsedWordGuard &other) = delete;
+		UsedWordGuard &operator=(UsedWordGuard &&other) = delete;
+		explicit operator bool() const;
+		~UsedWordGuard();
+
+	private:
+		std::vector<small> &_map;
+		int _index = 0;
+		bool _guarded = false;
+
+	};
+	std::vector<small> _currentItemWordsUsedMap;
+
+};
+
+Completer::UsedWordGuard::UsedWordGuard(std::vector<small> &map, int index) : _map(map), _index(index) {
+	if (!_map[_index]) {
+		_guarded = _map[_index] = 1;
+	}
+}
+
+Completer::UsedWordGuard::UsedWordGuard(UsedWordGuard &&other) : _map(other._map), _index(other._index), _guarded(other._guarded) {
+	other._guarded = 0;
+}
+
+Completer::UsedWordGuard::operator bool() const {
+	return _guarded;
+}
+
+Completer::UsedWordGuard::~UsedWordGuard() {
+	if (_guarded) {
+		_map[_index] = 0;
+	}
+}
+
+Completer::Completer(utf16string query) : _initialQuery(query), _query(NormalizeQuery(query)) {
+}
+
+// Remove all non-letters-or-numbers.
+// Leave '-' and '+' only if they're followed by a number or
+// at the end of the query (so it is possibly followed by a number).
+std::vector<utf16char> Completer::NormalizeQuery(utf16string query) {
+	auto result = std::vector<utf16char>();
+	result.reserve(query.size());
+	auto copyFrom = query.data();
+	auto e = copyFrom + query.size();
+	auto copyTo = result.data();
+	for (auto i = query.data(); i != e; ++i) {
+		if (IsLetterOrNumber(*i)) {
+			continue;
+		} else if (*i == '-' || *i == '+') {
+			if (i + 1 == e || IsNumber(*(i + 1))) {
+				continue;
+			}
+		}
+		if (i > copyFrom) {
+			result.resize(result.size() + (i - copyFrom));
+			memcpy(copyTo, copyFrom, (i - copyFrom) * sizeof(utf16char));
+			copyTo += (i - copyFrom);
+		}
+		copyFrom = i + 1;
+	}
+	if (e > copyFrom) {
+		result.resize(result.size() + (e - copyFrom));
+		memcpy(copyTo, copyFrom, (e - copyFrom) * sizeof(utf16char));
+		copyTo += (e - copyFrom);
+	}
+	return result;
+}
+
+std::vector<Suggestion> Completer::resolve() {
+	_queryBegin = _query.data();
+	_querySize = _query.size();
+	if (!_querySize) {
+		return std::vector<Suggestion>();
+	}
+	_initialList = GetReplacements(*_queryBegin);
+	if (!_initialList) {
+		return std::vector<Suggestion>();
+	}
+	_result.reserve(_initialList->size());
+	processInitialList();
+	return prepareResult();
+}
+
+bool Completer::isDuplicateOfLastResult(const Replacement *item) const {
+	if (_result.empty()) {
+		return false;
+	}
+	return (_result.back().replacement->emoji == item->emoji);
+}
+
+bool Completer::isBetterThanLastResult(const Replacement *item) const {
+	auto &last = _result.back();
+	if (_currentItemWordsUsedCount < last.wordsUsed) {
+		return true;
+	}
+
+	auto firstCharOfQuery = _query[0];
+	auto firstCharAfterColonLast = last.replacement->replacement[1];
+	auto firstCharAfterColonCurrent = item->replacement[1];
+	auto goodLast = (firstCharAfterColonLast == firstCharOfQuery);
+	auto goodCurrent = (firstCharAfterColonCurrent == firstCharOfQuery);
+	return !goodLast && goodCurrent;
+}
+
+void Completer::addResult(const Replacement *item) {
+	if (!isDuplicateOfLastResult(item)) {
+		_result.push_back({ item, _currentItemWordsUsedCount });
+	} else if (isBetterThanLastResult(item)) {
+		_result.back() = { item, _currentItemWordsUsedCount };
+	}
+}
+
+void Completer::processInitialList() {
+	if (_querySize > 1) {
+		filterInitialList();
+	} else {
+		_currentItemWordsUsedCount = 1;
+		for (auto item : *_initialList) {
+			addResult(item);
+		}
+	}
+}
+
+void Completer::initWordsTracking() {
+	auto maxWordsCount = 0;
+	for (auto item : *_initialList) {
+		auto wordsCount = item->words.size();
+		if (maxWordsCount < wordsCount) {
+			maxWordsCount = wordsCount;
+		}
+	}
+	_currentItemWordsUsedMap = std::vector<small>(maxWordsCount, 0);
+}
+
+void Completer::filterInitialList() {
+	initWordsTracking();
+	for (auto item : *_initialList) {
+		_currentItemWords = string_span(item->words);
+		_currentItemWordsUsedCount = 1;
+		if (matchQueryForCurrentItem()) {
+			addResult(item);
+		}
+		_currentItemWordsUsedCount = 0;
+	}
+}
+
+bool Completer::matchQueryForCurrentItem() {
+	if (_currentItemWords.size() < 2) {
+		return startsWithQuery(*_currentItemWords.begin());
+	}
+	return matchQueryTailStartingFrom(0);
+}
+
+bool Completer::startsWithQuery(utf16string word) {
+	if (word.size() < _query.size()) {
+		return false;
+	}
+	for (auto i = std::size_t(0), size = _query.size(); i != size; ++i) {
+		if (word[i] != _query[i]) {
+			return false;
+		}
+	}
+	return true;
+}
+
+bool Completer::isExactMatch(utf16string replacement) {
+	if (replacement.size() != _initialQuery.size() + 1) {
+		return false;
+	}
+	for (auto i = std::size_t(0), size = _initialQuery.size(); i != size; ++i) {
+		if (replacement[i] != _initialQuery[i]) {
+			return false;
+		}
+	}
+	return true;
+}
+
+bool Completer::matchQueryTailStartingFrom(int position) {
+	auto charsLeftToMatch = (_querySize - position);
+	if (!charsLeftToMatch) {
+		return true;
+	}
+
+	auto firstCharToMatch = *(_queryBegin + position);
+	auto foundWords = findWordsStartingWith(firstCharToMatch);
+
+	for (auto word = foundWords.begin(), foundWordsEnd = word + foundWords.size(); word != foundWordsEnd; ++word) {
+		auto wordIndex = word - _currentItemWords.begin();
+		if (auto guard = UsedWordGuard(_currentItemWordsUsedMap, wordIndex)) {
+			++_currentItemWordsUsedCount;
+			auto equalCharsCount = findEqualCharsCount(position, word);
+			for (auto check = equalCharsCount; check != 0; --check) {
+				if (matchQueryTailStartingFrom(position + check)) {
+					return true;
+				}
+			}
+			--_currentItemWordsUsedCount;
+		}
+	}
+	return false;
+}
+
+int Completer::findEqualCharsCount(int position, const utf16string *word) {
+	auto charsLeft = (_querySize - position);
+	auto wordBegin = word->data();
+	auto wordSize = word->size();
+	auto possibleEqualCharsCount = (charsLeft > wordSize ? wordSize : charsLeft);
+	for (auto equalTill = 1; equalTill != possibleEqualCharsCount; ++equalTill) {
+		auto wordCh = *(wordBegin + equalTill);
+		auto queryCh = *(_queryBegin + position + equalTill);
+		if (wordCh != queryCh) {
+			return equalTill;
+		}
+	}
+	return possibleEqualCharsCount;
+}
+
+std::vector<Suggestion> Completer::prepareResult() {
+	auto firstCharOfQuery = _query[0];
+	std::stable_partition(_result.begin(), _result.end(), [firstCharOfQuery](Result &result) {
+		auto firstCharAfterColon = result.replacement->replacement[1];
+		return (firstCharAfterColon == firstCharOfQuery);
+	});
+	std::stable_partition(_result.begin(), _result.end(), [](Result &result) {
+		return (result.wordsUsed < 2);
+	});
+	std::stable_partition(_result.begin(), _result.end(), [](Result &result) {
+		return (result.wordsUsed < 3);
+	});
+	std::stable_partition(_result.begin(), _result.end(), [this](Result &result) {
+		return isExactMatch(result.replacement->replacement);
+	});
+
+	auto result = std::vector<Suggestion>();
+	result.reserve(_result.size());
+	for (auto &item : _result) {
+		result.emplace_back(item.replacement->emoji, item.replacement->replacement, item.replacement->replacement);
+	}
+	return result;
+}
+
+string_span Completer::findWordsStartingWith(utf16char ch) {
+	auto begin = std::lower_bound(_currentItemWords.begin(), _currentItemWords.end(), ch, [](utf16string word, utf16char ch) {
+		return word[0] < ch;
+	});
+	auto end = std::upper_bound(_currentItemWords.begin(), _currentItemWords.end(), ch, [](utf16char ch, utf16string word) {
+		return ch < word[0];
+	});
+	return _currentItemWords.subspan(begin - _currentItemWords.begin(), end - begin);
+}
+
+std::vector<Suggestion> GetSuggestions(utf16string query) {
+	return Completer(query).resolve();
+}
+
+int GetSuggestionMaxLength() {
+	return kReplacementMaxLength;
+}
+
+jclass jclass_Suggestion = nullptr;
+jmethodID jclass_Suggestion_constructor;
+
+extern "C" {
+
+jobjectArray
+Java_org_telegram_messenger_Emoji_getSuggestion(JNIEnv *env, jobject object, jstring query) {
+    const jchar *raw = env->GetStringChars(query, 0);
+    jsize len = env->GetStringLength(query);
+    std::vector<Suggestion> suggestions = GetSuggestions(utf16string(raw, len));
+    env->ReleaseStringChars(query, raw);
+
+    if (suggestions.empty()) {
+        return nullptr;
+    }
+
+    if (jclass_Suggestion == nullptr) {
+        jclass_Suggestion = (jclass) env->NewGlobalRef(env->FindClass("org/telegram/messenger/EmojiSuggestion"));
+        jclass_Suggestion_constructor = env->GetMethodID(jclass_Suggestion, "<init>",
+                                                         "(Ljava/lang/String;Ljava/lang/String;)V");
+    }
+
+    jobjectArray result = env->NewObjectArray(suggestions.size(), jclass_Suggestion, nullptr);
+    size_t size = suggestions.size();
+    for (size_t a = 0; a < size; a++) {
+        Suggestion &suggestion = suggestions[a];
+        utf16string emoji = suggestion.emoji();
+        utf16string label = suggestion.label();
+        jstring emojiStr = env->NewString(emoji.data(), emoji.size());
+        jstring labelStr = env->NewString(label.data(), label.size());
+        object = env->NewObject(jclass_Suggestion, jclass_Suggestion_constructor, emojiStr, labelStr);
+        env->SetObjectArrayElement(result, a, object);
+		env->DeleteLocalRef(object);
+        env->DeleteLocalRef(emojiStr);
+        env->DeleteLocalRef(labelStr);
+    }
+
+    return result;
+}
+
+}
diff --git a/TMessagesProj/jni/emoji/emoji_suggestions.h b/TMessagesProj/jni/emoji/emoji_suggestions.h
new file mode 100644
index 000000000..e6000ffd0
--- /dev/null
+++ b/TMessagesProj/jni/emoji/emoji_suggestions.h
@@ -0,0 +1,97 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop version of Telegram messaging app, see https://telegram.org
+
+Telegram Desktop is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+It is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+In addition, as a special exception, the copyright holders give permission
+to link the code of portions of this program with the OpenSSL library.
+
+Full license: https://github.com/telegramdesktop/tdesktop/blob/master/LICENSE
+Copyright (c) 2014-2017 John Preston, https://desktop.telegram.org
+*/
+#pragma once
+
+#include <vector>
+#include <cstring>
+
+using small = unsigned char;
+using medium = unsigned short;
+using utf16char = unsigned short;
+
+static_assert(sizeof(utf16char) == 2, "Bad UTF-16 character size.");
+
+class utf16string {
+public:
+	utf16string() = default;
+	utf16string(const utf16char *data, std::size_t size) : data_(data), size_(size) {
+	}
+	utf16string(const utf16string &other) = default;
+	utf16string &operator=(const utf16string &other) = default;
+
+	const utf16char *data() const {
+		return data_;
+	}
+	std::size_t size() const {
+		return size_;
+	}
+
+	utf16char operator[](int index) const {
+		return data_[index];
+	}
+
+private:
+	const utf16char *data_ = nullptr;
+	std::size_t size_ = 0;
+
+};
+
+inline bool operator==(utf16string a, utf16string b) {
+	return (a.size() == b.size()) && (!a.size() || !memcmp(a.data(), b.data(), a.size() * sizeof(utf16char)));
+}
+
+using checksum = unsigned int;
+checksum countChecksum(const void *data, std::size_t size);
+
+utf16string GetReplacementEmoji(utf16string replacement);
+
+class Suggestion {
+public:
+	Suggestion() = default;
+	Suggestion(utf16string emoji, utf16string label, utf16string replacement) : emoji_(emoji), label_(label), replacement_(replacement) {
+	}
+	Suggestion(const Suggestion &other) = default;
+	Suggestion &operator=(const Suggestion &other) = default;
+
+	utf16string emoji() const {
+		return emoji_;
+	}
+	utf16string label() const {
+		return label_;
+	}
+	utf16string replacement() const {
+		return replacement_;
+	}
+
+private:
+	utf16string emoji_;
+	utf16string label_;
+	utf16string replacement_;
+
+};
+
+std::vector<Suggestion> GetSuggestions(utf16string query);
+
+inline utf16string GetSuggestionEmoji(utf16string replacement) {
+	return GetReplacementEmoji(replacement);
+}
+
+int GetSuggestionMaxLength();
diff --git a/TMessagesProj/jni/emoji/emoji_suggestions_data.cpp b/TMessagesProj/jni/emoji/emoji_suggestions_data.cpp
new file mode 100644
index 000000000..c6b570c4f
--- /dev/null
+++ b/TMessagesProj/jni/emoji/emoji_suggestions_data.cpp
@@ -0,0 +1,6356 @@
+/*
+WARNING! All changes made in this file will be lost!
+Created from 'empty' by 'codegen_emoji'
+
+This file is part of Telegram Desktop,
+the official desktop version of Telegram messaging app, see https://telegram.org
+
+Telegram Desktop is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+It is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+In addition, as a special exception, the copyright holders give permission
+to link the code of portions of this program with the OpenSSL library.
+
+Full license: https://github.com/telegramdesktop/tdesktop/blob/master/LICENSE
+Copyright (c) 2014-2017 John Preston, https://desktop.telegram.org
+*/
+#include "emoji_suggestions_data.h"
+
+#include <map>
+
+struct ReplacementStruct {
+	small emojiSize;
+	small replacementSize;
+	small wordsCount;
+};
+
+const utf16char ReplacementData[] = {
+0xd83d, 0xde00, 0x3a, 0x67, 0x72, 0x69, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x3a,
+0x67, 0x72, 0x69, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0xd83d, 0xde03, 0x3a, 0x73,
+0x6d, 0x69, 0x6c, 0x65, 0x79, 0x3a, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x79,
+0xd83d, 0xde04, 0x3a, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x3a, 0x73, 0x6d, 0x69,
+0x6c, 0x65, 0xd83d, 0xde01, 0x3a, 0x67, 0x72, 0x69, 0x6e, 0x3a, 0x67, 0x72,
+0x69, 0x6e, 0xd83d, 0xde06, 0x3a, 0x73, 0x61, 0x74, 0x69, 0x73, 0x66, 0x69,
+0x65, 0x64, 0x3a, 0x73, 0x61, 0x74, 0x69, 0x73, 0x66, 0x69, 0x65, 0x64,
+0xd83d, 0xde06, 0x3a, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x69, 0x6e, 0x67, 0x3a,
+0x6c, 0x61, 0x75, 0x67, 0x68, 0x69, 0x6e, 0x67, 0xd83d, 0xde05, 0x3a, 0x73,
+0x77, 0x65, 0x61, 0x74, 0x5f, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x3a, 0x73,
+0x6d, 0x69, 0x6c, 0x65, 0x73, 0x77, 0x65, 0x61, 0x74, 0xd83d, 0xde02, 0x3a,
+0x6a, 0x6f, 0x79, 0x3a, 0x6a, 0x6f, 0x79, 0xd83e, 0xdd23, 0x3a, 0x72, 0x6f,
+0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x6f, 0x6e, 0x5f, 0x74, 0x68, 0x65,
+0x5f, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x5f, 0x6c, 0x61, 0x75, 0x67, 0x68,
+0x69, 0x6e, 0x67, 0x3a, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x6c, 0x61, 0x75,
+0x67, 0x68, 0x69, 0x6e, 0x67, 0x6f, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x69,
+0x6e, 0x67, 0x74, 0x68, 0x65, 0xd83e, 0xdd23, 0x3a, 0x72, 0x6f, 0x66, 0x6c,
+0x3a, 0x72, 0x6f, 0x66, 0x6c, 0x263a, 0xfe0f, 0x3a, 0x72, 0x65, 0x6c, 0x61,
+0x78, 0x65, 0x64, 0x3a, 0x72, 0x65, 0x6c, 0x61, 0x78, 0x65, 0x64, 0xd83d,
+0xde0a, 0x3a, 0x62, 0x6c, 0x75, 0x73, 0x68, 0x3a, 0x62, 0x6c, 0x75, 0x73,
+0x68, 0xd83d, 0xde07, 0x3a, 0x69, 0x6e, 0x6e, 0x6f, 0x63, 0x65, 0x6e, 0x74,
+0x3a, 0x69, 0x6e, 0x6e, 0x6f, 0x63, 0x65, 0x6e, 0x74, 0xd83d, 0xde42, 0x3a,
+0x73, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x6c, 0x79, 0x5f, 0x73, 0x6d, 0x69,
+0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x73, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x6c, 0x79, 0x73, 0x6d,
+0x69, 0x6c, 0x69, 0x6e, 0x67, 0xd83d, 0xde42, 0x3a, 0x73, 0x6c, 0x69, 0x67,
+0x68, 0x74, 0x5f, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x3a, 0x73, 0x6c, 0x69,
+0x67, 0x68, 0x74, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0xd83d, 0xde43, 0x3a, 0x75,
+0x70, 0x73, 0x69, 0x64, 0x65, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x66,
+0x61, 0x63, 0x65, 0x3a, 0x64, 0x6f, 0x77, 0x6e, 0x66, 0x61, 0x63, 0x65,
+0x75, 0x70, 0x73, 0x69, 0x64, 0x65, 0xd83d, 0xde43, 0x3a, 0x75, 0x70, 0x73,
+0x69, 0x64, 0x65, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x64, 0x6f, 0x77,
+0x6e, 0x75, 0x70, 0x73, 0x69, 0x64, 0x65, 0xd83d, 0xde09, 0x3a, 0x77, 0x69,
+0x6e, 0x6b, 0x3a, 0x77, 0x69, 0x6e, 0x6b, 0xd83d, 0xde0c, 0x3a, 0x72, 0x65,
+0x6c, 0x69, 0x65, 0x76, 0x65, 0x64, 0x3a, 0x72, 0x65, 0x6c, 0x69, 0x65,
+0x76, 0x65, 0x64, 0xd83d, 0xde0d, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f,
+0x65, 0x79, 0x65, 0x73, 0x3a, 0x65, 0x79, 0x65, 0x73, 0x68, 0x65, 0x61,
+0x72, 0x74, 0xd83d, 0xde18, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67,
+0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74,
+0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0xd83d, 0xde17, 0x3a, 0x6b, 0x69,
+0x73, 0x73, 0x69, 0x6e, 0x67, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e,
+0x67, 0xd83d, 0xde19, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x5f,
+0x73, 0x6d, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x79, 0x65, 0x73,
+0x3a, 0x65, 0x79, 0x65, 0x73, 0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67,
+0x73, 0x6d, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0xd83d, 0xde1a, 0x3a, 0x6b, 0x69,
+0x73, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64,
+0x5f, 0x65, 0x79, 0x65, 0x73, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64,
+0x65, 0x79, 0x65, 0x73, 0x6b, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0xd83d,
+0xde0b, 0x3a, 0x79, 0x75, 0x6d, 0x3a, 0x79, 0x75, 0x6d, 0xd83d, 0xde1c, 0x3a,
+0x73, 0x74, 0x75, 0x63, 0x6b, 0x5f, 0x6f, 0x75, 0x74, 0x5f, 0x74, 0x6f,
+0x6e, 0x67, 0x75, 0x65, 0x5f, 0x77, 0x69, 0x6e, 0x6b, 0x69, 0x6e, 0x67,
+0x5f, 0x65, 0x79, 0x65, 0x3a, 0x65, 0x79, 0x65, 0x6f, 0x75, 0x74, 0x73,
+0x74, 0x75, 0x63, 0x6b, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x77, 0x69,
+0x6e, 0x6b, 0x69, 0x6e, 0x67, 0xd83d, 0xde1d, 0x3a, 0x73, 0x74, 0x75, 0x63,
+0x6b, 0x5f, 0x6f, 0x75, 0x74, 0x5f, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65,
+0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x5f, 0x65, 0x79, 0x65, 0x73,
+0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x65, 0x79, 0x65, 0x73, 0x6f,
+0x75, 0x74, 0x73, 0x74, 0x75, 0x63, 0x6b, 0x74, 0x6f, 0x6e, 0x67, 0x75,
+0x65, 0xd83d, 0xde1b, 0x3a, 0x73, 0x74, 0x75, 0x63, 0x6b, 0x5f, 0x6f, 0x75,
+0x74, 0x5f, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x3a, 0x6f, 0x75, 0x74,
+0x73, 0x74, 0x75, 0x63, 0x6b, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0xd83e,
+0xdd11, 0x3a, 0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x5f, 0x6d, 0x6f, 0x75, 0x74,
+0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x6d,
+0x6f, 0x6e, 0x65, 0x79, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0xd83e, 0xdd11, 0x3a,
+0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x5f, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0x3a,
+0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0xd83e, 0xdd17,
+0x3a, 0x68, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x68, 0x75, 0x67, 0x67, 0x69, 0x6e,
+0x67, 0xd83e, 0xdd17, 0x3a, 0x68, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x3a,
+0x68, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0xd83e, 0xdd13, 0x3a, 0x6e, 0x65,
+0x72, 0x64, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x6e, 0x65, 0x72, 0x64, 0xd83e, 0xdd13, 0x3a, 0x6e, 0x65, 0x72, 0x64, 0x3a,
+0x6e, 0x65, 0x72, 0x64, 0xd83d, 0xde0e, 0x3a, 0x73, 0x75, 0x6e, 0x67, 0x6c,
+0x61, 0x73, 0x73, 0x65, 0x73, 0x3a, 0x73, 0x75, 0x6e, 0x67, 0x6c, 0x61,
+0x73, 0x73, 0x65, 0x73, 0xd83e, 0xdd21, 0x3a, 0x63, 0x6c, 0x6f, 0x77, 0x6e,
+0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x63, 0x6c, 0x6f, 0x77, 0x6e, 0x66,
+0x61, 0x63, 0x65, 0xd83e, 0xdd21, 0x3a, 0x63, 0x6c, 0x6f, 0x77, 0x6e, 0x3a,
+0x63, 0x6c, 0x6f, 0x77, 0x6e, 0xd83e, 0xdd20, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x63, 0x6f, 0x77, 0x62, 0x6f, 0x79,
+0x5f, 0x68, 0x61, 0x74, 0x3a, 0x63, 0x6f, 0x77, 0x62, 0x6f, 0x79, 0x66,
+0x61, 0x63, 0x65, 0x68, 0x61, 0x74, 0x77, 0x69, 0x74, 0x68, 0xd83e, 0xdd20,
+0x3a, 0x63, 0x6f, 0x77, 0x62, 0x6f, 0x79, 0x3a, 0x63, 0x6f, 0x77, 0x62,
+0x6f, 0x79, 0xd83d, 0xde0f, 0x3a, 0x73, 0x6d, 0x69, 0x72, 0x6b, 0x3a, 0x73,
+0x6d, 0x69, 0x72, 0x6b, 0xd83d, 0xde12, 0x3a, 0x75, 0x6e, 0x61, 0x6d, 0x75,
+0x73, 0x65, 0x64, 0x3a, 0x75, 0x6e, 0x61, 0x6d, 0x75, 0x73, 0x65, 0x64,
+0xd83d, 0xde1e, 0x3a, 0x64, 0x69, 0x73, 0x61, 0x70, 0x70, 0x6f, 0x69, 0x6e,
+0x74, 0x65, 0x64, 0x3a, 0x64, 0x69, 0x73, 0x61, 0x70, 0x70, 0x6f, 0x69,
+0x6e, 0x74, 0x65, 0x64, 0xd83d, 0xde14, 0x3a, 0x70, 0x65, 0x6e, 0x73, 0x69,
+0x76, 0x65, 0x3a, 0x70, 0x65, 0x6e, 0x73, 0x69, 0x76, 0x65, 0xd83d, 0xde1f,
+0x3a, 0x77, 0x6f, 0x72, 0x72, 0x69, 0x65, 0x64, 0x3a, 0x77, 0x6f, 0x72,
+0x72, 0x69, 0x65, 0x64, 0xd83d, 0xde15, 0x3a, 0x63, 0x6f, 0x6e, 0x66, 0x75,
+0x73, 0x65, 0x64, 0x3a, 0x63, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x65, 0x64,
+0xd83d, 0xde41, 0x3a, 0x73, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x6c, 0x79, 0x5f,
+0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69,
+0x6e, 0x67, 0x73, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x6c, 0x79, 0xd83d, 0xde41,
+0x3a, 0x73, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x72, 0x6f, 0x77,
+0x6e, 0x3a, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x73, 0x6c, 0x69, 0x67, 0x68,
+0x74, 0x2639, 0xfe0f, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x66, 0x72,
+0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a,
+0x66, 0x61, 0x63, 0x65, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67,
+0x77, 0x68, 0x69, 0x74, 0x65, 0x2639, 0xfe0f, 0x3a, 0x66, 0x72, 0x6f, 0x77,
+0x6e, 0x69, 0x6e, 0x67, 0x32, 0x3a, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69,
+0x6e, 0x67, 0x32, 0xd83d, 0xde23, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x65, 0x76,
+0x65, 0x72, 0x65, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x65, 0x76, 0x65, 0x72,
+0x65, 0xd83d, 0xde16, 0x3a, 0x63, 0x6f, 0x6e, 0x66, 0x6f, 0x75, 0x6e, 0x64,
+0x65, 0x64, 0x3a, 0x63, 0x6f, 0x6e, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x65,
+0x64, 0xd83d, 0xde2b, 0x3a, 0x74, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x61,
+0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x74, 0x69, 0x72, 0x65, 0x64,
+0xd83d, 0xde29, 0x3a, 0x77, 0x65, 0x61, 0x72, 0x79, 0x3a, 0x77, 0x65, 0x61,
+0x72, 0x79, 0xd83d, 0xde24, 0x3a, 0x74, 0x72, 0x69, 0x75, 0x6d, 0x70, 0x68,
+0x3a, 0x74, 0x72, 0x69, 0x75, 0x6d, 0x70, 0x68, 0xd83d, 0xde20, 0x3a, 0x61,
+0x6e, 0x67, 0x72, 0x79, 0x3a, 0x61, 0x6e, 0x67, 0x72, 0x79, 0xd83d, 0xde21,
+0x3a, 0x72, 0x61, 0x67, 0x65, 0x3a, 0x72, 0x61, 0x67, 0x65, 0xd83d, 0xde36,
+0x3a, 0x6e, 0x6f, 0x5f, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0x3a, 0x6d, 0x6f,
+0x75, 0x74, 0x68, 0x6e, 0x6f, 0xd83d, 0xde10, 0x3a, 0x6e, 0x65, 0x75, 0x74,
+0x72, 0x61, 0x6c, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63,
+0x65, 0x6e, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6c, 0xd83d, 0xde11, 0x3a, 0x65,
+0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x6c, 0x65, 0x73,
+0x73, 0x3a, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
+0x6c, 0x65, 0x73, 0x73, 0xd83d, 0xde2f, 0x3a, 0x68, 0x75, 0x73, 0x68, 0x65,
+0x64, 0x3a, 0x68, 0x75, 0x73, 0x68, 0x65, 0x64, 0xd83d, 0xde26, 0x3a, 0x66,
+0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x66, 0x72, 0x6f, 0x77,
+0x6e, 0x69, 0x6e, 0x67, 0xd83d, 0xde27, 0x3a, 0x61, 0x6e, 0x67, 0x75, 0x69,
+0x73, 0x68, 0x65, 0x64, 0x3a, 0x61, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68,
+0x65, 0x64, 0xd83d, 0xde2e, 0x3a, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x6d, 0x6f,
+0x75, 0x74, 0x68, 0x3a, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0x6f, 0x70, 0x65,
+0x6e, 0xd83d, 0xde32, 0x3a, 0x61, 0x73, 0x74, 0x6f, 0x6e, 0x69, 0x73, 0x68,
+0x65, 0x64, 0x3a, 0x61, 0x73, 0x74, 0x6f, 0x6e, 0x69, 0x73, 0x68, 0x65,
+0x64, 0xd83d, 0xde35, 0x3a, 0x64, 0x69, 0x7a, 0x7a, 0x79, 0x5f, 0x66, 0x61,
+0x63, 0x65, 0x3a, 0x64, 0x69, 0x7a, 0x7a, 0x79, 0x66, 0x61, 0x63, 0x65,
+0xd83d, 0xde33, 0x3a, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x65, 0x64, 0x3a, 0x66,
+0x6c, 0x75, 0x73, 0x68, 0x65, 0x64, 0xd83d, 0xde31, 0x3a, 0x73, 0x63, 0x72,
+0x65, 0x61, 0x6d, 0x3a, 0x73, 0x63, 0x72, 0x65, 0x61, 0x6d, 0xd83d, 0xde28,
+0x3a, 0x66, 0x65, 0x61, 0x72, 0x66, 0x75, 0x6c, 0x3a, 0x66, 0x65, 0x61,
+0x72, 0x66, 0x75, 0x6c, 0xd83d, 0xde30, 0x3a, 0x63, 0x6f, 0x6c, 0x64, 0x5f,
+0x73, 0x77, 0x65, 0x61, 0x74, 0x3a, 0x63, 0x6f, 0x6c, 0x64, 0x73, 0x77,
+0x65, 0x61, 0x74, 0xd83d, 0xde22, 0x3a, 0x63, 0x72, 0x79, 0x3a, 0x63, 0x72,
+0x79, 0xd83d, 0xde25, 0x3a, 0x64, 0x69, 0x73, 0x61, 0x70, 0x70, 0x6f, 0x69,
+0x6e, 0x74, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x6c, 0x69, 0x65, 0x76, 0x65,
+0x64, 0x3a, 0x64, 0x69, 0x73, 0x61, 0x70, 0x70, 0x6f, 0x69, 0x6e, 0x74,
+0x65, 0x64, 0x72, 0x65, 0x6c, 0x69, 0x65, 0x76, 0x65, 0x64, 0xd83e, 0xdd24,
+0x3a, 0x64, 0x72, 0x6f, 0x6f, 0x6c, 0x3a, 0x64, 0x72, 0x6f, 0x6f, 0x6c,
+0xd83e, 0xdd24, 0x3a, 0x64, 0x72, 0x6f, 0x6f, 0x6c, 0x69, 0x6e, 0x67, 0x5f,
+0x66, 0x61, 0x63, 0x65, 0x3a, 0x64, 0x72, 0x6f, 0x6f, 0x6c, 0x69, 0x6e,
+0x67, 0x66, 0x61, 0x63, 0x65, 0xd83d, 0xde2d, 0x3a, 0x73, 0x6f, 0x62, 0x3a,
+0x73, 0x6f, 0x62, 0xd83d, 0xde13, 0x3a, 0x73, 0x77, 0x65, 0x61, 0x74, 0x3a,
+0x73, 0x77, 0x65, 0x61, 0x74, 0xd83d, 0xde2a, 0x3a, 0x73, 0x6c, 0x65, 0x65,
+0x70, 0x79, 0x3a, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x79, 0xd83d, 0xde34, 0x3a,
+0x73, 0x6c, 0x65, 0x65, 0x70, 0x69, 0x6e, 0x67, 0x3a, 0x73, 0x6c, 0x65,
+0x65, 0x70, 0x69, 0x6e, 0x67, 0xd83d, 0xde44, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e,
+0x67, 0x5f, 0x65, 0x79, 0x65, 0x73, 0x3a, 0x65, 0x79, 0x65, 0x73, 0x66,
+0x61, 0x63, 0x65, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xde44, 0x3a, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67,
+0x5f, 0x65, 0x79, 0x65, 0x73, 0x3a, 0x65, 0x79, 0x65, 0x73, 0x72, 0x6f,
+0x6c, 0x6c, 0x69, 0x6e, 0x67, 0xd83e, 0xdd14, 0x3a, 0x68, 0x6d, 0x6d, 0x3a,
+0x68, 0x6d, 0x6d, 0xd83e, 0xdd14, 0x3a, 0x74, 0x68, 0x69, 0x6e, 0x6b, 0x69,
+0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x74, 0x68, 0x69, 0x6e, 0x6b, 0x69, 0x6e, 0x67, 0xd83e, 0xdd14, 0x3a, 0x74,
+0x68, 0x69, 0x6e, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x74, 0x68, 0x69, 0x6e,
+0x6b, 0x69, 0x6e, 0x67, 0xd83e, 0xdd25, 0x3a, 0x6c, 0x69, 0x61, 0x72, 0x3a,
+0x6c, 0x69, 0x61, 0x72, 0xd83e, 0xdd25, 0x3a, 0x6c, 0x79, 0x69, 0x6e, 0x67,
+0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x6c, 0x79,
+0x69, 0x6e, 0x67, 0xd83d, 0xde2c, 0x3a, 0x67, 0x72, 0x69, 0x6d, 0x61, 0x63,
+0x69, 0x6e, 0x67, 0x3a, 0x67, 0x72, 0x69, 0x6d, 0x61, 0x63, 0x69, 0x6e,
+0x67, 0xd83e, 0xdd10, 0x3a, 0x7a, 0x69, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6d,
+0x6f, 0x75, 0x74, 0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0x7a, 0x69, 0x70, 0x70, 0x65,
+0x72, 0xd83e, 0xdd10, 0x3a, 0x7a, 0x69, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6d,
+0x6f, 0x75, 0x74, 0x68, 0x3a, 0x6d, 0x6f, 0x75, 0x74, 0x68, 0x7a, 0x69,
+0x70, 0x70, 0x65, 0x72, 0xd83e, 0xdd22, 0x3a, 0x73, 0x69, 0x63, 0x6b, 0x3a,
+0x73, 0x69, 0x63, 0x6b, 0xd83e, 0xdd22, 0x3a, 0x6e, 0x61, 0x75, 0x73, 0x65,
+0x61, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x6e, 0x61, 0x75, 0x73, 0x65, 0x61, 0x74, 0x65, 0x64, 0xd83e,
+0xdd27, 0x3a, 0x73, 0x6e, 0x65, 0x65, 0x7a, 0x65, 0x3a, 0x73, 0x6e, 0x65,
+0x65, 0x7a, 0x65, 0xd83e, 0xdd27, 0x3a, 0x73, 0x6e, 0x65, 0x65, 0x7a, 0x69,
+0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x73, 0x6e, 0x65, 0x65, 0x7a, 0x69, 0x6e, 0x67, 0xd83d, 0xde37, 0x3a, 0x6d,
+0x61, 0x73, 0x6b, 0x3a, 0x6d, 0x61, 0x73, 0x6b, 0xd83e, 0xdd12, 0x3a, 0x66,
+0x61, 0x63, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x74, 0x68, 0x65,
+0x72, 0x6d, 0x6f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x3a, 0x66, 0x61, 0x63,
+0x65, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x6f, 0x6d, 0x65, 0x74, 0x65, 0x72,
+0x77, 0x69, 0x74, 0x68, 0xd83e, 0xdd12, 0x3a, 0x74, 0x68, 0x65, 0x72, 0x6d,
+0x6f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a,
+0x66, 0x61, 0x63, 0x65, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x6f, 0x6d, 0x65,
+0x74, 0x65, 0x72, 0xd83e, 0xdd15, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x5f, 0x62, 0x61, 0x6e,
+0x64, 0x61, 0x67, 0x65, 0x3a, 0x62, 0x61, 0x6e, 0x64, 0x61, 0x67, 0x65,
+0x66, 0x61, 0x63, 0x65, 0x68, 0x65, 0x61, 0x64, 0x77, 0x69, 0x74, 0x68,
+0xd83e, 0xdd15, 0x3a, 0x68, 0x65, 0x61, 0x64, 0x5f, 0x62, 0x61, 0x6e, 0x64,
+0x61, 0x67, 0x65, 0x3a, 0x62, 0x61, 0x6e, 0x64, 0x61, 0x67, 0x65, 0x68,
+0x65, 0x61, 0x64, 0xd83d, 0xde08, 0x3a, 0x73, 0x6d, 0x69, 0x6c, 0x69, 0x6e,
+0x67, 0x5f, 0x69, 0x6d, 0x70, 0x3a, 0x69, 0x6d, 0x70, 0x73, 0x6d, 0x69,
+0x6c, 0x69, 0x6e, 0x67, 0xd83d, 0xdc7f, 0x3a, 0x69, 0x6d, 0x70, 0x3a, 0x69,
+0x6d, 0x70, 0xd83d, 0xdc79, 0x3a, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73,
+0x65, 0x5f, 0x6f, 0x67, 0x72, 0x65, 0x3a, 0x6a, 0x61, 0x70, 0x61, 0x6e,
+0x65, 0x73, 0x65, 0x6f, 0x67, 0x72, 0x65, 0xd83d, 0xdc7a, 0x3a, 0x6a, 0x61,
+0x70, 0x61, 0x6e, 0x65, 0x73, 0x65, 0x5f, 0x67, 0x6f, 0x62, 0x6c, 0x69,
+0x6e, 0x3a, 0x67, 0x6f, 0x62, 0x6c, 0x69, 0x6e, 0x6a, 0x61, 0x70, 0x61,
+0x6e, 0x65, 0x73, 0x65, 0xd83d, 0xdca9, 0x3a, 0x70, 0x6f, 0x6f, 0x3a, 0x70,
+0x6f, 0x6f, 0xd83d, 0xdca9, 0x3a, 0x68, 0x61, 0x6e, 0x6b, 0x65, 0x79, 0x3a,
+0x68, 0x61, 0x6e, 0x6b, 0x65, 0x79, 0xd83d, 0xdca9, 0x3a, 0x73, 0x68, 0x69,
+0x74, 0x3a, 0x73, 0x68, 0x69, 0x74, 0xd83d, 0xdca9, 0x3a, 0x70, 0x6f, 0x6f,
+0x70, 0x3a, 0x70, 0x6f, 0x6f, 0x70, 0xd83d, 0xdc7b, 0x3a, 0x67, 0x68, 0x6f,
+0x73, 0x74, 0x3a, 0x67, 0x68, 0x6f, 0x73, 0x74, 0xd83d, 0xdc80, 0x3a, 0x73,
+0x6b, 0x65, 0x6c, 0x65, 0x74, 0x6f, 0x6e, 0x3a, 0x73, 0x6b, 0x65, 0x6c,
+0x65, 0x74, 0x6f, 0x6e, 0xd83d, 0xdc80, 0x3a, 0x73, 0x6b, 0x75, 0x6c, 0x6c,
+0x3a, 0x73, 0x6b, 0x75, 0x6c, 0x6c, 0x2620, 0xfe0f, 0x3a, 0x73, 0x6b, 0x75,
+0x6c, 0x6c, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73,
+0x62, 0x6f, 0x6e, 0x65, 0x73, 0x3a, 0x61, 0x6e, 0x64, 0x63, 0x72, 0x6f,
+0x73, 0x73, 0x62, 0x6f, 0x6e, 0x65, 0x73, 0x73, 0x6b, 0x75, 0x6c, 0x6c,
+0x2620, 0xfe0f, 0x3a, 0x73, 0x6b, 0x75, 0x6c, 0x6c, 0x5f, 0x63, 0x72, 0x6f,
+0x73, 0x73, 0x62, 0x6f, 0x6e, 0x65, 0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73,
+0x73, 0x62, 0x6f, 0x6e, 0x65, 0x73, 0x73, 0x6b, 0x75, 0x6c, 0x6c, 0xd83d,
+0xdc7d, 0x3a, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x3a, 0x61, 0x6c, 0x69, 0x65,
+0x6e, 0xd83d, 0xdc7e, 0x3a, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x6e,
+0x76, 0x61, 0x64, 0x65, 0x72, 0x3a, 0x69, 0x6e, 0x76, 0x61, 0x64, 0x65,
+0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0xd83e, 0xdd16, 0x3a, 0x72, 0x6f, 0x62,
+0x6f, 0x74, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x72, 0x6f, 0x62, 0x6f, 0x74, 0xd83e, 0xdd16, 0x3a, 0x72, 0x6f, 0x62, 0x6f,
+0x74, 0x3a, 0x72, 0x6f, 0x62, 0x6f, 0x74, 0xd83c, 0xdf83, 0x3a, 0x6a, 0x61,
+0x63, 0x6b, 0x5f, 0x6f, 0x5f, 0x6c, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x6e,
+0x3a, 0x6a, 0x61, 0x63, 0x6b, 0x6c, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x6e,
+0x6f, 0xd83d, 0xde3a, 0x3a, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x79, 0x5f, 0x63,
+0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x79,
+0xd83d, 0xde38, 0x3a, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x5f, 0x63, 0x61, 0x74,
+0x3a, 0x63, 0x61, 0x74, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0xd83d, 0xde39, 0x3a,
+0x6a, 0x6f, 0x79, 0x5f, 0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x6a,
+0x6f, 0x79, 0xd83d, 0xde3b, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x65,
+0x79, 0x65, 0x73, 0x5f, 0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x65,
+0x79, 0x65, 0x73, 0x68, 0x65, 0x61, 0x72, 0x74, 0xd83d, 0xde3c, 0x3a, 0x73,
+0x6d, 0x69, 0x72, 0x6b, 0x5f, 0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74,
+0x73, 0x6d, 0x69, 0x72, 0x6b, 0xd83d, 0xde3d, 0x3a, 0x6b, 0x69, 0x73, 0x73,
+0x69, 0x6e, 0x67, 0x5f, 0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x6b,
+0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0xd83d, 0xde40, 0x3a, 0x73, 0x63, 0x72,
+0x65, 0x61, 0x6d, 0x5f, 0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x73,
+0x63, 0x72, 0x65, 0x61, 0x6d, 0xd83d, 0xde3f, 0x3a, 0x63, 0x72, 0x79, 0x69,
+0x6e, 0x67, 0x5f, 0x63, 0x61, 0x74, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a,
+0x63, 0x61, 0x74, 0x63, 0x72, 0x79, 0x69, 0x6e, 0x67, 0x66, 0x61, 0x63,
+0x65, 0xd83d, 0xde3e, 0x3a, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x5f,
+0x63, 0x61, 0x74, 0x3a, 0x63, 0x61, 0x74, 0x70, 0x6f, 0x75, 0x74, 0x69,
+0x6e, 0x67, 0xd83d, 0xdc50, 0x3a, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x68, 0x61,
+0x6e, 0x64, 0x73, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x6f, 0x70, 0x65,
+0x6e, 0xd83d, 0xde4c, 0x3a, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x5f, 0x68,
+0x61, 0x6e, 0x64, 0x73, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x72, 0x61,
+0x69, 0x73, 0x65, 0x64, 0xd83d, 0xdc4f, 0x3a, 0x63, 0x6c, 0x61, 0x70, 0x3a,
+0x63, 0x6c, 0x61, 0x70, 0xd83d, 0xde4f, 0x3a, 0x70, 0x72, 0x61, 0x79, 0x3a,
+0x70, 0x72, 0x61, 0x79, 0xd83e, 0xdd1d, 0x3a, 0x73, 0x68, 0x61, 0x6b, 0x69,
+0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x3a, 0x68, 0x61, 0x6e,
+0x64, 0x73, 0x73, 0x68, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0xd83e, 0xdd1d, 0x3a,
+0x68, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x3a, 0x68, 0x61,
+0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0xd83d, 0xdc4d, 0x3a, 0x6c, 0x69,
+0x6b, 0x65, 0x3a, 0x6c, 0x69, 0x6b, 0x65, 0xd83d, 0xdc4d, 0x3a, 0x74, 0x68,
+0x75, 0x6d, 0x62, 0x75, 0x70, 0x3a, 0x74, 0x68, 0x75, 0x6d, 0x62, 0x75,
+0x70, 0xd83d, 0xdc4d, 0x3a, 0x2b, 0x31, 0x3a, 0x2b, 0x31, 0xd83d, 0xdc4d, 0x3a,
+0x74, 0x68, 0x75, 0x6d, 0x62, 0x73, 0x75, 0x70, 0x3a, 0x74, 0x68, 0x75,
+0x6d, 0x62, 0x73, 0x75, 0x70, 0xd83d, 0xdc4e, 0x3a, 0x64, 0x69, 0x73, 0x6c,
+0x69, 0x6b, 0x65, 0x3a, 0x64, 0x69, 0x73, 0x6c, 0x69, 0x6b, 0x65, 0xd83d,
+0xdc4e, 0x3a, 0x74, 0x68, 0x75, 0x6d, 0x62, 0x64, 0x6f, 0x77, 0x6e, 0x3a,
+0x74, 0x68, 0x75, 0x6d, 0x62, 0x64, 0x6f, 0x77, 0x6e, 0xd83d, 0xdc4e, 0x3a,
+0x2d, 0x31, 0x3a, 0x2d, 0x31, 0xd83d, 0xdc4e, 0x3a, 0x74, 0x68, 0x75, 0x6d,
+0x62, 0x73, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x74, 0x68, 0x75, 0x6d, 0x62,
+0x73, 0x64, 0x6f, 0x77, 0x6e, 0xd83d, 0xdc4a, 0x3a, 0x70, 0x75, 0x6e, 0x63,
+0x68, 0x3a, 0x70, 0x75, 0x6e, 0x63, 0x68, 0x270a, 0xfe0f, 0x3a, 0x66, 0x69,
+0x73, 0x74, 0x3a, 0x66, 0x69, 0x73, 0x74, 0xd83e, 0xdd1b, 0x3a, 0x6c, 0x65,
+0x66, 0x74, 0x5f, 0x66, 0x69, 0x73, 0x74, 0x3a, 0x66, 0x69, 0x73, 0x74,
+0x6c, 0x65, 0x66, 0x74, 0xd83e, 0xdd1b, 0x3a, 0x6c, 0x65, 0x66, 0x74, 0x5f,
+0x66, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x69, 0x73, 0x74, 0x3a,
+0x66, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x66, 0x69, 0x73, 0x74, 0x6c, 0x65,
+0x66, 0x74, 0xd83e, 0xdd1c, 0x3a, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66,
+0x69, 0x73, 0x74, 0x3a, 0x66, 0x69, 0x73, 0x74, 0x72, 0x69, 0x67, 0x68,
+0x74, 0xd83e, 0xdd1c, 0x3a, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x61,
+0x63, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x69, 0x73, 0x74, 0x3a, 0x66, 0x61,
+0x63, 0x69, 0x6e, 0x67, 0x66, 0x69, 0x73, 0x74, 0x72, 0x69, 0x67, 0x68,
+0x74, 0xd83e, 0xdd1e, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x5f, 0x61, 0x6e, 0x64, 0x5f,
+0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x5f, 0x66, 0x69, 0x6e, 0x67, 0x65,
+0x72, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64, 0x3a, 0x61, 0x6e,
+0x64, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64, 0x66, 0x69, 0x6e, 0x67,
+0x65, 0x72, 0x68, 0x61, 0x6e, 0x64, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x6d,
+0x69, 0x64, 0x64, 0x6c, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83e, 0xdd1e, 0x3a,
+0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x5f, 0x63, 0x72, 0x6f, 0x73,
+0x73, 0x65, 0x64, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64, 0x66,
+0x69, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x270c, 0xfe0f, 0x3a, 0x76, 0x3a, 0x76,
+0xd83e, 0xdd18, 0x3a, 0x73, 0x69, 0x67, 0x6e, 0x5f, 0x6f, 0x66, 0x5f, 0x74,
+0x68, 0x65, 0x5f, 0x68, 0x6f, 0x72, 0x6e, 0x73, 0x3a, 0x68, 0x6f, 0x72,
+0x6e, 0x73, 0x6f, 0x66, 0x73, 0x69, 0x67, 0x6e, 0x74, 0x68, 0x65, 0xd83e,
+0xdd18, 0x3a, 0x6d, 0x65, 0x74, 0x61, 0x6c, 0x3a, 0x6d, 0x65, 0x74, 0x61,
+0x6c, 0xd83d, 0xdc4c, 0x3a, 0x6f, 0x6b, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a,
+0x68, 0x61, 0x6e, 0x64, 0x6f, 0x6b, 0xd83d, 0xdc48, 0x3a, 0x70, 0x6f, 0x69,
+0x6e, 0x74, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x3a, 0x6c, 0x65, 0x66, 0x74,
+0x70, 0x6f, 0x69, 0x6e, 0x74, 0xd83d, 0xdc49, 0x3a, 0x70, 0x6f, 0x69, 0x6e,
+0x74, 0x5f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x70, 0x6f, 0x69, 0x6e,
+0x74, 0x72, 0x69, 0x67, 0x68, 0x74, 0xd83d, 0xdc46, 0x3a, 0x70, 0x6f, 0x69,
+0x6e, 0x74, 0x5f, 0x75, 0x70, 0x5f, 0x32, 0x3a, 0x32, 0x70, 0x6f, 0x69,
+0x6e, 0x74, 0x75, 0x70, 0xd83d, 0xdc47, 0x3a, 0x70, 0x6f, 0x69, 0x6e, 0x74,
+0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x64, 0x6f, 0x77, 0x6e, 0x70, 0x6f,
+0x69, 0x6e, 0x74, 0x261d, 0xfe0f, 0x3a, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x5f,
+0x75, 0x70, 0x3a, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x75, 0x70, 0x270b, 0xfe0f,
+0x3a, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x5f, 0x68, 0x61, 0x6e, 0x64,
+0x3a, 0x68, 0x61, 0x6e, 0x64, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0xd83e,
+0xdd1a, 0x3a, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x6f, 0x66, 0x5f, 0x68, 0x61,
+0x6e, 0x64, 0x3a, 0x62, 0x61, 0x63, 0x6b, 0x68, 0x61, 0x6e, 0x64, 0x6f,
+0x66, 0xd83e, 0xdd1a, 0x3a, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x5f, 0x62,
+0x61, 0x63, 0x6b, 0x5f, 0x6f, 0x66, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a,
+0x62, 0x61, 0x63, 0x6b, 0x68, 0x61, 0x6e, 0x64, 0x6f, 0x66, 0x72, 0x61,
+0x69, 0x73, 0x65, 0x64, 0xd83d, 0xdd90, 0x3a, 0x72, 0x61, 0x69, 0x73, 0x65,
+0x64, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f,
+0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x5f, 0x73, 0x70, 0x6c, 0x61,
+0x79, 0x65, 0x64, 0x3a, 0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x68,
+0x61, 0x6e, 0x64, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x73, 0x70, 0x6c,
+0x61, 0x79, 0x65, 0x64, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdd90, 0x3a, 0x68,
+0x61, 0x6e, 0x64, 0x5f, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x3a,
+0x68, 0x61, 0x6e, 0x64, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0xd83d,
+0xdd96, 0x3a, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x5f,
+0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x5f, 0x6d, 0x69, 0x64, 0x64,
+0x6c, 0x65, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x69, 0x6e, 0x67, 0x5f,
+0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x3a, 0x61, 0x6e, 0x64, 0x62,
+0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x66, 0x69, 0x6e, 0x67, 0x65, 0x72,
+0x73, 0x68, 0x61, 0x6e, 0x64, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x70,
+0x61, 0x72, 0x74, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x72, 0x69, 0x6e,
+0x67, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdd96, 0x3a, 0x76, 0x75, 0x6c, 0x63,
+0x61, 0x6e, 0x3a, 0x76, 0x75, 0x6c, 0x63, 0x61, 0x6e, 0xd83d, 0xdc4b, 0x3a,
+0x77, 0x61, 0x76, 0x65, 0x3a, 0x77, 0x61, 0x76, 0x65, 0xd83e, 0xdd19, 0x3a,
+0x63, 0x61, 0x6c, 0x6c, 0x5f, 0x6d, 0x65, 0x5f, 0x68, 0x61, 0x6e, 0x64,
+0x3a, 0x63, 0x61, 0x6c, 0x6c, 0x68, 0x61, 0x6e, 0x64, 0x6d, 0x65, 0xd83e,
+0xdd19, 0x3a, 0x63, 0x61, 0x6c, 0x6c, 0x5f, 0x6d, 0x65, 0x3a, 0x63, 0x61,
+0x6c, 0x6c, 0x6d, 0x65, 0xd83d, 0xdcaa, 0x3a, 0x6d, 0x75, 0x73, 0x63, 0x6c,
+0x65, 0x3a, 0x6d, 0x75, 0x73, 0x63, 0x6c, 0x65, 0xd83d, 0xdd95, 0x3a, 0x72,
+0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x64, 0x5f, 0x68, 0x61, 0x6e, 0x64,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65,
+0x5f, 0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x74, 0x65,
+0x6e, 0x64, 0x65, 0x64, 0x3a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x65,
+0x64, 0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x68, 0x61, 0x6e, 0x64, 0x6d,
+0x69, 0x64, 0x64, 0x6c, 0x65, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65,
+0x64, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdd95, 0x3a, 0x6d, 0x69, 0x64, 0x64,
+0x6c, 0x65, 0x5f, 0x66, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x3a, 0x66, 0x69,
+0x6e, 0x67, 0x65, 0x72, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x270d, 0xfe0f,
+0x3a, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6e,
+0x67, 0xd83e, 0xdd33, 0x3a, 0x73, 0x65, 0x6c, 0x66, 0x69, 0x65, 0x3a, 0x73,
+0x65, 0x6c, 0x66, 0x69, 0x65, 0xd83d, 0xdc85, 0x3a, 0x6e, 0x61, 0x69, 0x6c,
+0x5f, 0x63, 0x61, 0x72, 0x65, 0x3a, 0x63, 0x61, 0x72, 0x65, 0x6e, 0x61,
+0x69, 0x6c, 0xd83d, 0xdc8d, 0x3a, 0x72, 0x69, 0x6e, 0x67, 0x3a, 0x72, 0x69,
+0x6e, 0x67, 0xd83d, 0xdc84, 0x3a, 0x6c, 0x69, 0x70, 0x73, 0x74, 0x69, 0x63,
+0x6b, 0x3a, 0x6c, 0x69, 0x70, 0x73, 0x74, 0x69, 0x63, 0x6b, 0xd83d, 0xdc8b,
+0x3a, 0x6b, 0x69, 0x73, 0x73, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0xd83d, 0xdc44,
+0x3a, 0x6c, 0x69, 0x70, 0x73, 0x3a, 0x6c, 0x69, 0x70, 0x73, 0xd83d, 0xdc45,
+0x3a, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x3a, 0x74, 0x6f, 0x6e, 0x67,
+0x75, 0x65, 0xd83d, 0xdc42, 0x3a, 0x65, 0x61, 0x72, 0x3a, 0x65, 0x61, 0x72,
+0xd83d, 0xdc43, 0x3a, 0x6e, 0x6f, 0x73, 0x65, 0x3a, 0x6e, 0x6f, 0x73, 0x65,
+0xd83d, 0xdc63, 0x3a, 0x66, 0x6f, 0x6f, 0x74, 0x70, 0x72, 0x69, 0x6e, 0x74,
+0x73, 0x3a, 0x66, 0x6f, 0x6f, 0x74, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x73,
+0xd83d, 0xdc41, 0x3a, 0x65, 0x79, 0x65, 0x3a, 0x65, 0x79, 0x65, 0xd83d, 0xdc40,
+0x3a, 0x65, 0x79, 0x65, 0x73, 0x3a, 0x65, 0x79, 0x65, 0x73, 0xd83d, 0xdde3,
+0x3a, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x65,
+0x61, 0x64, 0x5f, 0x69, 0x6e, 0x5f, 0x73, 0x69, 0x6c, 0x68, 0x6f, 0x75,
+0x65, 0x74, 0x74, 0x65, 0x3a, 0x68, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x73,
+0x69, 0x6c, 0x68, 0x6f, 0x75, 0x65, 0x74, 0x74, 0x65, 0x73, 0x70, 0x65,
+0x61, 0x6b, 0x69, 0x6e, 0x67, 0xd83d, 0xdde3, 0x3a, 0x73, 0x70, 0x65, 0x61,
+0x6b, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x3a, 0x68, 0x65,
+0x61, 0x64, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0xd83d, 0xdc64,
+0x3a, 0x62, 0x75, 0x73, 0x74, 0x5f, 0x69, 0x6e, 0x5f, 0x73, 0x69, 0x6c,
+0x68, 0x6f, 0x75, 0x65, 0x74, 0x74, 0x65, 0x3a, 0x62, 0x75, 0x73, 0x74,
+0x69, 0x6e, 0x73, 0x69, 0x6c, 0x68, 0x6f, 0x75, 0x65, 0x74, 0x74, 0x65,
+0xd83d, 0xdc65, 0x3a, 0x62, 0x75, 0x73, 0x74, 0x73, 0x5f, 0x69, 0x6e, 0x5f,
+0x73, 0x69, 0x6c, 0x68, 0x6f, 0x75, 0x65, 0x74, 0x74, 0x65, 0x3a, 0x62,
+0x75, 0x73, 0x74, 0x73, 0x69, 0x6e, 0x73, 0x69, 0x6c, 0x68, 0x6f, 0x75,
+0x65, 0x74, 0x74, 0x65, 0xd83d, 0xdc76, 0x3a, 0x62, 0x61, 0x62, 0x79, 0x3a,
+0x62, 0x61, 0x62, 0x79, 0xd83d, 0xdc66, 0x3a, 0x62, 0x6f, 0x79, 0x3a, 0x62,
+0x6f, 0x79, 0xd83d, 0xdc67, 0x3a, 0x67, 0x69, 0x72, 0x6c, 0x3a, 0x67, 0x69,
+0x72, 0x6c, 0xd83d, 0xdc68, 0x3a, 0x6d, 0x61, 0x6e, 0x3a, 0x6d, 0x61, 0x6e,
+0xd83d, 0xdc69, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x3a, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0xd83d, 0xdc71, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x62, 0x6c, 0x6f, 0x6e,
+0x64, 0x2d, 0x68, 0x61, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0x3a, 0x62, 0x6c, 0x6f, 0x6e, 0x64, 0x68, 0x61, 0x69, 0x72,
+0x65, 0x64, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc71, 0x3a, 0x62, 0x6c,
+0x6f, 0x6e, 0x64, 0x2d, 0x68, 0x61, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x6d,
+0x61, 0x6e, 0x3a, 0x62, 0x6c, 0x6f, 0x6e, 0x64, 0x68, 0x61, 0x69, 0x72,
+0x65, 0x64, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc71, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x62, 0x6c, 0x6f, 0x6e,
+0x64, 0x5f, 0x68, 0x61, 0x69, 0x72, 0x3a, 0x62, 0x6c, 0x6f, 0x6e, 0x64,
+0x68, 0x61, 0x69, 0x72, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xdc71, 0x3a, 0x62, 0x6c, 0x6f, 0x6e, 0x64, 0x5f, 0x68,
+0x61, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x3a, 0x62, 0x6c, 0x6f, 0x6e, 0x64, 0x68, 0x61, 0x69, 0x72, 0x65, 0x64,
+0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d, 0xdc74, 0x3a, 0x6f, 0x6c, 0x64,
+0x65, 0x72, 0x5f, 0x6d, 0x61, 0x6e, 0x3a, 0x6d, 0x61, 0x6e, 0x6f, 0x6c,
+0x64, 0x65, 0x72, 0xd83d, 0xdc75, 0x3a, 0x67, 0x72, 0x61, 0x6e, 0x64, 0x6d,
+0x61, 0x3a, 0x67, 0x72, 0x61, 0x6e, 0x64, 0x6d, 0x61, 0xd83d, 0xdc75, 0x3a,
+0x6f, 0x6c, 0x64, 0x65, 0x72, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x3a,
+0x6f, 0x6c, 0x64, 0x65, 0x72, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc72,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x67, 0x75,
+0x61, 0x5f, 0x70, 0x69, 0x5f, 0x6d, 0x61, 0x6f, 0x3a, 0x67, 0x75, 0x61,
+0x6d, 0x61, 0x6e, 0x6d, 0x61, 0x6f, 0x70, 0x69, 0x77, 0x69, 0x74, 0x68,
+0xd83d, 0xdc72, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f,
+0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x65, 0x5f, 0x63, 0x61, 0x70, 0x3a,
+0x63, 0x61, 0x70, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x65, 0x6d, 0x61,
+0x6e, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdc73, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67,
+0x5f, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e, 0x3a, 0x74, 0x75, 0x72, 0x62,
+0x61, 0x6e, 0x77, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0xd83d, 0xdc73, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x65, 0x61,
+0x72, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e, 0x3a,
+0x6d, 0x61, 0x6e, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e, 0x77, 0x65, 0x61,
+0x72, 0x69, 0x6e, 0x67, 0xd83d, 0xdc73, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e, 0x3a, 0x6d,
+0x61, 0x6e, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e, 0x77, 0x69, 0x74, 0x68,
+0xd83d, 0xdc73, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x77, 0x65,
+0x61, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x75, 0x72, 0x62, 0x61, 0x6e,
+0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x74, 0x75, 0x72, 0x62, 0x61,
+0x6e, 0x77, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67, 0xd83d, 0xdc6e, 0x200d, 0x2640,
+0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x70, 0x6f, 0x6c, 0x69,
+0x63, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x3a, 0x6f,
+0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x65,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc6e, 0x3a, 0x6d, 0x61, 0x6e, 0x5f,
+0x70, 0x6f, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63,
+0x65, 0x72, 0x3a, 0x6d, 0x61, 0x6e, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65,
+0x72, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x65, 0xd83d, 0xdc6e, 0x3a, 0x63, 0x6f,
+0x70, 0x3a, 0x63, 0x6f, 0x70, 0xd83d, 0xdc6e, 0x3a, 0x70, 0x6f, 0x6c, 0x69,
+0x63, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x3a, 0x6f,
+0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x65,
+0xd83d, 0xdc77, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e,
+0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x63, 0x6f, 0x6e, 0x73,
+0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc77, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69,
+0x6f, 0x6e, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x63, 0x6f,
+0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x6d, 0x61,
+0x6e, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc77, 0x3a, 0x63, 0x6f,
+0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x77,
+0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
+0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72,
+0xd83d, 0xdc82, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x67, 0x75, 0x61, 0x72, 0x64, 0x3a, 0x67, 0x75, 0x61, 0x72, 0x64, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc82, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x67,
+0x75, 0x61, 0x72, 0x64, 0x3a, 0x67, 0x75, 0x61, 0x72, 0x64, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc82, 0x3a, 0x67, 0x75, 0x61, 0x72, 0x64, 0x73, 0x6d, 0x61,
+0x6e, 0x3a, 0x67, 0x75, 0x61, 0x72, 0x64, 0x73, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc82, 0x3a, 0x67, 0x75, 0x61, 0x72, 0x64, 0x3a, 0x67, 0x75, 0x61, 0x72,
+0x64, 0xd83d, 0xdd75, 0xfe0f, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x3a,
+0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0xd83d, 0xdd75, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x64, 0x65,
+0x74, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x3a, 0x64, 0x65, 0x74, 0x65,
+0x63, 0x74, 0x69, 0x76, 0x65, 0x6d, 0x61, 0x6e, 0xd83d, 0xdd75, 0xfe0f, 0x3a,
+0x73, 0x6c, 0x65, 0x75, 0x74, 0x68, 0x5f, 0x6f, 0x72, 0x5f, 0x73, 0x70,
+0x79, 0x3a, 0x6f, 0x72, 0x73, 0x6c, 0x65, 0x75, 0x74, 0x68, 0x73, 0x70,
+0x79, 0xd83d, 0xdd75, 0xfe0f, 0x3a, 0x73, 0x70, 0x79, 0x3a, 0x73, 0x70, 0x79,
+0xd83d, 0xdd75, 0xfe0f, 0x3a, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x76,
+0x65, 0x3a, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0xd83d,
+0xdc69, 0x200d, 0x2695, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x68,
+0x65, 0x61, 0x6c, 0x74, 0x68, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72,
+0x3a, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc68, 0x200d, 0x2695, 0xfe0f, 0x3a,
+0x6d, 0x61, 0x6e, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x5f, 0x77,
+0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68,
+0x6d, 0x61, 0x6e, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc69, 0x200d,
+0xd83c, 0xdf3e, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x61, 0x72,
+0x6d, 0x65, 0x72, 0x3a, 0x66, 0x61, 0x72, 0x6d, 0x65, 0x72, 0x77, 0x6f,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83c, 0xdf3e, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x66, 0x61, 0x72, 0x6d, 0x65, 0x72, 0x3a, 0x66, 0x61, 0x72, 0x6d,
+0x65, 0x72, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0xd83c, 0xdf73, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x63, 0x6f, 0x6f, 0x6b, 0x3a, 0x63, 0x6f,
+0x6f, 0x6b, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83c, 0xdf73,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x63, 0x6f, 0x6f, 0x6b, 0x3a, 0x63, 0x6f,
+0x6f, 0x6b, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0xd83c, 0xdf93, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x74, 0x75, 0x64, 0x65, 0x6e, 0x74,
+0x3a, 0x73, 0x74, 0x75, 0x64, 0x65, 0x6e, 0x74, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83c, 0xdf93, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x73,
+0x74, 0x75, 0x64, 0x65, 0x6e, 0x74, 0x3a, 0x6d, 0x61, 0x6e, 0x73, 0x74,
+0x75, 0x64, 0x65, 0x6e, 0x74, 0xd83d, 0xdc69, 0x200d, 0xd83c, 0xdfa4, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x3a,
+0x73, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc68, 0x200d, 0xd83c, 0xdfa4, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x69, 0x6e,
+0x67, 0x65, 0x72, 0x3a, 0x6d, 0x61, 0x6e, 0x73, 0x69, 0x6e, 0x67, 0x65,
+0x72, 0xd83d, 0xdc69, 0x200d, 0xd83c, 0xdfeb, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x74, 0x65, 0x61, 0x63, 0x68, 0x65, 0x72, 0x3a, 0x74, 0x65, 0x61,
+0x63, 0x68, 0x65, 0x72, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d,
+0xd83c, 0xdfeb, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x74, 0x65, 0x61, 0x63, 0x68,
+0x65, 0x72, 0x3a, 0x6d, 0x61, 0x6e, 0x74, 0x65, 0x61, 0x63, 0x68, 0x65,
+0x72, 0xd83d, 0xdc69, 0x200d, 0xd83c, 0xdfed, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x77, 0x6f, 0x72,
+0x6b, 0x65, 0x72, 0x3a, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc68,
+0x200d, 0xd83c, 0xdfed, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x61, 0x63, 0x74,
+0x6f, 0x72, 0x79, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x66,
+0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x6d, 0x61, 0x6e, 0x77, 0x6f, 0x72,
+0x6b, 0x65, 0x72, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdcbb, 0x3a, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0x5f, 0x74, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67,
+0x69, 0x73, 0x74, 0x3a, 0x74, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f,
+0x67, 0x69, 0x73, 0x74, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d,
+0xd83d, 0xdcbb, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x74, 0x65, 0x63, 0x68, 0x6e,
+0x6f, 0x6c, 0x6f, 0x67, 0x69, 0x73, 0x74, 0x3a, 0x6d, 0x61, 0x6e, 0x74,
+0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x69, 0x73, 0x74, 0xd83d,
+0xdc69, 0x200d, 0xd83d, 0xdcbc, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6f,
+0x66, 0x66, 0x69, 0x63, 0x65, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72,
+0x3a, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdcbc, 0x3a,
+0x6d, 0x61, 0x6e, 0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x5f, 0x77,
+0x6f, 0x72, 0x6b, 0x65, 0x72, 0x3a, 0x6d, 0x61, 0x6e, 0x6f, 0x66, 0x66,
+0x69, 0x63, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0xd83d, 0xdc69, 0x200d,
+0xd83d, 0xdd27, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6d, 0x65, 0x63,
+0x68, 0x61, 0x6e, 0x69, 0x63, 0x3a, 0x6d, 0x65, 0x63, 0x68, 0x61, 0x6e,
+0x69, 0x63, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdd27,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x6d, 0x65, 0x63, 0x68, 0x61, 0x6e, 0x69,
+0x63, 0x3a, 0x6d, 0x61, 0x6e, 0x6d, 0x65, 0x63, 0x68, 0x61, 0x6e, 0x69,
+0x63, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdd2c, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x73, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x69, 0x73, 0x74, 0x3a, 0x73,
+0x63, 0x69, 0x65, 0x6e, 0x74, 0x69, 0x73, 0x74, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdd2c, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x73,
+0x63, 0x69, 0x65, 0x6e, 0x74, 0x69, 0x73, 0x74, 0x3a, 0x6d, 0x61, 0x6e,
+0x73, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x69, 0x73, 0x74, 0xd83d, 0xdc69, 0x200d,
+0xd83c, 0xdfa8, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x61, 0x72, 0x74,
+0x69, 0x73, 0x74, 0x3a, 0x61, 0x72, 0x74, 0x69, 0x73, 0x74, 0x77, 0x6f,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83c, 0xdfa8, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x61, 0x72, 0x74, 0x69, 0x73, 0x74, 0x3a, 0x61, 0x72, 0x74, 0x69,
+0x73, 0x74, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xde92, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x69, 0x72, 0x65, 0x66, 0x69, 0x67,
+0x68, 0x74, 0x65, 0x72, 0x3a, 0x66, 0x69, 0x72, 0x65, 0x66, 0x69, 0x67,
+0x68, 0x74, 0x65, 0x72, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d,
+0xd83d, 0xde92, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x69, 0x72, 0x65, 0x66,
+0x69, 0x67, 0x68, 0x74, 0x65, 0x72, 0x3a, 0x66, 0x69, 0x72, 0x65, 0x66,
+0x69, 0x67, 0x68, 0x74, 0x65, 0x72, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d,
+0x2708, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x70, 0x69, 0x6c,
+0x6f, 0x74, 0x3a, 0x70, 0x69, 0x6c, 0x6f, 0x74, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0x2708, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x70,
+0x69, 0x6c, 0x6f, 0x74, 0x3a, 0x6d, 0x61, 0x6e, 0x70, 0x69, 0x6c, 0x6f,
+0x74, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xde80, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x61, 0x73, 0x74, 0x72, 0x6f, 0x6e, 0x61, 0x75, 0x74, 0x3a, 0x61,
+0x73, 0x74, 0x72, 0x6f, 0x6e, 0x61, 0x75, 0x74, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xde80, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x61,
+0x73, 0x74, 0x72, 0x6f, 0x6e, 0x61, 0x75, 0x74, 0x3a, 0x61, 0x73, 0x74,
+0x72, 0x6f, 0x6e, 0x61, 0x75, 0x74, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d,
+0x2696, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6a, 0x75, 0x64,
+0x67, 0x65, 0x3a, 0x6a, 0x75, 0x64, 0x67, 0x65, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0x2696, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x6a,
+0x75, 0x64, 0x67, 0x65, 0x3a, 0x6a, 0x75, 0x64, 0x67, 0x65, 0x6d, 0x61,
+0x6e, 0xd83e, 0xdd36, 0x3a, 0x6d, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x63,
+0x68, 0x72, 0x69, 0x73, 0x74, 0x6d, 0x61, 0x73, 0x3a, 0x63, 0x68, 0x72,
+0x69, 0x73, 0x74, 0x6d, 0x61, 0x73, 0x6d, 0x6f, 0x74, 0x68, 0x65, 0x72,
+0xd83e, 0xdd36, 0x3a, 0x6d, 0x72, 0x73, 0x5f, 0x63, 0x6c, 0x61, 0x75, 0x73,
+0x3a, 0x63, 0x6c, 0x61, 0x75, 0x73, 0x6d, 0x72, 0x73, 0xd83c, 0xdf85, 0x3a,
+0x73, 0x61, 0x6e, 0x74, 0x61, 0x3a, 0x73, 0x61, 0x6e, 0x74, 0x61, 0xd83d,
+0xdc78, 0x3a, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x65, 0x73, 0x73, 0x3a, 0x70,
+0x72, 0x69, 0x6e, 0x63, 0x65, 0x73, 0x73, 0xd83e, 0xdd34, 0x3a, 0x70, 0x72,
+0x69, 0x6e, 0x63, 0x65, 0x3a, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x65, 0xd83d,
+0xdc70, 0x3a, 0x62, 0x72, 0x69, 0x64, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68,
+0x5f, 0x76, 0x65, 0x69, 0x6c, 0x3a, 0x62, 0x72, 0x69, 0x64, 0x65, 0x76,
+0x65, 0x69, 0x6c, 0x77, 0x69, 0x74, 0x68, 0xd83e, 0xdd35, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x69, 0x6e, 0x5f, 0x74, 0x75, 0x78, 0x65, 0x64, 0x6f, 0x3a,
+0x69, 0x6e, 0x6d, 0x61, 0x6e, 0x74, 0x75, 0x78, 0x65, 0x64, 0x6f, 0xd83d,
+0xdc7c, 0x3a, 0x61, 0x6e, 0x67, 0x65, 0x6c, 0x3a, 0x61, 0x6e, 0x67, 0x65,
+0x6c, 0xd83e, 0xdd30, 0x3a, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x69, 0x6e,
+0x67, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x3a, 0x65, 0x78, 0x70, 0x65,
+0x63, 0x74, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd30,
+0x3a, 0x70, 0x72, 0x65, 0x67, 0x6e, 0x61, 0x6e, 0x74, 0x5f, 0x77, 0x6f,
+0x6d, 0x61, 0x6e, 0x3a, 0x70, 0x72, 0x65, 0x67, 0x6e, 0x61, 0x6e, 0x74,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xde47, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x3a,
+0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d,
+0xde47, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67,
+0x3a, 0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0xd83d, 0xde47,
+0x3a, 0x62, 0x6f, 0x77, 0x3a, 0x62, 0x6f, 0x77, 0xd83d, 0xde47, 0x3a, 0x70,
+0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67,
+0x3a, 0x62, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73, 0x6f,
+0x6e, 0xd83d, 0xdc81, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x74, 0x69,
+0x70, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a, 0x68,
+0x61, 0x6e, 0x64, 0x74, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x77, 0x6f,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdc81, 0x3a, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
+0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x65, 0x73, 0x6b, 0x5f, 0x70,
+0x65, 0x72, 0x73, 0x6f, 0x6e, 0x3a, 0x64, 0x65, 0x73, 0x6b, 0x69, 0x6e,
+0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x70, 0x65, 0x72,
+0x73, 0x6f, 0x6e, 0xd83d, 0xdc81, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x5f, 0x74, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x74, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67, 0xd83d, 0xdc81, 0x200d, 0x2642, 0xfe0f,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x74, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67,
+0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x6d, 0x61,
+0x6e, 0x74, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67, 0xd83d, 0xde45, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69,
+0x6e, 0x67, 0x5f, 0x6e, 0x6f, 0x3a, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72,
+0x69, 0x6e, 0x67, 0x6e, 0x6f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xde45,
+0x3a, 0x6e, 0x6f, 0x5f, 0x67, 0x6f, 0x6f, 0x64, 0x3a, 0x67, 0x6f, 0x6f,
+0x64, 0x6e, 0x6f, 0xd83d, 0xde45, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x6e,
+0x6f, 0x3a, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x6e,
+0x6f, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d, 0xde45, 0x200d, 0x2642, 0xfe0f,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69,
+0x6e, 0x67, 0x5f, 0x6e, 0x6f, 0x3a, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72,
+0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0x6e, 0x6f, 0xd83d, 0xde46, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69,
+0x6e, 0x67, 0x5f, 0x6f, 0x6b, 0x3a, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72,
+0x69, 0x6e, 0x67, 0x6f, 0x6b, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xde46,
+0x3a, 0x6f, 0x6b, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x3a, 0x6f, 0x6b,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xde46, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 0x6e, 0x67,
+0x5f, 0x6f, 0x6b, 0x3a, 0x67, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 0x6e,
+0x67, 0x6f, 0x6b, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d, 0xde46, 0x200d,
+0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x73, 0x74, 0x75,
+0x72, 0x69, 0x6e, 0x67, 0x5f, 0x6f, 0x6b, 0x3a, 0x67, 0x65, 0x73, 0x74,
+0x75, 0x72, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0x6f, 0x6b, 0xd83d, 0xde4b,
+0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x73, 0x69,
+0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64,
+0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0xd83d, 0xde4b, 0x3a, 0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x68,
+0x61, 0x6e, 0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x72, 0x61, 0x69, 0x73,
+0x69, 0x6e, 0x67, 0xd83d, 0xde4b, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x5f, 0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67, 0xd83d, 0xde4b, 0x200d, 0x2642, 0xfe0f,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67,
+0x5f, 0x68, 0x61, 0x6e, 0x64, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x6d, 0x61,
+0x6e, 0x72, 0x61, 0x69, 0x73, 0x69, 0x6e, 0x67, 0xd83e, 0xdd26, 0x200d, 0x2640,
+0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x61, 0x63, 0x65,
+0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0xd83e, 0xdd26, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x61,
+0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e,
+0xd83e, 0xdd26, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x70, 0x61,
+0x6c, 0x6d, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0xd83e,
+0xdd26, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x5f, 0x70, 0x61,
+0x6c, 0x6d, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0xd83e,
+0xdd26, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f,
+0x66, 0x61, 0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x3a,
+0x66, 0x61, 0x63, 0x65, 0x70, 0x61, 0x6c, 0x6d, 0x69, 0x6e, 0x67, 0x70,
+0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83e, 0xdd37, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x68, 0x72, 0x75, 0x67, 0x67, 0x69,
+0x6e, 0x67, 0x3a, 0x73, 0x68, 0x72, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd37, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x73,
+0x68, 0x72, 0x75, 0x67, 0x3a, 0x73, 0x68, 0x72, 0x75, 0x67, 0xd83e, 0xdd37,
+0x200d, 0x2640, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x73,
+0x68, 0x72, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x3a, 0x70, 0x65, 0x72,
+0x73, 0x6f, 0x6e, 0x73, 0x68, 0x72, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67,
+0xd83e, 0xdd37, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x68,
+0x72, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x3a, 0x6d, 0x61, 0x6e, 0x73,
+0x68, 0x72, 0x75, 0x67, 0x67, 0x69, 0x6e, 0x67, 0xd83d, 0xde4e, 0x3a, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67,
+0x3a, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xde4e, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x5f,
+0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x70, 0x65, 0x72,
+0x73, 0x6f, 0x6e, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xde4e, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f,
+0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0xd83d, 0xde4e, 0x200d,
+0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x70, 0x6f, 0x75, 0x74, 0x69,
+0x6e, 0x67, 0x3a, 0x6d, 0x61, 0x6e, 0x70, 0x6f, 0x75, 0x74, 0x69, 0x6e,
+0x67, 0xd83d, 0xde4d, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x66, 0x72,
+0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x66, 0x72, 0x6f, 0x77, 0x6e,
+0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xde4d, 0x3a, 0x70,
+0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69,
+0x6e, 0x67, 0x3a, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x70,
+0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d, 0xde4d, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d,
+0x61, 0x6e, 0x5f, 0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x3a,
+0x66, 0x72, 0x6f, 0x77, 0x6e, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc87, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x74, 0x74,
+0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x69, 0x72, 0x63, 0x75, 0x74, 0x3a,
+0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x68, 0x61, 0x69, 0x72, 0x63,
+0x75, 0x74, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc87, 0x3a, 0x68, 0x61,
+0x69, 0x72, 0x63, 0x75, 0x74, 0x3a, 0x68, 0x61, 0x69, 0x72, 0x63, 0x75,
+0x74, 0xd83d, 0xdc87, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x67,
+0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x69, 0x72, 0x63,
+0x75, 0x74, 0x3a, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x68, 0x61,
+0x69, 0x72, 0x63, 0x75, 0x74, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d,
+0xdc87, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x65, 0x74,
+0x74, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x69, 0x72, 0x63, 0x75, 0x74,
+0x3a, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x68, 0x61, 0x69, 0x72,
+0x63, 0x75, 0x74, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc86, 0x3a, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0x5f, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x66,
+0x61, 0x63, 0x65, 0x5f, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a,
+0x66, 0x61, 0x63, 0x65, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x6d,
+0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc86, 0x3a, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x6d, 0x61,
+0x73, 0x73, 0x61, 0x67, 0x65, 0xd83d, 0xdc86, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x5f, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x6d,
+0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x67, 0x65, 0x74, 0x74, 0x69,
+0x6e, 0x67, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x70, 0x65, 0x72,
+0x73, 0x6f, 0x6e, 0xd83d, 0xdc86, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x5f, 0x6d, 0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e,
+0x6d, 0x61, 0x73, 0x73, 0x61, 0x67, 0x65, 0xd83d, 0xdd74, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x69, 0x6e, 0x5f, 0x62, 0x75, 0x73, 0x69, 0x6e, 0x65, 0x73,
+0x73, 0x5f, 0x73, 0x75, 0x69, 0x74, 0x5f, 0x6c, 0x65, 0x76, 0x69, 0x74,
+0x61, 0x74, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x75, 0x73, 0x69, 0x6e, 0x65,
+0x73, 0x73, 0x69, 0x6e, 0x6c, 0x65, 0x76, 0x69, 0x74, 0x61, 0x74, 0x69,
+0x6e, 0x67, 0x6d, 0x61, 0x6e, 0x73, 0x75, 0x69, 0x74, 0xd83d, 0xdc83, 0x3a,
+0x64, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x3a, 0x64, 0x61, 0x6e, 0x63, 0x65,
+0x72, 0xd83d, 0xdd7a, 0x3a, 0x6d, 0x61, 0x6c, 0x65, 0x5f, 0x64, 0x61, 0x6e,
+0x63, 0x65, 0x72, 0x3a, 0x64, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x6d, 0x61,
+0x6c, 0x65, 0xd83d, 0xdd7a, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x64, 0x61, 0x6e,
+0x63, 0x69, 0x6e, 0x67, 0x3a, 0x64, 0x61, 0x6e, 0x63, 0x69, 0x6e, 0x67,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdc6f, 0x3a, 0x77, 0x6f, 0x6d, 0x65, 0x6e, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x62, 0x75, 0x6e, 0x6e, 0x79, 0x5f, 0x65,
+0x61, 0x72, 0x73, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x79, 0x69, 0x6e, 0x67,
+0x3a, 0x62, 0x75, 0x6e, 0x6e, 0x79, 0x65, 0x61, 0x72, 0x73, 0x70, 0x61,
+0x72, 0x74, 0x79, 0x69, 0x6e, 0x67, 0x77, 0x69, 0x74, 0x68, 0x77, 0x6f,
+0x6d, 0x65, 0x6e, 0xd83d, 0xdc6f, 0x3a, 0x64, 0x61, 0x6e, 0x63, 0x65, 0x72,
+0x73, 0x3a, 0x64, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x73, 0xd83d, 0xdc6f, 0x3a,
+0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f,
+0x62, 0x75, 0x6e, 0x6e, 0x79, 0x5f, 0x65, 0x61, 0x72, 0x73, 0x5f, 0x70,
+0x61, 0x72, 0x74, 0x79, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x75, 0x6e, 0x6e,
+0x79, 0x65, 0x61, 0x72, 0x73, 0x70, 0x61, 0x72, 0x74, 0x79, 0x69, 0x6e,
+0x67, 0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83d,
+0xdc6f, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x65, 0x6e, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x62, 0x75, 0x6e, 0x6e, 0x79, 0x5f, 0x65, 0x61, 0x72, 0x73,
+0x5f, 0x70, 0x61, 0x72, 0x74, 0x79, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x75,
+0x6e, 0x6e, 0x79, 0x65, 0x61, 0x72, 0x73, 0x6d, 0x65, 0x6e, 0x70, 0x61,
+0x72, 0x74, 0x79, 0x69, 0x6e, 0x67, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdeb6,
+0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x61,
+0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
+0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdeb6, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x6d, 0x61, 0x6e,
+0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0xd83d, 0xdeb6, 0x3a, 0x77, 0x61,
+0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
+0x67, 0xd83d, 0xdeb6, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x77,
+0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f,
+0x6e, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0xd83c, 0xdfc3, 0x200d, 0x2640,
+0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x72, 0x75, 0x6e, 0x6e,
+0x69, 0x6e, 0x67, 0x3a, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0xd83c, 0xdfc3, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x72,
+0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x6d, 0x61, 0x6e, 0x72, 0x75,
+0x6e, 0x6e, 0x69, 0x6e, 0x67, 0xd83c, 0xdfc3, 0x3a, 0x72, 0x75, 0x6e, 0x6e,
+0x65, 0x72, 0x3a, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0xd83c, 0xdfc3, 0x3a,
+0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x72, 0x75, 0x6e, 0x6e, 0x69,
+0x6e, 0x67, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x72, 0x75, 0x6e,
+0x6e, 0x69, 0x6e, 0x67, 0xd83d, 0xdc6b, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c,
+0x65, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0xd83d, 0xdc6d, 0x3a, 0x74,
+0x77, 0x6f, 0x5f, 0x77, 0x6f, 0x6d, 0x65, 0x6e, 0x5f, 0x68, 0x6f, 0x6c,
+0x64, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x3a, 0x68,
+0x61, 0x6e, 0x64, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x74,
+0x77, 0x6f, 0x77, 0x6f, 0x6d, 0x65, 0x6e, 0xd83d, 0xdc6c, 0x3a, 0x74, 0x77,
+0x6f, 0x5f, 0x6d, 0x65, 0x6e, 0x5f, 0x68, 0x6f, 0x6c, 0x64, 0x69, 0x6e,
+0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x3a, 0x68, 0x61, 0x6e, 0x64,
+0x73, 0x68, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x6d, 0x65, 0x6e, 0x74,
+0x77, 0x6f, 0xd83d, 0xdc91, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x3a, 0x63,
+0x6f, 0x75, 0x70, 0x6c, 0x65, 0x68, 0x65, 0x61, 0x72, 0x74, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xdc91, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6d, 0x61, 0x6e, 0x3a, 0x63, 0x6f, 0x75,
+0x70, 0x6c, 0x65, 0x68, 0x65, 0x61, 0x72, 0x74, 0x6d, 0x61, 0x6e, 0x77,
+0x69, 0x74, 0x68, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0x2764,
+0xfe0f, 0x200d, 0xd83d, 0xdc69, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x77,
+0x77, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x68, 0x65, 0x61, 0x72,
+0x74, 0x77, 0x69, 0x74, 0x68, 0x77, 0x77, 0xd83d, 0xdc69, 0x200d, 0x2764, 0xfe0f,
+0x200d, 0xd83d, 0xdc69, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x5f, 0x77,
+0x77, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x77, 0x77, 0xd83d, 0xdc68,
+0x200d, 0x2764, 0xfe0f, 0x200d, 0xd83d, 0xdc68, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c,
+0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74,
+0x5f, 0x6d, 0x6d, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x68, 0x65,
+0x61, 0x72, 0x74, 0x6d, 0x6d, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdc68, 0x200d,
+0x2764, 0xfe0f, 0x200d, 0xd83d, 0xdc68, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65,
+0x5f, 0x6d, 0x6d, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x6d, 0x6d,
+0xd83d, 0xdc8f, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x6b, 0x69, 0x73,
+0x73, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x6b, 0x69, 0x73, 0x73,
+0xd83d, 0xdc8f, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x5f, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x5f, 0x6d, 0x61, 0x6e, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x6d, 0x61,
+0x6e, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0x2764, 0xfe0f, 0x200d,
+0xd83d, 0xdc8b, 0x200d, 0xd83d, 0xdc69, 0x3a, 0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65,
+0x6b, 0x69, 0x73, 0x73, 0x5f, 0x77, 0x77, 0x3a, 0x63, 0x6f, 0x75, 0x70,
+0x6c, 0x65, 0x6b, 0x69, 0x73, 0x73, 0x77, 0x77, 0xd83d, 0xdc69, 0x200d, 0x2764,
+0xfe0f, 0x200d, 0xd83d, 0xdc8b, 0x200d, 0xd83d, 0xdc69, 0x3a, 0x6b, 0x69, 0x73, 0x73,
+0x5f, 0x77, 0x77, 0x3a, 0x6b, 0x69, 0x73, 0x73, 0x77, 0x77, 0xd83d, 0xdc68,
+0x200d, 0x2764, 0xfe0f, 0x200d, 0xd83d, 0xdc8b, 0x200d, 0xd83d, 0xdc68, 0x3a, 0x63, 0x6f,
+0x75, 0x70, 0x6c, 0x65, 0x6b, 0x69, 0x73, 0x73, 0x5f, 0x6d, 0x6d, 0x3a,
+0x63, 0x6f, 0x75, 0x70, 0x6c, 0x65, 0x6b, 0x69, 0x73, 0x73, 0x6d, 0x6d,
+0xd83d, 0xdc68, 0x200d, 0x2764, 0xfe0f, 0x200d, 0xd83d, 0xdc8b, 0x200d, 0xd83d, 0xdc68, 0x3a,
+0x6b, 0x69, 0x73, 0x73, 0x5f, 0x6d, 0x6d, 0x3a, 0x6b, 0x69, 0x73, 0x73,
+0x6d, 0x6d, 0xd83d, 0xdc6a, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0xd83d, 0xdc6a, 0x3a, 0x66, 0x61, 0x6d,
+0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x61, 0x6e, 0x5f, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f, 0x79, 0x66, 0x61, 0x6d,
+0x69, 0x6c, 0x79, 0x6d, 0x61, 0x6e, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc68, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x5f, 0x6d, 0x77, 0x67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x6d, 0x77, 0x67, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67,
+0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d,
+0x77, 0x67, 0x62, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x77,
+0x67, 0x62, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc66, 0x200d, 0xd83d,
+0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x77, 0x62,
+0x62, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x77, 0x62, 0x62,
+0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc67, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x77, 0x67, 0x67, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x77, 0x67, 0x67, 0xd83d, 0xdc69,
+0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x5f, 0x77, 0x77, 0x62, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79,
+0x77, 0x77, 0x62, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x77, 0x77, 0x67, 0x3a, 0x66,
+0x61, 0x6d, 0x69, 0x6c, 0x79, 0x77, 0x77, 0x67, 0xd83d, 0xdc69, 0x200d, 0xd83d,
+0xdc69, 0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x5f, 0x77, 0x77, 0x67, 0x62, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x77, 0x77, 0x67, 0x62, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc69, 0x200d,
+0xd83d, 0xdc66, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79,
+0x5f, 0x77, 0x77, 0x62, 0x62, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79,
+0x77, 0x77, 0x62, 0x62, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67,
+0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x77,
+0x77, 0x67, 0x67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x77, 0x77,
+0x67, 0x67, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66,
+0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x6d, 0x62, 0x3a, 0x66, 0x61,
+0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x6d, 0x62, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc68,
+0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d,
+0x6d, 0x67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x6d, 0x67,
+0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc66, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x6d, 0x67, 0x62, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x6d, 0x67, 0x62, 0xd83d, 0xdc68,
+0x200d, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc66, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61,
+0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x6d, 0x62, 0x62, 0x3a, 0x66, 0x61,
+0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x6d, 0x62, 0x62, 0xd83d, 0xdc68, 0x200d, 0xd83d,
+0xdc68, 0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x5f, 0x6d, 0x6d, 0x67, 0x67, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x6d, 0x6d, 0x67, 0x67, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc66, 0x3a,
+0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f, 0x79, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69, 0x200d, 0xd83d, 0xdc67,
+0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x5f, 0x67, 0x69, 0x72, 0x6c, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x67, 0x69, 0x72, 0x6c, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69,
+0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x69, 0x72, 0x6c,
+0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f, 0x79, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x67, 0x69, 0x72, 0x6c, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d,
+0xdc69, 0x200d, 0xd83d, 0xdc66, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x62, 0x6f, 0x79,
+0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f, 0x79, 0x62, 0x6f, 0x79, 0x66,
+0x61, 0x6d, 0x69, 0x6c, 0x79, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc69,
+0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x5f, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x69, 0x72, 0x6c,
+0x5f, 0x67, 0x69, 0x72, 0x6c, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79,
+0x67, 0x69, 0x72, 0x6c, 0x67, 0x69, 0x72, 0x6c, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x5f, 0x6d, 0x61, 0x6e, 0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f,
+0x79, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68,
+0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d,
+0x61, 0x6e, 0x5f, 0x67, 0x69, 0x72, 0x6c, 0x3a, 0x66, 0x61, 0x6d, 0x69,
+0x6c, 0x79, 0x67, 0x69, 0x72, 0x6c, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d,
+0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79,
+0x5f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x69, 0x72, 0x6c, 0x5f, 0x62, 0x6f,
+0x79, 0x3a, 0x62, 0x6f, 0x79, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x67,
+0x69, 0x72, 0x6c, 0x6d, 0x61, 0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc66, 0x200d,
+0xd83d, 0xdc66, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x61,
+0x6e, 0x5f, 0x62, 0x6f, 0x79, 0x5f, 0x62, 0x6f, 0x79, 0x3a, 0x62, 0x6f,
+0x79, 0x62, 0x6f, 0x79, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x6d, 0x61,
+0x6e, 0xd83d, 0xdc68, 0x200d, 0xd83d, 0xdc67, 0x200d, 0xd83d, 0xdc67, 0x3a, 0x66, 0x61,
+0x6d, 0x69, 0x6c, 0x79, 0x5f, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x69, 0x72,
+0x6c, 0x5f, 0x67, 0x69, 0x72, 0x6c, 0x3a, 0x66, 0x61, 0x6d, 0x69, 0x6c,
+0x79, 0x67, 0x69, 0x72, 0x6c, 0x67, 0x69, 0x72, 0x6c, 0x6d, 0x61, 0x6e,
+0xd83d, 0xdc5a, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x73, 0x5f, 0x63, 0x6c,
+0x6f, 0x74, 0x68, 0x65, 0x73, 0x3a, 0x63, 0x6c, 0x6f, 0x74, 0x68, 0x65,
+0x73, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x73, 0xd83d, 0xdc55, 0x3a, 0x73, 0x68,
+0x69, 0x72, 0x74, 0x3a, 0x73, 0x68, 0x69, 0x72, 0x74, 0xd83d, 0xdc56, 0x3a,
+0x6a, 0x65, 0x61, 0x6e, 0x73, 0x3a, 0x6a, 0x65, 0x61, 0x6e, 0x73, 0xd83d,
+0xdc54, 0x3a, 0x6e, 0x65, 0x63, 0x6b, 0x74, 0x69, 0x65, 0x3a, 0x6e, 0x65,
+0x63, 0x6b, 0x74, 0x69, 0x65, 0xd83d, 0xdc57, 0x3a, 0x64, 0x72, 0x65, 0x73,
+0x73, 0x3a, 0x64, 0x72, 0x65, 0x73, 0x73, 0xd83d, 0xdc59, 0x3a, 0x62, 0x69,
+0x6b, 0x69, 0x6e, 0x69, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x69, 0xd83d,
+0xdc58, 0x3a, 0x6b, 0x69, 0x6d, 0x6f, 0x6e, 0x6f, 0x3a, 0x6b, 0x69, 0x6d,
+0x6f, 0x6e, 0x6f, 0xd83d, 0xdc60, 0x3a, 0x68, 0x69, 0x67, 0x68, 0x5f, 0x68,
+0x65, 0x65, 0x6c, 0x3a, 0x68, 0x65, 0x65, 0x6c, 0x68, 0x69, 0x67, 0x68,
+0xd83d, 0xdc61, 0x3a, 0x73, 0x61, 0x6e, 0x64, 0x61, 0x6c, 0x3a, 0x73, 0x61,
+0x6e, 0x64, 0x61, 0x6c, 0xd83d, 0xdc62, 0x3a, 0x62, 0x6f, 0x6f, 0x74, 0x3a,
+0x62, 0x6f, 0x6f, 0x74, 0xd83d, 0xdc5e, 0x3a, 0x6d, 0x61, 0x6e, 0x73, 0x5f,
+0x73, 0x68, 0x6f, 0x65, 0x3a, 0x6d, 0x61, 0x6e, 0x73, 0x73, 0x68, 0x6f,
+0x65, 0xd83d, 0xdc5f, 0x3a, 0x61, 0x74, 0x68, 0x6c, 0x65, 0x74, 0x69, 0x63,
+0x5f, 0x73, 0x68, 0x6f, 0x65, 0x3a, 0x61, 0x74, 0x68, 0x6c, 0x65, 0x74,
+0x69, 0x63, 0x73, 0x68, 0x6f, 0x65, 0xd83d, 0xdc52, 0x3a, 0x77, 0x6f, 0x6d,
+0x61, 0x6e, 0x73, 0x5f, 0x68, 0x61, 0x74, 0x3a, 0x68, 0x61, 0x74, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0x73, 0xd83c, 0xdfa9, 0x3a, 0x74, 0x6f, 0x70, 0x68,
+0x61, 0x74, 0x3a, 0x74, 0x6f, 0x70, 0x68, 0x61, 0x74, 0xd83c, 0xdf93, 0x3a,
+0x6d, 0x6f, 0x72, 0x74, 0x61, 0x72, 0x5f, 0x62, 0x6f, 0x61, 0x72, 0x64,
+0x3a, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x6d, 0x6f, 0x72, 0x74, 0x61, 0x72,
+0xd83d, 0xdc51, 0x3a, 0x63, 0x72, 0x6f, 0x77, 0x6e, 0x3a, 0x63, 0x72, 0x6f,
+0x77, 0x6e, 0x26d1, 0x3a, 0x68, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x63, 0x72,
+0x6f, 0x73, 0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x68, 0x65, 0x6c,
+0x6d, 0x65, 0x74, 0x77, 0x68, 0x69, 0x74, 0x65, 0x77, 0x69, 0x74, 0x68,
+0x26d1, 0x3a, 0x68, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73,
+0x73, 0x68, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x77, 0x69, 0x74, 0x68, 0xd83c,
+0xdf92, 0x3a, 0x73, 0x63, 0x68, 0x6f, 0x6f, 0x6c, 0x5f, 0x73, 0x61, 0x74,
+0x63, 0x68, 0x65, 0x6c, 0x3a, 0x73, 0x61, 0x74, 0x63, 0x68, 0x65, 0x6c,
+0x73, 0x63, 0x68, 0x6f, 0x6f, 0x6c, 0xd83d, 0xdc5d, 0x3a, 0x70, 0x6f, 0x75,
+0x63, 0x68, 0x3a, 0x70, 0x6f, 0x75, 0x63, 0x68, 0xd83d, 0xdc5b, 0x3a, 0x70,
+0x75, 0x72, 0x73, 0x65, 0x3a, 0x70, 0x75, 0x72, 0x73, 0x65, 0xd83d, 0xdc5c,
+0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62, 0x61, 0x67, 0x3a, 0x68, 0x61, 0x6e,
+0x64, 0x62, 0x61, 0x67, 0xd83d, 0xdcbc, 0x3a, 0x62, 0x72, 0x69, 0x65, 0x66,
+0x63, 0x61, 0x73, 0x65, 0x3a, 0x62, 0x72, 0x69, 0x65, 0x66, 0x63, 0x61,
+0x73, 0x65, 0xd83d, 0xdc53, 0x3a, 0x65, 0x79, 0x65, 0x67, 0x6c, 0x61, 0x73,
+0x73, 0x65, 0x73, 0x3a, 0x65, 0x79, 0x65, 0x67, 0x6c, 0x61, 0x73, 0x73,
+0x65, 0x73, 0xd83d, 0xdd76, 0x3a, 0x64, 0x61, 0x72, 0x6b, 0x5f, 0x73, 0x75,
+0x6e, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x3a, 0x64, 0x61, 0x72,
+0x6b, 0x73, 0x75, 0x6e, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0xd83c,
+0xdf02, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x5f, 0x75, 0x6d, 0x62,
+0x72, 0x65, 0x6c, 0x6c, 0x61, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64,
+0x75, 0x6d, 0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0x2602, 0xfe0f, 0x3a, 0x75,
+0x6d, 0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0x32, 0x3a, 0x75, 0x6d, 0x62,
+0x72, 0x65, 0x6c, 0x6c, 0x61, 0x32, 0xd83d, 0xdc36, 0x3a, 0x64, 0x6f, 0x67,
+0x3a, 0x64, 0x6f, 0x67, 0xd83d, 0xdc31, 0x3a, 0x63, 0x61, 0x74, 0x3a, 0x63,
+0x61, 0x74, 0xd83d, 0xdc2d, 0x3a, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x3a, 0x6d,
+0x6f, 0x75, 0x73, 0x65, 0xd83d, 0xdc39, 0x3a, 0x68, 0x61, 0x6d, 0x73, 0x74,
+0x65, 0x72, 0x3a, 0x68, 0x61, 0x6d, 0x73, 0x74, 0x65, 0x72, 0xd83d, 0xdc30,
+0x3a, 0x72, 0x61, 0x62, 0x62, 0x69, 0x74, 0x3a, 0x72, 0x61, 0x62, 0x62,
+0x69, 0x74, 0xd83e, 0xdd8a, 0x3a, 0x66, 0x6f, 0x78, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x66, 0x6f, 0x78, 0xd83e, 0xdd8a, 0x3a,
+0x66, 0x6f, 0x78, 0x3a, 0x66, 0x6f, 0x78, 0xd83d, 0xdc3b, 0x3a, 0x62, 0x65,
+0x61, 0x72, 0x3a, 0x62, 0x65, 0x61, 0x72, 0xd83d, 0xdc3c, 0x3a, 0x70, 0x61,
+0x6e, 0x64, 0x61, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63,
+0x65, 0x70, 0x61, 0x6e, 0x64, 0x61, 0xd83d, 0xdc28, 0x3a, 0x6b, 0x6f, 0x61,
+0x6c, 0x61, 0x3a, 0x6b, 0x6f, 0x61, 0x6c, 0x61, 0xd83d, 0xdc2f, 0x3a, 0x74,
+0x69, 0x67, 0x65, 0x72, 0x3a, 0x74, 0x69, 0x67, 0x65, 0x72, 0xd83e, 0xdd81,
+0x3a, 0x6c, 0x69, 0x6f, 0x6e, 0x3a, 0x6c, 0x69, 0x6f, 0x6e, 0xd83e, 0xdd81,
+0x3a, 0x6c, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66,
+0x61, 0x63, 0x65, 0x6c, 0x69, 0x6f, 0x6e, 0xd83d, 0xdc2e, 0x3a, 0x63, 0x6f,
+0x77, 0x3a, 0x63, 0x6f, 0x77, 0xd83d, 0xdc37, 0x3a, 0x70, 0x69, 0x67, 0x3a,
+0x70, 0x69, 0x67, 0xd83d, 0xdc3d, 0x3a, 0x70, 0x69, 0x67, 0x5f, 0x6e, 0x6f,
+0x73, 0x65, 0x3a, 0x6e, 0x6f, 0x73, 0x65, 0x70, 0x69, 0x67, 0xd83d, 0xdc38,
+0x3a, 0x66, 0x72, 0x6f, 0x67, 0x3a, 0x66, 0x72, 0x6f, 0x67, 0xd83d, 0xdc35,
+0x3a, 0x6d, 0x6f, 0x6e, 0x6b, 0x65, 0x79, 0x5f, 0x66, 0x61, 0x63, 0x65,
+0x3a, 0x66, 0x61, 0x63, 0x65, 0x6d, 0x6f, 0x6e, 0x6b, 0x65, 0x79, 0xd83d,
+0xde48, 0x3a, 0x73, 0x65, 0x65, 0x5f, 0x6e, 0x6f, 0x5f, 0x65, 0x76, 0x69,
+0x6c, 0x3a, 0x65, 0x76, 0x69, 0x6c, 0x6e, 0x6f, 0x73, 0x65, 0x65, 0xd83d,
+0xde49, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x5f, 0x6e, 0x6f, 0x5f, 0x65, 0x76,
+0x69, 0x6c, 0x3a, 0x65, 0x76, 0x69, 0x6c, 0x68, 0x65, 0x61, 0x72, 0x6e,
+0x6f, 0xd83d, 0xde4a, 0x3a, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x5f, 0x6e, 0x6f,
+0x5f, 0x65, 0x76, 0x69, 0x6c, 0x3a, 0x65, 0x76, 0x69, 0x6c, 0x6e, 0x6f,
+0x73, 0x70, 0x65, 0x61, 0x6b, 0xd83d, 0xdc12, 0x3a, 0x6d, 0x6f, 0x6e, 0x6b,
+0x65, 0x79, 0x3a, 0x6d, 0x6f, 0x6e, 0x6b, 0x65, 0x79, 0xd83d, 0xdc14, 0x3a,
+0x63, 0x68, 0x69, 0x63, 0x6b, 0x65, 0x6e, 0x3a, 0x63, 0x68, 0x69, 0x63,
+0x6b, 0x65, 0x6e, 0xd83d, 0xdc27, 0x3a, 0x70, 0x65, 0x6e, 0x67, 0x75, 0x69,
+0x6e, 0x3a, 0x70, 0x65, 0x6e, 0x67, 0x75, 0x69, 0x6e, 0xd83d, 0xdc26, 0x3a,
+0x62, 0x69, 0x72, 0x64, 0x3a, 0x62, 0x69, 0x72, 0x64, 0xd83d, 0xdc24, 0x3a,
+0x62, 0x61, 0x62, 0x79, 0x5f, 0x63, 0x68, 0x69, 0x63, 0x6b, 0x3a, 0x62,
+0x61, 0x62, 0x79, 0x63, 0x68, 0x69, 0x63, 0x6b, 0xd83d, 0xdc23, 0x3a, 0x68,
+0x61, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x68, 0x69, 0x63,
+0x6b, 0x3a, 0x63, 0x68, 0x69, 0x63, 0x6b, 0x68, 0x61, 0x74, 0x63, 0x68,
+0x69, 0x6e, 0x67, 0xd83d, 0xdc25, 0x3a, 0x68, 0x61, 0x74, 0x63, 0x68, 0x65,
+0x64, 0x5f, 0x63, 0x68, 0x69, 0x63, 0x6b, 0x3a, 0x63, 0x68, 0x69, 0x63,
+0x6b, 0x68, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0xd83e, 0xdd86, 0x3a, 0x64,
+0x75, 0x63, 0x6b, 0x3a, 0x64, 0x75, 0x63, 0x6b, 0xd83e, 0xdd85, 0x3a, 0x65,
+0x61, 0x67, 0x6c, 0x65, 0x3a, 0x65, 0x61, 0x67, 0x6c, 0x65, 0xd83e, 0xdd89,
+0x3a, 0x6f, 0x77, 0x6c, 0x3a, 0x6f, 0x77, 0x6c, 0xd83e, 0xdd87, 0x3a, 0x62,
+0x61, 0x74, 0x3a, 0x62, 0x61, 0x74, 0xd83d, 0xdc3a, 0x3a, 0x77, 0x6f, 0x6c,
+0x66, 0x3a, 0x77, 0x6f, 0x6c, 0x66, 0xd83d, 0xdc17, 0x3a, 0x62, 0x6f, 0x61,
+0x72, 0x3a, 0x62, 0x6f, 0x61, 0x72, 0xd83d, 0xdc34, 0x3a, 0x68, 0x6f, 0x72,
+0x73, 0x65, 0x3a, 0x68, 0x6f, 0x72, 0x73, 0x65, 0xd83e, 0xdd84, 0x3a, 0x75,
+0x6e, 0x69, 0x63, 0x6f, 0x72, 0x6e, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a,
+0x66, 0x61, 0x63, 0x65, 0x75, 0x6e, 0x69, 0x63, 0x6f, 0x72, 0x6e, 0xd83e,
+0xdd84, 0x3a, 0x75, 0x6e, 0x69, 0x63, 0x6f, 0x72, 0x6e, 0x3a, 0x75, 0x6e,
+0x69, 0x63, 0x6f, 0x72, 0x6e, 0xd83d, 0xdc1d, 0x3a, 0x62, 0x65, 0x65, 0x3a,
+0x62, 0x65, 0x65, 0xd83d, 0xdc1b, 0x3a, 0x62, 0x75, 0x67, 0x3a, 0x62, 0x75,
+0x67, 0xd83e, 0xdd8b, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x65, 0x72, 0x66, 0x6c,
+0x79, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x65, 0x72, 0x66, 0x6c, 0x79, 0xd83d,
+0xdc0c, 0x3a, 0x73, 0x6e, 0x61, 0x69, 0x6c, 0x3a, 0x73, 0x6e, 0x61, 0x69,
+0x6c, 0xd83d, 0xdc1a, 0x3a, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x3a, 0x73, 0x68,
+0x65, 0x6c, 0x6c, 0xd83d, 0xdc1e, 0x3a, 0x62, 0x65, 0x65, 0x74, 0x6c, 0x65,
+0x3a, 0x62, 0x65, 0x65, 0x74, 0x6c, 0x65, 0xd83d, 0xdc1c, 0x3a, 0x61, 0x6e,
+0x74, 0x3a, 0x61, 0x6e, 0x74, 0xd83d, 0xdd77, 0x3a, 0x73, 0x70, 0x69, 0x64,
+0x65, 0x72, 0x3a, 0x73, 0x70, 0x69, 0x64, 0x65, 0x72, 0xd83d, 0xdd78, 0x3a,
+0x73, 0x70, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x77, 0x65, 0x62, 0x3a, 0x73,
+0x70, 0x69, 0x64, 0x65, 0x72, 0x77, 0x65, 0x62, 0xd83d, 0xdc22, 0x3a, 0x74,
+0x75, 0x72, 0x74, 0x6c, 0x65, 0x3a, 0x74, 0x75, 0x72, 0x74, 0x6c, 0x65,
+0xd83d, 0xdc0d, 0x3a, 0x73, 0x6e, 0x61, 0x6b, 0x65, 0x3a, 0x73, 0x6e, 0x61,
+0x6b, 0x65, 0xd83e, 0xdd8e, 0x3a, 0x6c, 0x69, 0x7a, 0x61, 0x72, 0x64, 0x3a,
+0x6c, 0x69, 0x7a, 0x61, 0x72, 0x64, 0xd83e, 0xdd82, 0x3a, 0x73, 0x63, 0x6f,
+0x72, 0x70, 0x69, 0x6f, 0x6e, 0x3a, 0x73, 0x63, 0x6f, 0x72, 0x70, 0x69,
+0x6f, 0x6e, 0xd83e, 0xdd80, 0x3a, 0x63, 0x72, 0x61, 0x62, 0x3a, 0x63, 0x72,
+0x61, 0x62, 0xd83e, 0xdd91, 0x3a, 0x73, 0x71, 0x75, 0x69, 0x64, 0x3a, 0x73,
+0x71, 0x75, 0x69, 0x64, 0xd83d, 0xdc19, 0x3a, 0x6f, 0x63, 0x74, 0x6f, 0x70,
+0x75, 0x73, 0x3a, 0x6f, 0x63, 0x74, 0x6f, 0x70, 0x75, 0x73, 0xd83e, 0xdd90,
+0x3a, 0x73, 0x68, 0x72, 0x69, 0x6d, 0x70, 0x3a, 0x73, 0x68, 0x72, 0x69,
+0x6d, 0x70, 0xd83d, 0xdc20, 0x3a, 0x74, 0x72, 0x6f, 0x70, 0x69, 0x63, 0x61,
+0x6c, 0x5f, 0x66, 0x69, 0x73, 0x68, 0x3a, 0x66, 0x69, 0x73, 0x68, 0x74,
+0x72, 0x6f, 0x70, 0x69, 0x63, 0x61, 0x6c, 0xd83d, 0xdc1f, 0x3a, 0x66, 0x69,
+0x73, 0x68, 0x3a, 0x66, 0x69, 0x73, 0x68, 0xd83d, 0xdc21, 0x3a, 0x62, 0x6c,
+0x6f, 0x77, 0x66, 0x69, 0x73, 0x68, 0x3a, 0x62, 0x6c, 0x6f, 0x77, 0x66,
+0x69, 0x73, 0x68, 0xd83d, 0xdc2c, 0x3a, 0x64, 0x6f, 0x6c, 0x70, 0x68, 0x69,
+0x6e, 0x3a, 0x64, 0x6f, 0x6c, 0x70, 0x68, 0x69, 0x6e, 0xd83e, 0xdd88, 0x3a,
+0x73, 0x68, 0x61, 0x72, 0x6b, 0x3a, 0x73, 0x68, 0x61, 0x72, 0x6b, 0xd83d,
+0xdc33, 0x3a, 0x77, 0x68, 0x61, 0x6c, 0x65, 0x3a, 0x77, 0x68, 0x61, 0x6c,
+0x65, 0xd83d, 0xdc0b, 0x3a, 0x77, 0x68, 0x61, 0x6c, 0x65, 0x32, 0x3a, 0x77,
+0x68, 0x61, 0x6c, 0x65, 0x32, 0xd83d, 0xdc0a, 0x3a, 0x63, 0x72, 0x6f, 0x63,
+0x6f, 0x64, 0x69, 0x6c, 0x65, 0x3a, 0x63, 0x72, 0x6f, 0x63, 0x6f, 0x64,
+0x69, 0x6c, 0x65, 0xd83d, 0xdc06, 0x3a, 0x6c, 0x65, 0x6f, 0x70, 0x61, 0x72,
+0x64, 0x3a, 0x6c, 0x65, 0x6f, 0x70, 0x61, 0x72, 0x64, 0xd83d, 0xdc05, 0x3a,
+0x74, 0x69, 0x67, 0x65, 0x72, 0x32, 0x3a, 0x74, 0x69, 0x67, 0x65, 0x72,
+0x32, 0xd83d, 0xdc03, 0x3a, 0x77, 0x61, 0x74, 0x65, 0x72, 0x5f, 0x62, 0x75,
+0x66, 0x66, 0x61, 0x6c, 0x6f, 0x3a, 0x62, 0x75, 0x66, 0x66, 0x61, 0x6c,
+0x6f, 0x77, 0x61, 0x74, 0x65, 0x72, 0xd83d, 0xdc02, 0x3a, 0x6f, 0x78, 0x3a,
+0x6f, 0x78, 0xd83d, 0xdc04, 0x3a, 0x63, 0x6f, 0x77, 0x32, 0x3a, 0x63, 0x6f,
+0x77, 0x32, 0xd83e, 0xdd8c, 0x3a, 0x64, 0x65, 0x65, 0x72, 0x3a, 0x64, 0x65,
+0x65, 0x72, 0xd83d, 0xdc2a, 0x3a, 0x64, 0x72, 0x6f, 0x6d, 0x65, 0x64, 0x61,
+0x72, 0x79, 0x5f, 0x63, 0x61, 0x6d, 0x65, 0x6c, 0x3a, 0x63, 0x61, 0x6d,
+0x65, 0x6c, 0x64, 0x72, 0x6f, 0x6d, 0x65, 0x64, 0x61, 0x72, 0x79, 0xd83d,
+0xdc2b, 0x3a, 0x63, 0x61, 0x6d, 0x65, 0x6c, 0x3a, 0x63, 0x61, 0x6d, 0x65,
+0x6c, 0xd83d, 0xdc18, 0x3a, 0x65, 0x6c, 0x65, 0x70, 0x68, 0x61, 0x6e, 0x74,
+0x3a, 0x65, 0x6c, 0x65, 0x70, 0x68, 0x61, 0x6e, 0x74, 0xd83e, 0xdd8f, 0x3a,
+0x72, 0x68, 0x69, 0x6e, 0x6f, 0x63, 0x65, 0x72, 0x6f, 0x73, 0x3a, 0x72,
+0x68, 0x69, 0x6e, 0x6f, 0x63, 0x65, 0x72, 0x6f, 0x73, 0xd83e, 0xdd8f, 0x3a,
+0x72, 0x68, 0x69, 0x6e, 0x6f, 0x3a, 0x72, 0x68, 0x69, 0x6e, 0x6f, 0xd83e,
+0xdd8d, 0x3a, 0x67, 0x6f, 0x72, 0x69, 0x6c, 0x6c, 0x61, 0x3a, 0x67, 0x6f,
+0x72, 0x69, 0x6c, 0x6c, 0x61, 0xd83d, 0xdc0e, 0x3a, 0x72, 0x61, 0x63, 0x65,
+0x68, 0x6f, 0x72, 0x73, 0x65, 0x3a, 0x72, 0x61, 0x63, 0x65, 0x68, 0x6f,
+0x72, 0x73, 0x65, 0xd83d, 0xdc16, 0x3a, 0x70, 0x69, 0x67, 0x32, 0x3a, 0x70,
+0x69, 0x67, 0x32, 0xd83d, 0xdc10, 0x3a, 0x67, 0x6f, 0x61, 0x74, 0x3a, 0x67,
+0x6f, 0x61, 0x74, 0xd83d, 0xdc0f, 0x3a, 0x72, 0x61, 0x6d, 0x3a, 0x72, 0x61,
+0x6d, 0xd83d, 0xdc11, 0x3a, 0x73, 0x68, 0x65, 0x65, 0x70, 0x3a, 0x73, 0x68,
+0x65, 0x65, 0x70, 0xd83d, 0xdc15, 0x3a, 0x64, 0x6f, 0x67, 0x32, 0x3a, 0x64,
+0x6f, 0x67, 0x32, 0xd83d, 0xdc29, 0x3a, 0x70, 0x6f, 0x6f, 0x64, 0x6c, 0x65,
+0x3a, 0x70, 0x6f, 0x6f, 0x64, 0x6c, 0x65, 0xd83d, 0xdc08, 0x3a, 0x63, 0x61,
+0x74, 0x32, 0x3a, 0x63, 0x61, 0x74, 0x32, 0xd83d, 0xdc13, 0x3a, 0x72, 0x6f,
+0x6f, 0x73, 0x74, 0x65, 0x72, 0x3a, 0x72, 0x6f, 0x6f, 0x73, 0x74, 0x65,
+0x72, 0xd83e, 0xdd83, 0x3a, 0x74, 0x75, 0x72, 0x6b, 0x65, 0x79, 0x3a, 0x74,
+0x75, 0x72, 0x6b, 0x65, 0x79, 0xd83d, 0xdd4a, 0x3a, 0x64, 0x6f, 0x76, 0x65,
+0x5f, 0x6f, 0x66, 0x5f, 0x70, 0x65, 0x61, 0x63, 0x65, 0x3a, 0x64, 0x6f,
+0x76, 0x65, 0x6f, 0x66, 0x70, 0x65, 0x61, 0x63, 0x65, 0xd83d, 0xdd4a, 0x3a,
+0x64, 0x6f, 0x76, 0x65, 0x3a, 0x64, 0x6f, 0x76, 0x65, 0xd83d, 0xdc07, 0x3a,
+0x72, 0x61, 0x62, 0x62, 0x69, 0x74, 0x32, 0x3a, 0x72, 0x61, 0x62, 0x62,
+0x69, 0x74, 0x32, 0xd83d, 0xdc01, 0x3a, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x32,
+0x3a, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x32, 0xd83d, 0xdc00, 0x3a, 0x72, 0x61,
+0x74, 0x3a, 0x72, 0x61, 0x74, 0xd83d, 0xdc3f, 0x3a, 0x63, 0x68, 0x69, 0x70,
+0x6d, 0x75, 0x6e, 0x6b, 0x3a, 0x63, 0x68, 0x69, 0x70, 0x6d, 0x75, 0x6e,
+0x6b, 0xd83d, 0xdc3e, 0x3a, 0x70, 0x61, 0x77, 0x5f, 0x70, 0x72, 0x69, 0x6e,
+0x74, 0x73, 0x3a, 0x70, 0x61, 0x77, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x73,
+0xd83d, 0xdc3e, 0x3a, 0x66, 0x65, 0x65, 0x74, 0x3a, 0x66, 0x65, 0x65, 0x74,
+0xd83d, 0xdc09, 0x3a, 0x64, 0x72, 0x61, 0x67, 0x6f, 0x6e, 0x3a, 0x64, 0x72,
+0x61, 0x67, 0x6f, 0x6e, 0xd83d, 0xdc32, 0x3a, 0x64, 0x72, 0x61, 0x67, 0x6f,
+0x6e, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x64, 0x72, 0x61, 0x67, 0x6f,
+0x6e, 0x66, 0x61, 0x63, 0x65, 0xd83c, 0xdf35, 0x3a, 0x63, 0x61, 0x63, 0x74,
+0x75, 0x73, 0x3a, 0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0xd83c, 0xdf84, 0x3a,
+0x63, 0x68, 0x72, 0x69, 0x73, 0x74, 0x6d, 0x61, 0x73, 0x5f, 0x74, 0x72,
+0x65, 0x65, 0x3a, 0x63, 0x68, 0x72, 0x69, 0x73, 0x74, 0x6d, 0x61, 0x73,
+0x74, 0x72, 0x65, 0x65, 0xd83c, 0xdf32, 0x3a, 0x65, 0x76, 0x65, 0x72, 0x67,
+0x72, 0x65, 0x65, 0x6e, 0x5f, 0x74, 0x72, 0x65, 0x65, 0x3a, 0x65, 0x76,
+0x65, 0x72, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x74, 0x72, 0x65, 0x65, 0xd83c,
+0xdf33, 0x3a, 0x64, 0x65, 0x63, 0x69, 0x64, 0x75, 0x6f, 0x75, 0x73, 0x5f,
+0x74, 0x72, 0x65, 0x65, 0x3a, 0x64, 0x65, 0x63, 0x69, 0x64, 0x75, 0x6f,
+0x75, 0x73, 0x74, 0x72, 0x65, 0x65, 0xd83c, 0xdf34, 0x3a, 0x70, 0x61, 0x6c,
+0x6d, 0x5f, 0x74, 0x72, 0x65, 0x65, 0x3a, 0x70, 0x61, 0x6c, 0x6d, 0x74,
+0x72, 0x65, 0x65, 0xd83c, 0xdf31, 0x3a, 0x73, 0x65, 0x65, 0x64, 0x6c, 0x69,
+0x6e, 0x67, 0x3a, 0x73, 0x65, 0x65, 0x64, 0x6c, 0x69, 0x6e, 0x67, 0xd83c,
+0xdf3f, 0x3a, 0x68, 0x65, 0x72, 0x62, 0x3a, 0x68, 0x65, 0x72, 0x62, 0x2618,
+0xfe0f, 0x3a, 0x73, 0x68, 0x61, 0x6d, 0x72, 0x6f, 0x63, 0x6b, 0x3a, 0x73,
+0x68, 0x61, 0x6d, 0x72, 0x6f, 0x63, 0x6b, 0xd83c, 0xdf40, 0x3a, 0x66, 0x6f,
+0x75, 0x72, 0x5f, 0x6c, 0x65, 0x61, 0x66, 0x5f, 0x63, 0x6c, 0x6f, 0x76,
+0x65, 0x72, 0x3a, 0x63, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x66, 0x6f, 0x75,
+0x72, 0x6c, 0x65, 0x61, 0x66, 0xd83c, 0xdf8d, 0x3a, 0x62, 0x61, 0x6d, 0x62,
+0x6f, 0x6f, 0x3a, 0x62, 0x61, 0x6d, 0x62, 0x6f, 0x6f, 0xd83c, 0xdf8b, 0x3a,
+0x74, 0x61, 0x6e, 0x61, 0x62, 0x61, 0x74, 0x61, 0x5f, 0x74, 0x72, 0x65,
+0x65, 0x3a, 0x74, 0x61, 0x6e, 0x61, 0x62, 0x61, 0x74, 0x61, 0x74, 0x72,
+0x65, 0x65, 0xd83c, 0xdf43, 0x3a, 0x6c, 0x65, 0x61, 0x76, 0x65, 0x73, 0x3a,
+0x6c, 0x65, 0x61, 0x76, 0x65, 0x73, 0xd83c, 0xdf42, 0x3a, 0x66, 0x61, 0x6c,
+0x6c, 0x65, 0x6e, 0x5f, 0x6c, 0x65, 0x61, 0x66, 0x3a, 0x66, 0x61, 0x6c,
+0x6c, 0x65, 0x6e, 0x6c, 0x65, 0x61, 0x66, 0xd83c, 0xdf41, 0x3a, 0x6d, 0x61,
+0x70, 0x6c, 0x65, 0x5f, 0x6c, 0x65, 0x61, 0x66, 0x3a, 0x6c, 0x65, 0x61,
+0x66, 0x6d, 0x61, 0x70, 0x6c, 0x65, 0xd83c, 0xdf44, 0x3a, 0x6d, 0x75, 0x73,
+0x68, 0x72, 0x6f, 0x6f, 0x6d, 0x3a, 0x6d, 0x75, 0x73, 0x68, 0x72, 0x6f,
+0x6f, 0x6d, 0xd83c, 0xdf3e, 0x3a, 0x65, 0x61, 0x72, 0x5f, 0x6f, 0x66, 0x5f,
+0x72, 0x69, 0x63, 0x65, 0x3a, 0x65, 0x61, 0x72, 0x6f, 0x66, 0x72, 0x69,
+0x63, 0x65, 0xd83d, 0xdc90, 0x3a, 0x62, 0x6f, 0x75, 0x71, 0x75, 0x65, 0x74,
+0x3a, 0x62, 0x6f, 0x75, 0x71, 0x75, 0x65, 0x74, 0xd83c, 0xdf37, 0x3a, 0x74,
+0x75, 0x6c, 0x69, 0x70, 0x3a, 0x74, 0x75, 0x6c, 0x69, 0x70, 0xd83c, 0xdf39,
+0x3a, 0x72, 0x6f, 0x73, 0x65, 0x3a, 0x72, 0x6f, 0x73, 0x65, 0xd83e, 0xdd40,
+0x3a, 0x77, 0x69, 0x6c, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x6c, 0x6f, 0x77,
+0x65, 0x72, 0x3a, 0x66, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x77, 0x69, 0x6c,
+0x74, 0x65, 0x64, 0xd83e, 0xdd40, 0x3a, 0x77, 0x69, 0x6c, 0x74, 0x65, 0x64,
+0x5f, 0x72, 0x6f, 0x73, 0x65, 0x3a, 0x72, 0x6f, 0x73, 0x65, 0x77, 0x69,
+0x6c, 0x74, 0x65, 0x64, 0xd83c, 0xdf3b, 0x3a, 0x73, 0x75, 0x6e, 0x66, 0x6c,
+0x6f, 0x77, 0x65, 0x72, 0x3a, 0x73, 0x75, 0x6e, 0x66, 0x6c, 0x6f, 0x77,
+0x65, 0x72, 0xd83c, 0xdf3c, 0x3a, 0x62, 0x6c, 0x6f, 0x73, 0x73, 0x6f, 0x6d,
+0x3a, 0x62, 0x6c, 0x6f, 0x73, 0x73, 0x6f, 0x6d, 0xd83c, 0xdf38, 0x3a, 0x63,
+0x68, 0x65, 0x72, 0x72, 0x79, 0x5f, 0x62, 0x6c, 0x6f, 0x73, 0x73, 0x6f,
+0x6d, 0x3a, 0x62, 0x6c, 0x6f, 0x73, 0x73, 0x6f, 0x6d, 0x63, 0x68, 0x65,
+0x72, 0x72, 0x79, 0xd83c, 0xdf3a, 0x3a, 0x68, 0x69, 0x62, 0x69, 0x73, 0x63,
+0x75, 0x73, 0x3a, 0x68, 0x69, 0x62, 0x69, 0x73, 0x63, 0x75, 0x73, 0xd83c,
+0xdf0e, 0x3a, 0x65, 0x61, 0x72, 0x74, 0x68, 0x5f, 0x61, 0x6d, 0x65, 0x72,
+0x69, 0x63, 0x61, 0x73, 0x3a, 0x61, 0x6d, 0x65, 0x72, 0x69, 0x63, 0x61,
+0x73, 0x65, 0x61, 0x72, 0x74, 0x68, 0xd83c, 0xdf0d, 0x3a, 0x65, 0x61, 0x72,
+0x74, 0x68, 0x5f, 0x61, 0x66, 0x72, 0x69, 0x63, 0x61, 0x3a, 0x61, 0x66,
+0x72, 0x69, 0x63, 0x61, 0x65, 0x61, 0x72, 0x74, 0x68, 0xd83c, 0xdf0f, 0x3a,
+0x65, 0x61, 0x72, 0x74, 0x68, 0x5f, 0x61, 0x73, 0x69, 0x61, 0x3a, 0x61,
+0x73, 0x69, 0x61, 0x65, 0x61, 0x72, 0x74, 0x68, 0xd83c, 0xdf15, 0x3a, 0x66,
+0x75, 0x6c, 0x6c, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x3a, 0x66, 0x75, 0x6c,
+0x6c, 0x6d, 0x6f, 0x6f, 0x6e, 0xd83c, 0xdf16, 0x3a, 0x77, 0x61, 0x6e, 0x69,
+0x6e, 0x67, 0x5f, 0x67, 0x69, 0x62, 0x62, 0x6f, 0x75, 0x73, 0x5f, 0x6d,
+0x6f, 0x6f, 0x6e, 0x3a, 0x67, 0x69, 0x62, 0x62, 0x6f, 0x75, 0x73, 0x6d,
+0x6f, 0x6f, 0x6e, 0x77, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0xd83c, 0xdf17, 0x3a,
+0x6c, 0x61, 0x73, 0x74, 0x5f, 0x71, 0x75, 0x61, 0x72, 0x74, 0x65, 0x72,
+0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x3a, 0x6c, 0x61, 0x73, 0x74, 0x6d, 0x6f,
+0x6f, 0x6e, 0x71, 0x75, 0x61, 0x72, 0x74, 0x65, 0x72, 0xd83c, 0xdf18, 0x3a,
+0x77, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x72, 0x65, 0x73, 0x63,
+0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x3a, 0x63, 0x72, 0x65,
+0x73, 0x63, 0x65, 0x6e, 0x74, 0x6d, 0x6f, 0x6f, 0x6e, 0x77, 0x61, 0x6e,
+0x69, 0x6e, 0x67, 0xd83c, 0xdf11, 0x3a, 0x6e, 0x65, 0x77, 0x5f, 0x6d, 0x6f,
+0x6f, 0x6e, 0x3a, 0x6d, 0x6f, 0x6f, 0x6e, 0x6e, 0x65, 0x77, 0xd83c, 0xdf12,
+0x3a, 0x77, 0x61, 0x78, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x72, 0x65, 0x73,
+0x63, 0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x3a, 0x63, 0x72,
+0x65, 0x73, 0x63, 0x65, 0x6e, 0x74, 0x6d, 0x6f, 0x6f, 0x6e, 0x77, 0x61,
+0x78, 0x69, 0x6e, 0x67, 0xd83c, 0xdf13, 0x3a, 0x66, 0x69, 0x72, 0x73, 0x74,
+0x5f, 0x71, 0x75, 0x61, 0x72, 0x74, 0x65, 0x72, 0x5f, 0x6d, 0x6f, 0x6f,
+0x6e, 0x3a, 0x66, 0x69, 0x72, 0x73, 0x74, 0x6d, 0x6f, 0x6f, 0x6e, 0x71,
+0x75, 0x61, 0x72, 0x74, 0x65, 0x72, 0xd83c, 0xdf14, 0x3a, 0x77, 0x61, 0x78,
+0x69, 0x6e, 0x67, 0x5f, 0x67, 0x69, 0x62, 0x62, 0x6f, 0x75, 0x73, 0x5f,
+0x6d, 0x6f, 0x6f, 0x6e, 0x3a, 0x67, 0x69, 0x62, 0x62, 0x6f, 0x75, 0x73,
+0x6d, 0x6f, 0x6f, 0x6e, 0x77, 0x61, 0x78, 0x69, 0x6e, 0x67, 0xd83c, 0xdf1a,
+0x3a, 0x6e, 0x65, 0x77, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x5f, 0x77, 0x69,
+0x74, 0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65,
+0x6d, 0x6f, 0x6f, 0x6e, 0x6e, 0x65, 0x77, 0x77, 0x69, 0x74, 0x68, 0xd83c,
+0xdf1d, 0x3a, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61,
+0x63, 0x65, 0x66, 0x75, 0x6c, 0x6c, 0x6d, 0x6f, 0x6f, 0x6e, 0x77, 0x69,
+0x74, 0x68, 0xd83c, 0xdf1e, 0x3a, 0x73, 0x75, 0x6e, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x73,
+0x75, 0x6e, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf1b, 0x3a, 0x66, 0x69, 0x72,
+0x73, 0x74, 0x5f, 0x71, 0x75, 0x61, 0x72, 0x74, 0x65, 0x72, 0x5f, 0x6d,
+0x6f, 0x6f, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x3a, 0x66, 0x61, 0x63, 0x65, 0x66, 0x69, 0x72, 0x73, 0x74, 0x6d,
+0x6f, 0x6f, 0x6e, 0x71, 0x75, 0x61, 0x72, 0x74, 0x65, 0x72, 0x77, 0x69,
+0x74, 0x68, 0xd83c, 0xdf1c, 0x3a, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x71, 0x75,
+0x61, 0x72, 0x74, 0x65, 0x72, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x66, 0x61, 0x63,
+0x65, 0x6c, 0x61, 0x73, 0x74, 0x6d, 0x6f, 0x6f, 0x6e, 0x71, 0x75, 0x61,
+0x72, 0x74, 0x65, 0x72, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf19, 0x3a, 0x63,
+0x72, 0x65, 0x73, 0x63, 0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x6f, 0x6e,
+0x3a, 0x63, 0x72, 0x65, 0x73, 0x63, 0x65, 0x6e, 0x74, 0x6d, 0x6f, 0x6f,
+0x6e, 0xd83d, 0xdcab, 0x3a, 0x64, 0x69, 0x7a, 0x7a, 0x79, 0x3a, 0x64, 0x69,
+0x7a, 0x7a, 0x79, 0x2b50, 0xfe0f, 0x3a, 0x73, 0x74, 0x61, 0x72, 0x3a, 0x73,
+0x74, 0x61, 0x72, 0xd83c, 0xdf1f, 0x3a, 0x73, 0x74, 0x61, 0x72, 0x32, 0x3a,
+0x73, 0x74, 0x61, 0x72, 0x32, 0x2728, 0x3a, 0x73, 0x70, 0x61, 0x72, 0x6b,
+0x6c, 0x65, 0x73, 0x3a, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x6c, 0x65, 0x73,
+0x26a1, 0xfe0f, 0x3a, 0x7a, 0x61, 0x70, 0x3a, 0x7a, 0x61, 0x70, 0xd83d, 0xdd25,
+0x3a, 0x66, 0x6c, 0x61, 0x6d, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x6d, 0x65,
+0xd83d, 0xdd25, 0x3a, 0x66, 0x69, 0x72, 0x65, 0x3a, 0x66, 0x69, 0x72, 0x65,
+0xd83d, 0xdca5, 0x3a, 0x62, 0x6f, 0x6f, 0x6d, 0x3a, 0x62, 0x6f, 0x6f, 0x6d,
+0x2604, 0xfe0f, 0x3a, 0x63, 0x6f, 0x6d, 0x65, 0x74, 0x3a, 0x63, 0x6f, 0x6d,
+0x65, 0x74, 0x2600, 0xfe0f, 0x3a, 0x73, 0x75, 0x6e, 0x6e, 0x79, 0x3a, 0x73,
+0x75, 0x6e, 0x6e, 0x79, 0xd83c, 0xdf24, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65,
+0x5f, 0x73, 0x75, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x6d,
+0x61, 0x6c, 0x6c, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x73, 0x75, 0x6e, 0x77,
+0x68, 0x69, 0x74, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf24, 0x3a, 0x77,
+0x68, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x75, 0x6e, 0x5f, 0x73, 0x6d, 0x61,
+0x6c, 0x6c, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x3a, 0x63, 0x6c, 0x6f,
+0x75, 0x64, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x73, 0x75, 0x6e, 0x77, 0x68,
+0x69, 0x74, 0x65, 0x26c5, 0xfe0f, 0x3a, 0x70, 0x61, 0x72, 0x74, 0x6c, 0x79,
+0x5f, 0x73, 0x75, 0x6e, 0x6e, 0x79, 0x3a, 0x70, 0x61, 0x72, 0x74, 0x6c,
+0x79, 0x73, 0x75, 0x6e, 0x6e, 0x79, 0xd83c, 0xdf25, 0x3a, 0x77, 0x68, 0x69,
+0x74, 0x65, 0x5f, 0x73, 0x75, 0x6e, 0x5f, 0x62, 0x65, 0x68, 0x69, 0x6e,
+0x64, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x3a, 0x62, 0x65, 0x68, 0x69,
+0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x73, 0x75, 0x6e, 0x77, 0x68,
+0x69, 0x74, 0x65, 0xd83c, 0xdf25, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f,
+0x73, 0x75, 0x6e, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0x73, 0x75, 0x6e, 0x77, 0x68, 0x69, 0x74, 0x65, 0xd83c,
+0xdf26, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x75, 0x6e, 0x5f,
+0x62, 0x65, 0x68, 0x69, 0x6e, 0x64, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x72, 0x61, 0x69, 0x6e, 0x3a, 0x62,
+0x65, 0x68, 0x69, 0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x72, 0x61,
+0x69, 0x6e, 0x73, 0x75, 0x6e, 0x77, 0x68, 0x69, 0x74, 0x65, 0x77, 0x69,
+0x74, 0x68, 0xd83c, 0xdf26, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x73,
+0x75, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x63, 0x6c, 0x6f, 0x75,
+0x64, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x73,
+0x75, 0x6e, 0x77, 0x68, 0x69, 0x74, 0x65, 0xd83c, 0xdf08, 0x3a, 0x72, 0x61,
+0x69, 0x6e, 0x62, 0x6f, 0x77, 0x3a, 0x72, 0x61, 0x69, 0x6e, 0x62, 0x6f,
+0x77, 0x2601, 0xfe0f, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0xd83c, 0xdf27, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x72, 0x61, 0x69, 0x6e, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x77, 0x69, 0x74, 0x68, 0xd83c,
+0xdf27, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x5f, 0x72, 0x61, 0x69, 0x6e,
+0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x26c8, 0x3a,
+0x74, 0x68, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x5f, 0x63, 0x6c, 0x6f, 0x75,
+0x64, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x72, 0x61, 0x69, 0x6e, 0x3a, 0x61,
+0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x74,
+0x68, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x26c8, 0x3a, 0x74, 0x68, 0x75, 0x6e,
+0x64, 0x65, 0x72, 0x5f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x5f, 0x72, 0x61,
+0x69, 0x6e, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x72, 0x61, 0x69, 0x6e,
+0x74, 0x68, 0x75, 0x6e, 0x64, 0x65, 0x72, 0xd83c, 0xdf29, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6c, 0x69, 0x67,
+0x68, 0x74, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64,
+0x6c, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x69, 0x6e, 0x67, 0x77, 0x69, 0x74,
+0x68, 0xd83c, 0xdf29, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x5f, 0x6c, 0x69,
+0x67, 0x68, 0x74, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x63, 0x6c, 0x6f, 0x75,
+0x64, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x69, 0x6e, 0x67, 0xd83c, 0xdf28,
+0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f,
+0x73, 0x6e, 0x6f, 0x77, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x73, 0x6e,
+0x6f, 0x77, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf28, 0x3a, 0x63, 0x6c, 0x6f,
+0x75, 0x64, 0x5f, 0x73, 0x6e, 0x6f, 0x77, 0x3a, 0x63, 0x6c, 0x6f, 0x75,
+0x64, 0x73, 0x6e, 0x6f, 0x77, 0x2603, 0xfe0f, 0x3a, 0x73, 0x6e, 0x6f, 0x77,
+0x6d, 0x61, 0x6e, 0x32, 0x3a, 0x73, 0x6e, 0x6f, 0x77, 0x6d, 0x61, 0x6e,
+0x32, 0x26c4, 0xfe0f, 0x3a, 0x73, 0x6e, 0x6f, 0x77, 0x6d, 0x61, 0x6e, 0x3a,
+0x73, 0x6e, 0x6f, 0x77, 0x6d, 0x61, 0x6e, 0x2744, 0xfe0f, 0x3a, 0x73, 0x6e,
+0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x3a, 0x73, 0x6e, 0x6f, 0x77,
+0x66, 0x6c, 0x61, 0x6b, 0x65, 0xd83c, 0xdf2c, 0x3a, 0x77, 0x69, 0x6e, 0x64,
+0x5f, 0x62, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63,
+0x65, 0x3a, 0x62, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x66, 0x61, 0x63,
+0x65, 0x77, 0x69, 0x6e, 0x64, 0xd83d, 0xdca8, 0x3a, 0x64, 0x61, 0x73, 0x68,
+0x3a, 0x64, 0x61, 0x73, 0x68, 0xd83c, 0xdf2a, 0x3a, 0x63, 0x6c, 0x6f, 0x75,
+0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x72, 0x6e, 0x61,
+0x64, 0x6f, 0x3a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x74, 0x6f, 0x72, 0x6e,
+0x61, 0x64, 0x6f, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf2a, 0x3a, 0x63, 0x6c,
+0x6f, 0x75, 0x64, 0x5f, 0x74, 0x6f, 0x72, 0x6e, 0x61, 0x64, 0x6f, 0x3a,
+0x63, 0x6c, 0x6f, 0x75, 0x64, 0x74, 0x6f, 0x72, 0x6e, 0x61, 0x64, 0x6f,
+0xd83c, 0xdf2b, 0x3a, 0x66, 0x6f, 0x67, 0x3a, 0x66, 0x6f, 0x67, 0xd83c, 0xdf0a,
+0x3a, 0x6f, 0x63, 0x65, 0x61, 0x6e, 0x3a, 0x6f, 0x63, 0x65, 0x61, 0x6e,
+0xd83d, 0xdca7, 0x3a, 0x64, 0x72, 0x6f, 0x70, 0x6c, 0x65, 0x74, 0x3a, 0x64,
+0x72, 0x6f, 0x70, 0x6c, 0x65, 0x74, 0xd83d, 0xdca6, 0x3a, 0x73, 0x77, 0x65,
+0x61, 0x74, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x3a, 0x64, 0x72, 0x6f,
+0x70, 0x73, 0x73, 0x77, 0x65, 0x61, 0x74, 0x2614, 0xfe0f, 0x3a, 0x75, 0x6d,
+0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0x3a, 0x75, 0x6d, 0x62, 0x72, 0x65,
+0x6c, 0x6c, 0x61, 0xd83c, 0xdf4f, 0x3a, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x5f,
+0x61, 0x70, 0x70, 0x6c, 0x65, 0x3a, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x67,
+0x72, 0x65, 0x65, 0x6e, 0xd83c, 0xdf4e, 0x3a, 0x61, 0x70, 0x70, 0x6c, 0x65,
+0x3a, 0x61, 0x70, 0x70, 0x6c, 0x65, 0xd83c, 0xdf50, 0x3a, 0x70, 0x65, 0x61,
+0x72, 0x3a, 0x70, 0x65, 0x61, 0x72, 0xd83c, 0xdf4a, 0x3a, 0x74, 0x61, 0x6e,
+0x67, 0x65, 0x72, 0x69, 0x6e, 0x65, 0x3a, 0x74, 0x61, 0x6e, 0x67, 0x65,
+0x72, 0x69, 0x6e, 0x65, 0xd83c, 0xdf4b, 0x3a, 0x6c, 0x65, 0x6d, 0x6f, 0x6e,
+0x3a, 0x6c, 0x65, 0x6d, 0x6f, 0x6e, 0xd83c, 0xdf4c, 0x3a, 0x62, 0x61, 0x6e,
+0x61, 0x6e, 0x61, 0x3a, 0x62, 0x61, 0x6e, 0x61, 0x6e, 0x61, 0xd83c, 0xdf49,
+0x3a, 0x77, 0x61, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x6c, 0x6f, 0x6e, 0x3a,
+0x77, 0x61, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x6c, 0x6f, 0x6e, 0xd83c, 0xdf47,
+0x3a, 0x67, 0x72, 0x61, 0x70, 0x65, 0x73, 0x3a, 0x67, 0x72, 0x61, 0x70,
+0x65, 0x73, 0xd83c, 0xdf53, 0x3a, 0x73, 0x74, 0x72, 0x61, 0x77, 0x62, 0x65,
+0x72, 0x72, 0x79, 0x3a, 0x73, 0x74, 0x72, 0x61, 0x77, 0x62, 0x65, 0x72,
+0x72, 0x79, 0xd83c, 0xdf48, 0x3a, 0x6d, 0x65, 0x6c, 0x6f, 0x6e, 0x3a, 0x6d,
+0x65, 0x6c, 0x6f, 0x6e, 0xd83c, 0xdf52, 0x3a, 0x63, 0x68, 0x65, 0x72, 0x72,
+0x69, 0x65, 0x73, 0x3a, 0x63, 0x68, 0x65, 0x72, 0x72, 0x69, 0x65, 0x73,
+0xd83c, 0xdf51, 0x3a, 0x70, 0x65, 0x61, 0x63, 0x68, 0x3a, 0x70, 0x65, 0x61,
+0x63, 0x68, 0xd83c, 0xdf4d, 0x3a, 0x70, 0x69, 0x6e, 0x65, 0x61, 0x70, 0x70,
+0x6c, 0x65, 0x3a, 0x70, 0x69, 0x6e, 0x65, 0x61, 0x70, 0x70, 0x6c, 0x65,
+0xd83e, 0xdd5d, 0x3a, 0x6b, 0x69, 0x77, 0x69, 0x66, 0x72, 0x75, 0x69, 0x74,
+0x3a, 0x6b, 0x69, 0x77, 0x69, 0x66, 0x72, 0x75, 0x69, 0x74, 0xd83e, 0xdd5d,
+0x3a, 0x6b, 0x69, 0x77, 0x69, 0x3a, 0x6b, 0x69, 0x77, 0x69, 0xd83e, 0xdd51,
+0x3a, 0x61, 0x76, 0x6f, 0x63, 0x61, 0x64, 0x6f, 0x3a, 0x61, 0x76, 0x6f,
+0x63, 0x61, 0x64, 0x6f, 0xd83c, 0xdf45, 0x3a, 0x74, 0x6f, 0x6d, 0x61, 0x74,
+0x6f, 0x3a, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0xd83c, 0xdf46, 0x3a, 0x65,
+0x67, 0x67, 0x70, 0x6c, 0x61, 0x6e, 0x74, 0x3a, 0x65, 0x67, 0x67, 0x70,
+0x6c, 0x61, 0x6e, 0x74, 0xd83e, 0xdd52, 0x3a, 0x63, 0x75, 0x63, 0x75, 0x6d,
+0x62, 0x65, 0x72, 0x3a, 0x63, 0x75, 0x63, 0x75, 0x6d, 0x62, 0x65, 0x72,
+0xd83e, 0xdd55, 0x3a, 0x63, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x3a, 0x63, 0x61,
+0x72, 0x72, 0x6f, 0x74, 0xd83c, 0xdf3d, 0x3a, 0x63, 0x6f, 0x72, 0x6e, 0x3a,
+0x63, 0x6f, 0x72, 0x6e, 0xd83c, 0xdf36, 0x3a, 0x68, 0x6f, 0x74, 0x5f, 0x70,
+0x65, 0x70, 0x70, 0x65, 0x72, 0x3a, 0x68, 0x6f, 0x74, 0x70, 0x65, 0x70,
+0x70, 0x65, 0x72, 0xd83e, 0xdd54, 0x3a, 0x70, 0x6f, 0x74, 0x61, 0x74, 0x6f,
+0x3a, 0x70, 0x6f, 0x74, 0x61, 0x74, 0x6f, 0xd83c, 0xdf60, 0x3a, 0x73, 0x77,
+0x65, 0x65, 0x74, 0x5f, 0x70, 0x6f, 0x74, 0x61, 0x74, 0x6f, 0x3a, 0x70,
+0x6f, 0x74, 0x61, 0x74, 0x6f, 0x73, 0x77, 0x65, 0x65, 0x74, 0xd83c, 0xdf30,
+0x3a, 0x63, 0x68, 0x65, 0x73, 0x74, 0x6e, 0x75, 0x74, 0x3a, 0x63, 0x68,
+0x65, 0x73, 0x74, 0x6e, 0x75, 0x74, 0xd83e, 0xdd5c, 0x3a, 0x73, 0x68, 0x65,
+0x6c, 0x6c, 0x65, 0x64, 0x5f, 0x70, 0x65, 0x61, 0x6e, 0x75, 0x74, 0x3a,
+0x70, 0x65, 0x61, 0x6e, 0x75, 0x74, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65,
+0x64, 0xd83e, 0xdd5c, 0x3a, 0x70, 0x65, 0x61, 0x6e, 0x75, 0x74, 0x73, 0x3a,
+0x70, 0x65, 0x61, 0x6e, 0x75, 0x74, 0x73, 0xd83c, 0xdf6f, 0x3a, 0x68, 0x6f,
+0x6e, 0x65, 0x79, 0x5f, 0x70, 0x6f, 0x74, 0x3a, 0x68, 0x6f, 0x6e, 0x65,
+0x79, 0x70, 0x6f, 0x74, 0xd83e, 0xdd50, 0x3a, 0x63, 0x72, 0x6f, 0x69, 0x73,
+0x73, 0x61, 0x6e, 0x74, 0x3a, 0x63, 0x72, 0x6f, 0x69, 0x73, 0x73, 0x61,
+0x6e, 0x74, 0xd83c, 0xdf5e, 0x3a, 0x62, 0x72, 0x65, 0x61, 0x64, 0x3a, 0x62,
+0x72, 0x65, 0x61, 0x64, 0xd83e, 0xdd56, 0x3a, 0x62, 0x61, 0x67, 0x75, 0x65,
+0x74, 0x74, 0x65, 0x5f, 0x62, 0x72, 0x65, 0x61, 0x64, 0x3a, 0x62, 0x61,
+0x67, 0x75, 0x65, 0x74, 0x74, 0x65, 0x62, 0x72, 0x65, 0x61, 0x64, 0xd83e,
+0xdd56, 0x3a, 0x66, 0x72, 0x65, 0x6e, 0x63, 0x68, 0x5f, 0x62, 0x72, 0x65,
+0x61, 0x64, 0x3a, 0x62, 0x72, 0x65, 0x61, 0x64, 0x66, 0x72, 0x65, 0x6e,
+0x63, 0x68, 0xd83e, 0xddc0, 0x3a, 0x63, 0x68, 0x65, 0x65, 0x73, 0x65, 0x5f,
+0x77, 0x65, 0x64, 0x67, 0x65, 0x3a, 0x63, 0x68, 0x65, 0x65, 0x73, 0x65,
+0x77, 0x65, 0x64, 0x67, 0x65, 0xd83e, 0xddc0, 0x3a, 0x63, 0x68, 0x65, 0x65,
+0x73, 0x65, 0x3a, 0x63, 0x68, 0x65, 0x65, 0x73, 0x65, 0xd83e, 0xdd5a, 0x3a,
+0x65, 0x67, 0x67, 0x3a, 0x65, 0x67, 0x67, 0xd83c, 0xdf73, 0x3a, 0x63, 0x6f,
+0x6f, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x6e,
+0x67, 0xd83e, 0xdd53, 0x3a, 0x62, 0x61, 0x63, 0x6f, 0x6e, 0x3a, 0x62, 0x61,
+0x63, 0x6f, 0x6e, 0xd83e, 0xdd5e, 0x3a, 0x70, 0x61, 0x6e, 0x63, 0x61, 0x6b,
+0x65, 0x73, 0x3a, 0x70, 0x61, 0x6e, 0x63, 0x61, 0x6b, 0x65, 0x73, 0xd83c,
+0xdf64, 0x3a, 0x66, 0x72, 0x69, 0x65, 0x64, 0x5f, 0x73, 0x68, 0x72, 0x69,
+0x6d, 0x70, 0x3a, 0x66, 0x72, 0x69, 0x65, 0x64, 0x73, 0x68, 0x72, 0x69,
+0x6d, 0x70, 0xd83c, 0xdf57, 0x3a, 0x70, 0x6f, 0x75, 0x6c, 0x74, 0x72, 0x79,
+0x5f, 0x6c, 0x65, 0x67, 0x3a, 0x6c, 0x65, 0x67, 0x70, 0x6f, 0x75, 0x6c,
+0x74, 0x72, 0x79, 0xd83c, 0xdf56, 0x3a, 0x6d, 0x65, 0x61, 0x74, 0x5f, 0x6f,
+0x6e, 0x5f, 0x62, 0x6f, 0x6e, 0x65, 0x3a, 0x62, 0x6f, 0x6e, 0x65, 0x6d,
+0x65, 0x61, 0x74, 0x6f, 0x6e, 0xd83c, 0xdf55, 0x3a, 0x70, 0x69, 0x7a, 0x7a,
+0x61, 0x3a, 0x70, 0x69, 0x7a, 0x7a, 0x61, 0xd83c, 0xdf2d, 0x3a, 0x68, 0x6f,
+0x74, 0x5f, 0x64, 0x6f, 0x67, 0x3a, 0x64, 0x6f, 0x67, 0x68, 0x6f, 0x74,
+0xd83c, 0xdf2d, 0x3a, 0x68, 0x6f, 0x74, 0x64, 0x6f, 0x67, 0x3a, 0x68, 0x6f,
+0x74, 0x64, 0x6f, 0x67, 0xd83c, 0xdf54, 0x3a, 0x68, 0x61, 0x6d, 0x62, 0x75,
+0x72, 0x67, 0x65, 0x72, 0x3a, 0x68, 0x61, 0x6d, 0x62, 0x75, 0x72, 0x67,
+0x65, 0x72, 0xd83c, 0xdf5f, 0x3a, 0x66, 0x72, 0x69, 0x65, 0x73, 0x3a, 0x66,
+0x72, 0x69, 0x65, 0x73, 0xd83e, 0xdd59, 0x3a, 0x73, 0x74, 0x75, 0x66, 0x66,
+0x65, 0x64, 0x5f, 0x70, 0x69, 0x74, 0x61, 0x3a, 0x70, 0x69, 0x74, 0x61,
+0x73, 0x74, 0x75, 0x66, 0x66, 0x65, 0x64, 0xd83e, 0xdd59, 0x3a, 0x73, 0x74,
+0x75, 0x66, 0x66, 0x65, 0x64, 0x5f, 0x66, 0x6c, 0x61, 0x74, 0x62, 0x72,
+0x65, 0x61, 0x64, 0x3a, 0x66, 0x6c, 0x61, 0x74, 0x62, 0x72, 0x65, 0x61,
+0x64, 0x73, 0x74, 0x75, 0x66, 0x66, 0x65, 0x64, 0xd83c, 0xdf2e, 0x3a, 0x74,
+0x61, 0x63, 0x6f, 0x3a, 0x74, 0x61, 0x63, 0x6f, 0xd83c, 0xdf2f, 0x3a, 0x62,
+0x75, 0x72, 0x72, 0x69, 0x74, 0x6f, 0x3a, 0x62, 0x75, 0x72, 0x72, 0x69,
+0x74, 0x6f, 0xd83e, 0xdd57, 0x3a, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x73,
+0x61, 0x6c, 0x61, 0x64, 0x3a, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x61,
+0x6c, 0x61, 0x64, 0xd83e, 0xdd57, 0x3a, 0x73, 0x61, 0x6c, 0x61, 0x64, 0x3a,
+0x73, 0x61, 0x6c, 0x61, 0x64, 0xd83e, 0xdd58, 0x3a, 0x70, 0x61, 0x65, 0x6c,
+0x6c, 0x61, 0x3a, 0x70, 0x61, 0x65, 0x6c, 0x6c, 0x61, 0xd83e, 0xdd58, 0x3a,
+0x73, 0x68, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x61, 0x6e, 0x5f,
+0x6f, 0x66, 0x5f, 0x66, 0x6f, 0x6f, 0x64, 0x3a, 0x66, 0x6f, 0x6f, 0x64,
+0x6f, 0x66, 0x70, 0x61, 0x6e, 0x73, 0x68, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
+0xd83c, 0xdf5d, 0x3a, 0x73, 0x70, 0x61, 0x67, 0x68, 0x65, 0x74, 0x74, 0x69,
+0x3a, 0x73, 0x70, 0x61, 0x67, 0x68, 0x65, 0x74, 0x74, 0x69, 0xd83c, 0xdf5c,
+0x3a, 0x72, 0x61, 0x6d, 0x65, 0x6e, 0x3a, 0x72, 0x61, 0x6d, 0x65, 0x6e,
+0xd83c, 0xdf72, 0x3a, 0x73, 0x74, 0x65, 0x77, 0x3a, 0x73, 0x74, 0x65, 0x77,
+0xd83c, 0xdf65, 0x3a, 0x66, 0x69, 0x73, 0x68, 0x5f, 0x63, 0x61, 0x6b, 0x65,
+0x3a, 0x63, 0x61, 0x6b, 0x65, 0x66, 0x69, 0x73, 0x68, 0xd83c, 0xdf63, 0x3a,
+0x73, 0x75, 0x73, 0x68, 0x69, 0x3a, 0x73, 0x75, 0x73, 0x68, 0x69, 0xd83c,
+0xdf71, 0x3a, 0x62, 0x65, 0x6e, 0x74, 0x6f, 0x3a, 0x62, 0x65, 0x6e, 0x74,
+0x6f, 0xd83c, 0xdf5b, 0x3a, 0x63, 0x75, 0x72, 0x72, 0x79, 0x3a, 0x63, 0x75,
+0x72, 0x72, 0x79, 0xd83c, 0xdf59, 0x3a, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x62,
+0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x72, 0x69, 0x63, 0x65,
+0xd83c, 0xdf5a, 0x3a, 0x72, 0x69, 0x63, 0x65, 0x3a, 0x72, 0x69, 0x63, 0x65,
+0xd83c, 0xdf58, 0x3a, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x63, 0x72, 0x61, 0x63,
+0x6b, 0x65, 0x72, 0x3a, 0x63, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x72,
+0x69, 0x63, 0x65, 0xd83c, 0xdf62, 0x3a, 0x6f, 0x64, 0x65, 0x6e, 0x3a, 0x6f,
+0x64, 0x65, 0x6e, 0xd83c, 0xdf61, 0x3a, 0x64, 0x61, 0x6e, 0x67, 0x6f, 0x3a,
+0x64, 0x61, 0x6e, 0x67, 0x6f, 0xd83c, 0xdf67, 0x3a, 0x73, 0x68, 0x61, 0x76,
+0x65, 0x64, 0x5f, 0x69, 0x63, 0x65, 0x3a, 0x69, 0x63, 0x65, 0x73, 0x68,
+0x61, 0x76, 0x65, 0x64, 0xd83c, 0xdf68, 0x3a, 0x69, 0x63, 0x65, 0x5f, 0x63,
+0x72, 0x65, 0x61, 0x6d, 0x3a, 0x63, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x63,
+0x65, 0xd83c, 0xdf66, 0x3a, 0x69, 0x63, 0x65, 0x63, 0x72, 0x65, 0x61, 0x6d,
+0x3a, 0x69, 0x63, 0x65, 0x63, 0x72, 0x65, 0x61, 0x6d, 0xd83c, 0xdf70, 0x3a,
+0x63, 0x61, 0x6b, 0x65, 0x3a, 0x63, 0x61, 0x6b, 0x65, 0xd83c, 0xdf82, 0x3a,
+0x62, 0x69, 0x72, 0x74, 0x68, 0x64, 0x61, 0x79, 0x3a, 0x62, 0x69, 0x72,
+0x74, 0x68, 0x64, 0x61, 0x79, 0xd83c, 0xdf6e, 0x3a, 0x66, 0x6c, 0x61, 0x6e,
+0x3a, 0x66, 0x6c, 0x61, 0x6e, 0xd83c, 0xdf6e, 0x3a, 0x70, 0x75, 0x64, 0x64,
+0x69, 0x6e, 0x67, 0x3a, 0x70, 0x75, 0x64, 0x64, 0x69, 0x6e, 0x67, 0xd83c,
+0xdf6e, 0x3a, 0x63, 0x75, 0x73, 0x74, 0x61, 0x72, 0x64, 0x3a, 0x63, 0x75,
+0x73, 0x74, 0x61, 0x72, 0x64, 0xd83c, 0xdf6d, 0x3a, 0x6c, 0x6f, 0x6c, 0x6c,
+0x69, 0x70, 0x6f, 0x70, 0x3a, 0x6c, 0x6f, 0x6c, 0x6c, 0x69, 0x70, 0x6f,
+0x70, 0xd83c, 0xdf6c, 0x3a, 0x63, 0x61, 0x6e, 0x64, 0x79, 0x3a, 0x63, 0x61,
+0x6e, 0x64, 0x79, 0xd83c, 0xdf6b, 0x3a, 0x63, 0x68, 0x6f, 0x63, 0x6f, 0x6c,
+0x61, 0x74, 0x65, 0x5f, 0x62, 0x61, 0x72, 0x3a, 0x62, 0x61, 0x72, 0x63,
+0x68, 0x6f, 0x63, 0x6f, 0x6c, 0x61, 0x74, 0x65, 0xd83c, 0xdf7f, 0x3a, 0x70,
+0x6f, 0x70, 0x63, 0x6f, 0x72, 0x6e, 0x3a, 0x70, 0x6f, 0x70, 0x63, 0x6f,
+0x72, 0x6e, 0xd83c, 0xdf69, 0x3a, 0x64, 0x6f, 0x75, 0x67, 0x68, 0x6e, 0x75,
+0x74, 0x3a, 0x64, 0x6f, 0x75, 0x67, 0x68, 0x6e, 0x75, 0x74, 0xd83c, 0xdf6a,
+0x3a, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x3a, 0x63, 0x6f, 0x6f, 0x6b,
+0x69, 0x65, 0xd83e, 0xdd5b, 0x3a, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x6f,
+0x66, 0x5f, 0x6d, 0x69, 0x6c, 0x6b, 0x3a, 0x67, 0x6c, 0x61, 0x73, 0x73,
+0x6d, 0x69, 0x6c, 0x6b, 0x6f, 0x66, 0xd83e, 0xdd5b, 0x3a, 0x6d, 0x69, 0x6c,
+0x6b, 0x3a, 0x6d, 0x69, 0x6c, 0x6b, 0xd83c, 0xdf7c, 0x3a, 0x62, 0x61, 0x62,
+0x79, 0x5f, 0x62, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x3a, 0x62, 0x61, 0x62,
+0x79, 0x62, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x2615, 0xfe0f, 0x3a, 0x63, 0x6f,
+0x66, 0x66, 0x65, 0x65, 0x3a, 0x63, 0x6f, 0x66, 0x66, 0x65, 0x65, 0xd83c,
+0xdf75, 0x3a, 0x74, 0x65, 0x61, 0x3a, 0x74, 0x65, 0x61, 0xd83c, 0xdf76, 0x3a,
+0x73, 0x61, 0x6b, 0x65, 0x3a, 0x73, 0x61, 0x6b, 0x65, 0xd83c, 0xdf7a, 0x3a,
+0x62, 0x65, 0x65, 0x72, 0x3a, 0x62, 0x65, 0x65, 0x72, 0xd83c, 0xdf7b, 0x3a,
+0x62, 0x65, 0x65, 0x72, 0x73, 0x3a, 0x62, 0x65, 0x65, 0x72, 0x73, 0xd83e,
+0xdd42, 0x3a, 0x63, 0x6c, 0x69, 0x6e, 0x6b, 0x69, 0x6e, 0x67, 0x5f, 0x67,
+0x6c, 0x61, 0x73, 0x73, 0x3a, 0x63, 0x6c, 0x69, 0x6e, 0x6b, 0x69, 0x6e,
+0x67, 0x67, 0x6c, 0x61, 0x73, 0x73, 0xd83e, 0xdd42, 0x3a, 0x63, 0x68, 0x61,
+0x6d, 0x70, 0x61, 0x67, 0x6e, 0x65, 0x5f, 0x67, 0x6c, 0x61, 0x73, 0x73,
+0x3a, 0x63, 0x68, 0x61, 0x6d, 0x70, 0x61, 0x67, 0x6e, 0x65, 0x67, 0x6c,
+0x61, 0x73, 0x73, 0xd83c, 0xdf77, 0x3a, 0x77, 0x69, 0x6e, 0x65, 0x5f, 0x67,
+0x6c, 0x61, 0x73, 0x73, 0x3a, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x77, 0x69,
+0x6e, 0x65, 0xd83e, 0xdd43, 0x3a, 0x77, 0x68, 0x69, 0x73, 0x6b, 0x79, 0x3a,
+0x77, 0x68, 0x69, 0x73, 0x6b, 0x79, 0xd83e, 0xdd43, 0x3a, 0x74, 0x75, 0x6d,
+0x62, 0x6c, 0x65, 0x72, 0x5f, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x3a, 0x67,
+0x6c, 0x61, 0x73, 0x73, 0x74, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x72, 0xd83c,
+0xdf78, 0x3a, 0x63, 0x6f, 0x63, 0x6b, 0x74, 0x61, 0x69, 0x6c, 0x3a, 0x63,
+0x6f, 0x63, 0x6b, 0x74, 0x61, 0x69, 0x6c, 0xd83c, 0xdf79, 0x3a, 0x74, 0x72,
+0x6f, 0x70, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x64, 0x72, 0x69, 0x6e, 0x6b,
+0x3a, 0x64, 0x72, 0x69, 0x6e, 0x6b, 0x74, 0x72, 0x6f, 0x70, 0x69, 0x63,
+0x61, 0x6c, 0xd83c, 0xdf7e, 0x3a, 0x62, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x70, 0x6f, 0x70, 0x70, 0x69, 0x6e, 0x67,
+0x5f, 0x63, 0x6f, 0x72, 0x6b, 0x3a, 0x62, 0x6f, 0x74, 0x74, 0x6c, 0x65,
+0x63, 0x6f, 0x72, 0x6b, 0x70, 0x6f, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x77,
+0x69, 0x74, 0x68, 0xd83c, 0xdf7e, 0x3a, 0x63, 0x68, 0x61, 0x6d, 0x70, 0x61,
+0x67, 0x6e, 0x65, 0x3a, 0x63, 0x68, 0x61, 0x6d, 0x70, 0x61, 0x67, 0x6e,
+0x65, 0xd83e, 0xdd44, 0x3a, 0x73, 0x70, 0x6f, 0x6f, 0x6e, 0x3a, 0x73, 0x70,
+0x6f, 0x6f, 0x6e, 0xd83c, 0xdf74, 0x3a, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x61,
+0x6e, 0x64, 0x5f, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0x3a, 0x61, 0x6e, 0x64,
+0x66, 0x6f, 0x72, 0x6b, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0xd83c, 0xdf7d, 0x3a,
+0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x6b, 0x6e, 0x69,
+0x66, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x70, 0x6c, 0x61, 0x74,
+0x65, 0x3a, 0x61, 0x6e, 0x64, 0x66, 0x6f, 0x72, 0x6b, 0x6b, 0x6e, 0x69,
+0x66, 0x65, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83c,
+0xdf7d, 0x3a, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x6b, 0x6e, 0x69, 0x66, 0x65,
+0x5f, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x3a, 0x66, 0x6f, 0x72, 0x6b, 0x6b,
+0x6e, 0x69, 0x66, 0x65, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x26bd, 0xfe0f, 0x3a,
+0x73, 0x6f, 0x63, 0x63, 0x65, 0x72, 0x3a, 0x73, 0x6f, 0x63, 0x63, 0x65,
+0x72, 0xd83c, 0xdfc0, 0x3a, 0x62, 0x61, 0x73, 0x6b, 0x65, 0x74, 0x62, 0x61,
+0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x73, 0x6b, 0x65, 0x74, 0x62, 0x61, 0x6c,
+0x6c, 0xd83c, 0xdfc8, 0x3a, 0x66, 0x6f, 0x6f, 0x74, 0x62, 0x61, 0x6c, 0x6c,
+0x3a, 0x66, 0x6f, 0x6f, 0x74, 0x62, 0x61, 0x6c, 0x6c, 0x26be, 0xfe0f, 0x3a,
+0x62, 0x61, 0x73, 0x65, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x73,
+0x65, 0x62, 0x61, 0x6c, 0x6c, 0xd83c, 0xdfbe, 0x3a, 0x74, 0x65, 0x6e, 0x6e,
+0x69, 0x73, 0x3a, 0x74, 0x65, 0x6e, 0x6e, 0x69, 0x73, 0xd83c, 0xdfd0, 0x3a,
+0x76, 0x6f, 0x6c, 0x6c, 0x65, 0x79, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x76,
+0x6f, 0x6c, 0x6c, 0x65, 0x79, 0x62, 0x61, 0x6c, 0x6c, 0xd83c, 0xdfc9, 0x3a,
+0x72, 0x75, 0x67, 0x62, 0x79, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x62, 0x61,
+0x6c, 0x6c, 0x3a, 0x66, 0x6f, 0x6f, 0x74, 0x62, 0x61, 0x6c, 0x6c, 0x72,
+0x75, 0x67, 0x62, 0x79, 0xd83c, 0xdfb1, 0x3a, 0x38, 0x62, 0x61, 0x6c, 0x6c,
+0x3a, 0x38, 0x62, 0x61, 0x6c, 0x6c, 0xd83c, 0xdfd3, 0x3a, 0x74, 0x61, 0x62,
+0x6c, 0x65, 0x5f, 0x74, 0x65, 0x6e, 0x6e, 0x69, 0x73, 0x3a, 0x74, 0x61,
+0x62, 0x6c, 0x65, 0x74, 0x65, 0x6e, 0x6e, 0x69, 0x73, 0xd83c, 0xdfd3, 0x3a,
+0x70, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x6f, 0x6e, 0x67, 0x3a, 0x70, 0x69,
+0x6e, 0x67, 0x70, 0x6f, 0x6e, 0x67, 0xd83c, 0xdff8, 0x3a, 0x62, 0x61, 0x64,
+0x6d, 0x69, 0x6e, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x61, 0x64, 0x6d, 0x69,
+0x6e, 0x74, 0x6f, 0x6e, 0xd83e, 0xdd45, 0x3a, 0x67, 0x6f, 0x61, 0x6c, 0x5f,
+0x6e, 0x65, 0x74, 0x3a, 0x67, 0x6f, 0x61, 0x6c, 0x6e, 0x65, 0x74, 0xd83e,
+0xdd45, 0x3a, 0x67, 0x6f, 0x61, 0x6c, 0x3a, 0x67, 0x6f, 0x61, 0x6c, 0xd83c,
+0xdfd2, 0x3a, 0x68, 0x6f, 0x63, 0x6b, 0x65, 0x79, 0x3a, 0x68, 0x6f, 0x63,
+0x6b, 0x65, 0x79, 0xd83c, 0xdfd1, 0x3a, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f,
+0x68, 0x6f, 0x63, 0x6b, 0x65, 0x79, 0x3a, 0x66, 0x69, 0x65, 0x6c, 0x64,
+0x68, 0x6f, 0x63, 0x6b, 0x65, 0x79, 0xd83c, 0xdfcf, 0x3a, 0x63, 0x72, 0x69,
+0x63, 0x6b, 0x65, 0x74, 0x5f, 0x62, 0x61, 0x74, 0x5f, 0x62, 0x61, 0x6c,
+0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x74, 0x63, 0x72, 0x69,
+0x63, 0x6b, 0x65, 0x74, 0xd83c, 0xdfcf, 0x3a, 0x63, 0x72, 0x69, 0x63, 0x6b,
+0x65, 0x74, 0x5f, 0x67, 0x61, 0x6d, 0x65, 0x3a, 0x63, 0x72, 0x69, 0x63,
+0x6b, 0x65, 0x74, 0x67, 0x61, 0x6d, 0x65, 0x26f3, 0xfe0f, 0x3a, 0x67, 0x6f,
+0x6c, 0x66, 0x3a, 0x67, 0x6f, 0x6c, 0x66, 0xd83c, 0xdff9, 0x3a, 0x61, 0x72,
+0x63, 0x68, 0x65, 0x72, 0x79, 0x3a, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72,
+0x79, 0xd83c, 0xdff9, 0x3a, 0x62, 0x6f, 0x77, 0x5f, 0x61, 0x6e, 0x64, 0x5f,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x3a, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x62, 0x6f, 0x77, 0xd83c, 0xdfa3, 0x3a, 0x66, 0x69, 0x73, 0x68,
+0x69, 0x6e, 0x67, 0x5f, 0x70, 0x6f, 0x6c, 0x65, 0x5f, 0x61, 0x6e, 0x64,
+0x5f, 0x66, 0x69, 0x73, 0x68, 0x3a, 0x61, 0x6e, 0x64, 0x66, 0x69, 0x73,
+0x68, 0x66, 0x69, 0x73, 0x68, 0x69, 0x6e, 0x67, 0x70, 0x6f, 0x6c, 0x65,
+0xd83e, 0xdd4a, 0x3a, 0x62, 0x6f, 0x78, 0x69, 0x6e, 0x67, 0x5f, 0x67, 0x6c,
+0x6f, 0x76, 0x65, 0x73, 0x3a, 0x62, 0x6f, 0x78, 0x69, 0x6e, 0x67, 0x67,
+0x6c, 0x6f, 0x76, 0x65, 0x73, 0xd83e, 0xdd4a, 0x3a, 0x62, 0x6f, 0x78, 0x69,
+0x6e, 0x67, 0x5f, 0x67, 0x6c, 0x6f, 0x76, 0x65, 0x3a, 0x62, 0x6f, 0x78,
+0x69, 0x6e, 0x67, 0x67, 0x6c, 0x6f, 0x76, 0x65, 0xd83e, 0xdd4b, 0x3a, 0x6b,
+0x61, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x75, 0x6e, 0x69, 0x66, 0x6f, 0x72,
+0x6d, 0x3a, 0x6b, 0x61, 0x72, 0x61, 0x74, 0x65, 0x75, 0x6e, 0x69, 0x66,
+0x6f, 0x72, 0x6d, 0xd83e, 0xdd4b, 0x3a, 0x6d, 0x61, 0x72, 0x74, 0x69, 0x61,
+0x6c, 0x5f, 0x61, 0x72, 0x74, 0x73, 0x5f, 0x75, 0x6e, 0x69, 0x66, 0x6f,
+0x72, 0x6d, 0x3a, 0x61, 0x72, 0x74, 0x73, 0x6d, 0x61, 0x72, 0x74, 0x69,
+0x61, 0x6c, 0x75, 0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x26f8, 0x3a, 0x69,
+0x63, 0x65, 0x5f, 0x73, 0x6b, 0x61, 0x74, 0x65, 0x3a, 0x69, 0x63, 0x65,
+0x73, 0x6b, 0x61, 0x74, 0x65, 0xd83c, 0xdfbf, 0x3a, 0x73, 0x6b, 0x69, 0x3a,
+0x73, 0x6b, 0x69, 0x26f7, 0x3a, 0x73, 0x6b, 0x69, 0x65, 0x72, 0x3a, 0x73,
+0x6b, 0x69, 0x65, 0x72, 0xd83c, 0xdfc2, 0x3a, 0x73, 0x6e, 0x6f, 0x77, 0x62,
+0x6f, 0x61, 0x72, 0x64, 0x65, 0x72, 0x3a, 0x73, 0x6e, 0x6f, 0x77, 0x62,
+0x6f, 0x61, 0x72, 0x64, 0x65, 0x72, 0xd83c, 0xdfcb, 0xfe0f, 0x200d, 0x2640, 0xfe0f,
+0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x74, 0x69,
+0x6e, 0x67, 0x5f, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0x3a, 0x6c,
+0x69, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74,
+0x73, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83c, 0xdfcb, 0xfe0f, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x65,
+0x69, 0x67, 0x68, 0x74, 0x73, 0x3a, 0x6c, 0x69, 0x66, 0x74, 0x69, 0x6e,
+0x67, 0x6d, 0x61, 0x6e, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0xd83c,
+0xdfcb, 0xfe0f, 0x3a, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x69,
+0x66, 0x74, 0x65, 0x72, 0x3a, 0x6c, 0x69, 0x66, 0x74, 0x65, 0x72, 0x77,
+0x65, 0x69, 0x67, 0x68, 0x74, 0xd83c, 0xdfcb, 0xfe0f, 0x3a, 0x6c, 0x69, 0x66,
+0x74, 0x65, 0x72, 0x3a, 0x6c, 0x69, 0x66, 0x74, 0x65, 0x72, 0xd83c, 0xdfcb,
+0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x6c, 0x69, 0x66,
+0x74, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73,
+0x3a, 0x6c, 0x69, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x73, 0xd83e, 0xdd3a, 0x3a,
+0x66, 0x65, 0x6e, 0x63, 0x69, 0x6e, 0x67, 0x3a, 0x66, 0x65, 0x6e, 0x63,
+0x69, 0x6e, 0x67, 0xd83e, 0xdd3a, 0x3a, 0x66, 0x65, 0x6e, 0x63, 0x65, 0x72,
+0x3a, 0x66, 0x65, 0x6e, 0x63, 0x65, 0x72, 0xd83e, 0xdd3a, 0x3a, 0x70, 0x65,
+0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x66, 0x65, 0x6e, 0x63, 0x69, 0x6e, 0x67,
+0x3a, 0x66, 0x65, 0x6e, 0x63, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0xd83e, 0xdd3c, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x65,
+0x6e, 0x5f, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x3a,
+0x77, 0x6f, 0x6d, 0x65, 0x6e, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69,
+0x6e, 0x67, 0xd83e, 0xdd3c, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x65, 0x6e, 0x5f,
+0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x3a, 0x6d, 0x65,
+0x6e, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0xd83e, 0xdd3c,
+0x200d, 0x2642, 0xfe0f, 0x3a, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e,
+0x67, 0x3a, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0xd83e,
+0xdd3c, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x65,
+0x72, 0x73, 0x3a, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x65, 0x72, 0x73,
+0xd83e, 0xdd3c, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65,
+0x5f, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x3a, 0x70,
+0x65, 0x6f, 0x70, 0x6c, 0x65, 0x77, 0x72, 0x65, 0x73, 0x74, 0x6c, 0x69,
+0x6e, 0x67, 0xd83e, 0xdd38, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0x5f, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68, 0x65, 0x65, 0x6c, 0x69,
+0x6e, 0x67, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68, 0x65, 0x65, 0x6c,
+0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd38, 0x200d, 0x2642,
+0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68,
+0x65, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x77,
+0x68, 0x65, 0x65, 0x6c, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd38,
+0x200d, 0x2642, 0xfe0f, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68, 0x65, 0x65,
+0x6c, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68, 0x65, 0x65, 0x6c, 0xd83e,
+0xdd38, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f,
+0x64, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68,
+0x65, 0x65, 0x6c, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x77, 0x68, 0x65, 0x65,
+0x6c, 0x64, 0x6f, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x26f9, 0xfe0f, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x62, 0x6f, 0x75, 0x6e, 0x63, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x61, 0x6c,
+0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x62, 0x6f, 0x75, 0x6e, 0x63, 0x69,
+0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x26f9, 0xfe0f, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x63, 0x69, 0x6e, 0x67, 0x5f, 0x62,
+0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x62, 0x6f, 0x75, 0x6e,
+0x63, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0x26f9, 0xfe0f, 0x3a, 0x70, 0x65,
+0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x62, 0x61,
+0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x70, 0x65, 0x72, 0x73, 0x6f,
+0x6e, 0x77, 0x69, 0x74, 0x68, 0x26f9, 0xfe0f, 0x3a, 0x62, 0x61, 0x73, 0x6b,
+0x65, 0x74, 0x62, 0x61, 0x6c, 0x6c, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65,
+0x72, 0x3a, 0x62, 0x61, 0x73, 0x6b, 0x65, 0x74, 0x62, 0x61, 0x6c, 0x6c,
+0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x26f9, 0xfe0f, 0x3a, 0x70, 0x65, 0x72,
+0x73, 0x6f, 0x6e, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x63, 0x69, 0x6e, 0x67,
+0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x62, 0x6f,
+0x75, 0x6e, 0x63, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0xd83e, 0xdd3e, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e, 0x64,
+0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62, 0x61, 0x6c,
+0x6c, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61,
+0x6e, 0xd83e, 0xdd3e, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62,
+0x61, 0x6c, 0x6c, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62, 0x61, 0x6c, 0x6c,
+0xd83e, 0xdd3e, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x5f, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62, 0x61,
+0x6c, 0x6c, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x70, 0x6c, 0x61, 0x79,
+0x69, 0x6e, 0x67, 0xd83e, 0xdd3e, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x6e,
+0x64, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x68, 0x61, 0x6e, 0x64, 0x62, 0x61,
+0x6c, 0x6c, 0x6d, 0x61, 0x6e, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67,
+0xd83c, 0xdfcc, 0xfe0f, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e,
+0x5f, 0x67, 0x6f, 0x6c, 0x66, 0x69, 0x6e, 0x67, 0x3a, 0x67, 0x6f, 0x6c,
+0x66, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83c, 0xdfcc, 0xfe0f,
+0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x67, 0x6f, 0x6c, 0x66, 0x69, 0x6e, 0x67,
+0x3a, 0x67, 0x6f, 0x6c, 0x66, 0x69, 0x6e, 0x67, 0x6d, 0x61, 0x6e, 0xd83c,
+0xdfcc, 0xfe0f, 0x3a, 0x67, 0x6f, 0x6c, 0x66, 0x65, 0x72, 0x3a, 0x67, 0x6f,
+0x6c, 0x66, 0x65, 0x72, 0xd83c, 0xdfcc, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x5f, 0x67, 0x6f, 0x6c, 0x66, 0x69, 0x6e, 0x67, 0x3a, 0x67,
+0x6f, 0x6c, 0x66, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0xd83c, 0xdfc4, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x73, 0x75, 0x72, 0x66, 0x69, 0x6e, 0x67, 0x3a, 0x73, 0x75, 0x72, 0x66,
+0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83c, 0xdfc4, 0x3a, 0x6d,
+0x61, 0x6e, 0x5f, 0x73, 0x75, 0x72, 0x66, 0x69, 0x6e, 0x67, 0x3a, 0x6d,
+0x61, 0x6e, 0x73, 0x75, 0x72, 0x66, 0x69, 0x6e, 0x67, 0xd83c, 0xdfc4, 0x3a,
+0x73, 0x75, 0x72, 0x66, 0x65, 0x72, 0x3a, 0x73, 0x75, 0x72, 0x66, 0x65,
+0x72, 0xd83c, 0xdfc4, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x73,
+0x75, 0x72, 0x66, 0x69, 0x6e, 0x67, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f,
+0x6e, 0x73, 0x75, 0x72, 0x66, 0x69, 0x6e, 0x67, 0xd83c, 0xdfca, 0x200d, 0x2640,
+0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x73, 0x77, 0x69, 0x6d,
+0x6d, 0x69, 0x6e, 0x67, 0x3a, 0x73, 0x77, 0x69, 0x6d, 0x6d, 0x69, 0x6e,
+0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83c, 0xdfca, 0x3a, 0x6d, 0x61, 0x6e,
+0x5f, 0x73, 0x77, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x3a, 0x6d, 0x61,
+0x6e, 0x73, 0x77, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0xd83c, 0xdfca, 0x3a,
+0x73, 0x77, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x3a, 0x73, 0x77, 0x69, 0x6d,
+0x6d, 0x65, 0x72, 0xd83c, 0xdfca, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e,
+0x5f, 0x73, 0x77, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x3a, 0x70, 0x65,
+0x72, 0x73, 0x6f, 0x6e, 0x73, 0x77, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67,
+0xd83e, 0xdd3d, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x61, 0x74, 0x65,
+0x72, 0x5f, 0x70, 0x6f, 0x6c, 0x6f, 0x3a, 0x70, 0x6c, 0x61, 0x79, 0x69,
+0x6e, 0x67, 0x70, 0x6f, 0x6c, 0x6f, 0x77, 0x61, 0x74, 0x65, 0x72, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd3d, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6d, 0x61,
+0x6e, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x61,
+0x74, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x6c, 0x6f, 0x3a, 0x6d, 0x61, 0x6e,
+0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x70, 0x6f, 0x6c, 0x6f, 0x77,
+0x61, 0x74, 0x65, 0x72, 0xd83e, 0xdd3d, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x77, 0x61,
+0x74, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x6c, 0x6f, 0x3a, 0x70, 0x6f, 0x6c,
+0x6f, 0x77, 0x61, 0x74, 0x65, 0x72, 0xd83e, 0xdd3d, 0x200d, 0x2642, 0xfe0f, 0x3a,
+0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x69,
+0x6e, 0x67, 0x5f, 0x77, 0x61, 0x74, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x6c,
+0x6f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x70, 0x6c, 0x61, 0x79,
+0x69, 0x6e, 0x67, 0x70, 0x6f, 0x6c, 0x6f, 0x77, 0x61, 0x74, 0x65, 0x72,
+0xd83d, 0xdea3, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f,
+0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x6f, 0x61, 0x74, 0x3a,
+0x62, 0x6f, 0x61, 0x74, 0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x77, 0x6f,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdea3, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x72, 0x6f,
+0x77, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x6f, 0x61, 0x74, 0x3a, 0x62, 0x6f,
+0x61, 0x74, 0x6d, 0x61, 0x6e, 0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0xd83d,
+0xdea3, 0x3a, 0x72, 0x6f, 0x77, 0x62, 0x6f, 0x61, 0x74, 0x3a, 0x72, 0x6f,
+0x77, 0x62, 0x6f, 0x61, 0x74, 0xd83d, 0xdea3, 0x3a, 0x70, 0x65, 0x72, 0x73,
+0x6f, 0x6e, 0x5f, 0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x6f,
+0x61, 0x74, 0x3a, 0x62, 0x6f, 0x61, 0x74, 0x70, 0x65, 0x72, 0x73, 0x6f,
+0x6e, 0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0xd83c, 0xdfc7, 0x3a, 0x68, 0x6f,
+0x72, 0x73, 0x65, 0x5f, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x3a, 0x68,
+0x6f, 0x72, 0x73, 0x65, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0xd83d, 0xdeb4,
+0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x62, 0x69,
+0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67, 0x77,
+0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdeb4, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x62,
+0x69, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67,
+0x6d, 0x61, 0x6e, 0xd83d, 0xdeb4, 0x3a, 0x62, 0x69, 0x63, 0x79, 0x63, 0x6c,
+0x69, 0x73, 0x74, 0x3a, 0x62, 0x69, 0x63, 0x79, 0x63, 0x6c, 0x69, 0x73,
+0x74, 0xd83d, 0xdeb4, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x62,
+0x69, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67,
+0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83d, 0xdeb5, 0x200d, 0x2640, 0xfe0f, 0x3a,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61,
+0x69, 0x6e, 0x5f, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x69,
+0x6b, 0x69, 0x6e, 0x67, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e,
+0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83d, 0xdeb5, 0x3a, 0x6d, 0x61, 0x6e, 0x5f,
+0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x62, 0x69, 0x6b,
+0x69, 0x6e, 0x67, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67, 0x6d, 0x61,
+0x6e, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0xd83d, 0xdeb5, 0x3a,
+0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x62, 0x69, 0x63,
+0x79, 0x63, 0x6c, 0x69, 0x73, 0x74, 0x3a, 0x62, 0x69, 0x63, 0x79, 0x63,
+0x6c, 0x69, 0x73, 0x74, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e,
+0xd83d, 0xdeb5, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f, 0x6d, 0x6f,
+0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x62, 0x69, 0x6b, 0x69, 0x6e,
+0x67, 0x3a, 0x62, 0x69, 0x6b, 0x69, 0x6e, 0x67, 0x6d, 0x6f, 0x75, 0x6e,
+0x74, 0x61, 0x69, 0x6e, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83c, 0xdfbd,
+0x3a, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x68, 0x69,
+0x72, 0x74, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x61, 0x73, 0x68,
+0x3a, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x61, 0x73, 0x68,
+0x73, 0x68, 0x69, 0x72, 0x74, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdfc5, 0x3a,
+0x73, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f, 0x6d, 0x65, 0x64, 0x61, 0x6c,
+0x3a, 0x6d, 0x65, 0x64, 0x61, 0x6c, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x73,
+0xd83c, 0xdfc5, 0x3a, 0x6d, 0x65, 0x64, 0x61, 0x6c, 0x3a, 0x6d, 0x65, 0x64,
+0x61, 0x6c, 0xd83c, 0xdf96, 0x3a, 0x6d, 0x69, 0x6c, 0x69, 0x74, 0x61, 0x72,
+0x79, 0x5f, 0x6d, 0x65, 0x64, 0x61, 0x6c, 0x3a, 0x6d, 0x65, 0x64, 0x61,
+0x6c, 0x6d, 0x69, 0x6c, 0x69, 0x74, 0x61, 0x72, 0x79, 0xd83e, 0xdd47, 0x3a,
+0x66, 0x69, 0x72, 0x73, 0x74, 0x5f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f,
+0x6d, 0x65, 0x64, 0x61, 0x6c, 0x3a, 0x66, 0x69, 0x72, 0x73, 0x74, 0x6d,
+0x65, 0x64, 0x61, 0x6c, 0x70, 0x6c, 0x61, 0x63, 0x65, 0xd83e, 0xdd47, 0x3a,
+0x66, 0x69, 0x72, 0x73, 0x74, 0x5f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x3a,
+0x66, 0x69, 0x72, 0x73, 0x74, 0x70, 0x6c, 0x61, 0x63, 0x65, 0xd83e, 0xdd48,
+0x3a, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x5f, 0x70, 0x6c, 0x61, 0x63,
+0x65, 0x5f, 0x6d, 0x65, 0x64, 0x61, 0x6c, 0x3a, 0x6d, 0x65, 0x64, 0x61,
+0x6c, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64,
+0xd83e, 0xdd48, 0x3a, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x5f, 0x70, 0x6c,
+0x61, 0x63, 0x65, 0x3a, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x65, 0x63,
+0x6f, 0x6e, 0x64, 0xd83e, 0xdd49, 0x3a, 0x74, 0x68, 0x69, 0x72, 0x64, 0x5f,
+0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x6d, 0x65, 0x64, 0x61, 0x6c, 0x3a,
+0x6d, 0x65, 0x64, 0x61, 0x6c, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x74, 0x68,
+0x69, 0x72, 0x64, 0xd83e, 0xdd49, 0x3a, 0x74, 0x68, 0x69, 0x72, 0x64, 0x5f,
+0x70, 0x6c, 0x61, 0x63, 0x65, 0x3a, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x74,
+0x68, 0x69, 0x72, 0x64, 0xd83c, 0xdfc6, 0x3a, 0x74, 0x72, 0x6f, 0x70, 0x68,
+0x79, 0x3a, 0x74, 0x72, 0x6f, 0x70, 0x68, 0x79, 0xd83c, 0xdff5, 0x3a, 0x72,
+0x6f, 0x73, 0x65, 0x74, 0x74, 0x65, 0x3a, 0x72, 0x6f, 0x73, 0x65, 0x74,
+0x74, 0x65, 0xd83c, 0xdf97, 0x3a, 0x72, 0x65, 0x6d, 0x69, 0x6e, 0x64, 0x65,
+0x72, 0x5f, 0x72, 0x69, 0x62, 0x62, 0x6f, 0x6e, 0x3a, 0x72, 0x65, 0x6d,
+0x69, 0x6e, 0x64, 0x65, 0x72, 0x72, 0x69, 0x62, 0x62, 0x6f, 0x6e, 0xd83c,
+0xdfab, 0x3a, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x3a, 0x74, 0x69, 0x63,
+0x6b, 0x65, 0x74, 0xd83c, 0xdf9f, 0x3a, 0x61, 0x64, 0x6d, 0x69, 0x73, 0x73,
+0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x3a,
+0x61, 0x64, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x74, 0x69, 0x63,
+0x6b, 0x65, 0x74, 0x73, 0xd83c, 0xdf9f, 0x3a, 0x74, 0x69, 0x63, 0x6b, 0x65,
+0x74, 0x73, 0x3a, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x73, 0xd83c, 0xdfaa,
+0x3a, 0x63, 0x69, 0x72, 0x63, 0x75, 0x73, 0x5f, 0x74, 0x65, 0x6e, 0x74,
+0x3a, 0x63, 0x69, 0x72, 0x63, 0x75, 0x73, 0x74, 0x65, 0x6e, 0x74, 0xd83e,
+0xdd39, 0x200d, 0x2640, 0xfe0f, 0x3a, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0x5f, 0x6a,
+0x75, 0x67, 0x67, 0x6c, 0x69, 0x6e, 0x67, 0x3a, 0x6a, 0x75, 0x67, 0x67,
+0x6c, 0x69, 0x6e, 0x67, 0x77, 0x6f, 0x6d, 0x61, 0x6e, 0xd83e, 0xdd39, 0x200d,
+0x2642, 0xfe0f, 0x3a, 0x6d, 0x61, 0x6e, 0x5f, 0x6a, 0x75, 0x67, 0x67, 0x6c,
+0x69, 0x6e, 0x67, 0x3a, 0x6a, 0x75, 0x67, 0x67, 0x6c, 0x69, 0x6e, 0x67,
+0x6d, 0x61, 0x6e, 0xd83e, 0xdd39, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6a, 0x75, 0x67,
+0x67, 0x6c, 0x65, 0x72, 0x3a, 0x6a, 0x75, 0x67, 0x67, 0x6c, 0x65, 0x72,
+0xd83e, 0xdd39, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x6a, 0x75, 0x67, 0x67, 0x6c, 0x69,
+0x6e, 0x67, 0x3a, 0x6a, 0x75, 0x67, 0x67, 0x6c, 0x69, 0x6e, 0x67, 0xd83e,
+0xdd39, 0x200d, 0x2642, 0xfe0f, 0x3a, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x5f,
+0x6a, 0x75, 0x67, 0x67, 0x6c, 0x69, 0x6e, 0x67, 0x3a, 0x6a, 0x75, 0x67,
+0x67, 0x6c, 0x69, 0x6e, 0x67, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0xd83c,
+0xdfad, 0x3a, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x6e, 0x67,
+0x5f, 0x61, 0x72, 0x74, 0x73, 0x3a, 0x61, 0x72, 0x74, 0x73, 0x70, 0x65,
+0x72, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x6e, 0x67, 0xd83c, 0xdfa8, 0x3a, 0x61,
+0x72, 0x74, 0x3a, 0x61, 0x72, 0x74, 0xd83c, 0xdfac, 0x3a, 0x63, 0x6c, 0x61,
+0x70, 0x70, 0x65, 0x72, 0x3a, 0x63, 0x6c, 0x61, 0x70, 0x70, 0x65, 0x72,
+0xd83c, 0xdfa4, 0x3a, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f, 0x6e,
+0x65, 0x3a, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f, 0x6e, 0x65,
+0xd83c, 0xdfa7, 0x3a, 0x68, 0x65, 0x61, 0x64, 0x70, 0x68, 0x6f, 0x6e, 0x65,
+0x73, 0x3a, 0x68, 0x65, 0x61, 0x64, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x73,
+0xd83c, 0xdfbc, 0x3a, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x73,
+0x63, 0x6f, 0x72, 0x65, 0x3a, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x61, 0x6c,
+0x73, 0x63, 0x6f, 0x72, 0x65, 0xd83c, 0xdfb9, 0x3a, 0x6d, 0x75, 0x73, 0x69,
+0x63, 0x61, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x62, 0x6f, 0x61, 0x72, 0x64,
+0x3a, 0x6b, 0x65, 0x79, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x6d, 0x75, 0x73,
+0x69, 0x63, 0x61, 0x6c, 0xd83e, 0xdd41, 0x3a, 0x64, 0x72, 0x75, 0x6d, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x64, 0x72, 0x75, 0x6d, 0x73, 0x74, 0x69,
+0x63, 0x6b, 0x73, 0x3a, 0x64, 0x72, 0x75, 0x6d, 0x64, 0x72, 0x75, 0x6d,
+0x73, 0x74, 0x69, 0x63, 0x6b, 0x73, 0x77, 0x69, 0x74, 0x68, 0xd83e, 0xdd41,
+0x3a, 0x64, 0x72, 0x75, 0x6d, 0x3a, 0x64, 0x72, 0x75, 0x6d, 0xd83c, 0xdfb7,
+0x3a, 0x73, 0x61, 0x78, 0x6f, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x3a, 0x73,
+0x61, 0x78, 0x6f, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0xd83c, 0xdfba, 0x3a, 0x74,
+0x72, 0x75, 0x6d, 0x70, 0x65, 0x74, 0x3a, 0x74, 0x72, 0x75, 0x6d, 0x70,
+0x65, 0x74, 0xd83c, 0xdfb8, 0x3a, 0x67, 0x75, 0x69, 0x74, 0x61, 0x72, 0x3a,
+0x67, 0x75, 0x69, 0x74, 0x61, 0x72, 0xd83c, 0xdfbb, 0x3a, 0x76, 0x69, 0x6f,
+0x6c, 0x69, 0x6e, 0x3a, 0x76, 0x69, 0x6f, 0x6c, 0x69, 0x6e, 0xd83c, 0xdfb2,
+0x3a, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x64, 0x69, 0x65, 0x3a, 0x64, 0x69,
+0x65, 0x67, 0x61, 0x6d, 0x65, 0xd83c, 0xdfaf, 0x3a, 0x64, 0x61, 0x72, 0x74,
+0x3a, 0x64, 0x61, 0x72, 0x74, 0xd83c, 0xdfb3, 0x3a, 0x62, 0x6f, 0x77, 0x6c,
+0x69, 0x6e, 0x67, 0x3a, 0x62, 0x6f, 0x77, 0x6c, 0x69, 0x6e, 0x67, 0xd83c,
+0xdfae, 0x3a, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x67, 0x61, 0x6d, 0x65,
+0x3a, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x69, 0x64, 0x65, 0x6f, 0xd83c, 0xdfb0,
+0x3a, 0x73, 0x6c, 0x6f, 0x74, 0x5f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
+0x65, 0x3a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x6c, 0x6f,
+0x74, 0xd83d, 0xde97, 0x3a, 0x72, 0x65, 0x64, 0x5f, 0x63, 0x61, 0x72, 0x3a,
+0x63, 0x61, 0x72, 0x72, 0x65, 0x64, 0xd83d, 0xde95, 0x3a, 0x74, 0x61, 0x78,
+0x69, 0x3a, 0x74, 0x61, 0x78, 0x69, 0xd83d, 0xde99, 0x3a, 0x62, 0x6c, 0x75,
+0x65, 0x5f, 0x63, 0x61, 0x72, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x63, 0x61,
+0x72, 0xd83d, 0xde8c, 0x3a, 0x62, 0x75, 0x73, 0x3a, 0x62, 0x75, 0x73, 0xd83d,
+0xde8e, 0x3a, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x79, 0x62, 0x75, 0x73,
+0x3a, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x79, 0x62, 0x75, 0x73, 0xd83c,
+0xdfce, 0x3a, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x61, 0x72,
+0x3a, 0x63, 0x61, 0x72, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0xd83c, 0xdfce,
+0x3a, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x3a, 0x63, 0x61,
+0x72, 0x72, 0x61, 0x63, 0x65, 0xd83d, 0xde93, 0x3a, 0x70, 0x6f, 0x6c, 0x69,
+0x63, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x3a, 0x63, 0x61, 0x72, 0x70, 0x6f,
+0x6c, 0x69, 0x63, 0x65, 0xd83d, 0xde91, 0x3a, 0x61, 0x6d, 0x62, 0x75, 0x6c,
+0x61, 0x6e, 0x63, 0x65, 0x3a, 0x61, 0x6d, 0x62, 0x75, 0x6c, 0x61, 0x6e,
+0x63, 0x65, 0xd83d, 0xde92, 0x3a, 0x66, 0x69, 0x72, 0x65, 0x5f, 0x65, 0x6e,
+0x67, 0x69, 0x6e, 0x65, 0x3a, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x66,
+0x69, 0x72, 0x65, 0xd83d, 0xde90, 0x3a, 0x6d, 0x69, 0x6e, 0x69, 0x62, 0x75,
+0x73, 0x3a, 0x6d, 0x69, 0x6e, 0x69, 0x62, 0x75, 0x73, 0xd83d, 0xde9a, 0x3a,
+0x74, 0x72, 0x75, 0x63, 0x6b, 0x3a, 0x74, 0x72, 0x75, 0x63, 0x6b, 0xd83d,
+0xde9b, 0x3a, 0x61, 0x72, 0x74, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x65,
+0x64, 0x5f, 0x6c, 0x6f, 0x72, 0x72, 0x79, 0x3a, 0x61, 0x72, 0x74, 0x69,
+0x63, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x6c, 0x6f, 0x72, 0x72, 0x79,
+0xd83d, 0xde9c, 0x3a, 0x74, 0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x3a, 0x74,
+0x72, 0x61, 0x63, 0x74, 0x6f, 0x72, 0xd83d, 0xdef4, 0x3a, 0x73, 0x63, 0x6f,
+0x6f, 0x74, 0x65, 0x72, 0x3a, 0x73, 0x63, 0x6f, 0x6f, 0x74, 0x65, 0x72,
+0xd83d, 0xdeb2, 0x3a, 0x62, 0x69, 0x6b, 0x65, 0x3a, 0x62, 0x69, 0x6b, 0x65,
+0xd83d, 0xdef5, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x62, 0x69, 0x6b, 0x65,
+0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x62, 0x69, 0x6b, 0x65, 0xd83d, 0xdef5,
+0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x63, 0x6f, 0x6f, 0x74,
+0x65, 0x72, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x73, 0x63, 0x6f, 0x6f,
+0x74, 0x65, 0x72, 0xd83c, 0xdfcd, 0x3a, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67,
+0x5f, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x3a,
+0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x72, 0x61,
+0x63, 0x69, 0x6e, 0x67, 0xd83c, 0xdfcd, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72,
+0x63, 0x79, 0x63, 0x6c, 0x65, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x63,
+0x79, 0x63, 0x6c, 0x65, 0xd83d, 0xdea8, 0x3a, 0x72, 0x6f, 0x74, 0x61, 0x74,
+0x69, 0x6e, 0x67, 0x5f, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x6c, 0x69,
+0x67, 0x68, 0x74, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6e, 0x67, 0xd83d,
+0xde94, 0x3a, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x70,
+0x6f, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x63, 0x61, 0x72, 0x3a, 0x63, 0x61,
+0x72, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x70, 0x6f, 0x6c,
+0x69, 0x63, 0x65, 0xd83d, 0xde8d, 0x3a, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69,
+0x6e, 0x67, 0x5f, 0x62, 0x75, 0x73, 0x3a, 0x62, 0x75, 0x73, 0x6f, 0x6e,
+0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0xd83d, 0xde98, 0x3a, 0x6f, 0x6e, 0x63,
+0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x6f,
+0x62, 0x69, 0x6c, 0x65, 0x3a, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x6f, 0x62,
+0x69, 0x6c, 0x65, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0xd83d,
+0xde96, 0x3a, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x74,
+0x61, 0x78, 0x69, 0x3a, 0x6f, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67,
+0x74, 0x61, 0x78, 0x69, 0xd83d, 0xdea1, 0x3a, 0x61, 0x65, 0x72, 0x69, 0x61,
+0x6c, 0x5f, 0x74, 0x72, 0x61, 0x6d, 0x77, 0x61, 0x79, 0x3a, 0x61, 0x65,
+0x72, 0x69, 0x61, 0x6c, 0x74, 0x72, 0x61, 0x6d, 0x77, 0x61, 0x79, 0xd83d,
+0xdea0, 0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x63,
+0x61, 0x62, 0x6c, 0x65, 0x77, 0x61, 0x79, 0x3a, 0x63, 0x61, 0x62, 0x6c,
+0x65, 0x77, 0x61, 0x79, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e,
+0xd83d, 0xde9f, 0x3a, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6e, 0x73, 0x69, 0x6f,
+0x6e, 0x5f, 0x72, 0x61, 0x69, 0x6c, 0x77, 0x61, 0x79, 0x3a, 0x72, 0x61,
+0x69, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6e, 0x73,
+0x69, 0x6f, 0x6e, 0xd83d, 0xde83, 0x3a, 0x72, 0x61, 0x69, 0x6c, 0x77, 0x61,
+0x79, 0x5f, 0x63, 0x61, 0x72, 0x3a, 0x63, 0x61, 0x72, 0x72, 0x61, 0x69,
+0x6c, 0x77, 0x61, 0x79, 0xd83d, 0xde8b, 0x3a, 0x74, 0x72, 0x61, 0x69, 0x6e,
+0x3a, 0x74, 0x72, 0x61, 0x69, 0x6e, 0xd83d, 0xde9e, 0x3a, 0x6d, 0x6f, 0x75,
+0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x72, 0x61, 0x69, 0x6c, 0x77, 0x61,
+0x79, 0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x72, 0x61,
+0x69, 0x6c, 0x77, 0x61, 0x79, 0xd83d, 0xde9d, 0x3a, 0x6d, 0x6f, 0x6e, 0x6f,
+0x72, 0x61, 0x69, 0x6c, 0x3a, 0x6d, 0x6f, 0x6e, 0x6f, 0x72, 0x61, 0x69,
+0x6c, 0xd83d, 0xde84, 0x3a, 0x62, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x74, 0x72,
+0x61, 0x69, 0x6e, 0x5f, 0x73, 0x69, 0x64, 0x65, 0x3a, 0x62, 0x75, 0x6c,
+0x6c, 0x65, 0x74, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65,
+0xd83d, 0xde85, 0x3a, 0x62, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x74, 0x72, 0x61,
+0x69, 0x6e, 0x5f, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x3a, 0x62, 0x75, 0x6c,
+0x6c, 0x65, 0x74, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x66, 0x72, 0x6f, 0x6e,
+0x74, 0xd83d, 0xde88, 0x3a, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x72, 0x61,
+0x69, 0x6c, 0x3a, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x72, 0x61, 0x69, 0x6c,
+0xd83d, 0xde82, 0x3a, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x6c, 0x6f, 0x63,
+0x6f, 0x6d, 0x6f, 0x74, 0x69, 0x76, 0x65, 0x3a, 0x6c, 0x6f, 0x63, 0x6f,
+0x6d, 0x6f, 0x74, 0x69, 0x76, 0x65, 0x73, 0x74, 0x65, 0x61, 0x6d, 0xd83d,
+0xde86, 0x3a, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x32, 0x3a, 0x74, 0x72, 0x61,
+0x69, 0x6e, 0x32, 0xd83d, 0xde87, 0x3a, 0x6d, 0x65, 0x74, 0x72, 0x6f, 0x3a,
+0x6d, 0x65, 0x74, 0x72, 0x6f, 0xd83d, 0xde8a, 0x3a, 0x74, 0x72, 0x61, 0x6d,
+0x3a, 0x74, 0x72, 0x61, 0x6d, 0xd83d, 0xde89, 0x3a, 0x73, 0x74, 0x61, 0x74,
+0x69, 0x6f, 0x6e, 0x3a, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xd83d,
+0xde81, 0x3a, 0x68, 0x65, 0x6c, 0x69, 0x63, 0x6f, 0x70, 0x74, 0x65, 0x72,
+0x3a, 0x68, 0x65, 0x6c, 0x69, 0x63, 0x6f, 0x70, 0x74, 0x65, 0x72, 0xd83d,
+0xdee9, 0x3a, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x61, 0x69, 0x72, 0x70,
+0x6c, 0x61, 0x6e, 0x65, 0x3a, 0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e,
+0x65, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0xd83d, 0xdee9, 0x3a, 0x61, 0x69, 0x72,
+0x70, 0x6c, 0x61, 0x6e, 0x65, 0x5f, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x3a,
+0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0x73, 0x6d, 0x61, 0x6c,
+0x6c, 0x2708, 0xfe0f, 0x3a, 0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e, 0x65,
+0x3a, 0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0xd83d, 0xdeeb, 0x3a,
+0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0x5f, 0x64, 0x65, 0x70,
+0x61, 0x72, 0x74, 0x75, 0x72, 0x65, 0x3a, 0x61, 0x69, 0x72, 0x70, 0x6c,
+0x61, 0x6e, 0x65, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x75, 0x72, 0x65,
+0xd83d, 0xdeec, 0x3a, 0x61, 0x69, 0x72, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0x5f,
+0x61, 0x72, 0x72, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x3a, 0x61, 0x69, 0x72,
+0x70, 0x6c, 0x61, 0x6e, 0x65, 0x61, 0x72, 0x72, 0x69, 0x76, 0x69, 0x6e,
+0x67, 0xd83d, 0xde80, 0x3a, 0x72, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x3a, 0x72,
+0x6f, 0x63, 0x6b, 0x65, 0x74, 0xd83d, 0xdef0, 0x3a, 0x73, 0x61, 0x74, 0x65,
+0x6c, 0x6c, 0x69, 0x74, 0x65, 0x5f, 0x6f, 0x72, 0x62, 0x69, 0x74, 0x61,
+0x6c, 0x3a, 0x6f, 0x72, 0x62, 0x69, 0x74, 0x61, 0x6c, 0x73, 0x61, 0x74,
+0x65, 0x6c, 0x6c, 0x69, 0x74, 0x65, 0xd83d, 0xdcba, 0x3a, 0x73, 0x65, 0x61,
+0x74, 0x3a, 0x73, 0x65, 0x61, 0x74, 0xd83d, 0xdef6, 0x3a, 0x6b, 0x61, 0x79,
+0x61, 0x6b, 0x3a, 0x6b, 0x61, 0x79, 0x61, 0x6b, 0xd83d, 0xdef6, 0x3a, 0x63,
+0x61, 0x6e, 0x6f, 0x65, 0x3a, 0x63, 0x61, 0x6e, 0x6f, 0x65, 0x26f5, 0xfe0f,
+0x3a, 0x73, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x61, 0x74, 0x3a, 0x73, 0x61,
+0x69, 0x6c, 0x62, 0x6f, 0x61, 0x74, 0xd83d, 0xdee5, 0x3a, 0x6d, 0x6f, 0x74,
+0x6f, 0x72, 0x62, 0x6f, 0x61, 0x74, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72,
+0x62, 0x6f, 0x61, 0x74, 0xd83d, 0xdea4, 0x3a, 0x73, 0x70, 0x65, 0x65, 0x64,
+0x62, 0x6f, 0x61, 0x74, 0x3a, 0x73, 0x70, 0x65, 0x65, 0x64, 0x62, 0x6f,
+0x61, 0x74, 0xd83d, 0xdef3, 0x3a, 0x70, 0x61, 0x73, 0x73, 0x65, 0x6e, 0x67,
+0x65, 0x72, 0x5f, 0x73, 0x68, 0x69, 0x70, 0x3a, 0x70, 0x61, 0x73, 0x73,
+0x65, 0x6e, 0x67, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0xd83d, 0xdef3, 0x3a,
+0x63, 0x72, 0x75, 0x69, 0x73, 0x65, 0x5f, 0x73, 0x68, 0x69, 0x70, 0x3a,
+0x63, 0x72, 0x75, 0x69, 0x73, 0x65, 0x73, 0x68, 0x69, 0x70, 0x26f4, 0x3a,
+0x66, 0x65, 0x72, 0x72, 0x79, 0x3a, 0x66, 0x65, 0x72, 0x72, 0x79, 0xd83d,
+0xdea2, 0x3a, 0x73, 0x68, 0x69, 0x70, 0x3a, 0x73, 0x68, 0x69, 0x70, 0x2693,
+0xfe0f, 0x3a, 0x61, 0x6e, 0x63, 0x68, 0x6f, 0x72, 0x3a, 0x61, 0x6e, 0x63,
+0x68, 0x6f, 0x72, 0xd83d, 0xdea7, 0x3a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
+0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x63, 0x6f, 0x6e, 0x73, 0x74,
+0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x26fd, 0xfe0f, 0x3a, 0x66, 0x75,
+0x65, 0x6c, 0x70, 0x75, 0x6d, 0x70, 0x3a, 0x66, 0x75, 0x65, 0x6c, 0x70,
+0x75, 0x6d, 0x70, 0xd83d, 0xde8f, 0x3a, 0x62, 0x75, 0x73, 0x73, 0x74, 0x6f,
+0x70, 0x3a, 0x62, 0x75, 0x73, 0x73, 0x74, 0x6f, 0x70, 0xd83d, 0xdea6, 0x3a,
+0x76, 0x65, 0x72, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x74, 0x72, 0x61,
+0x66, 0x66, 0x69, 0x63, 0x5f, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x6c,
+0x69, 0x67, 0x68, 0x74, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x76,
+0x65, 0x72, 0x74, 0x69, 0x63, 0x61, 0x6c, 0xd83d, 0xdea5, 0x3a, 0x74, 0x72,
+0x61, 0x66, 0x66, 0x69, 0x63, 0x5f, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x3a,
+0x6c, 0x69, 0x67, 0x68, 0x74, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63,
+0xd83d, 0xddfa, 0x3a, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x5f, 0x6d, 0x61, 0x70,
+0x3a, 0x6d, 0x61, 0x70, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0xd83d, 0xddfa, 0x3a,
+0x6d, 0x61, 0x70, 0x3a, 0x6d, 0x61, 0x70, 0xd83d, 0xddff, 0x3a, 0x6d, 0x6f,
+0x79, 0x61, 0x69, 0x3a, 0x6d, 0x6f, 0x79, 0x61, 0x69, 0xd83d, 0xddfd, 0x3a,
+0x73, 0x74, 0x61, 0x74, 0x75, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x6c, 0x69,
+0x62, 0x65, 0x72, 0x74, 0x79, 0x3a, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x74,
+0x79, 0x6f, 0x66, 0x73, 0x74, 0x61, 0x74, 0x75, 0x65, 0x26f2, 0xfe0f, 0x3a,
+0x66, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x3a, 0x66, 0x6f, 0x75,
+0x6e, 0x74, 0x61, 0x69, 0x6e, 0xd83d, 0xddfc, 0x3a, 0x74, 0x6f, 0x6b, 0x79,
+0x6f, 0x5f, 0x74, 0x6f, 0x77, 0x65, 0x72, 0x3a, 0x74, 0x6f, 0x6b, 0x79,
+0x6f, 0x74, 0x6f, 0x77, 0x65, 0x72, 0xd83c, 0xdff0, 0x3a, 0x65, 0x75, 0x72,
+0x6f, 0x70, 0x65, 0x61, 0x6e, 0x5f, 0x63, 0x61, 0x73, 0x74, 0x6c, 0x65,
+0x3a, 0x63, 0x61, 0x73, 0x74, 0x6c, 0x65, 0x65, 0x75, 0x72, 0x6f, 0x70,
+0x65, 0x61, 0x6e, 0xd83c, 0xdfef, 0x3a, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65,
+0x73, 0x65, 0x5f, 0x63, 0x61, 0x73, 0x74, 0x6c, 0x65, 0x3a, 0x63, 0x61,
+0x73, 0x74, 0x6c, 0x65, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73, 0x65,
+0xd83c, 0xdfdf, 0x3a, 0x73, 0x74, 0x61, 0x64, 0x69, 0x75, 0x6d, 0x3a, 0x73,
+0x74, 0x61, 0x64, 0x69, 0x75, 0x6d, 0xd83c, 0xdfa1, 0x3a, 0x66, 0x65, 0x72,
+0x72, 0x69, 0x73, 0x5f, 0x77, 0x68, 0x65, 0x65, 0x6c, 0x3a, 0x66, 0x65,
+0x72, 0x72, 0x69, 0x73, 0x77, 0x68, 0x65, 0x65, 0x6c, 0xd83c, 0xdfa2, 0x3a,
+0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x61, 0x73, 0x74,
+0x65, 0x72, 0x3a, 0x63, 0x6f, 0x61, 0x73, 0x74, 0x65, 0x72, 0x72, 0x6f,
+0x6c, 0x6c, 0x65, 0x72, 0xd83c, 0xdfa0, 0x3a, 0x63, 0x61, 0x72, 0x6f, 0x75,
+0x73, 0x65, 0x6c, 0x5f, 0x68, 0x6f, 0x72, 0x73, 0x65, 0x3a, 0x63, 0x61,
+0x72, 0x6f, 0x75, 0x73, 0x65, 0x6c, 0x68, 0x6f, 0x72, 0x73, 0x65, 0x26f1,
+0x3a, 0x75, 0x6d, 0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0x5f, 0x6f, 0x6e,
+0x5f, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x3a, 0x67, 0x72, 0x6f, 0x75,
+0x6e, 0x64, 0x6f, 0x6e, 0x75, 0x6d, 0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61,
+0x26f1, 0x3a, 0x62, 0x65, 0x61, 0x63, 0x68, 0x5f, 0x75, 0x6d, 0x62, 0x72,
+0x65, 0x6c, 0x6c, 0x61, 0x3a, 0x62, 0x65, 0x61, 0x63, 0x68, 0x75, 0x6d,
+0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0xd83c, 0xdfd6, 0x3a, 0x62, 0x65, 0x61,
+0x63, 0x68, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x75, 0x6d, 0x62, 0x72,
+0x65, 0x6c, 0x6c, 0x61, 0x3a, 0x62, 0x65, 0x61, 0x63, 0x68, 0x75, 0x6d,
+0x62, 0x72, 0x65, 0x6c, 0x6c, 0x61, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdfd6,
+0x3a, 0x62, 0x65, 0x61, 0x63, 0x68, 0x3a, 0x62, 0x65, 0x61, 0x63, 0x68,
+0xd83c, 0xdfdd, 0x3a, 0x64, 0x65, 0x73, 0x65, 0x72, 0x74, 0x5f, 0x69, 0x73,
+0x6c, 0x61, 0x6e, 0x64, 0x3a, 0x64, 0x65, 0x73, 0x65, 0x72, 0x74, 0x69,
+0x73, 0x6c, 0x61, 0x6e, 0x64, 0xd83c, 0xdfdd, 0x3a, 0x69, 0x73, 0x6c, 0x61,
+0x6e, 0x64, 0x3a, 0x69, 0x73, 0x6c, 0x61, 0x6e, 0x64, 0x26f0, 0x3a, 0x6d,
+0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x3a, 0x6d, 0x6f, 0x75, 0x6e,
+0x74, 0x61, 0x69, 0x6e, 0xd83c, 0xdfd4, 0x3a, 0x73, 0x6e, 0x6f, 0x77, 0x5f,
+0x63, 0x61, 0x70, 0x70, 0x65, 0x64, 0x5f, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
+0x61, 0x69, 0x6e, 0x3a, 0x63, 0x61, 0x70, 0x70, 0x65, 0x64, 0x6d, 0x6f,
+0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x6e, 0x6f, 0x77, 0xd83c, 0xdfd4,
+0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x73, 0x6e,
+0x6f, 0x77, 0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73,
+0x6e, 0x6f, 0x77, 0xd83d, 0xddfb, 0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f,
+0x66, 0x75, 0x6a, 0x69, 0x3a, 0x66, 0x75, 0x6a, 0x69, 0x6d, 0x6f, 0x75,
+0x6e, 0x74, 0xd83c, 0xdf0b, 0x3a, 0x76, 0x6f, 0x6c, 0x63, 0x61, 0x6e, 0x6f,
+0x3a, 0x76, 0x6f, 0x6c, 0x63, 0x61, 0x6e, 0x6f, 0xd83c, 0xdfdc, 0x3a, 0x64,
+0x65, 0x73, 0x65, 0x72, 0x74, 0x3a, 0x64, 0x65, 0x73, 0x65, 0x72, 0x74,
+0xd83c, 0xdfd5, 0x3a, 0x63, 0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x3a, 0x63,
+0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x26fa, 0xfe0f, 0x3a, 0x74, 0x65, 0x6e,
+0x74, 0x3a, 0x74, 0x65, 0x6e, 0x74, 0xd83d, 0xdee4, 0x3a, 0x72, 0x61, 0x69,
+0x6c, 0x72, 0x6f, 0x61, 0x64, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x3a,
+0x72, 0x61, 0x69, 0x6c, 0x72, 0x6f, 0x61, 0x64, 0x74, 0x72, 0x61, 0x63,
+0x6b, 0xd83d, 0xdee4, 0x3a, 0x72, 0x61, 0x69, 0x6c, 0x77, 0x61, 0x79, 0x5f,
+0x74, 0x72, 0x61, 0x63, 0x6b, 0x3a, 0x72, 0x61, 0x69, 0x6c, 0x77, 0x61,
+0x79, 0x74, 0x72, 0x61, 0x63, 0x6b, 0xd83d, 0xdee3, 0x3a, 0x6d, 0x6f, 0x74,
+0x6f, 0x72, 0x77, 0x61, 0x79, 0x3a, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x77,
+0x61, 0x79, 0xd83c, 0xdfd7, 0x3a, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e,
+0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69,
+0x6f, 0x6e, 0x3a, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x63,
+0x6f, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0xd83c,
+0xdfd7, 0x3a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69,
+0x6f, 0x6e, 0x5f, 0x73, 0x69, 0x74, 0x65, 0x3a, 0x63, 0x6f, 0x6e, 0x73,
+0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x69, 0x74, 0x65,
+0xd83c, 0xdfed, 0x3a, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x3a, 0x66,
+0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0xd83c, 0xdfe0, 0x3a, 0x68, 0x6f, 0x75,
+0x73, 0x65, 0x3a, 0x68, 0x6f, 0x75, 0x73, 0x65, 0xd83c, 0xdfe1, 0x3a, 0x68,
+0x6f, 0x75, 0x73, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x67, 0x61,
+0x72, 0x64, 0x65, 0x6e, 0x3a, 0x67, 0x61, 0x72, 0x64, 0x65, 0x6e, 0x68,
+0x6f, 0x75, 0x73, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdfd8, 0x3a, 0x68,
+0x6f, 0x75, 0x73, 0x65, 0x5f, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e,
+0x67, 0x73, 0x3a, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x73,
+0x68, 0x6f, 0x75, 0x73, 0x65, 0xd83c, 0xdfd8, 0x3a, 0x68, 0x6f, 0x6d, 0x65,
+0x73, 0x3a, 0x68, 0x6f, 0x6d, 0x65, 0x73, 0xd83c, 0xdfda, 0x3a, 0x64, 0x65,
+0x72, 0x65, 0x6c, 0x69, 0x63, 0x74, 0x5f, 0x68, 0x6f, 0x75, 0x73, 0x65,
+0x5f, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x75,
+0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x64, 0x65, 0x72, 0x65, 0x6c, 0x69,
+0x63, 0x74, 0x68, 0x6f, 0x75, 0x73, 0x65, 0xd83c, 0xdfda, 0x3a, 0x68, 0x6f,
+0x75, 0x73, 0x65, 0x5f, 0x61, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x65,
+0x64, 0x3a, 0x61, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x64, 0x68,
+0x6f, 0x75, 0x73, 0x65, 0xd83c, 0xdfe2, 0x3a, 0x6f, 0x66, 0x66, 0x69, 0x63,
+0x65, 0x3a, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0xd83c, 0xdfec, 0x3a, 0x64,
+0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74,
+0x6f, 0x72, 0x65, 0x3a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65,
+0x6e, 0x74, 0x73, 0x74, 0x6f, 0x72, 0x65, 0xd83c, 0xdfe3, 0x3a, 0x70, 0x6f,
+0x73, 0x74, 0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x3a, 0x6f, 0x66,
+0x66, 0x69, 0x63, 0x65, 0x70, 0x6f, 0x73, 0x74, 0xd83c, 0xdfe4, 0x3a, 0x65,
+0x75, 0x72, 0x6f, 0x70, 0x65, 0x61, 0x6e, 0x5f, 0x70, 0x6f, 0x73, 0x74,
+0x5f, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x3a, 0x65, 0x75, 0x72, 0x6f,
+0x70, 0x65, 0x61, 0x6e, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x70, 0x6f,
+0x73, 0x74, 0xd83c, 0xdfe5, 0x3a, 0x68, 0x6f, 0x73, 0x70, 0x69, 0x74, 0x61,
+0x6c, 0x3a, 0x68, 0x6f, 0x73, 0x70, 0x69, 0x74, 0x61, 0x6c, 0xd83c, 0xdfe6,
+0x3a, 0x62, 0x61, 0x6e, 0x6b, 0x3a, 0x62, 0x61, 0x6e, 0x6b, 0xd83c, 0xdfe8,
+0x3a, 0x68, 0x6f, 0x74, 0x65, 0x6c, 0x3a, 0x68, 0x6f, 0x74, 0x65, 0x6c,
+0xd83c, 0xdfea, 0x3a, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x6e, 0x69, 0x65, 0x6e,
+0x63, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x3a, 0x63, 0x6f, 0x6e,
+0x76, 0x65, 0x6e, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72,
+0x65, 0xd83c, 0xdfeb, 0x3a, 0x73, 0x63, 0x68, 0x6f, 0x6f, 0x6c, 0x3a, 0x73,
+0x63, 0x68, 0x6f, 0x6f, 0x6c, 0xd83c, 0xdfe9, 0x3a, 0x6c, 0x6f, 0x76, 0x65,
+0x5f, 0x68, 0x6f, 0x74, 0x65, 0x6c, 0x3a, 0x68, 0x6f, 0x74, 0x65, 0x6c,
+0x6c, 0x6f, 0x76, 0x65, 0xd83d, 0xdc92, 0x3a, 0x77, 0x65, 0x64, 0x64, 0x69,
+0x6e, 0x67, 0x3a, 0x77, 0x65, 0x64, 0x64, 0x69, 0x6e, 0x67, 0xd83c, 0xdfdb,
+0x3a, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x62,
+0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x3a, 0x62, 0x75, 0x69, 0x6c,
+0x64, 0x69, 0x6e, 0x67, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x63, 0x61,
+0x6c, 0x26ea, 0xfe0f, 0x3a, 0x63, 0x68, 0x75, 0x72, 0x63, 0x68, 0x3a, 0x63,
+0x68, 0x75, 0x72, 0x63, 0x68, 0xd83d, 0xdd4c, 0x3a, 0x6d, 0x6f, 0x73, 0x71,
+0x75, 0x65, 0x3a, 0x6d, 0x6f, 0x73, 0x71, 0x75, 0x65, 0xd83d, 0xdd4d, 0x3a,
+0x73, 0x79, 0x6e, 0x61, 0x67, 0x6f, 0x67, 0x75, 0x65, 0x3a, 0x73, 0x79,
+0x6e, 0x61, 0x67, 0x6f, 0x67, 0x75, 0x65, 0xd83d, 0xdd4b, 0x3a, 0x6b, 0x61,
+0x61, 0x62, 0x61, 0x3a, 0x6b, 0x61, 0x61, 0x62, 0x61, 0x26e9, 0x3a, 0x73,
+0x68, 0x69, 0x6e, 0x74, 0x6f, 0x5f, 0x73, 0x68, 0x72, 0x69, 0x6e, 0x65,
+0x3a, 0x73, 0x68, 0x69, 0x6e, 0x74, 0x6f, 0x73, 0x68, 0x72, 0x69, 0x6e,
+0x65, 0xd83d, 0xddfe, 0x3a, 0x6a, 0x61, 0x70, 0x61, 0x6e, 0x3a, 0x6a, 0x61,
+0x70, 0x61, 0x6e, 0xd83c, 0xdf91, 0x3a, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x73,
+0x63, 0x65, 0x6e, 0x65, 0x3a, 0x72, 0x69, 0x63, 0x65, 0x73, 0x63, 0x65,
+0x6e, 0x65, 0xd83c, 0xdfde, 0x3a, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61,
+0x6c, 0x5f, 0x70, 0x61, 0x72, 0x6b, 0x3a, 0x6e, 0x61, 0x74, 0x69, 0x6f,
+0x6e, 0x61, 0x6c, 0x70, 0x61, 0x72, 0x6b, 0xd83c, 0xdfde, 0x3a, 0x70, 0x61,
+0x72, 0x6b, 0x3a, 0x70, 0x61, 0x72, 0x6b, 0xd83c, 0xdf05, 0x3a, 0x73, 0x75,
+0x6e, 0x72, 0x69, 0x73, 0x65, 0x3a, 0x73, 0x75, 0x6e, 0x72, 0x69, 0x73,
+0x65, 0xd83c, 0xdf04, 0x3a, 0x73, 0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0x5f,
+0x6f, 0x76, 0x65, 0x72, 0x5f, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69,
+0x6e, 0x73, 0x3a, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73,
+0x6f, 0x76, 0x65, 0x72, 0x73, 0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0xd83c,
+0xdf20, 0x3a, 0x73, 0x74, 0x61, 0x72, 0x73, 0x3a, 0x73, 0x74, 0x61, 0x72,
+0x73, 0xd83c, 0xdf87, 0x3a, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x6c, 0x65, 0x72,
+0x3a, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x6c, 0x65, 0x72, 0xd83c, 0xdf86, 0x3a,
+0x66, 0x69, 0x72, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x3a, 0x66, 0x69,
+0x72, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0xd83c, 0xdf07, 0x3a, 0x63, 0x69,
+0x74, 0x79, 0x5f, 0x73, 0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0x3a, 0x63,
+0x69, 0x74, 0x79, 0x73, 0x75, 0x6e, 0x72, 0x69, 0x73, 0x65, 0xd83c, 0xdf07,
+0x3a, 0x63, 0x69, 0x74, 0x79, 0x5f, 0x73, 0x75, 0x6e, 0x73, 0x65, 0x74,
+0x3a, 0x63, 0x69, 0x74, 0x79, 0x73, 0x75, 0x6e, 0x73, 0x65, 0x74, 0xd83c,
+0xdf06, 0x3a, 0x63, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x75, 0x73, 0x6b, 0x3a,
+0x63, 0x69, 0x74, 0x79, 0x64, 0x75, 0x73, 0x6b, 0xd83c, 0xdfd9, 0x3a, 0x63,
+0x69, 0x74, 0x79, 0x73, 0x63, 0x61, 0x70, 0x65, 0x3a, 0x63, 0x69, 0x74,
+0x79, 0x73, 0x63, 0x61, 0x70, 0x65, 0xd83c, 0xdf03, 0x3a, 0x6e, 0x69, 0x67,
+0x68, 0x74, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x73, 0x74, 0x61, 0x72,
+0x73, 0x3a, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x73, 0x74, 0x61, 0x72, 0x73,
+0x77, 0x69, 0x74, 0x68, 0xd83c, 0xdf0c, 0x3a, 0x6d, 0x69, 0x6c, 0x6b, 0x79,
+0x5f, 0x77, 0x61, 0x79, 0x3a, 0x6d, 0x69, 0x6c, 0x6b, 0x79, 0x77, 0x61,
+0x79, 0xd83c, 0xdf09, 0x3a, 0x62, 0x72, 0x69, 0x64, 0x67, 0x65, 0x5f, 0x61,
+0x74, 0x5f, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x61, 0x74, 0x62, 0x72,
+0x69, 0x64, 0x67, 0x65, 0x6e, 0x69, 0x67, 0x68, 0x74, 0xd83c, 0xdf01, 0x3a,
+0x66, 0x6f, 0x67, 0x67, 0x79, 0x3a, 0x66, 0x6f, 0x67, 0x67, 0x79, 0x231a,
+0xfe0f, 0x3a, 0x77, 0x61, 0x74, 0x63, 0x68, 0x3a, 0x77, 0x61, 0x74, 0x63,
+0x68, 0xd83d, 0xdcf1, 0x3a, 0x69, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x3a, 0x69,
+0x70, 0x68, 0x6f, 0x6e, 0x65, 0xd83d, 0xdcf2, 0x3a, 0x63, 0x61, 0x6c, 0x6c,
+0x69, 0x6e, 0x67, 0x3a, 0x63, 0x61, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0xd83d,
+0xdcbb, 0x3a, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x3a, 0x63,
+0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x2328, 0xfe0f, 0x3a, 0x6b, 0x65,
+0x79, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x3a, 0x6b, 0x65, 0x79, 0x62, 0x6f,
+0x61, 0x72, 0x64, 0xd83d, 0xdda5, 0x3a, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f,
+0x70, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x3a, 0x63,
+0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x64, 0x65, 0x73, 0x6b, 0x74,
+0x6f, 0x70, 0xd83d, 0xdda5, 0x3a, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70,
+0x3a, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0xd83d, 0xdda8, 0x3a, 0x70,
+0x72, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x3a, 0x70, 0x72, 0x69, 0x6e, 0x74,
+0x65, 0x72, 0xd83d, 0xddb1, 0x3a, 0x74, 0x68, 0x72, 0x65, 0x65, 0x5f, 0x62,
+0x75, 0x74, 0x74, 0x6f, 0x6e, 0x5f, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x3a,
+0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x74,
+0x68, 0x72, 0x65, 0x65, 0xd83d, 0xddb1, 0x3a, 0x6d, 0x6f, 0x75, 0x73, 0x65,
+0x5f, 0x74, 0x68, 0x72, 0x65, 0x65, 0x5f, 0x62, 0x75, 0x74, 0x74, 0x6f,
+0x6e, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x6d, 0x6f, 0x75, 0x73,
+0x65, 0x74, 0x68, 0x72, 0x65, 0x65, 0xd83d, 0xddb2, 0x3a, 0x74, 0x72, 0x61,
+0x63, 0x6b, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x74, 0x72, 0x61, 0x63, 0x6b,
+0x62, 0x61, 0x6c, 0x6c, 0xd83d, 0xdd79, 0x3a, 0x6a, 0x6f, 0x79, 0x73, 0x74,
+0x69, 0x63, 0x6b, 0x3a, 0x6a, 0x6f, 0x79, 0x73, 0x74, 0x69, 0x63, 0x6b,
+0xd83d, 0xdddc, 0x3a, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
+0x6f, 0x6e, 0x3a, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
+0x6f, 0x6e, 0xd83d, 0xdcbd, 0x3a, 0x6d, 0x69, 0x6e, 0x69, 0x64, 0x69, 0x73,
+0x63, 0x3a, 0x6d, 0x69, 0x6e, 0x69, 0x64, 0x69, 0x73, 0x63, 0xd83d, 0xdcbe,
+0x3a, 0x66, 0x6c, 0x6f, 0x70, 0x70, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b,
+0x3a, 0x64, 0x69, 0x73, 0x6b, 0x66, 0x6c, 0x6f, 0x70, 0x70, 0x79, 0xd83d,
+0xdcbf, 0x3a, 0x63, 0x64, 0x3a, 0x63, 0x64, 0xd83d, 0xdcc0, 0x3a, 0x64, 0x76,
+0x64, 0x3a, 0x64, 0x76, 0x64, 0xd83d, 0xdcfc, 0x3a, 0x76, 0x68, 0x73, 0x3a,
+0x76, 0x68, 0x73, 0xd83d, 0xdcf7, 0x3a, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61,
+0x3a, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0xd83d, 0xdcf8, 0x3a, 0x63, 0x61,
+0x6d, 0x65, 0x72, 0x61, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x66, 0x6c,
+0x61, 0x73, 0x68, 0x3a, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x66, 0x6c,
+0x61, 0x73, 0x68, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdcf9, 0x3a, 0x76, 0x69,
+0x64, 0x65, 0x6f, 0x5f, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x3a, 0x63,
+0x61, 0x6d, 0x65, 0x72, 0x61, 0x76, 0x69, 0x64, 0x65, 0x6f, 0xd83c, 0xdfa5,
+0x3a, 0x6d, 0x6f, 0x76, 0x69, 0x65, 0x5f, 0x63, 0x61, 0x6d, 0x65, 0x72,
+0x61, 0x3a, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x6d, 0x6f, 0x76, 0x69,
+0x65, 0xd83d, 0xdcfd, 0x3a, 0x66, 0x69, 0x6c, 0x6d, 0x5f, 0x70, 0x72, 0x6f,
+0x6a, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x3a, 0x66, 0x69, 0x6c, 0x6d, 0x70,
+0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x6f, 0x72, 0xd83d, 0xdcfd, 0x3a, 0x70,
+0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x3a, 0x70, 0x72, 0x6f,
+0x6a, 0x65, 0x63, 0x74, 0x6f, 0x72, 0xd83c, 0xdf9e, 0x3a, 0x66, 0x69, 0x6c,
+0x6d, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x3a, 0x66, 0x69, 0x6c,
+0x6d, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0xd83d, 0xdcde, 0x3a, 0x74, 0x65,
+0x6c, 0x65, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x65,
+0x69, 0x76, 0x65, 0x72, 0x3a, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
+0x72, 0x74, 0x65, 0x6c, 0x65, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x260e, 0xfe0f,
+0x3a, 0x74, 0x65, 0x6c, 0x65, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x3a, 0x74,
+0x65, 0x6c, 0x65, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0xd83d, 0xdcdf, 0x3a, 0x70,
+0x61, 0x67, 0x65, 0x72, 0x3a, 0x70, 0x61, 0x67, 0x65, 0x72, 0xd83d, 0xdce0,
+0x3a, 0x66, 0x61, 0x78, 0x3a, 0x66, 0x61, 0x78, 0xd83d, 0xdcfa, 0x3a, 0x74,
+0x76, 0x3a, 0x74, 0x76, 0xd83d, 0xdcfb, 0x3a, 0x72, 0x61, 0x64, 0x69, 0x6f,
+0x3a, 0x72, 0x61, 0x64, 0x69, 0x6f, 0xd83c, 0xdf99, 0x3a, 0x73, 0x74, 0x75,
+0x64, 0x69, 0x6f, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f,
+0x6e, 0x65, 0x3a, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f, 0x6e,
+0x65, 0x73, 0x74, 0x75, 0x64, 0x69, 0x6f, 0xd83c, 0xdf99, 0x3a, 0x6d, 0x69,
+0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x32, 0x3a, 0x6d, 0x69,
+0x63, 0x72, 0x6f, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x32, 0xd83c, 0xdf9a, 0x3a,
+0x6c, 0x65, 0x76, 0x65, 0x6c, 0x5f, 0x73, 0x6c, 0x69, 0x64, 0x65, 0x72,
+0x3a, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x73, 0x6c, 0x69, 0x64, 0x65, 0x72,
+0xd83c, 0xdf9b, 0x3a, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x6b,
+0x6e, 0x6f, 0x62, 0x73, 0x3a, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
+0x6b, 0x6e, 0x6f, 0x62, 0x73, 0x23f1, 0x3a, 0x73, 0x74, 0x6f, 0x70, 0x77,
+0x61, 0x74, 0x63, 0x68, 0x3a, 0x73, 0x74, 0x6f, 0x70, 0x77, 0x61, 0x74,
+0x63, 0x68, 0x23f2, 0x3a, 0x74, 0x69, 0x6d, 0x65, 0x72, 0x5f, 0x63, 0x6c,
+0x6f, 0x63, 0x6b, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x74, 0x69, 0x6d,
+0x65, 0x72, 0x23f2, 0x3a, 0x74, 0x69, 0x6d, 0x65, 0x72, 0x3a, 0x74, 0x69,
+0x6d, 0x65, 0x72, 0x23f0, 0x3a, 0x61, 0x6c, 0x61, 0x72, 0x6d, 0x5f, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x3a, 0x61, 0x6c, 0x61, 0x72, 0x6d, 0x63, 0x6c,
+0x6f, 0x63, 0x6b, 0xd83d, 0xdd70, 0x3a, 0x6d, 0x61, 0x6e, 0x74, 0x6c, 0x65,
+0x70, 0x69, 0x65, 0x63, 0x65, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x6d, 0x61, 0x6e, 0x74, 0x6c, 0x65, 0x70,
+0x69, 0x65, 0x63, 0x65, 0xd83d, 0xdd70, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x231b, 0xfe0f, 0x3a, 0x68, 0x6f, 0x75,
+0x72, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x3a, 0x68, 0x6f, 0x75, 0x72, 0x67,
+0x6c, 0x61, 0x73, 0x73, 0x23f3, 0x3a, 0x68, 0x6f, 0x75, 0x72, 0x67, 0x6c,
+0x61, 0x73, 0x73, 0x5f, 0x66, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x5f,
+0x73, 0x61, 0x6e, 0x64, 0x3a, 0x66, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67,
+0x68, 0x6f, 0x75, 0x72, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x73, 0x61, 0x6e,
+0x64, 0xd83d, 0xdce1, 0x3a, 0x73, 0x61, 0x74, 0x65, 0x6c, 0x6c, 0x69, 0x74,
+0x65, 0x3a, 0x73, 0x61, 0x74, 0x65, 0x6c, 0x6c, 0x69, 0x74, 0x65, 0xd83d,
+0xdd0b, 0x3a, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x3a, 0x62, 0x61,
+0x74, 0x74, 0x65, 0x72, 0x79, 0xd83d, 0xdd0c, 0x3a, 0x65, 0x6c, 0x65, 0x63,
+0x74, 0x72, 0x69, 0x63, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x3a, 0x65, 0x6c,
+0x65, 0x63, 0x74, 0x72, 0x69, 0x63, 0x70, 0x6c, 0x75, 0x67, 0xd83d, 0xdca1,
+0x3a, 0x62, 0x75, 0x6c, 0x62, 0x3a, 0x62, 0x75, 0x6c, 0x62, 0xd83d, 0xdd26,
+0x3a, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x3a,
+0x66, 0x6c, 0x61, 0x73, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74, 0xd83d, 0xdd6f,
+0x3a, 0x63, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x3a, 0x63, 0x61, 0x6e, 0x64,
+0x6c, 0x65, 0xd83d, 0xddd1, 0x3a, 0x77, 0x61, 0x73, 0x74, 0x65, 0x62, 0x61,
+0x73, 0x6b, 0x65, 0x74, 0x3a, 0x77, 0x61, 0x73, 0x74, 0x65, 0x62, 0x61,
+0x73, 0x6b, 0x65, 0x74, 0xd83d, 0xdee2, 0x3a, 0x6f, 0x69, 0x6c, 0x5f, 0x64,
+0x72, 0x75, 0x6d, 0x3a, 0x64, 0x72, 0x75, 0x6d, 0x6f, 0x69, 0x6c, 0xd83d,
+0xdee2, 0x3a, 0x6f, 0x69, 0x6c, 0x3a, 0x6f, 0x69, 0x6c, 0xd83d, 0xdcb8, 0x3a,
+0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x77,
+0x69, 0x6e, 0x67, 0x73, 0x3a, 0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x77, 0x69,
+0x6e, 0x67, 0x73, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdcb5, 0x3a, 0x64, 0x6f,
+0x6c, 0x6c, 0x61, 0x72, 0x3a, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0xd83d,
+0xdcb4, 0x3a, 0x79, 0x65, 0x6e, 0x3a, 0x79, 0x65, 0x6e, 0xd83d, 0xdcb6, 0x3a,
+0x65, 0x75, 0x72, 0x6f, 0x3a, 0x65, 0x75, 0x72, 0x6f, 0xd83d, 0xdcb7, 0x3a,
+0x70, 0x6f, 0x75, 0x6e, 0x64, 0x3a, 0x70, 0x6f, 0x75, 0x6e, 0x64, 0xd83d,
+0xdcb0, 0x3a, 0x6d, 0x6f, 0x6e, 0x65, 0x79, 0x62, 0x61, 0x67, 0x3a, 0x6d,
+0x6f, 0x6e, 0x65, 0x79, 0x62, 0x61, 0x67, 0xd83d, 0xdcb3, 0x3a, 0x63, 0x72,
+0x65, 0x64, 0x69, 0x74, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x3a, 0x63, 0x61,
+0x72, 0x64, 0x63, 0x72, 0x65, 0x64, 0x69, 0x74, 0xd83d, 0xdc8e, 0x3a, 0x67,
+0x65, 0x6d, 0x3a, 0x67, 0x65, 0x6d, 0x2696, 0xfe0f, 0x3a, 0x73, 0x63, 0x61,
+0x6c, 0x65, 0x73, 0x3a, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x73, 0xd83d, 0xdd27,
+0x3a, 0x77, 0x72, 0x65, 0x6e, 0x63, 0x68, 0x3a, 0x77, 0x72, 0x65, 0x6e,
+0x63, 0x68, 0xd83d, 0xdd28, 0x3a, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x3a,
+0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x2692, 0x3a, 0x68, 0x61, 0x6d, 0x6d,
+0x65, 0x72, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x70, 0x69, 0x63, 0x6b, 0x3a,
+0x61, 0x6e, 0x64, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x70, 0x69, 0x63,
+0x6b, 0x2692, 0x3a, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x5f, 0x70, 0x69,
+0x63, 0x6b, 0x3a, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x70, 0x69, 0x63,
+0x6b, 0xd83d, 0xdee0, 0x3a, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x5f, 0x61,
+0x6e, 0x64, 0x5f, 0x77, 0x72, 0x65, 0x6e, 0x63, 0x68, 0x3a, 0x61, 0x6e,
+0x64, 0x68, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x77, 0x72, 0x65, 0x6e, 0x63,
+0x68, 0xd83d, 0xdee0, 0x3a, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x3a, 0x74, 0x6f,
+0x6f, 0x6c, 0x73, 0x26cf, 0x3a, 0x70, 0x69, 0x63, 0x6b, 0x3a, 0x70, 0x69,
+0x63, 0x6b, 0xd83d, 0xdd29, 0x3a, 0x6e, 0x75, 0x74, 0x5f, 0x61, 0x6e, 0x64,
+0x5f, 0x62, 0x6f, 0x6c, 0x74, 0x3a, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x6c,
+0x74, 0x6e, 0x75, 0x74, 0x2699, 0xfe0f, 0x3a, 0x67, 0x65, 0x61, 0x72, 0x3a,
+0x67, 0x65, 0x61, 0x72, 0x26d3, 0x3a, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x73,
+0x3a, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x73, 0xd83d, 0xdd2b, 0x3a, 0x67, 0x75,
+0x6e, 0x3a, 0x67, 0x75, 0x6e, 0xd83d, 0xdca3, 0x3a, 0x62, 0x6f, 0x6d, 0x62,
+0x3a, 0x62, 0x6f, 0x6d, 0x62, 0xd83d, 0xdd2a, 0x3a, 0x6b, 0x6e, 0x69, 0x66,
+0x65, 0x3a, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0xd83d, 0xdde1, 0x3a, 0x64, 0x61,
+0x67, 0x67, 0x65, 0x72, 0x5f, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0x3a, 0x64,
+0x61, 0x67, 0x67, 0x65, 0x72, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0xd83d, 0xdde1,
+0x3a, 0x64, 0x61, 0x67, 0x67, 0x65, 0x72, 0x3a, 0x64, 0x61, 0x67, 0x67,
+0x65, 0x72, 0x2694, 0xfe0f, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64,
+0x5f, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73,
+0x73, 0x65, 0x64, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x73, 0xd83d, 0xdee1, 0x3a,
+0x73, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x3a, 0x73, 0x68, 0x69, 0x65, 0x6c,
+0x64, 0xd83d, 0xdeac, 0x3a, 0x73, 0x6d, 0x6f, 0x6b, 0x69, 0x6e, 0x67, 0x3a,
+0x73, 0x6d, 0x6f, 0x6b, 0x69, 0x6e, 0x67, 0x26b0, 0xfe0f, 0x3a, 0x63, 0x6f,
+0x66, 0x66, 0x69, 0x6e, 0x3a, 0x63, 0x6f, 0x66, 0x66, 0x69, 0x6e, 0x26b1,
+0xfe0f, 0x3a, 0x66, 0x75, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x5f, 0x75, 0x72,
+0x6e, 0x3a, 0x66, 0x75, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x75, 0x72, 0x6e,
+0x26b1, 0xfe0f, 0x3a, 0x75, 0x72, 0x6e, 0x3a, 0x75, 0x72, 0x6e, 0xd83c, 0xdffa,
+0x3a, 0x61, 0x6d, 0x70, 0x68, 0x6f, 0x72, 0x61, 0x3a, 0x61, 0x6d, 0x70,
+0x68, 0x6f, 0x72, 0x61, 0xd83d, 0xdd2e, 0x3a, 0x63, 0x72, 0x79, 0x73, 0x74,
+0x61, 0x6c, 0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c,
+0x63, 0x72, 0x79, 0x73, 0x74, 0x61, 0x6c, 0xd83d, 0xdcff, 0x3a, 0x70, 0x72,
+0x61, 0x79, 0x65, 0x72, 0x5f, 0x62, 0x65, 0x61, 0x64, 0x73, 0x3a, 0x62,
+0x65, 0x61, 0x64, 0x73, 0x70, 0x72, 0x61, 0x79, 0x65, 0x72, 0xd83d, 0xdc88,
+0x3a, 0x62, 0x61, 0x72, 0x62, 0x65, 0x72, 0x3a, 0x62, 0x61, 0x72, 0x62,
+0x65, 0x72, 0x2697, 0xfe0f, 0x3a, 0x61, 0x6c, 0x65, 0x6d, 0x62, 0x69, 0x63,
+0x3a, 0x61, 0x6c, 0x65, 0x6d, 0x62, 0x69, 0x63, 0xd83d, 0xdd2d, 0x3a, 0x74,
+0x65, 0x6c, 0x65, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x3a, 0x74, 0x65, 0x6c,
+0x65, 0x73, 0x63, 0x6f, 0x70, 0x65, 0xd83d, 0xdd2c, 0x3a, 0x6d, 0x69, 0x63,
+0x72, 0x6f, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x3a, 0x6d, 0x69, 0x63, 0x72,
+0x6f, 0x73, 0x63, 0x6f, 0x70, 0x65, 0xd83d, 0xdd73, 0x3a, 0x68, 0x6f, 0x6c,
+0x65, 0x3a, 0x68, 0x6f, 0x6c, 0x65, 0xd83d, 0xdc8a, 0x3a, 0x70, 0x69, 0x6c,
+0x6c, 0x3a, 0x70, 0x69, 0x6c, 0x6c, 0xd83d, 0xdc89, 0x3a, 0x73, 0x79, 0x72,
+0x69, 0x6e, 0x67, 0x65, 0x3a, 0x73, 0x79, 0x72, 0x69, 0x6e, 0x67, 0x65,
+0xd83c, 0xdf21, 0x3a, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x6f, 0x6d, 0x65, 0x74,
+0x65, 0x72, 0x3a, 0x74, 0x68, 0x65, 0x72, 0x6d, 0x6f, 0x6d, 0x65, 0x74,
+0x65, 0x72, 0xd83d, 0xdebd, 0x3a, 0x74, 0x6f, 0x69, 0x6c, 0x65, 0x74, 0x3a,
+0x74, 0x6f, 0x69, 0x6c, 0x65, 0x74, 0xd83d, 0xdeb0, 0x3a, 0x70, 0x6f, 0x74,
+0x61, 0x62, 0x6c, 0x65, 0x5f, 0x77, 0x61, 0x74, 0x65, 0x72, 0x3a, 0x70,
+0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x77, 0x61, 0x74, 0x65, 0x72, 0xd83d,
+0xdebf, 0x3a, 0x73, 0x68, 0x6f, 0x77, 0x65, 0x72, 0x3a, 0x73, 0x68, 0x6f,
+0x77, 0x65, 0x72, 0xd83d, 0xdec1, 0x3a, 0x62, 0x61, 0x74, 0x68, 0x74, 0x75,
+0x62, 0x3a, 0x62, 0x61, 0x74, 0x68, 0x74, 0x75, 0x62, 0xd83d, 0xdec0, 0x3a,
+0x62, 0x61, 0x74, 0x68, 0x3a, 0x62, 0x61, 0x74, 0x68, 0xd83d, 0xdece, 0x3a,
+0x62, 0x65, 0x6c, 0x6c, 0x68, 0x6f, 0x70, 0x5f, 0x62, 0x65, 0x6c, 0x6c,
+0x3a, 0x62, 0x65, 0x6c, 0x6c, 0x62, 0x65, 0x6c, 0x6c, 0x68, 0x6f, 0x70,
+0xd83d, 0xdece, 0x3a, 0x62, 0x65, 0x6c, 0x6c, 0x68, 0x6f, 0x70, 0x3a, 0x62,
+0x65, 0x6c, 0x6c, 0x68, 0x6f, 0x70, 0xd83d, 0xdd11, 0x3a, 0x6b, 0x65, 0x79,
+0x3a, 0x6b, 0x65, 0x79, 0xd83d, 0xdddd, 0x3a, 0x6f, 0x6c, 0x64, 0x5f, 0x6b,
+0x65, 0x79, 0x3a, 0x6b, 0x65, 0x79, 0x6f, 0x6c, 0x64, 0xd83d, 0xdddd, 0x3a,
+0x6b, 0x65, 0x79, 0x32, 0x3a, 0x6b, 0x65, 0x79, 0x32, 0xd83d, 0xdeaa, 0x3a,
+0x64, 0x6f, 0x6f, 0x72, 0x3a, 0x64, 0x6f, 0x6f, 0x72, 0xd83d, 0xdecb, 0x3a,
+0x63, 0x6f, 0x75, 0x63, 0x68, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x61,
+0x6d, 0x70, 0x3a, 0x61, 0x6e, 0x64, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x6c,
+0x61, 0x6d, 0x70, 0xd83d, 0xdecb, 0x3a, 0x63, 0x6f, 0x75, 0x63, 0x68, 0x3a,
+0x63, 0x6f, 0x75, 0x63, 0x68, 0xd83d, 0xdecf, 0x3a, 0x62, 0x65, 0x64, 0x3a,
+0x62, 0x65, 0x64, 0xd83d, 0xdecc, 0x3a, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x69,
+0x6e, 0x67, 0x5f, 0x61, 0x63, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x64, 0x61,
+0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x61, 0x63, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
+0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x69,
+0x6e, 0x67, 0xd83d, 0xddbc, 0x3a, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x70, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x3a,
+0x66, 0x72, 0x61, 0x6d, 0x65, 0x70, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65,
+0x77, 0x69, 0x74, 0x68, 0xd83d, 0xddbc, 0x3a, 0x66, 0x72, 0x61, 0x6d, 0x65,
+0x5f, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x3a, 0x66, 0x72, 0x61, 0x6d, 0x65,
+0x70, 0x68, 0x6f, 0x74, 0x6f, 0xd83d, 0xdecd, 0x3a, 0x73, 0x68, 0x6f, 0x70,
+0x70, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x61, 0x67, 0x73, 0x3a, 0x62, 0x61,
+0x67, 0x73, 0x73, 0x68, 0x6f, 0x70, 0x70, 0x69, 0x6e, 0x67, 0xd83d, 0xded2,
+0x3a, 0x73, 0x68, 0x6f, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x72,
+0x6f, 0x6c, 0x6c, 0x65, 0x79, 0x3a, 0x73, 0x68, 0x6f, 0x70, 0x70, 0x69,
+0x6e, 0x67, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x79, 0xd83d, 0xded2, 0x3a,
+0x73, 0x68, 0x6f, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x61, 0x72,
+0x74, 0x3a, 0x63, 0x61, 0x72, 0x74, 0x73, 0x68, 0x6f, 0x70, 0x70, 0x69,
+0x6e, 0x67, 0xd83c, 0xdf81, 0x3a, 0x67, 0x69, 0x66, 0x74, 0x3a, 0x67, 0x69,
+0x66, 0x74, 0xd83c, 0xdf88, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x6f, 0x6e,
+0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x6f, 0x6e, 0xd83c, 0xdf8f, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0xd83c, 0xdf80,
+0x3a, 0x72, 0x69, 0x62, 0x62, 0x6f, 0x6e, 0x3a, 0x72, 0x69, 0x62, 0x62,
+0x6f, 0x6e, 0xd83c, 0xdf8a, 0x3a, 0x63, 0x6f, 0x6e, 0x66, 0x65, 0x74, 0x74,
+0x69, 0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x63,
+0x6f, 0x6e, 0x66, 0x65, 0x74, 0x74, 0x69, 0xd83c, 0xdf89, 0x3a, 0x74, 0x61,
+0x64, 0x61, 0x3a, 0x74, 0x61, 0x64, 0x61, 0xd83c, 0xdf8e, 0x3a, 0x64, 0x6f,
+0x6c, 0x6c, 0x73, 0x3a, 0x64, 0x6f, 0x6c, 0x6c, 0x73, 0xd83c, 0xdfee, 0x3a,
+0x69, 0x7a, 0x61, 0x6b, 0x61, 0x79, 0x61, 0x5f, 0x6c, 0x61, 0x6e, 0x74,
+0x65, 0x72, 0x6e, 0x3a, 0x69, 0x7a, 0x61, 0x6b, 0x61, 0x79, 0x61, 0x6c,
+0x61, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0xd83c, 0xdf90, 0x3a, 0x77, 0x69, 0x6e,
+0x64, 0x5f, 0x63, 0x68, 0x69, 0x6d, 0x65, 0x3a, 0x63, 0x68, 0x69, 0x6d,
+0x65, 0x77, 0x69, 0x6e, 0x64, 0x2709, 0xfe0f, 0x3a, 0x65, 0x6e, 0x76, 0x65,
+0x6c, 0x6f, 0x70, 0x65, 0x3a, 0x65, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70,
+0x65, 0xd83d, 0xdce9, 0x3a, 0x65, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x3a,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70,
+0x65, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdce8, 0x3a, 0x69, 0x6e, 0x63, 0x6f,
+0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70,
+0x65, 0x3a, 0x65, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65, 0x69, 0x6e,
+0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0xd83d, 0xdce7, 0x3a, 0x65, 0x6d, 0x61,
+0x69, 0x6c, 0x3a, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0xd83d, 0xdce7, 0x3a, 0x65,
+0x2d, 0x6d, 0x61, 0x69, 0x6c, 0x3a, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0xd83d,
+0xdc8c, 0x3a, 0x6c, 0x6f, 0x76, 0x65, 0x5f, 0x6c, 0x65, 0x74, 0x74, 0x65,
+0x72, 0x3a, 0x6c, 0x65, 0x74, 0x74, 0x65, 0x72, 0x6c, 0x6f, 0x76, 0x65,
+0xd83d, 0xdce5, 0x3a, 0x69, 0x6e, 0x62, 0x6f, 0x78, 0x5f, 0x74, 0x72, 0x61,
+0x79, 0x3a, 0x69, 0x6e, 0x62, 0x6f, 0x78, 0x74, 0x72, 0x61, 0x79, 0xd83d,
+0xdce4, 0x3a, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x78, 0x5f, 0x74, 0x72, 0x61,
+0x79, 0x3a, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x78, 0x74, 0x72, 0x61, 0x79,
+0xd83d, 0xdce6, 0x3a, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x3a, 0x70,
+0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0xd83c, 0xdff7, 0x3a, 0x6c, 0x61, 0x62,
+0x65, 0x6c, 0x3a, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0xd83d, 0xdcea, 0x3a, 0x6d,
+0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65,
+0x64, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x6d, 0x61, 0x69, 0x6c,
+0x62, 0x6f, 0x78, 0xd83d, 0xdceb, 0x3a, 0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f,
+0x78, 0x3a, 0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0xd83d, 0xdcec, 0x3a,
+0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0x5f, 0x77, 0x69, 0x74, 0x68,
+0x5f, 0x6d, 0x61, 0x69, 0x6c, 0x3a, 0x6d, 0x61, 0x69, 0x6c, 0x6d, 0x61,
+0x69, 0x6c, 0x62, 0x6f, 0x78, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdced, 0x3a,
+0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0x5f, 0x77, 0x69, 0x74, 0x68,
+0x5f, 0x6e, 0x6f, 0x5f, 0x6d, 0x61, 0x69, 0x6c, 0x3a, 0x6d, 0x61, 0x69,
+0x6c, 0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0x6e, 0x6f, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xdcee, 0x3a, 0x70, 0x6f, 0x73, 0x74, 0x62, 0x6f, 0x78,
+0x3a, 0x70, 0x6f, 0x73, 0x74, 0x62, 0x6f, 0x78, 0xd83d, 0xdcef, 0x3a, 0x70,
+0x6f, 0x73, 0x74, 0x61, 0x6c, 0x5f, 0x68, 0x6f, 0x72, 0x6e, 0x3a, 0x68,
+0x6f, 0x72, 0x6e, 0x70, 0x6f, 0x73, 0x74, 0x61, 0x6c, 0xd83d, 0xdcdc, 0x3a,
+0x73, 0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x3a, 0x73, 0x63, 0x72, 0x6f, 0x6c,
+0x6c, 0xd83d, 0xdcc3, 0x3a, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x63, 0x75, 0x72, 0x6c, 0x3a, 0x63, 0x75, 0x72, 0x6c, 0x70,
+0x61, 0x67, 0x65, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdcc4, 0x3a, 0x70, 0x61,
+0x67, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x5f, 0x75, 0x70,
+0x3a, 0x66, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x70, 0x61, 0x67, 0x65, 0x75,
+0x70, 0xd83d, 0xdcd1, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x6d, 0x61, 0x72, 0x6b,
+0x5f, 0x74, 0x61, 0x62, 0x73, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x6d, 0x61,
+0x72, 0x6b, 0x74, 0x61, 0x62, 0x73, 0xd83d, 0xdcca, 0x3a, 0x62, 0x61, 0x72,
+0x5f, 0x63, 0x68, 0x61, 0x72, 0x74, 0x3a, 0x62, 0x61, 0x72, 0x63, 0x68,
+0x61, 0x72, 0x74, 0xd83d, 0xdcc8, 0x3a, 0x63, 0x68, 0x61, 0x72, 0x74, 0x5f,
+0x77, 0x69, 0x74, 0x68, 0x5f, 0x75, 0x70, 0x77, 0x61, 0x72, 0x64, 0x73,
+0x5f, 0x74, 0x72, 0x65, 0x6e, 0x64, 0x3a, 0x63, 0x68, 0x61, 0x72, 0x74,
+0x74, 0x72, 0x65, 0x6e, 0x64, 0x75, 0x70, 0x77, 0x61, 0x72, 0x64, 0x73,
+0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdcc9, 0x3a, 0x63, 0x68, 0x61, 0x72, 0x74,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x77, 0x61,
+0x72, 0x64, 0x73, 0x5f, 0x74, 0x72, 0x65, 0x6e, 0x64, 0x3a, 0x63, 0x68,
+0x61, 0x72, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x77, 0x61, 0x72, 0x64, 0x73,
+0x74, 0x72, 0x65, 0x6e, 0x64, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xddd2, 0x3a,
+0x73, 0x70, 0x69, 0x72, 0x61, 0x6c, 0x5f, 0x6e, 0x6f, 0x74, 0x65, 0x5f,
+0x70, 0x61, 0x64, 0x3a, 0x6e, 0x6f, 0x74, 0x65, 0x70, 0x61, 0x64, 0x73,
+0x70, 0x69, 0x72, 0x61, 0x6c, 0xd83d, 0xddd2, 0x3a, 0x6e, 0x6f, 0x74, 0x65,
+0x70, 0x61, 0x64, 0x5f, 0x73, 0x70, 0x69, 0x72, 0x61, 0x6c, 0x3a, 0x6e,
+0x6f, 0x74, 0x65, 0x70, 0x61, 0x64, 0x73, 0x70, 0x69, 0x72, 0x61, 0x6c,
+0xd83d, 0xddd3, 0x3a, 0x73, 0x70, 0x69, 0x72, 0x61, 0x6c, 0x5f, 0x63, 0x61,
+0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x5f, 0x70, 0x61, 0x64, 0x3a, 0x63,
+0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x70, 0x61, 0x64, 0x73, 0x70,
+0x69, 0x72, 0x61, 0x6c, 0xd83d, 0xddd3, 0x3a, 0x63, 0x61, 0x6c, 0x65, 0x6e,
+0x64, 0x61, 0x72, 0x5f, 0x73, 0x70, 0x69, 0x72, 0x61, 0x6c, 0x3a, 0x63,
+0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0x73, 0x70, 0x69, 0x72, 0x61,
+0x6c, 0xd83d, 0xdcc6, 0x3a, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72,
+0x3a, 0x63, 0x61, 0x6c, 0x65, 0x6e, 0x64, 0x61, 0x72, 0xd83d, 0xdcc5, 0x3a,
+0x64, 0x61, 0x74, 0x65, 0x3a, 0x64, 0x61, 0x74, 0x65, 0xd83d, 0xdcc7, 0x3a,
+0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x3a, 0x63,
+0x61, 0x72, 0x64, 0x69, 0x6e, 0x64, 0x65, 0x78, 0xd83d, 0xddc3, 0x3a, 0x63,
+0x61, 0x72, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x62, 0x6f, 0x78,
+0x3a, 0x62, 0x6f, 0x78, 0x63, 0x61, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65,
+0xd83d, 0xddc3, 0x3a, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x62, 0x6f, 0x78, 0x3a,
+0x62, 0x6f, 0x78, 0x63, 0x61, 0x72, 0x64, 0xd83d, 0xddf3, 0x3a, 0x62, 0x61,
+0x6c, 0x6c, 0x6f, 0x74, 0x5f, 0x62, 0x6f, 0x78, 0x5f, 0x77, 0x69, 0x74,
+0x68, 0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x74, 0x3a, 0x62, 0x61, 0x6c,
+0x6c, 0x6f, 0x74, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x74, 0x62, 0x6f, 0x78,
+0x77, 0x69, 0x74, 0x68, 0xd83d, 0xddf3, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f,
+0x74, 0x5f, 0x62, 0x6f, 0x78, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x74,
+0x62, 0x6f, 0x78, 0xd83d, 0xddc4, 0x3a, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x63,
+0x61, 0x62, 0x69, 0x6e, 0x65, 0x74, 0x3a, 0x63, 0x61, 0x62, 0x69, 0x6e,
+0x65, 0x74, 0x66, 0x69, 0x6c, 0x65, 0xd83d, 0xdccb, 0x3a, 0x63, 0x6c, 0x69,
+0x70, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x3a, 0x63, 0x6c, 0x69, 0x70, 0x62,
+0x6f, 0x61, 0x72, 0x64, 0xd83d, 0xdcc1, 0x3a, 0x66, 0x69, 0x6c, 0x65, 0x5f,
+0x66, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x3a, 0x66, 0x69, 0x6c, 0x65, 0x66,
+0x6f, 0x6c, 0x64, 0x65, 0x72, 0xd83d, 0xdcc2, 0x3a, 0x6f, 0x70, 0x65, 0x6e,
+0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x72,
+0x3a, 0x66, 0x69, 0x6c, 0x65, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x6f,
+0x70, 0x65, 0x6e, 0xd83d, 0xddc2, 0x3a, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69,
+0x6e, 0x64, 0x65, 0x78, 0x5f, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72,
+0x73, 0x3a, 0x63, 0x61, 0x72, 0x64, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65,
+0x72, 0x73, 0x69, 0x6e, 0x64, 0x65, 0x78, 0xd83d, 0xddc2, 0x3a, 0x64, 0x69,
+0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x3a, 0x64, 0x69, 0x76, 0x69, 0x64,
+0x65, 0x72, 0x73, 0xd83d, 0xddde, 0x3a, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x64,
+0x5f, 0x75, 0x70, 0x5f, 0x6e, 0x65, 0x77, 0x73, 0x70, 0x61, 0x70, 0x65,
+0x72, 0x3a, 0x6e, 0x65, 0x77, 0x73, 0x70, 0x61, 0x70, 0x65, 0x72, 0x72,
+0x6f, 0x6c, 0x6c, 0x65, 0x64, 0x75, 0x70, 0xd83d, 0xddde, 0x3a, 0x6e, 0x65,
+0x77, 0x73, 0x70, 0x61, 0x70, 0x65, 0x72, 0x32, 0x3a, 0x6e, 0x65, 0x77,
+0x73, 0x70, 0x61, 0x70, 0x65, 0x72, 0x32, 0xd83d, 0xdcf0, 0x3a, 0x6e, 0x65,
+0x77, 0x73, 0x70, 0x61, 0x70, 0x65, 0x72, 0x3a, 0x6e, 0x65, 0x77, 0x73,
+0x70, 0x61, 0x70, 0x65, 0x72, 0xd83d, 0xdcd3, 0x3a, 0x6e, 0x6f, 0x74, 0x65,
+0x62, 0x6f, 0x6f, 0x6b, 0x3a, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6f, 0x6f,
+0x6b, 0xd83d, 0xdcd4, 0x3a, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6f, 0x6f, 0x6b,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x64, 0x65, 0x63, 0x6f, 0x72, 0x61,
+0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x3a, 0x63,
+0x6f, 0x76, 0x65, 0x72, 0x64, 0x65, 0x63, 0x6f, 0x72, 0x61, 0x74, 0x69,
+0x76, 0x65, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x77, 0x69,
+0x74, 0x68, 0xd83d, 0xdcd2, 0x3a, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x72, 0x3a,
+0x6c, 0x65, 0x64, 0x67, 0x65, 0x72, 0xd83d, 0xdcd5, 0x3a, 0x63, 0x6c, 0x6f,
+0x73, 0x65, 0x64, 0x5f, 0x62, 0x6f, 0x6f, 0x6b, 0x3a, 0x62, 0x6f, 0x6f,
+0x6b, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0xd83d, 0xdcd7, 0x3a, 0x67, 0x72,
+0x65, 0x65, 0x6e, 0x5f, 0x62, 0x6f, 0x6f, 0x6b, 0x3a, 0x62, 0x6f, 0x6f,
+0x6b, 0x67, 0x72, 0x65, 0x65, 0x6e, 0xd83d, 0xdcd8, 0x3a, 0x62, 0x6c, 0x75,
+0x65, 0x5f, 0x62, 0x6f, 0x6f, 0x6b, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x62,
+0x6f, 0x6f, 0x6b, 0xd83d, 0xdcd9, 0x3a, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65,
+0x5f, 0x62, 0x6f, 0x6f, 0x6b, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x6f, 0x72,
+0x61, 0x6e, 0x67, 0x65, 0xd83d, 0xdcda, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x73,
+0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x73, 0xd83d, 0xdcd6, 0x3a, 0x62, 0x6f, 0x6f,
+0x6b, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0xd83d, 0xdd16, 0x3a, 0x62, 0x6f, 0x6f,
+0x6b, 0x6d, 0x61, 0x72, 0x6b, 0x3a, 0x62, 0x6f, 0x6f, 0x6b, 0x6d, 0x61,
+0x72, 0x6b, 0xd83d, 0xdd17, 0x3a, 0x6c, 0x69, 0x6e, 0x6b, 0x3a, 0x6c, 0x69,
+0x6e, 0x6b, 0xd83d, 0xdcce, 0x3a, 0x70, 0x61, 0x70, 0x65, 0x72, 0x63, 0x6c,
+0x69, 0x70, 0x3a, 0x70, 0x61, 0x70, 0x65, 0x72, 0x63, 0x6c, 0x69, 0x70,
+0xd83d, 0xdd87, 0x3a, 0x6c, 0x69, 0x6e, 0x6b, 0x65, 0x64, 0x5f, 0x70, 0x61,
+0x70, 0x65, 0x72, 0x63, 0x6c, 0x69, 0x70, 0x73, 0x3a, 0x6c, 0x69, 0x6e,
+0x6b, 0x65, 0x64, 0x70, 0x61, 0x70, 0x65, 0x72, 0x63, 0x6c, 0x69, 0x70,
+0x73, 0xd83d, 0xdd87, 0x3a, 0x70, 0x61, 0x70, 0x65, 0x72, 0x63, 0x6c, 0x69,
+0x70, 0x73, 0x3a, 0x70, 0x61, 0x70, 0x65, 0x72, 0x63, 0x6c, 0x69, 0x70,
+0x73, 0xd83d, 0xdcd0, 0x3a, 0x74, 0x72, 0x69, 0x61, 0x6e, 0x67, 0x75, 0x6c,
+0x61, 0x72, 0x5f, 0x72, 0x75, 0x6c, 0x65, 0x72, 0x3a, 0x72, 0x75, 0x6c,
+0x65, 0x72, 0x74, 0x72, 0x69, 0x61, 0x6e, 0x67, 0x75, 0x6c, 0x61, 0x72,
+0xd83d, 0xdccf, 0x3a, 0x73, 0x74, 0x72, 0x61, 0x69, 0x67, 0x68, 0x74, 0x5f,
+0x72, 0x75, 0x6c, 0x65, 0x72, 0x3a, 0x72, 0x75, 0x6c, 0x65, 0x72, 0x73,
+0x74, 0x72, 0x61, 0x69, 0x67, 0x68, 0x74, 0xd83d, 0xdccc, 0x3a, 0x70, 0x75,
+0x73, 0x68, 0x70, 0x69, 0x6e, 0x3a, 0x70, 0x75, 0x73, 0x68, 0x70, 0x69,
+0x6e, 0xd83d, 0xdccd, 0x3a, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x70, 0x75,
+0x73, 0x68, 0x70, 0x69, 0x6e, 0x3a, 0x70, 0x75, 0x73, 0x68, 0x70, 0x69,
+0x6e, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x2702, 0xfe0f, 0x3a, 0x73, 0x63, 0x69,
+0x73, 0x73, 0x6f, 0x72, 0x73, 0x3a, 0x73, 0x63, 0x69, 0x73, 0x73, 0x6f,
+0x72, 0x73, 0xd83d, 0xdd8a, 0x3a, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x6c,
+0x65, 0x66, 0x74, 0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x70, 0x6f, 0x69, 0x6e,
+0x74, 0x5f, 0x70, 0x65, 0x6e, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x70, 0x6f,
+0x69, 0x6e, 0x74, 0x6c, 0x65, 0x66, 0x74, 0x6c, 0x6f, 0x77, 0x65, 0x72,
+0x70, 0x65, 0x6e, 0xd83d, 0xdd8a, 0x3a, 0x70, 0x65, 0x6e, 0x5f, 0x62, 0x61,
+0x6c, 0x6c, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x3a, 0x62, 0x61, 0x6c, 0x6c,
+0x70, 0x6f, 0x69, 0x6e, 0x74, 0x70, 0x65, 0x6e, 0xd83d, 0xdd8b, 0x3a, 0x6c,
+0x6f, 0x77, 0x65, 0x72, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f,
+0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x5f, 0x70, 0x65, 0x6e, 0x3a, 0x66,
+0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x6c, 0x65, 0x66, 0x74, 0x6c,
+0x6f, 0x77, 0x65, 0x72, 0x70, 0x65, 0x6e, 0xd83d, 0xdd8b, 0x3a, 0x70, 0x65,
+0x6e, 0x5f, 0x66, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x3a, 0x66,
+0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x70, 0x65, 0x6e, 0x2712, 0xfe0f,
+0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x6e, 0x69, 0x62, 0x3a, 0x62,
+0x6c, 0x61, 0x63, 0x6b, 0x6e, 0x69, 0x62, 0xd83d, 0xdd8c, 0x3a, 0x6c, 0x6f,
+0x77, 0x65, 0x72, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x70, 0x61, 0x69,
+0x6e, 0x74, 0x62, 0x72, 0x75, 0x73, 0x68, 0x3a, 0x6c, 0x65, 0x66, 0x74,
+0x6c, 0x6f, 0x77, 0x65, 0x72, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x62, 0x72,
+0x75, 0x73, 0x68, 0xd83d, 0xdd8c, 0x3a, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x62,
+0x72, 0x75, 0x73, 0x68, 0x3a, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x62, 0x72,
+0x75, 0x73, 0x68, 0xd83d, 0xdd8d, 0x3a, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f,
+0x6c, 0x65, 0x66, 0x74, 0x5f, 0x63, 0x72, 0x61, 0x79, 0x6f, 0x6e, 0x3a,
+0x63, 0x72, 0x61, 0x79, 0x6f, 0x6e, 0x6c, 0x65, 0x66, 0x74, 0x6c, 0x6f,
+0x77, 0x65, 0x72, 0xd83d, 0xdd8d, 0x3a, 0x63, 0x72, 0x61, 0x79, 0x6f, 0x6e,
+0x3a, 0x63, 0x72, 0x61, 0x79, 0x6f, 0x6e, 0xd83d, 0xdcdd, 0x3a, 0x6d, 0x65,
+0x6d, 0x6f, 0x3a, 0x6d, 0x65, 0x6d, 0x6f, 0xd83d, 0xdcdd, 0x3a, 0x70, 0x65,
+0x6e, 0x63, 0x69, 0x6c, 0x3a, 0x70, 0x65, 0x6e, 0x63, 0x69, 0x6c, 0x270f,
+0xfe0f, 0x3a, 0x70, 0x65, 0x6e, 0x63, 0x69, 0x6c, 0x32, 0x3a, 0x70, 0x65,
+0x6e, 0x63, 0x69, 0x6c, 0x32, 0xd83d, 0xdd0d, 0x3a, 0x6d, 0x61, 0x67, 0x3a,
+0x6d, 0x61, 0x67, 0xd83d, 0xdd0e, 0x3a, 0x6d, 0x61, 0x67, 0x5f, 0x72, 0x69,
+0x67, 0x68, 0x74, 0x3a, 0x6d, 0x61, 0x67, 0x72, 0x69, 0x67, 0x68, 0x74,
+0xd83d, 0xdd0f, 0x3a, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x77, 0x69, 0x74, 0x68,
+0x5f, 0x69, 0x6e, 0x6b, 0x5f, 0x70, 0x65, 0x6e, 0x3a, 0x69, 0x6e, 0x6b,
+0x6c, 0x6f, 0x63, 0x6b, 0x70, 0x65, 0x6e, 0x77, 0x69, 0x74, 0x68, 0xd83d,
+0xdd10, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x5f, 0x6c, 0x6f, 0x63,
+0x6b, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6b, 0x65, 0x79, 0x3a, 0x63,
+0x6c, 0x6f, 0x73, 0x65, 0x64, 0x6b, 0x65, 0x79, 0x6c, 0x6f, 0x63, 0x6b,
+0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdd12, 0x3a, 0x6c, 0x6f, 0x63, 0x6b, 0x3a,
+0x6c, 0x6f, 0x63, 0x6b, 0xd83d, 0xdd13, 0x3a, 0x75, 0x6e, 0x6c, 0x6f, 0x63,
+0x6b, 0x3a, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x2764, 0xfe0f, 0x3a, 0x68,
+0x65, 0x61, 0x72, 0x74, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0xd83d, 0xdc9b,
+0x3a, 0x79, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x68, 0x65, 0x61, 0x72,
+0x74, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x79, 0x65, 0x6c, 0x6c, 0x6f,
+0x77, 0xd83d, 0xdc9a, 0x3a, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x68, 0x65,
+0x61, 0x72, 0x74, 0x3a, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x68, 0x65, 0x61,
+0x72, 0x74, 0xd83d, 0xdc99, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x5f, 0x68, 0x65,
+0x61, 0x72, 0x74, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x68, 0x65, 0x61, 0x72,
+0x74, 0xd83d, 0xdc9c, 0x3a, 0x70, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x5f, 0x68,
+0x65, 0x61, 0x72, 0x74, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x70, 0x75,
+0x72, 0x70, 0x6c, 0x65, 0xd83d, 0xdda4, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x68, 0x65, 0x61, 0x72, 0x74, 0xd83d, 0xdc94, 0x3a, 0x62, 0x72, 0x6f, 0x6b,
+0x65, 0x6e, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x3a, 0x62, 0x72, 0x6f,
+0x6b, 0x65, 0x6e, 0x68, 0x65, 0x61, 0x72, 0x74, 0x2763, 0xfe0f, 0x3a, 0x68,
+0x65, 0x61, 0x76, 0x79, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x65,
+0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d,
+0x61, 0x72, 0x6b, 0x5f, 0x6f, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x6e, 0x74,
+0x3a, 0x65, 0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+0x68, 0x65, 0x61, 0x72, 0x74, 0x68, 0x65, 0x61, 0x76, 0x79, 0x6d, 0x61,
+0x72, 0x6b, 0x6f, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x2763, 0xfe0f,
+0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x65, 0x78, 0x63, 0x6c, 0x61,
+0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x65, 0x78, 0x63, 0x6c, 0x61,
+0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x68, 0x65, 0x61, 0x72, 0x74, 0xd83d,
+0xdc95, 0x3a, 0x74, 0x77, 0x6f, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73,
+0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73, 0x74, 0x77, 0x6f, 0xd83d, 0xdc9e,
+0x3a, 0x72, 0x65, 0x76, 0x6f, 0x6c, 0x76, 0x69, 0x6e, 0x67, 0x5f, 0x68,
+0x65, 0x61, 0x72, 0x74, 0x73, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73,
+0x72, 0x65, 0x76, 0x6f, 0x6c, 0x76, 0x69, 0x6e, 0x67, 0xd83d, 0xdc93, 0x3a,
+0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x3a, 0x68, 0x65,
+0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0xd83d, 0xdc97, 0x3a, 0x68, 0x65,
+0x61, 0x72, 0x74, 0x70, 0x75, 0x6c, 0x73, 0x65, 0x3a, 0x68, 0x65, 0x61,
+0x72, 0x74, 0x70, 0x75, 0x6c, 0x73, 0x65, 0xd83d, 0xdc96, 0x3a, 0x73, 0x70,
+0x61, 0x72, 0x6b, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x68, 0x65, 0x61, 0x72,
+0x74, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73, 0x70, 0x61, 0x72, 0x6b,
+0x6c, 0x69, 0x6e, 0x67, 0xd83d, 0xdc98, 0x3a, 0x63, 0x75, 0x70, 0x69, 0x64,
+0x3a, 0x63, 0x75, 0x70, 0x69, 0x64, 0xd83d, 0xdc9d, 0x3a, 0x67, 0x69, 0x66,
+0x74, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x3a, 0x67, 0x69, 0x66, 0x74,
+0x68, 0x65, 0x61, 0x72, 0x74, 0xd83d, 0xdc9f, 0x3a, 0x68, 0x65, 0x61, 0x72,
+0x74, 0x5f, 0x64, 0x65, 0x63, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+0x3a, 0x64, 0x65, 0x63, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x68,
+0x65, 0x61, 0x72, 0x74, 0x262e, 0xfe0f, 0x3a, 0x70, 0x65, 0x61, 0x63, 0x65,
+0x5f, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x3a, 0x70, 0x65, 0x61, 0x63,
+0x65, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x262e, 0xfe0f, 0x3a, 0x70, 0x65,
+0x61, 0x63, 0x65, 0x3a, 0x70, 0x65, 0x61, 0x63, 0x65, 0x271d, 0xfe0f, 0x3a,
+0x6c, 0x61, 0x74, 0x69, 0x6e, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x3a,
+0x63, 0x72, 0x6f, 0x73, 0x73, 0x6c, 0x61, 0x74, 0x69, 0x6e, 0x271d, 0xfe0f,
+0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73,
+0x262a, 0xfe0f, 0x3a, 0x73, 0x74, 0x61, 0x72, 0x5f, 0x61, 0x6e, 0x64, 0x5f,
+0x63, 0x72, 0x65, 0x73, 0x63, 0x65, 0x6e, 0x74, 0x3a, 0x61, 0x6e, 0x64,
+0x63, 0x72, 0x65, 0x73, 0x63, 0x65, 0x6e, 0x74, 0x73, 0x74, 0x61, 0x72,
+0xd83d, 0xdd49, 0x3a, 0x6f, 0x6d, 0x5f, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
+0x3a, 0x6f, 0x6d, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x2638, 0xfe0f, 0x3a,
+0x77, 0x68, 0x65, 0x65, 0x6c, 0x5f, 0x6f, 0x66, 0x5f, 0x64, 0x68, 0x61,
+0x72, 0x6d, 0x61, 0x3a, 0x64, 0x68, 0x61, 0x72, 0x6d, 0x61, 0x6f, 0x66,
+0x77, 0x68, 0x65, 0x65, 0x6c, 0x2721, 0xfe0f, 0x3a, 0x73, 0x74, 0x61, 0x72,
+0x5f, 0x6f, 0x66, 0x5f, 0x64, 0x61, 0x76, 0x69, 0x64, 0x3a, 0x64, 0x61,
+0x76, 0x69, 0x64, 0x6f, 0x66, 0x73, 0x74, 0x61, 0x72, 0xd83d, 0xdd2f, 0x3a,
+0x73, 0x69, 0x78, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x5f,
+0x73, 0x74, 0x61, 0x72, 0x3a, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64,
+0x73, 0x69, 0x78, 0x73, 0x74, 0x61, 0x72, 0xd83d, 0xdd4e, 0x3a, 0x6d, 0x65,
+0x6e, 0x6f, 0x72, 0x61, 0x68, 0x3a, 0x6d, 0x65, 0x6e, 0x6f, 0x72, 0x61,
+0x68, 0x262f, 0xfe0f, 0x3a, 0x79, 0x69, 0x6e, 0x5f, 0x79, 0x61, 0x6e, 0x67,
+0x3a, 0x79, 0x61, 0x6e, 0x67, 0x79, 0x69, 0x6e, 0x2626, 0xfe0f, 0x3a, 0x6f,
+0x72, 0x74, 0x68, 0x6f, 0x64, 0x6f, 0x78, 0x5f, 0x63, 0x72, 0x6f, 0x73,
+0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x6f, 0x72, 0x74, 0x68, 0x6f,
+0x64, 0x6f, 0x78, 0xd83d, 0xded0, 0x3a, 0x77, 0x6f, 0x72, 0x73, 0x68, 0x69,
+0x70, 0x5f, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x3a, 0x73, 0x79, 0x6d,
+0x62, 0x6f, 0x6c, 0x77, 0x6f, 0x72, 0x73, 0x68, 0x69, 0x70, 0xd83d, 0xded0,
+0x3a, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x77, 0x6f,
+0x72, 0x73, 0x68, 0x69, 0x70, 0x3a, 0x6f, 0x66, 0x70, 0x6c, 0x61, 0x63,
+0x65, 0x77, 0x6f, 0x72, 0x73, 0x68, 0x69, 0x70, 0x26ce, 0x3a, 0x6f, 0x70,
+0x68, 0x69, 0x75, 0x63, 0x68, 0x75, 0x73, 0x3a, 0x6f, 0x70, 0x68, 0x69,
+0x75, 0x63, 0x68, 0x75, 0x73, 0x2648, 0xfe0f, 0x3a, 0x61, 0x72, 0x69, 0x65,
+0x73, 0x3a, 0x61, 0x72, 0x69, 0x65, 0x73, 0x2649, 0xfe0f, 0x3a, 0x74, 0x61,
+0x75, 0x72, 0x75, 0x73, 0x3a, 0x74, 0x61, 0x75, 0x72, 0x75, 0x73, 0x264a,
+0xfe0f, 0x3a, 0x67, 0x65, 0x6d, 0x69, 0x6e, 0x69, 0x3a, 0x67, 0x65, 0x6d,
+0x69, 0x6e, 0x69, 0x264b, 0xfe0f, 0x3a, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x72,
+0x3a, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x72, 0x264c, 0xfe0f, 0x3a, 0x6c, 0x65,
+0x6f, 0x3a, 0x6c, 0x65, 0x6f, 0x264d, 0xfe0f, 0x3a, 0x76, 0x69, 0x72, 0x67,
+0x6f, 0x3a, 0x76, 0x69, 0x72, 0x67, 0x6f, 0x264e, 0xfe0f, 0x3a, 0x6c, 0x69,
+0x62, 0x72, 0x61, 0x3a, 0x6c, 0x69, 0x62, 0x72, 0x61, 0x264f, 0xfe0f, 0x3a,
+0x73, 0x63, 0x6f, 0x72, 0x70, 0x69, 0x75, 0x73, 0x3a, 0x73, 0x63, 0x6f,
+0x72, 0x70, 0x69, 0x75, 0x73, 0x2650, 0xfe0f, 0x3a, 0x73, 0x61, 0x67, 0x69,
+0x74, 0x74, 0x61, 0x72, 0x69, 0x75, 0x73, 0x3a, 0x73, 0x61, 0x67, 0x69,
+0x74, 0x74, 0x61, 0x72, 0x69, 0x75, 0x73, 0x2651, 0xfe0f, 0x3a, 0x63, 0x61,
+0x70, 0x72, 0x69, 0x63, 0x6f, 0x72, 0x6e, 0x3a, 0x63, 0x61, 0x70, 0x72,
+0x69, 0x63, 0x6f, 0x72, 0x6e, 0x2652, 0xfe0f, 0x3a, 0x61, 0x71, 0x75, 0x61,
+0x72, 0x69, 0x75, 0x73, 0x3a, 0x61, 0x71, 0x75, 0x61, 0x72, 0x69, 0x75,
+0x73, 0x2653, 0xfe0f, 0x3a, 0x70, 0x69, 0x73, 0x63, 0x65, 0x73, 0x3a, 0x70,
+0x69, 0x73, 0x63, 0x65, 0x73, 0xd83c, 0xdd94, 0x3a, 0x69, 0x64, 0x3a, 0x69,
+0x64, 0x269b, 0xfe0f, 0x3a, 0x61, 0x74, 0x6f, 0x6d, 0x5f, 0x73, 0x79, 0x6d,
+0x62, 0x6f, 0x6c, 0x3a, 0x61, 0x74, 0x6f, 0x6d, 0x73, 0x79, 0x6d, 0x62,
+0x6f, 0x6c, 0x269b, 0xfe0f, 0x3a, 0x61, 0x74, 0x6f, 0x6d, 0x3a, 0x61, 0x74,
+0x6f, 0x6d, 0xd83c, 0xde51, 0x3a, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x3a,
+0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2622, 0xfe0f, 0x3a, 0x72, 0x61, 0x64,
+0x69, 0x6f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x73, 0x69, 0x67,
+0x6e, 0x3a, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x61, 0x63, 0x74, 0x69, 0x76,
+0x65, 0x73, 0x69, 0x67, 0x6e, 0x2622, 0xfe0f, 0x3a, 0x72, 0x61, 0x64, 0x69,
+0x6f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x3a, 0x72, 0x61, 0x64, 0x69,
+0x6f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x2623, 0xfe0f, 0x3a, 0x62, 0x69,
+0x6f, 0x68, 0x61, 0x7a, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x69, 0x67, 0x6e,
+0x3a, 0x62, 0x69, 0x6f, 0x68, 0x61, 0x7a, 0x61, 0x72, 0x64, 0x73, 0x69,
+0x67, 0x6e, 0x2623, 0xfe0f, 0x3a, 0x62, 0x69, 0x6f, 0x68, 0x61, 0x7a, 0x61,
+0x72, 0x64, 0x3a, 0x62, 0x69, 0x6f, 0x68, 0x61, 0x7a, 0x61, 0x72, 0x64,
+0xd83d, 0xdcf4, 0x3a, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x5f, 0x70, 0x68,
+0x6f, 0x6e, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x3a, 0x6d, 0x6f, 0x62, 0x69,
+0x6c, 0x65, 0x6f, 0x66, 0x66, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0xd83d, 0xdcf3,
+0x3a, 0x76, 0x69, 0x62, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d,
+0x6f, 0x64, 0x65, 0x3a, 0x6d, 0x6f, 0x64, 0x65, 0x76, 0x69, 0x62, 0x72,
+0x61, 0x74, 0x69, 0x6f, 0x6e, 0xd83c, 0xde36, 0x3a, 0x75, 0x36, 0x37, 0x30,
+0x39, 0x3a, 0x75, 0x36, 0x37, 0x30, 0x39, 0xd83c, 0xde1a, 0xfe0f, 0x3a, 0x75,
+0x37, 0x31, 0x32, 0x31, 0x3a, 0x75, 0x37, 0x31, 0x32, 0x31, 0xd83c, 0xde38,
+0x3a, 0x75, 0x37, 0x35, 0x33, 0x33, 0x3a, 0x75, 0x37, 0x35, 0x33, 0x33,
+0xd83c, 0xde3a, 0x3a, 0x75, 0x35, 0x35, 0x62, 0x36, 0x3a, 0x75, 0x35, 0x35,
+0x62, 0x36, 0xd83c, 0xde37, 0x3a, 0x75, 0x36, 0x37, 0x30, 0x38, 0x3a, 0x75,
+0x36, 0x37, 0x30, 0x38, 0x2734, 0xfe0f, 0x3a, 0x65, 0x69, 0x67, 0x68, 0x74,
+0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x6c, 0x61,
+0x63, 0x6b, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x3a, 0x62, 0x6c, 0x61, 0x63,
+0x6b, 0x65, 0x69, 0x67, 0x68, 0x74, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65,
+0x64, 0x73, 0x74, 0x61, 0x72, 0xd83c, 0xdd9a, 0x3a, 0x76, 0x73, 0x3a, 0x76,
+0x73, 0xd83d, 0xdcae, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x66, 0x6c,
+0x6f, 0x77, 0x65, 0x72, 0x3a, 0x66, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x77,
+0x68, 0x69, 0x74, 0x65, 0xd83c, 0xde50, 0x3a, 0x69, 0x64, 0x65, 0x6f, 0x67,
+0x72, 0x61, 0x70, 0x68, 0x5f, 0x61, 0x64, 0x76, 0x61, 0x6e, 0x74, 0x61,
+0x67, 0x65, 0x3a, 0x61, 0x64, 0x76, 0x61, 0x6e, 0x74, 0x61, 0x67, 0x65,
+0x69, 0x64, 0x65, 0x6f, 0x67, 0x72, 0x61, 0x70, 0x68, 0x3299, 0xfe0f, 0x3a,
+0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x3a, 0x73, 0x65, 0x63, 0x72, 0x65,
+0x74, 0x3297, 0xfe0f, 0x3a, 0x63, 0x6f, 0x6e, 0x67, 0x72, 0x61, 0x74, 0x75,
+0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x3a, 0x63, 0x6f, 0x6e, 0x67,
+0x72, 0x61, 0x74, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xd83c,
+0xde34, 0x3a, 0x75, 0x35, 0x34, 0x30, 0x38, 0x3a, 0x75, 0x35, 0x34, 0x30,
+0x38, 0xd83c, 0xde35, 0x3a, 0x75, 0x36, 0x65, 0x38, 0x30, 0x3a, 0x75, 0x36,
+0x65, 0x38, 0x30, 0xd83c, 0xde39, 0x3a, 0x75, 0x35, 0x32, 0x37, 0x32, 0x3a,
+0x75, 0x35, 0x32, 0x37, 0x32, 0xd83c, 0xde32, 0x3a, 0x75, 0x37, 0x39, 0x38,
+0x31, 0x3a, 0x75, 0x37, 0x39, 0x38, 0x31, 0xd83c, 0xdd70, 0xfe0f, 0x3a, 0x61,
+0x3a, 0x61, 0xd83c, 0xdd71, 0xfe0f, 0x3a, 0x62, 0x3a, 0x62, 0xd83c, 0xdd8e, 0x3a,
+0x61, 0x62, 0x3a, 0x61, 0x62, 0xd83c, 0xdd91, 0x3a, 0x63, 0x6c, 0x3a, 0x63,
+0x6c, 0xd83c, 0xdd7e, 0xfe0f, 0x3a, 0x6f, 0x32, 0x3a, 0x6f, 0x32, 0xd83c, 0xdd98,
+0x3a, 0x73, 0x6f, 0x73, 0x3a, 0x73, 0x6f, 0x73, 0x274c, 0x3a, 0x78, 0x3a,
+0x78, 0x2b55, 0xfe0f, 0x3a, 0x6f, 0x3a, 0x6f, 0xd83d, 0xded1, 0x3a, 0x73, 0x74,
+0x6f, 0x70, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x73, 0x69, 0x67, 0x6e,
+0x73, 0x74, 0x6f, 0x70, 0xd83d, 0xded1, 0x3a, 0x6f, 0x63, 0x74, 0x61, 0x67,
+0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x6f, 0x63,
+0x74, 0x61, 0x67, 0x6f, 0x6e, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x26d4,
+0xfe0f, 0x3a, 0x6e, 0x6f, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x3a, 0x65,
+0x6e, 0x74, 0x72, 0x79, 0x6e, 0x6f, 0xd83d, 0xdcdb, 0x3a, 0x6e, 0x61, 0x6d,
+0x65, 0x5f, 0x62, 0x61, 0x64, 0x67, 0x65, 0x3a, 0x62, 0x61, 0x64, 0x67,
+0x65, 0x6e, 0x61, 0x6d, 0x65, 0xd83d, 0xdeab, 0x3a, 0x6e, 0x6f, 0x5f, 0x65,
+0x6e, 0x74, 0x72, 0x79, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x65, 0x6e,
+0x74, 0x72, 0x79, 0x6e, 0x6f, 0x73, 0x69, 0x67, 0x6e, 0xd83d, 0xdcaf, 0x3a,
+0x31, 0x30, 0x30, 0x3a, 0x31, 0x30, 0x30, 0xd83d, 0xdca2, 0x3a, 0x61, 0x6e,
+0x67, 0x65, 0x72, 0x3a, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x2668, 0xfe0f, 0x3a,
+0x68, 0x6f, 0x74, 0x73, 0x70, 0x72, 0x69, 0x6e, 0x67, 0x73, 0x3a, 0x68,
+0x6f, 0x74, 0x73, 0x70, 0x72, 0x69, 0x6e, 0x67, 0x73, 0xd83d, 0xdeb7, 0x3a,
+0x6e, 0x6f, 0x5f, 0x70, 0x65, 0x64, 0x65, 0x73, 0x74, 0x72, 0x69, 0x61,
+0x6e, 0x73, 0x3a, 0x6e, 0x6f, 0x70, 0x65, 0x64, 0x65, 0x73, 0x74, 0x72,
+0x69, 0x61, 0x6e, 0x73, 0xd83d, 0xdeaf, 0x3a, 0x64, 0x6f, 0x5f, 0x6e, 0x6f,
+0x74, 0x5f, 0x6c, 0x69, 0x74, 0x74, 0x65, 0x72, 0x3a, 0x64, 0x6f, 0x6c,
+0x69, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x6f, 0x74, 0xd83d, 0xdeb3, 0x3a, 0x6e,
+0x6f, 0x5f, 0x62, 0x69, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x3a, 0x62,
+0x69, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x6e, 0x6f, 0xd83d, 0xdeb1, 0x3a,
+0x6e, 0x6f, 0x6e, 0x2d, 0x70, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f,
+0x77, 0x61, 0x74, 0x65, 0x72, 0x3a, 0x6e, 0x6f, 0x6e, 0x70, 0x6f, 0x74,
+0x61, 0x62, 0x6c, 0x65, 0x77, 0x61, 0x74, 0x65, 0x72, 0xd83d, 0xdd1e, 0x3a,
+0x75, 0x6e, 0x64, 0x65, 0x72, 0x61, 0x67, 0x65, 0x3a, 0x75, 0x6e, 0x64,
+0x65, 0x72, 0x61, 0x67, 0x65, 0xd83d, 0xdcf5, 0x3a, 0x6e, 0x6f, 0x5f, 0x6d,
+0x6f, 0x62, 0x69, 0x6c, 0x65, 0x5f, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x73,
+0x3a, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x6e, 0x6f, 0x70, 0x68, 0x6f,
+0x6e, 0x65, 0x73, 0xd83d, 0xdead, 0x3a, 0x6e, 0x6f, 0x5f, 0x73, 0x6d, 0x6f,
+0x6b, 0x69, 0x6e, 0x67, 0x3a, 0x6e, 0x6f, 0x73, 0x6d, 0x6f, 0x6b, 0x69,
+0x6e, 0x67, 0x2757, 0xfe0f, 0x3a, 0x65, 0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61,
+0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x65, 0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61,
+0x74, 0x69, 0x6f, 0x6e, 0x2755, 0x3a, 0x67, 0x72, 0x65, 0x79, 0x5f, 0x65,
+0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x65,
+0x78, 0x63, 0x6c, 0x61, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x67, 0x72,
+0x65, 0x79, 0x2753, 0x3a, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6f, 0x6e,
+0x3a, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6f, 0x6e, 0x2754, 0x3a, 0x67,
+0x72, 0x65, 0x79, 0x5f, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6f, 0x6e,
+0x3a, 0x67, 0x72, 0x65, 0x79, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6f,
+0x6e, 0x203c, 0xfe0f, 0x3a, 0x62, 0x61, 0x6e, 0x67, 0x62, 0x61, 0x6e, 0x67,
+0x3a, 0x62, 0x61, 0x6e, 0x67, 0x62, 0x61, 0x6e, 0x67, 0x2049, 0xfe0f, 0x3a,
+0x69, 0x6e, 0x74, 0x65, 0x72, 0x72, 0x6f, 0x62, 0x61, 0x6e, 0x67, 0x3a,
+0x69, 0x6e, 0x74, 0x65, 0x72, 0x72, 0x6f, 0x62, 0x61, 0x6e, 0x67, 0xd83d,
+0xdd05, 0x3a, 0x6c, 0x6f, 0x77, 0x5f, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74,
+0x6e, 0x65, 0x73, 0x73, 0x3a, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6e,
+0x65, 0x73, 0x73, 0x6c, 0x6f, 0x77, 0xd83d, 0xdd06, 0x3a, 0x68, 0x69, 0x67,
+0x68, 0x5f, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x65, 0x73, 0x73,
+0x3a, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x65, 0x73, 0x73, 0x68,
+0x69, 0x67, 0x68, 0x303d, 0xfe0f, 0x3a, 0x70, 0x61, 0x72, 0x74, 0x5f, 0x61,
+0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d,
+0x61, 0x72, 0x6b, 0x3a, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74,
+0x69, 0x6f, 0x6e, 0x6d, 0x61, 0x72, 0x6b, 0x70, 0x61, 0x72, 0x74, 0x26a0,
+0xfe0f, 0x3a, 0x77, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x3a, 0x77, 0x61,
+0x72, 0x6e, 0x69, 0x6e, 0x67, 0xd83d, 0xdeb8, 0x3a, 0x63, 0x68, 0x69, 0x6c,
+0x64, 0x72, 0x65, 0x6e, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x69, 0x6e,
+0x67, 0x3a, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x63, 0x72,
+0x6f, 0x73, 0x73, 0x69, 0x6e, 0x67, 0xd83d, 0xdd31, 0x3a, 0x74, 0x72, 0x69,
+0x64, 0x65, 0x6e, 0x74, 0x3a, 0x74, 0x72, 0x69, 0x64, 0x65, 0x6e, 0x74,
+0x269c, 0xfe0f, 0x3a, 0x66, 0x6c, 0x65, 0x75, 0x72, 0x2d, 0x64, 0x65, 0x2d,
+0x6c, 0x69, 0x73, 0x3a, 0x64, 0x65, 0x66, 0x6c, 0x65, 0x75, 0x72, 0x6c,
+0x69, 0x73, 0xd83d, 0xdd30, 0x3a, 0x62, 0x65, 0x67, 0x69, 0x6e, 0x6e, 0x65,
+0x72, 0x3a, 0x62, 0x65, 0x67, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x267b, 0xfe0f,
+0x3a, 0x72, 0x65, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x3a, 0x72, 0x65, 0x63,
+0x79, 0x63, 0x6c, 0x65, 0x2705, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f,
+0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x3a, 0x63,
+0x68, 0x65, 0x63, 0x6b, 0x6d, 0x61, 0x72, 0x6b, 0x77, 0x68, 0x69, 0x74,
+0x65, 0xd83c, 0xde2f, 0xfe0f, 0x3a, 0x75, 0x36, 0x33, 0x30, 0x37, 0x3a, 0x75,
+0x36, 0x33, 0x30, 0x37, 0xd83d, 0xdcb9, 0x3a, 0x63, 0x68, 0x61, 0x72, 0x74,
+0x3a, 0x63, 0x68, 0x61, 0x72, 0x74, 0x2747, 0xfe0f, 0x3a, 0x73, 0x70, 0x61,
+0x72, 0x6b, 0x6c, 0x65, 0x3a, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x6c, 0x65,
+0x2733, 0xfe0f, 0x3a, 0x65, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x73, 0x70, 0x6f,
+0x6b, 0x65, 0x64, 0x5f, 0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x73, 0x6b,
+0x3a, 0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x73, 0x6b, 0x65, 0x69, 0x67,
+0x68, 0x74, 0x73, 0x70, 0x6f, 0x6b, 0x65, 0x64, 0x274e, 0x3a, 0x6e, 0x65,
+0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72,
+0x65, 0x64, 0x5f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x5f, 0x6d, 0x61, 0x72,
+0x6b, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x6d, 0x61, 0x72, 0x6b, 0x6e,
+0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x71, 0x75, 0x61, 0x72,
+0x65, 0x64, 0xd83c, 0xdf10, 0x3a, 0x67, 0x6c, 0x6f, 0x62, 0x65, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x6d, 0x65, 0x72, 0x69, 0x64, 0x69, 0x61, 0x6e,
+0x73, 0x3a, 0x67, 0x6c, 0x6f, 0x62, 0x65, 0x6d, 0x65, 0x72, 0x69, 0x64,
+0x69, 0x61, 0x6e, 0x73, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdca0, 0x3a, 0x64,
+0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x70, 0x65,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x61, 0x5f, 0x64, 0x6f, 0x74, 0x5f,
+0x69, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x3a, 0x61, 0x64, 0x69, 0x61, 0x6d,
+0x6f, 0x6e, 0x64, 0x64, 0x6f, 0x74, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65,
+0x73, 0x68, 0x61, 0x70, 0x65, 0x77, 0x69, 0x74, 0x68, 0x24c2, 0xfe0f, 0x3a,
+0x6d, 0x3a, 0x6d, 0xd83c, 0xdf00, 0x3a, 0x63, 0x79, 0x63, 0x6c, 0x6f, 0x6e,
+0x65, 0x3a, 0x63, 0x79, 0x63, 0x6c, 0x6f, 0x6e, 0x65, 0xd83d, 0xdca4, 0x3a,
+0x7a, 0x7a, 0x7a, 0x3a, 0x7a, 0x7a, 0x7a, 0xd83c, 0xdfe7, 0x3a, 0x61, 0x74,
+0x6d, 0x3a, 0x61, 0x74, 0x6d, 0xd83d, 0xdebe, 0x3a, 0x77, 0x63, 0x3a, 0x77,
+0x63, 0x267f, 0xfe0f, 0x3a, 0x77, 0x68, 0x65, 0x65, 0x6c, 0x63, 0x68, 0x61,
+0x69, 0x72, 0x3a, 0x77, 0x68, 0x65, 0x65, 0x6c, 0x63, 0x68, 0x61, 0x69,
+0x72, 0xd83c, 0xdd7f, 0xfe0f, 0x3a, 0x70, 0x61, 0x72, 0x6b, 0x69, 0x6e, 0x67,
+0x3a, 0x70, 0x61, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0xd83c, 0xde33, 0x3a, 0x75,
+0x37, 0x61, 0x37, 0x61, 0x3a, 0x75, 0x37, 0x61, 0x37, 0x61, 0xd83c, 0xde02,
+0x3a, 0x73, 0x61, 0x3a, 0x73, 0x61, 0xd83d, 0xdec2, 0x3a, 0x70, 0x61, 0x73,
+0x73, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
+0x6c, 0x3a, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x70, 0x61, 0x73,
+0x73, 0x70, 0x6f, 0x72, 0x74, 0xd83d, 0xdec3, 0x3a, 0x63, 0x75, 0x73, 0x74,
+0x6f, 0x6d, 0x73, 0x3a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x73, 0xd83d,
+0xdec4, 0x3a, 0x62, 0x61, 0x67, 0x67, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x6c,
+0x61, 0x69, 0x6d, 0x3a, 0x62, 0x61, 0x67, 0x67, 0x61, 0x67, 0x65, 0x63,
+0x6c, 0x61, 0x69, 0x6d, 0xd83d, 0xdec5, 0x3a, 0x6c, 0x65, 0x66, 0x74, 0x5f,
+0x6c, 0x75, 0x67, 0x67, 0x61, 0x67, 0x65, 0x3a, 0x6c, 0x65, 0x66, 0x74,
+0x6c, 0x75, 0x67, 0x67, 0x61, 0x67, 0x65, 0xd83d, 0xdeb9, 0x3a, 0x6d, 0x65,
+0x6e, 0x73, 0x3a, 0x6d, 0x65, 0x6e, 0x73, 0xd83d, 0xdeba, 0x3a, 0x77, 0x6f,
+0x6d, 0x65, 0x6e, 0x73, 0x3a, 0x77, 0x6f, 0x6d, 0x65, 0x6e, 0x73, 0xd83d,
+0xdebc, 0x3a, 0x62, 0x61, 0x62, 0x79, 0x5f, 0x73, 0x79, 0x6d, 0x62, 0x6f,
+0x6c, 0x3a, 0x62, 0x61, 0x62, 0x79, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
+0xd83d, 0xdebb, 0x3a, 0x72, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x6f, 0x6d, 0x3a,
+0x72, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x6f, 0x6d, 0xd83d, 0xdeae, 0x3a, 0x70,
+0x75, 0x74, 0x5f, 0x6c, 0x69, 0x74, 0x74, 0x65, 0x72, 0x5f, 0x69, 0x6e,
+0x5f, 0x69, 0x74, 0x73, 0x5f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x3a, 0x69,
+0x6e, 0x69, 0x74, 0x73, 0x6c, 0x69, 0x74, 0x74, 0x65, 0x72, 0x70, 0x6c,
+0x61, 0x63, 0x65, 0x70, 0x75, 0x74, 0xd83c, 0xdfa6, 0x3a, 0x63, 0x69, 0x6e,
+0x65, 0x6d, 0x61, 0x3a, 0x63, 0x69, 0x6e, 0x65, 0x6d, 0x61, 0xd83d, 0xdcf6,
+0x3a, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x72, 0x65,
+0x6e, 0x67, 0x74, 0x68, 0x3a, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x73,
+0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0xd83c, 0xde01, 0x3a, 0x6b, 0x6f,
+0x6b, 0x6f, 0x3a, 0x6b, 0x6f, 0x6b, 0x6f, 0xd83d, 0xdd23, 0x3a, 0x73, 0x79,
+0x6d, 0x62, 0x6f, 0x6c, 0x73, 0x3a, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
+0x73, 0x2139, 0xfe0f, 0x3a, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x3a, 0x69,
+0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x6f,
+0x75, 0x72, 0x63, 0x65, 0xd83d, 0xdd24, 0x3a, 0x61, 0x62, 0x63, 0x3a, 0x61,
+0x62, 0x63, 0xd83d, 0xdd21, 0x3a, 0x61, 0x62, 0x63, 0x64, 0x3a, 0x61, 0x62,
+0x63, 0x64, 0xd83d, 0xdd20, 0x3a, 0x63, 0x61, 0x70, 0x69, 0x74, 0x61, 0x6c,
+0x5f, 0x61, 0x62, 0x63, 0x64, 0x3a, 0x61, 0x62, 0x63, 0x64, 0x63, 0x61,
+0x70, 0x69, 0x74, 0x61, 0x6c, 0xd83c, 0xdd96, 0x3a, 0x6e, 0x67, 0x3a, 0x6e,
+0x67, 0xd83c, 0xdd97, 0x3a, 0x6f, 0x6b, 0x3a, 0x6f, 0x6b, 0xd83c, 0xdd99, 0x3a,
+0x75, 0x70, 0x3a, 0x75, 0x70, 0xd83c, 0xdd92, 0x3a, 0x63, 0x6f, 0x6f, 0x6c,
+0x3a, 0x63, 0x6f, 0x6f, 0x6c, 0xd83c, 0xdd95, 0x3a, 0x6e, 0x65, 0x77, 0x3a,
+0x6e, 0x65, 0x77, 0xd83c, 0xdd93, 0x3a, 0x66, 0x72, 0x65, 0x65, 0x3a, 0x66,
+0x72, 0x65, 0x65, 0x30, 0xfe0f, 0x20e3, 0x3a, 0x7a, 0x65, 0x72, 0x6f, 0x3a,
+0x7a, 0x65, 0x72, 0x6f, 0x31, 0xfe0f, 0x20e3, 0x3a, 0x6f, 0x6e, 0x65, 0x3a,
+0x6f, 0x6e, 0x65, 0x32, 0xfe0f, 0x20e3, 0x3a, 0x74, 0x77, 0x6f, 0x3a, 0x74,
+0x77, 0x6f, 0x33, 0xfe0f, 0x20e3, 0x3a, 0x74, 0x68, 0x72, 0x65, 0x65, 0x3a,
+0x74, 0x68, 0x72, 0x65, 0x65, 0x34, 0xfe0f, 0x20e3, 0x3a, 0x66, 0x6f, 0x75,
+0x72, 0x3a, 0x66, 0x6f, 0x75, 0x72, 0x35, 0xfe0f, 0x20e3, 0x3a, 0x66, 0x69,
+0x76, 0x65, 0x3a, 0x66, 0x69, 0x76, 0x65, 0x36, 0xfe0f, 0x20e3, 0x3a, 0x73,
+0x69, 0x78, 0x3a, 0x73, 0x69, 0x78, 0x37, 0xfe0f, 0x20e3, 0x3a, 0x73, 0x65,
+0x76, 0x65, 0x6e, 0x3a, 0x73, 0x65, 0x76, 0x65, 0x6e, 0x38, 0xfe0f, 0x20e3,
+0x3a, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x65, 0x69, 0x67, 0x68, 0x74,
+0x39, 0xfe0f, 0x20e3, 0x3a, 0x6e, 0x69, 0x6e, 0x65, 0x3a, 0x6e, 0x69, 0x6e,
+0x65, 0xd83d, 0xdd1f, 0x3a, 0x6b, 0x65, 0x79, 0x63, 0x61, 0x70, 0x5f, 0x74,
+0x65, 0x6e, 0x3a, 0x6b, 0x65, 0x79, 0x63, 0x61, 0x70, 0x74, 0x65, 0x6e,
+0xd83d, 0xdd22, 0x3a, 0x31, 0x32, 0x33, 0x34, 0x3a, 0x31, 0x32, 0x33, 0x34,
+0x23, 0xfe0f, 0x20e3, 0x3a, 0x68, 0x61, 0x73, 0x68, 0x3a, 0x68, 0x61, 0x73,
+0x68, 0x2a, 0xfe0f, 0x20e3, 0x3a, 0x6b, 0x65, 0x79, 0x63, 0x61, 0x70, 0x5f,
+0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x73, 0x6b, 0x3a, 0x61, 0x73, 0x74,
+0x65, 0x72, 0x69, 0x73, 0x6b, 0x6b, 0x65, 0x79, 0x63, 0x61, 0x70, 0x2a,
+0xfe0f, 0x20e3, 0x3a, 0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x73, 0x6b, 0x3a,
+0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x73, 0x6b, 0x25b6, 0xfe0f, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x5f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
+0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,
+0x64, 0x23f8, 0x3a, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x5f, 0x76, 0x65,
+0x72, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x62, 0x61, 0x72, 0x3a, 0x62,
+0x61, 0x72, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x76, 0x65, 0x72, 0x74,
+0x69, 0x63, 0x61, 0x6c, 0x23f8, 0x3a, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f,
+0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x6f,
+0x6e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x23ef, 0x3a, 0x70, 0x6c, 0x61, 0x79,
+0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x3a, 0x70, 0x61, 0x75, 0x73, 0x65,
+0x70, 0x6c, 0x61, 0x79, 0x23f9, 0x3a, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x62,
+0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e,
+0x73, 0x74, 0x6f, 0x70, 0x23fa, 0x3a, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64,
+0x5f, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x75, 0x74, 0x74,
+0x6f, 0x6e, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x23ed, 0x3a, 0x6e, 0x65,
+0x78, 0x74, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x3a, 0x6e, 0x65, 0x78,
+0x74, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x23ed, 0x3a, 0x74, 0x72, 0x61, 0x63,
+0x6b, 0x5f, 0x6e, 0x65, 0x78, 0x74, 0x3a, 0x6e, 0x65, 0x78, 0x74, 0x74,
+0x72, 0x61, 0x63, 0x6b, 0x23ee, 0x3a, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f,
+0x75, 0x73, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x3a, 0x70, 0x72, 0x65,
+0x76, 0x69, 0x6f, 0x75, 0x73, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x23ee, 0x3a,
+0x74, 0x72, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f,
+0x75, 0x73, 0x3a, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x74,
+0x72, 0x61, 0x63, 0x6b, 0x23e9, 0x3a, 0x66, 0x61, 0x73, 0x74, 0x5f, 0x66,
+0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x3a, 0x66, 0x61, 0x73, 0x74, 0x66,
+0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x23ea, 0x3a, 0x72, 0x65, 0x77, 0x69,
+0x6e, 0x64, 0x3a, 0x72, 0x65, 0x77, 0x69, 0x6e, 0x64, 0x23eb, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x5f, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x5f,
+0x75, 0x70, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x64, 0x6f, 0x75, 0x62,
+0x6c, 0x65, 0x75, 0x70, 0x23ec, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f,
+0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x64,
+0x6f, 0x77, 0x6e, 0x25c0, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f,
+0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x3a, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0xd83d, 0xdd3c,
+0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x75, 0x70, 0x5f, 0x73, 0x6d,
+0x61, 0x6c, 0x6c, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x73, 0x6d, 0x61,
+0x6c, 0x6c, 0x75, 0x70, 0xd83d, 0xdd3d, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77,
+0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x3a,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x73, 0x6d, 0x61,
+0x6c, 0x6c, 0x27a1, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x72,
+0x69, 0x67, 0x68, 0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x72, 0x69,
+0x67, 0x68, 0x74, 0x2b05, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f,
+0x6c, 0x65, 0x66, 0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x6c, 0x65,
+0x66, 0x74, 0x2b06, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x75,
+0x70, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x75, 0x70, 0x2b07, 0xfe0f, 0x3a,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x2197, 0xfe0f, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x72,
+0x69, 0x67, 0x68, 0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x72, 0x69,
+0x67, 0x68, 0x74, 0x75, 0x70, 0x70, 0x65, 0x72, 0x2198, 0xfe0f, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x72,
+0x69, 0x67, 0x68, 0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x6c, 0x6f,
+0x77, 0x65, 0x72, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2199, 0xfe0f, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x6c,
+0x65, 0x66, 0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x6c, 0x65, 0x66,
+0x74, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x2196, 0xfe0f, 0x3a, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6c, 0x65, 0x66,
+0x74, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x6c, 0x65, 0x66, 0x74, 0x75,
+0x70, 0x70, 0x65, 0x72, 0x2195, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77,
+0x5f, 0x75, 0x70, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x75, 0x70, 0x2194, 0xfe0f, 0x3a, 0x6c,
+0x65, 0x66, 0x74, 0x5f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72,
+0x72, 0x6f, 0x77, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x6c, 0x65, 0x66,
+0x74, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21aa, 0xfe0f, 0x3a, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x5f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x6f, 0x6f,
+0x6b, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x68, 0x6f, 0x6f, 0x6b, 0x72,
+0x69, 0x67, 0x68, 0x74, 0x21a9, 0xfe0f, 0x3a, 0x6c, 0x65, 0x66, 0x74, 0x77,
+0x61, 0x72, 0x64, 0x73, 0x5f, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x77,
+0x69, 0x74, 0x68, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x3a, 0x61, 0x72, 0x72,
+0x6f, 0x77, 0x68, 0x6f, 0x6f, 0x6b, 0x6c, 0x65, 0x66, 0x74, 0x77, 0x61,
+0x72, 0x64, 0x73, 0x77, 0x69, 0x74, 0x68, 0x2934, 0xfe0f, 0x3a, 0x61, 0x72,
+0x72, 0x6f, 0x77, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x5f,
+0x75, 0x70, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x68, 0x65, 0x61, 0x64,
+0x69, 0x6e, 0x67, 0x75, 0x70, 0x2935, 0xfe0f, 0x3a, 0x61, 0x72, 0x72, 0x6f,
+0x77, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x6f,
+0x77, 0x6e, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e,
+0x68, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0xd83d, 0xdd00, 0x3a, 0x74, 0x77,
+0x69, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x77,
+0x61, 0x72, 0x64, 0x73, 0x5f, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x73, 0x3a,
+0x61, 0x72, 0x72, 0x6f, 0x77, 0x73, 0x72, 0x69, 0x67, 0x68, 0x74, 0x77,
+0x61, 0x72, 0x64, 0x73, 0x74, 0x77, 0x69, 0x73, 0x74, 0x65, 0x64, 0xd83d,
+0xdd01, 0x3a, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x3a, 0x72, 0x65, 0x70,
+0x65, 0x61, 0x74, 0xd83d, 0xdd02, 0x3a, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74,
+0x5f, 0x6f, 0x6e, 0x65, 0x3a, 0x6f, 0x6e, 0x65, 0x72, 0x65, 0x70, 0x65,
+0x61, 0x74, 0xd83d, 0xdd04, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x73, 0x5f,
+0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
+0x77, 0x69, 0x73, 0x65, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x73, 0x63,
+0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x77,
+0x69, 0x73, 0x65, 0xd83d, 0xdd03, 0x3a, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x73,
+0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x77, 0x69, 0x73, 0x65, 0x3a, 0x61,
+0x72, 0x72, 0x6f, 0x77, 0x73, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x77, 0x69,
+0x73, 0x65, 0xd83c, 0xdfb5, 0x3a, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x61, 0x6c,
+0x5f, 0x6e, 0x6f, 0x74, 0x65, 0x3a, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x61,
+0x6c, 0x6e, 0x6f, 0x74, 0x65, 0xd83c, 0xdfb6, 0x3a, 0x6e, 0x6f, 0x74, 0x65,
+0x73, 0x3a, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x2795, 0x3a, 0x68, 0x65, 0x61,
+0x76, 0x79, 0x5f, 0x70, 0x6c, 0x75, 0x73, 0x5f, 0x73, 0x69, 0x67, 0x6e,
+0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x70, 0x6c, 0x75, 0x73, 0x73, 0x69,
+0x67, 0x6e, 0x2796, 0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x5f, 0x6d, 0x69,
+0x6e, 0x75, 0x73, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x68, 0x65, 0x61,
+0x76, 0x79, 0x6d, 0x69, 0x6e, 0x75, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x2797,
+0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x5f, 0x64, 0x69, 0x76, 0x69, 0x73,
+0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x64, 0x69, 0x76,
+0x69, 0x73, 0x69, 0x6f, 0x6e, 0x68, 0x65, 0x61, 0x76, 0x79, 0x73, 0x69,
+0x67, 0x6e, 0x2716, 0xfe0f, 0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x5f, 0x6d,
+0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
+0x6e, 0x5f, 0x78, 0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x6d, 0x75, 0x6c,
+0x74, 0x69, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x78,
+0xd83d, 0xdcb2, 0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x5f, 0x64, 0x6f, 0x6c,
+0x6c, 0x61, 0x72, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x3a, 0x64, 0x6f, 0x6c,
+0x6c, 0x61, 0x72, 0x68, 0x65, 0x61, 0x76, 0x79, 0x73, 0x69, 0x67, 0x6e,
+0xd83d, 0xdcb1, 0x3a, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f,
+0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x3a, 0x63, 0x75, 0x72,
+0x72, 0x65, 0x6e, 0x63, 0x79, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67,
+0x65, 0x2122, 0x3a, 0x74, 0x6d, 0x3a, 0x74, 0x6d, 0xa9, 0x3a, 0x63, 0x6f,
+0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x3a, 0x63, 0x6f, 0x70, 0x79,
+0x72, 0x69, 0x67, 0x68, 0x74, 0xae, 0x3a, 0x72, 0x65, 0x67, 0x69, 0x73,
+0x74, 0x65, 0x72, 0x65, 0x64, 0x3a, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74,
+0x65, 0x72, 0x65, 0x64, 0x3030, 0x3a, 0x77, 0x61, 0x76, 0x79, 0x5f, 0x64,
+0x61, 0x73, 0x68, 0x3a, 0x64, 0x61, 0x73, 0x68, 0x77, 0x61, 0x76, 0x79,
+0x27b0, 0x3a, 0x63, 0x75, 0x72, 0x6c, 0x79, 0x5f, 0x6c, 0x6f, 0x6f, 0x70,
+0x3a, 0x63, 0x75, 0x72, 0x6c, 0x79, 0x6c, 0x6f, 0x6f, 0x70, 0x27bf, 0x3a,
+0x6c, 0x6f, 0x6f, 0x70, 0x3a, 0x6c, 0x6f, 0x6f, 0x70, 0xd83d, 0xdd1a, 0x3a,
+0x65, 0x6e, 0x64, 0x3a, 0x65, 0x6e, 0x64, 0xd83d, 0xdd19, 0x3a, 0x62, 0x61,
+0x63, 0x6b, 0x3a, 0x62, 0x61, 0x63, 0x6b, 0xd83d, 0xdd1b, 0x3a, 0x6f, 0x6e,
+0x3a, 0x6f, 0x6e, 0xd83d, 0xdd1d, 0x3a, 0x74, 0x6f, 0x70, 0x3a, 0x74, 0x6f,
+0x70, 0xd83d, 0xdd1c, 0x3a, 0x73, 0x6f, 0x6f, 0x6e, 0x3a, 0x73, 0x6f, 0x6f,
+0x6e, 0x2714, 0xfe0f, 0x3a, 0x68, 0x65, 0x61, 0x76, 0x79, 0x5f, 0x63, 0x68,
+0x65, 0x63, 0x6b, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x3a, 0x63, 0x68, 0x65,
+0x63, 0x6b, 0x68, 0x65, 0x61, 0x76, 0x79, 0x6d, 0x61, 0x72, 0x6b, 0x2611,
+0xfe0f, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x74, 0x5f, 0x62, 0x6f, 0x78,
+0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x3a,
+0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x74, 0x62, 0x6f, 0x78, 0x63, 0x68, 0x65,
+0x63, 0x6b, 0x77, 0x69, 0x74, 0x68, 0xd83d, 0xdd18, 0x3a, 0x72, 0x61, 0x64,
+0x69, 0x6f, 0x5f, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x75,
+0x74, 0x74, 0x6f, 0x6e, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x26aa, 0xfe0f, 0x3a,
+0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x63, 0x69, 0x72, 0x63, 0x6c, 0x65,
+0x3a, 0x63, 0x69, 0x72, 0x63, 0x6c, 0x65, 0x77, 0x68, 0x69, 0x74, 0x65,
+0x26ab, 0xfe0f, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x63, 0x69, 0x72,
+0x63, 0x6c, 0x65, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x63, 0x69, 0x72,
+0x63, 0x6c, 0x65, 0xd83d, 0xdd34, 0x3a, 0x72, 0x65, 0x64, 0x5f, 0x63, 0x69,
+0x72, 0x63, 0x6c, 0x65, 0x3a, 0x63, 0x69, 0x72, 0x63, 0x6c, 0x65, 0x72,
+0x65, 0x64, 0xd83d, 0xdd35, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x5f, 0x63, 0x69,
+0x72, 0x63, 0x6c, 0x65, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x63, 0x69, 0x72,
+0x63, 0x6c, 0x65, 0xd83d, 0xdd3a, 0x3a, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f,
+0x72, 0x65, 0x64, 0x5f, 0x74, 0x72, 0x69, 0x61, 0x6e, 0x67, 0x6c, 0x65,
+0x3a, 0x72, 0x65, 0x64, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x74, 0x72, 0x69,
+0x61, 0x6e, 0x67, 0x6c, 0x65, 0xd83d, 0xdd3b, 0x3a, 0x73, 0x6d, 0x61, 0x6c,
+0x6c, 0x5f, 0x72, 0x65, 0x64, 0x5f, 0x74, 0x72, 0x69, 0x61, 0x6e, 0x67,
+0x6c, 0x65, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x3a, 0x64, 0x6f, 0x77, 0x6e,
+0x72, 0x65, 0x64, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x74, 0x72, 0x69, 0x61,
+0x6e, 0x67, 0x6c, 0x65, 0xd83d, 0xdd38, 0x3a, 0x73, 0x6d, 0x61, 0x6c, 0x6c,
+0x5f, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x64, 0x69, 0x61, 0x6d,
+0x6f, 0x6e, 0x64, 0x3a, 0x64, 0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x6f,
+0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0xd83d, 0xdd39,
+0x3a, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x62, 0x6c, 0x75, 0x65, 0x5f,
+0x64, 0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x3a, 0x62, 0x6c, 0x75, 0x65,
+0x64, 0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x73, 0x6d, 0x61, 0x6c, 0x6c,
+0xd83d, 0xdd36, 0x3a, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x5f, 0x6f, 0x72, 0x61,
+0x6e, 0x67, 0x65, 0x5f, 0x64, 0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x3a,
+0x64, 0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x6c, 0x61, 0x72, 0x67, 0x65,
+0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0xd83d, 0xdd37, 0x3a, 0x6c, 0x61, 0x72,
+0x67, 0x65, 0x5f, 0x62, 0x6c, 0x75, 0x65, 0x5f, 0x64, 0x69, 0x61, 0x6d,
+0x6f, 0x6e, 0x64, 0x3a, 0x62, 0x6c, 0x75, 0x65, 0x64, 0x69, 0x61, 0x6d,
+0x6f, 0x6e, 0x64, 0x6c, 0x61, 0x72, 0x67, 0x65, 0xd83d, 0xdd33, 0x3a, 0x77,
+0x68, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x5f,
+0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62, 0x75, 0x74, 0x74, 0x6f,
+0x6e, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x77, 0x68, 0x69, 0x74, 0x65,
+0xd83d, 0xdd32, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x73, 0x71, 0x75,
+0x61, 0x72, 0x65, 0x5f, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x62,
+0x6c, 0x61, 0x63, 0x6b, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x73, 0x71,
+0x75, 0x61, 0x72, 0x65, 0x25aa, 0xfe0f, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x5f, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72,
+0x65, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x73, 0x6d, 0x61, 0x6c, 0x6c,
+0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x25ab, 0xfe0f, 0x3a, 0x77, 0x68, 0x69,
+0x74, 0x65, 0x5f, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x73, 0x71, 0x75,
+0x61, 0x72, 0x65, 0x3a, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x73, 0x71, 0x75,
+0x61, 0x72, 0x65, 0x77, 0x68, 0x69, 0x74, 0x65, 0x25fe, 0xfe0f, 0x3a, 0x62,
+0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x5f,
+0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65,
+0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d,
+0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x25fd,
+0xfe0f, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x64, 0x69,
+0x75, 0x6d, 0x5f, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x5f, 0x73, 0x71, 0x75,
+0x61, 0x72, 0x65, 0x3a, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x73, 0x6d,
+0x61, 0x6c, 0x6c, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x77, 0x68, 0x69,
+0x74, 0x65, 0x25fc, 0xfe0f, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x6d,
+0x65, 0x64, 0x69, 0x75, 0x6d, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65,
+0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d,
+0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x25fb, 0xfe0f, 0x3a, 0x77, 0x68, 0x69,
+0x74, 0x65, 0x5f, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x5f, 0x73, 0x71,
+0x75, 0x61, 0x72, 0x65, 0x3a, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x73,
+0x71, 0x75, 0x61, 0x72, 0x65, 0x77, 0x68, 0x69, 0x74, 0x65, 0x2b1b, 0xfe0f,
+0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x65,
+0x5f, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x3a, 0x62, 0x6c, 0x61, 0x63,
+0x6b, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65,
+0x2b1c, 0xfe0f, 0x3a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x6c, 0x61, 0x72,
+0x67, 0x65, 0x5f, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x3a, 0x6c, 0x61,
+0x72, 0x67, 0x65, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x77, 0x68, 0x69,
+0x74, 0x65, 0xd83d, 0xdd08, 0x3a, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72,
+0x3a, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0xd83d, 0xdd07, 0x3a, 0x6d,
+0x75, 0x74, 0x65, 0x3a, 0x6d, 0x75, 0x74, 0x65, 0xd83d, 0xdd09, 0x3a, 0x73,
+0x6f, 0x75, 0x6e, 0x64, 0x3a, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0xd83d, 0xdd0a,
+0x3a, 0x6c, 0x6f, 0x75, 0x64, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x3a,
+0x6c, 0x6f, 0x75, 0x64, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0xd83d, 0xdd14, 0x3a,
+0x62, 0x65, 0x6c, 0x6c, 0x3a, 0x62, 0x65, 0x6c, 0x6c, 0xd83d, 0xdd15, 0x3a,
+0x6e, 0x6f, 0x5f, 0x62, 0x65, 0x6c, 0x6c, 0x3a, 0x62, 0x65, 0x6c, 0x6c,
+0x6e, 0x6f, 0xd83d, 0xdce3, 0x3a, 0x6d, 0x65, 0x67, 0x61, 0x3a, 0x6d, 0x65,
+0x67, 0x61, 0xd83d, 0xdce2, 0x3a, 0x6c, 0x6f, 0x75, 0x64, 0x73, 0x70, 0x65,
+0x61, 0x6b, 0x65, 0x72, 0x3a, 0x6c, 0x6f, 0x75, 0x64, 0x73, 0x70, 0x65,
+0x61, 0x6b, 0x65, 0x72, 0xd83d, 0xdde8, 0x3a, 0x6c, 0x65, 0x66, 0x74, 0x5f,
+0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x5f, 0x62, 0x75, 0x62, 0x62, 0x6c,
+0x65, 0x3a, 0x62, 0x75, 0x62, 0x62, 0x6c, 0x65, 0x6c, 0x65, 0x66, 0x74,
+0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0xd83d, 0xdde8, 0x3a, 0x73, 0x70, 0x65,
+0x65, 0x63, 0x68, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x3a, 0x6c, 0x65, 0x66,
+0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0xd83d, 0xdc41, 0x200d, 0xd83d, 0xdde8,
+0x3a, 0x65, 0x79, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x73, 0x70, 0x65, 0x65,
+0x63, 0x68, 0x5f, 0x62, 0x75, 0x62, 0x62, 0x6c, 0x65, 0x3a, 0x62, 0x75,
+0x62, 0x62, 0x6c, 0x65, 0x65, 0x79, 0x65, 0x69, 0x6e, 0x73, 0x70, 0x65,
+0x65, 0x63, 0x68, 0xd83d, 0xdcac, 0x3a, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
+0x5f, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x6f, 0x6e, 0x3a, 0x62, 0x61, 0x6c,
+0x6c, 0x6f, 0x6f, 0x6e, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0xd83d, 0xdcad,
+0x3a, 0x74, 0x68, 0x6f, 0x75, 0x67, 0x68, 0x74, 0x5f, 0x62, 0x61, 0x6c,
+0x6c, 0x6f, 0x6f, 0x6e, 0x3a, 0x62, 0x61, 0x6c, 0x6c, 0x6f, 0x6f, 0x6e,
+0x74, 0x68, 0x6f, 0x75, 0x67, 0x68, 0x74, 0xd83d, 0xddef, 0x3a, 0x72, 0x69,
+0x67, 0x68, 0x74, 0x5f, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x5f, 0x62, 0x75,
+0x62, 0x62, 0x6c, 0x65, 0x3a, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x62, 0x75,
+0x62, 0x62, 0x6c, 0x65, 0x72, 0x69, 0x67, 0x68, 0x74, 0xd83d, 0xddef, 0x3a,
+0x61, 0x6e, 0x67, 0x65, 0x72, 0x5f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x3a,
+0x61, 0x6e, 0x67, 0x65, 0x72, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2660, 0xfe0f,
+0x3a, 0x73, 0x70, 0x61, 0x64, 0x65, 0x73, 0x3a, 0x73, 0x70, 0x61, 0x64,
+0x65, 0x73, 0x2663, 0xfe0f, 0x3a, 0x63, 0x6c, 0x75, 0x62, 0x73, 0x3a, 0x63,
+0x6c, 0x75, 0x62, 0x73, 0x2665, 0xfe0f, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74,
+0x73, 0x3a, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73, 0x2666, 0xfe0f, 0x3a, 0x64,
+0x69, 0x61, 0x6d, 0x6f, 0x6e, 0x64, 0x73, 0x3a, 0x64, 0x69, 0x61, 0x6d,
+0x6f, 0x6e, 0x64, 0x73, 0xd83c, 0xdccf, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x5f, 0x6a, 0x6f, 0x6b, 0x65, 0x72, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x6a, 0x6f, 0x6b, 0x65, 0x72, 0xd83c, 0xdfb4, 0x3a, 0x66, 0x6c, 0x6f, 0x77,
+0x65, 0x72, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x5f, 0x63,
+0x61, 0x72, 0x64, 0x73, 0x3a, 0x63, 0x61, 0x72, 0x64, 0x73, 0x66, 0x6c,
+0x6f, 0x77, 0x65, 0x72, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0xd83c,
+0xdc04, 0xfe0f, 0x3a, 0x6d, 0x61, 0x68, 0x6a, 0x6f, 0x6e, 0x67, 0x3a, 0x6d,
+0x61, 0x68, 0x6a, 0x6f, 0x6e, 0x67, 0xd83d, 0xdd50, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x31, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0xd83d, 0xdd51,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x32, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x32, 0xd83d, 0xdd52, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x33, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x33, 0xd83d, 0xdd53, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x34, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x34, 0xd83d, 0xdd54,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x35, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x35, 0xd83d, 0xdd55, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x36, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x36, 0xd83d, 0xdd56, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x37, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x37, 0xd83d, 0xdd57,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x38, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x38, 0xd83d, 0xdd58, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x39, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x39, 0xd83d, 0xdd59, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x31, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x30,
+0xd83d, 0xdd5a, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x31, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x31, 0xd83d, 0xdd5b, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x31, 0x32, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x32,
+0xd83d, 0xdd5c, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x33, 0x30, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x33, 0x30, 0xd83d, 0xdd5d, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x32, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x32, 0x33, 0x30, 0xd83d, 0xdd5e, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
+0x33, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x33, 0x33, 0x30,
+0xd83d, 0xdd5f, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x34, 0x33, 0x30, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x34, 0x33, 0x30, 0xd83d, 0xdd60, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x35, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x35, 0x33, 0x30, 0xd83d, 0xdd61, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
+0x36, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x36, 0x33, 0x30,
+0xd83d, 0xdd62, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x37, 0x33, 0x30, 0x3a,
+0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x37, 0x33, 0x30, 0xd83d, 0xdd63, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x38, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63,
+0x6b, 0x38, 0x33, 0x30, 0xd83d, 0xdd64, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b,
+0x39, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x39, 0x33, 0x30,
+0xd83d, 0xdd65, 0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x30, 0x33, 0x30,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x30, 0x33, 0x30, 0xd83d, 0xdd66,
+0x3a, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x31, 0x33, 0x30, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x31, 0x33, 0x30, 0xd83d, 0xdd67, 0x3a, 0x63,
+0x6c, 0x6f, 0x63, 0x6b, 0x31, 0x32, 0x33, 0x30, 0x3a, 0x63, 0x6c, 0x6f,
+0x63, 0x6b, 0x31, 0x32, 0x33, 0x30, 0xd83c, 0xdff3, 0x3a, 0x77, 0x61, 0x76,
+0x69, 0x6e, 0x67, 0x5f, 0x77, 0x68, 0x69, 0x74, 0x65, 0x5f, 0x66, 0x6c,
+0x61, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x77, 0x61, 0x76, 0x69, 0x6e,
+0x67, 0x77, 0x68, 0x69, 0x74, 0x65, 0xd83c, 0xdff3, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x77, 0x68, 0x69, 0x74, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x77, 0x68, 0x69, 0x74, 0x65, 0xd83c, 0xdff4, 0x3a, 0x77, 0x61, 0x76, 0x69,
+0x6e, 0x67, 0x5f, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x5f, 0x66, 0x6c, 0x61,
+0x67, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x66, 0x6c, 0x61, 0x67, 0x77,
+0x61, 0x76, 0x69, 0x6e, 0x67, 0xd83c, 0xdff4, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x3a, 0x62, 0x6c, 0x61, 0x63, 0x6b,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdfc1, 0x3a, 0x63, 0x68, 0x65, 0x63, 0x6b,
+0x65, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x3a, 0x63, 0x68,
+0x65, 0x63, 0x6b, 0x65, 0x72, 0x65, 0x64, 0x66, 0x6c, 0x61, 0x67, 0xd83d,
+0xdea9, 0x3a, 0x74, 0x72, 0x69, 0x61, 0x6e, 0x67, 0x75, 0x6c, 0x61, 0x72,
+0x5f, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6f, 0x6e, 0x5f, 0x70, 0x6f, 0x73,
+0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6f, 0x6e, 0x70, 0x6f, 0x73, 0x74,
+0x74, 0x72, 0x69, 0x61, 0x6e, 0x67, 0x75, 0x6c, 0x61, 0x72, 0xd83c, 0xdff3,
+0xfe0f, 0x200d, 0xd83c, 0xdf08, 0x3a, 0x67, 0x61, 0x79, 0x5f, 0x70, 0x72, 0x69,
+0x64, 0x65, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x67, 0x61, 0x79, 0x70, 0x72, 0x69, 0x64, 0x65, 0xd83c, 0xdff3, 0xfe0f, 0x200d,
+0xd83c, 0xdf08, 0x3a, 0x72, 0x61, 0x69, 0x6e, 0x62, 0x6f, 0x77, 0x5f, 0x66,
+0x6c, 0x61, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x72, 0x61, 0x69, 0x6e,
+0x62, 0x6f, 0x77, 0xd83c, 0xdde6, 0xd83c, 0xddeb, 0x3a, 0x61, 0x66, 0x3a, 0x61,
+0x66, 0xd83c, 0xdde6, 0xd83c, 0xddeb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61,
+0x66, 0x3a, 0x61, 0x66, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddfd,
+0x3a, 0x61, 0x78, 0x3a, 0x61, 0x78, 0xd83c, 0xdde6, 0xd83c, 0xddfd, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x61, 0x78, 0x3a, 0x61, 0x78, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xdde6, 0xd83c, 0xddf1, 0x3a, 0x61, 0x6c, 0x3a, 0x61, 0x6c, 0xd83c,
+0xdde6, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x6c, 0x3a,
+0x61, 0x6c, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde9, 0xd83c, 0xddff, 0x3a, 0x64,
+0x7a, 0x3a, 0x64, 0x7a, 0xd83c, 0xdde9, 0xd83c, 0xddff, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x64, 0x7a, 0x3a, 0x64, 0x7a, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xdde6, 0xd83c, 0xddf8, 0x3a, 0x61, 0x73, 0x3a, 0x61, 0x73, 0xd83c, 0xdde6, 0xd83c,
+0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x73, 0x3a, 0x61, 0x73,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xdde9, 0x3a, 0x61, 0x64, 0x3a,
+0x61, 0x64, 0xd83c, 0xdde6, 0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x61, 0x64, 0x3a, 0x61, 0x64, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c,
+0xddf4, 0x3a, 0x61, 0x6f, 0x3a, 0x61, 0x6f, 0xd83c, 0xdde6, 0xd83c, 0xddf4, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x6f, 0x3a, 0x61, 0x6f, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddee, 0x3a, 0x61, 0x69, 0x3a, 0x61, 0x69,
+0xd83c, 0xdde6, 0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x69,
+0x3a, 0x61, 0x69, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddf6, 0x3a,
+0x61, 0x71, 0x3a, 0x61, 0x71, 0xd83c, 0xdde6, 0xd83c, 0xddf6, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x61, 0x71, 0x3a, 0x61, 0x71, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xdde6, 0xd83c, 0xddec, 0x3a, 0x61, 0x67, 0x3a, 0x61, 0x67, 0xd83c, 0xdde6,
+0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x67, 0x3a, 0x61,
+0x67, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddf7, 0x3a, 0x61, 0x72,
+0x3a, 0x61, 0x72, 0xd83c, 0xdde6, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x61, 0x72, 0x3a, 0x61, 0x72, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6,
+0xd83c, 0xddf2, 0x3a, 0x61, 0x6d, 0x3a, 0x61, 0x6d, 0xd83c, 0xdde6, 0xd83c, 0xddf2,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x6d, 0x3a, 0x61, 0x6d, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddfc, 0x3a, 0x61, 0x77, 0x3a, 0x61,
+0x77, 0xd83c, 0xdde6, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61,
+0x77, 0x3a, 0x61, 0x77, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddfa,
+0x3a, 0x68, 0x6d, 0x3a, 0x68, 0x6d, 0xd83c, 0xdde6, 0xd83c, 0xddfa, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x68, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x68,
+0x6d, 0xd83c, 0xdde6, 0xd83c, 0xddfa, 0x3a, 0x61, 0x75, 0x3a, 0x61, 0x75, 0xd83c,
+0xdde6, 0xd83c, 0xddfa, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x75, 0x3a,
+0x61, 0x75, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde6, 0xd83c, 0xddf9, 0x3a, 0x61,
+0x74, 0x3a, 0x61, 0x74, 0xd83c, 0xdde6, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x61, 0x74, 0x3a, 0x61, 0x74, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xdde6, 0xd83c, 0xddff, 0x3a, 0x61, 0x7a, 0x3a, 0x61, 0x7a, 0xd83c, 0xdde6, 0xd83c,
+0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x61, 0x7a, 0x3a, 0x61, 0x7a,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf8, 0x3a, 0x62, 0x73, 0x3a,
+0x62, 0x73, 0xd83c, 0xdde7, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x62, 0x73, 0x3a, 0x62, 0x73, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c,
+0xdded, 0x3a, 0x62, 0x68, 0x3a, 0x62, 0x68, 0xd83c, 0xdde7, 0xd83c, 0xdded, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x68, 0x3a, 0x62, 0x68, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xdde9, 0x3a, 0x62, 0x64, 0x3a, 0x62, 0x64,
+0xd83c, 0xdde7, 0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x64,
+0x3a, 0x62, 0x64, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xdde7, 0x3a,
+0x62, 0x62, 0x3a, 0x62, 0x62, 0xd83c, 0xdde7, 0xd83c, 0xdde7, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x62, 0x62, 0x3a, 0x62, 0x62, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xdde7, 0xd83c, 0xddfe, 0x3a, 0x62, 0x79, 0x3a, 0x62, 0x79, 0xd83c, 0xdde7,
+0xd83c, 0xddfe, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x79, 0x3a, 0x62,
+0x79, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddea, 0x3a, 0x62, 0x65,
+0x3a, 0x62, 0x65, 0xd83c, 0xdde7, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x62, 0x65, 0x3a, 0x62, 0x65, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7,
+0xd83c, 0xddff, 0x3a, 0x62, 0x7a, 0x3a, 0x62, 0x7a, 0xd83c, 0xdde7, 0xd83c, 0xddff,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x7a, 0x3a, 0x62, 0x7a, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddef, 0x3a, 0x62, 0x6a, 0x3a, 0x62,
+0x6a, 0xd83c, 0xdde7, 0xd83c, 0xddef, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62,
+0x6a, 0x3a, 0x62, 0x6a, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf2,
+0x3a, 0x62, 0x6d, 0x3a, 0x62, 0x6d, 0xd83c, 0xdde7, 0xd83c, 0xddf2, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x62, 0x6d, 0x3a, 0x62, 0x6d, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf9, 0x3a, 0x62, 0x74, 0x3a, 0x62, 0x74, 0xd83c,
+0xdde7, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x74, 0x3a,
+0x62, 0x74, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf4, 0x3a, 0x62,
+0x6f, 0x3a, 0x62, 0x6f, 0xd83c, 0xdde7, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x62, 0x6f, 0x3a, 0x62, 0x6f, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xdde7, 0xd83c, 0xdde6, 0x3a, 0x62, 0x61, 0x3a, 0x62, 0x61, 0xd83c, 0xdde7, 0xd83c,
+0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x61, 0x3a, 0x62, 0x61,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddfc, 0x3a, 0x62, 0x77, 0x3a,
+0x62, 0x77, 0xd83c, 0xdde7, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x62, 0x77, 0x3a, 0x62, 0x77, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c,
+0xddf7, 0x3a, 0x62, 0x72, 0x3a, 0x62, 0x72, 0xd83c, 0xdde7, 0xd83c, 0xddf7, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x72, 0x3a, 0x62, 0x72, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xddee, 0xd83c, 0xddf4, 0x3a, 0x69, 0x6f, 0x3a, 0x69, 0x6f,
+0xd83c, 0xddee, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69, 0x6f,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x6f, 0xd83c, 0xddee, 0xd83c, 0xddf4, 0x3a,
+0x64, 0x67, 0x3a, 0x64, 0x67, 0xd83c, 0xddee, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x64, 0x67, 0x3a, 0x64, 0x67, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xddfb, 0xd83c, 0xddec, 0x3a, 0x76, 0x67, 0x3a, 0x76, 0x67, 0xd83c, 0xddfb,
+0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x76, 0x67, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x76, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf3, 0x3a, 0x62, 0x6e,
+0x3a, 0x62, 0x6e, 0xd83c, 0xdde7, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x62, 0x6e, 0x3a, 0x62, 0x6e, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7,
+0xd83c, 0xddec, 0x3a, 0x62, 0x67, 0x3a, 0x62, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddec,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x67, 0x3a, 0x62, 0x67, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddeb, 0x3a, 0x62, 0x66, 0x3a, 0x62,
+0x66, 0xd83c, 0xdde7, 0xd83c, 0xddeb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62,
+0x66, 0x3a, 0x62, 0x66, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddee,
+0x3a, 0x62, 0x69, 0x3a, 0x62, 0x69, 0xd83c, 0xdde7, 0xd83c, 0xddee, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x62, 0x69, 0x3a, 0x62, 0x69, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xddf0, 0xd83c, 0xdded, 0x3a, 0x6b, 0x68, 0x3a, 0x6b, 0x68, 0xd83c,
+0xddf0, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x68, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x6b, 0x68, 0xd83c, 0xdde8, 0xd83c, 0xddf2, 0x3a, 0x63,
+0x6d, 0x3a, 0x63, 0x6d, 0xd83c, 0xdde8, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x63, 0x6d, 0x3a, 0x63, 0x6d, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xdde8, 0xd83c, 0xdde6, 0x3a, 0x63, 0x61, 0x3a, 0x63, 0x61, 0xd83c, 0xdde8, 0xd83c,
+0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x61, 0x3a, 0x63, 0x61,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddee, 0xd83c, 0xdde8, 0x3a, 0x69, 0x63, 0x3a,
+0x69, 0x63, 0xd83c, 0xddee, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x69, 0x63, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x63, 0xd83c, 0xdde8, 0xd83c,
+0xddfb, 0x3a, 0x63, 0x76, 0x3a, 0x63, 0x76, 0xd83c, 0xdde8, 0xd83c, 0xddfb, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x76, 0x3a, 0x63, 0x76, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xdde7, 0xd83c, 0xddf6, 0x3a, 0x62, 0x71, 0x3a, 0x62, 0x71,
+0xd83c, 0xdde7, 0xd83c, 0xddf6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x71,
+0x3a, 0x62, 0x71, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf0, 0xd83c, 0xddfe, 0x3a,
+0x6b, 0x79, 0x3a, 0x6b, 0x79, 0xd83c, 0xddf0, 0xd83c, 0xddfe, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x6b, 0x79, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b, 0x79,
+0xd83c, 0xdde8, 0xd83c, 0xddeb, 0x3a, 0x63, 0x66, 0x3a, 0x63, 0x66, 0xd83c, 0xdde8,
+0xd83c, 0xddeb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x66, 0x3a, 0x63,
+0x66, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf9, 0xd83c, 0xdde9, 0x3a, 0x74, 0x64,
+0x3a, 0x74, 0x64, 0xd83c, 0xddf9, 0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x74, 0x64, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x64, 0xd83c, 0xdde8,
+0xd83c, 0xddf1, 0x3a, 0x63, 0x68, 0x69, 0x6c, 0x65, 0x3a, 0x63, 0x68, 0x69,
+0x6c, 0x65, 0xd83c, 0xdde8, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x63, 0x6c, 0x3a, 0x63, 0x6c, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c,
+0xddf3, 0x3a, 0x63, 0x6e, 0x3a, 0x63, 0x6e, 0xd83c, 0xdde8, 0xd83c, 0xddf3, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x6e, 0x3a, 0x63, 0x6e, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddfd, 0x3a, 0x63, 0x78, 0x3a, 0x63, 0x78,
+0xd83c, 0xdde8, 0xd83c, 0xddfd, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x78,
+0x3a, 0x63, 0x78, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xdde8, 0x3a,
+0x63, 0x63, 0x3a, 0x63, 0x63, 0xd83c, 0xdde8, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x63, 0x63, 0x3a, 0x63, 0x63, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xdde8, 0xd83c, 0xddf4, 0x3a, 0x63, 0x6f, 0x3a, 0x63, 0x6f, 0xd83c, 0xdde8,
+0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x6f, 0x3a, 0x63,
+0x6f, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf0, 0xd83c, 0xddf2, 0x3a, 0x6b, 0x6d,
+0x3a, 0x6b, 0x6d, 0xd83c, 0xddf0, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6b, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b, 0x6d, 0xd83c, 0xdde8,
+0xd83c, 0xddec, 0x3a, 0x63, 0x67, 0x3a, 0x63, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddec,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x67, 0x3a, 0x63, 0x67, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xdde9, 0x3a, 0x63, 0x6f, 0x6e, 0x67,
+0x6f, 0x3a, 0x63, 0x6f, 0x6e, 0x67, 0x6f, 0xd83c, 0xdde8, 0xd83c, 0xdde9, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x64, 0x3a, 0x63, 0x64, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddf0, 0x3a, 0x63, 0x6b, 0x3a, 0x63, 0x6b,
+0xd83c, 0xdde8, 0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x6b,
+0x3a, 0x63, 0x6b, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddf7, 0x3a,
+0x63, 0x72, 0x3a, 0x63, 0x72, 0xd83c, 0xdde8, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x63, 0x72, 0x3a, 0x63, 0x72, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xdde8, 0xd83c, 0xddee, 0x3a, 0x63, 0x69, 0x3a, 0x63, 0x69, 0xd83c, 0xdde8,
+0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x69, 0x3a, 0x63,
+0x69, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdded, 0xd83c, 0xddf7, 0x3a, 0x68, 0x72,
+0x3a, 0x68, 0x72, 0xd83c, 0xdded, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x68, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x68, 0x72, 0xd83c, 0xdde8,
+0xd83c, 0xddfa, 0x3a, 0x63, 0x75, 0x3a, 0x63, 0x75, 0xd83c, 0xdde8, 0xd83c, 0xddfa,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x75, 0x3a, 0x63, 0x75, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddfc, 0x3a, 0x63, 0x77, 0x3a, 0x63,
+0x77, 0xd83c, 0xdde8, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63,
+0x77, 0x3a, 0x63, 0x77, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde8, 0xd83c, 0xddfe,
+0x3a, 0x63, 0x79, 0x3a, 0x63, 0x79, 0xd83c, 0xdde8, 0xd83c, 0xddfe, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x63, 0x79, 0x3a, 0x63, 0x79, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xdde8, 0xd83c, 0xddff, 0x3a, 0x63, 0x7a, 0x3a, 0x63, 0x7a, 0xd83c,
+0xdde8, 0xd83c, 0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x7a, 0x3a,
+0x63, 0x7a, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde9, 0xd83c, 0xddf0, 0x3a, 0x64,
+0x6b, 0x3a, 0x64, 0x6b, 0xd83c, 0xdde9, 0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x64, 0x6b, 0x3a, 0x64, 0x6b, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xdde9, 0xd83c, 0xddef, 0x3a, 0x64, 0x6a, 0x3a, 0x64, 0x6a, 0xd83c, 0xdde9, 0xd83c,
+0xddef, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x64, 0x6a, 0x3a, 0x64, 0x6a,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde9, 0xd83c, 0xddf2, 0x3a, 0x64, 0x6d, 0x3a,
+0x64, 0x6d, 0xd83c, 0xdde9, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x64, 0x6d, 0x3a, 0x64, 0x6d, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xdde9, 0xd83c,
+0xddf4, 0x3a, 0x64, 0x6f, 0x3a, 0x64, 0x6f, 0xd83c, 0xdde9, 0xd83c, 0xddf4, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x64, 0x6f, 0x3a, 0x64, 0x6f, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xddea, 0xd83c, 0xdde8, 0x3a, 0x65, 0x63, 0x3a, 0x65, 0x63,
+0xd83c, 0xddea, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65, 0x63,
+0x3a, 0x65, 0x63, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddea, 0xd83c, 0xddec, 0x3a,
+0x65, 0x67, 0x3a, 0x65, 0x67, 0xd83c, 0xddea, 0xd83c, 0xddec, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x65, 0x67, 0x3a, 0x65, 0x67, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xddf8, 0xd83c, 0xddfb, 0x3a, 0x73, 0x76, 0x3a, 0x73, 0x76, 0xd83c, 0xddf8,
+0xd83c, 0xddfb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x76, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x73, 0x76, 0xd83c, 0xddec, 0xd83c, 0xddf6, 0x3a, 0x67, 0x71,
+0x3a, 0x67, 0x71, 0xd83c, 0xddec, 0xd83c, 0xddf6, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x67, 0x71, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x71, 0xd83c, 0xddea,
+0xd83c, 0xddf7, 0x3a, 0x65, 0x72, 0x3a, 0x65, 0x72, 0xd83c, 0xddea, 0xd83c, 0xddf7,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65, 0x72, 0x3a, 0x65, 0x72, 0x66,
+0x6c, 0x61, 0x67, 0xd83c, 0xddea, 0xd83c, 0xddea, 0x3a, 0x65, 0x65, 0x3a, 0x65,
+0x65, 0xd83c, 0xddea, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65,
+0x65, 0x3a, 0x65, 0x65, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddea, 0xd83c, 0xddf9,
+0x3a, 0x65, 0x74, 0x3a, 0x65, 0x74, 0xd83c, 0xddea, 0xd83c, 0xddf9, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x65, 0x74, 0x3a, 0x65, 0x74, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xddea, 0xd83c, 0xddfa, 0x3a, 0x65, 0x75, 0x3a, 0x65, 0x75, 0xd83c,
+0xddea, 0xd83c, 0xddfa, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65, 0x75, 0x3a,
+0x65, 0x75, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddeb, 0xd83c, 0xddf0, 0x3a, 0x66,
+0x6b, 0x3a, 0x66, 0x6b, 0xd83c, 0xddeb, 0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x66, 0x6b, 0x3a, 0x66, 0x6b, 0x66, 0x6c, 0x61, 0x67, 0xd83c,
+0xddeb, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6f, 0x3a, 0x66, 0x6f, 0xd83c, 0xddeb, 0xd83c,
+0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x66, 0x6f, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x66, 0x6f, 0xd83c, 0xddeb, 0xd83c, 0xddef, 0x3a, 0x66, 0x6a, 0x3a,
+0x66, 0x6a, 0xd83c, 0xddeb, 0xd83c, 0xddef, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x66, 0x6a, 0x3a, 0x66, 0x6a, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddeb, 0xd83c,
+0xddee, 0x3a, 0x66, 0x69, 0x3a, 0x66, 0x69, 0xd83c, 0xddeb, 0xd83c, 0xddee, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x66, 0x69, 0x3a, 0x66, 0x69, 0x66, 0x6c,
+0x61, 0x67, 0xd83c, 0xddeb, 0xd83c, 0xddf7, 0x3a, 0x6d, 0x66, 0x3a, 0x6d, 0x66,
+0xd83c, 0xddeb, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x66,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x66, 0xd83c, 0xddeb, 0xd83c, 0xddf7, 0x3a,
+0x66, 0x72, 0x3a, 0x66, 0x72, 0xd83c, 0xddeb, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x66, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x66, 0x72,
+0xd83c, 0xddeb, 0xd83c, 0xddf7, 0x3a, 0x63, 0x70, 0x3a, 0x63, 0x70, 0xd83c, 0xddeb,
+0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x70, 0x3a, 0x63,
+0x70, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddec, 0xd83c, 0xddeb, 0x3a, 0x67, 0x66,
+0x3a, 0x67, 0x66, 0xd83c, 0xddec, 0xd83c, 0xddeb, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x67, 0x66, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x66, 0xd83c, 0xddf5,
+0xd83c, 0xddeb, 0x3a, 0x70, 0x66, 0x3a, 0x70, 0x66, 0xd83c, 0xddf5, 0xd83c, 0xddeb,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x66, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x70, 0x66, 0xd83c, 0xddf9, 0xd83c, 0xddeb, 0x3a, 0x74, 0x66, 0x3a, 0x74,
+0x66, 0xd83c, 0xddf9, 0xd83c, 0xddeb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74,
+0x66, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x66, 0xd83c, 0xddec, 0xd83c, 0xdde6,
+0x3a, 0x67, 0x61, 0x3a, 0x67, 0x61, 0xd83c, 0xddec, 0xd83c, 0xdde6, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x67, 0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67,
+0x61, 0xd83c, 0xddec, 0xd83c, 0xddf2, 0x3a, 0x67, 0x6d, 0x3a, 0x67, 0x6d, 0xd83c,
+0xddec, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x6d, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x67, 0x6d, 0xd83c, 0xddec, 0xd83c, 0xddea, 0x3a, 0x67,
+0x65, 0x3a, 0x67, 0x65, 0xd83c, 0xddec, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x67, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x65, 0xd83c,
+0xdde9, 0xd83c, 0xddea, 0x3a, 0x64, 0x65, 0x3a, 0x64, 0x65, 0xd83c, 0xdde9, 0xd83c,
+0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x64, 0x65, 0x3a, 0x64, 0x65,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddec, 0xd83c, 0xdded, 0x3a, 0x67, 0x68, 0x3a,
+0x67, 0x68, 0xd83c, 0xddec, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x67, 0x68, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x68, 0xd83c, 0xddec, 0xd83c,
+0xddee, 0x3a, 0x67, 0x69, 0x3a, 0x67, 0x69, 0xd83c, 0xddec, 0xd83c, 0xddee, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x69, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x67, 0x69, 0xd83c, 0xddec, 0xd83c, 0xddf7, 0x3a, 0x67, 0x72, 0x3a, 0x67, 0x72,
+0xd83c, 0xddec, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x72,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x72, 0xd83c, 0xddec, 0xd83c, 0xddf1, 0x3a,
+0x67, 0x6c, 0x3a, 0x67, 0x6c, 0xd83c, 0xddec, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x67, 0x6c, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x6c,
+0xd83c, 0xddec, 0xd83c, 0xdde9, 0x3a, 0x67, 0x64, 0x3a, 0x67, 0x64, 0xd83c, 0xddec,
+0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x64, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x67, 0x64, 0xd83c, 0xddec, 0xd83c, 0xddf5, 0x3a, 0x67, 0x70,
+0x3a, 0x67, 0x70, 0xd83c, 0xddec, 0xd83c, 0xddf5, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x67, 0x70, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x70, 0xd83c, 0xddec,
+0xd83c, 0xddfa, 0x3a, 0x67, 0x75, 0x3a, 0x67, 0x75, 0xd83c, 0xddec, 0xd83c, 0xddfa,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x75, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x67, 0x75, 0xd83c, 0xddec, 0xd83c, 0xddf9, 0x3a, 0x67, 0x74, 0x3a, 0x67,
+0x74, 0xd83c, 0xddec, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67,
+0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x74, 0xd83c, 0xddec, 0xd83c, 0xddec,
+0x3a, 0x67, 0x67, 0x3a, 0x67, 0x67, 0xd83c, 0xddec, 0xd83c, 0xddec, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x67, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67,
+0x67, 0xd83c, 0xddec, 0xd83c, 0xddf3, 0x3a, 0x67, 0x6e, 0x3a, 0x67, 0x6e, 0xd83c,
+0xddec, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x6e, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x67, 0x6e, 0xd83c, 0xddec, 0xd83c, 0xddfc, 0x3a, 0x67,
+0x77, 0x3a, 0x67, 0x77, 0xd83c, 0xddec, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x67, 0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67, 0x77, 0xd83c,
+0xddec, 0xd83c, 0xddfe, 0x3a, 0x67, 0x79, 0x3a, 0x67, 0x79, 0xd83c, 0xddec, 0xd83c,
+0xddfe, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x79, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x67, 0x79, 0xd83c, 0xdded, 0xd83c, 0xddf9, 0x3a, 0x68, 0x74, 0x3a,
+0x68, 0x74, 0xd83c, 0xdded, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x68, 0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x68, 0x74, 0xd83c, 0xdded, 0xd83c,
+0xddf3, 0x3a, 0x68, 0x6e, 0x3a, 0x68, 0x6e, 0xd83c, 0xdded, 0xd83c, 0xddf3, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x68, 0x6e, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x68, 0x6e, 0xd83c, 0xdded, 0xd83c, 0xddf0, 0x3a, 0x68, 0x6b, 0x3a, 0x68, 0x6b,
+0xd83c, 0xdded, 0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x68, 0x6b,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x68, 0x6b, 0xd83c, 0xdded, 0xd83c, 0xddfa, 0x3a,
+0x68, 0x75, 0x3a, 0x68, 0x75, 0xd83c, 0xdded, 0xd83c, 0xddfa, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x68, 0x75, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x68, 0x75,
+0xd83c, 0xddee, 0xd83c, 0xddf8, 0x3a, 0x69, 0x73, 0x3a, 0x69, 0x73, 0xd83c, 0xddee,
+0xd83c, 0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69, 0x73, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x69, 0x73, 0xd83c, 0xddee, 0xd83c, 0xddf3, 0x3a, 0x69, 0x6e,
+0x3a, 0x69, 0x6e, 0xd83c, 0xddee, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x69, 0x6e, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x6e, 0xd83c, 0xddee,
+0xd83c, 0xdde9, 0x3a, 0x69, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x73, 0x69, 0x61,
+0x3a, 0x69, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x73, 0x69, 0x61, 0xd83c, 0xddee,
+0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69, 0x64, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x69, 0x64, 0xd83c, 0xddee, 0xd83c, 0xddf7, 0x3a, 0x69, 0x72,
+0x3a, 0x69, 0x72, 0xd83c, 0xddee, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x69, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x72, 0xd83c, 0xddee,
+0xd83c, 0xddf6, 0x3a, 0x69, 0x71, 0x3a, 0x69, 0x71, 0xd83c, 0xddee, 0xd83c, 0xddf6,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69, 0x71, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x69, 0x71, 0xd83c, 0xddee, 0xd83c, 0xddea, 0x3a, 0x69, 0x65, 0x3a, 0x69,
+0x65, 0xd83c, 0xddee, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69,
+0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x65, 0xd83c, 0xddee, 0xd83c, 0xddf2,
+0x3a, 0x69, 0x6d, 0x3a, 0x69, 0x6d, 0xd83c, 0xddee, 0xd83c, 0xddf2, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x69, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69,
+0x6d, 0xd83c, 0xddee, 0xd83c, 0xddf1, 0x3a, 0x69, 0x6c, 0x3a, 0x69, 0x6c, 0xd83c,
+0xddee, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x69, 0x6c, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x69, 0x6c, 0xd83c, 0xddee, 0xd83c, 0xddf9, 0x3a, 0x69,
+0x74, 0x3a, 0x69, 0x74, 0xd83c, 0xddee, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x69, 0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x69, 0x74, 0xd83c,
+0xddef, 0xd83c, 0xddf2, 0x3a, 0x6a, 0x6d, 0x3a, 0x6a, 0x6d, 0xd83c, 0xddef, 0xd83c,
+0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6a, 0x6d, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x6a, 0x6d, 0xd83c, 0xddef, 0xd83c, 0xddf5, 0x3a, 0x6a, 0x70, 0x3a,
+0x6a, 0x70, 0xd83c, 0xddef, 0xd83c, 0xddf5, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6a, 0x70, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6a, 0x70, 0xd83c, 0xdf8c, 0x3a,
+0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x66, 0x6c, 0x61, 0x67,
+0x73, 0x3a, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x65, 0x64, 0x66, 0x6c, 0x61,
+0x67, 0x73, 0xd83c, 0xddef, 0xd83c, 0xddea, 0x3a, 0x6a, 0x65, 0x3a, 0x6a, 0x65,
+0xd83c, 0xddef, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6a, 0x65,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6a, 0x65, 0xd83c, 0xddef, 0xd83c, 0xddf4, 0x3a,
+0x6a, 0x6f, 0x3a, 0x6a, 0x6f, 0xd83c, 0xddef, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x6a, 0x6f, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6a, 0x6f,
+0xd83c, 0xddf0, 0xd83c, 0xddff, 0x3a, 0x6b, 0x7a, 0x3a, 0x6b, 0x7a, 0xd83c, 0xddf0,
+0xd83c, 0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x7a, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6b, 0x7a, 0xd83c, 0xddf0, 0xd83c, 0xddea, 0x3a, 0x6b, 0x65,
+0x3a, 0x6b, 0x65, 0xd83c, 0xddf0, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6b, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b, 0x65, 0xd83c, 0xddf0,
+0xd83c, 0xddee, 0x3a, 0x6b, 0x69, 0x3a, 0x6b, 0x69, 0xd83c, 0xddf0, 0xd83c, 0xddee,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x69, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x6b, 0x69, 0xd83c, 0xddfd, 0xd83c, 0xddf0, 0x3a, 0x78, 0x6b, 0x3a, 0x78,
+0x6b, 0xd83c, 0xddfd, 0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x78,
+0x6b, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x78, 0x6b, 0xd83c, 0xddf0, 0xd83c, 0xddfc,
+0x3a, 0x6b, 0x77, 0x3a, 0x6b, 0x77, 0xd83c, 0xddf0, 0xd83c, 0xddfc, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b,
+0x77, 0xd83c, 0xddf0, 0xd83c, 0xddec, 0x3a, 0x6b, 0x67, 0x3a, 0x6b, 0x67, 0xd83c,
+0xddf0, 0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x67, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x6b, 0x67, 0xd83c, 0xddf1, 0xd83c, 0xdde6, 0x3a, 0x6c,
+0x61, 0x3a, 0x6c, 0x61, 0xd83c, 0xddf1, 0xd83c, 0xdde6, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6c, 0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x61, 0xd83c,
+0xddf1, 0xd83c, 0xddfb, 0x3a, 0x6c, 0x76, 0x3a, 0x6c, 0x76, 0xd83c, 0xddf1, 0xd83c,
+0xddfb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x76, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x6c, 0x76, 0xd83c, 0xddf1, 0xd83c, 0xdde7, 0x3a, 0x6c, 0x62, 0x3a,
+0x6c, 0x62, 0xd83c, 0xddf1, 0xd83c, 0xdde7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6c, 0x62, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x62, 0xd83c, 0xddf1, 0xd83c,
+0xddf8, 0x3a, 0x6c, 0x73, 0x3a, 0x6c, 0x73, 0xd83c, 0xddf1, 0xd83c, 0xddf8, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x6c, 0x73, 0xd83c, 0xddf1, 0xd83c, 0xddf7, 0x3a, 0x6c, 0x72, 0x3a, 0x6c, 0x72,
+0xd83c, 0xddf1, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x72,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x72, 0xd83c, 0xddf1, 0xd83c, 0xddfe, 0x3a,
+0x6c, 0x79, 0x3a, 0x6c, 0x79, 0xd83c, 0xddf1, 0xd83c, 0xddfe, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x6c, 0x79, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x79,
+0xd83c, 0xddf1, 0xd83c, 0xddee, 0x3a, 0x6c, 0x69, 0x3a, 0x6c, 0x69, 0xd83c, 0xddf1,
+0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x69, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6c, 0x69, 0xd83c, 0xddf1, 0xd83c, 0xddf9, 0x3a, 0x6c, 0x74,
+0x3a, 0x6c, 0x74, 0xd83c, 0xddf1, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6c, 0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x74, 0xd83c, 0xddf1,
+0xd83c, 0xddfa, 0x3a, 0x6c, 0x75, 0x3a, 0x6c, 0x75, 0xd83c, 0xddf1, 0xd83c, 0xddfa,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x75, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x6c, 0x75, 0xd83c, 0xddf2, 0xd83c, 0xddf4, 0x3a, 0x6d, 0x6f, 0x3a, 0x6d,
+0x6f, 0xd83c, 0xddf2, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d,
+0x6f, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x6f, 0xd83c, 0xddf2, 0xd83c, 0xddf0,
+0x3a, 0x6d, 0x6b, 0x3a, 0x6d, 0x6b, 0xd83c, 0xddf2, 0xd83c, 0xddf0, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x6b, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d,
+0x6b, 0xd83c, 0xddf2, 0xd83c, 0xddec, 0x3a, 0x6d, 0x67, 0x3a, 0x6d, 0x67, 0xd83c,
+0xddf2, 0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x67, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x6d, 0x67, 0xd83c, 0xddf2, 0xd83c, 0xddfc, 0x3a, 0x6d,
+0x77, 0x3a, 0x6d, 0x77, 0xd83c, 0xddf2, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6d, 0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x77, 0xd83c,
+0xddf2, 0xd83c, 0xddfe, 0x3a, 0x6d, 0x79, 0x3a, 0x6d, 0x79, 0xd83c, 0xddf2, 0xd83c,
+0xddfe, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x79, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x6d, 0x79, 0xd83c, 0xddf2, 0xd83c, 0xddfb, 0x3a, 0x6d, 0x76, 0x3a,
+0x6d, 0x76, 0xd83c, 0xddf2, 0xd83c, 0xddfb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6d, 0x76, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x76, 0xd83c, 0xddf2, 0xd83c,
+0xddf1, 0x3a, 0x6d, 0x6c, 0x3a, 0x6d, 0x6c, 0xd83c, 0xddf2, 0xd83c, 0xddf1, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x6c, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x6d, 0x6c, 0xd83c, 0xddf2, 0xd83c, 0xddf9, 0x3a, 0x6d, 0x74, 0x3a, 0x6d, 0x74,
+0xd83c, 0xddf2, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x74,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x74, 0xd83c, 0xddf2, 0xd83c, 0xdded, 0x3a,
+0x6d, 0x68, 0x3a, 0x6d, 0x68, 0xd83c, 0xddf2, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x6d, 0x68, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x68,
+0xd83c, 0xddf2, 0xd83c, 0xddf6, 0x3a, 0x6d, 0x71, 0x3a, 0x6d, 0x71, 0xd83c, 0xddf2,
+0xd83c, 0xddf6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x71, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6d, 0x71, 0xd83c, 0xddf2, 0xd83c, 0xddf7, 0x3a, 0x6d, 0x72,
+0x3a, 0x6d, 0x72, 0xd83c, 0xddf2, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6d, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x72, 0xd83c, 0xddf2,
+0xd83c, 0xddfa, 0x3a, 0x6d, 0x75, 0x3a, 0x6d, 0x75, 0xd83c, 0xddf2, 0xd83c, 0xddfa,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x75, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x6d, 0x75, 0xd83c, 0xddfe, 0xd83c, 0xddf9, 0x3a, 0x79, 0x74, 0x3a, 0x79,
+0x74, 0xd83c, 0xddfe, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x79,
+0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x79, 0x74, 0xd83c, 0xddf2, 0xd83c, 0xddfd,
+0x3a, 0x6d, 0x78, 0x3a, 0x6d, 0x78, 0xd83c, 0xddf2, 0xd83c, 0xddfd, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x78, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d,
+0x78, 0xd83c, 0xddeb, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6d, 0x3a, 0x66, 0x6d, 0xd83c,
+0xddeb, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x66, 0x6d, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x66, 0x6d, 0xd83c, 0xddf2, 0xd83c, 0xdde9, 0x3a, 0x6d,
+0x64, 0x3a, 0x6d, 0x64, 0xd83c, 0xddf2, 0xd83c, 0xdde9, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6d, 0x64, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x64, 0xd83c,
+0xddf2, 0xd83c, 0xdde8, 0x3a, 0x6d, 0x63, 0x3a, 0x6d, 0x63, 0xd83c, 0xddf2, 0xd83c,
+0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x63, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x6d, 0x63, 0xd83c, 0xddf2, 0xd83c, 0xddf3, 0x3a, 0x6d, 0x6e, 0x3a,
+0x6d, 0x6e, 0xd83c, 0xddf2, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6d, 0x6e, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x6e, 0xd83c, 0xddf2, 0xd83c,
+0xddea, 0x3a, 0x6d, 0x65, 0x3a, 0x6d, 0x65, 0xd83c, 0xddf2, 0xd83c, 0xddea, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x6d, 0x65, 0xd83c, 0xddf2, 0xd83c, 0xddf8, 0x3a, 0x6d, 0x73, 0x3a, 0x6d, 0x73,
+0xd83c, 0xddf2, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x73,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x73, 0xd83c, 0xddf2, 0xd83c, 0xdde6, 0x3a,
+0x6d, 0x61, 0x3a, 0x6d, 0x61, 0xd83c, 0xddf2, 0xd83c, 0xdde6, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x6d, 0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x61,
+0xd83c, 0xddf2, 0xd83c, 0xddff, 0x3a, 0x6d, 0x7a, 0x3a, 0x6d, 0x7a, 0xd83c, 0xddf2,
+0xd83c, 0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x7a, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6d, 0x7a, 0xd83c, 0xddf2, 0xd83c, 0xddf2, 0x3a, 0x6d, 0x6d,
+0x3a, 0x6d, 0x6d, 0xd83c, 0xddf2, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6d, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d, 0x6d, 0xd83c, 0xddf3,
+0xd83c, 0xdde6, 0x3a, 0x6e, 0x61, 0x3a, 0x6e, 0x61, 0xd83c, 0xddf3, 0xd83c, 0xdde6,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x61, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x6e, 0x61, 0xd83c, 0xddf3, 0xd83c, 0xddf7, 0x3a, 0x6e, 0x72, 0x3a, 0x6e,
+0x72, 0xd83c, 0xddf3, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e,
+0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e, 0x72, 0xd83c, 0xddf3, 0xd83c, 0xddf5,
+0x3a, 0x6e, 0x70, 0x3a, 0x6e, 0x70, 0xd83c, 0xddf3, 0xd83c, 0xddf5, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x70, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e,
+0x70, 0xd83c, 0xddf3, 0xd83c, 0xddf1, 0x3a, 0x6e, 0x6c, 0x3a, 0x6e, 0x6c, 0xd83c,
+0xddf3, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x6c, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x6e, 0x6c, 0xd83c, 0xddf3, 0xd83c, 0xdde8, 0x3a, 0x6e,
+0x63, 0x3a, 0x6e, 0x63, 0xd83c, 0xddf3, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6e, 0x63, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e, 0x63, 0xd83c,
+0xddf3, 0xd83c, 0xddff, 0x3a, 0x6e, 0x7a, 0x3a, 0x6e, 0x7a, 0xd83c, 0xddf3, 0xd83c,
+0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x7a, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x6e, 0x7a, 0xd83c, 0xddf3, 0xd83c, 0xddee, 0x3a, 0x6e, 0x69, 0x3a,
+0x6e, 0x69, 0xd83c, 0xddf3, 0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6e, 0x69, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e, 0x69, 0xd83c, 0xddf3, 0xd83c,
+0xddea, 0x3a, 0x6e, 0x65, 0x3a, 0x6e, 0x65, 0xd83c, 0xddf3, 0xd83c, 0xddea, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x6e, 0x65, 0xd83c, 0xddf3, 0xd83c, 0xddec, 0x3a, 0x6e, 0x69, 0x67, 0x65, 0x72,
+0x69, 0x61, 0x3a, 0x6e, 0x69, 0x67, 0x65, 0x72, 0x69, 0x61, 0xd83c, 0xddf3,
+0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x67, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6e, 0x67, 0xd83c, 0xddf3, 0xd83c, 0xddfa, 0x3a, 0x6e, 0x75,
+0x3a, 0x6e, 0x75, 0xd83c, 0xddf3, 0xd83c, 0xddfa, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x6e, 0x75, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e, 0x75, 0xd83c, 0xddf3,
+0xd83c, 0xddeb, 0x3a, 0x6e, 0x66, 0x3a, 0x6e, 0x66, 0xd83c, 0xddf3, 0xd83c, 0xddeb,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6e, 0x66, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x6e, 0x66, 0xd83c, 0xddf0, 0xd83c, 0xddf5, 0x3a, 0x6b, 0x70, 0x3a, 0x6b,
+0x70, 0xd83c, 0xddf0, 0xd83c, 0xddf5, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b,
+0x70, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b, 0x70, 0xd83c, 0xddf2, 0xd83c, 0xddf5,
+0x3a, 0x6d, 0x70, 0x3a, 0x6d, 0x70, 0xd83c, 0xddf2, 0xd83c, 0xddf5, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x6d, 0x70, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6d,
+0x70, 0xd83c, 0xddf3, 0xd83c, 0xddf4, 0x3a, 0x73, 0x6a, 0x3a, 0x73, 0x6a, 0xd83c,
+0xddf3, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x6a, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x73, 0x6a, 0xd83c, 0xddf3, 0xd83c, 0xddf4, 0x3a, 0x6e,
+0x6f, 0x3a, 0x6e, 0x6f, 0xd83c, 0xddf3, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6e, 0x6f, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6e, 0x6f, 0xd83c,
+0xddf3, 0xd83c, 0xddf4, 0x3a, 0x62, 0x76, 0x3a, 0x62, 0x76, 0xd83c, 0xddf3, 0xd83c,
+0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x62, 0x76, 0x3a, 0x62, 0x76,
+0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf4, 0xd83c, 0xddf2, 0x3a, 0x6f, 0x6d, 0x3a,
+0x6f, 0x6d, 0xd83c, 0xddf4, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6f, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6f, 0x6d, 0xd83c, 0xddf5, 0xd83c,
+0xddf0, 0x3a, 0x70, 0x6b, 0x3a, 0x70, 0x6b, 0xd83c, 0xddf5, 0xd83c, 0xddf0, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x6b, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x70, 0x6b, 0xd83c, 0xddf5, 0xd83c, 0xddfc, 0x3a, 0x70, 0x77, 0x3a, 0x70, 0x77,
+0xd83c, 0xddf5, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x77,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x77, 0xd83c, 0xddf5, 0xd83c, 0xddf8, 0x3a,
+0x70, 0x73, 0x3a, 0x70, 0x73, 0xd83c, 0xddf5, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x70, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x73,
+0xd83c, 0xddf5, 0xd83c, 0xdde6, 0x3a, 0x70, 0x61, 0x3a, 0x70, 0x61, 0xd83c, 0xddf5,
+0xd83c, 0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x61, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x70, 0x61, 0xd83c, 0xddf5, 0xd83c, 0xddec, 0x3a, 0x70, 0x67,
+0x3a, 0x70, 0x67, 0xd83c, 0xddf5, 0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x70, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x67, 0xd83c, 0xddf5,
+0xd83c, 0xddfe, 0x3a, 0x70, 0x79, 0x3a, 0x70, 0x79, 0xd83c, 0xddf5, 0xd83c, 0xddfe,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x79, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x70, 0x79, 0xd83c, 0xddf5, 0xd83c, 0xddea, 0x3a, 0x70, 0x65, 0x3a, 0x70,
+0x65, 0xd83c, 0xddf5, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70,
+0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x65, 0xd83c, 0xddf5, 0xd83c, 0xdded,
+0x3a, 0x70, 0x68, 0x3a, 0x70, 0x68, 0xd83c, 0xddf5, 0xd83c, 0xdded, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x70, 0x68, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70,
+0x68, 0xd83c, 0xddf5, 0xd83c, 0xddf3, 0x3a, 0x70, 0x6e, 0x3a, 0x70, 0x6e, 0xd83c,
+0xddf5, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x6e, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x70, 0x6e, 0xd83c, 0xddf5, 0xd83c, 0xddf1, 0x3a, 0x70,
+0x6c, 0x3a, 0x70, 0x6c, 0xd83c, 0xddf5, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x70, 0x6c, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x6c, 0xd83c,
+0xddf5, 0xd83c, 0xddf9, 0x3a, 0x70, 0x74, 0x3a, 0x70, 0x74, 0xd83c, 0xddf5, 0xd83c,
+0xddf9, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x74, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x70, 0x74, 0xd83c, 0xddf5, 0xd83c, 0xddf7, 0x3a, 0x70, 0x72, 0x3a,
+0x70, 0x72, 0xd83c, 0xddf5, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x70, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x70, 0x72, 0xd83c, 0xddf6, 0xd83c,
+0xdde6, 0x3a, 0x71, 0x61, 0x3a, 0x71, 0x61, 0xd83c, 0xddf6, 0xd83c, 0xdde6, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x71, 0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x71, 0x61, 0xd83c, 0xddf7, 0xd83c, 0xddea, 0x3a, 0x72, 0x65, 0x3a, 0x72, 0x65,
+0xd83c, 0xddf7, 0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x72, 0x65,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x72, 0x65, 0xd83c, 0xddf7, 0xd83c, 0xddf4, 0x3a,
+0x72, 0x6f, 0x3a, 0x72, 0x6f, 0xd83c, 0xddf7, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x72, 0x6f, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x72, 0x6f,
+0xd83c, 0xddf7, 0xd83c, 0xddfa, 0x3a, 0x72, 0x75, 0x3a, 0x72, 0x75, 0xd83c, 0xddf7,
+0xd83c, 0xddfa, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x72, 0x75, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x72, 0x75, 0xd83c, 0xddf7, 0xd83c, 0xddfc, 0x3a, 0x72, 0x77,
+0x3a, 0x72, 0x77, 0xd83c, 0xddf7, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x72, 0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x72, 0x77, 0xd83c, 0xddfc,
+0xd83c, 0xddf8, 0x3a, 0x77, 0x73, 0x3a, 0x77, 0x73, 0xd83c, 0xddfc, 0xd83c, 0xddf8,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x77, 0x73, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x77, 0x73, 0xd83c, 0xddf8, 0xd83c, 0xddf2, 0x3a, 0x73, 0x6d, 0x3a, 0x73,
+0x6d, 0xd83c, 0xddf8, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73,
+0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x6d, 0xd83c, 0xddf8, 0xd83c, 0xddf9,
+0x3a, 0x73, 0x74, 0x3a, 0x73, 0x74, 0xd83c, 0xddf8, 0xd83c, 0xddf9, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x73, 0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73,
+0x74, 0xd83c, 0xddf8, 0xd83c, 0xdde6, 0x3a, 0x73, 0x61, 0x75, 0x64, 0x69, 0x3a,
+0x73, 0x61, 0x75, 0x64, 0x69, 0xd83c, 0xddf8, 0xd83c, 0xdde6, 0x3a, 0x73, 0x61,
+0x75, 0x64, 0x69, 0x61, 0x72, 0x61, 0x62, 0x69, 0x61, 0x3a, 0x73, 0x61,
+0x75, 0x64, 0x69, 0x61, 0x72, 0x61, 0x62, 0x69, 0x61, 0xd83c, 0xddf8, 0xd83c,
+0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x61, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x73, 0x61, 0xd83c, 0xddf8, 0xd83c, 0xddf3, 0x3a, 0x73, 0x6e, 0x3a,
+0x73, 0x6e, 0xd83c, 0xddf8, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x73, 0x6e, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x6e, 0xd83c, 0xddf7, 0xd83c,
+0xddf8, 0x3a, 0x72, 0x73, 0x3a, 0x72, 0x73, 0xd83c, 0xddf7, 0xd83c, 0xddf8, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x72, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x72, 0x73, 0xd83c, 0xddf8, 0xd83c, 0xdde8, 0x3a, 0x73, 0x63, 0x3a, 0x73, 0x63,
+0xd83c, 0xddf8, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x63,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x63, 0xd83c, 0xddf8, 0xd83c, 0xddf1, 0x3a,
+0x73, 0x6c, 0x3a, 0x73, 0x6c, 0xd83c, 0xddf8, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x73, 0x6c, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x6c,
+0xd83c, 0xddf8, 0xd83c, 0xddec, 0x3a, 0x73, 0x67, 0x3a, 0x73, 0x67, 0xd83c, 0xddf8,
+0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x67, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x73, 0x67, 0xd83c, 0xddf8, 0xd83c, 0xddfd, 0x3a, 0x73, 0x78,
+0x3a, 0x73, 0x78, 0xd83c, 0xddf8, 0xd83c, 0xddfd, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x73, 0x78, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x78, 0xd83c, 0xddf8,
+0xd83c, 0xddf0, 0x3a, 0x73, 0x6b, 0x3a, 0x73, 0x6b, 0xd83c, 0xddf8, 0xd83c, 0xddf0,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x6b, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x73, 0x6b, 0xd83c, 0xddf8, 0xd83c, 0xddee, 0x3a, 0x73, 0x69, 0x3a, 0x73,
+0x69, 0xd83c, 0xddf8, 0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73,
+0x69, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x69, 0xd83c, 0xddec, 0xd83c, 0xddf8,
+0x3a, 0x67, 0x73, 0x3a, 0x67, 0x73, 0xd83c, 0xddec, 0xd83c, 0xddf8, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x67, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x67,
+0x73, 0xd83c, 0xddf8, 0xd83c, 0xdde7, 0x3a, 0x73, 0x62, 0x3a, 0x73, 0x62, 0xd83c,
+0xddf8, 0xd83c, 0xdde7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x62, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x73, 0x62, 0xd83c, 0xddf8, 0xd83c, 0xddf4, 0x3a, 0x73,
+0x6f, 0x3a, 0x73, 0x6f, 0xd83c, 0xddf8, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x73, 0x6f, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x6f, 0xd83c,
+0xddff, 0xd83c, 0xdde6, 0x3a, 0x7a, 0x61, 0x3a, 0x7a, 0x61, 0xd83c, 0xddff, 0xd83c,
+0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x7a, 0x61, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x7a, 0x61, 0xd83c, 0xddf0, 0xd83c, 0xddf7, 0x3a, 0x6b, 0x72, 0x3a,
+0x6b, 0x72, 0xd83c, 0xddf0, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x6b, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6b, 0x72, 0xd83c, 0xddf8, 0xd83c,
+0xddf8, 0x3a, 0x73, 0x73, 0x3a, 0x73, 0x73, 0xd83c, 0xddf8, 0xd83c, 0xddf8, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x73, 0x73, 0xd83c, 0xddea, 0xd83c, 0xddf8, 0x3a, 0x65, 0x73, 0x3a, 0x65, 0x73,
+0xd83c, 0xddea, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65, 0x73,
+0x3a, 0x65, 0x73, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddea, 0xd83c, 0xddf8, 0x3a,
+0x65, 0x61, 0x3a, 0x65, 0x61, 0xd83c, 0xddea, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x65, 0x61, 0x3a, 0x65, 0x61, 0x66, 0x6c, 0x61, 0x67,
+0xd83c, 0xddf1, 0xd83c, 0xddf0, 0x3a, 0x6c, 0x6b, 0x3a, 0x6c, 0x6b, 0xd83c, 0xddf1,
+0xd83c, 0xddf0, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6c, 0x6b, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x6c, 0x6b, 0xd83c, 0xdde7, 0xd83c, 0xddf1, 0x3a, 0x62, 0x6c,
+0x3a, 0x62, 0x6c, 0xd83c, 0xdde7, 0xd83c, 0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x62, 0x6c, 0x3a, 0x62, 0x6c, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf8,
+0xd83c, 0xdded, 0x3a, 0x74, 0x61, 0x3a, 0x74, 0x61, 0xd83c, 0xddf8, 0xd83c, 0xdded,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x61, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x74, 0x61, 0xd83c, 0xddf8, 0xd83c, 0xdded, 0x3a, 0x73, 0x68, 0x3a, 0x73,
+0x68, 0xd83c, 0xddf8, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73,
+0x68, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x68, 0xd83c, 0xddf8, 0xd83c, 0xdded,
+0x3a, 0x61, 0x63, 0x3a, 0x61, 0x63, 0xd83c, 0xddf8, 0xd83c, 0xdded, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x61, 0x63, 0x3a, 0x61, 0x63, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xddf0, 0xd83c, 0xddf3, 0x3a, 0x6b, 0x6e, 0x3a, 0x6b, 0x6e, 0xd83c,
+0xddf0, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x6b, 0x6e, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x6b, 0x6e, 0xd83c, 0xddf1, 0xd83c, 0xdde8, 0x3a, 0x6c,
+0x63, 0x3a, 0x6c, 0x63, 0xd83c, 0xddf1, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x6c, 0x63, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x6c, 0x63, 0xd83c,
+0xddf5, 0xd83c, 0xddf2, 0x3a, 0x70, 0x6d, 0x3a, 0x70, 0x6d, 0xd83c, 0xddf5, 0xd83c,
+0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x70, 0x6d, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x70, 0x6d, 0xd83c, 0xddfb, 0xd83c, 0xdde8, 0x3a, 0x76, 0x63, 0x3a,
+0x76, 0x63, 0xd83c, 0xddfb, 0xd83c, 0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x76, 0x63, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x76, 0x63, 0xd83c, 0xddf8, 0xd83c,
+0xdde9, 0x3a, 0x73, 0x64, 0x3a, 0x73, 0x64, 0xd83c, 0xddf8, 0xd83c, 0xdde9, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x64, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x73, 0x64, 0xd83c, 0xddf8, 0xd83c, 0xddf7, 0x3a, 0x73, 0x72, 0x3a, 0x73, 0x72,
+0xd83c, 0xddf8, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x72,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x72, 0xd83c, 0xddf8, 0xd83c, 0xddff, 0x3a,
+0x73, 0x7a, 0x3a, 0x73, 0x7a, 0xd83c, 0xddf8, 0xd83c, 0xddff, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x73, 0x7a, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x7a,
+0xd83c, 0xddf8, 0xd83c, 0xddea, 0x3a, 0x73, 0x65, 0x3a, 0x73, 0x65, 0xd83c, 0xddf8,
+0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x65, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x73, 0x65, 0xd83c, 0xdde8, 0xd83c, 0xdded, 0x3a, 0x63, 0x68,
+0x3a, 0x63, 0x68, 0xd83c, 0xdde8, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x63, 0x68, 0x3a, 0x63, 0x68, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddf8,
+0xd83c, 0xddfe, 0x3a, 0x73, 0x79, 0x3a, 0x73, 0x79, 0xd83c, 0xddf8, 0xd83c, 0xddfe,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x73, 0x79, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x73, 0x79, 0xd83c, 0xddf9, 0xd83c, 0xddfc, 0x3a, 0x74, 0x77, 0x3a, 0x74,
+0x77, 0xd83c, 0xddf9, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74,
+0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x77, 0xd83c, 0xddf9, 0xd83c, 0xddef,
+0x3a, 0x74, 0x6a, 0x3a, 0x74, 0x6a, 0xd83c, 0xddf9, 0xd83c, 0xddef, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x74, 0x6a, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74,
+0x6a, 0xd83c, 0xddf9, 0xd83c, 0xddff, 0x3a, 0x74, 0x7a, 0x3a, 0x74, 0x7a, 0xd83c,
+0xddf9, 0xd83c, 0xddff, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x7a, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x74, 0x7a, 0xd83c, 0xddf9, 0xd83c, 0xdded, 0x3a, 0x74,
+0x68, 0x3a, 0x74, 0x68, 0xd83c, 0xddf9, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x74, 0x68, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x68, 0xd83c,
+0xddf9, 0xd83c, 0xddf1, 0x3a, 0x74, 0x6c, 0x3a, 0x74, 0x6c, 0xd83c, 0xddf9, 0xd83c,
+0xddf1, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x6c, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x74, 0x6c, 0xd83c, 0xddf9, 0xd83c, 0xddec, 0x3a, 0x74, 0x67, 0x3a,
+0x74, 0x67, 0xd83c, 0xddf9, 0xd83c, 0xddec, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x74, 0x67, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x67, 0xd83c, 0xddf9, 0xd83c,
+0xddf0, 0x3a, 0x74, 0x6b, 0x3a, 0x74, 0x6b, 0xd83c, 0xddf9, 0xd83c, 0xddf0, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x6b, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x74, 0x6b, 0xd83c, 0xddf9, 0xd83c, 0xddf4, 0x3a, 0x74, 0x6f, 0x3a, 0x74, 0x6f,
+0xd83c, 0xddf9, 0xd83c, 0xddf4, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x6f,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x6f, 0xd83c, 0xddf9, 0xd83c, 0xddf9, 0x3a,
+0x74, 0x74, 0x3a, 0x74, 0x74, 0xd83c, 0xddf9, 0xd83c, 0xddf9, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x74, 0x74, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x74,
+0xd83c, 0xddf9, 0xd83c, 0xddf3, 0x3a, 0x74, 0x6e, 0x3a, 0x74, 0x6e, 0xd83c, 0xddf9,
+0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x6e, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x74, 0x6e, 0xd83c, 0xddf9, 0xd83c, 0xddf7, 0x3a, 0x74, 0x72,
+0x3a, 0x74, 0x72, 0xd83c, 0xddf9, 0xd83c, 0xddf7, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x74, 0x72, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x72, 0xd83c, 0xddf9,
+0xd83c, 0xddf2, 0x3a, 0x74, 0x75, 0x72, 0x6b, 0x6d, 0x65, 0x6e, 0x69, 0x73,
+0x74, 0x61, 0x6e, 0x3a, 0x74, 0x75, 0x72, 0x6b, 0x6d, 0x65, 0x6e, 0x69,
+0x73, 0x74, 0x61, 0x6e, 0xd83c, 0xddf9, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x74, 0x6d, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x74, 0x6d, 0xd83c,
+0xddf9, 0xd83c, 0xdde8, 0x3a, 0x74, 0x63, 0x3a, 0x74, 0x63, 0xd83c, 0xddf9, 0xd83c,
+0xdde8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x63, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x74, 0x63, 0xd83c, 0xddf9, 0xd83c, 0xddfb, 0x3a, 0x74, 0x75, 0x76,
+0x61, 0x6c, 0x75, 0x3a, 0x74, 0x75, 0x76, 0x61, 0x6c, 0x75, 0xd83c, 0xddf9,
+0xd83c, 0xddfb, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x74, 0x76, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x74, 0x76, 0xd83c, 0xddfb, 0xd83c, 0xddee, 0x3a, 0x76, 0x69,
+0x3a, 0x76, 0x69, 0xd83c, 0xddfb, 0xd83c, 0xddee, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x76, 0x69, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x76, 0x69, 0xd83c, 0xddfa,
+0xd83c, 0xddec, 0x3a, 0x75, 0x67, 0x3a, 0x75, 0x67, 0xd83c, 0xddfa, 0xd83c, 0xddec,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x75, 0x67, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x75, 0x67, 0xd83c, 0xddfa, 0xd83c, 0xdde6, 0x3a, 0x75, 0x61, 0x3a, 0x75,
+0x61, 0xd83c, 0xddfa, 0xd83c, 0xdde6, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x75,
+0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x75, 0x61, 0xd83c, 0xdde6, 0xd83c, 0xddea,
+0x3a, 0x61, 0x65, 0x3a, 0x61, 0x65, 0xd83c, 0xdde6, 0xd83c, 0xddea, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x61, 0x65, 0x3a, 0x61, 0x65, 0x66, 0x6c, 0x61,
+0x67, 0xd83c, 0xddec, 0xd83c, 0xdde7, 0x3a, 0x67, 0x62, 0x3a, 0x67, 0x62, 0xd83c,
+0xddec, 0xd83c, 0xdde7, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x67, 0x62, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x67, 0x62, 0xd83c, 0xddfa, 0xd83c, 0xddf8, 0x3a, 0x75,
+0x73, 0x3a, 0x75, 0x73, 0xd83c, 0xddfa, 0xd83c, 0xddf8, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x75, 0x73, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x75, 0x73, 0xd83c,
+0xddfa, 0xd83c, 0xddf8, 0x3a, 0x75, 0x6d, 0x3a, 0x75, 0x6d, 0xd83c, 0xddfa, 0xd83c,
+0xddf8, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x75, 0x6d, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x75, 0x6d, 0xd83c, 0xddfa, 0xd83c, 0xddfe, 0x3a, 0x75, 0x79, 0x3a,
+0x75, 0x79, 0xd83c, 0xddfa, 0xd83c, 0xddfe, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f,
+0x75, 0x79, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x75, 0x79, 0xd83c, 0xddfa, 0xd83c,
+0xddff, 0x3a, 0x75, 0x7a, 0x3a, 0x75, 0x7a, 0xd83c, 0xddfa, 0xd83c, 0xddff, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x5f, 0x75, 0x7a, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x75, 0x7a, 0xd83c, 0xddfb, 0xd83c, 0xddfa, 0x3a, 0x76, 0x75, 0x3a, 0x76, 0x75,
+0xd83c, 0xddfb, 0xd83c, 0xddfa, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x76, 0x75,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x76, 0x75, 0xd83c, 0xddfb, 0xd83c, 0xdde6, 0x3a,
+0x76, 0x61, 0x3a, 0x76, 0x61, 0xd83c, 0xddfb, 0xd83c, 0xdde6, 0x3a, 0x66, 0x6c,
+0x61, 0x67, 0x5f, 0x76, 0x61, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x76, 0x61,
+0xd83c, 0xddfb, 0xd83c, 0xddea, 0x3a, 0x76, 0x65, 0x3a, 0x76, 0x65, 0xd83c, 0xddfb,
+0xd83c, 0xddea, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x76, 0x65, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x76, 0x65, 0xd83c, 0xddfb, 0xd83c, 0xddf3, 0x3a, 0x76, 0x6e,
+0x3a, 0x76, 0x6e, 0xd83c, 0xddfb, 0xd83c, 0xddf3, 0x3a, 0x66, 0x6c, 0x61, 0x67,
+0x5f, 0x76, 0x6e, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x76, 0x6e, 0xd83c, 0xddfc,
+0xd83c, 0xddeb, 0x3a, 0x77, 0x66, 0x3a, 0x77, 0x66, 0xd83c, 0xddfc, 0xd83c, 0xddeb,
+0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x77, 0x66, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x77, 0x66, 0xd83c, 0xddea, 0xd83c, 0xdded, 0x3a, 0x65, 0x68, 0x3a, 0x65,
+0x68, 0xd83c, 0xddea, 0xd83c, 0xdded, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x65,
+0x68, 0x3a, 0x65, 0x68, 0x66, 0x6c, 0x61, 0x67, 0xd83c, 0xddfe, 0xd83c, 0xddea,
+0x3a, 0x79, 0x65, 0x3a, 0x79, 0x65, 0xd83c, 0xddfe, 0xd83c, 0xddea, 0x3a, 0x66,
+0x6c, 0x61, 0x67, 0x5f, 0x79, 0x65, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x79,
+0x65, 0xd83c, 0xddff, 0xd83c, 0xddf2, 0x3a, 0x7a, 0x6d, 0x3a, 0x7a, 0x6d, 0xd83c,
+0xddff, 0xd83c, 0xddf2, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x7a, 0x6d, 0x3a,
+0x66, 0x6c, 0x61, 0x67, 0x7a, 0x6d, 0xd83c, 0xddff, 0xd83c, 0xddfc, 0x3a, 0x7a,
+0x77, 0x3a, 0x7a, 0x77, 0xd83c, 0xddff, 0xd83c, 0xddfc, 0x3a, 0x66, 0x6c, 0x61,
+0x67, 0x5f, 0x7a, 0x77, 0x3a, 0x66, 0x6c, 0x61, 0x67, 0x7a, 0x77 };
+
+const small ReplacementWordLengths[] = {
+8, 6, 5, 4, 9, 8, 5, 5, 3, 5, 8, 2,
+7, 3, 4, 7, 5, 8, 4, 8, 7, 6, 5, 4,
+4, 6, 4, 6, 4, 8, 4, 5, 5, 7, 7, 4,
+7, 7, 6, 4, 7, 3, 3, 3, 5, 6, 7, 6,
+4, 3, 5, 6, 3, 5, 6, 4, 5, 5, 5, 5,
+4, 7, 7, 4, 4, 4, 10, 5, 4, 5, 6, 4,
+3, 4, 6, 5, 8, 12, 7, 7, 8, 4, 8, 8,
+5, 6, 4, 8, 5, 9, 9, 10, 4, 5, 5, 7,
+5, 4, 5, 2, 4, 7, 14, 6, 8, 9, 5, 4,
+10, 5, 4, 7, 6, 7, 4, 5, 3, 12, 8, 5,
+8, 4, 3, 5, 6, 8, 4, 4, 7, 4, 4, 7,
+3, 4, 8, 8, 4, 4, 5, 9, 4, 5, 6, 5,
+6, 4, 4, 9, 6, 4, 8, 4, 4, 11, 4, 4,
+11, 7, 4, 4, 4, 7, 4, 3, 7, 3, 8, 4,
+6, 8, 3, 6, 4, 4, 5, 8, 5, 3, 10, 5,
+10, 5, 5, 7, 5, 4, 5, 5, 4, 7, 1, 3,
+6, 3, 5, 3, 3, 3, 4, 5, 3, 5, 3, 7,
+3, 6, 3, 6, 4, 3, 7, 5, 4, 5, 6, 4,
+4, 5, 7, 9, 4, 7, 2, 8, 7, 9, 2, 10,
+5, 4, 4, 4, 6, 4, 4, 4, 5, 6, 4, 5,
+3, 7, 6, 4, 5, 6, 4, 7, 7, 1, 5, 2,
+4, 3, 5, 4, 2, 4, 5, 5, 5, 1, 5, 2,
+4, 5, 5, 2, 4, 6, 4, 4, 2, 4, 4, 2,
+6, 7, 4, 6, 7, 4, 4, 7, 3, 7, 7, 4,
+6, 4, 6, 4, 4, 6, 4, 4, 4, 2, 4, 2,
+6, 8, 6, 4, 6, 8, 4, 6, 6, 4, 7, 6,
+4, 4, 4, 8, 4, 4, 6, 3, 4, 10, 3, 4,
+4, 2, 10, 8, 4, 8, 4, 2, 10, 5, 2, 10,
+4, 3, 4, 3, 5, 5, 6, 5, 5, 6, 3, 5,
+4, 6, 4, 5, 6, 6, 3, 5, 7, 5, 5, 3,
+3, 3, 2, 4, 3, 7, 3, 4, 6, 7, 5, 3,
+6, 7, 3, 6, 4, 6, 6, 7, 7, 6, 5, 3,
+7, 6, 3, 7, 6, 12, 5, 6, 12, 3, 6, 12,
+6, 5, 5, 5, 3, 9, 5, 9, 5, 9, 3, 2,
+6, 3, 3, 9, 6, 5, 6, 6, 3, 6, 6, 5,
+6, 3, 4, 5, 4, 3, 7, 5, 3, 7, 6, 5,
+3, 6, 7, 5, 3, 7, 7, 5, 6, 7, 3, 6,
+12, 5, 3, 12, 6, 5, 6, 3, 6, 6, 8, 5,
+3, 8, 9, 5, 3, 9, 6, 5, 6, 3, 11, 5,
+11, 3, 5, 5, 3, 5, 9, 5, 9, 3, 5, 5,
+5, 3, 9, 6, 5, 3, 5, 8, 6, 5, 4, 4,
+2, 3, 6, 5, 9, 5, 8, 5, 6, 5, 6, 3,
+3, 6, 6, 4, 7, 5, 4, 11, 6, 4, 6, 7,
+4, 3, 7, 9, 2, 5, 4, 2, 9, 2, 6, 9,
+3, 2, 9, 2, 5, 2, 5, 9, 2, 6, 9, 3,
+2, 4, 7, 5, 4, 7, 4, 6, 7, 4, 3, 7,
+11, 5, 11, 3, 8, 4, 4, 11, 6, 9, 5, 5,
+6, 9, 3, 9, 7, 5, 4, 6, 7, 4, 6, 7,
+3, 7, 8, 5, 8, 6, 8, 3, 7, 7, 5, 7,
+7, 7, 6, 7, 7, 3, 4, 7, 7, 5, 7, 7,
+7, 6, 4, 7, 3, 7, 8, 2, 10, 3, 4, 6,
+6, 4, 7, 3, 5, 4, 8, 4, 5, 7, 5, 4,
+8, 6, 4, 5, 4, 3, 8, 4, 7, 5, 3, 7,
+7, 6, 7, 7, 5, 3, 7, 6, 6, 7, 6, 5,
+7, 3, 5, 5, 7, 3, 3, 6, 5, 4, 6, 5,
+3, 4, 5, 6, 5, 4, 2, 6, 2, 6, 5, 2,
+4, 6, 2, 10, 4, 3, 5, 10, 2, 4, 2, 10,
+2, 4, 2, 6, 3, 6, 3, 5, 6, 3, 6, 4,
+6, 4, 6, 4, 6, 3, 6, 3, 6, 4, 6, 4,
+6, 4, 6, 3, 6, 3, 6, 4, 6, 4, 6, 4,
+3, 6, 5, 6, 4, 5, 3, 6, 4, 5, 3, 3,
+6, 5, 6, 4, 4, 5, 3, 6, 3, 6, 4, 3,
+3, 6, 4, 3, 3, 3, 6, 3, 6, 4, 4, 3,
+7, 6, 5, 5, 7, 5, 6, 6, 4, 4, 6, 4,
+4, 4, 8, 4, 3, 6, 6, 5, 6, 5, 5, 6,
+5, 4, 5, 6, 4, 7, 6, 5, 5, 7, 9, 10,
+4, 10, 6, 8, 9, 3, 3, 5, 7, 6, 4, 3,
+3, 4, 4, 5, 5, 5, 4, 4, 4, 3, 3, 4,
+3, 4, 4, 6, 4, 2, 3, 4, 4, 2, 4, 2,
+5, 6, 7, 7, 4, 4, 5, 5, 8, 5, 7, 4,
+5, 3, 3, 4, 4, 5, 4, 7, 7, 3, 3, 9,
+5, 5, 6, 3, 6, 6, 3, 6, 5, 6, 8, 4,
+5, 7, 6, 4, 8, 4, 8, 7, 5, 5, 6, 9,
+7, 6, 7, 5, 2, 4, 4, 5, 9, 5, 8, 10,
+5, 7, 9, 4, 4, 3, 5, 4, 6, 4, 7, 6,
+4, 2, 5, 4, 7, 6, 3, 8, 3, 6, 4, 6,
+6, 4, 6, 9, 4, 9, 4, 9, 4, 4, 4, 8,
+4, 8, 6, 4, 4, 6, 8, 4, 6, 6, 4, 4,
+5, 8, 3, 2, 4, 7, 5, 4, 6, 6, 4, 6,
+9, 7, 7, 6, 8, 8, 5, 6, 5, 4, 5, 4,
+4, 7, 4, 6, 4, 4, 7, 8, 4, 6, 4, 3,
+8, 4, 6, 5, 4, 7, 7, 4, 6, 4, 4, 3,
+4, 4, 4, 4, 4, 4, 3, 4, 4, 5, 4, 7,
+4, 4, 4, 4, 7, 4, 8, 4, 5, 4, 5, 8,
+3, 5, 4, 4, 5, 5, 5, 5, 3, 5, 4, 5,
+5, 3, 5, 6, 5, 6, 5, 3, 5, 5, 3, 5,
+6, 5, 4, 3, 5, 4, 5, 4, 3, 5, 7, 5,
+5, 4, 4, 5, 4, 3, 5, 4, 7, 5, 4, 7,
+5, 9, 4, 5, 9, 5, 4, 4, 5, 4, 8, 7,
+9, 7, 4, 4, 4, 5, 7, 4, 5, 7, 3, 5,
+7, 5, 5, 8, 5, 5, 5, 4, 9, 5, 6, 10,
+6, 10, 5, 8, 5, 9, 9, 4, 7, 6, 8, 8,
+6, 4, 3, 6, 6, 6, 5, 8, 6, 7, 7, 5,
+3, 9, 5, 8, 5, 5, 6, 6, 5, 6, 3, 7,
+5, 8, 5, 6, 3, 7, 4, 4, 2, 5, 3, 3,
+6, 9, 5, 4, 7, 9, 7, 4, 7, 5, 5, 5,
+6, 4, 2, 3, 7, 9, 5, 4, 4, 4, 5, 5,
+5, 4, 4, 4, 7, 4, 4, 5, 3, 6, 5, 3,
+8, 4, 8, 4, 7, 7, 8, 5, 3, 9, 7, 8,
+6, 5, 4, 2, 4, 4, 6, 6, 3, 4, 4, 5,
+8, 5, 9, 5, 5, 4, 6, 5, 7, 8, 5, 8,
+6, 4, 7, 4, 9, 5, 3, 4, 5, 3, 4, 5,
+5, 4, 4, 5, 5, 6, 10, 8, 8, 6, 10, 8,
+5, 5, 5, 6, 4, 4, 9, 4, 3, 4, 6, 5,
+6, 4, 3, 7, 7, 4, 4, 7, 3, 5, 3, 3,
+4, 7, 4, 6, 6, 6, 5, 6, 7, 4, 7, 7,
+3, 5, 3, 5, 11, 7, 7, 5, 7, 3, 7, 6,
+6, 6, 7, 6, 7, 7, 6, 7, 6, 5, 9, 3,
+9, 9, 9, 6, 9, 12, 5, 12, 3, 9, 9, 5,
+6, 4, 8, 5, 4, 8, 3, 4, 6, 4, 10, 6,
+4, 8, 6, 8, 7, 5, 8, 8, 6, 7, 8, 3,
+7, 7, 5, 7, 3, 6, 7, 6, 7, 5, 3, 7,
+6, 6, 7, 8, 5, 3, 8, 7, 6, 8, 7, 4,
+5, 5, 3, 7, 4, 5, 4, 5, 6, 7, 4, 5,
+4, 6, 5, 4, 3, 6, 7, 4, 6, 6, 5, 6,
+6, 5, 6, 3, 9, 6, 6, 6, 8, 5, 6, 3,
+8, 9, 8, 6, 8, 6, 7, 4, 5, 4, 5, 6,
+5, 5, 8, 5, 5, 5, 5, 5, 5, 5, 6, 5,
+6, 5, 5, 5, 5, 5, 6, 7, 8, 6, 6, 9,
+7, 7, 6, 4, 8, 5, 8, 3, 7, 8, 8, 6,
+4, 10, 3, 7, 10, 10, 7, 5, 8, 7, 4, 10,
+4, 4, 9, 7, 6, 6, 3, 4, 4, 7, 4, 5,
+7, 4, 3, 3, 4, 4, 3, 3, 10, 3, 6, 3,
+4, 3, 6, 9, 6, 4, 7, 5, 11, 5, 7, 7,
+4, 9, 5, 7, 10, 6, 10, 5, 8, 3, 8, 6,
+3, 8, 10, 8, 8, 4, 6, 7, 8, 8, 7, 10,
+3, 7, 5, 8, 7, 8, 11, 4, 11, 5, 5, 4,
+10, 5, 6, 5, 4, 7, 10, 8, 5, 8, 5, 8,
+8, 9, 8, 8, 6, 7, 9, 4, 5, 5, 8, 9,
+9, 9, 4, 6, 4, 5, 4, 6, 12, 8, 7, 5,
+7, 8, 5, 7, 3, 5, 3, 5, 7, 2, 6, 8,
+5, 5, 6, 8, 6, 8, 7, 6, 5, 7, 6, 8,
+5, 6, 2, 8, 5, 8, 5, 8, 4, 5, 6, 6,
+6, 8, 6, 8, 4, 8, 4, 4, 5, 7, 6, 7,
+4, 8, 5, 7, 5, 8, 8, 12, 12, 4, 7, 5,
+6, 5, 4, 9, 5, 5, 8, 8, 5, 9, 5, 6,
+10, 5, 6, 4, 8, 6, 4, 8, 4, 5, 11, 5,
+6, 5, 4, 7, 8, 9, 6, 6, 9, 5, 6, 6,
+5, 4, 5, 8, 4, 4, 7, 9, 4, 7, 5, 8,
+9, 4, 7, 4, 6, 4, 4, 9, 5, 5, 4, 5,
+3, 2, 6, 5, 5, 5, 6, 7, 8, 8, 8, 7,
+7, 7, 6, 5, 5, 6, 5, 5, 9, 8, 11, 8,
+4, 6, 2, 3, 3, 6, 6, 5, 4, 6, 5, 6,
+5, 4, 9, 9, 4, 6, 8, 9, 9, 5, 3, 2,
+5, 10, 6, 11, 5, 6, 7, 5, 9, 5, 5, 5,
+5, 5, 5, 11, 5, 9, 7, 9, 4, 9, 7, 8,
+4, 4, 10, 6, 11, 4, 3, 3, 5, 5, 4, 6,
+3, 4, 5, 8, 4, 6, 3, 6, 6, 6, 3, 6,
+4, 6, 4, 3, 6, 6, 5, 4, 3, 4, 3, 4,
+6, 3, 4, 5, 6, 5, 6, 7, 6, 6, 7, 6,
+7, 3, 3, 7, 4, 7, 5, 6, 6, 7, 9, 10,
+4, 4, 7, 11, 6, 7, 5, 6, 7, 4, 4, 7,
+7, 3, 3, 3, 4, 4, 3, 5, 4, 5, 3, 13,
+8, 5, 7, 4, 5, 5, 4, 8, 8, 7, 4, 8,
+4, 7, 5, 6, 4, 8, 4, 5, 7, 7, 5, 4,
+8, 5, 8, 4, 8, 8, 5, 1, 4, 6, 4, 5,
+4, 6, 4, 7, 5, 6, 7, 7, 4, 7, 4, 4,
+7, 2, 4, 7, 4, 6, 6, 4, 4, 4, 6, 4,
+2, 8, 4, 3, 5, 5, 5, 7, 4, 5, 9, 5,
+4, 4, 3, 6, 7, 6, 8, 3, 6, 8, 6, 8,
+4, 4, 5, 3, 4, 4, 3, 4, 6, 6, 3, 4,
+6, 3, 7, 4, 9, 4, 6, 4, 6, 4, 4, 8,
+5, 8, 9, 6, 2, 10, 9, 8, 5, 10, 8, 4,
+6, 4, 6, 4, 5, 4, 4, 4, 6, 5, 4, 8,
+4, 9, 6, 10, 10, 5, 10, 5, 8, 7, 7, 5,
+8, 9, 4, 5, 3, 9, 3, 8, 4, 5, 3, 8,
+3, 5, 3, 4, 5, 10, 10, 6, 4, 5, 6, 4,
+6, 7, 3, 3, 5, 3, 4, 3, 4, 6, 3, 4,
+4, 4, 6, 5, 5, 6, 5, 5, 4, 5, 5, 6,
+5, 5, 6, 5, 11, 5, 5, 4, 8, 11, 5, 6,
+3, 6, 9, 9, 10, 5, 9, 5, 4, 5, 10, 5,
+5, 6, 5, 5, 5, 5, 3, 8, 4, 2, 6, 6,
+2, 5, 5, 2, 4, 7, 3, 4, 7, 4, 3, 5,
+8, 6, 7, 2, 5, 7, 9, 5, 6, 6, 6, 3,
+5, 5, 8, 11, 9, 8, 6, 2, 4, 6, 4, 6,
+11, 4, 11, 9, 4, 9, 6, 3, 5, 4, 9, 5,
+5, 5, 5, 5, 5, 5, 7, 4, 2, 6, 5, 9,
+9, 6, 15, 5, 5, 5, 5, 1, 1, 2, 2, 2,
+3, 1, 1, 4, 4, 9, 4, 5, 2, 5, 4, 5,
+2, 4, 3, 5, 10, 2, 11, 2, 6, 3, 8, 2,
+3, 7, 5, 8, 6, 2, 6, 2, 7, 11, 11, 4,
+8, 4, 8, 8, 11, 10, 3, 10, 4, 11, 4, 4,
+7, 8, 8, 7, 2, 5, 3, 8, 7, 5, 4, 5,
+5, 5, 7, 8, 5, 6, 5, 4, 8, 7, 5, 9,
+4, 1, 7, 3, 6, 5, 4, 1, 7, 3, 3, 2,
+10, 7, 5, 2, 7, 8, 7, 7, 5, 4, 7, 4,
+6, 4, 6, 8, 2, 3, 6, 5, 3, 6, 6, 8,
+4, 7, 11, 6, 3, 4, 4, 7, 2, 2, 2, 4,
+3, 4, 4, 3, 3, 5, 4, 4, 3, 5, 5, 4,
+6, 3, 4, 4, 8, 6, 8, 5, 7, 3, 6, 8,
+6, 5, 5, 4, 6, 4, 6, 6, 4, 5, 4, 5,
+8, 5, 8, 5, 4, 7, 6, 5, 6, 2, 5, 6,
+4, 5, 8, 5, 5, 2, 5, 4, 5, 5, 5, 5,
+4, 5, 2, 5, 4, 5, 5, 5, 5, 5, 5, 5,
+4, 5, 5, 4, 5, 5, 4, 2, 5, 4, 5, 5,
+4, 5, 5, 4, 9, 4, 5, 7, 2, 5, 4, 7,
+6, 10, 7, 6, 3, 6, 6, 16, 6, 9, 7, 4,
+5, 5, 4, 4, 5, 5, 4, 8, 5, 4, 5, 14,
+1, 6, 5, 4, 8, 8, 2, 9, 10, 4, 4, 5,
+4, 4, 3, 4, 2, 3, 4, 5, 5, 4, 6, 3,
+5, 4, 6, 5, 6, 5, 5, 6, 6, 3, 4, 6,
+3, 5, 8, 4, 3, 5, 8, 7, 6, 5, 4, 7,
+5, 7, 5, 6, 4, 7, 5, 6, 6, 5, 5, 6,
+6, 5, 5, 6, 5, 6, 5, 5, 6, 5, 6, 6,
+5, 6, 5, 5, 6, 6, 6, 6, 5, 5, 5, 6,
+5, 6, 5, 7, 4, 5, 4, 5, 4, 4, 2, 4,
+11, 6, 4, 6, 4, 6, 6, 3, 2, 6, 7, 6,
+7, 7, 5, 6, 5, 5, 5, 6, 5, 6, 8, 5,
+5, 5, 6, 7, 7, 6, 6, 6, 6, 6, 6, 6,
+6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8,
+8, 8, 9, 9, 9, 4, 6, 5, 4, 5, 5, 4,
+6, 5, 4, 9, 4, 4, 2, 4, 10, 4, 3, 5,
+4, 7, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 4, 2, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+4, 2, 2, 2, 4, 2, 4, 2, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 4, 2, 2,
+2, 4, 2, 2, 4, 2, 4, 2, 2, 2, 4, 2,
+2, 4, 2, 4, 2, 2, 2, 4, 2, 4, 2, 5,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 4, 2, 2, 2, 4, 5, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 4, 2, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 2, 4, 2, 4, 2, 2, 4, 2, 2,
+2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2,
+2, 4, 2, 4, 2, 2, 2, 4, 2, 2, 4, 2,
+4, 2, 2, 4, 2, 2, 2, 4, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 2, 4, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 9,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 7, 5, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 7, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 2, 4, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4,
+2, 2, 4, 2, 2, 4, 2, 5, 11, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 2, 4, 2, 2, 4, 2,
+4, 2, 2, 2, 4, 2, 4, 2, 2, 4, 2, 2,
+2, 4, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 2, 4, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 12, 4, 2, 2, 4, 2, 6,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+2, 4, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2,
+4, 2, 2, 4, 2, 2, 4, 2, 2, 2, 4, 2,
+4, 2, 2, 4, 2, 2, 4, 2 };
+
+const ReplacementStruct ReplacementInitData[] = {
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(31), small(5) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(23), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(30), small(5) },
+	{ small(2), small(30), small(5) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(22), small(4) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(14), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(24), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(16), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(23), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(24), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(23), small(3) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(24), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(43), small(7) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(3), small(1) },
+	{ small(2), small(19), small(4) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(21), small(4) },
+	{ small(2), small(34), small(5) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(55), small(9) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(43), small(6) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(29), small(4) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(5), small(20), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(24), small(4) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(21), small(5) },
+	{ small(2), small(22), small(4) },
+	{ small(5), small(22), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(23), small(3) },
+	{ small(5), small(22), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(27), small(3) },
+	{ small(2), small(25), small(3) },
+	{ small(2), small(21), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(6), small(17), small(2) },
+	{ small(3), small(15), small(2) },
+	{ small(3), small(15), small(3) },
+	{ small(3), small(5), small(1) },
+	{ small(3), small(11), small(1) },
+	{ small(5), small(21), small(3) },
+	{ small(5), small(19), small(3) },
+	{ small(5), small(14), small(2) },
+	{ small(5), small(12), small(2) },
+	{ small(5), small(12), small(2) },
+	{ small(5), small(10), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(5), small(12), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(5), small(22), small(3) },
+	{ small(5), small(20), small(3) },
+	{ small(5), small(20), small(2) },
+	{ small(5), small(18), small(2) },
+	{ small(5), small(21), small(3) },
+	{ small(5), small(19), small(3) },
+	{ small(5), small(16), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(5), small(12), small(2) },
+	{ small(5), small(19), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(5), small(11), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(5), small(11), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(25), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(5), small(18), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(5), small(18), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(5), small(18), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(5), small(18), small(3) },
+	{ small(5), small(19), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(10), small(1) },
+	{ small(5), small(11), small(2) },
+	{ small(5), small(20), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(7), small(1) },
+	{ small(5), small(18), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(26), small(4) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(13), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(2), small(23), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(24), small(3) },
+	{ small(5), small(21), small(3) },
+	{ small(2), small(28), small(4) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(24), small(3) },
+	{ small(5), small(26), small(4) },
+	{ small(2), small(33), small(5) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(32), small(5) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(33), small(5) },
+	{ small(5), small(30), small(5) },
+	{ small(5), small(15), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(25), small(4) },
+	{ small(2), small(23), small(4) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(29), small(5) },
+	{ small(8), small(22), small(4) },
+	{ small(8), small(11), small(2) },
+	{ small(8), small(22), small(4) },
+	{ small(8), small(11), small(2) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(16), small(3) },
+	{ small(11), small(15), small(2) },
+	{ small(11), small(9), small(2) },
+	{ small(11), small(15), small(2) },
+	{ small(11), small(9), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(22), small(4) },
+	{ small(8), small(12), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(8), small(12), small(2) },
+	{ small(8), small(12), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(8), small(12), small(2) },
+	{ small(8), small(12), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(11), small(13), small(2) },
+	{ small(5), small(18), small(3) },
+	{ small(5), small(19), small(3) },
+	{ small(8), small(23), small(4) },
+	{ small(8), small(22), small(4) },
+	{ small(8), small(24), small(4) },
+	{ small(5), small(16), small(3) },
+	{ small(5), small(17), small(3) },
+	{ small(8), small(21), small(4) },
+	{ small(8), small(20), small(4) },
+	{ small(8), small(22), small(4) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(1), small(25), small(4) },
+	{ small(1), small(19), small(3) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(13), small(3) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(20), small(4) },
+	{ small(2), small(21), small(4) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(30), small(5) },
+	{ small(2), small(29), small(5) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(1), small(10), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(28), small(5) },
+	{ small(2), small(23), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(24), small(4) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(34), small(6) },
+	{ small(2), small(22), small(4) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(1), small(24), small(4) },
+	{ small(1), small(20), small(3) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(21), small(4) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(26), small(4) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(27), small(5) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(23), small(4) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(1), small(11), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(1), small(7), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(6), small(23), small(3) },
+	{ small(3), small(21), small(3) },
+	{ small(3), small(15), small(2) },
+	{ small(3), small(8), small(1) },
+	{ small(3), small(24), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(17), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(5), small(11), small(1) },
+	{ small(5), small(11), small(1) },
+	{ small(5), small(18), small(2) },
+	{ small(5), small(20), small(2) },
+	{ small(5), small(18), small(2) },
+	{ small(5), small(11), small(1) },
+	{ small(5), small(24), small(3) },
+	{ small(5), small(21), small(3) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(5), small(24), small(3) },
+	{ small(5), small(10), small(1) },
+	{ small(5), small(25), small(3) },
+	{ small(5), small(22), small(3) },
+	{ small(6), small(15), small(2) },
+	{ small(3), small(13), small(2) },
+	{ small(3), small(8), small(1) },
+	{ small(3), small(16), small(2) },
+	{ small(5), small(15), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(5), small(16), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(5), small(26), small(4) },
+	{ small(5), small(24), small(4) },
+	{ small(5), small(12), small(2) },
+	{ small(5), small(27), small(4) },
+	{ small(5), small(19), small(3) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(5), small(23), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(24), small(3) },
+	{ small(2), small(25), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(5), small(16), small(2) },
+	{ small(5), small(14), small(2) },
+	{ small(5), small(9), small(1) },
+	{ small(5), small(10), small(1) },
+	{ small(5), small(17), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(21), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(1), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(14), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(24), small(3) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(1), small(20), small(3) },
+	{ small(1), small(16), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(1), small(10), small(1) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(23), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(25), small(3) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(1), small(15), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(24), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(1), small(11), small(1) },
+	{ small(1), small(13), small(2) },
+	{ small(1), small(7), small(1) },
+	{ small(1), small(13), small(2) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(1), small(24), small(3) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(1), small(17), small(3) },
+	{ small(1), small(13), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(1), small(6), small(1) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(6), small(1) },
+	{ small(1), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(24), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(22), small(4) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(26), small(4) },
+	{ small(2), small(28), small(4) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(24), small(4) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(32), small(4) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(26), small(4) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(25), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(23), small(3) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(19), small(4) },
+	{ small(2), small(22), small(4) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(39), small(5) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(17), small(3) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(18), small(3) },
+	{ small(1), small(11), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(3), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(26), small(4) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(21), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(17), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(3), small(3), small(1) },
+	{ small(3), small(3), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(3), small(4), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(1), small(3), small(1) },
+	{ small(2), small(3), small(1) },
+	{ small(2), small(11), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(13), small(1) },
+	{ small(1), small(18), small(2) },
+	{ small(1), small(10), small(1) },
+	{ small(1), small(15), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(23), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(19), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(14), small(3) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(1), small(18), small(3) },
+	{ small(3), small(7), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(23), small(3) },
+	{ small(1), small(29), small(4) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(33), small(6) },
+	{ small(2), small(3), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(12), small(1) },
+	{ small(3), small(9), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(25), small(5) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(20), small(2) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(3), small(6), small(1) },
+	{ small(3), small(5), small(1) },
+	{ small(3), small(5), small(1) },
+	{ small(3), small(7), small(1) },
+	{ small(3), small(6), small(1) },
+	{ small(3), small(6), small(1) },
+	{ small(3), small(5), small(1) },
+	{ small(3), small(7), small(1) },
+	{ small(3), small(7), small(1) },
+	{ small(3), small(6), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(3), small(6), small(1) },
+	{ small(3), small(17), small(2) },
+	{ small(3), small(10), small(1) },
+	{ small(2), small(15), small(2) },
+	{ small(1), small(21), small(3) },
+	{ small(1), small(14), small(2) },
+	{ small(1), small(12), small(2) },
+	{ small(1), small(13), small(2) },
+	{ small(1), small(15), small(2) },
+	{ small(1), small(12), small(2) },
+	{ small(1), small(12), small(2) },
+	{ small(1), small(16), small(2) },
+	{ small(1), small(16), small(2) },
+	{ small(1), small(14), small(2) },
+	{ small(1), small(8), small(1) },
+	{ small(1), small(17), small(3) },
+	{ small(1), small(19), small(3) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(16), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(10), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(15), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(27), small(4) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(27), small(3) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(25), small(2) },
+	{ small(2), small(18), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(7), small(1) },
+	{ small(1), small(17), small(3) },
+	{ small(1), small(18), small(3) },
+	{ small(1), small(21), small(3) },
+	{ small(2), small(24), small(3) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(19), small(2) },
+	{ small(1), small(4), small(1) },
+	{ small(1), small(11), small(1) },
+	{ small(1), small(12), small(1) },
+	{ small(1), small(11), small(2) },
+	{ small(1), small(12), small(2) },
+	{ small(1), small(6), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(4), small(1) },
+	{ small(2), small(5), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(18), small(3) },
+	{ small(2), small(23), small(4) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(14), small(2) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(25), small(4) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(22), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(27), small(4) },
+	{ small(2), small(27), small(4) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(21), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(9), small(2) },
+	{ small(2), small(6), small(1) },
+	{ small(2), small(13), small(1) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(5), small(22), small(4) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(17), small(2) },
+	{ small(2), small(20), small(3) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(7), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(13), small(2) },
+	{ small(2), small(22), small(3) },
+	{ small(3), small(9), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(8), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(9), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(10), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(11), small(1) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(19), small(3) },
+	{ small(2), small(12), small(2) },
+	{ small(2), small(16), small(2) },
+	{ small(2), small(25), small(4) },
+	{ small(6), small(16), small(3) },
+	{ small(6), small(14), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(7), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(7), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(11), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(2), small(15), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(9), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(7), small(1) },
+	{ small(4), small(13), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(14), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(8), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+	{ small(4), small(4), small(1) },
+	{ small(4), small(9), small(2) },
+};
+
+const medium ReplacementIndices[] = {
+131, 135, 1208, 1284, 151, 671, 54, 61, 63, 107, 109, 143,
+159, 240, 241, 246, 247, 257, 372, 431, 507, 508, 509, 545,
+563, 564, 578, 661, 662, 682, 683, 684, 688, 762, 770, 771,
+796, 800, 811, 813, 829, 830, 831, 832, 833, 846, 889, 922,
+962, 987, 989, 992, 1006, 1010, 1028, 1031, 1047, 1147, 1158, 1168,
+1171, 1172, 1173, 1188, 1195, 1197, 1209, 1226, 1237, 1240, 1244, 1264,
+1265, 1266, 1286, 1287, 1288, 1300, 1301, 1302, 1303, 1304, 1305, 1306,
+1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318,
+1319, 1322, 1323, 1379, 1380, 1420, 1421, 1422, 1423, 1424, 1425, 1428,
+1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440,
+1441, 1442, 1443, 1444, 1445, 1448, 1449, 1450, 1451, 1452, 1453, 1850,
+1851, 1906, 1907, 11, 94, 95, 155, 156, 159, 182, 183, 184,
+185, 189, 190, 191, 192, 255, 260, 261, 262, 263, 304, 308,
+310, 311, 336, 351, 353, 354, 356, 358, 359, 366, 370, 375,
+383, 395, 412, 413, 419, 421, 425, 426, 427, 430, 444, 452,
+491, 498, 504, 505, 531, 537, 539, 554, 568, 592, 593, 594,
+599, 603, 612, 622, 624, 633, 639, 645, 649, 650, 658, 665,
+667, 674, 679, 683, 685, 686, 710, 711, 712, 713, 714, 735,
+736, 738, 740, 741, 742, 743, 744, 745, 746, 747, 785, 790,
+791, 803, 810, 820, 821, 849, 865, 866, 867, 881, 886, 888,
+895, 901, 922, 932, 933, 968, 970, 992, 996, 1007, 1008, 1009,
+1020, 1021, 1022, 1023, 1030, 1034, 1038, 1041, 1065, 1066, 1076, 1077,
+1078, 1079, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1108, 1109, 1112,
+1129, 1131, 1132, 1176, 1177, 1185, 1196, 1206, 1213, 1222, 1224, 1225,
+1231, 1252, 1256, 1289, 1290, 1292, 1293, 1302, 1339, 1344, 1345, 1347,
+1349, 1353, 1355, 1356, 1357, 1358, 1360, 1362, 1364, 1370, 1371, 1374,
+1376, 1377, 1378, 1379, 1385, 1414, 1415, 1454, 1455, 1456, 1457, 1458,
+1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470,
+1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1488,
+1489, 1490, 1491, 1492, 1493, 1494, 1495, 1506, 1507, 1763, 1764, 1844,
+1845, 23, 26, 35, 36, 37, 38, 44, 50, 68, 69, 107,
+108, 114, 115, 116, 117, 118, 119, 120, 121, 122, 125, 143,
+144, 162, 163, 169, 197, 204, 206, 207, 208, 222, 223, 250,
+251, 320, 323, 324, 325, 326, 327, 328, 329, 331, 333, 361,
+376, 377, 378, 386, 389, 401, 410, 413, 414, 415, 438, 449,
+454, 456, 457, 469, 477, 482, 483, 490, 505, 513, 515, 523,
+532, 534, 535, 537, 538, 539, 540, 542, 543, 544, 545, 546,
+547, 548, 549, 550, 556, 557, 573, 581, 582, 583, 587, 591,
+595, 596, 598, 620, 623, 626, 630, 632, 636, 638, 639, 642,
+646, 651, 652, 656, 658, 659, 679, 680, 706, 707, 708, 709,
+764, 772, 788, 790, 793, 794, 795, 809, 814, 816, 838, 843,
+847, 858, 859, 862, 863, 871, 876, 881, 882, 897, 901, 902,
+916, 917, 918, 919, 926, 927, 929, 936, 939, 942, 943, 944,
+945, 958, 960, 962, 963, 964, 972, 982, 994, 1000, 1003, 1007,
+1028, 1029, 1036, 1041, 1045, 1056, 1063, 1066, 1067, 1068, 1071, 1072,
+1073, 1075, 1076, 1077, 1080, 1081, 1084, 1090, 1092, 1115, 1116, 1123,
+1140, 1145, 1146, 1147, 1154, 1161, 1167, 1190, 1198, 1228, 1233, 1235,
+1238, 1242, 1250, 1251, 1252, 1259, 1266, 1270, 1322, 1323, 1331, 1333,
+1336, 1343, 1344, 1346, 1347, 1348, 1349, 1382, 1386, 1388, 1389, 1390,
+1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402,
+1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1416, 1498, 1499,
+1500, 1501, 1504, 1505, 1510, 1511, 1514, 1515, 1516, 1517, 1518, 1519,
+1520, 1521, 1522, 1523, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533,
+1534, 1535, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1582, 1583,
+1652, 1868, 1869, 15, 16, 41, 64, 70, 71, 72, 133, 152,
+213, 214, 217, 265, 305, 306, 307, 309, 365, 385, 388, 416,
+445, 455, 456, 467, 472, 473, 480, 481, 485, 524, 555, 560,
+561, 605, 628, 641, 657, 709, 777, 778, 783, 784, 832, 868,
+875, 888, 891, 918, 929, 930, 938, 940, 974, 977, 998, 999,
+1027, 1043, 1068, 1074, 1084, 1085, 1090, 1142, 1149, 1150, 1212, 1230,
+1240, 1289, 1300, 1301, 1304, 1308, 1313, 1318, 1328, 1330, 1335, 1351,
+1352, 1353, 1354, 1355, 1384, 1426, 1427, 1484, 1485, 1546, 1547, 1548,
+1549, 1550, 1551, 1552, 1553, 1596, 1597, 19, 22, 23, 25, 26,
+58, 77, 78, 117, 165, 175, 178, 179, 258, 308, 310, 311,
+384, 406, 407, 408, 417, 458, 484, 497, 507, 508, 509, 580,
+597, 797, 858, 893, 969, 979, 1046, 1047, 1048, 1049, 1050, 1133,
+1134, 1185, 1205, 1207, 1218, 1219, 1237, 1281, 1331, 1338, 1376, 1554,
+1555, 1556, 1557, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1838,
+1839, 1840, 1841, 1928, 1929, 8, 13, 15, 28, 30, 32, 35,
+37, 45, 46, 47, 48, 51, 57, 60, 64, 65, 67, 72,
+77, 80, 83, 85, 88, 90, 92, 93, 94, 111, 121, 138,
+139, 140, 141, 142, 143, 144, 157, 159, 165, 166, 177, 220,
+221, 230, 231, 242, 243, 280, 281, 282, 283, 284, 290, 293,
+294, 295, 300, 303, 335, 336, 337, 338, 339, 340, 341, 342,
+343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354,
+355, 356, 357, 358, 359, 360, 393, 394, 396, 400, 404, 405,
+423, 442, 443, 479, 481, 490, 494, 501, 510, 516, 518, 519,
+520, 521, 522, 529, 530, 554, 558, 594, 601, 608, 610, 616,
+620, 634, 661, 662, 663, 666, 670, 678, 684, 698, 699, 700,
+752, 753, 797, 821, 844, 848, 856, 861, 873, 883, 915, 923,
+938, 943, 946, 948, 952, 966, 971, 1004, 1032, 1033, 1039, 1064,
+1076, 1080, 1082, 1083, 1110, 1111, 1187, 1230, 1272, 1277, 1278, 1288,
+1298, 1386, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1421, 1423,
+1425, 1427, 1429, 1431, 1433, 1435, 1437, 1439, 1441, 1443, 1445, 1447,
+1449, 1451, 1453, 1455, 1457, 1459, 1461, 1463, 1465, 1467, 1469, 1471,
+1473, 1475, 1477, 1479, 1481, 1483, 1485, 1487, 1489, 1491, 1493, 1495,
+1497, 1499, 1501, 1503, 1505, 1507, 1509, 1511, 1513, 1515, 1517, 1519,
+1521, 1523, 1525, 1527, 1529, 1531, 1533, 1535, 1537, 1539, 1541, 1543,
+1545, 1547, 1549, 1551, 1553, 1555, 1557, 1559, 1561, 1563, 1565, 1567,
+1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1579, 1580, 1581,
+1583, 1585, 1587, 1589, 1591, 1593, 1595, 1597, 1599, 1601, 1603, 1605,
+1607, 1609, 1611, 1613, 1615, 1617, 1619, 1621, 1623, 1625, 1627, 1629,
+1631, 1633, 1635, 1637, 1639, 1641, 1643, 1645, 1647, 1649, 1651, 1652,
+1654, 1656, 1658, 1660, 1662, 1664, 1666, 1668, 1670, 1672, 1674, 1676,
+1678, 1680, 1682, 1684, 1686, 1688, 1690, 1692, 1694, 1696, 1698, 1700,
+1702, 1704, 1706, 1708, 1710, 1712, 1714, 1715, 1716, 1718, 1720, 1722,
+1724, 1726, 1728, 1730, 1732, 1734, 1736, 1738, 1740, 1742, 1744, 1746,
+1748, 1750, 1752, 1754, 1756, 1758, 1760, 1762, 1764, 1766, 1768, 1770,
+1772, 1774, 1776, 1778, 1780, 1782, 1784, 1786, 1788, 1790, 1792, 1794,
+1796, 1798, 1800, 1802, 1804, 1806, 1809, 1811, 1813, 1815, 1817, 1819,
+1821, 1823, 1825, 1827, 1829, 1831, 1833, 1835, 1837, 1839, 1841, 1843,
+1845, 1847, 1849, 1851, 1853, 1855, 1857, 1859, 1861, 1863, 1865, 1867,
+1869, 1871, 1873, 1875, 1877, 1879, 1881, 1883, 1885, 1887, 1889, 1891,
+1893, 1895, 1897, 1899, 1901, 1903, 1905, 1907, 1909, 1911, 1913, 1915,
+1917, 1919, 1921, 1923, 1925, 1927, 1929, 1931, 1933, 1935, 0, 3,
+84, 99, 104, 186, 194, 196, 209, 210, 211, 212, 268, 269,
+270, 271, 272, 274, 275, 296, 298, 299, 300, 302, 303, 352,
+353, 355, 357, 358, 360, 461, 464, 511, 517, 563, 570, 613,
+643, 651, 652, 653, 655, 675, 676, 680, 681, 685, 686, 719,
+720, 721, 722, 781, 783, 786, 864, 885, 983, 993, 995, 1037,
+1093, 1128, 1141, 1160, 1219, 1221, 1239, 1418, 1560, 1561, 1584, 1585,
+1590, 1591, 1592, 1593, 1594, 1595, 1598, 1599, 1600, 1601, 1602, 1603,
+1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615,
+1616, 1617, 1618, 1619, 1620, 1621, 1826, 1827, 1908, 1909, 19, 20,
+30, 31, 37, 59, 79, 94, 95, 101, 117, 123, 124, 127,
+128, 143, 146, 148, 154, 155, 156, 157, 158, 159, 162, 165,
+167, 180, 181, 189, 190, 191, 192, 218, 219, 264, 266, 267,
+276, 277, 278, 279, 296, 297, 298, 299, 321, 322, 323, 324,
+325, 327, 368, 373, 377, 378, 382, 391, 407, 414, 415, 422,
+488, 506, 584, 590, 605, 606, 607, 677, 678, 715, 716, 717,
+718, 739, 774, 828, 863, 884, 885, 886, 887, 888, 889, 894,
+896, 899, 965, 966, 986, 987, 988, 989, 1013, 1061, 1126, 1127,
+1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139,
+1141, 1142, 1210, 1225, 1285, 1315, 1316, 1317, 1318, 1326, 1327, 1328,
+1329, 1330, 1343, 1383, 1446, 1447, 1536, 1537, 1622, 1623, 1624, 1625,
+1626, 1627, 1628, 1629, 12, 96, 97, 110, 143, 180, 182, 183,
+256, 265, 304, 629, 630, 631, 689, 868, 869, 925, 1044, 1048,
+1052, 1075, 1084, 1122, 1170, 1188, 1223, 1240, 1258, 1263, 1376, 1482,
+1483, 1502, 1503, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638,
+1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 7, 98, 99,
+113, 116, 248, 249, 363, 765, 766, 767, 768, 769, 859, 907,
+935, 1385, 1648, 1649, 1650, 1651, 1653, 1654, 1655, 1656, 20, 21,
+22, 23, 119, 172, 330, 332, 334, 367, 397, 576, 577, 661,
+662, 663, 687, 776, 837, 905, 928, 958, 997, 998, 1024, 1025,
+1026, 1123, 1261, 1283, 1286, 1496, 1497, 1508, 1509, 1524, 1525, 1657,
+1658, 1659, 1660, 1661, 1662, 1665, 1666, 1667, 1668, 1755, 1756, 1834,
+1835, 1852, 1853, 5, 8, 82, 83, 113, 129, 139, 140, 149,
+171, 173, 304, 399, 400, 436, 450, 490, 493, 494, 495, 512,
+522, 547, 548, 567, 602, 637, 693, 694, 695, 696, 697, 800,
+808, 822, 823, 850, 851, 855, 899, 957, 1028, 1044, 1051, 1055,
+1091, 1099, 1101, 1108, 1110, 1113, 1115, 1122, 1123, 1124, 1145, 1162,
+1164, 1212, 1224, 1230, 1253, 1258, 1306, 1310, 1311, 1312, 1314, 1316,
+1336, 1337, 1354, 1355, 1364, 1365, 1369, 1373, 1374, 1375, 1669, 1670,
+1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682,
+1683, 1684, 1685, 1686, 1842, 1843, 1854, 1855, 28, 29, 56, 62,
+85, 86, 91, 143, 147, 159, 162, 163, 164, 165, 166, 187,
+190, 193, 196, 197, 199, 200, 203, 207, 210, 214, 219, 221,
+223, 225, 227, 229, 231, 233, 235, 236, 237, 239, 241, 243,
+245, 247, 249, 250, 251, 256, 261, 267, 271, 275, 279, 281,
+288, 292, 295, 299, 300, 301, 302, 303, 304, 306, 307, 311,
+313, 317, 322, 324, 327, 328, 330, 333, 334, 336, 337, 338,
+339, 340, 346, 347, 348, 349, 350, 356, 357, 358, 359, 360,
+371, 375, 390, 405, 409, 475, 495, 496, 510, 511, 512, 513,
+514, 515, 516, 517, 518, 519, 521, 522, 523, 572, 603, 643,
+644, 688, 694, 702, 707, 711, 718, 720, 724, 728, 732, 736,
+741, 744, 745, 746, 747, 749, 750, 751, 752, 754, 756, 766,
+773, 775, 776, 787, 798, 804, 805, 806, 807, 814, 818, 819,
+825, 840, 852, 853, 854, 870, 871, 872, 873, 880, 903, 912,
+921, 932, 933, 937, 945, 955, 956, 963, 976, 981, 1012, 1050,
+1056, 1057, 1058, 1059, 1117, 1120, 1121, 1133, 1152, 1178, 1179, 1216,
+1226, 1233, 1238, 1239, 1241, 1254, 1324, 1327, 1329, 1343, 1360, 1361,
+1362, 1363, 1367, 1372, 1387, 1578, 1579, 1687, 1688, 1689, 1690, 1691,
+1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703,
+1704, 1705, 1706, 1707, 1708, 1709, 1710, 1713, 1714, 1717, 1718, 1719,
+1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731,
+1732, 1757, 1758, 32, 33, 56, 57, 88, 169, 176, 268, 269,
+270, 271, 364, 403, 406, 407, 408, 514, 518, 675, 909, 920,
+922, 992, 1059, 1069, 1070, 1086, 1087, 1088, 1089, 1090, 1112, 1205,
+1206, 1207, 1211, 1212, 1213, 1214, 1216, 1217, 1238, 1267, 1271, 1282,
+1294, 1295, 1324, 1325, 1371, 1733, 1734, 1735, 1736, 1737, 1738, 1739,
+1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751,
+1752, 1753, 1754, 1761, 1762, 8, 25, 26, 27, 62, 98, 113,
+123, 146, 148, 155, 156, 193, 195, 202, 203, 205, 215, 234,
+235, 272, 273, 274, 275, 418, 440, 453, 472, 497, 559, 603,
+616, 627, 643, 809, 810, 811, 812, 835, 855, 864, 890, 892,
+893, 912, 974, 975, 1025, 1053, 1083, 1095, 1133, 1148, 1149, 1150,
+1154, 1156, 1157, 1178, 1199, 1202, 1204, 1268, 1274, 1321, 1340, 1352,
+1354, 1417, 1765, 1766, 42, 49, 100, 103, 122, 126, 137, 149,
+150, 151, 152, 153, 159, 191, 192, 196, 201, 202, 203, 205,
+244, 245, 253, 254, 259, 263, 265, 266, 270, 274, 278, 283,
+284, 287, 289, 290, 291, 292, 294, 298, 302, 308, 310, 311,
+315, 319, 380, 381, 396, 402, 403, 411, 463, 468, 472, 478,
+486, 536, 565, 574, 575, 584, 585, 586, 588, 589, 590, 600,
+602, 604, 609, 615, 616, 635, 640, 658, 662, 663, 673, 684,
+697, 700, 705, 709, 712, 713, 714, 715, 717, 718, 722, 726,
+730, 731, 732, 733, 734, 738, 743, 747, 752, 753, 754, 755,
+756, 757, 769, 770, 795, 809, 842, 892, 893, 909, 910, 931,
+946, 947, 951, 969, 980, 987, 988, 991, 1008, 1014, 1018, 1032,
+1033, 1054, 1060, 1061, 1063, 1064, 1069, 1071, 1100, 1101, 1102, 1105,
+1106, 1108, 1109, 1110, 1111, 1113, 1114, 1118, 1119, 1122, 1130, 1143,
+1144, 1151, 1156, 1169, 1178, 1185, 1211, 1214, 1216, 1226, 1247, 1250,
+1258, 1290, 1291, 1296, 1297, 1326, 1386, 1417, 1418, 1586, 1587, 1767,
+1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779,
+1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1856,
+1857, 512, 516, 521, 522, 1220, 1221, 1791, 1792, 8, 9, 10,
+18, 55, 70, 77, 78, 111, 112, 124, 141, 142, 150, 154,
+156, 157, 159, 165, 170, 276, 277, 278, 279, 316, 317, 318,
+319, 392, 459, 460, 462, 465, 470, 474, 476, 497, 500, 502,
+539, 540, 541, 543, 544, 545, 546, 618, 624, 625, 626, 670,
+735, 736, 737, 738, 739, 748, 759, 760, 788, 793, 794, 806,
+808, 815, 816, 818, 822, 834, 862, 878, 879, 908, 949, 954,
+1040, 1086, 1103, 1104, 1106, 1121, 1136, 1174, 1175, 1232, 1257, 1293,
+1299, 1305, 1309, 1310, 1314, 1315, 1319, 1320, 1321, 1334, 1345, 1348,
+1350, 1351, 1379, 1380, 1419, 1793, 1794, 1795, 1796, 1797, 1798, 1799,
+1800, 1812, 1813, 1, 2, 4, 6, 13, 14, 22, 25, 26,
+27, 34, 39, 45, 46, 66, 68, 73, 74, 75, 76, 87,
+89, 90, 96, 102, 105, 106, 107, 108, 110, 114, 115, 118,
+120, 127, 146, 157, 158, 168, 180, 181, 182, 183, 215, 216,
+224, 225, 226, 227, 238, 239, 252, 285, 286, 287, 288, 304,
+362, 369, 371, 372, 379, 385, 406, 408, 428, 429, 432, 433,
+435, 437, 439, 441, 446, 466, 487, 489, 503, 520, 525, 526,
+527, 533, 534, 535, 536, 537, 538, 539, 540, 549, 550, 551,
+552, 553, 561, 571, 586, 588, 601, 609, 610, 613, 614, 616,
+617, 619, 621, 629, 648, 660, 664, 689, 690, 691, 692, 723,
+724, 725, 726, 727, 728, 729, 730, 748, 749, 754, 755, 775,
+779, 787, 802, 805, 815, 820, 823, 827, 829, 830, 835, 836,
+839, 841, 842, 843, 845, 855, 860, 871, 872, 882, 891, 897,
+898, 904, 906, 908, 911, 912, 913, 914, 916, 917, 920, 955,
+957, 959, 966, 967, 984, 1000, 1001, 1002, 1015, 1019, 1031, 1034,
+1035, 1036, 1062, 1069, 1070, 1071, 1072, 1104, 1107, 1139, 1143, 1147,
+1148, 1150, 1151, 1155, 1165, 1166, 1171, 1174, 1176, 1185, 1189, 1200,
+1203, 1204, 1207, 1217, 1236, 1237, 1238, 1240, 1249, 1256, 1260, 1262,
+1263, 1279, 1280, 1292, 1303, 1304, 1326, 1327, 1328, 1330, 1342, 1350,
+1351, 1352, 1353, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364,
+1365, 1366, 1368, 1369, 1374, 1375, 1376, 1377, 1381, 1558, 1559, 1759,
+1760, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1814, 1815,
+1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1828, 1829,
+1830, 1831, 1836, 1837, 1848, 1849, 1860, 1861, 1862, 1863, 1864, 1865,
+1866, 1867, 1870, 1871, 8, 25, 26, 27, 51, 53, 80, 81,
+92, 93, 130, 132, 134, 136, 146, 174, 198, 199, 200, 201,
+228, 229, 232, 233, 256, 264, 266, 267, 321, 322, 374, 398,
+434, 442, 451, 471, 483, 484, 485, 486, 492, 499, 545, 546,
+556, 557, 566, 579, 611, 647, 655, 657, 668, 672, 756, 757,
+758, 761, 762, 763, 764, 780, 789, 792, 799, 801, 812, 813,
+817, 824, 826, 850, 851, 857, 877, 878, 879, 932, 933, 934,
+949, 950, 953, 960, 961, 990, 1011, 1016, 1017, 1035, 1042, 1052,
+1053, 1065, 1067, 1068, 1103, 1135, 1159, 1229, 1275, 1276, 1283, 1294,
+1295, 1296, 1297, 1319, 1332, 1341, 1350, 1351, 1378, 1417, 1512, 1513,
+1588, 1589, 1846, 1847, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
+1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891,
+1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 15, 16, 40, 151,
+153, 386, 387, 423, 424, 562, 687, 688, 864, 865, 866, 1004,
+1005, 1064, 1067, 1086, 1125, 1180, 1181, 1182, 1183, 1184, 1191, 1192,
+1193, 1194, 1215, 1234, 1248, 1269, 1300, 1303, 1307, 1309, 1312, 1313,
+1317, 1902, 1903, 1904, 1905, 1910, 1911, 1912, 1913, 1914, 1915, 1916,
+1917, 145, 160, 255, 669, 782, 786, 850, 874, 941, 944, 1163,
+1179, 1186, 1289, 1486, 1487, 1858, 1859, 1900, 1901, 1918, 1919, 1920,
+1921, 1922, 1923, 1924, 1925, 17, 25, 37, 43, 47, 52, 77,
+92, 94, 143, 157, 159, 161, 165, 167, 188, 189, 191, 195,
+196, 197, 198, 199, 200, 201, 202, 206, 207, 208, 209, 213,
+218, 219, 220, 222, 224, 226, 228, 230, 231, 232, 234, 235,
+236, 238, 240, 242, 244, 246, 248, 255, 258, 259, 260, 264,
+268, 272, 273, 276, 280, 285, 289, 290, 293, 296, 300, 308,
+310, 311, 312, 313, 314, 315, 316, 321, 323, 324, 325, 326,
+327, 330, 331, 332, 336, 341, 342, 343, 344, 345, 351, 352,
+353, 354, 355, 361, 373, 377, 378, 420, 433, 447, 448, 452,
+501, 502, 511, 513, 515, 517, 518, 519, 520, 521, 522, 534,
+535, 537, 538, 539, 540, 543, 547, 549, 554, 556, 569, 595,
+653, 654, 658, 662, 693, 694, 695, 697, 701, 702, 703, 704,
+705, 706, 710, 712, 715, 719, 723, 727, 731, 732, 733, 734,
+735, 740, 744, 748, 765, 777, 852, 861, 866, 885, 900, 920,
+921, 924, 943, 973, 976, 985, 989, 1018, 1032, 1045, 1047, 1058,
+1059, 1063, 1067, 1068, 1078, 1090, 1122, 1123, 1149, 1155, 1156, 1187,
+1214, 1227, 1233, 1239, 1240, 1245, 1246, 1255, 1316, 1335, 1344, 1346,
+1356, 1359, 1361, 1363, 1365, 1412, 1413, 1414, 1801, 1802, 1926, 1927,
+1201, 1329, 1663, 1664, 24, 978, 1127, 1153, 1711, 1712, 1930, 1931,
+85, 86, 528, 1243, 1273, 1832, 1833, 1932, 1933, 1934, 1935 };
+
+struct ReplacementIndexStruct {
+	utf16char ch;
+	medium count;
+};
+
+const checksum ReplacementChecksums[] = {
+
+0xAE1DAB16U, 0x8F27A2AU, 0x465496D5U, 0x892E9135U, 0xD621DD31U, 0x40D5B583U, 0x23598B8CU, 0x174C4A14U, 0x9739B1DAU, 0xF448853DU, 0xF3DF7DF2U, 0x15D5108FU,
+0xE8A0D4E8U, 0x8FBCAF62U, 0x95F9E2A9U, 0x47CEA738U, 0x839E1EBCU, 0xA58AFD2AU, 0xAAA850BDU, 0xBBEE1755U, 0x4F9A8CDDU, 0x77C2915FU, 0x42B9AA72U, 0xABB65511U,
+0x984E9DE9U, 0x229620B8U, 0x11744AD7U, 0xDEA4DF8BU, 0x3DDDF327U, 0xC9016AA9U, 0xDD058F8EU, 0x33167FFDU, 0xCF4EB7B4U, 0x5E990F1U, 0xB6610B6U, 0xF3DA224AU,
+0xDDF16CC9U, 0x26FBBFD8U, 0xF0D58D6U, 0x9F57820DU, 0xCAEFB5CCU, 0x868C5775U, 0x36F0B13EU, 0xC2104FC3U, 0x635ED438U, 0xFE76A6BFU, 0xAF98DEFEU, 0xC4A1CE0BU,
+0x24A144DU, 0xA07F4113U, 0xA1B56E69U, 0x7AC6D4C1U, 0xA6737D27U, 0x3841C7E7U, 0x7BD9C74BU, 0x57960B20U, 0xA3016C3FU, 0x47DE3B8DU, 0x347522B4U, 0x3DD97630U,
+0x283C812CU, 0x62FCCC72U, 0x2A8707F7U, 0x4CAAF872U, 0x7DE5251FU, 0xA1CE4738U, 0x65284ADEU, 0x3CAC3D83U, 0xBBB37EE8U, 0xB74B407AU, 0xBB721077U, 0xD5827C60U,
+0xE79C25ACU, 0xF3A0B08AU, 0x754CB19FU, 0xC53F5EC8U, 0x2FB36C45U, 0x8A111CA0U, 0x16625752U, 0xC7DA2CAAU, 0x50A359D4U, 0x9E85659AU, 0xA6832DF5U, 0x7F7A32B5U,
+0x349608E1U, 0x3CA5EFD1U, 0xBEEDA352U, 0x10FF4E8EU, 0x5A37598EU, 0x92500B16U, 0xD5E5CEF4U, 0xF9ABE6FBU, 0xEF0313FDU, 0x5D682C8AU, 0xD1D48498U, 0x4DA7CF6AU,
+0x2B17F5C6U, 0xA903A376U, 0xCA823961U, 0x829E9619U, 0x8F456FB4U, 0xCC6B224AU, 0x75B42ABFU, 0xCD7DECEFU, 0x73290221U, 0xDF8E5CD8U, 0x1D568D7CU, 0x7F2FCD63U,
+0x539DB28DU, 0xB9BB5841U, 0x88EB5D8DU, 0x30B6C9CCU, 0xEA5F5485U, 0xF282B417U, 0x46508060U, 0x8C9D5E3EU, 0xBC04162BU, 0xFA329E5DU, 0xC885E4CCU, 0xDCBF9DCAU,
+0x4715B337U, 0x2FDC1366U, 0x3E3BBA50U, 0x9F2BF2CU, 0x73F18BAU, 0xB561B097U, 0x6DC1E6EFU, 0x9000A7E8U, 0xEE613496U, 0xCAD661B5U, 0xADEFBC1EU, 0x717A2494U,
+0x10ED817CU, 0xD5497538U, 0xC264618U, 0xA723C789U, 0x365CA2E0U, 0xC4AE628U, 0xDAD44170U, 0x69B2A699U, 0xFA94A82BU, 0x9500E45FU, 0x641EDBEU, 0xBBC0F4D2U,
+0xE21AA1F5U, 0x7FDEA451U, 0x5F8E4A17U, 0x9682906DU, 0x41B84148U, 0x6659DDC9U, 0xBA4A5BADU, 0x14B31920U, 0x1360E730U, 0x590C5708U, 0xF019A4AAU, 0x5089CA96U,
+0xF0B0E775U, 0xFDD90E49U, 0x1BF1824BU, 0xE13025FCU, 0xEF137B9DU, 0x7935115AU, 0x718BD26AU, 0xF09E5811U, 0x7BA332A6U, 0xA7615393U, 0x73FAF11U, 0x55936B7CU,
+0x141AF304U, 0x65E071DDU, 0x97589D6U, 0x73A15F22U, 0xB2FDF279U, 0xD6B59BAEU, 0x27ABA3E6U, 0x2367BEC9U, 0xE7C938F9U, 0x560FEC09U, 0x12C5119U, 0x5001267U,
+0x85080CCDU, 0xA3B79EC5U, 0x960F8445U, 0xF895CC46U, 0x3A3AF35CU, 0xC4A951A1U, 0x6BE7869BU, 0xEA4D4D5BU, 0xAE72E7B2U, 0x4282D2C1U, 0x33ECB6EBU, 0x4415ADC3U,
+0xC78A4A6EU, 0xA58D62B2U, 0xF3E3048EU, 0x1B8D6392U, 0x147A0701U, 0xE63DAAF0U, 0x8DDD9273U, 0xF5A4B231U, 0x9FF25F7FU, 0xDDEA0DB3U, 0x5CEB285U, 0x7DB792C7U,
+0x750B1EB5U, 0x57AE509CU, 0xC8F777C2U, 0xBCD1360BU, 0x632D2CA8U, 0xBC462336U, 0x602E733DU, 0x2194100DU, 0x2FB69E71U, 0x58D9C98U, 0xD3907616U, 0x40B025B8U,
+0x8638D05AU, 0xE4433DD5U, 0xB399E080U, 0xEB05158DU, 0x21E41D29U, 0xA97B497EU, 0x7DF9E406U, 0x2B2DDA74U, 0xBA0D8072U, 0x23F15693U, 0x69AB4478U, 0xE134102FU,
+0x8522D229U, 0x1CDE04C8U, 0x1021B3B1U, 0x685893F3U, 0x548FAB48U, 0x3926C75EU, 0xCD7FFCC1U, 0x95E309CCU, 0x70DCC40DU, 0x5809E8BDU, 0xC3D9F1CBU, 0x15C41B45U,
+0x461F4802U, 0xCE801C55U, 0x39156F0DU, 0x3AE08EU, 0x8D001528U, 0x51684523U, 0x85F53FF7U, 0x53E8D579U, 0x81AED8F1U, 0x5DC688FAU, 0x88B16330U, 0x43104043U,
+0x364A68E3U, 0xA3F2B218U, 0x84AC213BU, 0x752D5FFCU, 0xA15A7026U, 0x2CD52C5U, 0x8C136450U, 0x1A32A58U, 0xBE1AD3FCU, 0x368587ABU, 0x24762692U, 0xDB6866FU,
+0xDBFE03C1U, 0x32805E0BU, 0xBDB344CU, 0xB6576FD7U, 0xCE602BD5U, 0xD9A1C5D8U, 0x1E451C58U, 0xA3C947C3U, 0x8A5E6F27U, 0xA76375AEU, 0x5A7B58AAU, 0xE7F70331U,
+0x9E18A785U, 0x5E2B2BB3U, 0x4E3D9008U, 0xF3B1CB93U, 0xFE1D8CFCU, 0xC732037FU, 0xE5F2028FU, 0x922F93ECU, 0x3B1CD1U, 0x489442A4U, 0xF7CEB34U, 0xE3308006U,
+0x9E89A82AU, 0x88E25FD7U, 0xBA9183F8U, 0xC98F90D9U, 0x111E8936U, 0xAB056753U, 0x3E5DD491U, 0x83D04BE3U, 0x7419BEF7U, 0xDEC343D9U, 0xDF53B75BU, 0x8D38CBC1U,
+0x9E65B31DU, 0x49E9647BU, 0x487990F9U, 0x8586DA3AU, 0x8D4BA4A5U, 0xE27A2FD3U, 0xCF0F75B3U, 0x506B7DCCU, 0x7729EE20U, 0x83A892CEU, 0x1724B686U, 0x1D5443E6U,
+0xF994FF2AU, 0x606829CBU, 0x4F6BD1AEU, 0xB8F93024U, 0xF6C1C490U, 0x6F3D1271U, 0xE8119B5BU, 0xB7AC0B9EU, 0xA93D2434U, 0x9CBC7723U, 0x5384167CU, 0x6CC02C32U,
+0xE3AEFA3BU, 0x96ACCCB8U, 0x93EDFEB5U, 0xB455ABEU, 0xE0468B3U, 0xD2638E77U, 0x85F33C85U, 0x53C0FE60U, 0x40A0CF69U, 0xCE296866U, 0xDD49596FU, 0x89ED9A7CU,
+0xB2168218U, 0x2A16FE9FU, 0xC6158813U, 0x96D819A0U, 0xF1CB7821U, 0xF0B3234EU, 0xC76DD37CU, 0xF6999932U, 0xA6540881U, 0xC1476900U, 0xBF852F50U, 0x885BDF62U,
+0x2B6EA5F0U, 0x7BA33443U, 0x1CB055C2U, 0x406B945CU, 0x21FBAB96U, 0x25A9EEF7U, 0x29D0280DU, 0xDCD83354U, 0x95D847CAU, 0x193AD0D7U, 0x65149603U, 0x875F1D51U,
+0xF2D6AE5EU, 0x9E89C614U, 0x71040E80U, 0x2F6DB3B1U, 0x4FBD2D4DU, 0x382CE581U, 0x8682E54AU, 0xC6CE3C16U, 0xD0CDB310U, 0xC097D2DCU, 0x61442A6DU, 0x803FC77EU,
+0xBFABF3D6U, 0x2AB83F69U, 0xB70E7066U, 0x1BED886U, 0xE496DD92U, 0x125067C1U, 0xF2BDF6E8U, 0xA1E56DA4U, 0x1D17DA74U, 0xD6E2180AU, 0x96AAE39BU, 0x9E79ED3CU,
+0xFE814EF2U, 0x55E387B6U, 0x38A8B47FU, 0x1BD7ADCCU, 0xB200788AU, 0xC063E892U, 0x7E1CEC20U, 0x62C476EDU, 0xF83527BEU, 0xCB64655U, 0xF85F383EU, 0xEFE50809U,
+0xA32D4B9DU, 0x14325108U, 0xC46CF3FCU, 0x8646A4A2U, 0x24231E6EU, 0xE8DC260CU, 0x9CA8A446U, 0x4A5517EBU, 0xCDBD569CU, 0xB4C0F066U, 0xF1C615D9U, 0x14C9784FU,
+0xC35ACFA4U, 0xA1F99F39U, 0xDB5D327U, 0x16208387U, 0x487A6530U, 0x8B83FB15U, 0x47AA297BU, 0xA6838556U, 0xFE99F07BU, 0xAAC72C75U, 0xD7EE632BU, 0xCC9E80CU,
+0xDC478D7BU, 0x7E2514C1U, 0xEC7A9229U, 0x7EFF1AE2U, 0xDA58F332U, 0x7FFD9AE0U, 0xD62250F0U, 0x36FF2FD3U, 0x5343E85AU, 0x8ADA0754U, 0x7DE1A231U, 0x73105D3AU,
+0x9EA10A8CU, 0x454632DU, 0x2AFBA286U, 0x638306DBU, 0xD0EE5B94U, 0xBDBA49B8U, 0x26400C9AU, 0xB8A32501U, 0xED50973AU, 0x96A4B4A6U, 0x532A2EC9U, 0xC01BA957U,
+0x11CDDFF8U, 0x38F60BF1U, 0xAA9B52FCU, 0x709E7D5BU, 0xD63F1DE9U, 0xE5D7E3BU, 0xF7AF95C2U, 0x3D792D12U, 0x77418D32U, 0x3AF7B59U, 0xDF7CC644U, 0x796A3A58U,
+0x2A0F1115U, 0x8E3D8B1FU, 0x3EE734ECU, 0xA157B457U, 0x19AD5091U, 0xA348A4DCU, 0x4F107817U, 0xD65CF7B3U, 0xBD678059U, 0x5D63C132U, 0xB71ABEBBU, 0x3E76DFA6U,
+0x7B931373U, 0x4C62A6D8U, 0x57F03940U, 0xB2A038EEU, 0x5FDF9A23U, 0xA0263983U, 0x7E882A01U, 0x9DFC1084U, 0x7072D927U, 0xD8FDE69FU, 0xE0E7157BU, 0x58F4B5B9U,
+0x57E98EE9U, 0x2B7F17D5U, 0xBF5D536FU, 0x19B4B8DDU, 0x670EE546U, 0x759F5B56U, 0x521D3385U, 0x54FF4F92U, 0x2D9CBF6AU, 0xD0F0ACFBU, 0x41F4137CU, 0x3ECD73DCU,
+0xD98F534U, 0xAFC9093DU, 0x11EB63E2U, 0x69341E0FU, 0x45C58EDBU, 0xDFF71D29U, 0xBACC8D3CU, 0x795F863CU, 0xDA5B599FU, 0x756A6CFCU, 0x492FD69AU, 0x29F01476U,
+0x6E924FB3U, 0xE8B85ECU, 0x2AC4EC3FU, 0xF77C2327U, 0x4D7BA0B7U, 0xC9C38BCEU, 0xC46345A2U, 0xA8C65A6U, 0x1A0CBBA0U, 0xC6B953FBU, 0xF469483CU, 0xE8DBA058U,
+0x55E1E9EDU, 0x220DF006U, 0x752BEE8CU, 0xFBB8B0D5U, 0x16F0C1B5U, 0x6F47CA15U, 0xE7DF0A66U, 0x93AA672CU, 0xA4B0DB5U, 0x9798D36AU, 0x210C73B2U, 0x2D884E0BU,
+0x2CF555C5U, 0x2594AF17U, 0xF92DA22FU, 0x4C553278U, 0x559C4DCU, 0x2FEF17FCU, 0xF479A777U, 0x13EC6D08U, 0x507AFB0FU, 0x3DBD6B73U, 0xD3DAA910U, 0x56D07CCDU,
+0x76F544DDU, 0x8D972880U, 0xFF842DA6U, 0xAB51C2E8U, 0xFE925847U, 0x1266FB35U, 0x9951A06U, 0xD3FF1DF6U, 0x51D302CEU, 0x66FB4072U, 0x3338DADDU, 0x67610EA3U,
+0x8FD669ECU, 0xE3411213U, 0xA28A9DA9U, 0x170B62DFU, 0x46D9B7D7U, 0x3BAA86EEU, 0xF0257FF7U, 0x6DBF878BU, 0x520CEC4CU, 0x4A7596BEU, 0x732E55FDU, 0x36069DA1U,
+0x17D3C5EEU, 0xCCBE59DCU, 0xF17154B8U, 0xFED05FF9U, 0x70F66BAAU, 0x668A255FU, 0x5E1E3F24U, 0xC6AA9101U, 0xA9DF1308U, 0x1CE8989FU, 0xF2C4756CU, 0x606CB509U,
+0x2394B2A6U, 0x16C80794U, 0x2A219240U, 0xAE1222A3U, 0x8CB97B86U, 0x4CACE737U, 0x8EC4A97AU, 0xE6AE7EDU, 0xB911D42CU, 0x6C05079AU, 0x2A97030AU, 0x1E97978CU,
+0xA9209129U, 0x859AA93BU, 0xC97EF510U, 0x66821408U, 0x54C18CD7U, 0x66B85367U, 0x5C604485U, 0x3A9FAE2U, 0x3CD0C352U, 0x92F9FA79U, 0xC17824C7U, 0xB803EAFU,
+0x538FB0D3U, 0x948FC967U, 0x41D70FEBU, 0x8F21EB7FU, 0x90F8A446U, 0xD768A2BEU, 0xDDABF113U, 0xD17178C2U, 0x56378FD7U, 0xBED2C72U, 0x93D47BEAU, 0xAEA4D915U,
+0xF5601C83U, 0x317F54CBU, 0x10AA0C84U, 0xD907DC46U, 0xE342A78AU, 0xBD65E28U, 0xB389E207U, 0x3BD7614EU, 0xC08B5199U, 0x4E118784U, 0x48C31E39U, 0x7CF71C84U,
+0xB0B24B2CU, 0x1FE25283U, 0x629F7C2DU, 0x57EF2916U, 0x2B576B96U, 0xCE051BEAU, 0xEC16C919U, 0xBFF3A0CBU, 0xE838218DU, 0xEE352A21U, 0xE38E5B7FU, 0x3A8BB7DFU,
+0x1F0ECE93U, 0x5385D9B7U, 0xAC29F8F4U, 0x575DB2ADU, 0xACBF183FU, 0x567EEE14U, 0xE8AD89DBU, 0xE3E9CEBBU, 0xD8CE4D00U, 0xBA789F5AU, 0xF87F77BBU, 0x4A4B351BU,
+0xCF96A065U, 0x74744A1FU, 0xD93F0955U, 0x4F6722B3U, 0xFDCD24EEU, 0xE6A9F921U, 0x166CC0D6U, 0xB92186A0U, 0x29211071U, 0xD978BCDDU, 0xB14992FCU, 0x19854E77U,
+0x3FE60A5U, 0x58FC1E58U, 0x10475664U, 0xDAFCA3E6U, 0xFDCAE1D1U, 0x82D2915DU, 0xE3DFF22AU, 0x130FDF55U, 0xD3B59A0FU, 0xD5F60290U, 0x6CCD0385U, 0x58438A99U,
+0xDE26F199U, 0x3E40DEB9U, 0x706B5E46U, 0x3B8DBFD5U, 0x28CAFF29U, 0xD0A47AE4U, 0x3AA9B57AU, 0x8504AFF7U, 0x5E28BCA3U, 0xFBE90C93U, 0xEAD04C12U, 0xCB24B726U,
+0xF6C65A18U, 0x2A34D380U, 0x62E270A6U, 0x6E546C36U, 0x31006A54U, 0x29503BFAU, 0xBF30759DU, 0xA18BD87CU, 0xA2D5259U, 0x34D4508EU, 0xCDF525B8U, 0xD28710F0U,
+0xB2863FDDU, 0x9F9E5922U, 0xE1642FD1U, 0x12D001U, 0x16F6CE5BU, 0x70B1EF12U, 0xA6AC059CU, 0xBBEBD881U, 0x472BCFE6U, 0xE62890CU, 0xA80B1464U, 0xC5A27872U,
+0x3BEA65ABU, 0xA8392847U, 0x279F356AU, 0x7F03C067U, 0x7D764E6CU, 0xA208B04BU, 0x110FA646U, 0xFC591AA1U, 0x4B671A82U, 0x8737FAAAU, 0x552AF746U, 0x21D61F84U,
+0xB82AC965U, 0x3B3F074FU, 0x60BBD08AU, 0x426CB588U, 0xDB906369U, 0x9B6900FEU, 0x3017A86U, 0xEEDF7292U, 0xC60A5E22U, 0x19DDB430U, 0x7B87C150U, 0x49FFE8C2U,
+0x875E3C9U, 0xEFB8D540U, 0xBB551FEU, 0x485E57B1U, 0x7171D832U, 0xAA37823U, 0xB678C79CU, 0x9AD6EC38U, 0x6CB5177AU, 0xE42A432DU, 0xA711D2F5U, 0xDF1942E9U,
+0x92D028AU, 0xF00C77BCU, 0x7049BC1CU, 0xA2670B26U, 0x20B4D99EU, 0x8BEAF43BU, 0xEA39A146U, 0x14F38D7U, 0x3A72453FU, 0x464E138BU, 0xC1B90DE8U, 0x9EAD10B7U,
+0x1E4CB9E4U, 0x2CF77C5BU, 0x8927E59AU, 0x7116D68AU, 0xBB545FEBU, 0x81B4AA98U, 0xD01859CAU, 0xDF71061U, 0x479A64C4U, 0x71B1C5DBU, 0x5964E96BU, 0xF1560394U,
+0xF28823A4U, 0xE4E97619U, 0x1295A088U, 0x7049FDAU, 0xE592D573U, 0x3535BE69U, 0x1619B844U, 0xD727F3DEU, 0x13232E2BU, 0x51338796U, 0x4B84738U, 0xF482392DU,
+0xAB40F973U, 0x9E36BDD6U, 0x3845F022U, 0xA2F40E8BU, 0xC698595DU, 0x87D8352DU, 0xEEB9CC7FU, 0xC644164DU, 0x4CDBDEAFU, 0xE2DE7491U, 0x31F7EB3DU, 0x9599038U,
+0x9D918DA1U, 0x65E89B01U, 0x886E82A6U, 0xFFFE534AU, 0xE151673CU, 0x2026F087U, 0x6D682B4EU, 0xDEF444BDU, 0xF1416D33U, 0xBA2D6D03U, 0xEEFF589AU, 0xD41F5106U,
+0xDE088E4CU, 0x999A79F6U, 0xE8AEA3D0U, 0xE93324AEU, 0xAD49F7U, 0x5FE7A23DU, 0xC1728CACU, 0x60B9C80EU, 0xE3F2AFEBU, 0x95F0722U, 0xA039D72EU, 0xD6262CCFU,
+0x76C373F8U, 0xB040A838U, 0xCF9DD85FU, 0x89EE399BU, 0x4280BC28U, 0xFC69FC63U, 0x3D05B634U, 0x49B5C357U, 0x6E56C308U, 0x1754FB6U, 0xBB51865DU, 0x8715888CU,
+0x1D1552DU, 0xB7351D91U, 0x4537E08EU, 0xAD2738D0U, 0xAE6891D3U, 0x3D480692U, 0x964B44CEU, 0x7F89BA71U, 0x2E2BD03U, 0x7686B89FU, 0xDC21E010U, 0xC76B9756U,
+0x51599457U, 0x9E6B1EDU, 0x9A6FBFC1U, 0xBBC871A0U, 0xC3FAEA7CU, 0xFAD6BDE8U, 0x1D426A4FU, 0x54E93201U, 0x23516287U, 0x7D2AAB9U, 0x3D14944U, 0x20F91670U,
+0x7A1502CDU, 0x5A8B6DF7U, 0x2D7BE547U, 0xC7686672U, 0x6101B9D7U, 0x6D9E58AFU, 0xEB0B3F26U, 0x92FD1CE6U, 0x10438777U, 0xB9A6DF98U, 0x8F21D6D6U, 0xA5DC42D9U,
+0xAA8A7A11U, 0x97ABDF97U, 0xF820B371U, 0x12E7060FU, 0x7898B7E6U, 0xECC6032BU, 0x9CD6CAB9U, 0x3BC2405BU, 0x16974E59U, 0xB1168D81U, 0x2F1E6611U, 0xCEFB7A8CU,
+0x399695C7U, 0x116814AFU, 0x588FA645U, 0xC9B298CDU, 0xC2BC200U, 0x264CB5CEU, 0x9C43107EU, 0xA1A8D07EU, 0xE6BF9B30U, 0xDAAEEB22U, 0x9AE019F0U, 0xE91C586BU,
+0x2C799952U, 0xE5A1E7CEU, 0x405A2DB6U, 0x804346D2U, 0xBE708250U, 0x67B107D0U, 0xC596A1FBU, 0xB7E8AC33U, 0x829235A2U, 0xA0D9823DU, 0x46D24122U, 0x2B9EA93U,
+0xA1C073C6U, 0xC4EAFBEU, 0x9CBCA0CEU, 0x87CB523EU, 0x93F53F24U, 0x30F100CBU, 0xC76E5C71U, 0xC5B21FE9U, 0xEEEE5BF8U, 0xBB647D0EU, 0xE0A73F06U, 0xC685C32DU,
+0x1C5C9B9BU, 0x2A44CEAU, 0x9534296EU, 0x5A5EC350U, 0xB3780B29U, 0xE8A4B00U, 0xF8327784U, 0x996FC0C8U, 0xD67C8539U, 0x621659DDU, 0x1FD6996U, 0xB398D6D2U,
+0xBBEC03D6U, 0x3F8504F6U, 0x9FA1B8CEU, 0x83ADB8A5U, 0x9004789FU, 0x99ED15F4U, 0x6883E2DU, 0x3C75FFACU, 0xD2391F74U, 0x66EE73F1U, 0x8FA89A21U, 0x801A7503U,
+0x522E1784U, 0x36392E2EU, 0x19DF8128U, 0x6EA25305U, 0x846C8437U, 0x4EE0BEACU, 0xF690FDC5U, 0xF6832E1EU, 0xA48C9379U, 0x5F8921B0U, 0xFE3D1F9CU, 0x4B6BADFEU,
+0x2DDBBD52U, 0xFA227036U, 0xFE4FE03AU, 0xD4BD8877U, 0xC255594EU, 0x8A61FE32U, 0x63B85E32U, 0xC24637DFU, 0x39229F39U, 0xF9B405A4U, 0x3EBF9329U, 0xF28B6E98U,
+0x81DAA8C9U, 0x55ACEF34U, 0x296DE97FU, 0x5953C3AU, 0x7268DC76U, 0x49C2BAAAU, 0x1FD82E79U, 0xE54C1803U, 0x9CD98442U, 0x4C57DE89U, 0x7FD97D63U, 0x5B3CB6F5U,
+0x67B3B2E4U, 0x3F4D318AU, 0x3EC0ABB7U, 0xEE3200C0U, 0x3FA3D082U, 0x4D0F7C4AU, 0x892D309CU, 0x56B3DD2CU, 0xEB5F7612U, 0x2EE42882U, 0xCF07E495U, 0xF2A9BC6BU,
+0x9DA909A4U, 0x937B3A8U, 0x363217CFU, 0x9AED0006U, 0x60362015U, 0x5226B280U, 0x8524AEA3U, 0xFBC8F58DU, 0x7B172312U, 0x9CCC34DU, 0xA8AE6F61U, 0xE3CA111EU,
+0x59FE8325U, 0x6EC95B2U, 0xF676DCD9U, 0x9A250AE3U, 0x99E585E7U, 0xA62C89BU, 0xC631DEF4U, 0x58BC30C1U, 0x470412E1U, 0xC05117F0U, 0xA51D983CU, 0x1E629C01U,
+0x541C0E33U, 0xEB80059DU, 0x129D07E0U, 0x48EDAAD6U, 0x8397F485U, 0x1857F8F0U, 0x97497FE1U, 0xA8AEC1F6U, 0xC8027F76U, 0x736E96A8U, 0x1A578E1AU, 0x6B9FD701U,
+0x8B4734B7U, 0x7102220U, 0x13FE645BU, 0xE25D1A59U, 0x7A7D69ECU, 0x9295838AU, 0x6761FB08U, 0x493105F6U, 0x13BF90E3U, 0x6691E578U, 0xC741FD85U, 0x62E01643U,
+0xE782CAB0U, 0x3223B5F4U, 0xB36E1464U, 0x2C04AA45U, 0x9260D4CBU, 0x660DB966U, 0x41F2BCF7U, 0xF17D8432U, 0x17C405A6U, 0x87274585U, 0x537E9E9EU, 0x7B344BCU,
+0x1E023531U, 0xDD6783A8U, 0xFA37738DU, 0xD7D7F72CU, 0xEAADB26BU, 0x5B511B45U, 0x240A687DU, 0x44E66B55U, 0xD0808C97U, 0xF31BFF35U, 0x9EE5345CU, 0x258906C2U,
+0x9860CC4AU, 0xB9CCB14FU, 0x5580726EU, 0x26B182EU, 0x4F6C5C89U, 0x5D26775DU, 0xF0CA22ADU, 0x2DD7CAC5U, 0xD0EDAF27U, 0x8C09D6DU, 0xDCFB88F2U, 0x71C63BCFU,
+0xAEC8C854U, 0xC3ADC8F6U, 0xE93C7B65U, 0xC698C893U, 0x8E574092U, 0x92FF3CB6U, 0xF8648ABAU, 0xB5BC2991U, 0x5E05BD9DU, 0xB09A78A0U, 0x15AB67C0U, 0x3FADF7CEU,
+0x2927A3FDU, 0x445BA5DBU, 0xFA3008B2U, 0x2891DB6BU, 0xDBB845FU, 0x573B85ECU, 0x18F54327U, 0x74F4356BU, 0x95971E70U, 0x4470A211U, 0xB905173DU, 0x414D94A9U,
+0xE929B3ADU, 0xAE3B8A7AU, 0xFF18EB1U, 0xEE383B0CU, 0x7B04D607U, 0x693E6DA4U, 0xC3FB577EU, 0x7AC48735U, 0x1A99C4ADU, 0x45B0C657U, 0x5CC05A5U, 0xE24AE587U,
+0x884FA08EU, 0x5BCE0610U, 0xCCBADA00U, 0xEEBE62E2U, 0x1BED96D4U, 0xFF9731C4U, 0x5644B2A0U, 0x9119ABCAU, 0x28FC1FE4U, 0x983CF251U, 0xF92F5A3BU, 0xDC9DC061U,
+0x5B150730U, 0xCB5F1CBDU, 0x5966470CU, 0xE5C92630U, 0x974502D1U, 0x2047F98CU, 0x444D6B88U, 0xFB8235EU, 0x359D6CU, 0xC34153C2U, 0x2A95D777U, 0x5B6E4E6FU,
+0xB408F38U, 0x2423E46EU, 0x4C85DCE9U, 0xBBEEC84BU, 0xE9D46305U, 0x30187C97U, 0x181599U, 0xF4F90026U, 0x952F111CU, 0x5B9D9750U, 0x624304BEU, 0xCE566F2EU,
+0xF5B066E3U, 0xC84AEDC4U, 0x26984E70U, 0xD637245CU, 0xAEADB1U, 0x7F65D377U, 0xDD7410C6U, 0xE156A6E8U, 0x2BDB808BU, 0x3107D6E5U, 0xA654151FU, 0x5DBD1349U,
+0x29676B1CU, 0xD9B9A12BU, 0x559571C7U, 0x17D9B1EFU, 0x8EBB69EAU, 0x6E834FD7U, 0x22AF6658U, 0x50FD3DEBU, 0xA35B6E1U, 0x87B78513U, 0x5CA68B6U, 0xF3B77C65U,
+0xDAE7ACC8U, 0xBD84E707U, 0xC0B1F2EEU, 0x7C5B280BU, 0x3C82C2A7U, 0xF1848767U, 0xCF397063U, 0x11293CECU, 0x86B3A406U, 0xCF0391E2U, 0xCAE6F488U, 0xA2130914U,
+0x80443800U, 0x75A52C98U, 0x255D3BC5U, 0x70B8141FU, 0x52A6D7E8U, 0xF3773CB5U, 0x16682961U, 0xE291D23CU, 0xEA1AB08DU, 0x3AF6AC29U, 0xF077AF0BU, 0xDB42975FU,
+0xE4B5A5C3U, 0x828767D9U, 0xCE511DFDU, 0x8FA20C6DU, 0xD4FEEEB4U, 0x3B75D536U, 0x81090466U, 0xB210CB77U, 0xA0A56499U, 0x601ADD2U, 0xAB167BEAU, 0xF706C300U,
+0x1B058070U, 0x9F01D362U, 0x52CFBC44U, 0x96A9AB7BU, 0x966588D6U, 0xB899A286U, 0x5EE0407AU, 0x681CEAFFU, 0x4C40811U, 0xB20B7269U, 0x367237BFU, 0x428A0B94U,
+0xD691C645U, 0xB12CFF27U, 0x9E6383BEU, 0x6176461EU, 0xFDB47228U, 0x51A94E60U, 0xFBD6A3E0U, 0xF187D05EU, 0x4DA143CFU, 0x49C7CCE6U, 0xB4B52BF7U, 0x3BA3A346U,
+0xA803AAFEU, 0x9FC8C67BU, 0xA639766CU, 0x4C6B2408U, 0xED09AD3DU, 0xDBBD48U, 0xE0E2196DU, 0xE9FFEE62U, 0xB50384FU, 0xDFE188A2U, 0x3633AE21U, 0xAEF9F8C9U,
+0x80178502U, 0xED42BC9CU, 0x85653DDDU, 0x394C79C4U, 0x71477B3DU, 0xF8C674CFU, 0xD4B8C4E9U, 0x2A5947F9U, 0xFC4C64D2U, 0x6B322B31U, 0xB9B20DFBU, 0x57BB1739U,
+0x3D915162U, 0x5AAAA1ACU, 0x91EB2A66U, 0x35CA03C9U, 0xDE6D0202U, 0xCB2E089FU, 0x57048634U, 0xEEBBC058U, 0x3813A5F6U, 0x722CE848U, 0x8479A8A6U, 0xE92B8076U,
+0x1B1F3F83U, 0x81D8932FU, 0xFDDDB092U, 0x30D5B4C9U, 0xC91CF267U, 0x36AD135BU, 0x71F52515U, 0xC089EF35U, 0x41038328U, 0x6456724BU, 0x1B2B3E23U, 0xD24210BBU,
+0xC62FBD71U, 0xFCAD3662U, 0x8E3F7FF2U, 0xE48AE1B8U, 0xD23BC8ABU, 0xEF89F436U, 0x62BCE039U, 0x1A5DE46CU, 0x16236FU, 0xCA241E6DU, 0x9EEE203BU, 0x3D3879E4U,
+0x1D1C6180U, 0xD378251U, 0xE2BA4A87U, 0x66DFA1A0U, 0x7418FB2CU, 0x6CB7295CU, 0x9F7002F9U, 0x1F7DE611U, 0x5FA0D6B3U, 0xA466F742U, 0x8E097065U, 0x7F7B3458U,
+0x25360EB8U, 0xE8ADA4B0U, 0x18B1FE00U, 0x2AC22D1CU, 0x4186B027U, 0x959C76EAU, 0x8872FA1EU, 0x486317D3U, 0xED35E29BU, 0xB17E878U, 0x8F6CC5FCU, 0x2E8831DBU,
+0xFA55FF05U, 0x6FEFF36U, 0xBE942D00U, 0x36B6480EU, 0x4C5D91EFU, 0xEB2C7AC2U, 0xEA33683AU, 0xB8A51C5EU, 0x8BF2227BU, 0xF37E24F6U, 0x864012FU, 0x5DE7786U,
+0x3EFEC660U, 0xE2761ACU, 0x54A6C4ABU, 0x4047D505U, 0x37FBD45CU, 0x65D5D78BU, 0xBE3CF030U, 0x4A150EFBU, 0x2F283083U, 0xCB47C04DU, 0x973EDABU, 0xD6BC301FU,
+0xD792EACU, 0xEEA55E7U, 0xAB40BD74U, 0x2CAC2CA8U, 0x9B8691CAU, 0xF0EF8D89U, 0xA743045FU, 0xB76BFEDU, 0x76DD731AU, 0x3752687U, 0x968C7740U, 0x770D8687U,
+0xF6DE8D96U, 0x91B3A983U, 0x7228545U, 0xA8134914U, 0xFD9A01E6U, 0x72386ADDU, 0x845A80A6U, 0x10675D75U, 0x31032835U, 0xB6510D2AU, 0x67E9C2D9U, 0x8C073B5FU,
+0x348F2BA5U, 0xE4DF38ECU, 0x535EDE00U, 0xE31FD2EFU, 0xAA5BD7DCU, 0x9D963F06U, 0x8D26D2E9U, 0x5D76C1A0U, 0x95131597U, 0x25521978U, 0xA549BA78U, 0xFC809EA1U,
+0x9CC1A4E2U, 0x58043720U, 0xE3BD3B7BU, 0xED684815U, 0x8A1B48E8U, 0x9C5BFCA1U, 0x1C5A009AU, 0x7485B1C1U, 0xCA86F28AU, 0x32FA853AU, 0xB3626483U, 0x972DA82DU,
+0xE492749AU, 0x35CA2D1DU, 0xC1E25D40U, 0xFAA559E2U, 0x27472E18U, 0xEA8FB72AU, 0x5D846824U, 0x77540CDAU, 0x45717960U, 0x57C4D68EU, 0xEF78B1EBU, 0x72AF8952U,
+0xCA13EE37U, 0xD8A641D9U, 0x601A26BCU, 0x387936EAU, 0x80C5518FU, 0x47E9CBACU, 0xFF55ACC9U, 0xEDE00327U, 0x835DF178U, 0xDD2F69BU, 0xC178F605U, 0xCBBDFF1CU,
+0x717FF82U, 0x8998F861U, 0x4532F8FFU, 0x9C12EA53U, 0x50B8EACDU, 0x2E8AEB86U, 0xE220EB18U, 0x6CAFECFBU, 0x6D9D258CU, 0xBC42E87CU, 0x61A4E33U, 0xCFB8C4FU,
+0x81664E1AU, 0x13BBA529U, 0x5BFB8755U, 0x5B9E60F1U, 0x89633A85U, 0x3E0560D0U, 0x39A51A29U, 0x8EC3407CU, 0xE6DEDAE1U, 0x51B880B4U, 0xC3614311U, 0x74071944U,
+0xEEA49D28U, 0x59C2C77DU, 0x236AF20EU, 0x940CA85BU, 0xF46B750FU, 0x430D2F5AU, 0xD1002AD3U, 0x66667086U, 0x44AD55A3U, 0xF3CB0FF6U, 0x31DF5DE0U, 0x86B907B5U,
+0x5618FA4DU, 0xE17EA018U, 0x5E62BD84U, 0xE904E7D1U, 0x61C60A7FU, 0xD6A0502AU, 0x796DEC4CU, 0xCE0BB619U, 0xCBCFC2F4U, 0x7CA998A1U, 0x7373A591U, 0xC415FFC4U,
+0x93ACD2A2U, 0x24CA88F7U, 0x6830EF86U, 0xDF56B5D3U, 0xEF283F18U, 0x584E654DU, 0xA5FE80A0U, 0x1298DAF5U, 0x8095DF7CU, 0x37F38529U, 0x78D0FE2U, 0xB0EB55B7U,
+0x1D42E7C5U, 0xAA24BD90U, 0x1538A00CU, 0xA25EFA59U, 0x4521F793U, 0xF247ADC6U, 0xD8F6CF2AU, 0x6F90957FU, 0xF5E7D73FU, 0x42818D6AU, 0x72FF07A1U, 0xC5995DF4U,
+0x92207092U, 0x25462AC7U, 0xE75278D1U, 0x50342284U, 0xD08C88E3U, 0x67EAD2B6U, 0x1838F762U, 0xAF5EAD37U, 0x6112CC53U, 0xD6749606U, 0x2F0C6FC3U, 0x986A3596U,
+0xCA4360C4U, 0x7D253A91U, 0xB74B2F4EU, 0x2D751BU, 0xFF7482BU, 0xB891127EU, 0x5794587DU, 0xE0F20228U, 0xC8276ED0U, 0x7F413485U, 0x13AA1C8FU, 0xA4CC46DAU,
+0x597CA337U, 0xEE1AF962U, 0x52EE48DAU, 0xE588128FU, 0x94B2CC11U, 0x23D49644U, 0xC239270DU, 0x755F7D58U, 0x20825E2AU, 0x97E4047FU, 0xC4AB9B8EU, 0x73CDC1DBU,
+0x70716126U, 0xC7173B73U, 0xAC65B06DU, 0x1C7021BFU, 0x11FB361U, 0xB679E934U, 0x746DBB22U, 0xC30BE177U, 0xF3756BBCU, 0x441331E9U, 0xB9A3D404U, 0xEC58E51U,
+0xFFF99EE2U, 0x489FC4B7U, 0x7C17FCEBU, 0xCB71A6BEU, 0x4106B2AAU, 0xD9C40950U, 0x36C14353U, 0x81A71906U, 0x1BD05B46U, 0xACB60113U, 0x9CC88BD8U, 0x2BAED18DU,
+0x7117AB85U, 0xC671F1D0U, 0x860763FFU, 0x316139AAU, 0x2C0EAB74U, 0x9B68F121U, 0xCCD1DC47U, 0x7BB78612U, 0xDE6473A9U, 0x690229FCU, 0x2BC473EBU, 0x9CA229BEU,
+0x9378148EU, 0x241E4EDBU, 0xEAF2C37U, 0xB9C97662U, 0xA4A6E4BCU, 0x13C0BEE9U, 0x252C88A1U, 0x924AD2F4U, 0xAA4E1FF6U, 0x1D2845A3U, 0x9764CE8AU, 0x200294DFU,
+0x92F4B6BEU, 0x2592ECEBU, 0xCD89B85BU, 0x7AEFE20EU, 0x47D77DU, 0xB7218D28U, 0xE8E2E787U, 0x5F84BDD2U, 0x505E80E2U, 0xE738DAB7U, 0x660CD2E0U, 0xD16A88B5U,
+0xE96E45B7U, 0x5E081FE2U, 0xDEB0B585U, 0x69D6EFD0U, 0xCC051A6BU, 0x7B63403EU, 0xFEA1FAFEU, 0x49C7A0ABU, 0x4B1DCAF5U, 0xFC7B90A0U, 0xB1D993CDU, 0x6BFC998U,
+0x5F3AD998U, 0xE85C83CDU, 0x41E9EBBBU, 0xF68FB1EEU, 0xDA78A9ADU, 0x6D1EF3F8U, 0xC2EDE121U, 0x758BBB74U, 0x883B5E99U, 0x3F5D04CCU, 0x4D8F7676U, 0xFAE92C23U,
+0xCB1B04D8U, 0x7C7D5E8DU, 0xBFE5AEABU, 0x883F4FEU, 0x759C9CEU, 0xB03F939BU, 0x80411950U, 0x37274305U, 0x308739FCU, 0x87E163A9U, 0xF5331113U, 0x42554B46U,
+0x2A48D1DBU, 0x9D2E8B8EU, 0x1D9621E9U, 0xAAF07BBCU, 0xA52A468CU, 0x124C1CD9U, 0xE786BEFDU, 0x50E0E4A8U, 0x9A8EF177U, 0x2DE8AB22U, 0xB79FE962U, 0xF9B337U,
+0x57409E51U, 0xE026C404U, 0x547CF459U, 0xE31AAE0CU, 0x6BD843A2U, 0xDCBE19F7U, 0x5C06B390U, 0xEB60E9C5U, 0xECC0933CU, 0x5BA6C969U, 0x2F71F45U, 0xB5914510U,
+0xA0849007U, 0x17E2CA52U, 0x5D8F4DD1U, 0x785F2A36U, 0xBA4B7820U, 0xD2D2275U, 0xA8FED7CEU, 0x1F988D9BU, 0x77851706U, 0xC0E34D53U, 0xB2313FE9U, 0x55765BCU,
+0xA8D588CU, 0xBDEB02D9U, 0x9F2027FCU, 0x28467DA9U, 0x34A54D47U, 0x83C31712U, 0x96D6C205U, 0x21B09850U, 0x335DBD17U, 0xF11165A8U, 0x46773FFDU, 0x9EAC85CCU,
+0x29CADF99U, 0x3237F1C4U, 0x8551AB91U, 0x3A4DB60DU, 0x8D2BEC58U, 0x709B09B5U, 0xC7FD53E0U, 0x5FD0B10BU, 0xE8B6EB5EU, 0xC05D2919U, 0x773B734CU, 0x90447E86U,
+0x272224D3U, 0xA82A11E2U, 0x1F4C4BB7U, 0x65E47EC4U, 0xD2822491U, 0xBA9FBE0CU, 0xDF9E459U, 0x523A8EF6U, 0xE55CD4A3U, 0xEA86E993U, 0x5DE0B3C6U, 0x3D876E92U,
+0x8AE134C7U, 0x6D9E390DU, 0xDAF86358U, 0xCFEDB64FU, 0x788BEC1AU, 0x7751D12AU, 0xC0378B7FU, 0x83A9B574U, 0x34CFEF21U, 0xCCB2223U, 0xBBAD7876U, 0x461D9D9BU,
+0xF17BC7CEU, 0x1604CA04U, 0xA1629051U, 0xF6DBBD37U, 0x41BDE762U, 0xAEB8AD61U, 0x19DEF734U, 0x911C1A9AU, 0x267A40CFU, 0x4B165EAU, 0xB3D73FBFU, 0x1E7E8DCDU,
+0xA918D798U, 0x336F95D8U, 0x8409CF8DU, 0x21DA3A36U, 0x96BC6063U, 0xBC0D028FU, 0xB6B58DAU, 0x9CF62567U, 0x2B907F32U, 0x4E67DA52U, 0xF9018007U, 0x43678D3CU,
+0xF401D769U, 0x54A83275U, 0xE3CE6820U, 0xC97F0ACCU, 0x7E195099U, 0x3B15D211U, 0x8C738844U, 0xEC145510U, 0x5B720F45U, 0x99665D53U, 0x2E000706U, 0x6376C247U,
+0xD4109812U, 0xE46E12D9U, 0x5308488CU, 0x29A07DFFU, 0x9EC627AAU, 0xE5E2B0E9U, 0x5284EABCU, 0xA74E4898U, 0x102812CDU, 0xD478013U, 0xBA21DA46U, 0x17886834U,
+0xA0EE3261U, 0x4FEB7862U, 0xF88D2237U, 0x62FA6077U, 0xD59C3A22U, 0x20569806U, 0x9730C253U, 0x6A8027BEU, 0xDDE67DEBU, 0x318A297CU, 0x77EFB560U, 0x3A997021U,
+0x8DFF2A74U, 0x78358850U, 0xCF53D205U, 0x5D8A11A0U, 0xEAEC4BF5U, 0x8BD3F2BDU, 0x3CB5A8E8U, 0x8DAB26ADU, 0x3ACD7CF8U, 0x53DC7DAU, 0xB25B9D8FU, 0x5FEE1FB4U,
+0xE88845E1U, 0x6468DCF4U, 0xD30E86A1U, 0xB3833366U, 0x4E56933U, 0xA94CDB41U, 0x1E2A8114U, 0x262E4C16U, 0x91481643U, 0xDC3ED302U, 0x6B588957U, 0xF9558CDEU,
+0x4E33D68BU, 0x4993AC72U, 0xFEF5F627U, 0x535C4455U, 0xE43A1E00U, 0xA1369C88U, 0x1650C6DDU, 0x845DC354U, 0x333B9901U, 0x2E540BDFU, 0x9932518AU, 0xBBF974AFU,
+0xC9F2EFAU, 0x9E922B73U, 0x29F47126U, 0x176200A7U, 0xA0045AF2U, 0x1E94E55EU, 0xA9F2BF0BU, 0x7129053AU, 0xC64F5F6FU, 0x4E8DB2C1U, 0xF9EBE894U, 0xE4847A4AU,
+0x53E2201FU, 0x3B2B7CAEU, 0x8C4D26FBU, 0x107C1E14U, 0xA71A4441U, 0x3D6D0601U, 0x8A0B5C54U, 0xD1F96FEAU, 0x701F8A2FU, 0xEDCCFBF9U, 0x2C9B1FAU, 0xB5AFEBAFU,
+0x6BE6ED1DU, 0xDC80B748U, 0xF0A36927U, 0x47C53372U, 0xA8C07971U, 0x1FA62324U, 0x7FC1FE70U, 0xC8A7A425U, 0x77BBB9B9U, 0xC0DDE3ECU, 0x351741C8U, 0x82711B9DU,
+0x9F1E8943U, 0x2878D316U, 0x38FD7E35U, 0x8F9B2460U, 0x481F0E42U, 0xFF795417U, 0xBA75D69FU, 0xD138CCAU, 0x7DA5F064U, 0xCAC3AA31U, 0xF783D92BU, 0x40E5837EU,
+0xA0BA3EB8U, 0x17DC64EDU, 0x7535DF3EU, 0xC253856BU, 0x8F25402AU, 0x38431A7FU, 0xC797F186U, 0x70F1ABD3U, 0x604AA84FU, 0xD72CF21AU, 0x47AF9114U, 0xF0C9CB41U,
+0x27A2EE26U, 0x90C4B473U, 0xBEBDCAB7U, 0x9DB90E2U, 0xED4C310CU, 0x5A2A6B59U, 0x223D969U, 0xB545833CU, 0x96E86CBAU, 0x218E36EFU, 0xA06EF894U, 0x1708A2C1U,
+0x6D74519EU, 0xDA120BCBU, 0x180659DDU, 0xAF600388U, 0xDDB27132U, 0x6AD42B67U, 0xD5C836FBU, 0x62AE6CAEU, 0x2474ECBDU, 0x9312B6E8U, 0xCF07DEDCU, 0x78618489U,
+0x32DD9957U, 0x85BBC302U, 0x90AE1615U, 0x27C84C40U, 0xC0B7418AU, 0x77D11BDFU, 0x3AA7DE9EU, 0x8DC184CBU, 0xB5C549C9U, 0x2A3139CU, 0x62C4CEC8U, 0xD5A2949DU,
+0x28127170U, 0x9F742B25U, 0xA770E627U, 0x1016BC72U, 0x206836B9U, 0x970E6CECU, 0x1FCC8142U, 0xA8AADB17U, 0x5036965U, 0xB2653330U, 0x52862C08U, 0xBA1F74F9U,
+0xEDA6599FU, 0x5AC003CAU, 0x47526A2CU, 0x3D07A467U, 0xCFD318F0U, 0x78B542A5U, 0xA9981D6DU, 0x1EFE4738U, 0x8CF342B1U, 0x3B9518E4U, 0x9BD6956BU, 0x2CB0CF3EU,
+0xD0584ECFU, 0x673E149AU, 0x76E3DDA5U, 0xC18587F0U, 0xC625FD09U, 0x7143A75CU, 0x195E3DC1U, 0xAE386794U, 0xBEB922FU, 0xBC8DC87AU, 0xD51CF0D7U, 0x627AAA82U,
+0xA67301FU, 0xBD016A4AU, 0x8505A748U, 0x3263FD1DU, 0x52042049U, 0xE5627A1CU, 0x5CECDB03U, 0xEB8A8156U, 0xF22D0FA0U, 0x454B55F5U, 0x7453159DU, 0xC3354FC8U,
+0x37734FDCU, 0x80151589U, 0x8D7F827U, 0xBFB1A272U };
+
+const ReplacementIndexStruct ReplacementIndexData[] = {
+	{ utf16char(43), medium(1) },
+	{ utf16char(45), medium(1) },
+	{ utf16char(49), medium(2) },
+	{ utf16char(50), medium(1) },
+	{ utf16char(56), medium(1) },
+	{ utf16char(97), medium(129) },
+	{ utf16char(98), medium(226) },
+	{ utf16char(99), medium(290) },
+	{ utf16char(100), medium(100) },
+	{ utf16char(101), medium(70) },
+	{ utf16char(102), medium(437) },
+	{ utf16char(103), medium(108) },
+	{ utf16char(104), medium(138) },
+	{ utf16char(105), medium(53) },
+	{ utf16char(106), medium(25) },
+	{ utf16char(107), medium(53) },
+	{ utf16char(108), medium(101) },
+	{ utf16char(109), medium(247) },
+	{ utf16char(110), medium(74) },
+	{ utf16char(111), medium(71) },
+	{ utf16char(112), medium(201) },
+	{ utf16char(113), medium(8) },
+	{ utf16char(114), medium(114) },
+	{ utf16char(115), medium(289) },
+	{ utf16char(116), medium(148) },
+	{ utf16char(117), medium(53) },
+	{ utf16char(118), medium(28) },
+	{ utf16char(119), medium(211) },
+	{ utf16char(120), medium(4) },
+	{ utf16char(121), medium(8) },
+	{ utf16char(122), medium(11) },
+};
+
+std::vector<Replacement> Replacements;
+std::map<utf16char, std::vector<const Replacement*>> ReplacementsMap;
+std::map<checksum, const Replacement*> ReplacementsHash;
+
+void InitReplacements() {
+	if (!Replacements.empty()) {
+		return;
+	}
+	auto data = ReplacementData;
+	auto takeString = [&data](int size) {
+		auto result = utf16string(data, size);
+		data += size;
+		return result;
+	};
+	auto wordSize = ReplacementWordLengths;
+
+	Replacements.reserve(1936);
+	for (auto item : ReplacementInitData) {
+		auto emoji = takeString(item.emojiSize);
+		auto replacement = takeString(item.replacementSize);
+		auto words = std::vector<utf16string>();
+		words.reserve(item.wordsCount);
+		for (auto i = 0; i != item.wordsCount; ++i) {
+			words.push_back(takeString(*wordSize++));
+		}
+		Replacements.push_back({ std::move(emoji), std::move(replacement), std::move(words) });
+	}
+
+	auto indices = ReplacementIndices;
+	auto items = &Replacements[0];
+	for (auto item : ReplacementIndexData) {
+		auto index = std::vector<const Replacement*>();
+		index.reserve(item.count);
+		for (auto i = 0; i != item.count; ++i) {
+			index.push_back(items + (*indices++));
+		}
+		ReplacementsMap.emplace(item.ch, std::move(index));
+	}
+
+	for (auto checksum : ReplacementChecksums) {
+		ReplacementsHash.emplace(checksum, items++);
+	}
+}
+
+const std::vector<const Replacement*> *GetReplacements(utf16char first) {
+	if (ReplacementsMap.empty()) {
+		InitReplacements();
+	}
+	auto it = ReplacementsMap.find(first);
+	return (it == ReplacementsMap.cend()) ? nullptr : &it->second;
+}
+
+utf16string GetReplacementEmoji(utf16string replacement) {
+	auto code = countChecksum(replacement.data(), replacement.size() * sizeof(utf16char));
+	auto it = ReplacementsHash.find(code);
+	return (it == ReplacementsHash.cend()) ? utf16string() : it->second->emoji;
+}
diff --git a/TMessagesProj/jni/emoji/emoji_suggestions_data.h b/TMessagesProj/jni/emoji/emoji_suggestions_data.h
new file mode 100644
index 000000000..68d9692e2
--- /dev/null
+++ b/TMessagesProj/jni/emoji/emoji_suggestions_data.h
@@ -0,0 +1,38 @@
+/*
+WARNING! All changes made in this file will be lost!
+Created from 'empty' by 'codegen_emoji'
+
+This file is part of Telegram Desktop,
+the official desktop version of Telegram messaging app, see https://telegram.org
+
+Telegram Desktop is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+It is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+In addition, as a special exception, the copyright holders give permission
+to link the code of portions of this program with the OpenSSL library.
+
+Full license: https://github.com/telegramdesktop/tdesktop/blob/master/LICENSE
+Copyright (c) 2014-2017 John Preston, https://desktop.telegram.org
+*/
+#pragma once
+
+#include "emoji_suggestions.h"
+
+struct Replacement {
+	utf16string emoji;
+	utf16string replacement;
+	std::vector<utf16string> words;
+};
+
+constexpr auto kReplacementMaxLength = 55;
+
+void InitReplacements();
+const std::vector<const Replacement*> *GetReplacements(utf16char first);
+utf16string GetReplacementEmoji(utf16string replacement);
diff --git a/TMessagesProj/jni/gifvideo.cpp b/TMessagesProj/jni/gifvideo.cpp
index 06532917c..2de90d5cc 100644
--- a/TMessagesProj/jni/gifvideo.cpp
+++ b/TMessagesProj/jni/gifvideo.cpp
@@ -252,16 +252,27 @@ jint Java_org_telegram_ui_Components_AnimatedFileDrawable_getVideoFrame(JNIEnv *
             //LOGD("decoded frame with w = %d, h = %d, format = %d", info->frame->width, info->frame->height, info->frame->format);
             if (info->frame->format == AV_PIX_FMT_YUV420P || info->frame->format == AV_PIX_FMT_BGRA || info->frame->format == AV_PIX_FMT_YUVJ420P) {
                 jint *dataArr = env->GetIntArrayElements(data, 0);
+                int wantedWidth;
+                int wantedHeight;
                 if (dataArr != nullptr) {
+                    wantedWidth = dataArr[0];
+                    wantedHeight = dataArr[1];
                     dataArr[3] = (int) (1000 * info->frame->pkt_pts * av_q2d(info->video_stream->time_base));
                     env->ReleaseIntArrayElements(data, dataArr, 0);
+                } else {
+                    AndroidBitmapInfo bitmapInfo;
+                    AndroidBitmap_getInfo(env, bitmap, &bitmapInfo);
+                    wantedWidth = bitmapInfo.width;
+                    wantedHeight = bitmapInfo.height;
                 }
                 
                 void *pixels;
                 if (AndroidBitmap_lockPixels(env, bitmap, &pixels) >= 0) {
                     if (info->frame->format == AV_PIX_FMT_YUV420P || info->frame->format == AV_PIX_FMT_YUVJ420P) {
                         //LOGD("y %d, u %d, v %d, width %d, height %d", info->frame->linesize[0], info->frame->linesize[2], info->frame->linesize[1], info->frame->width, info->frame->height);
-                        libyuv::I420ToARGB(info->frame->data[0], info->frame->linesize[0], info->frame->data[2], info->frame->linesize[2], info->frame->data[1], info->frame->linesize[1], (uint8_t *) pixels, info->frame->width * 4, info->frame->width, info->frame->height);
+                        if (wantedWidth == info->frame->width && wantedHeight == info->frame->height || wantedWidth == info->frame->height && wantedHeight == info->frame->width) {
+                            libyuv::I420ToARGB(info->frame->data[0], info->frame->linesize[0], info->frame->data[2], info->frame->linesize[2], info->frame->data[1], info->frame->linesize[1], (uint8_t *) pixels, info->frame->width * 4, info->frame->width, info->frame->height);
+                        }
                     } else if (info->frame->format == AV_PIX_FMT_BGRA) {
                         libyuv::ABGRToARGB(info->frame->data[0], info->frame->linesize[0], (uint8_t *) pixels, info->frame->width * 4, info->frame->width, info->frame->height);
                     }
diff --git a/TMessagesProj/jni/intro/IntroRenderer.c b/TMessagesProj/jni/intro/IntroRenderer.c
new file mode 100644
index 000000000..9c20edc79
--- /dev/null
+++ b/TMessagesProj/jni/intro/IntroRenderer.c
@@ -0,0 +1,2814 @@
+#include "IntroRenderer.h"
+#include <math.h>
+#include <stdlib.h>
+#include <jni.h>
+
+static int32_t is_initialized = 0;
+static float _coefficientsX[TIMING_NUM][4], _coefficientsY[TIMING_NUM][4];
+static const float _c0x = 0.0;
+static const float _c0y = 0.0;
+static const float _c3x = 1.0;
+static const float _c3y = 1.0;
+
+float scale_factor;
+int width, height;
+int y_offset_absolute;
+static TextureProgram texture_program;
+static TextureProgram texture_program_one;
+static TextureProgram texture_program_red;
+static TextureProgram texture_program_blue;
+static TextureProgram texture_program_light_red;
+static TextureProgram texture_program_light_blue;
+static TextureProgram *texture_program_temp;
+static ColorProgram color_program;
+static float y_offset;
+
+#define BUFFER_OFFSET(i) ((void*)(i))
+
+static const vec4 black_color = {0.0f, 0.0f, 0.0f, 1.0f};
+static const vec4 white_color = {1.0f, 1.0f, 1.0f, 1.0f};
+
+static LayerParams ribbonLayer, privateLayer;
+
+static TexturedShape spiral;
+static Shape mask1;
+static Shape cloud_extra_mask1;
+static Shape cloud_extra_mask2;
+static Shape cloud_extra_mask3;
+static Shape cloud_extra_mask4;
+
+static Shape cloud_cover;
+
+static Shape free_bg;
+static TexturedShape fast_body;
+static TexturedShape fast_arrow_shadow;
+static TexturedShape fast_arrow;
+
+static TexturedShape free_knot1;
+static TexturedShape free_knot2;
+static TexturedShape free_knot3;
+static TexturedShape free_knot4;
+
+static Shape powerful_bg;
+static TexturedShape powerful_mask, powerful_infinity, powerful_infinity_white;
+
+static Shape private_bg;
+
+static TexturedShape telegram_sphere, telegram_plane;
+
+static Shape cloud_bg;
+
+#define starsCount 80
+static TexturedShape star;
+static Params stars[starsCount];
+
+static Shape ribbon1;
+static Shape ribbon2;
+static Shape ribbon3;
+static Shape ribbon4;
+static mat4x4 stars_matrix;
+static mat4x4 main_matrix;
+static mat4x4 ribbons_layer;
+
+static TexturedShape ic_bubble_dot, ic_bubble, ic_cam_lens, ic_cam, ic_pencil, ic_pin, ic_smile_eye, ic_smile, ic_videocam;
+static GLuint ic_bubble_dot_texture, ic_bubble_texture, ic_cam_lens_texture, ic_cam_texture, ic_pencil_texture, ic_pin_texture, ic_smile_eye_texture, ic_smile_texture, ic_videocam_texture;
+static GLuint telegram_sphere_texture, telegram_plane_texture;
+static GLuint fast_spiral_texture, fast_body_texture, fast_arrow_texture, fast_arrow_shadow_texture;
+static GLuint free_knot_up_texture, free_knot_down_texture;
+static GLuint powerful_mask_texture, powerful_star_texture, powerful_infinity_texture, powerful_infinity_white_texture;
+static GLuint private_door_texture, private_screw_texture, private_keyhole_body_texture;
+static Shape infinity;
+
+static TexturedShape private_door, private_screw, private_keyhole_body;
+static Shape private_stroke;
+
+static Shape start_button;
+
+static const float r1 = 58.5f;
+static const float r2 = 70;
+static double ms0;
+static float date, date0;
+static float duration_const = 0.3f;
+static int32_t direct;
+static int32_t i;
+static int32_t current_page, prev_page;
+static float time;
+static mat4x4 ic_matrix;
+static LayerParams ic_pin_layer, ic_cam_layer, ic_videocam_layer, ic_smile_layer, ic_bubble_layer, ic_pencil_layer;
+static float time_local = 0;
+static float knot_delays[4];
+static float offset_y;
+static float ribbonLength = 86.5f;
+static int32_t starsFar = 500;
+static float scroll_offset;
+
+static float calculated_speedometer_sin;
+float ms0_anim;
+int fps_anim;
+int count_anim_fps;
+static float speedometer_scroll_offset = 0, free_scroll_offset = 0, private_scroll_offset = 0;
+float anim_pencil_start_time, anim_pencil_start_all_time, anim_pencil_start_all_end_time;
+int anim_pencil_stage;
+int anim_bubble_dots_stage;
+int anim_bubble_dots_end_period;
+float anim_videocam_start_time, anim_videocam_next_time, anim_videocam_duration, anim_videocam_angle, anim_videocam_old_angle;
+float anim_cam_start_time, anim_cam_next_time, anim_cam_duration, anim_cam_angle, anim_cam_old_angle;
+CPoint anim_cam_position, anim_cam_old_position;
+int qShot;
+float anim_camshot_start_time, anim_camshot_duration;
+float anim_smile_start_time1, anim_smile_start_time2, anim_smile_blink_start_time;
+int anim_smile_blink_one;
+int anim_smile_stage;
+static float scale;
+float anim_pin_start_time, anim_pin_duration;
+static int32_t anim_pencil_period;
+static mat4x4 private_matrix;
+float cloud_scroll_offset;
+
+static inline void vec2_add(vec2 r, vec2 a, vec2 b) {
+    int32_t i;
+    for (i = 0; i < 2; ++i) {
+        r[i] = a[i] + b[i];
+    }
+}
+
+static inline float vec2_mul_inner(vec2 a, vec2 b) {
+    float p = 0.f;
+    int32_t i;
+    for (i = 0; i < 2; ++i) {
+        p += b[i] * a[i];
+    }
+    return p;
+}
+
+static inline float vec2_len(vec2 v) {
+    return sqrtf(vec2_mul_inner(v, v));
+}
+
+static inline void vec2_scale(vec2 r, vec2 v, float s) {
+    int32_t i;
+    for (i = 0; i < 2; ++i) {
+        r[i] = v[i] * s;
+    }
+}
+
+static inline void vec2_norm(vec2 r, vec2 v) {
+    float k = 1.f / vec2_len(v);
+    vec2_scale(r, v, k);
+}
+
+static inline void mat4x4_identity(mat4x4 M) {
+    int32_t i, j;
+    for (i = 0; i < 4; ++i) {
+        for (j = 0; j < 4; ++j) {
+            M[i][j] = i == j ? 1.f : 0.f;
+        }
+    }
+}
+
+static inline void mat4x4_dup(mat4x4 M, mat4x4 N) {
+    int32_t i, j;
+    for (i = 0; i < 4; ++i) {
+        for (j = 0; j < 4; ++j) {
+            M[i][j] = N[i][j];
+        }
+    }
+}
+
+static inline void vec4_scale(vec4 r, vec4 v, float s) {
+    int32_t i;
+    for (i = 0; i < 4; ++i) {
+        r[i] = v[i] * s;
+    }
+}
+
+static inline void mat4x4_scale_aniso(mat4x4 M, mat4x4 a, float x, float y, float z) {
+    vec4_scale(M[0], a[0], x);
+    vec4_scale(M[1], a[1], y);
+    vec4_scale(M[2], a[2], z);
+}
+
+static inline void mat4x4_mul(mat4x4 M, mat4x4 a, mat4x4 b) {
+    int32_t k, r, c;
+    for (c = 0; c < 4; ++c) {
+        for (r = 0; r < 4; ++r) {
+            M[c][r] = 0.f;
+            for (k = 0; k < 4; ++k) {
+                M[c][r] += a[k][r] * b[c][k];
+            }
+        }
+    }
+}
+
+static inline void mat4x4_mul_vec4(vec4 r, mat4x4 M, vec4 v) {
+    int32_t i, j;
+    for (j = 0; j < 4; ++j) {
+        r[j] = 0.f;
+        for (i = 0; i < 4; ++i) {
+            r[j] += M[i][j] * v[i];
+        }
+    }
+}
+
+static inline void mat4x4_translate(mat4x4 T, float x, float y, float z) {
+    mat4x4_identity(T);
+    T[3][0] = x;
+    T[3][1] = y;
+    T[3][2] = z;
+}
+
+static inline void mat4x4_rotate_Z2(mat4x4 Q, mat4x4 M, float angle) {
+    float s = sinf(angle);
+    float c = cosf(angle);
+    mat4x4 R = {
+            {c,   s,   0.f, 0.f},
+            {-s,  c,   0.f, 0.f},
+            {0.f, 0.f, 1.f, 0.f},
+            {0.f, 0.f, 0.f, 1.f}
+    };
+    mat4x4_mul(Q, M, R);
+}
+
+static inline void mat4x4_rotate_Z(mat4x4 Q, float angle) {
+    mat4x4 temp;
+    mat4x4_dup(temp, Q);
+    mat4x4_rotate_Z2(Q, temp, angle);
+}
+
+static inline void mat4x4_translate_in_place(mat4x4 m, float x, float y, float z) {
+    int32_t i;
+    for (i = 0; i < 4; ++i) {
+        m[3][i] += m[0][i] * x + m[1][i] * y + m[2][i] * z;
+    }
+}
+
+static inline float deg_to_radf(float deg) {
+    return deg * (float) M_PI / 180.0f;
+}
+
+static inline float MAXf(float a, float b) {
+    return a > b ? a : b;
+}
+
+static inline float MINf(float a, float b) {
+    return a < b ? a : b;
+}
+
+GLuint compile_shader(const GLenum type, const GLchar* source, const GLint length) {
+    GLuint shader_object_id = glCreateShader(type);
+    GLint compile_status;
+    glShaderSource(shader_object_id, 1, &source, &length);
+    glCompileShader(shader_object_id);
+    glGetShaderiv(shader_object_id, GL_COMPILE_STATUS, &compile_status);
+    return shader_object_id;
+}
+
+GLuint link_program(const GLuint vertex_shader, const GLuint fragment_shader) {
+    GLuint program_object_id = glCreateProgram();
+    GLint link_status;
+    glAttachShader(program_object_id, vertex_shader);
+    glAttachShader(program_object_id, fragment_shader);
+    glLinkProgram(program_object_id);
+    glGetProgramiv(program_object_id, GL_LINK_STATUS, &link_status);
+    return program_object_id;
+}
+
+GLuint build_program(const GLchar * vertex_shader_source, const GLint vertex_shader_source_length, const GLchar * fragment_shader_source, const GLint fragment_shader_source_length) {
+    GLuint vertex_shader = compile_shader(GL_VERTEX_SHADER, vertex_shader_source, vertex_shader_source_length);
+    GLuint fragment_shader = compile_shader(GL_FRAGMENT_SHADER, fragment_shader_source, fragment_shader_source_length);
+    return link_program(vertex_shader, fragment_shader);
+}
+
+GLuint create_vbo(const GLsizeiptr size, const GLvoid* data, const GLenum usage) {
+    GLuint vbo_object;
+    glGenBuffers(1, &vbo_object);
+    glBindBuffer(GL_ARRAY_BUFFER, vbo_object);
+    glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr) size, data, usage);
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    return vbo_object;
+}
+
+TextureProgram get_texture_program(GLuint program) {
+    return (TextureProgram) {
+            program,
+            (GLuint) glGetAttribLocation(program, "a_Position"),
+            (GLuint) glGetAttribLocation(program, "a_TextureCoordinates"),
+            glGetUniformLocation(program, "u_MvpMatrix"),
+            glGetUniformLocation(program, "u_TextureUnit"),
+            glGetUniformLocation(program, "u_Alpha")};
+}
+
+ColorProgram get_color_program(GLuint program) {
+    return (ColorProgram) {
+            program,
+            (GLuint) glGetAttribLocation(program, "a_Position"),
+            glGetUniformLocation(program, "u_MvpMatrix"),
+            glGetUniformLocation(program, "u_Color"),
+            glGetUniformLocation(program, "u_Alpha")};
+}
+
+float frand(float from, float to) {
+    return (float) (((double) random() / RAND_MAX) * (to - from) + from);
+}
+
+int irand(int32_t from, int32_t to) {
+    return (int32_t) (((double) random() / RAND_MAX) * (to - from + 1) + from);
+}
+
+int signrand() {
+    return irand(0, 1) * 2 - 1;
+}
+
+static inline float evaluateAtParameterWithCoefficients(float t, float coefficients[]) {
+    return coefficients[0] + t * coefficients[1] + t * t * coefficients[2] + t * t * t * coefficients[3];
+}
+
+static inline float evaluateDerivationAtParameterWithCoefficients(float t, float coefficients[]) {
+    return coefficients[1] + 2 * t * coefficients[2] + 3 * t * t * coefficients[3];
+}
+
+static inline float calcParameterViaNewtonRaphsonUsingXAndCoefficientsForX(float x, float coefficientsX[]) {
+    float t = x;
+    int32_t i;
+    for (i = 0; i < 10; i++) {
+        float x2 = evaluateAtParameterWithCoefficients(t, coefficientsX) - x;
+        float d = evaluateDerivationAtParameterWithCoefficients(t, coefficientsX);
+        float dt = x2 / d;
+        t = t - dt;
+    }
+    return t;
+}
+
+float timing(float x, timing_type type) {
+    if (is_initialized == 0) {
+        is_initialized = 1;
+
+        float c[TIMING_NUM][4];
+        c[Default][0] = 0.25f;
+        c[Default][1] = 0.1f;
+        c[Default][2] = 0.25f;
+        c[Default][3] = 1.0f;
+        c[EaseInEaseOut][0] = 0.42f;
+        c[EaseInEaseOut][1] = 0.0f;
+        c[EaseInEaseOut][2] = 0.58f;
+        c[EaseInEaseOut][3] = 1.0f;
+        c[EaseIn][0] = 0.42f;
+        c[EaseIn][1] = 0.0f;
+        c[EaseIn][2] = 1.0f;
+        c[EaseIn][3] = 1.0f;
+        c[EaseOut][0] = 0.0f;
+        c[EaseOut][1] = 0.0f;
+        c[EaseOut][2] = 0.58f;
+        c[EaseOut][3] = 1.0f;
+        c[EaseOutBounce][0] = 0.0f;
+        c[EaseOutBounce][1] = 0.0f;
+        c[EaseOutBounce][2] = 0.0f;
+        c[EaseOutBounce][3] = 1.25;
+        c[Linear][0] = 0.0;
+        c[Linear][1] = 0.0;
+        c[Linear][2] = 1.0;
+        c[Linear][3] = 1.0;
+        int32_t i;
+        for (i = 0; i < TIMING_NUM; i++) {
+            float _c1x = c[i][0];
+            float _c1y = c[i][1];
+            float _c2x = c[i][2];
+            float _c2y = c[i][3];
+            _coefficientsX[i][0] = _c0x;
+            _coefficientsX[i][1] = -3.0f * _c0x + 3.0f * _c1x;
+            _coefficientsX[i][2] = 3.0f * _c0x - 6.0f * _c1x + 3.0f * _c2x;
+            _coefficientsX[i][3] = -_c0x + 3.0f * _c1x - 3.0f * _c2x + _c3x;
+            _coefficientsY[i][0] = _c0y;
+            _coefficientsY[i][1] = -3.0f * _c0y + 3.0f * _c1y;
+            _coefficientsY[i][2] = 3.0f * _c0y - 6.0f * _c1y + 3.0f * _c2y;
+            _coefficientsY[i][3] = -_c0y + 3.0f * _c1y - 3.0f * _c2y + _c3y;
+        }
+    }
+
+    if (x == 0.0 || x == 1.0) {
+        return x;
+    }
+    float t = calcParameterViaNewtonRaphsonUsingXAndCoefficientsForX(x, _coefficientsX[type]);
+    float y = evaluateAtParameterWithCoefficients(t, _coefficientsY[type]);
+    return y;
+}
+
+void set_y_offset_objects(float a) {
+    y_offset = a;
+}
+
+void setup_shaders() {
+    const char *vshader =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "void main(){"
+                    "   gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    const char *fshader =
+            "precision lowp float;"
+                    "uniform vec4 u_Color;"
+                    "uniform float u_Alpha;"
+                    "void main() {"
+                    "   gl_FragColor = u_Color;"
+                    "   gl_FragColor.w*=u_Alpha;"
+                    "}";
+
+    color_program = get_color_program(build_program(vshader, (GLint) strlen(vshader), fshader, (GLint) strlen(fshader)));
+
+    const char *vshader_texture =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    const char *fshader_texture =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "    gl_FragColor.w *= u_Alpha;"
+                    "}";
+
+    texture_program = get_texture_program(build_program(vshader_texture, (GLint) strlen(vshader_texture), fshader_texture, (GLint) strlen(fshader_texture)));
+
+    const char *vshader_texture_blue =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    const char *fshader_texture_blue =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "   float p = u_Alpha*gl_FragColor.w;"
+                    "   gl_FragColor = vec4(0,0.6,0.898,p);"
+                    "}";
+
+    texture_program_blue = get_texture_program(build_program(vshader_texture_blue, (GLint) strlen(vshader_texture_blue), fshader_texture_blue, (GLint) strlen(fshader_texture_blue)));
+
+    const char *vshader_texture_red =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    const char *fshader_texture_red =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "   gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "   float p = gl_FragColor.w*u_Alpha;"
+                    "   gl_FragColor = vec4(210./255.,57./255.,41./255.,p);"
+                    "}";
+
+    texture_program_red = get_texture_program(build_program(vshader_texture_red, (GLint) strlen(vshader_texture_red), fshader_texture_red, (GLint) strlen(fshader_texture_red)));
+
+    vshader =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    fshader =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "    float p = u_Alpha*gl_FragColor.w;"
+                    "    gl_FragColor = vec4(246./255., 73./255., 55./255., p);"
+                    "}";
+
+    texture_program_light_red = get_texture_program(build_program(vshader, (GLint) strlen(vshader), fshader, (GLint) strlen(fshader)));
+
+    vshader =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    fshader =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "    float p = u_Alpha*gl_FragColor.w;"
+                    "    gl_FragColor = vec4(42./255.,180./255.,247./255.,p);"
+                    "}";
+
+    texture_program_light_blue = get_texture_program(build_program(vshader, (GLint) strlen(vshader), fshader, (GLint) strlen(fshader)));
+
+    vshader =
+            "uniform mat4 u_MvpMatrix;"
+                    "attribute vec4 a_Position;"
+                    "attribute vec2 a_TextureCoordinates;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "void main(){"
+                    "    v_TextureCoordinates = a_TextureCoordinates;"
+                    "    gl_Position = u_MvpMatrix * a_Position;"
+                    "}";
+
+    fshader =
+            "precision lowp float;"
+                    "uniform sampler2D u_TextureUnit;"
+                    "varying vec2 v_TextureCoordinates;"
+                    "uniform float u_Alpha;"
+                    "void main(){"
+                    "    gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates);"
+                    "    gl_FragColor *= u_Alpha;"
+                    "}";
+
+    texture_program_one = get_texture_program(build_program(vshader, (GLint) strlen(vshader), fshader, (GLint) strlen(fshader)));
+}
+
+CPoint CPointMake(float x, float y) {
+    CPoint p = {x, y};
+    return p;
+}
+
+CSize CSizeMake(float width, float height) {
+    CSize s = {width, height};
+    return s;
+}
+
+float D2R(float a) {
+    return (float) (a * M_PI / 180.0);
+}
+
+float R2D(float a) {
+    return (float) (a * 180.0 / M_PI);
+}
+
+xyz xyzMake(float x, float y, float z) {
+    xyz result;
+    result.x = x;
+    result.y = y;
+    result.z = z;
+    return result;
+}
+
+LayerParams default_layer_params() {
+    LayerParams params;
+    params.anchor.x = params.anchor.y = params.anchor.z = 0;
+    params.position.x = params.position.y = params.position.z = 0;
+    params.rotation = 0;
+    params.scale.x = params.scale.y = params.scale.z = 1.0f;
+    return params;
+}
+
+Params default_params() {
+    Params params;
+    params.anchor.x = params.anchor.y = params.anchor.z = 0.0f;
+    params.position.x = params.position.y = params.position.z = 0.0f;
+    params.rotation = 0;
+    params.scale.x = params.scale.y = params.scale.z = 1.0f;
+    params.alpha = 1.0f;
+    params.var_params.side_length = 0;
+    params.var_params.start_angle = 0;
+    params.var_params.end_angle = 0;
+    params.var_params.angle = 0;
+    params.var_params.size = CSizeMake(0, 0);
+    params.var_params.radius = 0;
+    params.var_params.width = 0;
+    params.const_params.is_star = 0;
+    params.layer_params = default_layer_params();
+    return params;
+}
+
+void mat4x4_translate_independed(mat4x4 m, float x, float y, float z) {
+    mat4x4 tr;
+    mat4x4_identity(tr);
+    mat4x4_translate_in_place(tr, x, y, z);
+    mat4x4 m_dup;
+    mat4x4_dup(m_dup, m);
+    mat4x4_mul(m, tr, m_dup);
+}
+
+static inline void mvp_matrix(mat4x4 model_view_projection_matrix, Params params, mat4x4 view_projection_matrix) {
+    mat4x4 model_matrix;
+    mat4x4_identity(model_matrix);
+    mat4x4 id;
+    mat4x4_identity(id);
+    mat4x4_translate(model_matrix, -params.anchor.x, -params.anchor.y, params.anchor.z);
+    mat4x4 scaled;
+    mat4x4_identity(scaled);
+    mat4x4_scale_aniso(scaled, scaled, params.scale.x, -params.scale.y, params.scale.z);
+    mat4x4 tmp;
+    mat4x4_dup(tmp, model_matrix);
+    mat4x4_mul(model_matrix, scaled, tmp);
+    mat4x4 rotate;
+    mat4x4_dup(rotate, id);
+    mat4x4_rotate_Z2(rotate, id, deg_to_radf(-params.rotation));
+    mat4x4_dup(tmp, model_matrix);
+    mat4x4_mul(model_matrix, rotate, tmp);
+    mat4x4_translate_independed(model_matrix, params.position.x, -params.position.y, params.position.z);
+    mat4x4 model_matrix3;
+    mat4x4_identity(model_matrix3);
+    mat4x4 mm;
+    mat4x4_mul(mm, model_matrix3, view_projection_matrix);
+    mat4x4_mul(model_view_projection_matrix, mm, model_matrix);
+    mat4x4_translate_independed(model_view_projection_matrix, 0, -y_offset / view_projection_matrix[3][3], 0);
+}
+
+void draw_shape(const Shape* shape, mat4x4 view_projection_matrix) {
+    if (shape->params.alpha > 0 && (fabs(shape->params.scale.x) > 0 && fabs(shape->params.scale.y) > 0 && fabs(shape->params.scale.z) > 0)) {
+        mat4x4 model_view_projection_matrix;
+        mvp_matrix(model_view_projection_matrix, shape->params, view_projection_matrix);
+        glUseProgram(color_program.program);
+        glUniformMatrix4fv(color_program.u_mvp_matrix_location, 1, GL_FALSE, (GLfloat *) model_view_projection_matrix);
+        if (shape->params.rotation == 5.0f) {
+            glUniform4fv(color_program.u_color_location, 1, shape->color);
+        } else if (shape->params.rotation == 10.0f) {
+            vec4 col = {0, 1, 0, 1};
+            glUniform4fv(color_program.u_color_location, 1, col);
+        } else {
+            glUniform4fv(color_program.u_color_location, 1, shape->color);
+        }
+        glUniform1f(color_program.u_alpha_loaction, shape->params.alpha);
+        glVertexAttribPointer(color_program.a_position_location, 2, GL_FLOAT, GL_FALSE, sizeof(CPoint), &shape->data[0].x);
+        glEnableVertexAttribArray(color_program.a_position_location);
+        glDrawArrays(shape->params.const_params.triangle_mode, 0, shape->num_points);
+    }
+}
+
+void draw_textured_shape(const TexturedShape* shape, mat4x4 view_projection_matrix, texture_program_type program_type) {
+    if (shape->params.alpha > 0 && (fabs(shape->params.scale.x) > 0 && fabs(shape->params.scale.y) > 0 && fabs(shape->params.scale.z) > 0)) {
+        mat4x4 model_view_projection_matrix;
+        mvp_matrix(model_view_projection_matrix, shape->params, view_projection_matrix);
+        if (shape->params.const_params.is_star == 1) {
+            vec4 pos;
+            vec4 vertex = {0, 0, 0, 1};
+            mat4x4_mul_vec4(pos, model_view_projection_matrix, vertex);
+            vec4 p_NDC = {pos[0] / pos[3], pos[1] / pos[3], pos[2] / pos[3], pos[3] / pos[3]};
+            vec4 p_window = {p_NDC[0] * width, -p_NDC[1] * height, 0, 0};
+            int32_t d = 160;
+            if (fabs(p_window[0]) > d || p_window[1] > y_offset_absolute * 2 + d || p_window[1] < y_offset_absolute * 2 - d) {
+                return;
+            }
+        }
+        if (program_type == RED) {
+            texture_program_temp = &texture_program_red;
+        } else if (program_type == BLUE) {
+            texture_program_temp = &texture_program_blue;
+        } else if (program_type == LIGHT_RED) {
+            texture_program_temp = &texture_program_light_red;
+        } else if (program_type == LIGHT_BLUE) {
+            texture_program_temp = &texture_program_light_blue;
+        } else if (program_type == NORMAL_ONE) {
+            texture_program_temp = &texture_program_one;
+        } else {
+            texture_program_temp = &texture_program;
+        }
+
+
+        glUseProgram(texture_program_temp->program);
+
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, shape->texture);
+        glUniformMatrix4fv(texture_program_temp->u_mvp_matrix_location, 1, GL_FALSE, (GLfloat *) model_view_projection_matrix);
+        glUniform1i(texture_program_temp->u_texture_unit_location, 0);
+        glUniform1f(texture_program_temp->u_alpha_loaction, shape->params.alpha);
+
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glVertexAttribPointer(texture_program_temp->a_position_location, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), BUFFER_OFFSET(0));
+        glVertexAttribPointer(texture_program_temp->a_texture_coordinates_location, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GL_FLOAT), BUFFER_OFFSET(2 * sizeof(GL_FLOAT)));
+        glEnableVertexAttribArray(texture_program_temp->a_position_location);
+        glEnableVertexAttribArray(texture_program_temp->a_texture_coordinates_location);
+        glDrawArrays(shape->params.const_params.triangle_mode, 0, shape->num_points);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+static inline void gen_rounded_rectangle(CPoint* out, CSize size, float radius, int32_t round_count) {
+    int32_t offset = 0;
+    out[offset++] = CPointMake(0, 0);
+    float k = (float) (M_PI / 2 / (round_count + 1));
+    int32_t i = 0;
+    int32_t n = 0;
+    for (i = (round_count + 2) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * radius, size.height / 2 - radius + sinf(i * k) * radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * radius, size.height / 2 - radius + sinf(i * k) * radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * radius, -size.height / 2 + radius + sinf(i * k) * radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * radius, -size.height / 2 + radius + sinf(i * k) * radius);
+    }
+    out[offset] = CPointMake(size.width / 2, size.height / 2 - radius);
+}
+
+Shape create_rounded_rectangle(CSize size, float radius, int32_t round_count, const vec4 color) {
+    int32_t real_vertex_count = 4 * (2 + round_count) + 2;
+
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count * 2;
+    params.const_params.round_count = round_count;
+    params.const_params.triangle_mode = GL_TRIANGLE_FAN;
+
+    params.var_params.size = size;
+    params.var_params.radius = radius;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_rounded_rectangle(data, params.var_params.size, params.var_params.radius, params.const_params.round_count);
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+void change_rounded_rectangle(Shape* shape, CSize size, float radius) {
+    if ((*shape).params.var_params.size.width != size.width || (*shape).params.var_params.size.height != size.height || (*shape).params.var_params.radius != radius) {
+        (*shape).params.var_params.size.width = size.width;
+        (*shape).params.var_params.size.height = size.height;
+        (*shape).params.var_params.radius = radius;
+        gen_rounded_rectangle((*shape).data, (*shape).params.var_params.size, (*shape).params.var_params.radius, (*shape).params.const_params.round_count);
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glBufferSubData(GL_ARRAY_BUFFER, 0, shape->params.const_params.datasize, shape->data);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+static inline CPoint square_point(float angle, float radius) {
+    CPoint p = {0.0f, 0.0f};
+    if (angle <= M_PI / 2 * 0.5f || angle > M_PI / 2 * 3.5f) {
+        p = CPointMake(radius, radius * sinf(angle) / cosf(angle));
+    } else if (angle <= M_PI / 2 * 1.5) {
+        p = CPointMake(radius * cosf(angle) / sinf(angle), radius);
+    } else if (angle <= M_PI / 2 * 2.5) {
+        p = CPointMake(-radius, -radius * sinf(angle) / cosf(angle));
+    } else if (angle <= (float) (M_PI / 2 * 3.5)) {
+        p = CPointMake(-radius * cosf(angle) / sinf(angle), -radius);
+    }
+    return p;
+}
+
+static inline CPoint square_texture_point(CPoint p, float side_length) {
+    return CPointMake((-p.x / side_length * 0.5f + 0.5f), -p.y / side_length * 0.5f + 0.5f);
+}
+
+static inline void gen_segmented_square(CPoint* out, float side_length, float start_angle, float end_angle) {
+    CPoint p;
+    float radius = side_length;
+    int32_t offset = 0;
+    float k = 1;
+    float da = D2R(-2.6f * 2) * k;
+    p = CPointMake(sinf(start_angle + end_angle) * 6 * k, -cosf(start_angle + end_angle) * 6 * k);
+    out[offset++] = p;
+    out[offset++] = square_texture_point(p, side_length);
+    p = square_point(start_angle + da, radius);
+    out[offset++] = p;
+    out[offset++] = square_texture_point(p, side_length);
+    int32_t q = 0;
+    int32_t i;
+    for (i = (int32_t) start_angle; i < floorf(R2D(start_angle + end_angle + da)); i++) {
+        if ((i + 45) % 90 == 0) {
+            p = square_point(D2R(i), radius);
+            out[offset++] = p;
+            out[offset++] = square_texture_point(p, side_length);
+            q++;
+        }
+    }
+    p = square_point(start_angle + end_angle + da, radius);
+    out[offset++] = p;
+    out[offset++] = square_texture_point(p, side_length);
+    for (i = 0; i < 4 - q; i++) {
+        p = square_point(start_angle + end_angle + da, radius);
+        out[offset++] = p;
+        out[offset++] = square_texture_point(p, side_length);
+    }
+}
+
+TexturedShape create_segmented_square(float side_length, float start_angle, float end_angle, GLuint texture) {
+    int32_t real_vertex_count = 7;
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count * 2 * 2;
+    params.const_params.triangle_mode = GL_TRIANGLE_FAN;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_segmented_square(data, side_length, start_angle, end_angle);
+    return (TexturedShape) {texture, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+void change_segmented_square(TexturedShape* shape, float side_length, float start_angle, float end_angle) {
+    if ((*shape).params.var_params.side_length != side_length || (*shape).params.var_params.start_angle != start_angle || (*shape).params.var_params.end_angle != end_angle) {
+        (*shape).params.var_params.side_length = side_length;
+        (*shape).params.var_params.start_angle = start_angle;
+        (*shape).params.var_params.end_angle = end_angle;
+        gen_segmented_square((*shape).data, side_length, start_angle, end_angle);
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glBufferSubData(GL_ARRAY_BUFFER, 0, shape->params.const_params.datasize, shape->data);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+static inline void gen_rectangle(CPoint* out, CSize size) {
+    out[0] = CPointMake(-size.width / 2, -size.height / 2);
+    out[1] = CPointMake(size.width / 2, -size.height / 2);
+    out[2] = CPointMake(-size.width / 2, size.height / 2);
+    out[3] = CPointMake(size.width / 2, size.height / 2);
+}
+
+Shape create_rectangle(CSize size, const vec4 color) {
+    int32_t real_vertex_count = 4;
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count;
+    params.const_params.triangle_mode = GL_TRIANGLE_STRIP;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_rectangle(data, size);
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+static inline CPoint rectangle_texture_point(CPoint p, CSize size) {
+    return CPointMake(1 - (-p.x / size.width + 0.5f), p.y / size.height + 0.5f);
+}
+
+static inline void gen_textured_rectangle(CPoint* out, CSize size) {
+    out[0] = CPointMake(-size.width / 2, -size.height / 2);
+    out[1] = rectangle_texture_point(CPointMake(-size.width / 2, -size.height / 2), size);
+    out[2] = CPointMake(size.width / 2, -size.height / 2);
+    out[3] = rectangle_texture_point(CPointMake(size.width / 2, -size.height / 2), size);
+    out[4] = CPointMake(-size.width / 2, size.height / 2);
+    out[5] = rectangle_texture_point(CPointMake(-size.width / 2, size.height / 2), size);
+    out[6] = CPointMake(size.width / 2, size.height / 2);
+    out[7] = rectangle_texture_point(CPointMake(size.width / 2, size.height / 2), size);
+}
+
+TexturedShape create_textured_rectangle(CSize size, GLuint texture) {
+    int32_t real_vertex_count = 4;
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count * 2;
+    params.const_params.triangle_mode = GL_TRIANGLE_STRIP;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_textured_rectangle(data, size);
+    return (TexturedShape) {texture, data, create_vbo(params.const_params.datasize, data, GL_STATIC_DRAW), real_vertex_count, params};
+}
+
+static inline void gen_ribbon(CPoint* out, float length) {
+    out[0] = CPointMake(-MAXf(length - 5.5f, 0), -5.5f);
+    out[1] = CPointMake(0, -5.5f);
+    out[2] = CPointMake(-MAXf(length, 0), 5.5f);
+    out[3] = CPointMake(0, 5.5f);
+}
+
+Shape create_ribbon(float length, const vec4 color) {
+    int32_t real_vertex_count = 4;
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count;
+    params.const_params.triangle_mode = GL_TRIANGLE_STRIP;
+    params.var_params.side_length = length;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_ribbon(data, length);
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+void change_ribbon(Shape* shape, float length) {
+    if ((*shape).params.var_params.side_length != length) {
+        (*shape).params.var_params.side_length = length;
+        gen_ribbon((*shape).data, length);
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glBufferSubData(GL_ARRAY_BUFFER, 0, shape->params.const_params.datasize, shape->data);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+static inline void gen_circle(CPoint* out, float radius, int32_t vertex_count) {
+    int32_t offset = 0;
+    out[offset++] = CPointMake(0, 0);
+    int32_t i;
+    for (i = 0; i <= vertex_count; i++) {
+        out[offset++] = CPointMake(radius * (cosf(2 * (float) M_PI * (i / (float) vertex_count))), radius * sinf(2 * (float) M_PI * (i / (float) vertex_count)));
+    }
+}
+
+Shape create_circle(float radius, int32_t vertex_count, const vec4 color) {
+    int32_t real_vertex_count = vertex_count + 2;
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count;
+    params.const_params.triangle_mode = GL_TRIANGLE_FAN;
+    params.const_params.round_count = vertex_count;
+    CPoint *data = (CPoint *) malloc((size_t) params.const_params.datasize);
+    gen_circle(data, radius, vertex_count);
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_STATIC_DRAW), real_vertex_count, params};
+}
+
+int size_of_infinity_in_vertices(int32_t segment_count) {
+    return (segment_count + 1) * 2;
+}
+
+static inline void gen_infinity(CPoint* out, float width, float angle, int32_t segment_count) {
+    CPoint path[13];
+    path[0] = CPointMake(53, 23);
+    path[1] = CPointMake(49, 31);
+    path[2] = CPointMake(39, 47);
+    path[3] = CPointMake(22, 47);
+    path[4] = CPointMake(6, 47);
+    path[5] = CPointMake(0, 31);
+    path[6] = CPointMake(0, 23);
+    path[7] = CPointMake(0, 16);
+    path[8] = CPointMake(5, 0);
+    path[9] = CPointMake(23, 0);
+    path[10] = CPointMake(39, 0);
+    path[11] = CPointMake(48, 15);
+    path[12] = CPointMake(52, 21);
+    int32_t offset = 0;
+    int32_t seg;
+    for (seg = 0; seg <= segment_count; seg++) {
+        float tt = ((float) seg / (float) segment_count) * angle;
+        int32_t q = 4;
+        float tstep = 1.f / q;
+        int32_t n = (int32_t) floor(tt / tstep);
+        CPoint a = path[0 + 3 * n];;
+        CPoint p1 = path[1 + 3 * n];
+        CPoint p2 = path[2 + 3 * n];
+        CPoint b = path[3 + 3 * n];
+        float t = (tt - tstep * n) * q;
+        float nt = 1.0f - t;
+
+        vec2 p = {a.x * nt * nt * nt + 3.0f * p1.x * nt * nt * t + 3.0f * p2.x * nt * t * t + b.x * t * t * t,
+                  a.y * nt * nt * nt + 3.0f * p1.y * nt * nt * t + 3.0f * p2.y * nt * t * t + b.y * t * t * t};
+        vec2 tangent = {-3.0f * a.x * nt * nt + 3.0f * p1.x * (1.0f - 4.0f * t + 3.0f * t * t) + 3.0f * p2.x * (2.0f * t - 3.0f * t * t) + 3.0f * b.x * t * t,
+                        -3.0f * a.y * nt * nt + 3.0f * p1.y * (1.0f - 4.0f * t + 3.0f * t * t) + 3.0f * p2.y * (2.0f * t - 3.0f * t * t) + 3.0f * b.y * t * t};
+
+        vec2 tan_norm = {-tangent[1], tangent[0]};
+        vec2 norm;
+        vec2_norm(norm, tan_norm);
+
+        vec2 v;
+        vec2 norm_scaled;
+        vec2_scale(norm_scaled, norm, +width / 2.f);
+        vec2_add(v, p, norm_scaled);
+
+        out[offset] = CPointMake(v[0], v[1]);
+        offset++;
+
+        vec2_scale(norm_scaled, norm, -width / 2.f);
+        vec2_add(v, p, norm_scaled);
+
+        out[offset] = CPointMake(v[0], v[1]);
+        offset++;
+    }
+}
+
+Shape create_infinity(float width, float angle, int32_t segment_count, const vec4 color) {
+    int32_t real_vertex_count = size_of_infinity_in_vertices(segment_count);
+    Params params = default_params();
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count;
+    params.const_params.triangle_mode = GL_TRIANGLE_STRIP;
+    params.const_params.round_count = segment_count;
+    params.var_params.width = width;
+    params.var_params.angle = angle;
+    CPoint *data = malloc((size_t) params.const_params.datasize);
+    gen_infinity(data, width, angle, segment_count);
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+void change_infinity(Shape* shape, float angle) {
+    if ((*shape).params.var_params.angle != angle) {
+        (*shape).params.var_params.angle = angle;
+        gen_infinity(shape->data, (*shape).params.var_params.width, (*shape).params.var_params.angle, (*shape).params.const_params.round_count);
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glBufferData(GL_ARRAY_BUFFER, shape->params.const_params.datasize, shape->data, GL_DYNAMIC_DRAW);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+static inline void gen_rounded_rectangle_stroked(CPoint* out, CSize size, float radius, float stroke_width, int32_t round_count) {
+    int32_t offset = 0;
+    float k = (float) (M_PI / 2 / (round_count + 1));
+    float inner_radius = radius - stroke_width;
+    int32_t i = 0;
+    int32_t n = 0;
+    for (i = (round_count + 2) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * radius, size.height / 2 - radius + sinf(i * k) * radius);
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * inner_radius, size.height / 2 - radius + sinf(i * k) * inner_radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * radius, size.height / 2 - radius + sinf(i * k) * radius);
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * inner_radius, size.height / 2 - radius + sinf(i * k) * inner_radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * radius, -size.height / 2 + radius + sinf(i * k) * radius);
+        out[offset++] = CPointMake(-size.width / 2 + radius + cosf(i * k) * inner_radius, -size.height / 2 + radius + sinf(i * k) * inner_radius);
+    }
+    n++;
+    for (i = (round_count + 1) * n; i <= round_count + 1 + (round_count + 1) * n; i++) {
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * radius, -size.height / 2 + radius + sinf(i * k) * radius);
+        out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * inner_radius, -size.height / 2 + radius + sinf(i * k) * inner_radius);
+    }
+    i = 0;
+    out[offset++] = CPointMake(size.width / 2 - radius + cosf(i * k) * radius, size.height / 2 - radius + sinf(i * k) * radius);
+    out[offset] = CPointMake(size.width / 2 - radius + cosf(i * k) * inner_radius, size.height / 2 - radius + sinf(i * k) * inner_radius);
+}
+
+Shape create_rounded_rectangle_stroked(CSize size, float radius, float stroke_width, int32_t round_count, const vec4 color) {
+    int32_t real_vertex_count = 4 * (2 + round_count) * 2 + 2;
+    Params params = default_params();
+    params.const_params.round_count = round_count;
+    params.const_params.datasize = sizeof(CPoint) * real_vertex_count * 2;
+    params.var_params.size = size;
+    params.var_params.radius = radius;
+    params.var_params.width = stroke_width;
+    CPoint *data = (CPoint *) malloc((size_t) params.const_params.datasize);
+    gen_rounded_rectangle_stroked(data, params.var_params.size, params.var_params.radius, params.var_params.width, params.const_params.round_count);
+    params.const_params.triangle_mode = GL_TRIANGLE_STRIP;
+    return (Shape) {{color[0], color[1], color[2], color[3]}, data, create_vbo(params.const_params.datasize, data, GL_DYNAMIC_DRAW), real_vertex_count, params};
+}
+
+void change_rounded_rectangle_stroked(Shape* shape, CSize size, float radius) {
+    if ((*shape).params.var_params.size.width != size.width || (*shape).params.var_params.size.height != size.height || (*shape).params.var_params.radius != radius) {
+        (*shape).params.var_params.size.width = size.width;
+        (*shape).params.var_params.size.height = size.height;
+        (*shape).params.var_params.radius = radius;
+        gen_rounded_rectangle_stroked((*shape).data, (*shape).params.var_params.size, (*shape).params.var_params.radius, (*shape).params.var_params.width, (*shape).params.const_params.round_count);
+        glBindBuffer(GL_ARRAY_BUFFER, shape->buffer);
+        glBufferSubData(GL_ARRAY_BUFFER, 0, shape->params.const_params.datasize, shape->data);
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+    }
+}
+
+//------------------------------
+
+float t(float start_value, float end_value, float start_time, float duration, timing_type type) {
+    if (time > start_time + duration) {
+        return end_value;
+    }
+    if (type == Linear) {
+        return start_value + (end_value - start_value) * MINf(duration + start_time, MAXf(.0, (time - start_time))) / duration;
+    }
+    return start_value + (end_value - start_value) * timing(MINf(duration + start_time, MAXf(.0, (time - start_time))) / duration, type);
+}
+
+float t_reversed(float end_value, float start_value, float start_time, float duration, timing_type type) {
+    if (time > start_time + duration) {
+        return end_value;
+    }
+    if (type == Linear) {
+        return start_value + (end_value - start_value) * MINf(duration + start_time, MAXf(0.0f, (time - start_time))) / duration;
+    }
+    return start_value + (end_value - start_value) * timing(MINf(duration + start_time, MAXf(0.0f, (time - start_time))) / duration, type);
+}
+
+float t_local(float start_value, float end_value, float start_time, float duration, timing_type type) {
+    if (type == Sin) {
+        return start_value + (end_value - start_value) * sinf(MINf(MAXf((time_local - start_time) / duration * (float) M_PI, 0), (float) M_PI));
+    }
+
+    if (time_local > start_time + duration) {
+        return end_value;
+    }
+
+    if (type == Linear) {
+        return start_value + (end_value - start_value) * MINf(duration + start_time, MAXf(.0, (time_local - start_time))) / duration;
+    }
+    return start_value + (end_value - start_value) * timing(MINf(duration + start_time, MAXf(.0, (time_local - start_time))) / duration, type);
+}
+
+xyz star_create_position(float far) {
+    starsFar = 1500;
+    int32_t minR = 100;
+    int32_t maxR = 1000;
+    return xyzMake(signrand() * frand(minR, maxR), signrand() * frand(minR, maxR), far);
+}
+
+xyz star_initial_position(int32_t randZ, int32_t forward) {
+    starsFar = 1500;
+    int32_t minR = 100;
+    int32_t maxR = 1000;
+    float z = 0;
+    if (forward == 1) {
+        if (randZ == 0) {
+            z = -starsFar;
+        } else {
+            z = frand(0, -starsFar);
+        }
+    }
+
+    return xyzMake(signrand() * frand(minR, maxR), signrand() * frand(minR, maxR), z);
+}
+
+void draw_stars() {
+    float k = (float) width / (float) height;
+
+    set_y_offset_objects(-100 * k * 0);
+    for (i = 0; i < starsCount; i++) {
+        float stars_scroll_offset = MAXf(0, scroll_offset) * 2;
+
+        float transition_speed;
+        if (direct == 1) {
+            float s = 5;
+            transition_speed = s - t(0, s, 0, duration_const + 1 + 0.8f, Linear);
+        } else {
+            transition_speed = t(-4, 0, 0, duration_const + 1, EaseOut);
+        }
+
+        float speed = stars_scroll_offset + transition_speed;
+        stars[i].position.z += speed;
+
+        if (stars[i].position.z > 0 && speed > 0) {
+            stars[i].position = star_initial_position(0, 1);
+        }
+        if (stars[i].position.z < -1500 && speed < 0) {
+            stars[i].position = star_initial_position(0, 0);
+        }
+
+        float inc = scroll_offset * 100;
+        stars[i].position.z = stars[i].position.z + inc;
+
+        star.params.position = stars[i].position;
+        float s = 1 + (-stars[i].position.z) / starsFar * 5;
+
+        star.params.scale = xyzMake(s, s, 1);
+        float far = starsFar;
+        star.params.alpha = (1 - (-stars[i].position.z) / far) * 10.0f;
+        star.params.alpha = star.params.alpha * star.params.alpha / 10.0f;
+
+
+        draw_textured_shape(&star, stars_matrix, NORMAL);
+
+        stars[i].position.z = stars[i].position.z - inc;
+    }
+
+    set_y_offset_objects(offset_y);
+}
+
+static inline void mat4x4_plain(mat4x4 M, int32_t width, int32_t height) {
+    int32_t i, j;
+    for (i = 0; i < 4; ++i) {
+        for (j = 0; j < 4; ++j) {
+            M[i][j] = 0.0f;
+        }
+    }
+
+    M[0][0] = 1;
+    M[1][1] = 1;
+    M[2][2] = 1;
+    M[0][0] = 1;
+    M[1][1] = (float) width / (float) height;
+    M[2][2] = 1;
+    M[3][3] = (float) width / 2.0f;
+}
+
+static inline void mat4x4_stars(mat4x4 m, float y_fov_in_degrees, float aspect, float n, float f, int32_t width, int32_t height) {
+    if (height >= width) {
+        float k = (float) width / (float) height;
+        float q = 1.4f;
+        m[0][0] = 1.0f / q;
+        m[1][0] = 0.0f;
+        m[2][0] = 0.0f;
+        m[3][0] = 0.0f;
+
+        m[1][0] = 0.0f;
+        m[1][1] = k / q;
+        m[1][2] = 0.0f;
+        m[1][3] = 0.0f;
+
+        m[2][0] = 0.0f;
+        m[2][1] = 0.0f;
+        m[2][2] = 1.0f;
+        m[2][3] = -1.25f;
+
+        m[3][0] = 0.0f;
+        m[3][1] = 0.0f;
+        m[3][2] = 0.0f;
+        m[3][3] = width * k;
+    } else {
+        float k = (float) height / (float) width;
+        float q = 2.0f;
+
+        m[0][0] = 1.0f / q;
+        m[1][0] = 0.0f;
+        m[2][0] = 0.0f;
+        m[3][0] = 0.0f;
+
+        m[1][0] = 0.0f;
+        m[1][1] = (1.0f / k) / q;
+        m[1][2] = 0.0f;
+        m[1][3] = 0.0f;
+
+        m[2][0] = 0.0f;
+        m[2][1] = 0.0f;
+        m[2][2] = 1.0f;
+        m[2][3] = -1.25f;
+
+        m[3][0] = 0.0f;
+        m[3][1] = 0.0f;
+        m[3][2] = 0.0f;
+        m[3][3] = height * k;
+    }
+    mat4x4_translate_independed(m, 0, -2 * y_offset_absolute / (float) height + 4 * scale_factor / (float) height, 0);
+}
+
+void rglNormalDraw() {
+    glDisable(GL_DEPTH_TEST);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glColorMask(1, 1, 1, 1);
+    glDepthMask(0);
+}
+
+void rglMaskDraw() {
+    glEnable(GL_DEPTH_TEST);
+    glDisable(GL_BLEND);
+    glDepthMask(1);
+    glColorMask(0, 0, 0, 0);
+    glDepthFunc(GL_GREATER);
+    glClearDepthf(0);
+    glClear(GL_DEPTH_BUFFER_BIT);
+}
+
+void rglNormalDrawThroughMask() {
+    glColorMask(1, 1, 1, 1);
+    glDepthFunc(GL_LESS);
+    glDepthMask(0);
+}
+
+void mat4x4_scaled(mat4x4 matrix, float s) {
+    mat4x4_identity(matrix);
+    mat4x4_scale_aniso(matrix, matrix, s, s, s);
+}
+
+void mat4x4_layer(mat4x4 matrix, LayerParams params, float s, float r) {
+    float a = main_matrix[1][1];
+    mat4x4 model_matrix;
+    mat4x4_identity(model_matrix);
+    mat4x4 id;
+    mat4x4_identity(id);
+    float sc = main_matrix[3][3];
+    mat4x4_translate(model_matrix, -params.anchor.x / sc, params.anchor.y / sc * a, params.anchor.z / sc);
+    mat4x4 scaled;
+    mat4x4_identity(scaled);
+    float f = 1.0f;
+    mat4x4_scale_aniso(scaled, scaled, params.scale.x * f, params.scale.y * f, params.scale.z * f);
+    mat4x4 tmp;
+    mat4x4_dup(tmp, model_matrix);
+    mat4x4_mul(model_matrix, scaled, tmp);
+    mat4x4 rotate;
+    mat4x4_dup(rotate, id);
+    mat4x4_rotate_Z2(rotate, id, -deg_to_radf(params.rotation));
+    mat4x4_dup(tmp, model_matrix);
+    mat4x4_mul(model_matrix, rotate, tmp);
+    mat4x4_translate_independed(model_matrix, params.position.x / sc, -params.position.y / sc * a, params.position.z / sc);
+
+    mat4x4 m;
+    mat4x4_mul(m, model_matrix, main_matrix);
+
+    m[1][0] /= a;
+    m[0][1] *= a;
+
+    mat4x4 scale_m;
+    mat4x4_scaled(scale_m, s);
+    mat4x4_rotate_Z(scale_m, r);
+    scale_m[1][0] /= a;
+    scale_m[0][1] *= a;
+    mat4x4_mul(matrix, scale_m, m);
+}
+
+float bubble_dots_sinf(float a) {
+    if (a < M_PI * 2 * anim_bubble_dots_end_period) {
+        return sinf(a);
+    }
+    return 0;
+}
+
+static void reset_ic() {
+    anim_smile_start_time1 = time_local;
+    anim_pencil_start_time = 0;
+    anim_pencil_start_all_end_time = 0;
+    anim_cam_next_time = time_local;
+    anim_smile_stage = 0;
+    anim_smile_blink_one = 0;
+    anim_pencil_stage = 0;
+    anim_bubble_dots_end_period = 4;
+    anim_pencil_period = 1;
+}
+
+static void draw_ic(int32_t type) {
+    float rotation;
+    float beginTimeK;
+    float commonDelay;
+    float beginY = 250;
+    int32_t bounce;
+    texture_program_type COLOR, LIGHT_COLOR;
+    if (type == 0) {
+        beginTimeK = 2.0f;
+        commonDelay = duration_const * 0.5f;
+        bounce = 1;
+        rotation = -D2R(free_scroll_offset);
+        cloud_scroll_offset = 0;
+        COLOR = RED, LIGHT_COLOR = LIGHT_RED;
+    } else {
+        rotation = 0;
+        beginTimeK = 2.5;
+        commonDelay = 0;
+        bounce = 1;
+        COLOR = BLUE, LIGHT_COLOR = LIGHT_BLUE;
+    }
+    float scale;
+    float t_y;
+    CPoint ic_pos;
+    float ic_layer_alpha;
+    if (current_page == 1 && direct == 0) {
+        ic_layer_alpha = t(1, 0, 0, duration_const * 0.25f, EaseOut);
+    } else {
+        ic_layer_alpha = 1;
+    }
+    ic_pin.params.alpha = ic_layer_alpha;
+    ic_cam.params.alpha = ic_layer_alpha;
+    ic_cam_lens.params.alpha = ic_layer_alpha;
+    ic_smile.params.alpha = ic_layer_alpha;
+    ic_smile_eye.params.alpha = ic_layer_alpha;
+    ic_videocam.params.alpha = ic_layer_alpha;
+    ic_bubble.params.alpha = ic_layer_alpha;
+    ic_bubble_dot.params.alpha = ic_layer_alpha;
+    ic_pencil.params.alpha = ic_layer_alpha;
+
+    if (type == 0) {
+        ic_pos = CPointMake(-106 / 2, 61 / 2);
+        if (current_page == 1 && direct == 0) {
+            t_y = 0;
+        } else {
+            t_y = t(beginY, 0, commonDelay + duration_const * 0.2f * beginTimeK, duration_const, EaseOut);
+            float arg = MAXf(0, time - (commonDelay + duration_const * 0.2f * beginTimeK)) * 50;
+            float value = beginY * powf(2.71, -0.055f * arg * 2) * cosf(0.08f * arg) * 0.4f;
+            t_y -= value * bounce;
+        }
+    } else {
+        ic_pos = CPointMake(-162 / 2 + 4, +26 / 2 + 20);
+        t_y = t(beginY, 0, commonDelay + duration_const * 0.2f * beginTimeK, duration_const, EaseOut);
+        float value = 0;
+        float e = 2.71;
+        float arg = MAXf(0, time - (commonDelay + duration_const * 0.2f * beginTimeK)) * 50;
+        value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg - (float) M_PI / 8.0f) * 0.4f;
+        t_y -= value * bounce;
+    }
+
+    if (time_local > anim_pin_start_time) {
+        if (time_local > anim_pin_start_time + anim_pin_duration) {
+            anim_pin_start_time = time_local + duration_const * frand(10, 20) * 2;
+            anim_pin_duration = duration_const * frand(10, 20) * 2;
+        }
+    }
+    float pinasin = 0;
+    ic_pin_layer.position = xyzMake(ic_pos.x + cosf(time_local * 5) * 3 * pinasin + cloud_scroll_offset, ic_pos.y + sinf(time_local * 5) * 1.5f * pinasin + t_y, 0);
+    mat4x4_layer(ic_matrix, ic_pin_layer, 1, rotation);
+    draw_textured_shape(&ic_pin, ic_matrix, COLOR);
+
+    if (type == 1) {
+        ic_videocam_layer.rotation = -30 + t_local(anim_videocam_old_angle, anim_videocam_angle, anim_videocam_start_time, anim_videocam_duration, EaseOut);
+        t_y = t(beginY, 0, commonDelay + duration_const * 0.45f * beginTimeK, duration_const, EaseOut);
+        float value = 0;
+        float e = 2.71;
+        float arg = MAXf(0, time - (commonDelay + duration_const * 0.45f * beginTimeK)) * 50;
+        value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * 0.4f;
+        t_y -= value * bounce;
+        if (t_y <= 1 && time_local > anim_videocam_next_time) {
+            anim_videocam_duration = duration_const * frand(1.0f, 1.5f) * 1.5f;
+            anim_videocam_old_angle = anim_videocam_angle;
+            anim_videocam_angle = 15 * irand(-1, 1);
+            anim_videocam_start_time = time_local;
+            anim_videocam_next_time = time_local + 1000000 + duration_const * frand(5, 8);
+        }
+        ic_videocam_layer.position = xyzMake(-68 / 2 + cloud_scroll_offset, +80 / 2 + t_y, 0);
+        mat4x4_layer(ic_matrix, ic_videocam_layer, 1, rotation);
+        draw_textured_shape(&ic_videocam, ic_matrix, COLOR);
+    }
+
+    if (type == 0) {
+        ic_pos = CPointMake(107 / 2, 78 / 2);
+        if (current_page == 1 && direct == 0) {
+            t_y = 0;
+        } else {
+            t_y = t(beginY, 0, commonDelay + duration_const * 0.3f * beginTimeK, duration_const, EaseOut);
+            float value = 0;
+            float e = 2.71;
+            float arg = MAXf(0, time - (commonDelay + duration_const * 0.3f * beginTimeK)) * 50;
+            value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * 0.4f;
+            t_y -= value * bounce;
+        }
+    } else {
+        ic_pos = CPointMake(-28 / 2, -20 / 2 + 2);
+        t_y = t(beginY, 0, commonDelay + duration_const * 0.15f * beginTimeK, duration_const, EaseOut);
+        float arg = MAXf(0, time - (commonDelay + duration_const * 0.15f * beginTimeK)) * 50;
+        float value = beginY * powf(2.71, -0.055f * arg * 2) * cosf(0.08f * arg) * 0.4f;
+        t_y -= value * bounce;
+    }
+
+    if (t_y <= 1 && time_local > anim_cam_next_time) {
+        anim_cam_duration = duration_const * frand(1.0, 1.5);
+        anim_cam_old_angle = anim_cam_angle;
+        anim_cam_old_position = anim_cam_position;
+        anim_cam_start_time = time_local;
+        anim_cam_next_time = time_local + 10000000;
+        int32_t r = irand(0, 1);
+        if (r == 0) {
+            anim_cam_position = CPointMake(-8 + 4, 0);
+            anim_cam_angle = signrand() * 10;
+        } else if (r == 1) {
+            anim_cam_position = CPointMake(4, -5);
+            anim_cam_angle = signrand() * 10;
+        } else if (r == 2) {
+            anim_cam_position = CPointMake(0, 0);
+            anim_cam_angle = 0;
+        }
+        qShot = irand(1, 2);
+        anim_camshot_start_time = time_local + duration_const * 0.5f;
+        anim_camshot_duration = duration_const * .4f;
+    }
+
+    ic_cam_layer.rotation = 15 + t_local(anim_cam_old_angle, anim_cam_angle, anim_cam_start_time, anim_cam_duration, EaseOut);
+    ic_cam_layer.position = xyzMake(
+            ic_pos.x + 0 * t_local(anim_cam_old_position.x, anim_cam_position.x, anim_cam_start_time, anim_cam_duration, EaseOut) + cloud_scroll_offset,
+            ic_pos.y + 0 * t_local(anim_cam_old_position.y, anim_cam_position.y, anim_cam_start_time, anim_cam_duration, EaseOut)
+            + t_y,
+            0);
+
+    mat4x4_layer(ic_matrix, ic_cam_layer, 1, rotation);
+    draw_textured_shape(&ic_cam, ic_matrix, COLOR);
+
+    float lens_scale;
+    lens_scale = 1;
+    if (qShot >= 0 && time_local > anim_camshot_start_time) {
+        lens_scale = t_local(1, 0, anim_camshot_start_time, anim_camshot_duration, Sin);
+        if (time_local > anim_camshot_start_time + anim_camshot_duration) {
+            qShot--;
+            anim_camshot_start_time = time_local + anim_camshot_duration;
+        }
+    }
+    ic_cam_lens.params.scale = xyzMake(lens_scale, lens_scale, 1);
+    ic_cam_lens.params.position = xyzMake(0, 1.7, 0);
+    draw_textured_shape(&ic_cam_lens, ic_matrix, COLOR);
+
+    if (type == 0) {
+        ic_pos = CPointMake(70 / 2, -116 / 2);
+        if (current_page == 1 && direct == 0) {
+            t_y = 0;
+        } else {
+            t_y = t(beginY, 0, commonDelay + duration_const * .0f * beginTimeK, duration_const, EaseOut);
+            float value = 0;
+            float e = 2.71;
+            float arg = MAXf(0, time - (commonDelay + duration_const * .0f * beginTimeK)) * 50;
+            value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * .4f;
+            t_y -= value * bounce;
+        }
+    } else {
+        ic_pos = CPointMake(+60 / 2, 50 / 2);
+        t_y = t(beginY, 0, commonDelay + duration_const * 0.25f * beginTimeK, duration_const, EaseOut);
+
+        float value = 0;
+        float e = 2.71;
+        float arg = MAXf(0, time - (commonDelay + duration_const * 0.25f * beginTimeK)) * 50;
+        value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg - (float) M_PI / 8.0f) * .4f;
+
+        t_y -= value * bounce;
+    }
+    float smile_laught = 0;
+    float anim_smile_fade_duration = duration_const * 2;
+    float anim_smile_duration = duration_const * 2;
+    if (anim_smile_stage == 0) {
+        smile_laught = t_local(0, 1, anim_smile_start_time1, anim_smile_fade_duration, Linear);
+        if (time_local > anim_smile_duration * 3 + anim_smile_start_time1) {
+            anim_smile_stage = 1;
+            anim_smile_start_time2 = time_local;
+        }
+    }
+
+    if (anim_smile_stage == 1) {
+        smile_laught = t_local(1, 0, anim_smile_start_time2, anim_smile_fade_duration, Linear);
+        if (time_local > anim_smile_duration + anim_smile_start_time2) {
+            smile_laught = 0;
+            anim_smile_stage = 2;
+            anim_smile_blink_one = 1;
+            anim_smile_blink_start_time = time_local + duration_const;
+        }
+    }
+
+    float y = 0;
+    if (anim_smile_stage < 2) {
+        y = sinf(time_local * (float) M_PI * 10) * 1.5f * smile_laught;
+    }
+
+    ic_smile_layer.position = xyzMake(ic_pos.x + cloud_scroll_offset, y + ic_pos.y + t_y, 0);
+    mat4x4_layer(ic_matrix, ic_smile_layer, 1, rotation);
+    draw_textured_shape(&ic_smile, ic_matrix, COLOR);
+
+    if (time_local > anim_smile_blink_start_time + .1) {
+
+        float blink_pause = frand(3, 6);
+        if (irand(0, 3) == 0) {
+            blink_pause = .3;
+        }
+        if (anim_smile_blink_one == 1) {
+            blink_pause = frand(3, 6);
+        }
+        anim_smile_blink_start_time = time_local + blink_pause;
+
+        anim_smile_blink_one = 0;
+    }
+
+    int32_t stop_time = 5;
+    float eye_scale = t_local(1, 0, anim_smile_blink_start_time, 0.1f, Sin);
+    ic_smile_eye.params.scale = xyzMake(1, eye_scale, 1);
+    if (time > stop_time) ic_smile_eye.params.scale = xyzMake(1, 1, 1);
+
+    ic_smile_eye.params.position = xyzMake(-7, -4.5f, 0);
+    draw_textured_shape(&ic_smile_eye, ic_matrix, COLOR);
+
+    if (anim_smile_blink_one == 1) ic_smile_eye.params.scale = xyzMake(1, 1, 1);
+    if (time > stop_time) ic_smile_eye.params.scale = xyzMake(1, 1, 1);
+    ic_smile_eye.params.position = xyzMake(7, -4.5f, 0);
+    draw_textured_shape(&ic_smile_eye, ic_matrix, COLOR);
+
+    if (type == 0) {
+        ic_pos = CPointMake(-60 / 2, 110 / 2);
+        if (current_page == 1 && direct == 0) {
+            t_y = 0;
+        } else {
+            t_y = t(beginY, 0, commonDelay + duration_const * .45f * beginTimeK, duration_const, EaseOut);
+
+            float value = 0;
+            float e = 2.71;
+            float arg = MAXf(0, time - (commonDelay + duration_const * .45f * beginTimeK)) * 50;
+
+            value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * .4f;
+
+            t_y -= value * bounce;
+        }
+    } else {
+        ic_pos = CPointMake(72 / 2, -74 / 2);
+        t_y = t(beginY, 0, commonDelay + duration_const * .0f * beginTimeK, duration_const, EaseOut);
+        float value = 0;
+        float e = 2.71;
+        float arg = MAXf(0, time - (commonDelay + duration_const * .0f * beginTimeK)) * 50;
+        value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * .4f;
+        t_y -= value * bounce;
+    }
+    ic_bubble_layer.position = xyzMake(ic_pos.x + cloud_scroll_offset, ic_pos.y + t_y, 0);
+    mat4x4_layer(ic_matrix, ic_bubble_layer, 1, rotation);
+    draw_textured_shape(&ic_bubble, ic_matrix, COLOR);
+
+    scale = 0.7f + 0.2f * bubble_dots_sinf(time * 10);
+    ic_bubble_dot.params.scale = xyzMake(scale, scale, scale);
+    ic_bubble_dot.params.position = xyzMake(0 - 80.5f, -9 / 2.0f, 0);
+    draw_textured_shape(&ic_bubble_dot, ic_matrix, LIGHT_COLOR);
+
+    scale = 0.7f + 0.2f * bubble_dots_sinf((float) -M_PI * 2 / 3 + time * 10);
+    if (anim_bubble_dots_stage == 0) scale = MAXf(.7, scale);
+    ic_bubble_dot.params.scale = xyzMake(scale, scale, scale);
+    ic_bubble_dot.params.position = xyzMake(0, -9 / 2.0f, 0);
+    draw_textured_shape(&ic_bubble_dot, ic_matrix, LIGHT_COLOR);
+
+    scale = 0.7f + 0.2f * bubble_dots_sinf((float) -M_PI * 2 / 3 * 2 + time * 10);
+    if (anim_bubble_dots_stage == 0) scale = MAXf(.7, scale);
+    ic_bubble_dot.params.scale = xyzMake(scale, scale, scale);
+    ic_bubble_dot.params.position = xyzMake(0 + 80.5f, -9 / 2.0f, 0);
+    draw_textured_shape(&ic_bubble_dot, ic_matrix, LIGHT_COLOR);
+
+    if (type == 0) {
+        ic_pos = CPointMake(-88 / 2 - 15, -100 / 2 + 13);
+        if (current_page == 1 && direct == 0) {
+            t_y = 0;
+        } else {
+            t_y = t(beginY, 0, commonDelay + duration_const * .1f * beginTimeK, duration_const, EaseOut);
+            float value = 0;
+            float e = 2.71;
+            float arg = MAXf(0, time - (commonDelay + duration_const * .1f * beginTimeK)) * 50;
+            value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * .4f;
+            t_y -= value * bounce;
+        }
+    } else {
+        ic_pos = CPointMake(+152 / 2 - 17, +66 / 2 + 14);
+
+        t_y = t(beginY, 0, commonDelay + duration_const * 0.35f * beginTimeK, duration_const, EaseOut);
+
+        float value = 0;
+        float e = 2.71;
+        float arg = MAXf(0, time - (commonDelay + duration_const * 0.35f * beginTimeK)) * 50;
+        value = beginY * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg) * 0.4f;
+
+        t_y -= value * bounce;
+    }
+
+    float pencil_x = 0;
+    if (anim_pencil_stage == 0) {
+        ic_pencil_layer.rotation = t_local(0, -5, anim_pencil_start_all_time, duration_const * 0.5f, EaseOut);
+
+        pencil_x = t_local(0, 14, anim_pencil_start_time, 1.5f * 0.85f, Linear);
+        if (time_local > anim_pencil_start_time + 1.5 * 0.85) {
+            anim_pencil_start_time = time_local;
+            anim_pencil_stage = 1;
+        }
+    } else if (anim_pencil_stage == 1) {
+        pencil_x = t_local(14, 0, anim_pencil_start_time, 1.5f * 0.15f, Linear);
+        if (time_local > anim_pencil_start_time + 1.5f * 0.15f) {
+            if (anim_pencil_period == 0) {
+                anim_pencil_start_all_end_time = time_local;
+                anim_pencil_start_time = time_local + duration_const * 1;
+                anim_pencil_stage = 2;
+            } else {
+                anim_pencil_period--;
+                anim_pencil_start_time = time_local;
+                anim_pencil_stage = 0;
+            }
+        }
+    } else if (anim_pencil_stage == 2) {
+        ic_pencil_layer.rotation = t_local(-5, 0, anim_pencil_start_all_end_time, duration_const * 0.5f, EaseOut);
+        if (time_local > anim_pencil_start_time) {
+            anim_pencil_start_all_time = time_local;
+            anim_pencil_start_time = time_local;
+            anim_pencil_stage = 3;
+        }
+    }
+
+    float pencil_v = (anim_pencil_stage < 2) ? sinf((float) (time_local * 2 * M_PI * 4)) * 0.8f : 0;
+    ic_pencil_layer.position = xyzMake(pencil_x + ic_pos.x + cloud_scroll_offset, pencil_v + ic_pos.y + t_y, 0);
+    mat4x4_layer(ic_matrix, ic_pencil_layer, 1, rotation);
+    draw_textured_shape(&ic_pencil, ic_matrix, COLOR);
+}
+
+void draw_safe(int32_t type, float alpha, float screw_alpha) {
+    float screw_distance = 53;
+
+    private_screw.params.alpha = alpha * screw_alpha;
+
+    scale = 1;
+    private_screw.params.scale = xyzMake(scale, scale, 1);
+    private_screw.params.position = xyzMake(-screw_distance, -screw_distance, 0);
+    draw_textured_shape(&private_screw, private_matrix, NORMAL_ONE);
+
+    private_screw.params.scale = xyzMake(scale, scale, 1);
+    private_screw.params.position = xyzMake(screw_distance, -screw_distance, 0);
+    draw_textured_shape(&private_screw, private_matrix, NORMAL_ONE);
+
+    private_screw.params.scale = xyzMake(scale, scale, 1);
+    private_screw.params.position = xyzMake(-screw_distance, screw_distance, 0);
+    draw_textured_shape(&private_screw, private_matrix, NORMAL_ONE);
+
+    private_screw.params.scale = xyzMake(scale, scale, 1);
+    private_screw.params.position = xyzMake(screw_distance, screw_distance, 0);
+    draw_textured_shape(&private_screw, private_matrix, NORMAL_ONE);
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_onDrawFrame(JNIEnv *env, jclass class) {
+    time_local += 0.016f;
+
+    if (current_page != prev_page) {
+        reset_ic();
+        ms0_anim = date;
+        fps_anim = 0;
+        count_anim_fps = 1;
+    }
+
+    float knotDelayStep = 0.075f;
+    if (prev_page != current_page) {
+        for (i = 0; i < 4; i++) {
+            knot_delays[i] = (0.65f + knotDelayStep * i) * duration_const;
+        }
+
+        for (i = 0; i < 10; i++) {
+            int32_t j1 = irand(0, 3);
+            int32_t j2 = irand(0, 3);
+            float temp = knot_delays[j1];
+            knot_delays[j1] = knot_delays[j2];
+            knot_delays[j2] = temp;
+        }
+
+        if (current_page == 2) {
+            ic_pin_layer.rotation = -15;
+            ic_cam_layer.rotation = 15;
+            ic_smile_layer.rotation = -15;
+            ic_bubble_layer.rotation = -15;
+        }
+
+        if (current_page == 5) {
+            ic_pin_layer.rotation = -15;
+            ic_videocam_layer.rotation = -30;
+            ic_cam_layer.rotation = 15;
+            ic_smile_layer.rotation = -15;
+            ic_bubble_layer.rotation = -15;
+        }
+    }
+
+    fps_anim++;
+    if (count_anim_fps == 1 && date - ms0_anim >= duration_const) {
+        count_anim_fps = 0;
+    }
+
+    if (date - ms0 >= 1.0f) {
+        ms0 = date;
+    }
+
+    time = date - date0;
+
+    float private_back_k = .8;
+
+    glClearColor(1, 1, 1, 1);
+    glClear(GL_COLOR_BUFFER_BIT);
+
+
+    if (current_page == 0) {
+        rglNormalDraw();
+
+        telegram_sphere.params.alpha = 1;
+
+        scale = 1;
+
+        float alpha = 1;
+        if (direct == 0) {
+            alpha = t(0, 1, 0, duration_const, Linear);
+
+            fast_body.params.alpha = 1;
+            fast_body.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&fast_body, main_matrix, NORMAL);
+        }
+
+        telegram_sphere.params.alpha = alpha;
+        telegram_sphere.params.scale = xyzMake(scale, scale, 1);
+
+        telegram_plane.params.alpha = 1;
+
+        float tt = MINf(0, (float) (-M_PI * 125. / 180. + time * M_PI * 2 * 1.5));
+
+        float dx = sinf(tt) * 75;
+        float dy = -sinf(tt) * 60;
+
+        telegram_plane.params.position = xyzMake(dx, dy, 0);
+
+        float scale = (cosf(tt) + 1) * 0.5f;
+
+        telegram_plane.params.scale = xyzMake(cosf(tt) * scale, scale, 1);
+
+        if (tt < D2R(125)) {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+        }
+    } else if (current_page == 1) {
+        rglNormalDraw();
+        if (direct == 1) {
+            fast_body.params.scale = xyzMake(1, 1, 1);
+            fast_body.params.alpha = 1;
+            draw_textured_shape(&fast_body, main_matrix, NORMAL);
+        } else {
+            fast_body.params.alpha = t(0, 1, .0, duration_const, Linear);;
+            float scale = t(.95, 1, 0, duration_const, EaseInEaseOut);
+            fast_body.params.scale = xyzMake(scale, scale, 1.0f);
+            draw_textured_shape(&fast_body, main_matrix, NORMAL);
+        }
+    } else if (current_page == 2) {
+        rglNormalDraw();
+        if (direct == 1) {
+            fast_body.params.alpha = t(1.0f, .0, .0, duration_const, Linear);;
+            float scale = t(1, .95, 0, duration_const, EaseInEaseOut);
+            fast_body.params.scale = xyzMake(scale, scale, 1.0f);
+            draw_textured_shape(&fast_body, main_matrix, NORMAL);
+        }
+    } else if (current_page == 4) {
+        if (direct == 1) {
+            privateLayer.rotation = private_scroll_offset + t(-90, 0, 0, duration_const, EaseOut);
+        } else {
+            privateLayer.rotation = private_scroll_offset + t(90, 0, 0, duration_const * private_back_k, EaseOut);
+        }
+        mat4x4_layer(private_matrix, privateLayer, 1.0f, 0);
+    }
+
+    rglMaskDraw();
+    mask1.params.position.z = cloud_extra_mask1.params.position.z = cloud_extra_mask2.params.position.z = cloud_extra_mask3.params.position.z = cloud_extra_mask4.params.position.z = 1;
+
+    if (current_page == 0) {
+        if (direct == 0) {
+            change_rounded_rectangle(&mask1, CSizeMake(r1 * 2, r1 * 2), r1);
+            mask1.params.rotation = 0;
+        }
+    } else if (current_page == 1) {
+        if (direct == 1) {
+            change_rounded_rectangle(&mask1, CSizeMake(r1 * 2, r1 * 2), r1);
+            mask1.params.rotation = 0;
+        } else {
+            float size = t(r2 * 2, r1 * 2, 0, duration_const, EaseInEaseOut);
+            float round = t(30, r1, 0, duration_const, EaseInEaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            free_scroll_offset = 0;
+            mask1.params.rotation = t(180, 0.0f, 0, duration_const, EaseInEaseOut) + free_scroll_offset;
+        }
+    } else if (current_page == 2) {
+        if (direct == 1) {
+            float size = t(r1 * 2, r2 * 2, 0, duration_const, EaseInEaseOut);
+            float round = t(r1, 30, 0, duration_const, EaseInEaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            free_scroll_offset = scroll_offset * 5;
+            mask1.params.rotation = t(0, 180.0f, 0, duration_const, EaseInEaseOut) + free_scroll_offset;
+        } else {
+            free_scroll_offset = scroll_offset * 5;
+            float r = 316 / 4.0f;
+            float size = t_reversed(r2 * 2, r * 2, 0, duration_const, EaseInEaseOut);
+            float round = t_reversed(30, 20, 0, duration_const, EaseInEaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            mask1.params.rotation = t_reversed(180.0f + free_scroll_offset, 180.0f + 90.0f, 0, duration_const, EaseInEaseOut);
+        }
+    } else if (current_page == 3) {
+        if (direct == 1) {
+            float r = 316 / 4.0f;
+            float size = t(r2 * 2, r * 2, 0, duration_const, EaseInEaseOut);
+            float round = t(30, 20, 0, duration_const, EaseInEaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            mask1.params.rotation = t(180.0f + free_scroll_offset, 180.0f + 90.0f, 0, duration_const, EaseInEaseOut);
+        } else {
+            float r = 316 / 4.0f;
+            float size = t_reversed(r * 2, r2 * 2, 0, duration_const, EaseOut);
+            float round = t_reversed(20, 30, 0, duration_const, EaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            mask1.params.rotation = t_reversed(180.0f + 90.0f, 180.0f + 90.0f + 90.0f, 0, duration_const, EaseOut);
+            mask1.params.position = xyzMake(0, 0, mask1.params.position.z);
+        }
+    } else if (current_page == 4) {
+        if (direct == 1) {
+            float r = 316 / 4.0f;
+            float size = t(r * 2, r2 * 2, 0, duration_const, EaseOut);
+            float round = t(20, 30, 0, duration_const, EaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(size, size), round);
+            mask1.params.rotation = private_scroll_offset + t(180.0f + 90.0f, 180.0f + 90.0f + 90.0f, 0, duration_const, EaseOut);
+            mask1.params.position = xyzMake(0, 0, mask1.params.position.z);
+        } else {
+            float k = 0;
+            k = 1.0f * private_back_k;
+            float scale = t_reversed(r2 * 2, 100, 0, duration_const * k, EaseOut);
+            change_rounded_rectangle(&mask1, CSizeMake(scale, scale), t_reversed(30, 50, 0, duration_const * k, EaseOut));
+            mask1.params.position = xyzMake(t_reversed(0, 29 / 2, 0, duration_const * k, EaseOut), t_reversed(0, -19 / 2, 0, duration_const * k, EaseOut), mask1.params.position.z);
+            mask1.params.rotation = private_scroll_offset + t_reversed(180.0f + 90.0f + 90.0f, 180.0f + 90.0f + 90.0f + 90.0f, 0, duration_const * k, EaseOut);
+
+            k = 1.0f * private_back_k;
+            int32_t sublayer2_radius = 33;
+            cloud_extra_mask1.params.position = xyzMake(t_reversed(0, -122 / 2, 0, duration_const * k, EaseOut), t_reversed(0, 54 / 2 - 1, 0, duration_const * k, EaseOut), cloud_extra_mask1.params.position.z);
+            scale = t_reversed(0, sublayer2_radius, 0, duration_const * k, EaseOut);
+            cloud_extra_mask1.params.scale = xyzMake(scale, scale, 1);
+            draw_shape(&cloud_extra_mask1, main_matrix);
+
+            k = 1.15f * private_back_k;
+            int32_t sublayer3_radius = 94 / 4;
+            cloud_extra_mask2.params.position = xyzMake(t_reversed(0, -84 / 2, 0, duration_const * k, EaseOut), t_reversed(0, -29 / 2, 0, duration_const * k, EaseOut), cloud_extra_mask2.params.position.z);
+            scale = t_reversed(0, sublayer3_radius, 0, duration_const * k, EaseOut);
+            cloud_extra_mask2.params.scale = xyzMake(scale, scale, 1);
+            draw_shape(&cloud_extra_mask2, main_matrix);
+
+            k = 1.3f * private_back_k;
+            int32_t sublayer4_radius = 124 / 4;
+            cloud_extra_mask3.params.position = xyzMake(t_reversed(0, 128 / 2, 0, duration_const * k, EaseOut), t_reversed(0, 56 / 2, 0, duration_const * k, EaseOut), cloud_extra_mask3.params.position.z);
+            scale = t_reversed(0, sublayer4_radius, 0, duration_const * k, EaseOut);
+            cloud_extra_mask3.params.scale = xyzMake(scale, scale, 1);
+            draw_shape(&cloud_extra_mask3, main_matrix);
+
+            k = 1.5f * private_back_k;
+            int32_t sublayer5_radius = 64;
+            cloud_extra_mask4.params.position = xyzMake(t_reversed(0, 0, 0, duration_const * k, EaseOut), t_reversed(0, 50, 0, duration_const * k, EaseOut), cloud_extra_mask4.params.position.z);
+            scale = t_reversed(0, sublayer5_radius, 0, duration_const * k, EaseOut);
+            cloud_extra_mask4.params.scale = xyzMake(scale, scale, 1);
+            draw_shape(&cloud_extra_mask4, main_matrix);
+        }
+    } else if (current_page == 5) {
+        float k = 0.8f;
+        float scale = t(r2 * 2, 100, 0, duration_const * k, EaseOut);
+        change_rounded_rectangle(&mask1, CSizeMake(scale, scale), t(30, 50, 0, duration_const * k, EaseOut));
+        mask1.params.position = xyzMake(t(0, 29 / 2, 0, duration_const * k, EaseOut), t(0, -19 / 2, 0, duration_const * k, EaseOut), mask1.params.position.z);
+        mask1.params.rotation = t(180.0f + 90.0f + 90.0f, 180.0f + 90.0f + 90.0f + 90.0f, 0, duration_const * k, EaseOut);
+
+        k = 1.0f;
+        int32_t sublayer2_radius = 33;
+        cloud_extra_mask1.params.position = xyzMake(t(0, -122 / 2, 0, duration_const * k, EaseOut), t(0, 54 / 2 - 1, 0, duration_const * k, EaseOut), cloud_extra_mask1.params.position.z);
+        scale = t(0, sublayer2_radius, 0, duration_const * k, EaseOut);
+        cloud_extra_mask1.params.scale = xyzMake(scale, scale, 1);
+        draw_shape(&cloud_extra_mask1, main_matrix);
+
+
+        k = 1.15;
+        int32_t sublayer3_radius = 94 / 4;
+        cloud_extra_mask2.params.position = xyzMake(t(0, -84 / 2, 0, duration_const * k, EaseOut), t(0, -29 / 2, 0, duration_const * k, EaseOut), cloud_extra_mask2.params.position.z);
+        scale = t(0, sublayer3_radius, 0, duration_const * k, EaseOut);
+        cloud_extra_mask2.params.scale = xyzMake(scale, scale, 1);
+        draw_shape(&cloud_extra_mask2, main_matrix);
+
+
+        k = 1.3;
+        int32_t sublayer4_radius = 124 / 4;
+        cloud_extra_mask3.params.position = xyzMake(t(0, 128 / 2, 0, duration_const * k, EaseOut), t(0, 56 / 2, 0, duration_const * k, EaseOut), cloud_extra_mask3.params.position.z);
+        scale = t(0, sublayer4_radius, 0, duration_const * k, EaseOut);
+        cloud_extra_mask3.params.scale = xyzMake(scale, scale, 1);
+        draw_shape(&cloud_extra_mask3, main_matrix);
+
+
+        k = 1.5f;
+        int32_t sublayer5_radius = 64;
+        cloud_extra_mask4.params.position = xyzMake(t(0, 0, 0, duration_const * k, EaseOut), t(0, 50, 0, duration_const * k, EaseOut), cloud_extra_mask4.params.position.z);
+        scale = t(0, sublayer5_radius, 0, duration_const * k, EaseOut);
+        cloud_extra_mask4.params.scale = xyzMake(scale, scale, 1);
+        draw_shape(&cloud_extra_mask4, main_matrix);
+
+    }
+    draw_shape(&mask1, main_matrix);
+
+    int32_t rr = 30;
+    int32_t seg = 15;
+    int32_t ang = 180;
+    rglNormalDrawThroughMask();
+    if (current_page == 0) {
+        if (direct == 0) {
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+            change_segmented_square(&spiral, r1, D2R(rr + seg), D2R(speedometer_scroll_offset + calculated_speedometer_sin + t(-seg + ang, 0, 0, duration_const, EaseOut)));
+
+            spiral.params.scale = xyzMake(1, 1, 1);
+            spiral.params.rotation = t(180.0f, 0, 0, duration_const, EaseOut);
+            spiral.params.alpha = t(1, 0, 0, duration_const, Linear);
+            draw_textured_shape(&spiral, main_matrix, NORMAL_ONE);
+
+            fast_arrow.params.alpha = fast_arrow_shadow.params.alpha = t(1, 0, 0, duration_const, Linear);
+            fast_arrow.params.rotation = fast_arrow_shadow.params.rotation = t(rr, rr - 180 - 160, 0, duration_const, EaseOut) + speedometer_scroll_offset + calculated_speedometer_sin;
+            draw_textured_shape(&fast_arrow_shadow, main_matrix, NORMAL_ONE);
+            draw_textured_shape(&fast_arrow, main_matrix, NORMAL_ONE);
+        }
+    } else if (current_page == 1) {
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+        speedometer_scroll_offset = scroll_offset * 25;
+        calculated_speedometer_sin = 0;
+
+        if (direct == 1) {
+
+            float value = 0;
+            float e = 2.71;
+
+            float arg = time * 50;
+
+            value = 180 - 180 * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg * 3);
+
+            float ta = t(0, 180.0f, 0, duration_const, EaseOut);
+
+            change_segmented_square(&spiral, r1, D2R(rr + seg), D2R(-seg + value + speedometer_scroll_offset));
+
+            spiral.params.scale = xyzMake(1, 1, 1);
+            spiral.params.rotation = ta;
+            spiral.params.alpha = t(0, 1, 0, duration_const, Linear);
+            draw_textured_shape(&spiral, main_matrix, NORMAL_ONE);
+
+            fast_arrow.params.alpha = fast_arrow_shadow.params.alpha = t(0, 1, 0, duration_const, Linear);
+            fast_arrow.params.rotation = fast_arrow_shadow.params.rotation = -330 + value + ta + speedometer_scroll_offset;
+            draw_textured_shape(&fast_arrow_shadow, main_matrix, NORMAL_ONE);
+            draw_textured_shape(&fast_arrow, main_matrix, NORMAL_ONE);
+
+        } else {
+            spiral.params.alpha = fast_arrow.params.alpha = fast_arrow_shadow.params.alpha = 1;
+
+            float value = 0;
+            float e = 2.71;
+
+            float arg = time * 50;
+
+            float dangle = 90;
+            value = 180 - 90 - (180 - 90) * powf(e, -0.055f * arg * 2) * cosf(0.08f * arg * 3);
+            value *= -1;
+
+            change_segmented_square(&spiral, r1, D2R(rr + seg), D2R(speedometer_scroll_offset + value + calculated_speedometer_sin + t(360, 360 - dangle - seg, 0, duration_const, EaseInEaseOut)));
+
+            float scale = t(1.18, 1, 0, duration_const, EaseInEaseOut);
+            spiral.params.scale = xyzMake(scale, scale, 1);
+            spiral.params.rotation = t(360, 180, 0, duration_const, EaseInEaseOut);
+            draw_textured_shape(&spiral, main_matrix, NORMAL);
+
+            fast_arrow.params.rotation = fast_arrow_shadow.params.rotation = speedometer_scroll_offset + value + calculated_speedometer_sin + t(rr + 360 + 6, rr + 360 - 180 - dangle, 0, duration_const, EaseInEaseOut);
+            draw_textured_shape(&fast_arrow_shadow, main_matrix, NORMAL);
+            draw_textured_shape(&fast_arrow, main_matrix, NORMAL);
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            free_bg.params.alpha = t(1, 0, 0, duration_const, Linear);
+            draw_shape(&free_bg, main_matrix);
+
+            draw_ic(0);
+        }
+    } else if (current_page == 2) {
+
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+        if (direct == 1) {
+            spiral.params.alpha = fast_arrow.params.alpha = fast_arrow_shadow.params.alpha = 1;
+
+            change_segmented_square(&spiral, r1, D2R(rr + seg + speedometer_scroll_offset), D2R(t(-seg + ang, 360, 0, duration_const, EaseInEaseOut)));
+
+            float scale = t(1, 1.18, 0, duration_const, EaseInEaseOut);
+            spiral.params.scale = xyzMake(scale, scale, 1);
+            spiral.params.rotation = t(180, 360, 0, duration_const, EaseInEaseOut);
+            draw_textured_shape(&spiral, main_matrix, NORMAL);
+
+            fast_arrow.params.rotation = fast_arrow_shadow.params.rotation = speedometer_scroll_offset + t(rr, rr + 360 + 6, 0, duration_const, EaseInEaseOut);
+            draw_textured_shape(&fast_arrow_shadow, main_matrix, NORMAL);
+            draw_textured_shape(&fast_arrow, main_matrix, NORMAL);
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            free_bg.params.alpha = t(0, 1, 0, duration_const, Linear);
+            draw_shape(&free_bg, main_matrix);
+
+            draw_ic(0);
+        } else {
+            glDisable(GL_BLEND);
+            free_bg.params.alpha = 1;
+            draw_shape(&free_bg, main_matrix);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            draw_ic(0);
+
+            powerful_bg.params.alpha = t_reversed(0, 1, 0, duration_const, Linear);
+            draw_shape(&powerful_bg, main_matrix);
+        }
+        ribbon1.params.rotation = 0;
+        ribbon2.params.rotation = 90;
+        ribbon3.params.rotation = 180;
+        ribbon4.params.rotation = 270;
+    } else if (current_page == 3) {
+        if (direct == 1) {
+            glDisable(GL_BLEND);
+            free_bg.params.alpha = 1;
+            draw_shape(&free_bg, main_matrix);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            powerful_bg.params.alpha = t(0, 1, 0, duration_const, Linear);
+            draw_shape(&powerful_bg, main_matrix);
+
+            draw_stars();
+
+        } else {
+            glDisable(GL_BLEND);
+            private_bg.params.alpha = 1;
+            draw_shape(&private_bg, main_matrix);
+
+            float a = t(0, 1.0f, 0, duration_const, EaseOut);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            powerful_bg.params.rotation = 0;
+            powerful_bg.params.alpha = a;
+            draw_shape(&powerful_bg, main_matrix);
+
+            draw_stars();
+        }
+    } else if (current_page == 4) {
+        if (direct == 1) {
+
+            glDisable(GL_BLEND);
+            powerful_bg.params.alpha = 1;
+            draw_shape(&powerful_bg, main_matrix);
+
+            float a = t(0, 1.0f, 0, duration_const, EaseOut);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            private_bg.params.rotation = t(45, 0, 0, duration_const, EaseOut);
+            private_bg.params.alpha = a;
+            draw_shape(&private_bg, main_matrix);
+
+        } else {
+            glDisable(GL_BLEND);
+            cloud_bg.params.alpha = 1;
+            draw_shape(&cloud_bg, main_matrix);
+
+            float a = t(0, 1.0f, 0, duration_const * private_back_k, EaseOut);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            private_bg.params.alpha = a;
+            draw_shape(&private_bg, main_matrix);
+        }
+    } else if (current_page == 5) {
+        glDisable(GL_BLEND);
+        private_bg.params.alpha = 1.0f;
+        draw_shape(&private_bg, main_matrix);
+        float a = t(0, 1.0f, 0, duration_const, EaseOut);
+
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        cloud_bg.params.alpha = a;
+        draw_shape(&cloud_bg, main_matrix);
+        if (scroll_offset > 0) {
+            cloud_scroll_offset = -scroll_offset * 40;
+        } else {
+            cloud_scroll_offset = -scroll_offset * 15;
+        }
+        draw_ic(1);
+    }
+
+    if (current_page == 0) {
+        rglNormalDraw();
+        if (direct == 0) {
+            telegram_sphere.params.alpha = t(0, 1, 0, duration_const * 0.8f, Linear);
+            scale = 1;
+
+            telegram_sphere.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&telegram_sphere, main_matrix, NORMAL);
+
+            float tt = MINf(0, (float) (-M_PI * 125.0f / 180.0f + time * M_PI * 2 * 1.5f));
+            float dx = sinf(tt) * 75;
+            float dy = -sinf(tt) * 60;
+            telegram_plane.params.position = xyzMake(dx, dy, 0);
+            float scale = (cosf(tt) + 1) * 0.5f;
+            telegram_plane.params.scale = xyzMake(cosf(tt) * scale, scale, 1);
+
+            if (tt < D2R(125)) {
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+                draw_textured_shape(&telegram_plane, main_matrix, NORMAL_ONE);
+            }
+        }
+    } else if (current_page == 1) {
+        rglNormalDraw();
+        if (direct == 1) {
+            telegram_sphere.params.alpha = t(1, 0, 0, duration_const, Linear);
+            draw_textured_shape(&telegram_sphere, main_matrix, NORMAL);
+
+            double tt = time * M_PI * 2 * 1.5f;
+
+            float dx = (float) sin(tt) * 75;
+            float dy = (float) -sin(tt) * 60;
+
+            telegram_plane.params.position = xyzMake(dx, dy, 0);
+
+            float scale = (float) (cos(tt) + 1) * 0.5f;
+
+            telegram_plane.params.scale = xyzMake((float) cos(tt) * scale, scale, 1);
+
+            if (tt < D2R(125)) {
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+                draw_textured_shape(&telegram_plane, main_matrix, NORMAL_ONE);
+            }
+        }
+    } else if (current_page == 2) {
+        rglNormalDraw();
+
+        float dribbon = 87;
+
+        if (direct == 1) {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+            ribbonLayer.rotation = scroll_offset * 5 + t(180, 360, 0, duration_const, EaseInEaseOut);
+            mat4x4_layer(ribbons_layer, ribbonLayer, 1.0f, 0);
+
+            float scale;
+            float dur = duration_const * 0.5f;
+
+            free_knot1.params.position = xyzMake(5, -5 - 9, 0);
+            scale = t(0, 1, knot_delays[0], dur, EaseOut);
+            free_knot1.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&free_knot1, ribbons_layer, NORMAL_ONE);
+
+            free_knot2.params.position = xyzMake(-5, -5 - 9, 0);
+            scale = t(0, 1, knot_delays[1], dur, EaseOut);
+            free_knot2.params.scale = xyzMake(-scale, scale, 1);
+            draw_textured_shape(&free_knot2, ribbons_layer, NORMAL_ONE);
+
+            free_knot3.params.position = xyzMake(-5, 5 - 9, 0);
+            scale = t(0, 1, knot_delays[2], dur, EaseOut);
+            free_knot3.params.scale = xyzMake(-scale, scale, 1);
+            draw_textured_shape(&free_knot3, ribbons_layer, NORMAL_ONE);
+
+            free_knot3.params.position = xyzMake(5, 5 - 9, 0);
+            scale = t(0, 1, knot_delays[3], dur, EaseOut);
+            free_knot3.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&free_knot3, ribbons_layer, NORMAL_ONE);
+
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            ribbon1.params.alpha = ribbon2.params.alpha = ribbon3.params.alpha = ribbon4.params.alpha = t(0, 1, 0, dur, EaseInEaseOut);
+
+            int32_t ribbon_k = time > duration_const ? 1 : 0;
+
+            change_ribbon(&ribbon1, ribbonLength - 8.0f * ribbon_k - free_scroll_offset / 5.0f * (30 - 8 * ribbon_k));
+            ribbon1.params.position.x = scroll_offset * 30 * 0 + t(-dribbon, 0, 0, duration_const, EaseInEaseOut);
+            draw_shape(&ribbon1, ribbons_layer);
+
+            change_ribbon(&ribbon2, ribbonLength - 10.0f * ribbon_k - free_scroll_offset / 5.0f * (22 - 10 * ribbon_k));
+            ribbon2.params.position.y = scroll_offset * 15 + t(-9 - dribbon, -9, 0, duration_const, EaseInEaseOut);
+            draw_shape(&ribbon2, ribbons_layer);
+
+            ribbon3.params.position.x = t(dribbon, 0, 0, duration_const, EaseInEaseOut);;
+            draw_shape(&ribbon3, ribbons_layer);
+
+            ribbon4.params.position.y = t(-9 + dribbon, -9, 0, duration_const, EaseInEaseOut);;
+            draw_shape(&ribbon4, ribbons_layer);
+
+            ribbonLayer.anchor.y = 0;
+            ribbonLayer.position.y = 0;
+
+            change_ribbon(&ribbon1, ribbonLength);
+            change_ribbon(&ribbon2, ribbonLength);
+            change_ribbon(&ribbon3, ribbonLength);
+            change_ribbon(&ribbon4, ribbonLength);
+        } else {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+            float scale = t(1, 2, 0, duration_const, EaseIn);
+            powerful_mask.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&powerful_mask, main_matrix, NORMAL_ONE);
+
+
+            ribbonLayer.rotation = free_scroll_offset + t_reversed(360, 360 + (45 + 30), 0, duration_const, EaseOut);
+            ribbonLayer.position.y = t_reversed(0, -8, 0, duration_const * 0.8f, EaseOut);
+            ribbonLayer.anchor.y = t_reversed(0, -9, 0, duration_const * 0.8f, EaseOut);
+            mat4x4_layer(ribbons_layer, ribbonLayer, 1.0f, 0);
+
+
+            float dur = duration_const * 0.5f;
+
+            free_knot1.params.position = xyzMake(11 / 2, -11 / 2 - 9, 0);
+            scale = t(0, 1, knot_delays[0], dur, EaseOut);
+            free_knot1.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&free_knot1, ribbons_layer, NORMAL_ONE);
+
+            free_knot2.params.position = xyzMake(-11 / 2, -11 / 2 - 9, 0);
+            scale = t(0, 1, knot_delays[1], dur, EaseOut);
+            free_knot2.params.scale = xyzMake(-scale, scale, 1);
+            draw_textured_shape(&free_knot2, ribbons_layer, NORMAL_ONE);
+
+            free_knot3.params.position = xyzMake(-11 / 2, 11 / 2 - 9, 0);
+            scale = t(0, 1, knot_delays[2], dur, EaseOut);
+            free_knot3.params.scale = xyzMake(-scale, scale, 1);
+            draw_textured_shape(&free_knot3, ribbons_layer, NORMAL_ONE);
+
+            free_knot3.params.position = xyzMake(11 / 2, 11 / 2 - 9, 0);
+            scale = t(0, 1, knot_delays[3], dur, EaseOut);
+            free_knot3.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&free_knot3, ribbons_layer, NORMAL_ONE);
+
+            float a1 = -25;
+            ribbon1.params.rotation = t_reversed(0, a1, 0, duration_const, EaseOut);
+            ribbon3.params.rotation = t_reversed(180, 180 + a1, 0, duration_const, EaseOut);
+
+            float a2 = 0;
+            ribbon2.params.rotation = t_reversed(90, 90 + a2, 0, duration_const, EaseOut);
+            ribbon4.params.rotation = t_reversed(270, 270 + a2, 0, duration_const, EaseOut);
+
+            float k = 0.9f;
+            ribbon2.params.alpha = ribbon4.params.alpha = t_reversed(1, 0, duration_const * 0.5f, duration_const * 0.1f, Linear);
+
+            int32_t ribbon_k = 0;
+            change_ribbon(&ribbon1, t_reversed(ribbonLength - 8.0f * ribbon_k, 0, 0, duration_const * 0.9f, Linear) - free_scroll_offset / 5.0f * (30 - 8 * ribbon_k));
+            ribbon1.params.position.x = 0;
+            draw_shape(&ribbon1, ribbons_layer);
+
+            change_ribbon(&ribbon2, t_reversed(ribbonLength - 10.0f * ribbon_k, 0, 0, duration_const * k, Linear) - free_scroll_offset / 5.0f * (22 - 10 * ribbon_k));
+            ribbon2.params.position.y = scroll_offset * 15 + -9;
+            draw_shape(&ribbon2, ribbons_layer);
+
+            change_ribbon(&ribbon3, t_reversed(ribbonLength, 0, 0, duration_const * 0.9f, Linear));
+            draw_shape(&ribbon3, ribbons_layer);
+
+            change_ribbon(&ribbon4, t_reversed(ribbonLength, 0, duration_const * 0.6f * 0, duration_const * k, Linear));
+            draw_shape(&ribbon4, ribbons_layer);
+
+            float infinityDurK = 1.3;
+
+            rglMaskDraw();
+
+            change_infinity(&infinity, t_reversed(0, 0.99, 0, duration_const * infinityDurK, EaseOut));
+
+            float rot1 = t(0, -50, duration_const * 0.5f, duration_const * 0.8f, EaseOut);
+            float rot2 = t(0, -30, duration_const * 0.8f, duration_const, EaseOut);
+            infinity.params.rotation = rot1;
+
+            infinity.params.position.z = 1;
+            infinity.params.position.y = -6;
+            infinity.params.anchor = xyzMake(52.75, 23.5f, 0);
+
+            float infinity_scale = 1.025;
+            infinity.params.scale = xyzMake(infinity_scale, infinity_scale, 1);
+            draw_shape(&infinity, main_matrix);
+            infinity.params.scale = xyzMake(-infinity_scale, -infinity_scale, 1);
+            draw_shape(&infinity, main_matrix);
+            rglNormalDrawThroughMask();
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            powerful_infinity_white.params.rotation = rot1 + rot2;
+            powerful_infinity_white.params.alpha = 1;
+            powerful_infinity_white.params.position.y = -6;
+            draw_textured_shape(&powerful_infinity_white, main_matrix, NORMAL_ONE);
+        }
+    } else if (current_page == 3) {
+        if (direct == 1) {
+            ribbon1.params.position.x = 0;
+            ribbon2.params.position.y = -9;
+            ribbon3.params.position.x = 0;
+            ribbon4.params.position.y = -9;
+            rglNormalDraw();
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            float scale = t(2, 1, 0, duration_const, EaseOut);
+            powerful_mask.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&powerful_mask, main_matrix, NORMAL_ONE);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            ribbonLayer.rotation = free_scroll_offset + t(360, 360 + (45 + 30), 0, duration_const * 0.8f, EaseOut);
+            ribbonLayer.position.y = t(0, -8, 0, duration_const * 0.8f, EaseOut);
+            ribbonLayer.anchor.y = t(0, -9, 0, duration_const * 0.8f, EaseOut);
+            mat4x4_layer(ribbons_layer, ribbonLayer, 1.0f, 0);
+
+            float a1 = -25;
+            ribbon1.params.rotation = t(0, a1, 0, duration_const, EaseOut);
+            ribbon3.params.rotation = t(180, 180 + a1, 0, duration_const, EaseOut);
+
+            float a2 = 0;
+            ribbon2.params.rotation = t(90, 90 + a2, 0, duration_const, EaseOut);
+            ribbon4.params.rotation = t(270, 270 + a2, 0, duration_const, EaseOut);
+
+            float k = 0.5f;
+            ribbon2.params.alpha = ribbon4.params.alpha = t(1, 0, duration_const * k * 0.5f, duration_const * k * 0.1f, Linear);
+
+            int32_t ribbon_k = time > duration_const ? 1 : 0;
+
+            change_ribbon(&ribbon1, t(ribbonLength - 8.0f * ribbon_k - free_scroll_offset / 5.0f * (30 - 8 * ribbon_k), 0, 0, duration_const * 0.9f, Linear));
+            draw_shape(&ribbon1, ribbons_layer);
+
+            change_ribbon(&ribbon2, t(ribbonLength - 10.0f * ribbon_k - free_scroll_offset / 5.0f * (22 - 10 * ribbon_k), 0, 0, duration_const * k, Linear));
+            draw_shape(&ribbon2, ribbons_layer);
+
+            change_ribbon(&ribbon3, t(ribbonLength, 0, 0, duration_const * 0.9f, Linear));
+            draw_shape(&ribbon3, ribbons_layer);
+
+            change_ribbon(&ribbon4, t(ribbonLength, 0, 0, duration_const * k, Linear));
+            draw_shape(&ribbon4, ribbons_layer);
+
+            float infinityDurK = 1.1f;
+            if (time < duration_const * infinityDurK - 0.025f) {
+                rglMaskDraw();
+
+                change_infinity(&infinity, t(0, 0.99f, 0, duration_const * infinityDurK, Linear));
+
+                infinity.params.rotation = 0;
+
+                infinity.params.position.z = 1;
+                infinity.params.position.y = -6;
+                infinity.params.anchor = xyzMake(52.75, 23.5f, 0);
+
+                float infinity_scale = 1.025f;
+                infinity.params.scale = xyzMake(infinity_scale, infinity_scale, 1);
+                draw_shape(&infinity, main_matrix);
+
+                infinity.params.scale = xyzMake(-infinity_scale, -infinity_scale, 1);
+                draw_shape(&infinity, main_matrix);
+
+                rglNormalDrawThroughMask();
+                glEnable(GL_BLEND);
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+                powerful_infinity_white.params.rotation = 0;
+                powerful_infinity_white.params.alpha = 1;
+                powerful_infinity_white.params.position.y = -6;
+
+                draw_textured_shape(&powerful_infinity_white, main_matrix, NORMAL_ONE);
+            } else {
+                rglNormalDraw();
+
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+                powerful_infinity.params.position.y = -6;
+                powerful_infinity.params.alpha = 1;
+                draw_textured_shape(&powerful_infinity, main_matrix, NORMAL_ONE);
+            }
+        } else {
+            rglNormalDraw();
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+            float scale = t(2, 1, 0, duration_const, EaseOut);
+            powerful_mask.params.scale = xyzMake(scale, scale, 1);
+            draw_textured_shape(&powerful_mask, main_matrix, NORMAL_ONE);
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            scale = t(1, 2, 0, duration_const, EaseOut);
+            private_stroke.params.scale = xyzMake(scale, scale, 1);
+            private_stroke.params.rotation = t(0, -90, 0, duration_const, EaseOut);
+            private_stroke.params.alpha = t(1, 0, 0, duration_const, Linear);
+            private_stroke.params.position = xyzMake(0, t(0, -6, 0, duration_const, EaseOut), 0);
+            scale = t_reversed(63 * 2.0f, 63 * 2, 0, duration_const, EaseOut);
+            change_rounded_rectangle_stroked(&private_stroke, CSizeMake(scale, scale), scale / 2.0f);
+            draw_shape(&private_stroke, main_matrix);
+
+            float infinityDurK = 1.1;
+            if (time < duration_const * infinityDurK - 0.025f) {
+                rglMaskDraw();
+
+                change_infinity(&infinity, t(0, 0.99, 0, duration_const * infinityDurK, Linear));
+
+                infinity.params.rotation = 0;
+
+                infinity.params.position.z = 1;
+                infinity.params.position.y = -6;
+                infinity.params.anchor = xyzMake(52.75, 23.5f, 0);
+
+                float infinity_scale = 1.025;
+                infinity.params.scale = xyzMake(infinity_scale, infinity_scale, 1);
+                draw_shape(&infinity, main_matrix);
+
+                infinity.params.scale = xyzMake(-infinity_scale, -infinity_scale, 1);
+                draw_shape(&infinity, main_matrix);
+
+
+                rglNormalDrawThroughMask();
+                glEnable(GL_BLEND);
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+                powerful_infinity_white.params.rotation = 0;
+                powerful_infinity_white.params.alpha = 1;
+                powerful_infinity_white.params.position.y = -6;
+
+                draw_textured_shape(&powerful_infinity_white, main_matrix, NORMAL_ONE);
+            } else {
+                rglNormalDraw();
+
+                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+                powerful_infinity.params.position.y = -6;
+                powerful_infinity.params.alpha = 1;
+                draw_textured_shape(&powerful_infinity, main_matrix, NORMAL_ONE);
+            }
+        }
+    } else if (current_page == 4) {
+        private_stroke.params.scale = xyzMake(1, 1, 1);
+
+        private_scroll_offset = scroll_offset * 5;
+
+        rglNormalDraw();
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+        scale = t(1, 2, 0, duration_const, EaseOut);
+        if (scale < 1.5) {
+            powerful_mask.params.scale = xyzMake(scale, scale, 1);
+        }
+
+        if (direct == 1) {
+            privateLayer.rotation = private_scroll_offset + t(-90, 0, 0, duration_const, EaseOut);
+        } else {
+            privateLayer.rotation = private_scroll_offset + t(90, 0, 0, duration_const * private_back_k, EaseOut);
+        }
+
+        mat4x4_layer(private_matrix, privateLayer, 1, 0);
+
+        if (direct == 1) {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            powerful_infinity.params.position.y = -6;
+            powerful_infinity.params.alpha = t(1, 0, 0, duration_const * 0.25f, EaseIn);
+            draw_textured_shape(&powerful_infinity, main_matrix, NORMAL_ONE);
+        }
+
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+        if (direct == 1) {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            scale = t(0.5f, 1.0f, 0, duration_const, EaseOut);
+            private_door.params.scale = xyzMake(scale, scale, 1);
+            private_door.params.alpha = t(.0, 1.0f, 0, duration_const, EaseOut);
+            draw_textured_shape(&private_door, main_matrix, NORMAL_ONE);
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            private_stroke.params.rotation = private_scroll_offset;
+            private_stroke.params.alpha = 1;
+            private_stroke.params.position = xyzMake(0, 0, 0);
+            scale = t(63, 63 * 2, 0, duration_const, EaseOut);
+            change_rounded_rectangle_stroked(&private_stroke, CSizeMake(scale, scale), scale / 2.0f);
+            draw_shape(&private_stroke, main_matrix);
+
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            float k = .0;
+            scale = t(0.5f, 1.0f, duration_const * k, duration_const, EaseOut);
+            private_keyhole_body.params.rotation = private_scroll_offset;
+            private_keyhole_body.params.scale = xyzMake(scale, scale, 1);
+            private_keyhole_body.params.alpha = t(.0, 1.0f, duration_const * k, duration_const, EaseOut);
+            draw_safe(0, 1, t(0, 1, 0, duration_const, Linear));
+        } else {
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            scale = t(0.5f, 1.0f, 0, duration_const * private_back_k, EaseOut);
+            private_door.params.scale = xyzMake(scale, scale, 1);
+            private_door.params.alpha = t(.0, 1.0f, 0, duration_const * private_back_k, EaseOut);
+            draw_textured_shape(&private_door, main_matrix, NORMAL_ONE);
+
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            private_stroke.params.rotation = private_scroll_offset;
+            private_stroke.params.alpha = t(0, 1, 0, duration_const * 0.25f, Linear);
+            private_stroke.params.position = xyzMake(0, 0, 0);
+            scale = t(63, 63 * 2, 0, duration_const * private_back_k, EaseOut);
+            change_rounded_rectangle_stroked(&private_stroke, CSizeMake(scale, scale), scale / 2.0f);
+            draw_shape(&private_stroke, main_matrix);
+
+            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            scale = t(00.5f, 1.0, 0, duration_const * private_back_k, EaseOut);
+            private_keyhole_body.params.rotation = private_scroll_offset;
+            private_keyhole_body.params.scale = xyzMake(scale, scale, 1);
+            private_keyhole_body.params.alpha = t(.0, 1.0f, 0, duration_const * private_back_k, EaseOut);
+
+            if (time < duration_const * .4) {
+                cloud_cover.params.position.y = t_reversed(118 / 2 + 50, 118 / 2, duration_const * 0.8f * private_back_k, duration_const * private_back_k, EaseOut);
+                draw_shape(&cloud_cover, main_matrix);
+            }
+
+            draw_safe(0, t(0, 1, duration_const * private_back_k * 0.0f, duration_const * private_back_k, Linear), t(0, 1, 0, duration_const, Linear));
+        }
+    } else if (current_page == 5) {
+        float private_fade_k = 0.5f;
+
+        rglNormalDraw();
+
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+        scale = 1;
+        private_door.params.scale = xyzMake(scale, scale, 1);
+        private_door.params.alpha = t(1, 0, 0, duration_const * private_fade_k * 0.5f, EaseOut);
+        draw_textured_shape(&private_door, main_matrix, NORMAL_ONE);
+
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        private_stroke.params.rotation = private_scroll_offset;
+        private_stroke.params.alpha = t(1, 0, 0, duration_const * private_fade_k * 0.5f, EaseOut);
+        scale = t(244 / 2, r2 * 2, 0, duration_const, EaseOut);
+        change_rounded_rectangle_stroked(&private_stroke, CSizeMake(scale, scale), scale / 2.0f);
+        draw_shape(&private_stroke, main_matrix);
+
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+        scale = 1;
+        private_keyhole_body.params.rotation = private_scroll_offset;
+        private_keyhole_body.params.scale = xyzMake(scale, scale, 1);
+        private_keyhole_body.params.alpha = t(1.0, 0.0, 0, duration_const * private_fade_k * 0.5f, EaseOut);
+        privateLayer.rotation = private_scroll_offset;
+        mat4x4_layer(private_matrix, privateLayer, t(1, 0.9f, 0, duration_const * private_fade_k, EaseOut), 0);
+        cloud_cover.params.position.y = t(118 / 2 + 50, 118 / 2, 0, duration_const, EaseOut);
+        draw_shape(&cloud_cover, main_matrix);
+    }
+
+    prev_page = current_page;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setScrollOffset(JNIEnv *env, jclass class, float a_offset) {
+    scroll_offset = a_offset;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setPage(JNIEnv *env, jclass class, int32_t page) {
+    if (current_page == page) {
+        return;
+    } else {
+        prev_page = current_page;
+        current_page = page;
+        direct = current_page > prev_page ? 1 : 0;
+        date0 = date;
+        time = 0;
+    }
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setDate(JNIEnv *env, jclass class, float a) {
+    date = a;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setIcTextures(JNIEnv *env, jclass class, GLuint a_ic_bubble_dot, GLuint a_ic_bubble, GLuint a_ic_cam_lens, GLuint a_ic_cam, GLuint a_ic_pencil, GLuint a_ic_pin, GLuint a_ic_smile_eye, GLuint a_ic_smile, GLuint a_ic_videocam) {
+    ic_bubble_dot_texture = a_ic_bubble_dot;
+    ic_bubble_texture = a_ic_bubble;
+    ic_cam_lens_texture = a_ic_cam_lens;
+    ic_cam_texture = a_ic_cam;
+    ic_pencil_texture = a_ic_pencil;
+    ic_pin_texture = a_ic_pin;
+    ic_smile_eye_texture = a_ic_smile_eye;
+    ic_smile_texture = a_ic_smile;
+    ic_videocam_texture = a_ic_videocam;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setTelegramTextures(JNIEnv *env, jclass class, GLuint a_telegram_sphere, GLuint a_telegram_plane) {
+    telegram_sphere_texture = a_telegram_sphere;
+    telegram_plane_texture = a_telegram_plane;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setFastTextures(JNIEnv *env, jclass class, GLuint a_fast_body, GLuint a_fast_spiral, GLuint a_fast_arrow, GLuint a_fast_arrow_shadow) {
+    fast_spiral_texture = a_fast_spiral;
+    fast_body_texture = a_fast_body;
+    fast_arrow_shadow_texture = a_fast_arrow_shadow;
+    fast_arrow_texture = a_fast_arrow;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setFreeTextures(JNIEnv *env, jclass class, GLuint a_knot_up, GLuint a_knot_down) {
+    free_knot_up_texture = a_knot_up;
+    free_knot_down_texture = a_knot_down;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setPowerfulTextures(JNIEnv *env, jclass class, GLuint a_powerful_mask, GLuint a_powerful_star, GLuint a_powerful_infinity, GLuint a_powerful_infinity_white) {
+    powerful_mask_texture = a_powerful_mask;
+    powerful_star_texture = a_powerful_star;
+    powerful_infinity_texture = a_powerful_infinity;
+    powerful_infinity_white_texture = a_powerful_infinity_white;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_setPrivateTextures(JNIEnv *env, jclass class, GLuint a_private_door, GLuint a_private_screw) {
+    private_door_texture = a_private_door;
+    private_screw_texture = a_private_screw;
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_onSurfaceCreated(JNIEnv *env, jclass class) {
+
+    ms0 = 0;
+    date = 1;
+    date0 = 0;
+    direct = 0;
+    i = 0;
+    current_page = 0;
+    prev_page = 0;
+    time = 0;
+    time_local = 0;
+    offset_y = 0;
+    ribbonLength = 86.5f;
+    starsFar = 500;
+    scroll_offset = 0;
+    calculated_speedometer_sin = 0;
+    ms0_anim = 0;
+    fps_anim = 0;
+    count_anim_fps = 0;
+    speedometer_scroll_offset = 0;
+    free_scroll_offset = 0;
+    private_scroll_offset = 0;
+    anim_pencil_start_time = 0;
+    anim_pencil_start_all_time = 0;
+    anim_pencil_start_all_end_time = 0;
+    anim_pencil_stage = 0;
+    anim_bubble_dots_stage = 0;
+    anim_bubble_dots_end_period = 0;
+    anim_videocam_start_time = 0;
+    anim_videocam_next_time = 0;
+    anim_videocam_duration = 0;
+    anim_videocam_angle = 0;
+    anim_videocam_old_angle = 0;
+    anim_cam_start_time = 0;
+    anim_cam_next_time = 0;
+    anim_cam_duration = 0;
+    anim_cam_angle = 0;
+    anim_cam_old_angle = 0;
+    qShot = 0;
+    anim_camshot_start_time = 0;
+    anim_camshot_duration = 0;
+    anim_smile_start_time1 = 0;
+    anim_smile_start_time2 = 0;
+    anim_smile_blink_start_time = 0;
+    anim_smile_blink_one = 0;
+    anim_smile_stage = 0;
+    scale = 0;
+    anim_pin_start_time = 0;
+    anim_pin_duration = 0;
+    anim_pencil_period = 0;
+    cloud_scroll_offset = 0;
+
+    setup_shaders();
+
+    vec4 start_button_col = {44 / 255.0f, 165 / 255.0f, 224 / 255.0f, 1.0f};
+    start_button = create_rounded_rectangle(CSizeMake(172, 44), 2, 3, start_button_col);
+    start_button.params.anchor.y = -22;
+
+    mask1 = create_rounded_rectangle(CSizeMake(60, 60), 0, 16, black_color);
+
+    telegram_sphere = create_textured_rectangle(CSizeMake(150, 150), telegram_sphere_texture);
+    telegram_plane = create_textured_rectangle(CSizeMake(82, 74), telegram_plane_texture);
+    telegram_plane.params.anchor = xyzMake(6, -5, 0);
+
+    fast_body = create_textured_rectangle(CSizeMake(148, 148), fast_body_texture);
+
+    fast_arrow_shadow = create_textured_rectangle(CSizeMake(164 / 2, 44 / 2), fast_arrow_shadow_texture);
+    fast_arrow_shadow.params.position.x = -1;
+    fast_arrow_shadow.params.position.y = 2;
+
+    fast_arrow = create_textured_rectangle(CSizeMake(164 / 2, 44 / 2), fast_arrow_texture);
+    fast_arrow.params.anchor.x = fast_arrow_shadow.params.anchor.x = -19;
+
+    int32_t ang = 180;
+    spiral = create_segmented_square(r1, D2R(35 + 1), D2R(35 + 1 - 10 + ang), fast_spiral_texture);
+
+    vec4 free_bg_color = {246 / 255.0f, 73 / 255.0f, 55 / 255.0f, 1};
+    free_bg = create_rectangle(CSizeMake(160 * 2, 160 * 2), free_bg_color);
+
+    free_knot1 = create_textured_rectangle(CSizeMake(138 / 3, 138 / 3), free_knot_up_texture);
+    free_knot1.params.anchor.x = -23 + 10;
+    free_knot1.params.anchor.y = 23 - 10;
+
+    free_knot2 = create_textured_rectangle(CSizeMake(138 / 3, 138 / 3), free_knot_up_texture);
+    free_knot2.params.anchor.x = -23 + 10;
+    free_knot2.params.anchor.y = 23 - 10;
+
+    free_knot3 = create_textured_rectangle(CSizeMake(150 / 3, 150 / 3), free_knot_down_texture);
+    free_knot3.params.anchor.x = -100 / 4.0f + 20 / 2.0f;
+    free_knot3.params.anchor.y = -100 / 4.0f + 20 / 2.0f;
+
+    free_knot4 = create_textured_rectangle(CSizeMake(150 / 3, 150 / 3), free_knot_down_texture);
+    free_knot4.params.anchor.x = -100 / 4.0f + 20 / 2.0f;
+    free_knot4.params.anchor.y = -100 / 4.0f + 20 / 2.0f;
+
+
+    ribbonLayer = default_layer_params();
+
+    ribbon1 = create_ribbon(ribbonLength, white_color);
+    ribbon1.params.layer_params = ribbonLayer;
+
+    ribbon2 = create_ribbon(ribbonLength, white_color);
+    ribbon2.params.rotation = 90;
+    ribbon2.params.layer_params = ribbonLayer;
+
+    ribbon3 = create_ribbon(ribbonLength, white_color);
+    ribbon3.params.rotation = 180;
+    ribbon3.params.layer_params = ribbonLayer;
+
+    ribbon4 = create_ribbon(ribbonLength, white_color);
+    ribbon4.params.rotation = 270;
+    ribbon4.params.layer_params = ribbonLayer;
+
+    ribbon1.params.position.y = ribbon2.params.position.y = ribbon3.params.position.y = ribbon4.params.position.y = -9;
+
+
+    ic_bubble_dot = create_textured_rectangle(CSizeMake(18 / 3, 18 / 3), ic_bubble_dot_texture);
+    ic_bubble = create_textured_rectangle(CSizeMake(102 / 3, 102 / 3), ic_bubble_texture);
+    ic_cam_lens = create_textured_rectangle(CSizeMake(36 / 3, 36 / 3), ic_cam_lens_texture);
+    ic_cam = create_textured_rectangle(CSizeMake(108 / 3, 96 / 3), ic_cam_texture);
+    ic_pencil = create_textured_rectangle(CSizeMake(86 / 3, 86 / 3), ic_pencil_texture);
+    ic_pin = create_textured_rectangle(CSizeMake(90 / 3, 120 / 3), ic_pin_texture);
+    ic_smile_eye = create_textured_rectangle(CSizeMake(18 / 3, 18 / 3), ic_smile_eye_texture);
+    ic_smile = create_textured_rectangle(CSizeMake(120 / 3, 120 / 3), ic_smile_texture);
+    ic_videocam = create_textured_rectangle(CSizeMake(144 / 3, 84 / 3), ic_videocam_texture);
+
+    ic_pin_layer = ic_cam_layer = ic_videocam_layer = ic_smile_layer = ic_bubble_layer = ic_pencil_layer = default_layer_params();
+
+    ic_pin_layer.anchor = xyzMake(0, 50 / 2, 0);
+    ic_pencil_layer.anchor = xyzMake(-30 / 2, 30 / 2, 0);
+
+    infinity = create_infinity(11.7, .0, 32, white_color);
+
+    vec4 powerful_bg_color = {47 / 255.f, 90 / 255.f, 131 / 255.f, 1};
+    powerful_bg = create_rectangle(CSizeMake(200, 200), powerful_bg_color);
+    powerful_mask = create_textured_rectangle(CSizeMake(200, 200), powerful_mask_texture);
+
+    powerful_infinity = create_textured_rectangle(CSizeMake(366 / 3, 180 / 3), powerful_infinity_texture);
+    powerful_infinity_white = create_textured_rectangle(CSizeMake(366 / 3, 180 / 3), powerful_infinity_white_texture);
+
+    float star_radius = 5.25;
+    star = create_textured_rectangle(CSizeMake(star_radius, star_radius), powerful_star_texture);
+    star.params.const_params.is_star = 1;
+    for (i = 0; i < starsCount; i++) {
+        stars[i] = default_params();
+        stars[i].position = star_create_position(-(i * 1500.0f) / starsCount);
+    }
+
+    privateLayer = default_layer_params();
+
+    vec4 private_bg_color = {200 / 255.f, 207 / 255.f, 212 / 255.f, 1};
+    private_bg = create_rectangle(CSizeMake(240, 240), private_bg_color);
+
+    private_door = create_textured_rectangle(CSizeMake(408 / 3, 408 / 3), private_door_texture);
+    private_keyhole_body = create_textured_rectangle(CSizeMake(216 / 3, 216 / 3), private_keyhole_body_texture);
+    private_screw = create_textured_rectangle(CSizeMake(30 / 3, 30 / 3), private_screw_texture);
+    private_stroke = create_rounded_rectangle_stroked(CSizeMake(244 / 2, 244 / 2), 21, 9, 16, white_color);
+
+    int32_t cloud_polygons_count = 64;
+    cloud_extra_mask1 = create_circle(1, cloud_polygons_count, black_color);
+    cloud_extra_mask2 = create_circle(1, cloud_polygons_count, black_color);
+    cloud_extra_mask3 = create_circle(1, cloud_polygons_count, black_color);
+    cloud_extra_mask4 = create_circle(1, cloud_polygons_count, black_color);
+
+    cloud_cover = create_rectangle(CSizeMake(240, 100), white_color);
+    cloud_cover.params.anchor.y = -50;
+
+    vec4 cloud_color = {42 / 255.0f, 180 / 255.0f, 247 / 255.0f, 1};
+    cloud_bg = create_rectangle(CSizeMake(160 * 2, 160 * 2), cloud_color);
+}
+
+JNIEXPORT void Java_org_telegram_messenger_Intro_onSurfaceChanged(JNIEnv *env, jclass class, int32_t a_width_px, int32_t a_height_px, float a_scale_factor, int32_t a1) {
+    glViewport(0, 0, a_width_px, a_height_px);
+    width = (int32_t) (a_width_px / a_scale_factor);
+    height = (int32_t) (a_height_px / a_scale_factor);
+    scale_factor = a_scale_factor;
+    mat4x4_plain(main_matrix, (int32_t) ((float) a_width_px / a_scale_factor), (int32_t) ((float) a_height_px / a_scale_factor));
+    offset_y = a1 * main_matrix[1][1];
+    set_y_offset_objects(offset_y);
+    y_offset_absolute = a1;
+    mat4x4_stars(stars_matrix, 45, 1, -1000, 0, (int32_t) ((float) a_width_px / a_scale_factor), (int32_t) ((float) a_height_px / a_scale_factor));
+}
\ No newline at end of file
diff --git a/TMessagesProj/jni/intro/IntroRenderer.h b/TMessagesProj/jni/intro/IntroRenderer.h
new file mode 100644
index 000000000..812f1d35a
--- /dev/null
+++ b/TMessagesProj/jni/intro/IntroRenderer.h
@@ -0,0 +1,113 @@
+#ifndef TMESSAGES_INTRO_RENDERER_H
+#define TMESSAGES_INTRO_RENDERER_H
+
+#include <GLES2/gl2.h>
+
+extern float scale_factor;
+extern int width, height;
+extern int y_offset_absolute;
+
+typedef enum {
+    Default = 0,
+    EaseIn = 1,
+    EaseOut = 2,
+    EaseInEaseOut = 3,
+    Linear = 4,
+    Sin = 5,
+    EaseOutBounce,
+    TIMING_NUM
+} timing_type;
+
+typedef float vec2[2];
+typedef float vec4[4];
+typedef vec4 mat4x4[4];
+
+typedef enum {NORMAL, NORMAL_ONE, RED, BLUE, LIGHT_RED, LIGHT_BLUE} texture_program_type;
+
+typedef struct {
+    float x;
+    float y;
+} CPoint;
+
+typedef struct {
+    float width;
+    float height;
+} CSize;
+
+typedef struct {
+    float x;
+    float y;
+    float z;
+} xyz;
+
+typedef struct {
+    GLuint program;
+    GLuint a_position_location;
+    GLuint a_texture_coordinates_location;
+    GLint u_mvp_matrix_location;
+    GLint u_texture_unit_location;
+    GLint u_alpha_loaction;
+} TextureProgram;
+
+typedef struct {
+    GLuint program;
+    GLuint a_position_location;
+    GLint u_mvp_matrix_location;
+    GLint u_color_location;
+    GLint u_alpha_loaction;
+} ColorProgram;
+
+typedef struct {
+    float side_length;
+    float start_angle;
+    float end_angle;
+    float angle;
+    CSize size;
+    float radius;
+    float width;
+} VarParams;
+
+typedef struct {
+    GLsizeiptr datasize;
+    int round_count;
+    GLenum triangle_mode;
+    int is_star;
+} ConstParams;
+
+typedef struct {
+    xyz anchor;
+    xyz position;
+    float rotation;
+    xyz scale;
+} LayerParams;
+
+typedef struct {
+    xyz anchor;
+    xyz position;
+    float rotation;
+    xyz scale;
+    float alpha;
+    VarParams var_params;
+    ConstParams const_params;
+    LayerParams layer_params;
+} Params;
+
+typedef struct {
+    vec4 color;
+    CPoint *data;
+    GLuint buffer;
+    int num_points;
+
+    Params params;
+} Shape;
+
+typedef struct {
+    GLuint texture;
+    CPoint *data;
+    GLuint buffer;
+    int num_points;
+
+    Params params;
+} TexturedShape;
+
+#endif
diff --git a/TMessagesProj/jni/jni.c b/TMessagesProj/jni/jni.c
index 1589a61e9..21deaaee6 100644
--- a/TMessagesProj/jni/jni.c
+++ b/TMessagesProj/jni/jni.c
@@ -56,6 +56,53 @@ JNIEXPORT void Java_org_telegram_messenger_Utilities_aesIgeEncryption(JNIEnv *en
     (*env)->ReleaseByteArrayElements(env, iv, ivBuff, 0);
 }
 
+JNIEXPORT jint Java_org_telegram_messenger_Utilities_aesCtrDecryption(JNIEnv *env, jclass class, jobject buffer, jbyteArray key, jbyteArray iv, int offset, int length) {
+    jbyte *what = (*env)->GetDirectBufferAddress(env, buffer) + offset;
+    unsigned char *keyBuff = (unsigned char *)(*env)->GetByteArrayElements(env, key, NULL);
+    unsigned char *ivBuff = (unsigned char *)(*env)->GetByteArrayElements(env, iv, NULL);
+
+    AES_KEY akey;
+    unsigned int num = 0;
+    uint8_t count[16];
+    memset(count, 0, 16);
+    AES_set_encrypt_key(keyBuff, 32 * 8, &akey);
+    AES_ctr128_encrypt(what, what, length, &akey, ivBuff, count, &num);
+    (*env)->ReleaseByteArrayElements(env, key, keyBuff, JNI_ABORT);
+    (*env)->ReleaseByteArrayElements(env, iv, ivBuff, JNI_ABORT);
+    return num;
+}
+
+JNIEXPORT jint Java_org_telegram_messenger_Utilities_aesCtrDecryptionByteArray(JNIEnv *env, jclass class, jbyteArray buffer, jbyteArray key, jbyteArray iv, int offset, int length, int fileOffset) {
+    unsigned char *bufferBuff = (unsigned char *)(*env)->GetByteArrayElements(env, buffer, NULL);
+    unsigned char *keyBuff = (unsigned char *)(*env)->GetByteArrayElements(env, key, NULL);
+    unsigned char *ivBuff = (unsigned char *)(*env)->GetByteArrayElements(env, iv, NULL);
+
+    AES_KEY akey;
+    uint8_t count[16];
+    AES_set_encrypt_key(keyBuff, 32 * 8, &akey);
+    unsigned int num = (unsigned int) (fileOffset % 16);
+
+    int o = fileOffset / 16;
+    ivBuff[15] = (uint8_t) (o & 0xff);
+    ivBuff[14] = (uint8_t) ((o >> 8) & 0xff);
+    ivBuff[13] = (uint8_t) ((o >> 16) & 0xff);
+    ivBuff[12] = (uint8_t) ((o >> 24) & 0xff);
+    AES_encrypt(ivBuff, count, &akey);
+
+    o = (fileOffset + 15) / 16;
+    ivBuff[15] = (uint8_t) (o & 0xff);
+    ivBuff[14] = (uint8_t) ((o >> 8) & 0xff);
+    ivBuff[13] = (uint8_t) ((o >> 16) & 0xff);
+    ivBuff[12] = (uint8_t) ((o >> 24) & 0xff);
+
+    AES_ctr128_encrypt(bufferBuff + offset, bufferBuff + offset, length, &akey, ivBuff, count, &num);
+
+    (*env)->ReleaseByteArrayElements(env, key, keyBuff, JNI_ABORT);
+    (*env)->ReleaseByteArrayElements(env, iv, ivBuff, JNI_ABORT);
+    (*env)->ReleaseByteArrayElements(env, buffer, bufferBuff, 0);
+    return num;
+}
+
 JNIEXPORT jstring Java_org_telegram_messenger_Utilities_readlink(JNIEnv *env, jclass class, jstring path) {
     static char buf[1000];
     char *fileName = (*env)->GetStringUTFChars(env, path, NULL);
diff --git a/TMessagesProj/jni/sqlite/sqlite3.c b/TMessagesProj/jni/sqlite/sqlite3.c
index af83f89f3..ea5ba16b6 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.c
+++ b/TMessagesProj/jni/sqlite/sqlite3.c
@@ -1,6 +1,6 @@
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
-** version 3.18.0.  By combining all the individual C code files into this
+** version 3.20.1.  By combining all the individual C code files into this
 ** single large file, the entire code can be compiled as a single translation
 ** unit.  This allows many compilers to do optimizations that would not be
 ** possible if the files were compiled separately.  Performance improvements
@@ -22,6 +22,758 @@
 #ifndef SQLITE_PRIVATE
 # define SQLITE_PRIVATE static
 #endif
+/************** Begin file ctime.c *******************************************/
+/*
+** 2010 February 23
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+*************************************************************************
+**
+** This file implements routines used to report what compile-time options
+** SQLite was built with.
+*/
+
+#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
+
+/*
+** Include the configuration header output by 'configure' if we're using the
+** autoconf-based build
+*/
+#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)
+#include "config.h"
+#define SQLITECONFIG_H 1
+#endif
+
+/* These macros are provided to "stringify" the value of the define
+** for those options in which the value is meaningful. */
+#define CTIMEOPT_VAL_(opt) #opt
+#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)
+
+/*
+** An array of names of all compile-time options.  This array should 
+** be sorted A-Z.
+**
+** This array looks large, but in a typical installation actually uses
+** only a handful of compile-time options, so most times this array is usually
+** rather short and uses little memory space.
+*/
+static const char * const sqlite3azCompileOpt[] = {
+
+/* 
+** BEGIN CODE GENERATED BY tool/mkctime.tcl 
+*/
+#if SQLITE_32BIT_ROWID
+  "32BIT_ROWID",
+#endif
+#if SQLITE_4_BYTE_ALIGNED_MALLOC
+  "4_BYTE_ALIGNED_MALLOC",
+#endif
+#if SQLITE_64BIT_STATS
+  "64BIT_STATS",
+#endif
+#if SQLITE_ALLOW_COVERING_INDEX_SCAN
+  "ALLOW_COVERING_INDEX_SCAN",
+#endif
+#if SQLITE_ALLOW_URI_AUTHORITY
+  "ALLOW_URI_AUTHORITY",
+#endif
+#ifdef SQLITE_BITMASK_TYPE
+  "BITMASK_TYPE=" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),
+#endif
+#if SQLITE_BUG_COMPATIBLE_20160819
+  "BUG_COMPATIBLE_20160819",
+#endif
+#if SQLITE_CASE_SENSITIVE_LIKE
+  "CASE_SENSITIVE_LIKE",
+#endif
+#if SQLITE_CHECK_PAGES
+  "CHECK_PAGES",
+#endif
+#if defined(__clang__) && defined(__clang_major__)
+  "COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."
+                    CTIMEOPT_VAL(__clang_minor__) "."
+                    CTIMEOPT_VAL(__clang_patchlevel__),
+#elif defined(_MSC_VER)
+  "COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),
+#elif defined(__GNUC__) && defined(__VERSION__)
+  "COMPILER=gcc-" __VERSION__,
+#endif
+#if SQLITE_COVERAGE_TEST
+  "COVERAGE_TEST",
+#endif
+#if SQLITE_DEBUG
+  "DEBUG",
+#endif
+#if SQLITE_DEFAULT_AUTOMATIC_INDEX
+  "DEFAULT_AUTOMATIC_INDEX",
+#endif
+#if SQLITE_DEFAULT_AUTOVACUUM
+  "DEFAULT_AUTOVACUUM",
+#endif
+#ifdef SQLITE_DEFAULT_CACHE_SIZE
+  "DEFAULT_CACHE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),
+#endif
+#if SQLITE_DEFAULT_CKPTFULLFSYNC
+  "DEFAULT_CKPTFULLFSYNC",
+#endif
+#ifdef SQLITE_DEFAULT_FILE_FORMAT
+  "DEFAULT_FILE_FORMAT=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),
+#endif
+#ifdef SQLITE_DEFAULT_FILE_PERMISSIONS
+  "DEFAULT_FILE_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),
+#endif
+#if SQLITE_DEFAULT_FOREIGN_KEYS
+  "DEFAULT_FOREIGN_KEYS",
+#endif
+#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
+  "DEFAULT_JOURNAL_SIZE_LIMIT=" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),
+#endif
+#ifdef SQLITE_DEFAULT_LOCKING_MODE
+  "DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),
+#endif
+#ifdef SQLITE_DEFAULT_LOOKASIDE
+  "DEFAULT_LOOKASIDE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOOKASIDE),
+#endif
+#if SQLITE_DEFAULT_MEMSTATUS
+  "DEFAULT_MEMSTATUS",
+#endif
+#ifdef SQLITE_DEFAULT_MMAP_SIZE
+  "DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),
+#endif
+#ifdef SQLITE_DEFAULT_PAGE_SIZE
+  "DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),
+#endif
+#ifdef SQLITE_DEFAULT_PCACHE_INITSZ
+  "DEFAULT_PCACHE_INITSZ=" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),
+#endif
+#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
+  "DEFAULT_PROXYDIR_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),
+#endif
+#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS
+  "DEFAULT_RECURSIVE_TRIGGERS",
+#endif
+#ifdef SQLITE_DEFAULT_ROWEST
+  "DEFAULT_ROWEST=" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),
+#endif
+#ifdef SQLITE_DEFAULT_SECTOR_SIZE
+  "DEFAULT_SECTOR_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),
+#endif
+#ifdef SQLITE_DEFAULT_SYNCHRONOUS
+  "DEFAULT_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),
+#endif
+#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT
+  "DEFAULT_WAL_AUTOCHECKPOINT=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),
+#endif
+#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUS
+  "DEFAULT_WAL_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),
+#endif
+#ifdef SQLITE_DEFAULT_WORKER_THREADS
+  "DEFAULT_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),
+#endif
+#if SQLITE_DIRECT_OVERFLOW_READ
+  "DIRECT_OVERFLOW_READ",
+#endif
+#if SQLITE_DISABLE_DIRSYNC
+  "DISABLE_DIRSYNC",
+#endif
+#if SQLITE_DISABLE_FTS3_UNICODE
+  "DISABLE_FTS3_UNICODE",
+#endif
+#if SQLITE_DISABLE_FTS4_DEFERRED
+  "DISABLE_FTS4_DEFERRED",
+#endif
+#if SQLITE_DISABLE_INTRINSIC
+  "DISABLE_INTRINSIC",
+#endif
+#if SQLITE_DISABLE_LFS
+  "DISABLE_LFS",
+#endif
+#if SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
+  "DISABLE_PAGECACHE_OVERFLOW_STATS",
+#endif
+#if SQLITE_DISABLE_SKIPAHEAD_DISTINCT
+  "DISABLE_SKIPAHEAD_DISTINCT",
+#endif
+#ifdef SQLITE_ENABLE_8_3_NAMES
+  "ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),
+#endif
+#if SQLITE_ENABLE_API_ARMOR
+  "ENABLE_API_ARMOR",
+#endif
+#if SQLITE_ENABLE_ATOMIC_WRITE
+  "ENABLE_ATOMIC_WRITE",
+#endif
+#if SQLITE_ENABLE_CEROD
+  "ENABLE_CEROD",
+#endif
+#if SQLITE_ENABLE_COLUMN_METADATA
+  "ENABLE_COLUMN_METADATA",
+#endif
+#if SQLITE_ENABLE_COLUMN_USED_MASK
+  "ENABLE_COLUMN_USED_MASK",
+#endif
+#if SQLITE_ENABLE_COSTMULT
+  "ENABLE_COSTMULT",
+#endif
+#if SQLITE_ENABLE_CURSOR_HINTS
+  "ENABLE_CURSOR_HINTS",
+#endif
+#if SQLITE_ENABLE_DBSTAT_VTAB
+  "ENABLE_DBSTAT_VTAB",
+#endif
+#if SQLITE_ENABLE_EXPENSIVE_ASSERT
+  "ENABLE_EXPENSIVE_ASSERT",
+#endif
+#if SQLITE_ENABLE_FTS1
+  "ENABLE_FTS1",
+#endif
+#if SQLITE_ENABLE_FTS2
+  "ENABLE_FTS2",
+#endif
+#if SQLITE_ENABLE_FTS3
+  "ENABLE_FTS3",
+#endif
+#if SQLITE_ENABLE_FTS3_PARENTHESIS
+  "ENABLE_FTS3_PARENTHESIS",
+#endif
+#if SQLITE_ENABLE_FTS3_TOKENIZER
+  "ENABLE_FTS3_TOKENIZER",
+#endif
+#if SQLITE_ENABLE_FTS4
+  "ENABLE_FTS4",
+#endif
+#if SQLITE_ENABLE_FTS5
+  "ENABLE_FTS5",
+#endif
+#if SQLITE_ENABLE_HIDDEN_COLUMNS
+  "ENABLE_HIDDEN_COLUMNS",
+#endif
+#if SQLITE_ENABLE_ICU
+  "ENABLE_ICU",
+#endif
+#if SQLITE_ENABLE_IOTRACE
+  "ENABLE_IOTRACE",
+#endif
+#if SQLITE_ENABLE_JSON1
+  "ENABLE_JSON1",
+#endif
+#if SQLITE_ENABLE_LOAD_EXTENSION
+  "ENABLE_LOAD_EXTENSION",
+#endif
+#ifdef SQLITE_ENABLE_LOCKING_STYLE
+  "ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),
+#endif
+#if SQLITE_ENABLE_MEMORY_MANAGEMENT
+  "ENABLE_MEMORY_MANAGEMENT",
+#endif
+#if SQLITE_ENABLE_MEMSYS3
+  "ENABLE_MEMSYS3",
+#endif
+#if SQLITE_ENABLE_MEMSYS5
+  "ENABLE_MEMSYS5",
+#endif
+#if SQLITE_ENABLE_MULTIPLEX
+  "ENABLE_MULTIPLEX",
+#endif
+#if SQLITE_ENABLE_NULL_TRIM
+  "ENABLE_NULL_TRIM",
+#endif
+#if SQLITE_ENABLE_OVERSIZE_CELL_CHECK
+  "ENABLE_OVERSIZE_CELL_CHECK",
+#endif
+#if SQLITE_ENABLE_PREUPDATE_HOOK
+  "ENABLE_PREUPDATE_HOOK",
+#endif
+#if SQLITE_ENABLE_QPSG
+  "ENABLE_QPSG",
+#endif
+#if SQLITE_ENABLE_RBU
+  "ENABLE_RBU",
+#endif
+#if SQLITE_ENABLE_RTREE
+  "ENABLE_RTREE",
+#endif
+#if SQLITE_ENABLE_SELECTTRACE
+  "ENABLE_SELECTTRACE",
+#endif
+#if SQLITE_ENABLE_SESSION
+  "ENABLE_SESSION",
+#endif
+#if SQLITE_ENABLE_SNAPSHOT
+  "ENABLE_SNAPSHOT",
+#endif
+#if SQLITE_ENABLE_SQLLOG
+  "ENABLE_SQLLOG",
+#endif
+#if defined(SQLITE_ENABLE_STAT4)
+  "ENABLE_STAT4",
+#elif defined(SQLITE_ENABLE_STAT3)
+  "ENABLE_STAT3",
+#endif
+#if SQLITE_ENABLE_STMTVTAB
+  "ENABLE_STMTVTAB",
+#endif
+#if SQLITE_ENABLE_STMT_SCANSTATUS
+  "ENABLE_STMT_SCANSTATUS",
+#endif
+#if SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
+  "ENABLE_UNKNOWN_SQL_FUNCTION",
+#endif
+#if SQLITE_ENABLE_UNLOCK_NOTIFY
+  "ENABLE_UNLOCK_NOTIFY",
+#endif
+#if SQLITE_ENABLE_UPDATE_DELETE_LIMIT
+  "ENABLE_UPDATE_DELETE_LIMIT",
+#endif
+#if SQLITE_ENABLE_URI_00_ERROR
+  "ENABLE_URI_00_ERROR",
+#endif
+#if SQLITE_ENABLE_VFSTRACE
+  "ENABLE_VFSTRACE",
+#endif
+#if SQLITE_ENABLE_WHERETRACE
+  "ENABLE_WHERETRACE",
+#endif
+#if SQLITE_ENABLE_ZIPVFS
+  "ENABLE_ZIPVFS",
+#endif
+#if SQLITE_EXPLAIN_ESTIMATED_ROWS
+  "EXPLAIN_ESTIMATED_ROWS",
+#endif
+#if SQLITE_EXTRA_IFNULLROW
+  "EXTRA_IFNULLROW",
+#endif
+#ifdef SQLITE_EXTRA_INIT
+  "EXTRA_INIT=" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),
+#endif
+#ifdef SQLITE_EXTRA_SHUTDOWN
+  "EXTRA_SHUTDOWN=" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),
+#endif
+#ifdef SQLITE_FTS3_MAX_EXPR_DEPTH
+  "FTS3_MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),
+#endif
+#if SQLITE_FTS5_ENABLE_TEST_MI
+  "FTS5_ENABLE_TEST_MI",
+#endif
+#if SQLITE_FTS5_NO_WITHOUT_ROWID
+  "FTS5_NO_WITHOUT_ROWID",
+#endif
+#if SQLITE_HAS_CODEC
+  "HAS_CODEC",
+#endif
+#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
+  "HAVE_ISNAN",
+#endif
+#if SQLITE_HOMEGROWN_RECURSIVE_MUTEX
+  "HOMEGROWN_RECURSIVE_MUTEX",
+#endif
+#if SQLITE_IGNORE_AFP_LOCK_ERRORS
+  "IGNORE_AFP_LOCK_ERRORS",
+#endif
+#if SQLITE_IGNORE_FLOCK_LOCK_ERRORS
+  "IGNORE_FLOCK_LOCK_ERRORS",
+#endif
+#if SQLITE_INLINE_MEMCPY
+  "INLINE_MEMCPY",
+#endif
+#if SQLITE_INT64_TYPE
+  "INT64_TYPE",
+#endif
+#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAX
+  "INTEGRITY_CHECK_ERROR_MAX=" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),
+#endif
+#if SQLITE_LIKE_DOESNT_MATCH_BLOBS
+  "LIKE_DOESNT_MATCH_BLOBS",
+#endif
+#if SQLITE_LOCK_TRACE
+  "LOCK_TRACE",
+#endif
+#if SQLITE_LOG_CACHE_SPILL
+  "LOG_CACHE_SPILL",
+#endif
+#ifdef SQLITE_MALLOC_SOFT_LIMIT
+  "MALLOC_SOFT_LIMIT=" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),
+#endif
+#ifdef SQLITE_MAX_ATTACHED
+  "MAX_ATTACHED=" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),
+#endif
+#ifdef SQLITE_MAX_COLUMN
+  "MAX_COLUMN=" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),
+#endif
+#ifdef SQLITE_MAX_COMPOUND_SELECT
+  "MAX_COMPOUND_SELECT=" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),
+#endif
+#ifdef SQLITE_MAX_DEFAULT_PAGE_SIZE
+  "MAX_DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),
+#endif
+#ifdef SQLITE_MAX_EXPR_DEPTH
+  "MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),
+#endif
+#ifdef SQLITE_MAX_FUNCTION_ARG
+  "MAX_FUNCTION_ARG=" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),
+#endif
+#ifdef SQLITE_MAX_LENGTH
+  "MAX_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),
+#endif
+#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTH
+  "MAX_LIKE_PATTERN_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),
+#endif
+#ifdef SQLITE_MAX_MEMORY
+  "MAX_MEMORY=" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),
+#endif
+#ifdef SQLITE_MAX_MMAP_SIZE
+  "MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),
+#endif
+#ifdef SQLITE_MAX_MMAP_SIZE_
+  "MAX_MMAP_SIZE_=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),
+#endif
+#ifdef SQLITE_MAX_PAGE_COUNT
+  "MAX_PAGE_COUNT=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),
+#endif
+#ifdef SQLITE_MAX_PAGE_SIZE
+  "MAX_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),
+#endif
+#ifdef SQLITE_MAX_SCHEMA_RETRY
+  "MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),
+#endif
+#ifdef SQLITE_MAX_SQL_LENGTH
+  "MAX_SQL_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),
+#endif
+#ifdef SQLITE_MAX_TRIGGER_DEPTH
+  "MAX_TRIGGER_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),
+#endif
+#ifdef SQLITE_MAX_VARIABLE_NUMBER
+  "MAX_VARIABLE_NUMBER=" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),
+#endif
+#ifdef SQLITE_MAX_VDBE_OP
+  "MAX_VDBE_OP=" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),
+#endif
+#ifdef SQLITE_MAX_WORKER_THREADS
+  "MAX_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),
+#endif
+#if SQLITE_MEMDEBUG
+  "MEMDEBUG",
+#endif
+#if SQLITE_MIXED_ENDIAN_64BIT_FLOAT
+  "MIXED_ENDIAN_64BIT_FLOAT",
+#endif
+#if SQLITE_MMAP_READWRITE
+  "MMAP_READWRITE",
+#endif
+#if SQLITE_MUTEX_NOOP
+  "MUTEX_NOOP",
+#endif
+#if SQLITE_MUTEX_NREF
+  "MUTEX_NREF",
+#endif
+#if SQLITE_MUTEX_OMIT
+  "MUTEX_OMIT",
+#endif
+#if SQLITE_MUTEX_PTHREADS
+  "MUTEX_PTHREADS",
+#endif
+#if SQLITE_MUTEX_W32
+  "MUTEX_W32",
+#endif
+#if SQLITE_NEED_ERR_NAME
+  "NEED_ERR_NAME",
+#endif
+#if SQLITE_NOINLINE
+  "NOINLINE",
+#endif
+#if SQLITE_NO_SYNC
+  "NO_SYNC",
+#endif
+#if SQLITE_OMIT_ALTERTABLE
+  "OMIT_ALTERTABLE",
+#endif
+#if SQLITE_OMIT_ANALYZE
+  "OMIT_ANALYZE",
+#endif
+#if SQLITE_OMIT_ATTACH
+  "OMIT_ATTACH",
+#endif
+#if SQLITE_OMIT_AUTHORIZATION
+  "OMIT_AUTHORIZATION",
+#endif
+#if SQLITE_OMIT_AUTOINCREMENT
+  "OMIT_AUTOINCREMENT",
+#endif
+#if SQLITE_OMIT_AUTOINIT
+  "OMIT_AUTOINIT",
+#endif
+#if SQLITE_OMIT_AUTOMATIC_INDEX
+  "OMIT_AUTOMATIC_INDEX",
+#endif
+#if SQLITE_OMIT_AUTORESET
+  "OMIT_AUTORESET",
+#endif
+#if SQLITE_OMIT_AUTOVACUUM
+  "OMIT_AUTOVACUUM",
+#endif
+#if SQLITE_OMIT_BETWEEN_OPTIMIZATION
+  "OMIT_BETWEEN_OPTIMIZATION",
+#endif
+#if SQLITE_OMIT_BLOB_LITERAL
+  "OMIT_BLOB_LITERAL",
+#endif
+#if SQLITE_OMIT_BTREECOUNT
+  "OMIT_BTREECOUNT",
+#endif
+#if SQLITE_OMIT_CAST
+  "OMIT_CAST",
+#endif
+#if SQLITE_OMIT_CHECK
+  "OMIT_CHECK",
+#endif
+#if SQLITE_OMIT_COMPLETE
+  "OMIT_COMPLETE",
+#endif
+#if SQLITE_OMIT_COMPOUND_SELECT
+  "OMIT_COMPOUND_SELECT",
+#endif
+#if SQLITE_OMIT_CONFLICT_CLAUSE
+  "OMIT_CONFLICT_CLAUSE",
+#endif
+#if SQLITE_OMIT_CTE
+  "OMIT_CTE",
+#endif
+#if SQLITE_OMIT_DATETIME_FUNCS
+  "OMIT_DATETIME_FUNCS",
+#endif
+#if SQLITE_OMIT_DECLTYPE
+  "OMIT_DECLTYPE",
+#endif
+#if SQLITE_OMIT_DEPRECATED
+  "OMIT_DEPRECATED",
+#endif
+#if SQLITE_OMIT_DISKIO
+  "OMIT_DISKIO",
+#endif
+#if SQLITE_OMIT_EXPLAIN
+  "OMIT_EXPLAIN",
+#endif
+#if SQLITE_OMIT_FLAG_PRAGMAS
+  "OMIT_FLAG_PRAGMAS",
+#endif
+#if SQLITE_OMIT_FLOATING_POINT
+  "OMIT_FLOATING_POINT",
+#endif
+#if SQLITE_OMIT_FOREIGN_KEY
+  "OMIT_FOREIGN_KEY",
+#endif
+#if SQLITE_OMIT_GET_TABLE
+  "OMIT_GET_TABLE",
+#endif
+#if SQLITE_OMIT_HEX_INTEGER
+  "OMIT_HEX_INTEGER",
+#endif
+#if SQLITE_OMIT_INCRBLOB
+  "OMIT_INCRBLOB",
+#endif
+#if SQLITE_OMIT_INTEGRITY_CHECK
+  "OMIT_INTEGRITY_CHECK",
+#endif
+#if SQLITE_OMIT_LIKE_OPTIMIZATION
+  "OMIT_LIKE_OPTIMIZATION",
+#endif
+#if SQLITE_OMIT_LOAD_EXTENSION
+  "OMIT_LOAD_EXTENSION",
+#endif
+#if SQLITE_OMIT_LOCALTIME
+  "OMIT_LOCALTIME",
+#endif
+#if SQLITE_OMIT_LOOKASIDE
+  "OMIT_LOOKASIDE",
+#endif
+#if SQLITE_OMIT_MEMORYDB
+  "OMIT_MEMORYDB",
+#endif
+#if SQLITE_OMIT_OR_OPTIMIZATION
+  "OMIT_OR_OPTIMIZATION",
+#endif
+#if SQLITE_OMIT_PAGER_PRAGMAS
+  "OMIT_PAGER_PRAGMAS",
+#endif
+#if SQLITE_OMIT_PARSER_TRACE
+  "OMIT_PARSER_TRACE",
+#endif
+#if SQLITE_OMIT_POPEN
+  "OMIT_POPEN",
+#endif
+#if SQLITE_OMIT_PRAGMA
+  "OMIT_PRAGMA",
+#endif
+#if SQLITE_OMIT_PROGRESS_CALLBACK
+  "OMIT_PROGRESS_CALLBACK",
+#endif
+#if SQLITE_OMIT_QUICKBALANCE
+  "OMIT_QUICKBALANCE",
+#endif
+#if SQLITE_OMIT_REINDEX
+  "OMIT_REINDEX",
+#endif
+#if SQLITE_OMIT_SCHEMA_PRAGMAS
+  "OMIT_SCHEMA_PRAGMAS",
+#endif
+#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
+  "OMIT_SCHEMA_VERSION_PRAGMAS",
+#endif
+#if SQLITE_OMIT_SHARED_CACHE
+  "OMIT_SHARED_CACHE",
+#endif
+#if SQLITE_OMIT_SHUTDOWN_DIRECTORIES
+  "OMIT_SHUTDOWN_DIRECTORIES",
+#endif
+#if SQLITE_OMIT_SUBQUERY
+  "OMIT_SUBQUERY",
+#endif
+#if SQLITE_OMIT_TCL_VARIABLE
+  "OMIT_TCL_VARIABLE",
+#endif
+#if SQLITE_OMIT_TEMPDB
+  "OMIT_TEMPDB",
+#endif
+#if SQLITE_OMIT_TEST_CONTROL
+  "OMIT_TEST_CONTROL",
+#endif
+#if SQLITE_OMIT_TRACE
+  "OMIT_TRACE",
+#endif
+#if SQLITE_OMIT_TRIGGER
+  "OMIT_TRIGGER",
+#endif
+#if SQLITE_OMIT_TRUNCATE_OPTIMIZATION
+  "OMIT_TRUNCATE_OPTIMIZATION",
+#endif
+#if SQLITE_OMIT_UTF16
+  "OMIT_UTF16",
+#endif
+#if SQLITE_OMIT_VACUUM
+  "OMIT_VACUUM",
+#endif
+#if SQLITE_OMIT_VIEW
+  "OMIT_VIEW",
+#endif
+#if SQLITE_OMIT_VIRTUALTABLE
+  "OMIT_VIRTUALTABLE",
+#endif
+#if SQLITE_OMIT_WAL
+  "OMIT_WAL",
+#endif
+#if SQLITE_OMIT_WSD
+  "OMIT_WSD",
+#endif
+#if SQLITE_OMIT_XFER_OPT
+  "OMIT_XFER_OPT",
+#endif
+#if SQLITE_PCACHE_SEPARATE_HEADER
+  "PCACHE_SEPARATE_HEADER",
+#endif
+#if SQLITE_PERFORMANCE_TRACE
+  "PERFORMANCE_TRACE",
+#endif
+#if SQLITE_POWERSAFE_OVERWRITE
+  "POWERSAFE_OVERWRITE",
+#endif
+#if SQLITE_PREFER_PROXY_LOCKING
+  "PREFER_PROXY_LOCKING",
+#endif
+#if SQLITE_PROXY_DEBUG
+  "PROXY_DEBUG",
+#endif
+#if SQLITE_REVERSE_UNORDERED_SELECTS
+  "REVERSE_UNORDERED_SELECTS",
+#endif
+#if SQLITE_RTREE_INT_ONLY
+  "RTREE_INT_ONLY",
+#endif
+#if SQLITE_SECURE_DELETE
+  "SECURE_DELETE",
+#endif
+#if SQLITE_SMALL_STACK
+  "SMALL_STACK",
+#endif
+#ifdef SQLITE_SORTER_PMASZ
+  "SORTER_PMASZ=" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),
+#endif
+#if SQLITE_SOUNDEX
+  "SOUNDEX",
+#endif
+#ifdef SQLITE_STAT4_SAMPLES
+  "STAT4_SAMPLES=" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),
+#endif
+#ifdef SQLITE_STMTJRNL_SPILL
+  "STMTJRNL_SPILL=" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),
+#endif
+#if SQLITE_SUBSTR_COMPATIBILITY
+  "SUBSTR_COMPATIBILITY",
+#endif
+#if SQLITE_SYSTEM_MALLOC
+  "SYSTEM_MALLOC",
+#endif
+#if SQLITE_TCL
+  "TCL",
+#endif
+#ifdef SQLITE_TEMP_STORE
+  "TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),
+#endif
+#if SQLITE_TEST
+  "TEST",
+#endif
+#if defined(SQLITE_THREADSAFE)
+  "THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),
+#elif defined(THREADSAFE)
+  "THREADSAFE=" CTIMEOPT_VAL(THREADSAFE),
+#else
+  "THREADSAFE=1",
+#endif
+#if SQLITE_UNLINK_AFTER_CLOSE
+  "UNLINK_AFTER_CLOSE",
+#endif
+#if SQLITE_UNTESTABLE
+  "UNTESTABLE",
+#endif
+#if SQLITE_USER_AUTHENTICATION
+  "USER_AUTHENTICATION",
+#endif
+#if SQLITE_USE_ALLOCA
+  "USE_ALLOCA",
+#endif
+#if SQLITE_USE_FCNTL_TRACE
+  "USE_FCNTL_TRACE",
+#endif
+#if SQLITE_USE_URI
+  "USE_URI",
+#endif
+#if SQLITE_VDBE_COVERAGE
+  "VDBE_COVERAGE",
+#endif
+#if SQLITE_WIN32_MALLOC
+  "WIN32_MALLOC",
+#endif
+#if SQLITE_ZERO_MALLOC
+  "ZERO_MALLOC",
+#endif
+/* 
+** END CODE GENERATED BY tool/mkctime.tcl 
+*/
+};
+
+SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){
+  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);
+  return (const char**)sqlite3azCompileOpt;
+}
+
+#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
+
+/************** End of ctime.c ***********************************************/
 /************** Begin file sqliteInt.h ***************************************/
 /*
 ** 2001 September 15
@@ -276,7 +1028,7 @@
 /************** Include sqlite3.h in the middle of sqliteInt.h ***************/
 /************** Begin file sqlite3.h *****************************************/
 /*
-** 2001 September 15
+** 2001-09-15
 **
 ** The author disclaims copyright to this source code.  In place of
 ** a legal notice, here is a blessing:
@@ -398,9 +1150,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.18.0"
-#define SQLITE_VERSION_NUMBER 3018000
-#define SQLITE_SOURCE_ID      "2017-03-28 18:48:43 424a0d380332858ee55bdebc4af3789f74e70a2b3ba1cf29d84b9b4bcf3e2e37"
+#define SQLITE_VERSION        "3.20.1"
+#define SQLITE_VERSION_NUMBER 3020001
+#define SQLITE_SOURCE_ID      "2017-08-24 16:21:36 8d3a7ea6c5690d6b7c3767558f4f01b511c55463e3f9e64506801fe9b74dce34"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -694,7 +1446,7 @@ SQLITE_API int sqlite3_exec(
 */
 #define SQLITE_OK           0   /* Successful result */
 /* beginning-of-error-codes */
-#define SQLITE_ERROR        1   /* SQL error or missing database */
+#define SQLITE_ERROR        1   /* Generic error */
 #define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */
 #define SQLITE_PERM         3   /* Access permission denied */
 #define SQLITE_ABORT        4   /* Callback routine requested an abort */
@@ -709,7 +1461,7 @@ SQLITE_API int sqlite3_exec(
 #define SQLITE_FULL        13   /* Insertion failed because database is full */
 #define SQLITE_CANTOPEN    14   /* Unable to open the database file */
 #define SQLITE_PROTOCOL    15   /* Database lock protocol error */
-#define SQLITE_EMPTY       16   /* Database is empty */
+#define SQLITE_EMPTY       16   /* Not used */
 #define SQLITE_SCHEMA      17   /* The database schema changed */
 #define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */
 #define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */
@@ -717,7 +1469,7 @@ SQLITE_API int sqlite3_exec(
 #define SQLITE_MISUSE      21   /* Library used incorrectly */
 #define SQLITE_NOLFS       22   /* Uses OS features not supported on host */
 #define SQLITE_AUTH        23   /* Authorization denied */
-#define SQLITE_FORMAT      24   /* Auxiliary database format error */
+#define SQLITE_FORMAT      24   /* Not used */
 #define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */
 #define SQLITE_NOTADB      26   /* File opened that is not a database file */
 #define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */
@@ -1134,7 +1886,7 @@ struct sqlite3_io_methods {
 ** opcode allows these two values (10 retries and 25 milliseconds of delay)
 ** to be adjusted.  The values are changed for all database connections
 ** within the same process.  The argument is a pointer to an array of two
-** integers where the first integer i the new retry count and the second
+** integers where the first integer is the new retry count and the second
 ** integer is the delay.  If either integer is negative, then the setting
 ** is not changed but instead the prior value of that setting is written
 ** into the array entry, allowing the current retry settings to be
@@ -2284,6 +3036,17 @@ struct sqlite3_mem_methods {
 ** have been disabled - 0 if they are not disabled, 1 if they are.
 ** </dd>
 **
+** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>
+** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates
+** the [query planner stability guarantee] (QPSG).  When the QPSG is active,
+** a single SQL query statement will always use the same algorithm regardless
+** of values of [bound parameters].)^ The QPSG disables some query optimizations
+** that look at the values of bound parameters, which can make some queries
+** slower.  But the QPSG has the advantage of more predictable behavior.  With
+** the QPSG active, SQLite will always use the same query plan in the field as
+** was used during testing in the lab.
+** </dd>
+**
 ** </dl>
 */
 #define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */
@@ -2293,6 +3056,7 @@ struct sqlite3_mem_methods {
 #define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 /* int int* */
 #define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 /* int int* */
 #define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006 /* int int* */
+#define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */
 
 
 /*
@@ -2488,9 +3252,6 @@ SQLITE_API int sqlite3_total_changes(sqlite3*);
 ** ^A call to sqlite3_interrupt(D) that occurs when there are no running
 ** SQL statements is a no-op and has no effect on SQL statements
 ** that are started after the sqlite3_interrupt() call returns.
-**
-** If the database connection closes while [sqlite3_interrupt()]
-** is running then bad things will likely happen.
 */
 SQLITE_API void sqlite3_interrupt(sqlite3*);
 
@@ -2953,12 +3714,14 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 /*
 ** CAPI3REF: Compile-Time Authorization Callbacks
 ** METHOD: sqlite3
+** KEYWORDS: {authorizer callback}
 **
 ** ^This routine registers an authorizer callback with a particular
 ** [database connection], supplied in the first argument.
 ** ^The authorizer callback is invoked as SQL statements are being compiled
 ** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],
-** [sqlite3_prepare16()] and [sqlite3_prepare16_v2()].  ^At various
+** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],
+** and [sqlite3_prepare16_v3()].  ^At various
 ** points during the compilation process, as logic is being created
 ** to perform various actions, the authorizer callback is invoked to
 ** see if those actions are allowed.  ^The authorizer callback should
@@ -2980,8 +3743,10 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** parameter to the sqlite3_set_authorizer() interface. ^The second parameter
 ** to the callback is an integer [SQLITE_COPY | action code] that specifies
 ** the particular action to be authorized. ^The third through sixth parameters
-** to the callback are zero-terminated strings that contain additional
-** details about the action to be authorized.
+** to the callback are either NULL pointers or zero-terminated strings
+** that contain additional details about the action to be authorized.
+** Applications must always be prepared to encounter a NULL pointer in any
+** of the third through the sixth parameters of the authorization callback.
 **
 ** ^If the action code is [SQLITE_READ]
 ** and the callback returns [SQLITE_IGNORE] then the
@@ -2990,6 +3755,10 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]
 ** return can be used to deny an untrusted user access to individual
 ** columns of a table.
+** ^When a table is referenced by a [SELECT] but no column values are
+** extracted from that table (for example in a query like
+** "SELECT count(*) FROM tab") then the [SQLITE_READ] authorizer callback
+** is invoked once for that table with a column name that is an empty string.
 ** ^If the action code is [SQLITE_DELETE] and the callback returns
 ** [SQLITE_IGNORE] then the [DELETE] operation proceeds but the
 ** [truncate optimization] is disabled and all rows are deleted individually.
@@ -3741,6 +4510,29 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 #define SQLITE_LIMIT_TRIGGER_DEPTH            10
 #define SQLITE_LIMIT_WORKER_THREADS           11
 
+/*
+** CAPI3REF: Prepare Flags
+**
+** These constants define various flags that can be passed into
+** "prepFlags" parameter of the [sqlite3_prepare_v3()] and
+** [sqlite3_prepare16_v3()] interfaces.
+**
+** New flags may be added in future releases of SQLite.
+**
+** <dl>
+** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>
+** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner
+** that the prepared statement will be retained for a long time and
+** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]
+** and [sqlite3_prepare16_v3()] assume that the prepared statement will 
+** be used just once or at most a few times and then destroyed using
+** [sqlite3_finalize()] relatively soon. The current implementation acts
+** on this hint by avoiding the use of [lookaside memory] so as not to
+** deplete the limited store of lookaside memory. Future versions of
+** SQLite may act on this hint differently.
+** </dl>
+*/
+#define SQLITE_PREPARE_PERSISTENT              0x01
 
 /*
 ** CAPI3REF: Compiling An SQL Statement
@@ -3748,17 +4540,29 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** METHOD: sqlite3
 ** CONSTRUCTOR: sqlite3_stmt
 **
-** To execute an SQL query, it must first be compiled into a byte-code
-** program using one of these routines.
+** To execute an SQL statement, it must first be compiled into a byte-code
+** program using one of these routines.  Or, in other words, these routines
+** are constructors for the [prepared statement] object.
+**
+** The preferred routine to use is [sqlite3_prepare_v2()].  The
+** [sqlite3_prepare()] interface is legacy and should be avoided.
+** [sqlite3_prepare_v3()] has an extra "prepFlags" option that is used
+** for special purposes.
+**
+** The use of the UTF-8 interfaces is preferred, as SQLite currently
+** does all parsing using UTF-8.  The UTF-16 interfaces are provided
+** as a convenience.  The UTF-16 interfaces work by converting the
+** input text into UTF-8, then invoking the corresponding UTF-8 interface.
 **
 ** The first argument, "db", is a [database connection] obtained from a
 ** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or
 ** [sqlite3_open16()].  The database connection must not have been closed.
 **
 ** The second argument, "zSql", is the statement to be compiled, encoded
-** as either UTF-8 or UTF-16.  The sqlite3_prepare() and sqlite3_prepare_v2()
-** interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()
-** use UTF-16.
+** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),
+** and sqlite3_prepare_v3()
+** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),
+** and sqlite3_prepare16_v3() use UTF-16.
 **
 ** ^If the nByte argument is negative, then zSql is read up to the
 ** first zero terminator. ^If nByte is positive, then it is the
@@ -3785,10 +4589,11 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];
 ** otherwise an [error code] is returned.
 **
-** The sqlite3_prepare_v2() and sqlite3_prepare16_v2() interfaces are
-** recommended for all new programs. The two older interfaces are retained
-** for backwards compatibility, but their use is discouraged.
-** ^In the "v2" interfaces, the prepared statement
+** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),
+** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.
+** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())
+** are retained for backwards compatibility, but their use is discouraged.
+** ^In the "vX" interfaces, the prepared statement
 ** that is returned (the [sqlite3_stmt] object) contains a copy of the
 ** original SQL text. This causes the [sqlite3_step()] interface to
 ** behave differently in three ways:
@@ -3821,6 +4626,12 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** or [GLOB] operator or if the parameter is compared to an indexed column
 ** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
 ** </li>
+**
+** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
+** the extra prepFlags parameter, which is a bit array consisting of zero or
+** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The
+** sqlite3_prepare_v2() interface works exactly the same as
+** sqlite3_prepare_v3() with a zero prepFlags parameter.
 ** </ol>
 */
 SQLITE_API int sqlite3_prepare(
@@ -3837,6 +4648,14 @@ SQLITE_API int sqlite3_prepare_v2(
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
+SQLITE_API int sqlite3_prepare_v3(
+  sqlite3 *db,            /* Database handle */
+  const char *zSql,       /* SQL statement, UTF-8 encoded */
+  int nByte,              /* Maximum length of zSql in bytes. */
+  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
+  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
+  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
+);
 SQLITE_API int sqlite3_prepare16(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
@@ -3851,6 +4670,14 @@ SQLITE_API int sqlite3_prepare16_v2(
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const void **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
+SQLITE_API int sqlite3_prepare16_v3(
+  sqlite3 *db,            /* Database handle */
+  const void *zSql,       /* SQL statement, UTF-16 encoded */
+  int nByte,              /* Maximum length of zSql in bytes. */
+  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
+  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
+  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
+);
 
 /*
 ** CAPI3REF: Retrieving Statement SQL
@@ -3858,7 +4685,8 @@ SQLITE_API int sqlite3_prepare16_v2(
 **
 ** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8
 ** SQL text used to create [prepared statement] P if P was
-** created by either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].
+** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],
+** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
 ** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8
 ** string containing the SQL text of prepared statement P with
 ** [bound parameters] expanded.
@@ -3982,7 +4810,7 @@ SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
 ** The [sqlite3_value_blob | sqlite3_value_type()] family of
 ** interfaces require protected sqlite3_value objects.
 */
-typedef struct Mem sqlite3_value;
+typedef struct sqlite3_value sqlite3_value;
 
 /*
 ** CAPI3REF: SQL Function Context Object
@@ -4084,6 +4912,15 @@ typedef struct sqlite3_context sqlite3_context;
 ** [sqlite3_blob_open | incremental BLOB I/O] routines.
 ** ^A negative value for the zeroblob results in a zero-length BLOB.
 **
+** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in
+** [prepared statement] S to have an SQL value of NULL, but to also be
+** associated with the pointer P of type T.  ^D is either a NULL pointer or
+** a pointer to a destructor function for P. ^SQLite will invoke the
+** destructor D with a single argument of P when it is finished using
+** P.  The T parameter should be a static string, preferably a string
+** literal. The sqlite3_bind_pointer() routine is part of the
+** [pointer passing interface] added for SQLite 3.20.0.
+**
 ** ^If any of the sqlite3_bind_*() routines are called with a NULL pointer
 ** for the [prepared statement] or with a prepared statement for which
 ** [sqlite3_step()] has been called more recently than [sqlite3_reset()],
@@ -4117,6 +4954,7 @@ SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)
 SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                          void(*)(void*), unsigned char encoding);
 SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
+SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
 SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
 
@@ -4160,8 +4998,8 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
 ** ^If the value N is out of range or if the N-th parameter is
 ** nameless, then NULL is returned.  ^The returned string is
 ** always in UTF-8 encoding even if the named parameter was
-** originally specified as UTF-16 in [sqlite3_prepare16()] or
-** [sqlite3_prepare16_v2()].
+** originally specified as UTF-16 in [sqlite3_prepare16()],
+** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
@@ -4178,7 +5016,8 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 ** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero
 ** is returned if no matching parameter is found.  ^The parameter
 ** name must be given in UTF-8 even if the original statement
-** was prepared from UTF-16 text using [sqlite3_prepare16_v2()].
+** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] or
+** [sqlite3_prepare16_v3()].
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
@@ -4332,16 +5171,18 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** CAPI3REF: Evaluate An SQL Statement
 ** METHOD: sqlite3_stmt
 **
-** After a [prepared statement] has been prepared using either
-** [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy
+** After a [prepared statement] has been prepared using any of
+** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],
+** or [sqlite3_prepare16_v3()] or one of the legacy
 ** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function
 ** must be called one or more times to evaluate the statement.
 **
 ** The details of the behavior of the sqlite3_step() interface depend
-** on whether the statement was prepared using the newer "v2" interface
-** [sqlite3_prepare_v2()] and [sqlite3_prepare16_v2()] or the older legacy
-** interface [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
-** new "v2" interface is recommended for new applications but the legacy
+** on whether the statement was prepared using the newer "vX" interfaces
+** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],
+** [sqlite3_prepare16_v2()] or the older legacy
+** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
+** new "vX" interface is recommended for new applications but the legacy
 ** interface will continue to be supported.
 **
 ** ^In the legacy interface, the return value will be either [SQLITE_BUSY],
@@ -4387,7 +5228,7 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** other than [SQLITE_ROW] before any subsequent invocation of
 ** sqlite3_step().  Failure to reset the prepared statement using 
 ** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from
-** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],
+** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1]),
 ** sqlite3_step() began
 ** calling [sqlite3_reset()] automatically in this circumstance rather
 ** than returning [SQLITE_MISUSE].  This is not considered a compatibility
@@ -4402,10 +5243,11 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** specific [error codes] that better describes the error.
 ** We admit that this is a goofy design.  The problem has been fixed
 ** with the "v2" interface.  If you prepare all of your SQL statements
-** using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] instead
+** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]
+** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead
 ** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,
 ** then the more specific [error codes] are returned directly
-** by sqlite3_step().  The use of the "v2" interface is recommended.
+** by sqlite3_step().  The use of the "vX" interfaces is recommended.
 */
 SQLITE_API int sqlite3_step(sqlite3_stmt*);
 
@@ -4467,6 +5309,28 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** KEYWORDS: {column access functions}
 ** METHOD: sqlite3_stmt
 **
+** <b>Summary:</b>
+** <blockquote><table border=0 cellpadding=0 cellspacing=0>
+** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB result
+** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL result
+** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER result
+** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER result
+** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT result
+** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT result
+** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an 
+** [sqlite3_value|unprotected sqlite3_value] object.
+** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
+** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOB
+** or a UTF-8 TEXT result in bytes
+** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
+** TEXT in bytes
+** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Default
+** datatype of the result
+** </table></blockquote>
+**
+** <b>Details:</b>
+**
 ** ^These routines return information about a single column of the current
 ** result row of a query.  ^In every case the first argument is a pointer
 ** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]
@@ -4488,16 +5352,29 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** are called from a different thread while any of these routines
 ** are pending, then the results are undefined.
 **
+** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)
+** each return the value of a result column in a specific data format.  If
+** the result column is not initially in the requested format (for example,
+** if the query returns an integer but the sqlite3_column_text() interface
+** is used to extract the value) then an automatic type conversion is performed.
+**
 ** ^The sqlite3_column_type() routine returns the
 ** [SQLITE_INTEGER | datatype code] for the initial data type
 ** of the result column.  ^The returned value is one of [SQLITE_INTEGER],
-** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].  The value
-** returned by sqlite3_column_type() is only meaningful if no type
-** conversions have occurred as described below.  After a type conversion,
-** the value returned by sqlite3_column_type() is undefined.  Future
+** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].
+** The return value of sqlite3_column_type() can be used to decide which
+** of the first six interface should be used to extract the column value.
+** The value returned by sqlite3_column_type() is only meaningful if no
+** automatic type conversions have occurred for the value in question.  
+** After a type conversion, the result of calling sqlite3_column_type()
+** is undefined, though harmless.  Future
 ** versions of SQLite may change the behavior of sqlite3_column_type()
 ** following a type conversion.
 **
+** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()
+** or sqlite3_column_bytes16() interfaces can be used to determine the size
+** of that BLOB or string.
+**
 ** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()
 ** routine returns the number of bytes in that BLOB or string.
 ** ^If the result is a UTF-16 string, then sqlite3_column_bytes() converts
@@ -4534,9 +5411,13 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** [sqlite3_column_value()] is used in any other way, including calls
 ** to routines like [sqlite3_value_int()], [sqlite3_value_text()],
 ** or [sqlite3_value_bytes()], the behavior is not threadsafe.
+** Hence, the sqlite3_column_value() interface
+** is normally only useful within the implementation of 
+** [application-defined SQL functions] or [virtual tables], not within
+** top-level application code.
 **
-** These routines attempt to convert the value where appropriate.  ^For
-** example, if the internal representation is FLOAT and a text result
+** The these routines may attempt to convert the datatype of the result.
+** ^For example, if the internal representation is FLOAT and a text result
 ** is requested, [sqlite3_snprintf()] is used internally to perform the
 ** conversion automatically.  ^(The following table details the conversions
 ** that are applied:
@@ -4608,7 +5489,7 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** ^The pointers returned are valid until a type conversion occurs as
 ** described above, or until [sqlite3_step()] or [sqlite3_reset()] or
 ** [sqlite3_finalize()] is called.  ^The memory space used to hold strings
-** and BLOBs is freed automatically.  Do <em>not</em> pass the pointers returned
+** and BLOBs is freed automatically.  Do not pass the pointers returned
 ** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into
 ** [sqlite3_free()].
 **
@@ -4619,15 +5500,15 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** [SQLITE_NOMEM].)^
 */
 SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
 SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
 SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
 SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
 SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
 SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
 SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
 
 /*
 ** CAPI3REF: Destroy A Prepared Statement Object
@@ -4861,21 +5742,40 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** CAPI3REF: Obtaining SQL Values
 ** METHOD: sqlite3_value
 **
-** The C-language implementation of SQL functions and aggregates uses
-** this set of interface routines to access the parameter values on
-** the function or aggregate.  
-**
-** The xFunc (for scalar functions) or xStep (for aggregates) parameters
-** to [sqlite3_create_function()] and [sqlite3_create_function16()]
-** define callbacks that implement the SQL functions and aggregates.
-** The 3rd parameter to these callbacks is an array of pointers to
-** [protected sqlite3_value] objects.  There is one [sqlite3_value] object for
-** each parameter to the SQL function.  These routines are used to
-** extract values from the [sqlite3_value] objects.
+** <b>Summary:</b>
+** <blockquote><table border=0 cellpadding=0 cellspacing=0>
+** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB value
+** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL value
+** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER value
+** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER value
+** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer value
+** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT value
+** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in
+** the native byteorder
+** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT value
+** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT value
+** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
+** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOB
+** or a UTF-8 TEXT in bytes
+** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
+** TEXT in bytes
+** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default
+** datatype of the value
+** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the value
+** </table></blockquote>
+**
+** <b>Details:</b>
+**
+** These routines extract type, size, and content information from
+** [protected sqlite3_value] objects.  Protected sqlite3_value objects
+** are used to pass parameter information into implementation of
+** [application-defined SQL functions] and [virtual tables].
 **
 ** These routines work only with [protected sqlite3_value] objects.
 ** Any attempt to use these routines on an [unprotected sqlite3_value]
-** object results in undefined behavior.
+** is not threadsafe.
 **
 ** ^These routines work just like the corresponding [column access functions]
 ** except that these routines take a single [protected sqlite3_value] object
@@ -4886,6 +5786,24 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** sqlite3_value_text16be() and sqlite3_value_text16le() interfaces
 ** extract UTF-16 strings as big-endian and little-endian respectively.
 **
+** ^If [sqlite3_value] object V was initialized 
+** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]
+** and if X and Y are strings that compare equal according to strcmp(X,Y),
+** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,
+** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() 
+** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
+**
+** ^(The sqlite3_value_type(V) interface returns the
+** [SQLITE_INTEGER | datatype code] for the initial datatype of the
+** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],
+** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^
+** Other interfaces might change the datatype for an sqlite3_value object.
+** For example, if the datatype is initially SQLITE_INTEGER and
+** sqlite3_value_text(V) is called to extract a text value for that
+** integer, then subsequent calls to sqlite3_value_type(V) might return
+** SQLITE_TEXT.  Whether or not a persistent internal datatype conversion
+** occurs is undefined and may change from one release of SQLite to the next.
+**
 ** ^(The sqlite3_value_numeric_type() interface attempts to apply
 ** numeric affinity to the value.  This means that an attempt is
 ** made to convert the value to an integer or floating point.  If
@@ -4904,15 +5822,16 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** the SQL function that supplied the [sqlite3_value*] parameters.
 */
 SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
 SQLITE_API double sqlite3_value_double(sqlite3_value*);
 SQLITE_API int sqlite3_value_int(sqlite3_value*);
 SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
+SQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);
 SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
+SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
+SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
 SQLITE_API int sqlite3_value_type(sqlite3_value*);
 SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 
@@ -4925,10 +5844,6 @@ SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 ** information can be used to pass a limited amount of context from
 ** one SQL function to another.  Use the [sqlite3_result_subtype()]
 ** routine to set the subtype for the return value of an SQL function.
-**
-** SQLite makes no use of subtype itself.  It merely passes the subtype
-** from the result of one [application-defined SQL function] into the
-** input of another.
 */
 SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);
 
@@ -5036,10 +5951,11 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** the compiled regular expression can be reused on multiple
 ** invocations of the same function.
 **
-** ^The sqlite3_get_auxdata() interface returns a pointer to the metadata
-** associated by the sqlite3_set_auxdata() function with the Nth argument
-** value to the application-defined function. ^If there is no metadata
-** associated with the function argument, this sqlite3_get_auxdata() interface
+** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata
+** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument
+** value to the application-defined function.  ^N is zero for the left-most
+** function argument.  ^If there is no metadata
+** associated with the function argument, the sqlite3_get_auxdata(C,N) interface
 ** returns a NULL pointer.
 **
 ** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th
@@ -5070,6 +5986,10 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** function parameters that are compile-time constants, including literal
 ** values and [parameters] and expressions composed from the same.)^
 **
+** The value of the N parameter to these interfaces should be non-negative.
+** Future enhancements may make use of negative N values to define new
+** kinds of function caching behavior.
+**
 ** These routines must be called from the same thread in which
 ** the SQL function is running.
 */
@@ -5193,7 +6113,7 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** when it has finished using that result.
 ** ^If the 4th parameter to the sqlite3_result_text* interfaces
 ** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT
-** then SQLite makes a copy of the result into space obtained from
+** then SQLite makes a copy of the result into space obtained
 ** from [sqlite3_malloc()] before it returns.
 **
 ** ^The sqlite3_result_value() interface sets the result of
@@ -5206,6 +6126,17 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** [unprotected sqlite3_value] object is required, so either
 ** kind of [sqlite3_value] object can be used with this interface.
 **
+** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to an
+** SQL NULL value, just like [sqlite3_result_null(C)], except that it
+** also associates the host-language pointer P or type T with that 
+** NULL value such that the pointer can be retrieved within an
+** [application-defined SQL function] using [sqlite3_value_pointer()].
+** ^If the D parameter is not NULL, then it is a pointer to a destructor
+** for the P parameter.  ^SQLite invokes D with P as its only argument
+** when SQLite is finished with P.  The T parameter should be a static
+** string and preferably a string literal. The sqlite3_result_pointer()
+** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
+**
 ** If these routines are called from within the different thread
 ** than the one containing the application-defined function that received
 ** the [sqlite3_context] pointer, the results are undefined.
@@ -5229,6 +6160,7 @@ SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*
 SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
 SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
 SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
+SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));
 SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
 SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
 
@@ -5888,7 +6820,9 @@ SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
 ** ^If the column-name parameter to sqlite3_table_column_metadata() is a
 ** NULL pointer, then this routine simply checks for the existence of the
 ** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it
-** does not.
+** does not.  If the table name parameter T in a call to
+** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is
+** undefined behavior.
 **
 ** ^The column is identified by the second, third and fourth parameters to
 ** this function. ^(The second parameter is either the name of the database
@@ -7401,6 +8335,24 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 ** used as a proxy for the total work done by the prepared statement.
 ** If the number of virtual machine operations exceeds 2147483647
 ** then the value returned by this statement status code is undefined.
+**
+** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>
+** <dd>^This is the number of times that the prepare statement has been
+** automatically regenerated due to schema changes or change to 
+** [bound parameters] that might affect the query plan.
+**
+** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>
+** <dd>^This is the number of times that the prepared statement has
+** been run.  A single "run" for the purposes of this counter is one
+** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].
+** The counter is incremented on the first [sqlite3_step()] call of each
+** cycle.
+**
+** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>
+** <dd>^This is the approximate number of bytes of heap memory
+** used to store the prepared statement.  ^This value is not actually
+** a counter, and so the resetFlg parameter to sqlite3_stmt_status()
+** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.
 ** </dd>
 ** </dl>
 */
@@ -7408,6 +8360,9 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 #define SQLITE_STMTSTATUS_SORT              2
 #define SQLITE_STMTSTATUS_AUTOINDEX         3
 #define SQLITE_STMTSTATUS_VM_STEP           4
+#define SQLITE_STMTSTATUS_REPREPARE         5
+#define SQLITE_STMTSTATUS_RUN               6
+#define SQLITE_STMTSTATUS_MEMUSED           99
 
 /*
 ** CAPI3REF: Custom Page Cache Object
@@ -9664,7 +10619,7 @@ typedef struct sqlite3_changegroup sqlite3_changegroup;
 ** sqlite3changegroup_output() functions, also available are the streaming
 ** versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().
 */
-int sqlite3changegroup_new(sqlite3_changegroup **pp);
+SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp);
 
 /*
 ** CAPI3REF: Add A Changeset To A Changegroup
@@ -9741,7 +10696,7 @@ int sqlite3changegroup_new(sqlite3_changegroup **pp);
 **
 ** If no error occurs, SQLITE_OK is returned.
 */
-int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
+SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
 
 /*
 ** CAPI3REF: Obtain A Composite Changeset From A Changegroup
@@ -9767,7 +10722,7 @@ int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
 ** responsibility of the caller to eventually free the buffer using a
 ** call to sqlite3_free().
 */
-int sqlite3changegroup_output(
+SQLITE_API int sqlite3changegroup_output(
   sqlite3_changegroup*,
   int *pnData,                    /* OUT: Size of output buffer in bytes */
   void **ppData                   /* OUT: Pointer to output buffer */
@@ -9776,7 +10731,7 @@ int sqlite3changegroup_output(
 /*
 ** CAPI3REF: Delete A Changegroup Object
 */
-void sqlite3changegroup_delete(sqlite3_changegroup*);
+SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);
 
 /*
 ** CAPI3REF: Apply A Changeset To A Database
@@ -10165,11 +11120,11 @@ SQLITE_API int sqlite3session_patchset_strm(
   int (*xOutput)(void *pOut, const void *pData, int nData),
   void *pOut
 );
-int sqlite3changegroup_add_strm(sqlite3_changegroup*, 
+SQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*, 
     int (*xInput)(void *pIn, void *pData, int *pnData),
     void *pIn
 );
-int sqlite3changegroup_output_strm(sqlite3_changegroup*,
+SQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,
     int (*xOutput)(void *pOut, const void *pData, int nData), 
     void *pOut
 );
@@ -10774,8 +11729,9 @@ struct fts5_api {
 ** Include the configuration header output by 'configure' if we're using the
 ** autoconf-based build
 */
-#ifdef _HAVE_SQLITE_CONFIG_H
-#include "config.h"
+#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)
+/* #include "config.h" */
+#define SQLITECONFIG_H 1
 #endif
 
 /************** Include sqliteLimit.h in the middle of sqliteInt.h ***********/
@@ -11085,6 +12041,11 @@ struct fts5_api {
 **
 ** Older versions of SQLite used an optional THREADSAFE macro.
 ** We support that for legacy.
+**
+** To ensure that the correct value of "THREADSAFE" is reported when querying
+** for compile-time options at runtime (e.g. "PRAGMA compile_options"), this
+** logic is partially replicated in ctime.c. If it is updated here, it should
+** also be updated there.
 */
 #if !defined(SQLITE_THREADSAFE)
 # if defined(THREADSAFE)
@@ -11453,76 +12414,76 @@ SQLITE_PRIVATE void sqlite3HashClear(Hash*);
 #define TK_AS                              24
 #define TK_WITHOUT                         25
 #define TK_COMMA                           26
-#define TK_OR                              27
-#define TK_AND                             28
-#define TK_IS                              29
-#define TK_MATCH                           30
-#define TK_LIKE_KW                         31
-#define TK_BETWEEN                         32
-#define TK_IN                              33
-#define TK_ISNULL                          34
-#define TK_NOTNULL                         35
-#define TK_NE                              36
-#define TK_EQ                              37
-#define TK_GT                              38
-#define TK_LE                              39
-#define TK_LT                              40
-#define TK_GE                              41
-#define TK_ESCAPE                          42
-#define TK_BITAND                          43
-#define TK_BITOR                           44
-#define TK_LSHIFT                          45
-#define TK_RSHIFT                          46
-#define TK_PLUS                            47
-#define TK_MINUS                           48
-#define TK_STAR                            49
-#define TK_SLASH                           50
-#define TK_REM                             51
-#define TK_CONCAT                          52
-#define TK_COLLATE                         53
-#define TK_BITNOT                          54
-#define TK_ID                              55
-#define TK_INDEXED                         56
-#define TK_ABORT                           57
-#define TK_ACTION                          58
-#define TK_AFTER                           59
-#define TK_ANALYZE                         60
-#define TK_ASC                             61
-#define TK_ATTACH                          62
-#define TK_BEFORE                          63
-#define TK_BY                              64
-#define TK_CASCADE                         65
-#define TK_CAST                            66
-#define TK_COLUMNKW                        67
-#define TK_CONFLICT                        68
-#define TK_DATABASE                        69
-#define TK_DESC                            70
-#define TK_DETACH                          71
-#define TK_EACH                            72
-#define TK_FAIL                            73
-#define TK_FOR                             74
-#define TK_IGNORE                          75
-#define TK_INITIALLY                       76
-#define TK_INSTEAD                         77
-#define TK_NO                              78
-#define TK_KEY                             79
-#define TK_OF                              80
-#define TK_OFFSET                          81
-#define TK_PRAGMA                          82
-#define TK_RAISE                           83
-#define TK_RECURSIVE                       84
-#define TK_REPLACE                         85
-#define TK_RESTRICT                        86
-#define TK_ROW                             87
-#define TK_TRIGGER                         88
-#define TK_VACUUM                          89
-#define TK_VIEW                            90
-#define TK_VIRTUAL                         91
-#define TK_WITH                            92
-#define TK_REINDEX                         93
-#define TK_RENAME                          94
-#define TK_CTIME_KW                        95
-#define TK_ANY                             96
+#define TK_ID                              27
+#define TK_ABORT                           28
+#define TK_ACTION                          29
+#define TK_AFTER                           30
+#define TK_ANALYZE                         31
+#define TK_ASC                             32
+#define TK_ATTACH                          33
+#define TK_BEFORE                          34
+#define TK_BY                              35
+#define TK_CASCADE                         36
+#define TK_CAST                            37
+#define TK_COLUMNKW                        38
+#define TK_CONFLICT                        39
+#define TK_DATABASE                        40
+#define TK_DESC                            41
+#define TK_DETACH                          42
+#define TK_EACH                            43
+#define TK_FAIL                            44
+#define TK_FOR                             45
+#define TK_IGNORE                          46
+#define TK_INITIALLY                       47
+#define TK_INSTEAD                         48
+#define TK_LIKE_KW                         49
+#define TK_MATCH                           50
+#define TK_NO                              51
+#define TK_KEY                             52
+#define TK_OF                              53
+#define TK_OFFSET                          54
+#define TK_PRAGMA                          55
+#define TK_RAISE                           56
+#define TK_RECURSIVE                       57
+#define TK_REPLACE                         58
+#define TK_RESTRICT                        59
+#define TK_ROW                             60
+#define TK_TRIGGER                         61
+#define TK_VACUUM                          62
+#define TK_VIEW                            63
+#define TK_VIRTUAL                         64
+#define TK_WITH                            65
+#define TK_REINDEX                         66
+#define TK_RENAME                          67
+#define TK_CTIME_KW                        68
+#define TK_ANY                             69
+#define TK_OR                              70
+#define TK_AND                             71
+#define TK_IS                              72
+#define TK_BETWEEN                         73
+#define TK_IN                              74
+#define TK_ISNULL                          75
+#define TK_NOTNULL                         76
+#define TK_NE                              77
+#define TK_EQ                              78
+#define TK_GT                              79
+#define TK_LE                              80
+#define TK_LT                              81
+#define TK_GE                              82
+#define TK_ESCAPE                          83
+#define TK_BITAND                          84
+#define TK_BITOR                           85
+#define TK_LSHIFT                          86
+#define TK_RSHIFT                          87
+#define TK_PLUS                            88
+#define TK_MINUS                           89
+#define TK_STAR                            90
+#define TK_SLASH                           91
+#define TK_REM                             92
+#define TK_CONCAT                          93
+#define TK_COLLATE                         94
+#define TK_BITNOT                          95
+#define TK_INDEXED                         96
 #define TK_STRING                          97
 #define TK_JOIN_KW                         98
 #define TK_CONSTRAINT                      99
@@ -11586,10 +12547,11 @@ SQLITE_PRIVATE void sqlite3HashClear(Hash*);
 #define TK_REGISTER                       157
 #define TK_VECTOR                         158
 #define TK_SELECT_COLUMN                  159
-#define TK_ASTERISK                       160
-#define TK_SPAN                           161
-#define TK_SPACE                          162
-#define TK_ILLEGAL                        163
+#define TK_IF_NULL_ROW                    160
+#define TK_ASTERISK                       161
+#define TK_SPAN                           162
+#define TK_SPACE                          163
+#define TK_ILLEGAL                        164
 
 /* The token codes above must all fit in 8 bits */
 #define TKFLG_MASK           0xff  
@@ -11674,7 +12636,6 @@ SQLITE_PRIVATE void sqlite3HashClear(Hash*);
 */
 #ifndef SQLITE_TEMP_STORE
 # define SQLITE_TEMP_STORE 1
-# define SQLITE_TEMP_STORE_xc 1  /* Exclude from ctime.c */
 #endif
 
 /*
@@ -11975,7 +12936,6 @@ typedef INT16_TYPE LogEst;
 # else
 #   define SQLITE_MAX_MMAP_SIZE 0
 # endif
-# define SQLITE_MAX_MMAP_SIZE_xc 1 /* exclude from ctime.c */
 #endif
 
 /*
@@ -11985,7 +12945,6 @@ typedef INT16_TYPE LogEst;
 */
 #ifndef SQLITE_DEFAULT_MMAP_SIZE
 # define SQLITE_DEFAULT_MMAP_SIZE 0
-# define SQLITE_DEFAULT_MMAP_SIZE_xc 1  /* Exclude from ctime.c */
 #endif
 #if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE
 # undef SQLITE_DEFAULT_MMAP_SIZE
@@ -12460,7 +13419,7 @@ struct BtreePayload {
   const void *pKey;       /* Key content for indexes.  NULL for tables */
   sqlite3_int64 nKey;     /* Size of pKey for indexes.  PRIMARY KEY for tabs */
   const void *pData;      /* Data for tables.  NULL for indexes */
-  struct Mem *aMem;       /* First of nMem value in the unpacked pKey */
+  sqlite3_value *aMem;    /* First of nMem value in the unpacked pKey */
   u16 nMem;               /* Number of aMem[] value.  Might be zero */
   int nData;              /* Size of pData.  0 if none. */
   int nZero;              /* Extra zero data appended after pData,nData */
@@ -12470,9 +13429,9 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,
                        int flags, int seekResult);
 SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes);
 SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes);
-SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int *pRes);
+SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int flags);
 SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*);
-SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int *pRes);
+SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int flags);
 SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor*);
 SQLITE_PRIVATE int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);
 SQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);
@@ -12590,7 +13549,7 @@ typedef struct Vdbe Vdbe;
 ** The names of the following types declared in vdbeInt.h are required
 ** for the VdbeOp definition.
 */
-typedef struct Mem Mem;
+typedef struct sqlite3_value Mem;
 typedef struct SubProgram SubProgram;
 
 /*
@@ -12623,7 +13582,7 @@ struct VdbeOp {
 #ifdef SQLITE_ENABLE_CURSOR_HINTS
     Expr *pExpr;           /* Used when p4type is P4_EXPR */
 #endif
-    int (*xAdvance)(BtCursor *, int *);
+    int (*xAdvance)(BtCursor *, int);
   } p4;
 #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
   char *zComment;          /* Comment to improve readability */
@@ -12667,24 +13626,26 @@ typedef struct VdbeOpList VdbeOpList;
 /*
 ** Allowed values of VdbeOp.p4type
 */
-#define P4_NOTUSED    0   /* The P4 parameter is not used */
-#define P4_DYNAMIC  (-1)  /* Pointer to a string obtained from sqliteMalloc() */
-#define P4_STATIC   (-2)  /* Pointer to a static string */
-#define P4_COLLSEQ  (-3)  /* P4 is a pointer to a CollSeq structure */
-#define P4_FUNCDEF  (-4)  /* P4 is a pointer to a FuncDef structure */
-#define P4_KEYINFO  (-5)  /* P4 is a pointer to a KeyInfo structure */
-#define P4_EXPR     (-6)  /* P4 is a pointer to an Expr tree */
-#define P4_MEM      (-7)  /* P4 is a pointer to a Mem*    structure */
-#define P4_TRANSIENT  0   /* P4 is a pointer to a transient string */
-#define P4_VTAB     (-8) /* P4 is a pointer to an sqlite3_vtab structure */
-#define P4_REAL     (-9) /* P4 is a 64-bit floating point value */
-#define P4_INT64    (-10) /* P4 is a 64-bit signed integer */
-#define P4_INT32    (-11) /* P4 is a 32-bit signed integer */
-#define P4_INTARRAY (-12) /* P4 is a vector of 32-bit integers */
-#define P4_SUBPROGRAM  (-13) /* P4 is a pointer to a SubProgram structure */
-#define P4_ADVANCE  (-14) /* P4 is a pointer to BtreeNext() or BtreePrev() */
-#define P4_TABLE    (-15) /* P4 is a pointer to a Table structure */
-#define P4_FUNCCTX  (-16) /* P4 is a pointer to an sqlite3_context object */
+#define P4_NOTUSED      0   /* The P4 parameter is not used */
+#define P4_TRANSIENT    0   /* P4 is a pointer to a transient string */
+#define P4_STATIC     (-1)  /* Pointer to a static string */
+#define P4_COLLSEQ    (-2)  /* P4 is a pointer to a CollSeq structure */
+#define P4_INT32      (-3)  /* P4 is a 32-bit signed integer */
+#define P4_SUBPROGRAM (-4)  /* P4 is a pointer to a SubProgram structure */
+#define P4_ADVANCE    (-5)  /* P4 is a pointer to BtreeNext() or BtreePrev() */
+#define P4_TABLE      (-6)  /* P4 is a pointer to a Table structure */
+/* Above do not own any resources.  Must free those below */
+#define P4_FREE_IF_LE (-7)
+#define P4_DYNAMIC    (-7)  /* Pointer to memory from sqliteMalloc() */
+#define P4_FUNCDEF    (-8)  /* P4 is a pointer to a FuncDef structure */
+#define P4_KEYINFO    (-9)  /* P4 is a pointer to a KeyInfo structure */
+#define P4_EXPR       (-10) /* P4 is a pointer to an Expr tree */
+#define P4_MEM        (-11) /* P4 is a pointer to a Mem*    structure */
+#define P4_VTAB       (-12) /* P4 is a pointer to an sqlite3_vtab structure */
+#define P4_REAL       (-13) /* P4 is a 64-bit floating point value */
+#define P4_INT64      (-14) /* P4 is a 64-bit signed integer */
+#define P4_INTARRAY   (-15) /* P4 is a vector of 32-bit integers */
+#define P4_FUNCCTX    (-16) /* P4 is a pointer to an sqlite3_context object */
 
 /* Error message codes for OP_Halt */
 #define P5_ConstraintNotNull 1
@@ -12750,90 +13711,90 @@ typedef struct VdbeOpList VdbeOpList;
 #define OP_Once           20
 #define OP_If             21
 #define OP_IfNot          22
-#define OP_SeekLT         23 /* synopsis: key=r[P3@P4]                     */
-#define OP_SeekLE         24 /* synopsis: key=r[P3@P4]                     */
-#define OP_SeekGE         25 /* synopsis: key=r[P3@P4]                     */
-#define OP_SeekGT         26 /* synopsis: key=r[P3@P4]                     */
-#define OP_Or             27 /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */
-#define OP_And            28 /* same as TK_AND, synopsis: r[P3]=(r[P1] && r[P2]) */
-#define OP_NoConflict     29 /* synopsis: key=r[P3@P4]                     */
-#define OP_NotFound       30 /* synopsis: key=r[P3@P4]                     */
-#define OP_Found          31 /* synopsis: key=r[P3@P4]                     */
-#define OP_SeekRowid      32 /* synopsis: intkey=r[P3]                     */
-#define OP_NotExists      33 /* synopsis: intkey=r[P3]                     */
-#define OP_IsNull         34 /* same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */
-#define OP_NotNull        35 /* same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */
-#define OP_Ne             36 /* same as TK_NE, synopsis: IF r[P3]!=r[P1]   */
-#define OP_Eq             37 /* same as TK_EQ, synopsis: IF r[P3]==r[P1]   */
-#define OP_Gt             38 /* same as TK_GT, synopsis: IF r[P3]>r[P1]    */
-#define OP_Le             39 /* same as TK_LE, synopsis: IF r[P3]<=r[P1]   */
-#define OP_Lt             40 /* same as TK_LT, synopsis: IF r[P3]<r[P1]    */
-#define OP_Ge             41 /* same as TK_GE, synopsis: IF r[P3]>=r[P1]   */
-#define OP_ElseNotEq      42 /* same as TK_ESCAPE                          */
-#define OP_BitAnd         43 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */
-#define OP_BitOr          44 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */
-#define OP_ShiftLeft      45 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */
-#define OP_ShiftRight     46 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */
-#define OP_Add            47 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */
-#define OP_Subtract       48 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */
-#define OP_Multiply       49 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */
-#define OP_Divide         50 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */
-#define OP_Remainder      51 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */
-#define OP_Concat         52 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */
-#define OP_Last           53
-#define OP_BitNot         54 /* same as TK_BITNOT, synopsis: r[P1]= ~r[P1] */
-#define OP_IfSmaller      55
-#define OP_SorterSort     56
-#define OP_Sort           57
-#define OP_Rewind         58
-#define OP_IdxLE          59 /* synopsis: key=r[P3@P4]                     */
-#define OP_IdxGT          60 /* synopsis: key=r[P3@P4]                     */
-#define OP_IdxLT          61 /* synopsis: key=r[P3@P4]                     */
-#define OP_IdxGE          62 /* synopsis: key=r[P3@P4]                     */
-#define OP_RowSetRead     63 /* synopsis: r[P3]=rowset(P1)                 */
-#define OP_RowSetTest     64 /* synopsis: if r[P3] in rowset(P1) goto P2   */
-#define OP_Program        65
-#define OP_FkIfZero       66 /* synopsis: if fkctr[P1]==0 goto P2          */
-#define OP_IfPos          67 /* synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 */
-#define OP_IfNotZero      68 /* synopsis: if r[P1]!=0 then r[P1]--, goto P2 */
-#define OP_DecrJumpZero   69 /* synopsis: if (--r[P1])==0 goto P2          */
-#define OP_IncrVacuum     70
-#define OP_VNext          71
-#define OP_Init           72 /* synopsis: Start at P2                      */
-#define OP_Return         73
-#define OP_EndCoroutine   74
-#define OP_HaltIfNull     75 /* synopsis: if r[P3]=null halt               */
-#define OP_Halt           76
-#define OP_Integer        77 /* synopsis: r[P2]=P1                         */
-#define OP_Int64          78 /* synopsis: r[P2]=P4                         */
-#define OP_String         79 /* synopsis: r[P2]='P4' (len=P1)              */
-#define OP_Null           80 /* synopsis: r[P2..P3]=NULL                   */
-#define OP_SoftNull       81 /* synopsis: r[P1]=NULL                       */
-#define OP_Blob           82 /* synopsis: r[P2]=P4 (len=P1)                */
-#define OP_Variable       83 /* synopsis: r[P2]=parameter(P1,P4)           */
-#define OP_Move           84 /* synopsis: r[P2@P3]=r[P1@P3]                */
-#define OP_Copy           85 /* synopsis: r[P2@P3+1]=r[P1@P3+1]            */
-#define OP_SCopy          86 /* synopsis: r[P2]=r[P1]                      */
-#define OP_IntCopy        87 /* synopsis: r[P2]=r[P1]                      */
-#define OP_ResultRow      88 /* synopsis: output=r[P1@P2]                  */
-#define OP_CollSeq        89
-#define OP_Function0      90 /* synopsis: r[P3]=func(r[P2@P5])             */
-#define OP_Function       91 /* synopsis: r[P3]=func(r[P2@P5])             */
-#define OP_AddImm         92 /* synopsis: r[P1]=r[P1]+P2                   */
-#define OP_RealAffinity   93
-#define OP_Cast           94 /* synopsis: affinity(r[P1])                  */
-#define OP_Permutation    95
-#define OP_Compare        96 /* synopsis: r[P1@P3] <-> r[P2@P3]            */
+#define OP_IfNullRow      23 /* synopsis: if P1.nullRow then r[P3]=NULL, goto P2 */
+#define OP_SeekLT         24 /* synopsis: key=r[P3@P4]                     */
+#define OP_SeekLE         25 /* synopsis: key=r[P3@P4]                     */
+#define OP_SeekGE         26 /* synopsis: key=r[P3@P4]                     */
+#define OP_SeekGT         27 /* synopsis: key=r[P3@P4]                     */
+#define OP_NoConflict     28 /* synopsis: key=r[P3@P4]                     */
+#define OP_NotFound       29 /* synopsis: key=r[P3@P4]                     */
+#define OP_Found          30 /* synopsis: key=r[P3@P4]                     */
+#define OP_SeekRowid      31 /* synopsis: intkey=r[P3]                     */
+#define OP_NotExists      32 /* synopsis: intkey=r[P3]                     */
+#define OP_Last           33
+#define OP_IfSmaller      34
+#define OP_SorterSort     35
+#define OP_Sort           36
+#define OP_Rewind         37
+#define OP_IdxLE          38 /* synopsis: key=r[P3@P4]                     */
+#define OP_IdxGT          39 /* synopsis: key=r[P3@P4]                     */
+#define OP_IdxLT          40 /* synopsis: key=r[P3@P4]                     */
+#define OP_IdxGE          41 /* synopsis: key=r[P3@P4]                     */
+#define OP_RowSetRead     42 /* synopsis: r[P3]=rowset(P1)                 */
+#define OP_RowSetTest     43 /* synopsis: if r[P3] in rowset(P1) goto P2   */
+#define OP_Program        44
+#define OP_FkIfZero       45 /* synopsis: if fkctr[P1]==0 goto P2          */
+#define OP_IfPos          46 /* synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 */
+#define OP_IfNotZero      47 /* synopsis: if r[P1]!=0 then r[P1]--, goto P2 */
+#define OP_DecrJumpZero   48 /* synopsis: if (--r[P1])==0 goto P2          */
+#define OP_IncrVacuum     49
+#define OP_VNext          50
+#define OP_Init           51 /* synopsis: Start at P2                      */
+#define OP_Return         52
+#define OP_EndCoroutine   53
+#define OP_HaltIfNull     54 /* synopsis: if r[P3]=null halt               */
+#define OP_Halt           55
+#define OP_Integer        56 /* synopsis: r[P2]=P1                         */
+#define OP_Int64          57 /* synopsis: r[P2]=P4                         */
+#define OP_String         58 /* synopsis: r[P2]='P4' (len=P1)              */
+#define OP_Null           59 /* synopsis: r[P2..P3]=NULL                   */
+#define OP_SoftNull       60 /* synopsis: r[P1]=NULL                       */
+#define OP_Blob           61 /* synopsis: r[P2]=P4 (len=P1)                */
+#define OP_Variable       62 /* synopsis: r[P2]=parameter(P1,P4)           */
+#define OP_Move           63 /* synopsis: r[P2@P3]=r[P1@P3]                */
+#define OP_Copy           64 /* synopsis: r[P2@P3+1]=r[P1@P3+1]            */
+#define OP_SCopy          65 /* synopsis: r[P2]=r[P1]                      */
+#define OP_IntCopy        66 /* synopsis: r[P2]=r[P1]                      */
+#define OP_ResultRow      67 /* synopsis: output=r[P1@P2]                  */
+#define OP_CollSeq        68
+#define OP_AddImm         69 /* synopsis: r[P1]=r[P1]+P2                   */
+#define OP_Or             70 /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */
+#define OP_And            71 /* same as TK_AND, synopsis: r[P3]=(r[P1] && r[P2]) */
+#define OP_RealAffinity   72
+#define OP_Cast           73 /* synopsis: affinity(r[P1])                  */
+#define OP_Permutation    74
+#define OP_IsNull         75 /* same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */
+#define OP_NotNull        76 /* same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */
+#define OP_Ne             77 /* same as TK_NE, synopsis: IF r[P3]!=r[P1]   */
+#define OP_Eq             78 /* same as TK_EQ, synopsis: IF r[P3]==r[P1]   */
+#define OP_Gt             79 /* same as TK_GT, synopsis: IF r[P3]>r[P1]    */
+#define OP_Le             80 /* same as TK_LE, synopsis: IF r[P3]<=r[P1]   */
+#define OP_Lt             81 /* same as TK_LT, synopsis: IF r[P3]<r[P1]    */
+#define OP_Ge             82 /* same as TK_GE, synopsis: IF r[P3]>=r[P1]   */
+#define OP_ElseNotEq      83 /* same as TK_ESCAPE                          */
+#define OP_BitAnd         84 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */
+#define OP_BitOr          85 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */
+#define OP_ShiftLeft      86 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */
+#define OP_ShiftRight     87 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */
+#define OP_Add            88 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */
+#define OP_Subtract       89 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */
+#define OP_Multiply       90 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */
+#define OP_Divide         91 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */
+#define OP_Remainder      92 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */
+#define OP_Concat         93 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */
+#define OP_Compare        94 /* synopsis: r[P1@P3] <-> r[P2@P3]            */
+#define OP_BitNot         95 /* same as TK_BITNOT, synopsis: r[P1]= ~r[P1] */
+#define OP_Column         96 /* synopsis: r[P3]=PX                         */
 #define OP_String8        97 /* same as TK_STRING, synopsis: r[P2]='P4'    */
-#define OP_Column         98 /* synopsis: r[P3]=PX                         */
-#define OP_Affinity       99 /* synopsis: affinity(r[P1@P2])               */
-#define OP_MakeRecord    100 /* synopsis: r[P3]=mkrec(r[P1@P2])            */
-#define OP_Count         101 /* synopsis: r[P2]=count()                    */
-#define OP_ReadCookie    102
-#define OP_SetCookie     103
-#define OP_ReopenIdx     104 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenRead      105 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenWrite     106 /* synopsis: root=P2 iDb=P3                   */
+#define OP_Affinity       98 /* synopsis: affinity(r[P1@P2])               */
+#define OP_MakeRecord     99 /* synopsis: r[P3]=mkrec(r[P1@P2])            */
+#define OP_Count         100 /* synopsis: r[P2]=count()                    */
+#define OP_ReadCookie    101
+#define OP_SetCookie     102
+#define OP_ReopenIdx     103 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenRead      104 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenWrite     105 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenDup       106
 #define OP_OpenAutoindex 107 /* synopsis: nColumn=P2                       */
 #define OP_OpenEphemeral 108 /* synopsis: nColumn=P2                       */
 #define OP_SorterOpen    109
@@ -12855,7 +13816,7 @@ typedef struct VdbeOpList VdbeOpList;
 #define OP_SorterInsert  125 /* synopsis: key=r[P2]                        */
 #define OP_IdxInsert     126 /* synopsis: key=r[P2]                        */
 #define OP_IdxDelete     127 /* synopsis: key=r[P2@P3]                     */
-#define OP_Seek          128 /* synopsis: Move P3 to P1.rowid              */
+#define OP_DeferredSeek  128 /* synopsis: Move P3 to P1.rowid if needed    */
 #define OP_IdxRowid      129 /* synopsis: r[P2]=rowid                      */
 #define OP_Destroy       130
 #define OP_Clear         131
@@ -12888,9 +13849,13 @@ typedef struct VdbeOpList VdbeOpList;
 #define OP_VRename       158
 #define OP_Pagecount     159
 #define OP_MaxPgcnt      160
-#define OP_CursorHint    161
-#define OP_Noop          162
-#define OP_Explain       163
+#define OP_PureFunc0     161
+#define OP_Function0     162 /* synopsis: r[P3]=func(r[P2@P5])             */
+#define OP_PureFunc      163
+#define OP_Function      164 /* synopsis: r[P3]=func(r[P2@P5])             */
+#define OP_CursorHint    165
+#define OP_Noop          166
+#define OP_Explain       167
 
 /* Properties such as "out2" or "jump" that are specified in
 ** comments following the "case" for each opcode in the vdbe.c
@@ -12905,17 +13870,17 @@ typedef struct VdbeOpList VdbeOpList;
 #define OPFLG_INITIALIZER {\
 /*   0 */ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,\
 /*   8 */ 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01,\
-/*  16 */ 0x03, 0x03, 0x01, 0x12, 0x01, 0x03, 0x03, 0x09,\
-/*  24 */ 0x09, 0x09, 0x09, 0x26, 0x26, 0x09, 0x09, 0x09,\
-/*  32 */ 0x09, 0x09, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\
-/*  40 */ 0x0b, 0x0b, 0x01, 0x26, 0x26, 0x26, 0x26, 0x26,\
-/*  48 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x01, 0x12, 0x01,\
-/*  56 */ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x23,\
-/*  64 */ 0x0b, 0x01, 0x01, 0x03, 0x03, 0x03, 0x01, 0x01,\
-/*  72 */ 0x01, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10,\
-/*  80 */ 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10,\
-/*  88 */ 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00,\
-/*  96 */ 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00,\
+/*  16 */ 0x03, 0x03, 0x01, 0x12, 0x01, 0x03, 0x03, 0x01,\
+/*  24 */ 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\
+/*  32 */ 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\
+/*  40 */ 0x01, 0x01, 0x23, 0x0b, 0x01, 0x01, 0x03, 0x03,\
+/*  48 */ 0x03, 0x01, 0x01, 0x01, 0x02, 0x02, 0x08, 0x00,\
+/*  56 */ 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00,\
+/*  64 */ 0x00, 0x10, 0x10, 0x00, 0x00, 0x02, 0x26, 0x26,\
+/*  72 */ 0x02, 0x02, 0x00, 0x03, 0x03, 0x0b, 0x0b, 0x0b,\
+/*  80 */ 0x0b, 0x0b, 0x0b, 0x01, 0x26, 0x26, 0x26, 0x26,\
+/*  88 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12,\
+/*  96 */ 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\
 /* 104 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 112 */ 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,\
 /* 120 */ 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x04, 0x00,\
@@ -12923,7 +13888,8 @@ typedef struct VdbeOpList VdbeOpList;
 /* 136 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,\
 /* 144 */ 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00,\
 /* 152 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\
-/* 160 */ 0x10, 0x00, 0x00, 0x00,}
+/* 160 */ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+}
 
 /* The sqlite3P2Values() routine is able to run faster if it knows
 ** the value of the largest JUMP opcode.  The smaller the maximum
@@ -12931,11 +13897,17 @@ typedef struct VdbeOpList VdbeOpList;
 ** generated this include file strives to group all JUMP opcodes
 ** together near the beginning of the list.
 */
-#define SQLITE_MX_JUMP_OPCODE  72  /* Maximum JUMP opcode */
+#define SQLITE_MX_JUMP_OPCODE  83  /* Maximum JUMP opcode */
 
 /************** End of opcodes.h *********************************************/
 /************** Continuing where we left off in vdbe.h ***********************/
 
+/*
+** Additional non-public SQLITE_PREPARE_* flags
+*/
+#define SQLITE_PREPARE_SAVESQL  0x80  /* Preserve SQL text */
+#define SQLITE_PREPARE_MASK     0x0f  /* Mask of public flags */
+
 /*
 ** Prototypes for the VDBE interface.  See comments on the implementation
 ** for a description of what each of these routines does.
@@ -12993,7 +13965,8 @@ SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int);
 SQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
 SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*);
 SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*);
-SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, int);
+SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe*);
+SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);
 SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*);
 SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
 SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);
@@ -13015,6 +13988,8 @@ SQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);
 SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
 #endif
 
+SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context*);
+
 /* Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on
 ** each VDBE opcode.
 **
@@ -13359,6 +14334,7 @@ struct PgHdr {
   sqlite3_pcache_page *pPage;    /* Pcache object page handle */
   void *pData;                   /* Page data */
   void *pExtra;                  /* Extra content */
+  PCache *pCache;                /* PRIVATE: Cache that owns this page */
   PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */
   Pager *pPager;                 /* The pager this page is part of */
   Pgno pgno;                     /* Page number for this page */
@@ -13368,12 +14344,11 @@ struct PgHdr {
   u16 flags;                     /* PGHDR flags defined below */
 
   /**********************************************************************
-  ** Elements above are public.  All that follows is private to pcache.c
-  ** and should not be accessed by other modules.
+  ** Elements above, except pCache, are public.  All that follow are 
+  ** private to pcache.c and should not be accessed by other modules.
+  ** pCache is grouped with the public elements for efficiency.
   */
   i16 nRef;                      /* Number of users of this page */
-  PCache *pCache;                /* Cache that owns this page */
-
   PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
   PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
 };
@@ -14215,8 +15190,8 @@ struct sqlite3 {
 **      SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNC
 **      SQLITE_CacheSpill    == PAGER_CACHE_SPILL
 */
-#define SQLITE_VdbeTrace      0x00000001  /* True to trace VDBE execution */
-#define SQLITE_InternChanges  0x00000002  /* Uncommitted Hash table changes */
+#define SQLITE_WriteSchema    0x00000001  /* OK to update SQLITE_MASTER */
+#define SQLITE_LegacyFileFmt  0x00000002  /* Create new databases in format 1 */
 #define SQLITE_FullColNames   0x00000004  /* Show full column names on SELECT */
 #define SQLITE_FullFSync      0x00000008  /* Use full fsync on the backend */
 #define SQLITE_CkptFullFSync  0x00000010  /* Use full fsync for checkpoint */
@@ -14227,29 +15202,34 @@ struct sqlite3 {
                                           /*   the count using a callback. */
 #define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */
                                           /*   result set is empty */
-#define SQLITE_SqlTrace       0x00000200  /* Debug print SQL as it executes */
-#define SQLITE_VdbeListing    0x00000400  /* Debug listings of VDBE programs */
-#define SQLITE_WriteSchema    0x00000800  /* OK to update SQLITE_MASTER */
-#define SQLITE_VdbeAddopTrace 0x00001000  /* Trace sqlite3VdbeAddOp() calls */
-#define SQLITE_IgnoreChecks   0x00002000  /* Do not enforce check constraints */
-#define SQLITE_ReadUncommitted 0x0004000  /* For shared-cache mode */
-#define SQLITE_LegacyFileFmt  0x00008000  /* Create new databases in format 1 */
-#define SQLITE_RecoveryMode   0x00010000  /* Ignore schema errors */
-#define SQLITE_ReverseOrder   0x00020000  /* Reverse unordered SELECTs */
-#define SQLITE_RecTriggers    0x00040000  /* Enable recursive triggers */
-#define SQLITE_ForeignKeys    0x00080000  /* Enforce foreign key constraints  */
-#define SQLITE_AutoIndex      0x00100000  /* Enable automatic indexes */
-#define SQLITE_PreferBuiltin  0x00200000  /* Preference to built-in funcs */
-#define SQLITE_LoadExtension  0x00400000  /* Enable load_extension */
-#define SQLITE_LoadExtFunc    0x00800000  /* Enable load_extension() SQL func */
-#define SQLITE_EnableTrigger  0x01000000  /* True to enable triggers */
-#define SQLITE_DeferFKs       0x02000000  /* Defer all FK constraints */
-#define SQLITE_QueryOnly      0x04000000  /* Disable database changes */
-#define SQLITE_VdbeEQP        0x08000000  /* Debug EXPLAIN QUERY PLAN */
-#define SQLITE_Vacuum         0x10000000  /* Currently in a VACUUM */
-#define SQLITE_CellSizeCk     0x20000000  /* Check btree cell sizes on load */
-#define SQLITE_Fts3Tokenizer  0x40000000  /* Enable fts3_tokenizer(2) */
-#define SQLITE_NoCkptOnClose  0x80000000  /* No checkpoint on close()/DETACH */
+#define SQLITE_IgnoreChecks   0x00000200  /* Do not enforce check constraints */
+#define SQLITE_ReadUncommit   0x00000400  /* READ UNCOMMITTED in shared-cache */
+#define SQLITE_NoCkptOnClose  0x00000800  /* No checkpoint on close()/DETACH */
+#define SQLITE_ReverseOrder   0x00001000  /* Reverse unordered SELECTs */
+#define SQLITE_RecTriggers    0x00002000  /* Enable recursive triggers */
+#define SQLITE_ForeignKeys    0x00004000  /* Enforce foreign key constraints  */
+#define SQLITE_AutoIndex      0x00008000  /* Enable automatic indexes */
+#define SQLITE_LoadExtension  0x00010000  /* Enable load_extension */
+#define SQLITE_EnableTrigger  0x00020000  /* True to enable triggers */
+#define SQLITE_DeferFKs       0x00040000  /* Defer all FK constraints */
+#define SQLITE_QueryOnly      0x00080000  /* Disable database changes */
+#define SQLITE_CellSizeCk     0x00100000  /* Check btree cell sizes on load */
+#define SQLITE_Fts3Tokenizer  0x00200000  /* Enable fts3_tokenizer(2) */
+#define SQLITE_EnableQPSG     0x00400000  /* Query Planner Stability Guarantee */
+/* The next four values are not used by PRAGMAs or by sqlite3_dbconfig() and
+** could be factored out into a separate bit vector of the sqlite3 object. */
+#define SQLITE_InternChanges  0x00800000  /* Uncommitted Hash table changes */
+#define SQLITE_LoadExtFunc    0x01000000  /* Enable load_extension() SQL func */
+#define SQLITE_PreferBuiltin  0x02000000  /* Preference to built-in funcs */
+#define SQLITE_Vacuum         0x04000000  /* Currently in a VACUUM */
+/* Flags used only if debugging */
+#ifdef SQLITE_DEBUG
+#define SQLITE_SqlTrace       0x08000000  /* Debug print SQL as it executes */
+#define SQLITE_VdbeListing    0x10000000  /* Debug listings of VDBE programs */
+#define SQLITE_VdbeTrace      0x20000000  /* True to trace VDBE execution */
+#define SQLITE_VdbeAddopTrace 0x40000000  /* Trace sqlite3VdbeAddOp() calls */
+#define SQLITE_VdbeEQP        0x80000000  /* Debug EXPLAIN QUERY PLAN */
+#endif
 
 
 /*
@@ -14269,6 +15249,7 @@ struct sqlite3 {
 #define SQLITE_Transitive     0x0200   /* Transitive constraints */
 #define SQLITE_OmitNoopJoin   0x0400   /* Omit unused tables in joins */
 #define SQLITE_Stat34         0x0800   /* Use STAT3 or STAT4 data */
+#define SQLITE_CountOfView    0x1000   /* The count-of-view optimization */
 #define SQLITE_CursorHints    0x2000   /* Add OP_CursorHint opcodes */
 #define SQLITE_AllOpts        0xffff   /* All optimizations */
 
@@ -14387,7 +15368,14 @@ struct FuncDestructor {
 **     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag and
 **     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functions
 **     and functions like sqlite_version() that can change, but not during
-**     a single query.
+**     a single query.  The iArg is ignored.  The user-data is always set
+**     to a NULL pointer.  The bNC parameter is not used.
+**
+**   PURE_DATE(zName, nArg, iArg, bNC, xFunc)
+**     Used for "pure" date/time functions, this macro is like DFUNCTION
+**     except that it does set the SQLITE_FUNC_CONSTANT flags.  iArg is
+**     ignored and the user-data for these functions is set to an 
+**     arbitrary non-NULL pointer.  The bNC parameter is not used.
 **
 **   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)
 **     Used to create an aggregate function definition implemented by
@@ -14410,8 +15398,11 @@ struct FuncDestructor {
   {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
    SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
 #define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \
-  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
-   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \
+   0, 0, xFunc, 0, #zName, {0} }
+#define PURE_DATE(zName, nArg, iArg, bNC, xFunc) \
+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \
+   (void*)&sqlite3Config, 0, xFunc, 0, #zName, {0} }
 #define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \
   {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\
    SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
@@ -15131,8 +16122,8 @@ struct Expr {
 */
 #define EP_FromJoin  0x000001 /* Originates in ON/USING clause of outer join */
 #define EP_Agg       0x000002 /* Contains one or more aggregate functions */
-#define EP_Resolved  0x000004 /* IDs have been resolved to COLUMNs */
-#define EP_Error     0x000008 /* Expression contains one or more errors */
+                  /* 0x000004 // available for use */
+                  /* 0x000008 // available for use */
 #define EP_Distinct  0x000010 /* Aggregate function with DISTINCT keyword */
 #define EP_VarSelect 0x000020 /* pSelect is correlated, not constant */
 #define EP_DblQuoted 0x000040 /* token.z was originally in "..." */
@@ -15211,6 +16202,7 @@ struct Expr {
 */
 struct ExprList {
   int nExpr;             /* Number of expressions on the list */
+  int nAlloc;            /* Number of a[] slots allocated */
   struct ExprList_item { /* For each expression in the list */
     Expr *pExpr;            /* The parse tree for this expression */
     char *zName;            /* Token associated with this expression */
@@ -15226,7 +16218,7 @@ struct ExprList {
       } x;
       int iConstExprReg;      /* Register in which Expr value is cached */
     } u;
-  } *a;                  /* Alloc a power of two greater or equal to nExpr */
+  } a[1];                  /* One slot for each expression in the list */
 };
 
 /*
@@ -15598,10 +16590,10 @@ struct Select {
 */
 struct SelectDest {
   u8 eDest;            /* How to dispose of the results.  On of SRT_* above. */
-  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */
   int iSDParm;         /* A parameter used by the eDest disposal method */
   int iSdst;           /* Base register where results are written */
   int nSdst;           /* Number of registers allocated */
+  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */
   ExprList *pOrderBy;  /* Key columns for SRT_Queue and SRT_DistQueue */
 };
 
@@ -15711,8 +16703,8 @@ struct Parse {
   int nMem;            /* Number of memory cells used so far */
   int nOpAlloc;        /* Number of slots allocated for Vdbe.aOp[] */
   int szOpAlloc;       /* Bytes of memory space allocated for Vdbe.aOp[] */
-  int ckBase;          /* Base register of data during check constraints */
-  int iSelfTab;        /* Table of an index whose exprs are being coded */
+  int iSelfTab;        /* Table for associated with an index on expr, or negative
+                       ** of the base register during check-constraint eval */
   int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */
   int iCacheCnt;       /* Counter used to generate aColCache[].lru values */
   int nLabel;          /* Number of labels used */
@@ -16083,14 +17075,17 @@ struct Walker {
   int walkerDepth;                          /* Number of subqueries */
   u8 eCode;                                 /* A small processing code */
   union {                                   /* Extra data for callback */
-    NameContext *pNC;                          /* Naming context */
-    int n;                                     /* A counter */
-    int iCur;                                  /* A cursor number */
-    SrcList *pSrcList;                         /* FROM clause */
-    struct SrcCount *pSrcCount;                /* Counting column references */
-    struct CCurHint *pCCurHint;                /* Used by codeCursorHint() */
-    int *aiCol;                                /* array of column indexes */
-    struct IdxCover *pIdxCover;                /* Check for index coverage */
+    NameContext *pNC;                         /* Naming context */
+    int n;                                    /* A counter */
+    int iCur;                                 /* A cursor number */
+    SrcList *pSrcList;                        /* FROM clause */
+    struct SrcCount *pSrcCount;               /* Counting column references */
+    struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */
+    int *aiCol;                               /* array of column indexes */
+    struct IdxCover *pIdxCover;               /* Check for index coverage */
+    struct IdxExprTrans *pIdxTrans;           /* Convert indexed expr to column */
+    ExprList *pGroupBy;                       /* GROUP BY clause */
+    struct HavingToWhereCtx *pHavingCtx;      /* HAVING to WHERE clause ctx */
   } u;
 };
 
@@ -16101,6 +17096,10 @@ SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*);
 SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);
 SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);
 SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*);
+SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker*, Select*);
+#ifdef SQLITE_DEBUG
+SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker*, Select*);
+#endif
 
 /*
 ** Return code from the parse-tree walking primitives and their
@@ -16162,11 +17161,14 @@ SQLITE_PRIVATE int sqlite3CantopenError(int);
 #ifdef SQLITE_DEBUG
 SQLITE_PRIVATE   int sqlite3NomemError(int);
 SQLITE_PRIVATE   int sqlite3IoerrnomemError(int);
+SQLITE_PRIVATE   int sqlite3CorruptPgnoError(int,Pgno);
 # define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)
 # define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)
+# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))
 #else
 # define SQLITE_NOMEM_BKPT SQLITE_NOMEM
 # define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM
+# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)
 #endif
 
 /*
@@ -16244,6 +17246,7 @@ SQLITE_PRIVATE void *sqlite3Realloc(void*, u64);
 SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);
 SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64);
 SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);
+SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3*, void*);
 SQLITE_PRIVATE int sqlite3MallocSize(void*);
 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);
 SQLITE_PRIVATE void *sqlite3ScratchMalloc(int);
@@ -16534,10 +17537,10 @@ SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);
 SQLITE_PRIVATE void sqlite3Vacuum(Parse*,Token*);
 SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*, int);
 SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);
-SQLITE_PRIVATE int sqlite3ExprCompare(Expr*, Expr*, int);
+SQLITE_PRIVATE int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);
 SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);
 SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);
-SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Expr*, Expr*, int);
+SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
 SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
@@ -16551,14 +17554,14 @@ SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*,int);
 SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int);
 SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);
 SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int);
-SQLITE_PRIVATE void sqlite3CommitTransaction(Parse*);
-SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse*);
+SQLITE_PRIVATE void sqlite3EndTransaction(Parse*,int);
 SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);
 SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);
 SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*);
 SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);
 SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);
 SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8);
+SQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);
 SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*,int);
 #ifdef SQLITE_ENABLE_CURSOR_HINTS
 SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr*);
@@ -16672,7 +17675,9 @@ SQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);
 SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);
 SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);
 SQLITE_PRIVATE int sqlite3Atoi(const char*);
+#ifndef SQLITE_OMIT_UTF16
 SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);
+#endif
 SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);
 SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**);
 SQLITE_PRIVATE LogEst sqlite3LogEst(u64);
@@ -16761,7 +17766,9 @@ SQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
 SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*);
 SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);
 SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);
+#ifndef SQLITE_OMIT_UTF16
 SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);
+#endif
 SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);
 SQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
 #ifndef SQLITE_AMALGAMATION
@@ -17125,6 +18132,10 @@ SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr*, int);
 SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int);
 SQLITE_PRIVATE void sqlite3VectorErrorMsg(Parse*, Expr*);
 
+#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
+SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt);
+#endif
+
 #endif /* SQLITEINT_H */
 
 /************** End of sqliteInt.h *******************************************/
@@ -17268,9 +18279,16 @@ SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {
 ** EVIDENCE-OF: R-43642-56306 By default, URI handling is globally
 ** disabled. The default value may be changed by compiling with the
 ** SQLITE_USE_URI symbol defined.
+**
+** URI filenames are enabled by default if SQLITE_HAS_CODEC is
+** enabled.
 */
 #ifndef SQLITE_USE_URI
-# define  SQLITE_USE_URI 0
+# ifdef SQLITE_HAS_CODEC
+#  define SQLITE_USE_URI 1
+# else
+#  define SQLITE_USE_URI 0
+# endif
 #endif
 
 /* EVIDENCE-OF: R-38720-18127 The default setting is determined by the
@@ -17422,472 +18440,6 @@ SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;
 SQLITE_PRIVATE const char sqlite3StrBINARY[] = "BINARY";
 
 /************** End of global.c **********************************************/
-/************** Begin file ctime.c *******************************************/
-/*
-** 2010 February 23
-**
-** The author disclaims copyright to this source code.  In place of
-** a legal notice, here is a blessing:
-**
-**    May you do good and not evil.
-**    May you find forgiveness for yourself and forgive others.
-**    May you share freely, never taking more than you give.
-**
-*************************************************************************
-**
-** This file implements routines used to report what compile-time options
-** SQLite was built with.
-*/
-
-#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
-
-/* #include "sqliteInt.h" */
-
-/*
-** An array of names of all compile-time options.  This array should 
-** be sorted A-Z.
-**
-** This array looks large, but in a typical installation actually uses
-** only a handful of compile-time options, so most times this array is usually
-** rather short and uses little memory space.
-*/
-static const char * const azCompileOpt[] = {
-
-/* These macros are provided to "stringify" the value of the define
-** for those options in which the value is meaningful. */
-#define CTIMEOPT_VAL_(opt) #opt
-#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)
-
-#if SQLITE_32BIT_ROWID
-  "32BIT_ROWID",
-#endif
-#if SQLITE_4_BYTE_ALIGNED_MALLOC
-  "4_BYTE_ALIGNED_MALLOC",
-#endif
-#if SQLITE_CASE_SENSITIVE_LIKE
-  "CASE_SENSITIVE_LIKE",
-#endif
-#if SQLITE_CHECK_PAGES
-  "CHECK_PAGES",
-#endif
-#if defined(__clang__) && defined(__clang_major__)
-  "COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."
-                    CTIMEOPT_VAL(__clang_minor__) "."
-                    CTIMEOPT_VAL(__clang_patchlevel__),
-#elif defined(_MSC_VER)
-  "COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),
-#elif defined(__GNUC__) && defined(__VERSION__)
-  "COMPILER=gcc-" __VERSION__,
-#endif
-#if SQLITE_COVERAGE_TEST
-  "COVERAGE_TEST",
-#endif
-#ifdef SQLITE_DEBUG
-  "DEBUG",
-#endif
-#if SQLITE_DEFAULT_LOCKING_MODE
-  "DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),
-#endif
-#if defined(SQLITE_DEFAULT_MMAP_SIZE) && !defined(SQLITE_DEFAULT_MMAP_SIZE_xc)
-  "DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),
-#endif
-#if SQLITE_DEFAULT_SYNCHRONOUS
-  "DEFAULT_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),
-#endif
-#if SQLITE_DEFAULT_WAL_SYNCHRONOUS
-  "DEFAULT_WAL_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),
-#endif
-#if SQLITE_DIRECT_OVERFLOW_READ
-  "DIRECT_OVERFLOW_READ",
-#endif
-#if SQLITE_DISABLE_DIRSYNC
-  "DISABLE_DIRSYNC",
-#endif
-#if SQLITE_DISABLE_LFS
-  "DISABLE_LFS",
-#endif
-#if SQLITE_ENABLE_8_3_NAMES
-  "ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),
-#endif
-#if SQLITE_ENABLE_API_ARMOR
-  "ENABLE_API_ARMOR",
-#endif
-#if SQLITE_ENABLE_ATOMIC_WRITE
-  "ENABLE_ATOMIC_WRITE",
-#endif
-#if SQLITE_ENABLE_CEROD
-  "ENABLE_CEROD",
-#endif
-#if SQLITE_ENABLE_COLUMN_METADATA
-  "ENABLE_COLUMN_METADATA",
-#endif
-#if SQLITE_ENABLE_DBSTAT_VTAB
-  "ENABLE_DBSTAT_VTAB",
-#endif
-#if SQLITE_ENABLE_EXPENSIVE_ASSERT
-  "ENABLE_EXPENSIVE_ASSERT",
-#endif
-#if SQLITE_ENABLE_FTS1
-  "ENABLE_FTS1",
-#endif
-#if SQLITE_ENABLE_FTS2
-  "ENABLE_FTS2",
-#endif
-#if SQLITE_ENABLE_FTS3
-  "ENABLE_FTS3",
-#endif
-#if SQLITE_ENABLE_FTS3_PARENTHESIS
-  "ENABLE_FTS3_PARENTHESIS",
-#endif
-#if SQLITE_ENABLE_FTS4
-  "ENABLE_FTS4",
-#endif
-#if SQLITE_ENABLE_FTS5
-  "ENABLE_FTS5",
-#endif
-#if SQLITE_ENABLE_ICU
-  "ENABLE_ICU",
-#endif
-#if SQLITE_ENABLE_IOTRACE
-  "ENABLE_IOTRACE",
-#endif
-#if SQLITE_ENABLE_JSON1
-  "ENABLE_JSON1",
-#endif
-#if SQLITE_ENABLE_LOAD_EXTENSION
-  "ENABLE_LOAD_EXTENSION",
-#endif
-#if SQLITE_ENABLE_LOCKING_STYLE
-  "ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),
-#endif
-#if SQLITE_ENABLE_MEMORY_MANAGEMENT
-  "ENABLE_MEMORY_MANAGEMENT",
-#endif
-#if SQLITE_ENABLE_MEMSYS3
-  "ENABLE_MEMSYS3",
-#endif
-#if SQLITE_ENABLE_MEMSYS5
-  "ENABLE_MEMSYS5",
-#endif
-#if SQLITE_ENABLE_OVERSIZE_CELL_CHECK
-  "ENABLE_OVERSIZE_CELL_CHECK",
-#endif
-#if SQLITE_ENABLE_RTREE
-  "ENABLE_RTREE",
-#endif
-#if defined(SQLITE_ENABLE_STAT4)
-  "ENABLE_STAT4",
-#elif defined(SQLITE_ENABLE_STAT3)
-  "ENABLE_STAT3",
-#endif
-#if SQLITE_ENABLE_UNLOCK_NOTIFY
-  "ENABLE_UNLOCK_NOTIFY",
-#endif
-#if SQLITE_ENABLE_UPDATE_DELETE_LIMIT
-  "ENABLE_UPDATE_DELETE_LIMIT",
-#endif
-#if defined(SQLITE_ENABLE_URI_00_ERROR)
-  "ENABLE_URI_00_ERROR",
-#endif
-#if SQLITE_HAS_CODEC
-  "HAS_CODEC",
-#endif
-#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
-  "HAVE_ISNAN",
-#endif
-#if SQLITE_HOMEGROWN_RECURSIVE_MUTEX
-  "HOMEGROWN_RECURSIVE_MUTEX",
-#endif
-#if SQLITE_IGNORE_AFP_LOCK_ERRORS
-  "IGNORE_AFP_LOCK_ERRORS",
-#endif
-#if SQLITE_IGNORE_FLOCK_LOCK_ERRORS
-  "IGNORE_FLOCK_LOCK_ERRORS",
-#endif
-#ifdef SQLITE_INT64_TYPE
-  "INT64_TYPE",
-#endif
-#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
-  "LIKE_DOESNT_MATCH_BLOBS",
-#endif
-#if SQLITE_LOCK_TRACE
-  "LOCK_TRACE",
-#endif
-#if defined(SQLITE_MAX_MMAP_SIZE) && !defined(SQLITE_MAX_MMAP_SIZE_xc)
-  "MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),
-#endif
-#ifdef SQLITE_MAX_SCHEMA_RETRY
-  "MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),
-#endif
-#if SQLITE_MEMDEBUG
-  "MEMDEBUG",
-#endif
-#if SQLITE_MIXED_ENDIAN_64BIT_FLOAT
-  "MIXED_ENDIAN_64BIT_FLOAT",
-#endif
-#if SQLITE_NO_SYNC
-  "NO_SYNC",
-#endif
-#if SQLITE_OMIT_ALTERTABLE
-  "OMIT_ALTERTABLE",
-#endif
-#if SQLITE_OMIT_ANALYZE
-  "OMIT_ANALYZE",
-#endif
-#if SQLITE_OMIT_ATTACH
-  "OMIT_ATTACH",
-#endif
-#if SQLITE_OMIT_AUTHORIZATION
-  "OMIT_AUTHORIZATION",
-#endif
-#if SQLITE_OMIT_AUTOINCREMENT
-  "OMIT_AUTOINCREMENT",
-#endif
-#if SQLITE_OMIT_AUTOINIT
-  "OMIT_AUTOINIT",
-#endif
-#if SQLITE_OMIT_AUTOMATIC_INDEX
-  "OMIT_AUTOMATIC_INDEX",
-#endif
-#if SQLITE_OMIT_AUTORESET
-  "OMIT_AUTORESET",
-#endif
-#if SQLITE_OMIT_AUTOVACUUM
-  "OMIT_AUTOVACUUM",
-#endif
-#if SQLITE_OMIT_BETWEEN_OPTIMIZATION
-  "OMIT_BETWEEN_OPTIMIZATION",
-#endif
-#if SQLITE_OMIT_BLOB_LITERAL
-  "OMIT_BLOB_LITERAL",
-#endif
-#if SQLITE_OMIT_BTREECOUNT
-  "OMIT_BTREECOUNT",
-#endif
-#if SQLITE_OMIT_CAST
-  "OMIT_CAST",
-#endif
-#if SQLITE_OMIT_CHECK
-  "OMIT_CHECK",
-#endif
-#if SQLITE_OMIT_COMPLETE
-  "OMIT_COMPLETE",
-#endif
-#if SQLITE_OMIT_COMPOUND_SELECT
-  "OMIT_COMPOUND_SELECT",
-#endif
-#if SQLITE_OMIT_CTE
-  "OMIT_CTE",
-#endif
-#if SQLITE_OMIT_DATETIME_FUNCS
-  "OMIT_DATETIME_FUNCS",
-#endif
-#if SQLITE_OMIT_DECLTYPE
-  "OMIT_DECLTYPE",
-#endif
-#if SQLITE_OMIT_DEPRECATED
-  "OMIT_DEPRECATED",
-#endif
-#if SQLITE_OMIT_DISKIO
-  "OMIT_DISKIO",
-#endif
-#if SQLITE_OMIT_EXPLAIN
-  "OMIT_EXPLAIN",
-#endif
-#if SQLITE_OMIT_FLAG_PRAGMAS
-  "OMIT_FLAG_PRAGMAS",
-#endif
-#if SQLITE_OMIT_FLOATING_POINT
-  "OMIT_FLOATING_POINT",
-#endif
-#if SQLITE_OMIT_FOREIGN_KEY
-  "OMIT_FOREIGN_KEY",
-#endif
-#if SQLITE_OMIT_GET_TABLE
-  "OMIT_GET_TABLE",
-#endif
-#if SQLITE_OMIT_INCRBLOB
-  "OMIT_INCRBLOB",
-#endif
-#if SQLITE_OMIT_INTEGRITY_CHECK
-  "OMIT_INTEGRITY_CHECK",
-#endif
-#if SQLITE_OMIT_LIKE_OPTIMIZATION
-  "OMIT_LIKE_OPTIMIZATION",
-#endif
-#if SQLITE_OMIT_LOAD_EXTENSION
-  "OMIT_LOAD_EXTENSION",
-#endif
-#if SQLITE_OMIT_LOCALTIME
-  "OMIT_LOCALTIME",
-#endif
-#if SQLITE_OMIT_LOOKASIDE
-  "OMIT_LOOKASIDE",
-#endif
-#if SQLITE_OMIT_MEMORYDB
-  "OMIT_MEMORYDB",
-#endif
-#if SQLITE_OMIT_OR_OPTIMIZATION
-  "OMIT_OR_OPTIMIZATION",
-#endif
-#if SQLITE_OMIT_PAGER_PRAGMAS
-  "OMIT_PAGER_PRAGMAS",
-#endif
-#if SQLITE_OMIT_PRAGMA
-  "OMIT_PRAGMA",
-#endif
-#if SQLITE_OMIT_PROGRESS_CALLBACK
-  "OMIT_PROGRESS_CALLBACK",
-#endif
-#if SQLITE_OMIT_QUICKBALANCE
-  "OMIT_QUICKBALANCE",
-#endif
-#if SQLITE_OMIT_REINDEX
-  "OMIT_REINDEX",
-#endif
-#if SQLITE_OMIT_SCHEMA_PRAGMAS
-  "OMIT_SCHEMA_PRAGMAS",
-#endif
-#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
-  "OMIT_SCHEMA_VERSION_PRAGMAS",
-#endif
-#if SQLITE_OMIT_SHARED_CACHE
-  "OMIT_SHARED_CACHE",
-#endif
-#if SQLITE_OMIT_SUBQUERY
-  "OMIT_SUBQUERY",
-#endif
-#if SQLITE_OMIT_TCL_VARIABLE
-  "OMIT_TCL_VARIABLE",
-#endif
-#if SQLITE_OMIT_TEMPDB
-  "OMIT_TEMPDB",
-#endif
-#if SQLITE_OMIT_TRACE
-  "OMIT_TRACE",
-#endif
-#if SQLITE_OMIT_TRIGGER
-  "OMIT_TRIGGER",
-#endif
-#if SQLITE_OMIT_TRUNCATE_OPTIMIZATION
-  "OMIT_TRUNCATE_OPTIMIZATION",
-#endif
-#if SQLITE_OMIT_UTF16
-  "OMIT_UTF16",
-#endif
-#if SQLITE_OMIT_VACUUM
-  "OMIT_VACUUM",
-#endif
-#if SQLITE_OMIT_VIEW
-  "OMIT_VIEW",
-#endif
-#if SQLITE_OMIT_VIRTUALTABLE
-  "OMIT_VIRTUALTABLE",
-#endif
-#if SQLITE_OMIT_WAL
-  "OMIT_WAL",
-#endif
-#if SQLITE_OMIT_WSD
-  "OMIT_WSD",
-#endif
-#if SQLITE_OMIT_XFER_OPT
-  "OMIT_XFER_OPT",
-#endif
-#if SQLITE_PERFORMANCE_TRACE
-  "PERFORMANCE_TRACE",
-#endif
-#if SQLITE_PROXY_DEBUG
-  "PROXY_DEBUG",
-#endif
-#if SQLITE_RTREE_INT_ONLY
-  "RTREE_INT_ONLY",
-#endif
-#if SQLITE_SECURE_DELETE
-  "SECURE_DELETE",
-#endif
-#if SQLITE_SMALL_STACK
-  "SMALL_STACK",
-#endif
-#if SQLITE_SOUNDEX
-  "SOUNDEX",
-#endif
-#if SQLITE_SYSTEM_MALLOC
-  "SYSTEM_MALLOC",
-#endif
-#if SQLITE_TCL
-  "TCL",
-#endif
-#if defined(SQLITE_TEMP_STORE) && !defined(SQLITE_TEMP_STORE_xc)
-  "TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),
-#endif
-#if SQLITE_TEST
-  "TEST",
-#endif
-#if defined(SQLITE_THREADSAFE)
-  "THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),
-#endif
-#if SQLITE_UNTESTABLE
-  "UNTESTABLE"
-#endif
-#if SQLITE_USE_ALLOCA
-  "USE_ALLOCA",
-#endif
-#if SQLITE_USER_AUTHENTICATION
-  "USER_AUTHENTICATION",
-#endif
-#if SQLITE_WIN32_MALLOC
-  "WIN32_MALLOC",
-#endif
-#if SQLITE_ZERO_MALLOC
-  "ZERO_MALLOC"
-#endif
-};
-
-/*
-** Given the name of a compile-time option, return true if that option
-** was used and false if not.
-**
-** The name can optionally begin with "SQLITE_" but the "SQLITE_" prefix
-** is not required for a match.
-*/
-SQLITE_API int sqlite3_compileoption_used(const char *zOptName){
-  int i, n;
-
-#if SQLITE_ENABLE_API_ARMOR
-  if( zOptName==0 ){
-    (void)SQLITE_MISUSE_BKPT;
-    return 0;
-  }
-#endif
-  if( sqlite3StrNICmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;
-  n = sqlite3Strlen30(zOptName);
-
-  /* Since ArraySize(azCompileOpt) is normally in single digits, a
-  ** linear search is adequate.  No need for a binary search. */
-  for(i=0; i<ArraySize(azCompileOpt); i++){
-    if( sqlite3StrNICmp(zOptName, azCompileOpt[i], n)==0
-     && sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0
-    ){
-      return 1;
-    }
-  }
-  return 0;
-}
-
-/*
-** Return the N-th compile-time option string.  If N is out of range,
-** return a NULL pointer.
-*/
-SQLITE_API const char *sqlite3_compileoption_get(int N){
-  if( N>=0 && N<ArraySize(azCompileOpt) ){
-    return azCompileOpt[N];
-  }
-  return 0;
-}
-
-#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
-
-/************** End of ctime.c ***********************************************/
 /************** Begin file status.c ******************************************/
 /*
 ** 2008 June 18
@@ -18094,11 +18646,12 @@ struct VdbeFrame {
 ** structures. Each Mem struct may cache multiple representations (string,
 ** integer etc.) of the same value.
 */
-struct Mem {
+struct sqlite3_value {
   union MemValue {
     double r;           /* Real value used when MEM_Real is set in flags */
     i64 i;              /* Integer value used when MEM_Int is set in flags */
-    int nZero;          /* Used when bit MEM_Zero is set in flags */
+    int nZero;          /* Extra zero bytes when MEM_Zero and MEM_Blob set */
+    const char *zPType; /* Pointer type when MEM_Term|MEM_Subtype|MEM_Null */
     FuncDef *pDef;      /* Used only when flags==MEM_Agg */
     RowSet *pRowSet;    /* Used only when flags==MEM_RowSet */
     VdbeFrame *pFrame;  /* Used when flags==MEM_Frame */
@@ -18130,7 +18683,8 @@ struct Mem {
 ** representations of the value stored in the Mem struct.
 **
 ** If the MEM_Null flag is set, then the value is an SQL NULL value.
-** No other flags may be set in this case.
+** For a pointer type created using sqlite3_bind_pointer() or
+** sqlite3_result_pointer() the MEM_Term and MEM_Subtype flags are also set.
 **
 ** If the MEM_Str flag is set then Mem.z points at a string representation.
 ** Usually this is encoded in the same unicode encoding as the main
@@ -18138,7 +18692,7 @@ struct Mem {
 ** set, then the string is nul terminated. The MEM_Int and MEM_Real 
 ** flags may coexist with the MEM_Str flag.
 */
-#define MEM_Null      0x0001   /* Value is NULL */
+#define MEM_Null      0x0001   /* Value is NULL (or a pointer) */
 #define MEM_Str       0x0002   /* Value is a string */
 #define MEM_Int       0x0004   /* Value is an integer */
 #define MEM_Real      0x0008   /* Value is a real number */
@@ -18148,7 +18702,7 @@ struct Mem {
 #define MEM_Frame     0x0040   /* Value is a VdbeFrame object */
 #define MEM_Undefined 0x0080   /* Value is undefined */
 #define MEM_Cleared   0x0100   /* NULL set by OP_Null, not from data */
-#define MEM_TypeMask  0x81ff   /* Mask of type bits */
+#define MEM_TypeMask  0xc1ff   /* Mask of type bits */
 
 
 /* Whenever Mem contains a valid string or blob representation, one of
@@ -18156,7 +18710,7 @@ struct Mem {
 ** policy for Mem.z.  The MEM_Term flag tells us whether or not the
 ** string is \000 or \u0000 terminated
 */
-#define MEM_Term      0x0200   /* String rep is nul terminated */
+#define MEM_Term      0x0200   /* String in Mem.z is zero terminated */
 #define MEM_Dyn       0x0400   /* Need to call Mem.xDel() on Mem.z */
 #define MEM_Static    0x0800   /* Mem.z points to a static string */
 #define MEM_Ephem     0x1000   /* Mem.z points to an ephemeral string */
@@ -18196,11 +18750,11 @@ struct Mem {
 ** when the VM is halted (if not before).
 */
 struct AuxData {
-  int iOp;                        /* Instruction number of OP_Function opcode */
-  int iArg;                       /* Index of function argument. */
+  int iAuxOp;                     /* Instruction number of OP_Function opcode */
+  int iAuxArg;                    /* Index of function argument. */
   void *pAux;                     /* Aux data pointer */
-  void (*xDelete)(void *);        /* Destructor for the aux data */
-  AuxData *pNext;                 /* Next element in list */
+  void (*xDeleteAux)(void*);      /* Destructor for the aux data */
+  AuxData *pNextAux;              /* Next element in list */
 };
 
 /*
@@ -18291,6 +18845,7 @@ struct Vdbe {
   u16 nResColumn;         /* Number of columns in one row of the result set */
   u8 errorAction;         /* Recovery action to do in case of an error */
   u8 minWriteFileFormat;  /* Minimum file format for writable database files */
+  u8 prepFlags;           /* SQLITE_PREPARE_* flags */
   bft expired:1;          /* True if the VM needs to be recompiled */
   bft doingRerun:1;       /* True if rerunning after an auto-reprepare */
   bft explain:2;          /* True if EXPLAIN present on SQL command */
@@ -18299,10 +18854,9 @@ struct Vdbe {
   bft usesStmtJournal:1;  /* True if uses a statement journal */
   bft readOnly:1;         /* True for statements that do not write */
   bft bIsReader:1;        /* True for statements that read */
-  bft isPrepareV2:1;      /* True if prepared with prepare_v2() */
   yDbMask btreeMask;      /* Bitmask of db->aDb[] entries referenced */
   yDbMask lockMask;       /* Subset of btreeMask that requires a lock */
-  u32 aCounter[5];        /* Counters used by sqlite3_stmt_status() */
+  u32 aCounter[7];        /* Counters used by sqlite3_stmt_status() */
   char *zSql;             /* Text of the SQL statement that generated this */
   void *pFree;            /* Free this when deleting the vdbe */
   VdbeFrame *pFrame;      /* Parent frame */
@@ -18384,6 +18938,7 @@ SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);
 #else
 SQLITE_PRIVATE   void sqlite3VdbeMemSetDouble(Mem*, double);
 #endif
+SQLITE_PRIVATE void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));
 SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem*,sqlite3*,u16);
 SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);
 SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int);
@@ -18415,7 +18970,7 @@ SQLITE_PRIVATE int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);
 SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);
 SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);
 SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);
-SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *, int *);
+SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);
 SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);
 SQLITE_PRIVATE int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);
 SQLITE_PRIVATE int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);
@@ -18443,12 +18998,14 @@ SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);
 # define sqlite3VdbeCheckFk(p,i) 0
 #endif
 
-SQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem*, u8);
 #ifdef SQLITE_DEBUG
 SQLITE_PRIVATE   void sqlite3VdbePrintSql(Vdbe*);
 SQLITE_PRIVATE   void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf);
 #endif
-SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem);
+#ifndef SQLITE_OMIT_UTF16
+SQLITE_PRIVATE   int sqlite3VdbeMemTranslate(Mem*, u8);
+SQLITE_PRIVATE   int sqlite3VdbeMemHandleBom(Mem *pMem);
+#endif
 
 #ifndef SQLITE_OMIT_INCRBLOB
 SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);
@@ -19187,7 +19744,7 @@ static int parseDateOrTime(
     return 0;
   }else if( parseHhMmSs(zDate, p)==0 ){
     return 0;
-  }else if( sqlite3StrICmp(zDate,"now")==0){
+  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){
     return setDateTimeToCurrent(context, p);
   }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8) ){
     setRawDateNumber(p, r);
@@ -19224,8 +19781,10 @@ static void computeYMD(DateTime *p){
     p->Y = 2000;
     p->M = 1;
     p->D = 1;
+  }else if( !validJulianDay(p->iJD) ){
+    datetimeError(p);
+    return;
   }else{
-    assert( validJulianDay(p->iJD) );
     Z = (int)((p->iJD + 43200000)/86400000);
     A = (int)((Z - 1867216.25)/36524.25);
     A = Z + 1 + A - (A/4);
@@ -19468,7 +20027,7 @@ static int parseModifier(
       ** Assuming the current time value is UTC (a.k.a. GMT), shift it to
       ** show local time.
       */
-      if( sqlite3_stricmp(z, "localtime")==0 ){
+      if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){
         computeJD(p);
         p->iJD += localtimeOffset(p, pCtx, &rc);
         clearYMD_HMS_TZ(p);
@@ -19494,7 +20053,7 @@ static int parseModifier(
         }
       }
 #ifndef SQLITE_OMIT_LOCALTIME
-      else if( sqlite3_stricmp(z, "utc")==0 ){
+      else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){
         if( p->tzSet==0 ){
           sqlite3_int64 c1;
           computeJD(p);
@@ -20030,11 +20589,11 @@ static void currentTimeFunc(
 SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){
   static FuncDef aDateTimeFuncs[] = {
 #ifndef SQLITE_OMIT_DATETIME_FUNCS
-    DFUNCTION(julianday,        -1, 0, 0, juliandayFunc ),
-    DFUNCTION(date,             -1, 0, 0, dateFunc      ),
-    DFUNCTION(time,             -1, 0, 0, timeFunc      ),
-    DFUNCTION(datetime,         -1, 0, 0, datetimeFunc  ),
-    DFUNCTION(strftime,         -1, 0, 0, strftimeFunc  ),
+    PURE_DATE(julianday,        -1, 0, 0, juliandayFunc ),
+    PURE_DATE(date,             -1, 0, 0, dateFunc      ),
+    PURE_DATE(time,             -1, 0, 0, timeFunc      ),
+    PURE_DATE(datetime,         -1, 0, 0, datetimeFunc  ),
+    PURE_DATE(strftime,         -1, 0, 0, strftimeFunc  ),
     DFUNCTION(current_time,      0, 0, 0, ctimeFunc     ),
     DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),
     DFUNCTION(current_date,      0, 0, 0, cdateFunc     ),
@@ -24661,11 +25220,12 @@ static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){
 
 /*
 ** Free memory that might be associated with a particular database
-** connection.
+** connection.  Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.
+** The sqlite3DbFreeNN(D,X) version requires that X be non-NULL.
 */
-SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
+SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){
   assert( db==0 || sqlite3_mutex_held(db->mutex) );
-  if( p==0 ) return;
+  assert( p!=0 );
   if( db ){
     if( db->pnBytesFreed ){
       measureAllocationSize(db, p);
@@ -24689,6 +25249,10 @@ SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
   sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
   sqlite3_free(p);
 }
+SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
+  assert( db==0 || sqlite3_mutex_held(db->mutex) );
+  if( p ) sqlite3DbFreeNN(db, p);
+}
 
 /*
 ** Change the size of an existing memory allocation
@@ -26381,7 +26945,7 @@ SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 m
 SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){
   const char *zBinOp = 0;   /* Binary operator */
   const char *zUniOp = 0;   /* Unary operator */
-  char zFlgs[30];
+  char zFlgs[60];
   pView = sqlite3TreeViewPush(pView, moreToFollow);
   if( pExpr==0 ){
     sqlite3TreeViewLine(pView, "nil");
@@ -26389,7 +26953,12 @@ SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 m
     return;
   }
   if( pExpr->flags ){
-    sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);
+    if( ExprHasProperty(pExpr, EP_FromJoin) ){
+      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x iRJT=%d",
+                       pExpr->flags, pExpr->iRightJoinTable);
+    }else{
+      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);
+    }
   }else{
     zFlgs[0] = 0;
   }
@@ -26520,17 +27089,17 @@ SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 m
     }
 #ifndef SQLITE_OMIT_SUBQUERY
     case TK_EXISTS: {
-      sqlite3TreeViewLine(pView, "EXISTS-expr");
+      sqlite3TreeViewLine(pView, "EXISTS-expr flags=0x%x", pExpr->flags);
       sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
       break;
     }
     case TK_SELECT: {
-      sqlite3TreeViewLine(pView, "SELECT-expr");
+      sqlite3TreeViewLine(pView, "SELECT-expr flags=0x%x", pExpr->flags);
       sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
       break;
     }
     case TK_IN: {
-      sqlite3TreeViewLine(pView, "IN");
+      sqlite3TreeViewLine(pView, "IN flags=0x%x", pExpr->flags);
       sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
       if( ExprHasProperty(pExpr, EP_xIsSelect) ){
         sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
@@ -26608,6 +27177,11 @@ SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 m
       sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);
       break;
     }
+    case TK_IF_NULL_ROW: {
+      sqlite3TreeViewLine(pView, "IF-NULL-ROW %d", pExpr->iTable);
+      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
+      break;
+    }
     default: {
       sqlite3TreeViewLine(pView, "op=%d", pExpr->op);
       break;
@@ -27413,7 +27987,9 @@ SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desired
 #endif
   return SQLITE_OK;
 }
+#endif /* SQLITE_OMIT_UTF16 */
 
+#ifndef SQLITE_OMIT_UTF16
 /*
 ** This routine checks for a byte-order mark at the beginning of the 
 ** UTF-16 string stored in *pMem. If one is present, it is removed and
@@ -28327,6 +28903,7 @@ SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){
     }
   }
 #endif
+  if( !sqlite3Isdigit(zNum[0]) ) return 0;
   while( zNum[0]=='0' ) zNum++;
   for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
     v = v*10 + c;
@@ -29323,8 +29900,9 @@ static int rehash(Hash *pH, unsigned int new_size){
 }
 
 /* This function (for internal use only) locates an element in an
-** hash table that matches the given key.  The hash for this key is
-** also computed and returned in the *pH parameter.
+** hash table that matches the given key.  If no element is found,
+** a pointer to a static null element with HashElem.data==0 is returned.
+** If pH is not NULL, then the hash for this key is written to *pH.
 */
 static HashElem *findElementWithHash(
   const Hash *pH,     /* The pH to be searched */
@@ -29334,6 +29912,7 @@ static HashElem *findElementWithHash(
   HashElem *elem;                /* Used to loop thru the element list */
   int count;                     /* Number of elements left to test */
   unsigned int h;                /* The computed hash */
+  static HashElem nullElement = { 0, 0, 0, 0 };
 
   if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/
     struct _ht *pEntry;
@@ -29346,7 +29925,7 @@ static HashElem *findElementWithHash(
     elem = pH->first;
     count = pH->count;
   }
-  *pHash = h;
+  if( pHash ) *pHash = h;
   while( count-- ){
     assert( elem!=0 );
     if( sqlite3StrICmp(elem->pKey,pKey)==0 ){ 
@@ -29354,7 +29933,7 @@ static HashElem *findElementWithHash(
     }
     elem = elem->next;
   }
-  return 0;
+  return &nullElement;
 }
 
 /* Remove a single entry from the hash table given a pointer to that
@@ -29396,13 +29975,9 @@ static void removeElementGivenHash(
 ** found, or NULL if there is no match.
 */
 SQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey){
-  HashElem *elem;    /* The element that matches key */
-  unsigned int h;    /* A hash on key */
-
   assert( pH!=0 );
   assert( pKey!=0 );
-  elem = findElementWithHash(pH, pKey, &h);
-  return elem ? elem->data : 0;
+  return findElementWithHash(pH, pKey, 0)->data;
 }
 
 /* Insert an element into the hash table pH.  The key is pKey
@@ -29427,7 +30002,7 @@ SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){
   assert( pH!=0 );
   assert( pKey!=0 );
   elem = findElementWithHash(pH,pKey,&h);
-  if( elem ){
+  if( elem->data ){
     void *old_data = elem->data;
     if( data==0 ){
       removeElementGivenHash(pH,elem,h);
@@ -29490,90 +30065,90 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
     /*  20 */ "Once"             OpHelp(""),
     /*  21 */ "If"               OpHelp(""),
     /*  22 */ "IfNot"            OpHelp(""),
-    /*  23 */ "SeekLT"           OpHelp("key=r[P3@P4]"),
-    /*  24 */ "SeekLE"           OpHelp("key=r[P3@P4]"),
-    /*  25 */ "SeekGE"           OpHelp("key=r[P3@P4]"),
-    /*  26 */ "SeekGT"           OpHelp("key=r[P3@P4]"),
-    /*  27 */ "Or"               OpHelp("r[P3]=(r[P1] || r[P2])"),
-    /*  28 */ "And"              OpHelp("r[P3]=(r[P1] && r[P2])"),
-    /*  29 */ "NoConflict"       OpHelp("key=r[P3@P4]"),
-    /*  30 */ "NotFound"         OpHelp("key=r[P3@P4]"),
-    /*  31 */ "Found"            OpHelp("key=r[P3@P4]"),
-    /*  32 */ "SeekRowid"        OpHelp("intkey=r[P3]"),
-    /*  33 */ "NotExists"        OpHelp("intkey=r[P3]"),
-    /*  34 */ "IsNull"           OpHelp("if r[P1]==NULL goto P2"),
-    /*  35 */ "NotNull"          OpHelp("if r[P1]!=NULL goto P2"),
-    /*  36 */ "Ne"               OpHelp("IF r[P3]!=r[P1]"),
-    /*  37 */ "Eq"               OpHelp("IF r[P3]==r[P1]"),
-    /*  38 */ "Gt"               OpHelp("IF r[P3]>r[P1]"),
-    /*  39 */ "Le"               OpHelp("IF r[P3]<=r[P1]"),
-    /*  40 */ "Lt"               OpHelp("IF r[P3]<r[P1]"),
-    /*  41 */ "Ge"               OpHelp("IF r[P3]>=r[P1]"),
-    /*  42 */ "ElseNotEq"        OpHelp(""),
-    /*  43 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),
-    /*  44 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),
-    /*  45 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),
-    /*  46 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),
-    /*  47 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),
-    /*  48 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),
-    /*  49 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),
-    /*  50 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),
-    /*  51 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),
-    /*  52 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
-    /*  53 */ "Last"             OpHelp(""),
-    /*  54 */ "BitNot"           OpHelp("r[P1]= ~r[P1]"),
-    /*  55 */ "IfSmaller"        OpHelp(""),
-    /*  56 */ "SorterSort"       OpHelp(""),
-    /*  57 */ "Sort"             OpHelp(""),
-    /*  58 */ "Rewind"           OpHelp(""),
-    /*  59 */ "IdxLE"            OpHelp("key=r[P3@P4]"),
-    /*  60 */ "IdxGT"            OpHelp("key=r[P3@P4]"),
-    /*  61 */ "IdxLT"            OpHelp("key=r[P3@P4]"),
-    /*  62 */ "IdxGE"            OpHelp("key=r[P3@P4]"),
-    /*  63 */ "RowSetRead"       OpHelp("r[P3]=rowset(P1)"),
-    /*  64 */ "RowSetTest"       OpHelp("if r[P3] in rowset(P1) goto P2"),
-    /*  65 */ "Program"          OpHelp(""),
-    /*  66 */ "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),
-    /*  67 */ "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),
-    /*  68 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]--, goto P2"),
-    /*  69 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),
-    /*  70 */ "IncrVacuum"       OpHelp(""),
-    /*  71 */ "VNext"            OpHelp(""),
-    /*  72 */ "Init"             OpHelp("Start at P2"),
-    /*  73 */ "Return"           OpHelp(""),
-    /*  74 */ "EndCoroutine"     OpHelp(""),
-    /*  75 */ "HaltIfNull"       OpHelp("if r[P3]=null halt"),
-    /*  76 */ "Halt"             OpHelp(""),
-    /*  77 */ "Integer"          OpHelp("r[P2]=P1"),
-    /*  78 */ "Int64"            OpHelp("r[P2]=P4"),
-    /*  79 */ "String"           OpHelp("r[P2]='P4' (len=P1)"),
-    /*  80 */ "Null"             OpHelp("r[P2..P3]=NULL"),
-    /*  81 */ "SoftNull"         OpHelp("r[P1]=NULL"),
-    /*  82 */ "Blob"             OpHelp("r[P2]=P4 (len=P1)"),
-    /*  83 */ "Variable"         OpHelp("r[P2]=parameter(P1,P4)"),
-    /*  84 */ "Move"             OpHelp("r[P2@P3]=r[P1@P3]"),
-    /*  85 */ "Copy"             OpHelp("r[P2@P3+1]=r[P1@P3+1]"),
-    /*  86 */ "SCopy"            OpHelp("r[P2]=r[P1]"),
-    /*  87 */ "IntCopy"          OpHelp("r[P2]=r[P1]"),
-    /*  88 */ "ResultRow"        OpHelp("output=r[P1@P2]"),
-    /*  89 */ "CollSeq"          OpHelp(""),
-    /*  90 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),
-    /*  91 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),
-    /*  92 */ "AddImm"           OpHelp("r[P1]=r[P1]+P2"),
-    /*  93 */ "RealAffinity"     OpHelp(""),
-    /*  94 */ "Cast"             OpHelp("affinity(r[P1])"),
-    /*  95 */ "Permutation"      OpHelp(""),
-    /*  96 */ "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),
+    /*  23 */ "IfNullRow"        OpHelp("if P1.nullRow then r[P3]=NULL, goto P2"),
+    /*  24 */ "SeekLT"           OpHelp("key=r[P3@P4]"),
+    /*  25 */ "SeekLE"           OpHelp("key=r[P3@P4]"),
+    /*  26 */ "SeekGE"           OpHelp("key=r[P3@P4]"),
+    /*  27 */ "SeekGT"           OpHelp("key=r[P3@P4]"),
+    /*  28 */ "NoConflict"       OpHelp("key=r[P3@P4]"),
+    /*  29 */ "NotFound"         OpHelp("key=r[P3@P4]"),
+    /*  30 */ "Found"            OpHelp("key=r[P3@P4]"),
+    /*  31 */ "SeekRowid"        OpHelp("intkey=r[P3]"),
+    /*  32 */ "NotExists"        OpHelp("intkey=r[P3]"),
+    /*  33 */ "Last"             OpHelp(""),
+    /*  34 */ "IfSmaller"        OpHelp(""),
+    /*  35 */ "SorterSort"       OpHelp(""),
+    /*  36 */ "Sort"             OpHelp(""),
+    /*  37 */ "Rewind"           OpHelp(""),
+    /*  38 */ "IdxLE"            OpHelp("key=r[P3@P4]"),
+    /*  39 */ "IdxGT"            OpHelp("key=r[P3@P4]"),
+    /*  40 */ "IdxLT"            OpHelp("key=r[P3@P4]"),
+    /*  41 */ "IdxGE"            OpHelp("key=r[P3@P4]"),
+    /*  42 */ "RowSetRead"       OpHelp("r[P3]=rowset(P1)"),
+    /*  43 */ "RowSetTest"       OpHelp("if r[P3] in rowset(P1) goto P2"),
+    /*  44 */ "Program"          OpHelp(""),
+    /*  45 */ "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),
+    /*  46 */ "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),
+    /*  47 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]--, goto P2"),
+    /*  48 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),
+    /*  49 */ "IncrVacuum"       OpHelp(""),
+    /*  50 */ "VNext"            OpHelp(""),
+    /*  51 */ "Init"             OpHelp("Start at P2"),
+    /*  52 */ "Return"           OpHelp(""),
+    /*  53 */ "EndCoroutine"     OpHelp(""),
+    /*  54 */ "HaltIfNull"       OpHelp("if r[P3]=null halt"),
+    /*  55 */ "Halt"             OpHelp(""),
+    /*  56 */ "Integer"          OpHelp("r[P2]=P1"),
+    /*  57 */ "Int64"            OpHelp("r[P2]=P4"),
+    /*  58 */ "String"           OpHelp("r[P2]='P4' (len=P1)"),
+    /*  59 */ "Null"             OpHelp("r[P2..P3]=NULL"),
+    /*  60 */ "SoftNull"         OpHelp("r[P1]=NULL"),
+    /*  61 */ "Blob"             OpHelp("r[P2]=P4 (len=P1)"),
+    /*  62 */ "Variable"         OpHelp("r[P2]=parameter(P1,P4)"),
+    /*  63 */ "Move"             OpHelp("r[P2@P3]=r[P1@P3]"),
+    /*  64 */ "Copy"             OpHelp("r[P2@P3+1]=r[P1@P3+1]"),
+    /*  65 */ "SCopy"            OpHelp("r[P2]=r[P1]"),
+    /*  66 */ "IntCopy"          OpHelp("r[P2]=r[P1]"),
+    /*  67 */ "ResultRow"        OpHelp("output=r[P1@P2]"),
+    /*  68 */ "CollSeq"          OpHelp(""),
+    /*  69 */ "AddImm"           OpHelp("r[P1]=r[P1]+P2"),
+    /*  70 */ "Or"               OpHelp("r[P3]=(r[P1] || r[P2])"),
+    /*  71 */ "And"              OpHelp("r[P3]=(r[P1] && r[P2])"),
+    /*  72 */ "RealAffinity"     OpHelp(""),
+    /*  73 */ "Cast"             OpHelp("affinity(r[P1])"),
+    /*  74 */ "Permutation"      OpHelp(""),
+    /*  75 */ "IsNull"           OpHelp("if r[P1]==NULL goto P2"),
+    /*  76 */ "NotNull"          OpHelp("if r[P1]!=NULL goto P2"),
+    /*  77 */ "Ne"               OpHelp("IF r[P3]!=r[P1]"),
+    /*  78 */ "Eq"               OpHelp("IF r[P3]==r[P1]"),
+    /*  79 */ "Gt"               OpHelp("IF r[P3]>r[P1]"),
+    /*  80 */ "Le"               OpHelp("IF r[P3]<=r[P1]"),
+    /*  81 */ "Lt"               OpHelp("IF r[P3]<r[P1]"),
+    /*  82 */ "Ge"               OpHelp("IF r[P3]>=r[P1]"),
+    /*  83 */ "ElseNotEq"        OpHelp(""),
+    /*  84 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),
+    /*  85 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),
+    /*  86 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),
+    /*  87 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),
+    /*  88 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),
+    /*  89 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),
+    /*  90 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),
+    /*  91 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),
+    /*  92 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),
+    /*  93 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
+    /*  94 */ "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),
+    /*  95 */ "BitNot"           OpHelp("r[P1]= ~r[P1]"),
+    /*  96 */ "Column"           OpHelp("r[P3]=PX"),
     /*  97 */ "String8"          OpHelp("r[P2]='P4'"),
-    /*  98 */ "Column"           OpHelp("r[P3]=PX"),
-    /*  99 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),
-    /* 100 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
-    /* 101 */ "Count"            OpHelp("r[P2]=count()"),
-    /* 102 */ "ReadCookie"       OpHelp(""),
-    /* 103 */ "SetCookie"        OpHelp(""),
-    /* 104 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
-    /* 105 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
-    /* 106 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
+    /*  98 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),
+    /*  99 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
+    /* 100 */ "Count"            OpHelp("r[P2]=count()"),
+    /* 101 */ "ReadCookie"       OpHelp(""),
+    /* 102 */ "SetCookie"        OpHelp(""),
+    /* 103 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
+    /* 104 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
+    /* 105 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
+    /* 106 */ "OpenDup"          OpHelp(""),
     /* 107 */ "OpenAutoindex"    OpHelp("nColumn=P2"),
     /* 108 */ "OpenEphemeral"    OpHelp("nColumn=P2"),
     /* 109 */ "SorterOpen"       OpHelp(""),
@@ -29595,7 +30170,7 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
     /* 125 */ "SorterInsert"     OpHelp("key=r[P2]"),
     /* 126 */ "IdxInsert"        OpHelp("key=r[P2]"),
     /* 127 */ "IdxDelete"        OpHelp("key=r[P2@P3]"),
-    /* 128 */ "Seek"             OpHelp("Move P3 to P1.rowid"),
+    /* 128 */ "DeferredSeek"     OpHelp("Move P3 to P1.rowid if needed"),
     /* 129 */ "IdxRowid"         OpHelp("r[P2]=rowid"),
     /* 130 */ "Destroy"          OpHelp(""),
     /* 131 */ "Clear"            OpHelp(""),
@@ -29628,9 +30203,13 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
     /* 158 */ "VRename"          OpHelp(""),
     /* 159 */ "Pagecount"        OpHelp(""),
     /* 160 */ "MaxPgcnt"         OpHelp(""),
-    /* 161 */ "CursorHint"       OpHelp(""),
-    /* 162 */ "Noop"             OpHelp(""),
-    /* 163 */ "Explain"          OpHelp(""),
+    /* 161 */ "PureFunc0"        OpHelp(""),
+    /* 162 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),
+    /* 163 */ "PureFunc"         OpHelp(""),
+    /* 164 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),
+    /* 165 */ "CursorHint"       OpHelp(""),
+    /* 166 */ "Noop"             OpHelp(""),
+    /* 167 */ "Explain"          OpHelp(""),
   };
   return azName[i];
 }
@@ -45245,8 +45824,7 @@ static int pcache1InitBulk(PCache1 *pCache){
   sqlite3EndBenignMalloc();
   if( zBulk ){
     int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;
-    int i;
-    for(i=0; i<nBulk; i++){
+    do{
       PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];
       pX->page.pBuf = zBulk;
       pX->page.pExtra = &pX[1];
@@ -45255,7 +45833,7 @@ static int pcache1InitBulk(PCache1 *pCache){
       pX->pNext = pCache->pFree;
       pCache->pFree = pX;
       zBulk += pCache->szAlloc;
-    }
+    }while( --nBulk );
   }
   return pCache->pFree!=0;
 }
@@ -46171,7 +46749,7 @@ SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){
   int nFree = 0;
   assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );
   assert( sqlite3_mutex_notheld(pcache1.mutex) );
-  if( sqlite3GlobalConfig.nPage==0 ){
+  if( sqlite3GlobalConfig.pPage==0 ){
     PgHdr1 *p;
     pcache1EnterMutex(&pcache1.grp);
     while( (nReq<0 || nFree<nReq)
@@ -49131,6 +49709,11 @@ static int pager_playback_one_page(
   char *aData;                  /* Temporary storage for the page */
   sqlite3_file *jfd;            /* The file descriptor for the journal file */
   int isSynced;                 /* True if journal page is synced */
+#ifdef SQLITE_HAS_CODEC
+  /* The jrnlEnc flag is true if Journal pages should be passed through
+  ** the codec.  It is false for pure in-memory journals. */
+  const int jrnlEnc = (isMainJrnl || pPager->subjInMemory==0);
+#endif
 
   assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */
   assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */
@@ -49254,14 +49837,34 @@ static int pager_playback_one_page(
     i64 ofst = (pgno-1)*(i64)pPager->pageSize;
     testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );
     assert( !pagerUseWal(pPager) );
+
+    /* Write the data read from the journal back into the database file.
+    ** This is usually safe even for an encrypted database - as the data
+    ** was encrypted before it was written to the journal file. The exception
+    ** is if the data was just read from an in-memory sub-journal. In that
+    ** case it must be encrypted here before it is copied into the database
+    ** file.  */
+#ifdef SQLITE_HAS_CODEC
+    if( !jrnlEnc ){
+      CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT, aData);
+      rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);
+      CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);
+    }else
+#endif
     rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);
+
     if( pgno>pPager->dbFileSize ){
       pPager->dbFileSize = pgno;
     }
     if( pPager->pBackup ){
-      CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);
+#ifdef SQLITE_HAS_CODEC
+      if( jrnlEnc ){
+        CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);
+        sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
+        CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT,aData);
+      }else
+#endif
       sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
-      CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT, aData);
     }
   }else if( !isMainJrnl && pPg==0 ){
     /* If this is a rollback of a savepoint and data was not written to
@@ -49313,7 +49916,9 @@ static int pager_playback_one_page(
     }
 
     /* Decode the page just read from disk */
-    CODEC1(pPager, pData, pPg->pgno, 3, rc=SQLITE_NOMEM_BKPT);
+#if SQLITE_HAS_CODEC
+    if( jrnlEnc ){ CODEC1(pPager, pData, pPg->pgno, 3, rc=SQLITE_NOMEM_BKPT); }
+#endif
     sqlite3PcacheRelease(pPg);
   }
   return rc;
@@ -50099,7 +50704,7 @@ static int pagerPagecount(Pager *pPager, Pgno *pnPage){
   nPage = sqlite3WalDbsize(pPager->pWal);
 
   /* If the number of pages in the database is not available from the
-  ** WAL sub-system, determine the page counte based on the size of
+  ** WAL sub-system, determine the page count based on the size of
   ** the database file.  If the size of the database file is not an
   ** integer multiple of the page-size, round up the result.
   */
@@ -50150,23 +50755,21 @@ static int pagerOpenWalIfPresent(Pager *pPager){
 
   if( !pPager->tempFile ){
     int isWal;                    /* True if WAL file exists */
-    Pgno nPage;                   /* Size of the database file */
-
-    rc = pagerPagecount(pPager, &nPage);
-    if( rc ) return rc;
-    if( nPage==0 ){
-      rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
-      if( rc==SQLITE_IOERR_DELETE_NOENT ) rc = SQLITE_OK;
-      isWal = 0;
-    }else{
-      rc = sqlite3OsAccess(
-          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
-      );
-    }
+    rc = sqlite3OsAccess(
+        pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
+    );
     if( rc==SQLITE_OK ){
       if( isWal ){
-        testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );
-        rc = sqlite3PagerOpenWal(pPager, 0);
+        Pgno nPage;                   /* Size of the database file */
+
+        rc = pagerPagecount(pPager, &nPage);
+        if( rc ) return rc;
+        if( nPage==0 ){
+          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
+        }else{
+          testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );
+          rc = sqlite3PagerOpenWal(pPager, 0);
+        }
       }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){
         pPager->journalMode = PAGER_JOURNALMODE_DELETE;
       }
@@ -51325,8 +51928,13 @@ static int subjournalPage(PgHdr *pPg){
       void *pData = pPg->pData;
       i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
       char *pData2;
-  
-      CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);
+
+#if SQLITE_HAS_CODEC   
+      if( !pPager->subjInMemory ){
+        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);
+      }else
+#endif
+      pData2 = pData;
       PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));
       rc = write32bits(pPager->sjfd, offset, pPg->pgno);
       if( rc==SQLITE_OK ){
@@ -52104,19 +52712,14 @@ SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){
       ** detected.  The chance of an undetected change is so small that
       ** it can be neglected.
       */
-      Pgno nPage = 0;
       char dbFileVers[sizeof(pPager->dbFileVers)];
 
-      rc = pagerPagecount(pPager, &nPage);
-      if( rc ) goto failed;
-
-      if( nPage>0 ){
-        IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));
-        rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
-        if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){
+      IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));
+      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
+      if( rc!=SQLITE_OK ){
+        if( rc!=SQLITE_IOERR_SHORT_READ ){
           goto failed;
         }
-      }else{
         memset(dbFileVers, 0, sizeof(dbFileVers));
       }
 
@@ -58409,10 +59012,12 @@ struct BtShared {
 #define BTS_READ_ONLY        0x0001   /* Underlying file is readonly */
 #define BTS_PAGESIZE_FIXED   0x0002   /* Page size can no longer be changed */
 #define BTS_SECURE_DELETE    0x0004   /* PRAGMA secure_delete is enabled */
-#define BTS_INITIALLY_EMPTY  0x0008   /* Database was empty at trans start */
-#define BTS_NO_WAL           0x0010   /* Do not open write-ahead-log files */
-#define BTS_EXCLUSIVE        0x0020   /* pWriter has an exclusive lock */
-#define BTS_PENDING          0x0040   /* Waiting for read-locks to clear */
+#define BTS_OVERWRITE        0x0008   /* Overwrite deleted content with zeros */
+#define BTS_FAST_SECURE      0x000c   /* Combination of the previous two */
+#define BTS_INITIALLY_EMPTY  0x0010   /* Database was empty at trans start */
+#define BTS_NO_WAL           0x0020   /* Do not open write-ahead-log files */
+#define BTS_EXCLUSIVE        0x0040   /* pWriter has an exclusive lock */
+#define BTS_PENDING          0x0080   /* Waiting for read-locks to clear */
 
 /*
 ** An instance of the following structure is used to hold information
@@ -58478,10 +59083,10 @@ struct BtCursor {
   ** initialized. */
   i8 iPage;                 /* Index of current page in apPage */
   u8 curIntKey;             /* Value of apPage[0]->intKey */
-  struct KeyInfo *pKeyInfo; /* Argument passed to comparison function */
-  void *padding1;           /* Make object size a multiple of 16 */
-  u16 aiIdx[BTCURSOR_MAX_DEPTH];        /* Current index in apPage[i] */
-  MemPage *apPage[BTCURSOR_MAX_DEPTH];  /* Pages from root to current page */
+  u16 ix;                   /* Current index for apPage[iPage] */
+  u16 aiIdx[BTCURSOR_MAX_DEPTH-1];     /* Current index in apPage[i] */
+  struct KeyInfo *pKeyInfo;            /* Arg passed to comparison function */
+  MemPage *apPage[BTCURSOR_MAX_DEPTH]; /* Pages from root to current page */
 };
 
 /*
@@ -59110,7 +59715,7 @@ static int hasSharedCacheTableLock(
   ** Return true immediately.
   */
   if( (pBtree->sharable==0)
-   || (eLockType==READ_LOCK && (pBtree->db->flags & SQLITE_ReadUncommitted))
+   || (eLockType==READ_LOCK && (pBtree->db->flags & SQLITE_ReadUncommit))
   ){
     return 1;
   }
@@ -59187,7 +59792,7 @@ static int hasReadConflicts(Btree *pBtree, Pgno iRoot){
   for(p=pBtree->pBt->pCursor; p; p=p->pNext){
     if( p->pgnoRoot==iRoot 
      && p->pBtree!=pBtree
-     && 0==(p->pBtree->db->flags & SQLITE_ReadUncommitted)
+     && 0==(p->pBtree->db->flags & SQLITE_ReadUncommit)
     ){
       return 1;
     }
@@ -59209,7 +59814,7 @@ static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){
   assert( sqlite3BtreeHoldsMutex(p) );
   assert( eLock==READ_LOCK || eLock==WRITE_LOCK );
   assert( p->db!=0 );
-  assert( !(p->db->flags&SQLITE_ReadUncommitted)||eLock==WRITE_LOCK||iTab==1 );
+  assert( !(p->db->flags&SQLITE_ReadUncommit)||eLock==WRITE_LOCK||iTab==1 );
   
   /* If requesting a write-lock, then the Btree must have an open write
   ** transaction on this file. And, obviously, for this to be so there 
@@ -59287,7 +59892,7 @@ static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){
   ** obtain a read-lock using this function. The only read-lock obtained
   ** by a connection in read-uncommitted mode is on the sqlite_master 
   ** table, and that lock is obtained in BtreeBeginTrans().  */
-  assert( 0==(p->db->flags&SQLITE_ReadUncommitted) || eLock==WRITE_LOCK );
+  assert( 0==(p->db->flags&SQLITE_ReadUncommit) || eLock==WRITE_LOCK );
 
   /* This function should only be called on a sharable b-tree after it 
   ** has been determined that no other b-tree holds a conflicting lock.  */
@@ -59457,6 +60062,7 @@ static void invalidateAllOverflowCache(BtShared *pBt){
 */
 static void invalidateIncrblobCursors(
   Btree *pBtree,          /* The database file to check */
+  Pgno pgnoRoot,          /* The table that might be changing */
   i64 iRow,               /* The rowid that might be changing */
   int isClearTable        /* True if all rows are being deleted */
 ){
@@ -59467,7 +60073,7 @@ static void invalidateIncrblobCursors(
   for(p=pBtree->pBt->pCursor; p; p=p->pNext){
     if( (p->curFlags & BTCF_Incrblob)!=0 ){
       pBtree->hasIncrblobCur = 1;
-      if( isClearTable || p->info.nKey==iRow ){
+      if( p->pgnoRoot==pgnoRoot && (isClearTable || p->info.nKey==iRow) ){
         p->eState = CURSOR_INVALID;
       }
     }
@@ -59476,7 +60082,7 @@ static void invalidateIncrblobCursors(
 
 #else
   /* Stub function when INCRBLOB is omitted */
-  #define invalidateIncrblobCursors(x,y,z)
+  #define invalidateIncrblobCursors(w,x,y,z)
 #endif /* SQLITE_OMIT_INCRBLOB */
 
 /*
@@ -59728,7 +60334,7 @@ static int btreeMoveto(
     if( pIdxKey==0 ) return SQLITE_NOMEM_BKPT;
     sqlite3VdbeRecordUnpack(pCur->pKeyInfo, (int)nKey, pKey, pIdxKey);
     if( pIdxKey->nField==0 ){
-      rc = SQLITE_CORRUPT_BKPT;
+      rc = SQLITE_CORRUPT_PGNO(pCur->apPage[pCur->iPage]->pgno);
       goto moveto_done;
     }
   }else{
@@ -59957,7 +60563,7 @@ static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){
   if( pPgno ) *pPgno = get4byte(&pPtrmap[offset+1]);
 
   sqlite3PagerUnref(pDbPage);
-  if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_BKPT;
+  if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_PGNO(iPtrmap);
   return SQLITE_OK;
 }
 
@@ -60342,7 +60948,7 @@ static int defragmentPage(MemPage *pPage, int nMaxFrag){
         int sz = get2byte(&data[iFree+2]);
         int top = get2byte(&data[hdr+5]);
         if( iFree2 ){
-          if( iFree+sz>iFree2 ) return SQLITE_CORRUPT_BKPT;
+          if( iFree+sz>iFree2 ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
           sz2 = get2byte(&data[iFree2+2]);
           assert( iFree+sz+sz2+iFree2-(iFree+sz) <= usableSize );
           memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));
@@ -60373,13 +60979,13 @@ static int defragmentPage(MemPage *pPage, int nMaxFrag){
     ** if PRAGMA cell_size_check=ON.
     */
     if( pc<iCellFirst || pc>iCellLast ){
-      return SQLITE_CORRUPT_BKPT;
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
     }
     assert( pc>=iCellFirst && pc<=iCellLast );
     size = pPage->xCellSize(pPage, &src[pc]);
     cbrk -= size;
     if( cbrk<iCellFirst || pc+size>usableSize ){
-      return SQLITE_CORRUPT_BKPT;
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
     }
     assert( cbrk+size<=usableSize && cbrk>=iCellFirst );
     testcase( cbrk+size==usableSize );
@@ -60399,7 +61005,7 @@ static int defragmentPage(MemPage *pPage, int nMaxFrag){
 
  defragment_out:
   if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){
-    return SQLITE_CORRUPT_BKPT;
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
   assert( cbrk>=iCellFirst );
   put2byte(&data[hdr+5], cbrk);
@@ -60438,7 +61044,7 @@ static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){
     /* EVIDENCE-OF: R-06866-39125 Freeblocks are always connected in order of
     ** increasing offset. */
     if( pc>usableSize-4 || pc<iAddr+4 ){
-      *pRc = SQLITE_CORRUPT_BKPT;
+      *pRc = SQLITE_CORRUPT_PGNO(pPg->pgno);
       return 0;
     }
     /* EVIDENCE-OF: R-22710-53328 The third and fourth bytes of each
@@ -60449,7 +61055,7 @@ static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){
       testcase( x==4 );
       testcase( x==3 );
       if( pc < pPg->cellOffset+2*pPg->nCell || size+pc > usableSize ){
-        *pRc = SQLITE_CORRUPT_BKPT;
+        *pRc = SQLITE_CORRUPT_PGNO(pPg->pgno);
         return 0;
       }else if( x<4 ){
         /* EVIDENCE-OF: R-11498-58022 In a well-formed b-tree page, the total
@@ -60516,7 +61122,7 @@ static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){
     if( top==0 && pPage->pBt->usableSize==65536 ){
       top = 65536;
     }else{
-      return SQLITE_CORRUPT_BKPT;
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
     }
   }
 
@@ -60597,7 +61203,7 @@ static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
 
   /* Overwrite deleted information with zeros when the secure_delete
   ** option is enabled */
-  if( pPage->pBt->btsFlags & BTS_SECURE_DELETE ){
+  if( pPage->pBt->btsFlags & BTS_FAST_SECURE ){
     memset(&data[iStart], 0, iSize);
   }
 
@@ -60612,11 +61218,11 @@ static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
     while( (iFreeBlk = get2byte(&data[iPtr]))<iStart ){
       if( iFreeBlk<iPtr+4 ){
         if( iFreeBlk==0 ) break;
-        return SQLITE_CORRUPT_BKPT;
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
       }
       iPtr = iFreeBlk;
     }
-    if( iFreeBlk>iLast ) return SQLITE_CORRUPT_BKPT;
+    if( iFreeBlk>iLast ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
     assert( iFreeBlk>iPtr || iFreeBlk==0 );
   
     /* At this point:
@@ -60627,9 +61233,11 @@ static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
     */
     if( iFreeBlk && iEnd+3>=iFreeBlk ){
       nFrag = iFreeBlk - iEnd;
-      if( iEnd>iFreeBlk ) return SQLITE_CORRUPT_BKPT;
+      if( iEnd>iFreeBlk ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
       iEnd = iFreeBlk + get2byte(&data[iFreeBlk+2]);
-      if( iEnd > pPage->pBt->usableSize ) return SQLITE_CORRUPT_BKPT;
+      if( iEnd > pPage->pBt->usableSize ){
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
+      }
       iSize = iEnd - iStart;
       iFreeBlk = get2byte(&data[iFreeBlk]);
     }
@@ -60641,20 +61249,20 @@ static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
     if( iPtr>hdr+1 ){
       int iPtrEnd = iPtr + get2byte(&data[iPtr+2]);
       if( iPtrEnd+3>=iStart ){
-        if( iPtrEnd>iStart ) return SQLITE_CORRUPT_BKPT;
+        if( iPtrEnd>iStart ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
         nFrag += iStart - iPtrEnd;
         iSize = iEnd - iPtr;
         iStart = iPtr;
       }
     }
-    if( nFrag>data[hdr+7] ) return SQLITE_CORRUPT_BKPT;
+    if( nFrag>data[hdr+7] ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
     data[hdr+7] -= nFrag;
   }
   if( iStart==get2byte(&data[hdr+5]) ){
     /* The new freeblock is at the beginning of the cell content area,
     ** so just extend the cell content area rather than create another
     ** freelist entry */
-    if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_BKPT;
+    if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_PGNO(pPage->pgno);
     put2byte(&data[hdr+1], iFreeBlk);
     put2byte(&data[hdr+5], iEnd);
   }else{
@@ -60722,7 +61330,7 @@ static int decodeFlags(MemPage *pPage, int flagByte){
   }else{
     /* EVIDENCE-OF: R-47608-56469 Any other value for the b-tree page type is
     ** an error. */
-    return SQLITE_CORRUPT_BKPT;
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
   pPage->max1bytePayload = pBt->max1bytePayload;
   return SQLITE_OK;
@@ -60738,6 +61346,16 @@ static int decodeFlags(MemPage *pPage, int flagByte){
 ** we failed to detect any corruption.
 */
 static int btreeInitPage(MemPage *pPage){
+  int pc;            /* Address of a freeblock within pPage->aData[] */
+  u8 hdr;            /* Offset to beginning of page header */
+  u8 *data;          /* Equal to pPage->aData */
+  BtShared *pBt;        /* The main btree structure */
+  int usableSize;    /* Amount of usable space on each page */
+  u16 cellOffset;    /* Offset from start of page to first cell pointer */
+  int nFree;         /* Number of unused bytes on the page */
+  int top;           /* First byte of the cell content area */
+  int iCellFirst;    /* First allowable cell or freeblock offset */
+  int iCellLast;     /* Last possible cell or freeblock offset */
 
   assert( pPage->pBt!=0 );
   assert( pPage->pBt->db!=0 );
@@ -60745,127 +61363,119 @@ static int btreeInitPage(MemPage *pPage){
   assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );
   assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );
   assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );
+  assert( pPage->isInit==0 );
 
-  if( !pPage->isInit ){
-    int pc;            /* Address of a freeblock within pPage->aData[] */
-    u8 hdr;            /* Offset to beginning of page header */
-    u8 *data;          /* Equal to pPage->aData */
-    BtShared *pBt;        /* The main btree structure */
-    int usableSize;    /* Amount of usable space on each page */
-    u16 cellOffset;    /* Offset from start of page to first cell pointer */
-    int nFree;         /* Number of unused bytes on the page */
-    int top;           /* First byte of the cell content area */
-    int iCellFirst;    /* First allowable cell or freeblock offset */
-    int iCellLast;     /* Last possible cell or freeblock offset */
-
-    pBt = pPage->pBt;
-
-    hdr = pPage->hdrOffset;
-    data = pPage->aData;
-    /* EVIDENCE-OF: R-28594-02890 The one-byte flag at offset 0 indicating
-    ** the b-tree page type. */
-    if( decodeFlags(pPage, data[hdr]) ) return SQLITE_CORRUPT_BKPT;
-    assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );
-    pPage->maskPage = (u16)(pBt->pageSize - 1);
-    pPage->nOverflow = 0;
-    usableSize = pBt->usableSize;
-    pPage->cellOffset = cellOffset = hdr + 8 + pPage->childPtrSize;
-    pPage->aDataEnd = &data[usableSize];
-    pPage->aCellIdx = &data[cellOffset];
-    pPage->aDataOfst = &data[pPage->childPtrSize];
-    /* EVIDENCE-OF: R-58015-48175 The two-byte integer at offset 5 designates
-    ** the start of the cell content area. A zero value for this integer is
-    ** interpreted as 65536. */
-    top = get2byteNotZero(&data[hdr+5]);
-    /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
-    ** number of cells on the page. */
-    pPage->nCell = get2byte(&data[hdr+3]);
-    if( pPage->nCell>MX_CELL(pBt) ){
-      /* To many cells for a single page.  The page must be corrupt */
-      return SQLITE_CORRUPT_BKPT;
-    }
-    testcase( pPage->nCell==MX_CELL(pBt) );
-    /* EVIDENCE-OF: R-24089-57979 If a page contains no cells (which is only
-    ** possible for a root page of a table that contains no rows) then the
-    ** offset to the cell content area will equal the page size minus the
-    ** bytes of reserved space. */
-    assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );
-
-    /* A malformed database page might cause us to read past the end
-    ** of page when parsing a cell.  
-    **
-    ** The following block of code checks early to see if a cell extends
-    ** past the end of a page boundary and causes SQLITE_CORRUPT to be 
-    ** returned if it does.
-    */
-    iCellFirst = cellOffset + 2*pPage->nCell;
-    iCellLast = usableSize - 4;
-    if( pBt->db->flags & SQLITE_CellSizeCk ){
-      int i;            /* Index into the cell pointer array */
-      int sz;           /* Size of a cell */
-
-      if( !pPage->leaf ) iCellLast--;
-      for(i=0; i<pPage->nCell; i++){
-        pc = get2byteAligned(&data[cellOffset+i*2]);
-        testcase( pc==iCellFirst );
-        testcase( pc==iCellLast );
-        if( pc<iCellFirst || pc>iCellLast ){
-          return SQLITE_CORRUPT_BKPT;
-        }
-        sz = pPage->xCellSize(pPage, &data[pc]);
-        testcase( pc+sz==usableSize );
-        if( pc+sz>usableSize ){
-          return SQLITE_CORRUPT_BKPT;
-        }
-      }
-      if( !pPage->leaf ) iCellLast++;
-    }  
+  pBt = pPage->pBt;
+  hdr = pPage->hdrOffset;
+  data = pPage->aData;
+  /* EVIDENCE-OF: R-28594-02890 The one-byte flag at offset 0 indicating
+  ** the b-tree page type. */
+  if( decodeFlags(pPage, data[hdr]) ){
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
+  }
+  assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );
+  pPage->maskPage = (u16)(pBt->pageSize - 1);
+  pPage->nOverflow = 0;
+  usableSize = pBt->usableSize;
+  pPage->cellOffset = cellOffset = hdr + 8 + pPage->childPtrSize;
+  pPage->aDataEnd = &data[usableSize];
+  pPage->aCellIdx = &data[cellOffset];
+  pPage->aDataOfst = &data[pPage->childPtrSize];
+  /* EVIDENCE-OF: R-58015-48175 The two-byte integer at offset 5 designates
+  ** the start of the cell content area. A zero value for this integer is
+  ** interpreted as 65536. */
+  top = get2byteNotZero(&data[hdr+5]);
+  /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
+  ** number of cells on the page. */
+  pPage->nCell = get2byte(&data[hdr+3]);
+  if( pPage->nCell>MX_CELL(pBt) ){
+    /* To many cells for a single page.  The page must be corrupt */
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
+  }
+  testcase( pPage->nCell==MX_CELL(pBt) );
+  /* EVIDENCE-OF: R-24089-57979 If a page contains no cells (which is only
+  ** possible for a root page of a table that contains no rows) then the
+  ** offset to the cell content area will equal the page size minus the
+  ** bytes of reserved space. */
+  assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );
+
+  /* A malformed database page might cause us to read past the end
+  ** of page when parsing a cell.  
+  **
+  ** The following block of code checks early to see if a cell extends
+  ** past the end of a page boundary and causes SQLITE_CORRUPT to be 
+  ** returned if it does.
+  */
+  iCellFirst = cellOffset + 2*pPage->nCell;
+  iCellLast = usableSize - 4;
+  if( pBt->db->flags & SQLITE_CellSizeCk ){
+    int i;            /* Index into the cell pointer array */
+    int sz;           /* Size of a cell */
 
-    /* Compute the total free space on the page
-    ** EVIDENCE-OF: R-23588-34450 The two-byte integer at offset 1 gives the
-    ** start of the first freeblock on the page, or is zero if there are no
-    ** freeblocks. */
-    pc = get2byte(&data[hdr+1]);
-    nFree = data[hdr+7] + top;  /* Init nFree to non-freeblock free space */
-    if( pc>0 ){
-      u32 next, size;
-      if( pc<iCellFirst ){
-        /* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will
-        ** always be at least one cell before the first freeblock.
-        */
-        return SQLITE_CORRUPT_BKPT; 
+    if( !pPage->leaf ) iCellLast--;
+    for(i=0; i<pPage->nCell; i++){
+      pc = get2byteAligned(&data[cellOffset+i*2]);
+      testcase( pc==iCellFirst );
+      testcase( pc==iCellLast );
+      if( pc<iCellFirst || pc>iCellLast ){
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
       }
-      while( 1 ){
-        if( pc>iCellLast ){
-          return SQLITE_CORRUPT_BKPT; /* Freeblock off the end of the page */
-        }
-        next = get2byte(&data[pc]);
-        size = get2byte(&data[pc+2]);
-        nFree = nFree + size;
-        if( next<=pc+size+3 ) break;
-        pc = next;
-      }
-      if( next>0 ){
-        return SQLITE_CORRUPT_BKPT;  /* Freeblock not in ascending order */
-      }
-      if( pc+size>(unsigned int)usableSize ){
-        return SQLITE_CORRUPT_BKPT;  /* Last freeblock extends past page end */
+      sz = pPage->xCellSize(pPage, &data[pc]);
+      testcase( pc+sz==usableSize );
+      if( pc+sz>usableSize ){
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
       }
     }
+    if( !pPage->leaf ) iCellLast++;
+  }  
 
-    /* At this point, nFree contains the sum of the offset to the start
-    ** of the cell-content area plus the number of free bytes within
-    ** the cell-content area. If this is greater than the usable-size
-    ** of the page, then the page must be corrupted. This check also
-    ** serves to verify that the offset to the start of the cell-content
-    ** area, according to the page header, lies within the page.
-    */
-    if( nFree>usableSize ){
-      return SQLITE_CORRUPT_BKPT; 
+  /* Compute the total free space on the page
+  ** EVIDENCE-OF: R-23588-34450 The two-byte integer at offset 1 gives the
+  ** start of the first freeblock on the page, or is zero if there are no
+  ** freeblocks. */
+  pc = get2byte(&data[hdr+1]);
+  nFree = data[hdr+7] + top;  /* Init nFree to non-freeblock free space */
+  if( pc>0 ){
+    u32 next, size;
+    if( pc<iCellFirst ){
+      /* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will
+      ** always be at least one cell before the first freeblock.
+      */
+      return SQLITE_CORRUPT_PGNO(pPage->pgno); 
+    }
+    while( 1 ){
+      if( pc>iCellLast ){
+        /* Freeblock off the end of the page */
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
+      }
+      next = get2byte(&data[pc]);
+      size = get2byte(&data[pc+2]);
+      nFree = nFree + size;
+      if( next<=pc+size+3 ) break;
+      pc = next;
     }
-    pPage->nFree = (u16)(nFree - iCellFirst);
-    pPage->isInit = 1;
+    if( next>0 ){
+      /* Freeblock not in ascending order */
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
+    }
+    if( pc+size>(unsigned int)usableSize ){
+      /* Last freeblock extends past page end */
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
+    }
+  }
+
+  /* At this point, nFree contains the sum of the offset to the start
+  ** of the cell-content area plus the number of free bytes within
+  ** the cell-content area. If this is greater than the usable-size
+  ** of the page, then the page must be corrupted. This check also
+  ** serves to verify that the offset to the start of the cell-content
+  ** area, according to the page header, lies within the page.
+  */
+  if( nFree>usableSize ){
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
+  pPage->nFree = (u16)(nFree - iCellFirst);
+  pPage->isInit = 1;
   return SQLITE_OK;
 }
 
@@ -60884,7 +61494,7 @@ static void zeroPage(MemPage *pPage, int flags){
   assert( sqlite3PagerGetData(pPage->pDbPage) == data );
   assert( sqlite3PagerIswriteable(pPage->pDbPage) );
   assert( sqlite3_mutex_held(pBt->mutex) );
-  if( pBt->btsFlags & BTS_SECURE_DELETE ){
+  if( pBt->btsFlags & BTS_FAST_SECURE ){
     memset(&data[hdr], 0, pBt->usableSize - hdr);
   }
   data[hdr] = (char)flags;
@@ -61029,7 +61639,7 @@ static int getAndInitPage(
   /* If obtaining a child page for a cursor, we must verify that the page is
   ** compatible with the root page. */
   if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){
-    rc = SQLITE_CORRUPT_BKPT;
+    rc = SQLITE_CORRUPT_PGNO(pgno);
     releasePage(*ppPage);
     goto getAndInitPage_error;
   }
@@ -61307,8 +61917,10 @@ SQLITE_PRIVATE int sqlite3BtreeOpen(
     pBt->pCursor = 0;
     pBt->pPage1 = 0;
     if( sqlite3PagerIsreadonly(pBt->pPager) ) pBt->btsFlags |= BTS_READ_ONLY;
-#ifdef SQLITE_SECURE_DELETE
+#if defined(SQLITE_SECURE_DELETE)
     pBt->btsFlags |= BTS_SECURE_DELETE;
+#elif defined(SQLITE_FAST_SECURE_DELETE)
+    pBt->btsFlags |= BTS_OVERWRITE;
 #endif
     /* EVIDENCE-OF: R-51873-39618 The page size for a database file is
     ** determined by the 2-byte integer located at an offset of 16 bytes from
@@ -61756,19 +62368,34 @@ SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){
 }
 
 /*
-** Set the BTS_SECURE_DELETE flag if newFlag is 0 or 1.  If newFlag is -1,
-** then make no changes.  Always return the value of the BTS_SECURE_DELETE
-** setting after the change.
+** Change the values for the BTS_SECURE_DELETE and BTS_OVERWRITE flags:
+**
+**    newFlag==0       Both BTS_SECURE_DELETE and BTS_OVERWRITE are cleared
+**    newFlag==1       BTS_SECURE_DELETE set and BTS_OVERWRITE is cleared
+**    newFlag==2       BTS_SECURE_DELETE cleared and BTS_OVERWRITE is set
+**    newFlag==(-1)    No changes
+**
+** This routine acts as a query if newFlag is less than zero
+**
+** With BTS_OVERWRITE set, deleted content is overwritten by zeros, but
+** freelist leaf pages are not written back to the database.  Thus in-page
+** deleted content is cleared, but freelist deleted content is not.
+**
+** With BTS_SECURE_DELETE, operation is like BTS_OVERWRITE with the addition
+** that freelist leaf pages are written back into the database, increasing
+** the amount of disk I/O.
 */
 SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
   int b;
   if( p==0 ) return 0;
   sqlite3BtreeEnter(p);
+  assert( BTS_OVERWRITE==BTS_SECURE_DELETE*2 );
+  assert( BTS_FAST_SECURE==(BTS_OVERWRITE|BTS_SECURE_DELETE) );
   if( newFlag>=0 ){
-    p->pBt->btsFlags &= ~BTS_SECURE_DELETE;
-    if( newFlag ) p->pBt->btsFlags |= BTS_SECURE_DELETE;
-  } 
-  b = (p->pBt->btsFlags & BTS_SECURE_DELETE)!=0;
+    p->pBt->btsFlags &= ~BTS_FAST_SECURE;
+    p->pBt->btsFlags |= BTS_SECURE_DELETE*newFlag;
+  }
+  b = (p->pBt->btsFlags & BTS_FAST_SECURE)/BTS_SECURE_DELETE;
   sqlite3BtreeLeave(p);
   return b;
 }
@@ -61974,7 +62601,7 @@ static int lockBtree(BtShared *pBt){
                                    pageSize-usableSize);
       return rc;
     }
-    if( (pBt->db->flags & SQLITE_RecoveryMode)==0 && nPage>nPageFile ){
+    if( (pBt->db->flags & SQLITE_WriteSchema)==0 && nPage>nPageFile ){
       rc = SQLITE_CORRUPT_BKPT;
       goto page1_init_failed;
     }
@@ -62317,7 +62944,7 @@ static int setChildPtrmaps(MemPage *pPage){
   Pgno pgno = pPage->pgno;
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
-  rc = btreeInitPage(pPage);
+  rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);
   if( rc!=SQLITE_OK ) return rc;
   nCell = pPage->nCell;
 
@@ -62360,7 +62987,7 @@ static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
   if( eType==PTRMAP_OVERFLOW2 ){
     /* The pointer is always the first 4 bytes of the page in this case.  */
     if( get4byte(pPage->aData)!=iFrom ){
-      return SQLITE_CORRUPT_BKPT;
+      return SQLITE_CORRUPT_PGNO(pPage->pgno);
     }
     put4byte(pPage->aData, iTo);
   }else{
@@ -62368,7 +62995,7 @@ static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
     int nCell;
     int rc;
 
-    rc = btreeInitPage(pPage);
+    rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);
     if( rc ) return rc;
     nCell = pPage->nCell;
 
@@ -62379,7 +63006,7 @@ static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
         pPage->xParseCell(pPage, pCell, &info);
         if( info.nLocal<info.nPayload ){
           if( pCell+info.nSize > pPage->aData+pPage->pBt->usableSize ){
-            return SQLITE_CORRUPT_BKPT;
+            return SQLITE_CORRUPT_PGNO(pPage->pgno);
           }
           if( iFrom==get4byte(pCell+info.nSize-4) ){
             put4byte(pCell+info.nSize-4, iTo);
@@ -62397,7 +63024,7 @@ static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
     if( i==nCell ){
       if( eType!=PTRMAP_BTREE || 
           get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){
-        return SQLITE_CORRUPT_BKPT;
+        return SQLITE_CORRUPT_PGNO(pPage->pgno);
       }
       put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);
     }
@@ -63274,7 +63901,7 @@ SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor *pCur){
     CellInfo info;
     int iPage = pCur->iPage;
     memset(&info, 0, sizeof(info));
-    btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], &info);
+    btreeParseCell(pCur->apPage[iPage], pCur->ix, &info);
     assert( CORRUPT_DB || memcmp(&info, &pCur->info, sizeof(info))==0 );
   }
 #else
@@ -63284,7 +63911,7 @@ static SQLITE_NOINLINE void getCellInfo(BtCursor *pCur){
   if( pCur->info.nSize==0 ){
     int iPage = pCur->iPage;
     pCur->curFlags |= BTCF_ValidNKey;
-    btreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info);
+    btreeParseCell(pCur->apPage[iPage],pCur->ix,&pCur->info);
   }else{
     assertCellInfo(pCur);
   }
@@ -63491,7 +64118,7 @@ static int accessPayload(
   assert( pPage );
   assert( eOp==0 || eOp==1 );
   assert( pCur->eState==CURSOR_VALID );
-  assert( pCur->aiIdx[pCur->iPage]<pPage->nCell );
+  assert( pCur->ix<pPage->nCell );
   assert( cursorHoldsMutex(pCur) );
 
   getCellInfo(pCur);
@@ -63505,7 +64132,7 @@ static int accessPayload(
     **    &aPayload[pCur->info.nLocal] > &pPage->aData[pBt->usableSize]
     ** but is recast into its current form to avoid integer overflow problems
     */
-    return SQLITE_CORRUPT_BKPT;
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
 
   /* Check if data must be read/written to/from the btree page itself. */
@@ -63652,7 +64279,8 @@ static int accessPayload(
   }
 
   if( rc==SQLITE_OK && amt>0 ){
-    return SQLITE_CORRUPT_BKPT; /* Overflow chain ends prematurely */
+    /* Overflow chain ends prematurely */
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
   return rc;
 }
@@ -63678,7 +64306,7 @@ SQLITE_PRIVATE int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] );
-  assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );
+  assert( pCur->ix<pCur->apPage[pCur->iPage]->nCell );
   return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
 }
 
@@ -63740,7 +64368,7 @@ static const void *fetchPayload(
   assert( pCur->eState==CURSOR_VALID );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
   assert( cursorOwnsBtShared(pCur) );
-  assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );
+  assert( pCur->ix<pCur->apPage[pCur->iPage]->nCell );
   assert( pCur->info.nSize>0 );
   assert( pCur->info.pPayload>pCur->apPage[pCur->iPage]->aData || CORRUPT_DB );
   assert( pCur->info.pPayload<pCur->apPage[pCur->iPage]->aDataEnd ||CORRUPT_DB);
@@ -63791,8 +64419,8 @@ static int moveToChild(BtCursor *pCur, u32 newPgno){
   }
   pCur->info.nSize = 0;
   pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
-  pCur->iPage++;
-  pCur->aiIdx[pCur->iPage] = 0;
+  pCur->aiIdx[pCur->iPage++] = pCur->ix;
+  pCur->ix = 0;
   return getAndInitPage(pBt, newPgno, &pCur->apPage[pCur->iPage],
                         pCur, pCur->curPagerFlags);
 }
@@ -63840,6 +64468,7 @@ static void moveToParent(BtCursor *pCur){
   testcase( pCur->aiIdx[pCur->iPage-1] > pCur->apPage[pCur->iPage-1]->nCell );
   pCur->info.nSize = 0;
   pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
+  pCur->ix = pCur->aiIdx[pCur->iPage-1];
   releasePageNotNull(pCur->apPage[pCur->iPage--]);
 }
 
@@ -63917,11 +64546,11 @@ static int moveToRoot(BtCursor *pCur){
   ** (or the freelist).  */
   assert( pRoot->intKey==1 || pRoot->intKey==0 );
   if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){
-    return SQLITE_CORRUPT_BKPT;
+    return SQLITE_CORRUPT_PGNO(pCur->apPage[pCur->iPage]->pgno);
   }
 
 skip_init:  
-  pCur->aiIdx[0] = 0;
+  pCur->ix = 0;
   pCur->info.nSize = 0;
   pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidNKey|BTCF_ValidOvfl);
 
@@ -63955,8 +64584,8 @@ static int moveToLeftmost(BtCursor *pCur){
   assert( cursorOwnsBtShared(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   while( rc==SQLITE_OK && !(pPage = pCur->apPage[pCur->iPage])->leaf ){
-    assert( pCur->aiIdx[pCur->iPage]<pPage->nCell );
-    pgno = get4byte(findCell(pPage, pCur->aiIdx[pCur->iPage]));
+    assert( pCur->ix<pPage->nCell );
+    pgno = get4byte(findCell(pPage, pCur->ix));
     rc = moveToChild(pCur, pgno);
   }
   return rc;
@@ -63981,11 +64610,11 @@ static int moveToRightmost(BtCursor *pCur){
   assert( pCur->eState==CURSOR_VALID );
   while( !(pPage = pCur->apPage[pCur->iPage])->leaf ){
     pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);
-    pCur->aiIdx[pCur->iPage] = pPage->nCell;
+    pCur->ix = pPage->nCell;
     rc = moveToChild(pCur, pgno);
     if( rc ) return rc;
   }
-  pCur->aiIdx[pCur->iPage] = pPage->nCell-1;
+  pCur->ix = pPage->nCell-1;
   assert( pCur->info.nSize==0 );
   assert( (pCur->curFlags & BTCF_ValidNKey)==0 );
   return SQLITE_OK;
@@ -64033,7 +64662,7 @@ SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor *pCur, int *pRes){
     for(ii=0; ii<pCur->iPage; ii++){
       assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );
     }
-    assert( pCur->aiIdx[pCur->iPage]==pCur->apPage[pCur->iPage]->nCell-1 );
+    assert( pCur->ix==pCur->apPage[pCur->iPage]->nCell-1 );
     assert( pCur->apPage[pCur->iPage]->leaf );
 #endif
     return SQLITE_OK;
@@ -64122,16 +64751,19 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
       /* If the requested key is one more than the previous key, then
       ** try to get there using sqlite3BtreeNext() rather than a full
       ** binary search.  This is an optimization only.  The correct answer
-      ** is still obtained without this ase, only a little more slowely */
+      ** is still obtained without this case, only a little more slowely */
       if( pCur->info.nKey+1==intKey && !pCur->skipNext ){
         *pRes = 0;
-        rc = sqlite3BtreeNext(pCur, pRes);
-        if( rc ) return rc;
-        if( *pRes==0 ){
+        rc = sqlite3BtreeNext(pCur, 0);
+        if( rc==SQLITE_OK ){
           getCellInfo(pCur);
           if( pCur->info.nKey==intKey ){
             return SQLITE_OK;
           }
+        }else if( rc==SQLITE_DONE ){
+          rc = SQLITE_OK;
+        }else{
+          return rc;
         }
       }
     }
@@ -64180,14 +64812,16 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
     upr = pPage->nCell-1;
     assert( biasRight==0 || biasRight==1 );
     idx = upr>>(1-biasRight); /* idx = biasRight ? upr : (lwr+upr)/2; */
-    pCur->aiIdx[pCur->iPage] = (u16)idx;
+    pCur->ix = (u16)idx;
     if( xRecordCompare==0 ){
       for(;;){
         i64 nCellKey;
         pCell = findCellPastPtr(pPage, idx);
         if( pPage->intKeyLeaf ){
           while( 0x80 <= *(pCell++) ){
-            if( pCell>=pPage->aDataEnd ) return SQLITE_CORRUPT_BKPT;
+            if( pCell>=pPage->aDataEnd ){
+              return SQLITE_CORRUPT_PGNO(pPage->pgno);
+            }
           }
         }
         getVarint(pCell, (u64*)&nCellKey);
@@ -64199,7 +64833,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
           if( lwr>upr ){ c = +1; break; }
         }else{
           assert( nCellKey==intKey );
-          pCur->aiIdx[pCur->iPage] = (u16)idx;
+          pCur->ix = (u16)idx;
           if( !pPage->leaf ){
             lwr = idx;
             goto moveto_next_layer;
@@ -64260,7 +64894,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
           testcase( nCell==1 );  /* Invalid key size:  0x80 0x80 0x01 */
           testcase( nCell==2 );  /* Minimum legal index key size */
           if( nCell<2 ){
-            rc = SQLITE_CORRUPT_BKPT;
+            rc = SQLITE_CORRUPT_PGNO(pPage->pgno);
             goto moveto_finish;
           }
           pCellKey = sqlite3Malloc( nCell+18 );
@@ -64268,7 +64902,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
             rc = SQLITE_NOMEM_BKPT;
             goto moveto_finish;
           }
-          pCur->aiIdx[pCur->iPage] = (u16)idx;
+          pCur->ix = (u16)idx;
           rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
           pCur->curFlags &= ~BTCF_ValidOvfl;
           if( rc ){
@@ -64290,7 +64924,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
           assert( c==0 );
           *pRes = 0;
           rc = SQLITE_OK;
-          pCur->aiIdx[pCur->iPage] = (u16)idx;
+          pCur->ix = (u16)idx;
           if( pIdxKey->errCode ) rc = SQLITE_CORRUPT;
           goto moveto_finish;
         }
@@ -64302,8 +64936,8 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
     assert( lwr==upr+1 || (pPage->intKey && !pPage->leaf) );
     assert( pPage->isInit );
     if( pPage->leaf ){
-      assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );
-      pCur->aiIdx[pCur->iPage] = (u16)idx;
+      assert( pCur->ix<pCur->apPage[pCur->iPage]->nCell );
+      pCur->ix = (u16)idx;
       *pRes = c;
       rc = SQLITE_OK;
       goto moveto_finish;
@@ -64314,7 +64948,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
     }else{
       chldPg = get4byte(findCell(pPage, lwr));
     }
-    pCur->aiIdx[pCur->iPage] = (u16)lwr;
+    pCur->ix = (u16)lwr;
     rc = moveToChild(pCur, chldPg);
     if( rc ) break;
   }
@@ -64365,10 +64999,12 @@ SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor *pCur){
 }
 
 /*
-** Advance the cursor to the next entry in the database.  If
-** successful then set *pRes=0.  If the cursor
-** was already pointing to the last entry in the database before
-** this routine was called, then set *pRes=1.
+** Advance the cursor to the next entry in the database. 
+** Return value:
+**
+**    SQLITE_OK        success
+**    SQLITE_DONE      cursor is already pointing at the last element
+**    otherwise        some kind of error occurred
 **
 ** The main entry point is sqlite3BtreeNext().  That routine is optimized
 ** for the common case of merely incrementing the cell counter BtCursor.aiIdx
@@ -64376,23 +65012,19 @@ SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor *pCur){
 ** routine is called when it is necessary to move to a different page or
 ** to restore the cursor.
 **
-** The calling function will set *pRes to 0 or 1.  The initial *pRes value
-** will be 1 if the cursor being stepped corresponds to an SQL index and
-** if this routine could have been skipped if that SQL index had been
-** a unique index.  Otherwise the caller will have set *pRes to zero.
-** Zero is the common case. The btree implementation is free to use the
-** initial *pRes value as a hint to improve performance, but the current
-** SQLite btree implementation does not. (Note that the comdb2 btree
-** implementation does use this hint, however.)
+** If bit 0x01 of the F argument in sqlite3BtreeNext(C,F) is 1, then the
+** cursor corresponds to an SQL index and this routine could have been
+** skipped if the SQL index had been a unique index.  The F argument
+** is a hint to the implement.  SQLite btree implementation does not use
+** this hint, but COMDB2 does.
 */
-static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){
+static SQLITE_NOINLINE int btreeNext(BtCursor *pCur){
   int rc;
   int idx;
   MemPage *pPage;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
-  assert( *pRes==0 );
   if( pCur->eState!=CURSOR_VALID ){
     assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );
     rc = restoreCursorPosition(pCur);
@@ -64400,8 +65032,7 @@ static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){
       return rc;
     }
     if( CURSOR_INVALID==pCur->eState ){
-      *pRes = 1;
-      return SQLITE_OK;
+      return SQLITE_DONE;
     }
     if( pCur->skipNext ){
       assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
@@ -64415,7 +65046,7 @@ static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){
   }
 
   pPage = pCur->apPage[pCur->iPage];
-  idx = ++pCur->aiIdx[pCur->iPage];
+  idx = ++pCur->ix;
   assert( pPage->isInit );
 
   /* If the database file is corrupt, it is possible for the value of idx 
@@ -64433,15 +65064,14 @@ static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){
     }
     do{
       if( pCur->iPage==0 ){
-        *pRes = 1;
         pCur->eState = CURSOR_INVALID;
-        return SQLITE_OK;
+        return SQLITE_DONE;
       }
       moveToParent(pCur);
       pPage = pCur->apPage[pCur->iPage];
-    }while( pCur->aiIdx[pCur->iPage]>=pPage->nCell );
+    }while( pCur->ix>=pPage->nCell );
     if( pPage->intKey ){
-      return sqlite3BtreeNext(pCur, pRes);
+      return sqlite3BtreeNext(pCur, 0);
     }else{
       return SQLITE_OK;
     }
@@ -64452,20 +65082,19 @@ static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){
     return moveToLeftmost(pCur);
   }
 }
-SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes){
+SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int flags){
   MemPage *pPage;
+  UNUSED_PARAMETER( flags );  /* Used in COMDB2 but not native SQLite */
   assert( cursorOwnsBtShared(pCur) );
-  assert( pRes!=0 );
-  assert( *pRes==0 || *pRes==1 );
+  assert( flags==0 || flags==1 );
   assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
   pCur->info.nSize = 0;
   pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
-  *pRes = 0;
-  if( pCur->eState!=CURSOR_VALID ) return btreeNext(pCur, pRes);
+  if( pCur->eState!=CURSOR_VALID ) return btreeNext(pCur);
   pPage = pCur->apPage[pCur->iPage];
-  if( (++pCur->aiIdx[pCur->iPage])>=pPage->nCell ){
-    pCur->aiIdx[pCur->iPage]--;
-    return btreeNext(pCur, pRes);
+  if( (++pCur->ix)>=pPage->nCell ){
+    pCur->ix--;
+    return btreeNext(pCur);
   }
   if( pPage->leaf ){
     return SQLITE_OK;
@@ -64475,10 +65104,12 @@ SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes){
 }
 
 /*
-** Step the cursor to the back to the previous entry in the database.  If
-** successful then set *pRes=0.  If the cursor
-** was already pointing to the first entry in the database before
-** this routine was called, then set *pRes=1.
+** Step the cursor to the back to the previous entry in the database.
+** Return values:
+**
+**     SQLITE_OK     success
+**     SQLITE_DONE   the cursor is already on the first element of the table
+**     otherwise     some kind of error occurred
 **
 ** The main entry point is sqlite3BtreePrevious().  That routine is optimized
 ** for the common case of merely decrementing the cell counter BtCursor.aiIdx
@@ -64486,22 +65117,17 @@ SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes){
 ** helper routine is called when it is necessary to move to a different page
 ** or to restore the cursor.
 **
-** The calling function will set *pRes to 0 or 1.  The initial *pRes value
-** will be 1 if the cursor being stepped corresponds to an SQL index and
-** if this routine could have been skipped if that SQL index had been
-** a unique index.  Otherwise the caller will have set *pRes to zero.
-** Zero is the common case. The btree implementation is free to use the
-** initial *pRes value as a hint to improve performance, but the current
-** SQLite btree implementation does not. (Note that the comdb2 btree
-** implementation does use this hint, however.)
+** If bit 0x01 of the F argument to sqlite3BtreePrevious(C,F) is 1, then
+** the cursor corresponds to an SQL index and this routine could have been
+** skipped if the SQL index had been a unique index.  The F argument is a
+** hint to the implement.  The native SQLite btree implementation does not
+** use this hint, but COMDB2 does.
 */
-static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){
+static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){
   int rc;
   MemPage *pPage;
 
   assert( cursorOwnsBtShared(pCur) );
-  assert( pRes!=0 );
-  assert( *pRes==0 );
   assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
   assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
   assert( pCur->info.nSize==0 );
@@ -64511,8 +65137,7 @@ static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){
       return rc;
     }
     if( CURSOR_INVALID==pCur->eState ){
-      *pRes = 1;
-      return SQLITE_OK;
+      return SQLITE_DONE;
     }
     if( pCur->skipNext ){
       assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
@@ -64528,47 +65153,45 @@ static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){
   pPage = pCur->apPage[pCur->iPage];
   assert( pPage->isInit );
   if( !pPage->leaf ){
-    int idx = pCur->aiIdx[pCur->iPage];
+    int idx = pCur->ix;
     rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
     if( rc ) return rc;
     rc = moveToRightmost(pCur);
   }else{
-    while( pCur->aiIdx[pCur->iPage]==0 ){
+    while( pCur->ix==0 ){
       if( pCur->iPage==0 ){
         pCur->eState = CURSOR_INVALID;
-        *pRes = 1;
-        return SQLITE_OK;
+        return SQLITE_DONE;
       }
       moveToParent(pCur);
     }
     assert( pCur->info.nSize==0 );
     assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );
 
-    pCur->aiIdx[pCur->iPage]--;
+    pCur->ix--;
     pPage = pCur->apPage[pCur->iPage];
     if( pPage->intKey && !pPage->leaf ){
-      rc = sqlite3BtreePrevious(pCur, pRes);
+      rc = sqlite3BtreePrevious(pCur, 0);
     }else{
       rc = SQLITE_OK;
     }
   }
   return rc;
 }
-SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){
+SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int flags){
   assert( cursorOwnsBtShared(pCur) );
-  assert( pRes!=0 );
-  assert( *pRes==0 || *pRes==1 );
+  assert( flags==0 || flags==1 );
   assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
-  *pRes = 0;
+  UNUSED_PARAMETER( flags );  /* Used in COMDB2 but not native SQLite */
   pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey);
   pCur->info.nSize = 0;
   if( pCur->eState!=CURSOR_VALID
-   || pCur->aiIdx[pCur->iPage]==0
+   || pCur->ix==0
    || pCur->apPage[pCur->iPage]->leaf==0
   ){
-    return btreePrevious(pCur, pRes);
+    return btreePrevious(pCur);
   }
-  pCur->aiIdx[pCur->iPage]--;
+  pCur->ix--;
   return SQLITE_OK;
 }
 
@@ -64674,7 +65297,7 @@ static int allocateBtreePage(
       }
       testcase( iTrunk==mxPage );
       if( iTrunk>mxPage || nSearch++ > n ){
-        rc = SQLITE_CORRUPT_BKPT;
+        rc = SQLITE_CORRUPT_PGNO(pPrevTrunk ? pPrevTrunk->pgno : 1);
       }else{
         rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);
       }
@@ -64703,7 +65326,7 @@ static int allocateBtreePage(
         TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n-1));
       }else if( k>(u32)(pBt->usableSize/4 - 2) ){
         /* Value of k is out of range.  Database corruption */
-        rc = SQLITE_CORRUPT_BKPT;
+        rc = SQLITE_CORRUPT_PGNO(iTrunk);
         goto end_allocate_page;
 #ifndef SQLITE_OMIT_AUTOVACUUM
       }else if( searchList 
@@ -64737,7 +65360,7 @@ static int allocateBtreePage(
           MemPage *pNewTrunk;
           Pgno iNewTrunk = get4byte(&pTrunk->aData[8]);
           if( iNewTrunk>mxPage ){ 
-            rc = SQLITE_CORRUPT_BKPT;
+            rc = SQLITE_CORRUPT_PGNO(iTrunk);
             goto end_allocate_page;
           }
           testcase( iNewTrunk==mxPage );
@@ -64802,7 +65425,7 @@ static int allocateBtreePage(
         iPage = get4byte(&aData[8+closest*4]);
         testcase( iPage==mxPage );
         if( iPage>mxPage ){
-          rc = SQLITE_CORRUPT_BKPT;
+          rc = SQLITE_CORRUPT_PGNO(iTrunk);
           goto end_allocate_page;
         }
         testcase( iPage==mxPage );
@@ -65072,7 +65695,8 @@ static int clearCell(
     return SQLITE_OK;  /* No overflow pages. Return without doing anything */
   }
   if( pCell+pInfo->nSize-1 > pPage->aData+pPage->maskPage ){
-    return SQLITE_CORRUPT_BKPT;  /* Cell extends past end of page */
+    /* Cell extends past end of page */
+    return SQLITE_CORRUPT_PGNO(pPage->pgno);
   }
   ovflPgno = get4byte(pCell + pInfo->nSize - 4);
   assert( pBt->usableSize > 4 );
@@ -66167,7 +66791,7 @@ static int balance_nonroot(
       ** In this case, temporarily copy the cell into the aOvflSpace[]
       ** buffer. It will be copied out again as soon as the aSpace[] buffer
       ** is allocated.  */
-      if( pBt->btsFlags & BTS_SECURE_DELETE ){
+      if( pBt->btsFlags & BTS_FAST_SECURE ){
         int iOff;
 
         iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);
@@ -66890,8 +67514,8 @@ static int balance(BtCursor *pCur){
         rc = balance_deeper(pPage, &pCur->apPage[1]);
         if( rc==SQLITE_OK ){
           pCur->iPage = 1;
+          pCur->ix = 0;
           pCur->aiIdx[0] = 0;
-          pCur->aiIdx[1] = 0;
           assert( pCur->apPage[1]->nOverflow );
         }
       }else{
@@ -67068,7 +67692,7 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
     assert( pX->pKey==0 );
     /* If this is an insert into a table b-tree, invalidate any incrblob 
     ** cursors open on the row being replaced */
-    invalidateIncrblobCursors(p, pX->nKey, 0);
+    invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);
 
     /* If BTREE_SAVEPOSITION is set, the cursor must already be pointing 
     ** to a row with the same key as the new entry being inserted.  */
@@ -67080,9 +67704,6 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
     ** btreeMoveto() call */
     if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){
       loc = 0;
-    }else if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey>0
-               && pCur->info.nKey==pX->nKey-1 ){
-      loc = -1;
     }else if( loc==0 ){
       rc = sqlite3BtreeMovetoUnpacked(pCur, 0, pX->nKey, flags!=0, &loc);
       if( rc ) return rc;
@@ -67120,7 +67741,7 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
   if( rc ) goto end_insert;
   assert( szNew==pPage->xCellSize(pPage, newCell) );
   assert( szNew <= MX_CELL_SIZE(pBt) );
-  idx = pCur->aiIdx[pCur->iPage];
+  idx = pCur->ix;
   if( loc==0 ){
     CellInfo info;
     assert( idx<pPage->nCell );
@@ -67133,12 +67754,18 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
       memcpy(newCell, oldCell, 4);
     }
     rc = clearCell(pPage, oldCell, &info);
-    if( info.nSize==szNew && info.nLocal==info.nPayload ){
+    if( info.nSize==szNew && info.nLocal==info.nPayload 
+     && (!ISAUTOVACUUM || szNew<pPage->minLocal)
+    ){
       /* Overwrite the old cell with the new if they are the same size.
       ** We could also try to do this if the old cell is smaller, then add
       ** the leftover space to the free list.  But experiments show that
       ** doing that is no faster then skipping this optimization and just
-      ** calling dropCell() and insertCell(). */
+      ** calling dropCell() and insertCell(). 
+      **
+      ** This optimization cannot be used on an autovacuum database if the
+      ** new entry uses overflow pages, as the insertCell() call below is
+      ** necessary to add the PTRMAP_OVERFLOW1 pointer-map entry.  */
       assert( rc==SQLITE_OK ); /* clearCell never fails when nLocal==nPayload */
       if( oldCell+szNew > pPage->aDataEnd ) return SQLITE_CORRUPT_BKPT;
       memcpy(oldCell, newCell, szNew);
@@ -67148,7 +67775,8 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
     if( rc ) goto end_insert;
   }else if( loc<0 && pPage->nCell>0 ){
     assert( pPage->leaf );
-    idx = ++pCur->aiIdx[pCur->iPage];
+    idx = ++pCur->ix;
+    pCur->curFlags &= ~BTCF_ValidNKey;
   }else{
     assert( pPage->leaf );
   }
@@ -67244,12 +67872,12 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
   assert( pCur->curFlags & BTCF_WriteFlag );
   assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );
   assert( !hasReadConflicts(p, pCur->pgnoRoot) );
-  assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );
+  assert( pCur->ix<pCur->apPage[pCur->iPage]->nCell );
   assert( pCur->eState==CURSOR_VALID );
   assert( (flags & ~(BTREE_SAVEPOSITION | BTREE_AUXDELETE))==0 );
 
   iCellDepth = pCur->iPage;
-  iCellIdx = pCur->aiIdx[iCellDepth];
+  iCellIdx = pCur->ix;
   pPage = pCur->apPage[iCellDepth];
   pCell = findCell(pPage, iCellIdx);
 
@@ -67283,8 +67911,8 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
   ** sub-tree headed by the child page of the cell being deleted. This makes
   ** balancing the tree following the delete operation easier.  */
   if( !pPage->leaf ){
-    int notUsed = 0;
-    rc = sqlite3BtreePrevious(pCur, &notUsed);
+    rc = sqlite3BtreePrevious(pCur, 0);
+    assert( rc!=SQLITE_DONE );
     if( rc ) return rc;
   }
 
@@ -67298,7 +67926,7 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
   /* If this is a delete operation to remove a row from a table b-tree,
   ** invalidate any incrblob cursors open on the row being deleted.  */
   if( pCur->pKeyInfo==0 ){
-    invalidateIncrblobCursors(p, pCur->info.nKey, 0);
+    invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);
   }
 
   /* Make the page containing the entry to be deleted writable. Then free any
@@ -67366,7 +67994,7 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
       pCur->eState = CURSOR_SKIPNEXT;
       if( iCellIdx>=pPage->nCell ){
         pCur->skipNext = -1;
-        pCur->aiIdx[iCellDepth] = pPage->nCell-1;
+        pCur->ix = pPage->nCell-1;
       }else{
         pCur->skipNext = 1;
       }
@@ -67625,7 +68253,7 @@ SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){
     /* Invalidate all incrblob cursors open on table iTable (assuming iTable
     ** is the root of a table b-tree - if it is not, the following call is
     ** a no-op).  */
-    invalidateIncrblobCursors(p, 0, 1);
+    invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);
     rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);
   }
   sqlite3BtreeLeave(p);
@@ -67879,16 +68507,16 @@ SQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry){
           return moveToRoot(pCur);
         }
         moveToParent(pCur);
-      }while ( pCur->aiIdx[pCur->iPage]>=pCur->apPage[pCur->iPage]->nCell );
+      }while ( pCur->ix>=pCur->apPage[pCur->iPage]->nCell );
 
-      pCur->aiIdx[pCur->iPage]++;
+      pCur->ix++;
       pPage = pCur->apPage[pCur->iPage];
     }
 
     /* Descend to the child node of the cell that the cursor currently 
     ** points at. This is the right-child if (iIdx==pPage->nCell).
     */
-    iIdx = pCur->aiIdx[pCur->iPage];
+    iIdx = pCur->ix;
     if( iIdx==pPage->nCell ){
       rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8]));
     }else{
@@ -68273,6 +68901,7 @@ static int checkTreePage(
         checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);
       }
       maxKey = info.nKey;
+      keyCanBeEqual = 0;     /* Only the first key on the page may ==maxKey */
     }
 
     /* Check the content overflow list */
@@ -69645,7 +70274,7 @@ SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
 */
 SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem *p){
   /* If MEM_Dyn is set then Mem.xDel!=0.  
-  ** Mem.xDel is might not be initialized if MEM_Dyn is clear.
+  ** Mem.xDel might not be initialized if MEM_Dyn is clear.
   */
   assert( (p->flags & MEM_Dyn)==0 || p->xDel!=0 );
 
@@ -69658,6 +70287,35 @@ SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem *p){
   /* Cannot be both MEM_Int and MEM_Real at the same time */
   assert( (p->flags & (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) );
 
+  if( p->flags & MEM_Null ){
+    /* Cannot be both MEM_Null and some other type */
+    assert( (p->flags & (MEM_Int|MEM_Real|MEM_Str|MEM_Blob
+                         |MEM_RowSet|MEM_Frame|MEM_Agg|MEM_Zero))==0 );
+
+    /* If MEM_Null is set, then either the value is a pure NULL (the usual
+    ** case) or it is a pointer set using sqlite3_bind_pointer() or
+    ** sqlite3_result_pointer().  If a pointer, then MEM_Term must also be
+    ** set.
+    */
+    if( (p->flags & (MEM_Term|MEM_Subtype))==(MEM_Term|MEM_Subtype) ){
+      /* This is a pointer type.  There may be a flag to indicate what to
+      ** do with the pointer. */
+      assert( ((p->flags&MEM_Dyn)!=0 ? 1 : 0) +
+              ((p->flags&MEM_Ephem)!=0 ? 1 : 0) +
+              ((p->flags&MEM_Static)!=0 ? 1 : 0) <= 1 );
+
+      /* No other bits set */
+      assert( (p->flags & ~(MEM_Null|MEM_Term|MEM_Subtype
+                           |MEM_Dyn|MEM_Ephem|MEM_Static))==0 );
+    }else{
+      /* A pure NULL might have other flags, such as MEM_Static, MEM_Dyn,
+      ** MEM_Ephem, MEM_Cleared, or MEM_Subtype */
+    }
+  }else{
+    /* The MEM_Cleared bit is only allowed on NULLs */
+    assert( (p->flags & MEM_Cleared)==0 );
+  }
+
   /* The szMalloc field holds the correct memory allocation size */
   assert( p->szMalloc==0
        || p->szMalloc==sqlite3DbMallocSize(p->db,p->zMalloc) );
@@ -69743,26 +70401,24 @@ SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPre
 
   assert( pMem->szMalloc==0
        || pMem->szMalloc==sqlite3DbMallocSize(pMem->db, pMem->zMalloc) );
-  if( pMem->szMalloc<n ){
-    if( n<32 ) n = 32;
-    if( bPreserve && pMem->szMalloc>0 && pMem->z==pMem->zMalloc ){
-      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
-      bPreserve = 0;
-    }else{
-      if( pMem->szMalloc>0 ) sqlite3DbFree(pMem->db, pMem->zMalloc);
-      pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
-    }
-    if( pMem->zMalloc==0 ){
-      sqlite3VdbeMemSetNull(pMem);
-      pMem->z = 0;
-      pMem->szMalloc = 0;
-      return SQLITE_NOMEM_BKPT;
-    }else{
-      pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
-    }
+  if( n<32 ) n = 32;
+  if( bPreserve && pMem->szMalloc>0 && pMem->z==pMem->zMalloc ){
+    pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
+    bPreserve = 0;
+  }else{
+    if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
+    pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
+  }
+  if( pMem->zMalloc==0 ){
+    sqlite3VdbeMemSetNull(pMem);
+    pMem->z = 0;
+    pMem->szMalloc = 0;
+    return SQLITE_NOMEM_BKPT;
+  }else{
+    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
   }
 
-  if( bPreserve && pMem->z && pMem->z!=pMem->zMalloc ){
+  if( bPreserve && pMem->z && ALWAYS(pMem->z!=pMem->zMalloc) ){
     memcpy(pMem->zMalloc, pMem->z, pMem->n);
   }
   if( (pMem->flags&MEM_Dyn)!=0 ){
@@ -69959,7 +70615,7 @@ SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
     ctx.pFunc = pFunc;
     pFunc->xFinalize(&ctx); /* IMP: R-24505-23230 */
     assert( (pMem->flags & MEM_Dyn)==0 );
-    if( pMem->szMalloc>0 ) sqlite3DbFree(pMem->db, pMem->zMalloc);
+    if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
     memcpy(pMem, &t, sizeof(t));
     rc = ctx.isError;
   }
@@ -70010,7 +70666,7 @@ static SQLITE_NOINLINE void vdbeMemClear(Mem *p){
     vdbeMemClearExternAndSetNull(p);
   }
   if( p->szMalloc ){
-    sqlite3DbFree(p->db, p->zMalloc);
+    sqlite3DbFreeNN(p->db, p->zMalloc);
     p->szMalloc = 0;
   }
   p->z = 0;
@@ -70038,7 +70694,7 @@ SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p){
 ** If the double is out of range of a 64-bit signed integer then
 ** return the closest available 64-bit signed integer.
 */
-static i64 doubleToInt64(double r){
+static SQLITE_NOINLINE i64 doubleToInt64(double r){
 #ifdef SQLITE_OMIT_FLOATING_POINT
   /* When floating-point is omitted, double and int64 are the same thing */
   return r;
@@ -70074,6 +70730,11 @@ static i64 doubleToInt64(double r){
 **
 ** If pMem represents a string value, its encoding might be changed.
 */
+static SQLITE_NOINLINE i64 memIntValue(Mem *pMem){
+  i64 value = 0;
+  sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
+  return value;
+}
 SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){
   int flags;
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
@@ -70084,10 +70745,8 @@ SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){
   }else if( flags & MEM_Real ){
     return doubleToInt64(pMem->u.r);
   }else if( flags & (MEM_Str|MEM_Blob) ){
-    i64 value = 0;
     assert( pMem->z || pMem->n==0 );
-    sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
-    return value;
+    return memIntValue(pMem);
   }else{
     return 0;
   }
@@ -70099,6 +70758,12 @@ SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){
 ** value.  If it is a string or blob, try to convert it to a double.
 ** If it is a NULL, return 0.0.
 */
+static SQLITE_NOINLINE double memRealValue(Mem *pMem){
+  /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
+  double val = (double)0;
+  sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
+  return val;
+}
 SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
   assert( EIGHT_BYTE_ALIGNMENT(pMem) );
@@ -70107,10 +70772,7 @@ SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){
   }else if( pMem->flags & MEM_Int ){
     return (double)pMem->u.i;
   }else if( pMem->flags & (MEM_Str|MEM_Blob) ){
-    /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
-    double val = (double)0;
-    sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
-    return val;
+    return memRealValue(pMem);
   }else{
     /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
     return (double)0;
@@ -70315,6 +70977,27 @@ SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
   }
 }
 
+/* A no-op destructor */
+static void sqlite3NoopDestructor(void *p){ UNUSED_PARAMETER(p); }
+
+/*
+** Set the value stored in *pMem should already be a NULL.
+** Also store a pointer to go with it.
+*/
+SQLITE_PRIVATE void sqlite3VdbeMemSetPointer(
+  Mem *pMem,
+  void *pPtr,
+  const char *zPType,
+  void (*xDestructor)(void*)
+){
+  assert( pMem->flags==MEM_Null );
+  pMem->u.zPType = zPType ? zPType : "";
+  pMem->z = pPtr;
+  pMem->flags = MEM_Null|MEM_Dyn|MEM_Subtype|MEM_Term;
+  pMem->eSubtype = 'p';
+  pMem->xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
+}
+
 #ifndef SQLITE_OMIT_FLOATING_POINT
 /*
 ** Delete any previous value and set the value stored in *pMem to val,
@@ -70735,7 +71418,7 @@ static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
             pRec->aMem[i].db = db;
           }
         }else{
-          sqlite3DbFree(db, pRec);
+          sqlite3DbFreeNN(db, pRec);
           pRec = 0;
         }
       }
@@ -70847,7 +71530,7 @@ static int valueFromFunction(
     for(i=0; i<nVal; i++){
       sqlite3ValueFree(apVal[i]);
     }
-    sqlite3DbFree(db, apVal);
+    sqlite3DbFreeNN(db, apVal);
   }
 
   *ppVal = pVal;
@@ -70935,7 +71618,7 @@ static int valueFromExpr(
     }
   }else if( op==TK_UMINUS ) {
     /* This branch happens for multiple negative signs.  Ex: -(-5) */
-    if( SQLITE_OK==sqlite3ValueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal) 
+    if( SQLITE_OK==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx) 
      && pVal!=0
     ){
       sqlite3VdbeMemNumerify(pVal);
@@ -71046,7 +71729,7 @@ static void recordFunc(
     putVarint32(&aRet[1], iSerial);
     sqlite3VdbeSerialPut(&aRet[1+nSerial], argv[0], iSerial);
     sqlite3_result_blob(context, aRet, nRet, SQLITE_TRANSIENT);
-    sqlite3DbFree(db, aRet);
+    sqlite3DbFreeNN(db, aRet);
   }
 }
 
@@ -71092,14 +71775,13 @@ static int stat4ValueFromExpr(
   /* Skip over any TK_COLLATE nodes */
   pExpr = sqlite3ExprSkipCollate(pExpr);
 
+  assert( pExpr==0 || pExpr->op!=TK_REGISTER || pExpr->op2!=TK_VARIABLE );
   if( !pExpr ){
     pVal = valueNew(db, pAlloc);
     if( pVal ){
       sqlite3VdbeMemSetNull((Mem*)pVal);
     }
-  }else if( pExpr->op==TK_VARIABLE
-        || NEVER(pExpr->op==TK_REGISTER && pExpr->op2==TK_VARIABLE)
-  ){
+  }else if( pExpr->op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){
     Vdbe *v;
     int iBindVar = pExpr->iColumn;
     sqlite3VdbeSetVarmask(pParse->pVdbe, iBindVar);
@@ -71107,9 +71789,7 @@ static int stat4ValueFromExpr(
       pVal = valueNew(db, pAlloc);
       if( pVal ){
         rc = sqlite3VdbeMemCopy((Mem*)pVal, &v->aVar[iBindVar-1]);
-        if( rc==SQLITE_OK ){
-          sqlite3ValueApplyAffinity(pVal, affinity, ENC(db));
-        }
+        sqlite3ValueApplyAffinity(pVal, affinity, ENC(db));
         pVal->db = pParse->db;
       }
     }
@@ -71273,7 +71953,7 @@ SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord *pRec){
       sqlite3VdbeMemRelease(&aMem[i]);
     }
     sqlite3KeyInfoUnref(pRec->pKeyInfo);
-    sqlite3DbFree(db, pRec);
+    sqlite3DbFreeNN(db, pRec);
   }
 }
 #endif /* ifdef SQLITE_ENABLE_STAT4 */
@@ -71297,7 +71977,7 @@ SQLITE_PRIVATE void sqlite3ValueSetStr(
 SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v){
   if( !v ) return;
   sqlite3VdbeMemRelease((Mem *)v);
-  sqlite3DbFree(((Mem*)v)->db, v);
+  sqlite3DbFreeNN(((Mem*)v)->db, v);
 }
 
 /*
@@ -71383,16 +72063,14 @@ SQLITE_PRIVATE void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){
 /*
 ** Remember the SQL string for a prepared statement.
 */
-SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepareV2){
-  assert( isPrepareV2==1 || isPrepareV2==0 );
+SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){
   if( p==0 ) return;
-  if( !isPrepareV2 ) p->expmask = 0;
-#if defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_ENABLE_SQLLOG)
-  if( !isPrepareV2 ) return;
-#endif
+  p->prepFlags = prepFlags;
+  if( (prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){
+    p->expmask = 0;
+  }
   assert( p->zSql==0 );
   p->zSql = sqlite3DbStrNDup(p->db, z, n);
-  p->isPrepareV2 = (u8)isPrepareV2;
 }
 
 /*
@@ -71414,8 +72092,10 @@ SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
   zTmp = pA->zSql;
   pA->zSql = pB->zSql;
   pB->zSql = zTmp;
-  pB->isPrepareV2 = pA->isPrepareV2;
   pB->expmask = pA->expmask;
+  pB->prepFlags = pA->prepFlags;
+  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
+  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++;
 }
 
 /*
@@ -71571,6 +72251,9 @@ SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){
 ** "s" character in zTypes[], the register is a string if the argument is
 ** not NULL, or OP_Null if the value is a null pointer.  For each "i" character
 ** in zTypes[], the register is initialized to an integer.
+**
+** If the input string does not end with "X" then an OP_ResultRow instruction
+** is generated for the values inserted.
 */
 SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
   va_list ap;
@@ -71580,12 +72263,15 @@ SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes,
   for(i=0; (c = zTypes[i])!=0; i++){
     if( c=='s' ){
       const char *z = va_arg(ap, const char*);
-      sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest++, 0, z, 0);
+      sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest+i, 0, z, 0);
+    }else if( c=='i' ){
+      sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest+i);
     }else{
-      assert( c=='i' );
-      sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest++);
+      goto skip_op_resultrow;
     }
   }
+  sqlite3VdbeAddOp2(p, OP_ResultRow, iDest, i);
+skip_op_resultrow:
   va_end(ap);
 }
 
@@ -72140,7 +72826,7 @@ SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){
 */
 static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){
   if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){
-    sqlite3DbFree(db, pDef);
+    sqlite3DbFreeNN(db, pDef);
   }
 }
 
@@ -72151,11 +72837,11 @@ static void vdbeFreeOpArray(sqlite3 *, Op *, int);
 */
 static SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){
   if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);
-  sqlite3DbFree(db, p);
+  sqlite3DbFreeNN(db, p);
 }
 static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){
   freeEphemeralFunction(db, p->pFunc);
-  sqlite3DbFree(db, p);
+ sqlite3DbFreeNN(db, p);
 }
 static void freeP4(sqlite3 *db, int p4type, void *p4){
   assert( db );
@@ -72208,14 +72894,14 @@ static void freeP4(sqlite3 *db, int p4type, void *p4){
 static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
   if( aOp ){
     Op *pOp;
-    for(pOp=aOp; pOp<&aOp[nOp]; pOp++){
-      if( pOp->p4type ) freeP4(db, pOp->p4type, pOp->p4.p);
+    for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){
+      if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);
 #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
       sqlite3DbFree(db, pOp->zComment);
 #endif     
     }
+    sqlite3DbFreeNN(db, aOp);
   }
-  sqlite3DbFree(db, aOp);
 }
 
 /*
@@ -72888,7 +73574,7 @@ static void releaseMemArray(Mem *p, int N){
       if( p->flags&(MEM_Agg|MEM_Dyn|MEM_Frame|MEM_RowSet) ){
         sqlite3VdbeMemRelease(p);
       }else if( p->szMalloc ){
-        sqlite3DbFree(db, p->zMalloc);
+        sqlite3DbFreeNN(db, p->zMalloc);
         p->szMalloc = 0;
       }
 
@@ -73364,8 +74050,8 @@ SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
       break;
     }
     case CURTYPE_BTREE: {
-      if( pCx->pBtx ){
-        sqlite3BtreeClose(pCx->pBtx);
+      if( pCx->isEphemeral ){
+        if( pCx->pBtx ) sqlite3BtreeClose(pCx->pBtx);
         /* The pCx->pCursor will be close automatically, if it exists, by
         ** the call above. */
       }else{
@@ -73489,17 +74175,18 @@ static void Cleanup(Vdbe *p){
 ** be called on an SQL statement before sqlite3_step().
 */
 SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
-  Mem *pColName;
   int n;
   sqlite3 *db = p->db;
 
-  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
-  sqlite3DbFree(db, p->aColName);
+  if( p->nResColumn ){
+    releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
+    sqlite3DbFree(db, p->aColName);
+  }
   n = nResColumn*COLNAME_N;
   p->nResColumn = (u16)nResColumn;
-  p->aColName = pColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );
+  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );
   if( p->aColName==0 ) return;
-  initMemArray(p->aColName, n, p->db, MEM_Null);
+  initMemArray(p->aColName, n, db, MEM_Null);
 }
 
 /*
@@ -74149,10 +74836,10 @@ SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p){
     sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
     sqlite3EndBenignMalloc();
     db->bBenignMalloc--;
-    db->errCode = rc;
-  }else{
-    sqlite3Error(db, rc);
+  }else if( db->pErr ){
+    sqlite3ValueSetNull(db->pErr);
   }
+  db->errCode = rc;
   return rc;
 }
 
@@ -74259,7 +74946,6 @@ SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p){
     }
   }
 #endif
-  p->iCurrentTime = 0;
   p->magic = VDBE_MAGIC_RESET;
   return p->rc & db->errMask;
 }
@@ -74298,16 +74984,18 @@ SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp,
   while( *pp ){
     AuxData *pAux = *pp;
     if( (iOp<0)
-     || (pAux->iOp==iOp && (pAux->iArg>31 || !(mask & MASKBIT32(pAux->iArg))))
+     || (pAux->iAuxOp==iOp
+          && pAux->iAuxArg>=0
+          && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))
     ){
-      testcase( pAux->iArg==31 );
-      if( pAux->xDelete ){
-        pAux->xDelete(pAux->pAux);
+      testcase( pAux->iAuxArg==31 );
+      if( pAux->xDeleteAux ){
+        pAux->xDeleteAux(pAux->pAux);
       }
-      *pp = pAux->pNext;
+      *pp = pAux->pNextAux;
       sqlite3DbFree(db, pAux);
     }else{
-      pp= &pAux->pNext;
+      pp= &pAux->pNextAux;
     }
   }
 }
@@ -74369,7 +75057,7 @@ SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p){
   }
   p->magic = VDBE_MAGIC_DEAD;
   p->db = 0;
-  sqlite3DbFree(db, p);
+  sqlite3DbFreeNN(db, p);
 }
 
 /*
@@ -75059,7 +75747,6 @@ static int vdbeCompareMemString(
   }else{
     int rc;
     const void *v1, *v2;
-    int n1, n2;
     Mem c1;
     Mem c2;
     sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);
@@ -75067,11 +75754,13 @@ static int vdbeCompareMemString(
     sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);
     sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);
     v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
-    n1 = v1==0 ? 0 : c1.n;
     v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
-    n2 = v2==0 ? 0 : c2.n;
-    rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);
-    if( (v1==0 || v2==0) && prcErr ) *prcErr = SQLITE_NOMEM_BKPT;
+    if( (v1==0 || v2==0) ){
+      if( prcErr ) *prcErr = SQLITE_NOMEM_BKPT;
+      rc = 0;
+    }else{
+      rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);
+    }
     sqlite3VdbeMemRelease(&c1);
     sqlite3VdbeMemRelease(&c2);
     return rc;
@@ -75856,6 +76545,13 @@ SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe *v){
   return v->db;
 }
 
+/*
+** Return the SQLITE_PREPARE flags for a Vdbe.
+*/
+SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe *v){
+  return v->prepFlags;
+}
+
 /*
 ** Return a pointer to an sqlite3_value structure containing the value bound
 ** parameter iVar of VM v. Except, if the value is an SQL NULL, return 
@@ -75868,6 +76564,7 @@ SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff
   assert( iVar>0 );
   if( v ){
     Mem *pMem = &v->aVar[iVar-1];
+    assert( (v->db->flags & SQLITE_EnableQPSG)==0 );
     if( 0==(pMem->flags & MEM_Null) ){
       sqlite3_value *pRet = sqlite3ValueNew(v->db);
       if( pRet ){
@@ -75887,6 +76584,7 @@ SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff
 */
 SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
   assert( iVar>0 );
+  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );
   if( iVar>=32 ){
     v->expmask |= 0x80000000;
   }else{
@@ -75894,6 +76592,28 @@ SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
   }
 }
 
+/*
+** Cause a function to throw an error if it was call from OP_PureFunc
+** rather than OP_Function.
+**
+** OP_PureFunc means that the function must be deterministic, and should
+** throw an error if it is given inputs that would make it non-deterministic.
+** This routine is invoked by date/time functions that use non-deterministic
+** features such as 'now'.
+*/
+SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context *pCtx){
+#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+  if( pCtx->pVdbe==0 ) return 1;
+#endif
+  if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){
+    sqlite3_result_error(pCtx, 
+       "non-deterministic function in index expression or CHECK constraint",
+       -1);
+    return 0;
+  }
+  return 1;
+}
+
 #ifndef SQLITE_OMIT_VIRTUALTABLE
 /*
 ** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored
@@ -75928,7 +76648,7 @@ static void vdbeFreeUnpacked(sqlite3 *db, int nField, UnpackedRecord *p){
       Mem *pMem = &p->aMem[i];
       if( pMem->zMalloc ) sqlite3VdbeMemRelease(pMem);
     }
-    sqlite3DbFree(db, p);
+    sqlite3DbFreeNN(db, p);
   }
 }
 #endif /* SQLITE_ENABLE_PREUPDATE_HOOK */
@@ -75995,7 +76715,7 @@ SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(
     for(i=0; i<pCsr->nField; i++){
       sqlite3VdbeMemRelease(&preupdate.aNew[i]);
     }
-    sqlite3DbFree(db, preupdate.aNew);
+    sqlite3DbFreeNN(db, preupdate.aNew);
   }
 }
 #endif /* SQLITE_ENABLE_PREUPDATE_HOOK */
@@ -76158,7 +76878,7 @@ SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
     sqlite3VdbeMemRelease(&p->aVar[i]);
     p->aVar[i].flags = MEM_Null;
   }
-  assert( p->isPrepareV2 || p->expmask==0 );
+  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );
   if( p->expmask ){
     p->expired = 1;
   }
@@ -76203,6 +76923,19 @@ SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value *pVal){
   Mem *pMem = (Mem*)pVal;
   return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0);
 }
+SQLITE_API void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){
+  Mem *p = (Mem*)pVal;
+  if( (p->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==
+                 (MEM_Null|MEM_Term|MEM_Subtype)
+   && zPType!=0
+   && p->eSubtype=='p'
+   && strcmp(p->u.zPType, zPType)==0
+  ){
+    return (void*)p->z;
+  }else{
+    return 0;
+  }
+}
 SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
   return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);
 }
@@ -76381,6 +77114,18 @@ SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetNull(pCtx->pOut);
 }
+SQLITE_API void sqlite3_result_pointer(
+  sqlite3_context *pCtx,
+  void *pPtr,
+  const char *zPType,
+  void (*xDestructor)(void*)
+){
+  Mem *pOut = pCtx->pOut;
+  assert( sqlite3_mutex_held(pOut->db->mutex) );
+  sqlite3VdbeMemRelease(pOut);
+  pOut->flags = MEM_Null;
+  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
+}
 SQLITE_API void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){
   Mem *pOut = pCtx->pOut;
   assert( sqlite3_mutex_held(pOut->db->mutex) );
@@ -76637,8 +77382,11 @@ static int sqlite3Step(Vdbe *p){
        || (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE
   );
   assert( (p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE) || p->rc==p->rcApp );
-  if( p->isPrepareV2 && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
-    /* If this statement was prepared using sqlite3_prepare_v2(), and an
+  if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 
+   && rc!=SQLITE_ROW 
+   && rc!=SQLITE_DONE 
+  ){
+    /* If this statement was prepared using saved SQL and an 
     ** error has occurred, then return the error code in p->rc to the
     ** caller. Set the error code in the database handle to the same value.
     */ 
@@ -76808,6 +77556,12 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
 /*
 ** Return the auxiliary data pointer, if any, for the iArg'th argument to
 ** the user-function defined by pCtx.
+**
+** The left-most argument is 0.
+**
+** Undocumented behavior:  If iArg is negative then access a cache of
+** auxiliary data pointers that is available to all functions within a
+** single prepared statement.  The iArg values must match.
 */
 SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
   AuxData *pAuxData;
@@ -76818,17 +77572,24 @@ SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
 #else
   assert( pCtx->pVdbe!=0 );
 #endif
-  for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNext){
-    if( pAuxData->iOp==pCtx->iOp && pAuxData->iArg==iArg ) break;
+  for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
+    if(  pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
+      return pAuxData->pAux;
+    }
   }
-
-  return (pAuxData ? pAuxData->pAux : 0);
+  return 0;
 }
 
 /*
 ** Set the auxiliary data pointer and delete function, for the iArg'th
 ** argument to the user-function defined by pCtx. Any previous value is
 ** deleted by calling the delete function specified when it was set.
+**
+** The left-most argument is 0.
+**
+** Undocumented behavior:  If iArg is negative then make the data available
+** to all functions within the current prepared statement using iArg as an
+** access code.
 */
 SQLITE_API void sqlite3_set_auxdata(
   sqlite3_context *pCtx, 
@@ -76840,33 +77601,34 @@ SQLITE_API void sqlite3_set_auxdata(
   Vdbe *pVdbe = pCtx->pVdbe;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
-  if( iArg<0 ) goto failed;
 #ifdef SQLITE_ENABLE_STAT3_OR_STAT4
   if( pVdbe==0 ) goto failed;
 #else
   assert( pVdbe!=0 );
 #endif
 
-  for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNext){
-    if( pAuxData->iOp==pCtx->iOp && pAuxData->iArg==iArg ) break;
+  for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
+    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
+      break;
+    }
   }
   if( pAuxData==0 ){
     pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));
     if( !pAuxData ) goto failed;
-    pAuxData->iOp = pCtx->iOp;
-    pAuxData->iArg = iArg;
-    pAuxData->pNext = pVdbe->pAuxData;
+    pAuxData->iAuxOp = pCtx->iOp;
+    pAuxData->iAuxArg = iArg;
+    pAuxData->pNextAux = pVdbe->pAuxData;
     pVdbe->pAuxData = pAuxData;
     if( pCtx->fErrorOrAux==0 ){
       pCtx->isError = 0;
       pCtx->fErrorOrAux = 1;
     }
-  }else if( pAuxData->xDelete ){
-    pAuxData->xDelete(pAuxData->pAux);
+  }else if( pAuxData->xDeleteAux ){
+    pAuxData->xDeleteAux(pAuxData->pAux);
   }
 
   pAuxData->pAux = pAux;
-  pAuxData->xDelete = xDelete;
+  pAuxData->xDeleteAux = xDelete;
   return;
 
 failed:
@@ -77263,7 +78025,7 @@ static int vdbeUnbind(Vdbe *p, int i){
   ** as if there had been a schema change, on the first sqlite3_step() call
   ** following any change to the bindings of that parameter.
   */
-  assert( p->isPrepareV2 || p->expmask==0 );
+  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );
   if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){
     p->expired = 1;
   }
@@ -77293,8 +78055,10 @@ static int bindText(
       if( rc==SQLITE_OK && encoding!=0 ){
         rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));
       }
-      sqlite3Error(p->db, rc);
-      rc = sqlite3ApiExit(p->db, rc);
+      if( rc ){
+        sqlite3Error(p->db, rc);
+        rc = sqlite3ApiExit(p->db, rc);
+      }
     }
     sqlite3_mutex_leave(p->db->mutex);
   }else if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){
@@ -77365,6 +78129,24 @@ SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
   }
   return rc;
 }
+SQLITE_API int sqlite3_bind_pointer(
+  sqlite3_stmt *pStmt,
+  int i,
+  void *pPtr,
+  const char *zPTtype,
+  void (*xDestructor)(void*)
+){
+  int rc;
+  Vdbe *p = (Vdbe*)pStmt;
+  rc = vdbeUnbind(p, i);
+  if( rc==SQLITE_OK ){
+    sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);
+    sqlite3_mutex_leave(p->db->mutex);
+  }else if( xDestructor ){
+    xDestructor(pPtr);
+  }
+  return rc;
+}
 SQLITE_API int sqlite3_bind_text( 
   sqlite3_stmt *pStmt, 
   int i, 
@@ -77527,11 +78309,11 @@ SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *
   if( pFrom->nVar!=pTo->nVar ){
     return SQLITE_ERROR;
   }
-  assert( pTo->isPrepareV2 || pTo->expmask==0 );
+  assert( (pTo->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pTo->expmask==0 );
   if( pTo->expmask ){
     pTo->expired = 1;
   }
-  assert( pFrom->isPrepareV2 || pFrom->expmask==0 );
+  assert( (pFrom->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pFrom->expmask==0 );
   if( pFrom->expmask ){
     pFrom->expired = 1;
   }
@@ -77601,8 +78383,19 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
     return 0;
   }
 #endif
-  v = pVdbe->aCounter[op];
-  if( resetFlag ) pVdbe->aCounter[op] = 0;
+  if( op==SQLITE_STMTSTATUS_MEMUSED ){
+    sqlite3 *db = pVdbe->db;
+    sqlite3_mutex_enter(db->mutex);
+    v = 0;
+    db->pnBytesFreed = (int*)&v;
+    sqlite3VdbeClearObject(db, pVdbe);
+    sqlite3DbFree(db, pVdbe);
+    db->pnBytesFreed = 0;
+    sqlite3_mutex_leave(db->mutex);
+  }else{
+    v = pVdbe->aCounter[op];
+    if( resetFlag ) pVdbe->aCounter[op] = 0;
+  }
   return (int)v;
 }
 
@@ -78581,6 +79374,7 @@ static void registerTrace(int iReg, Mem *p){
   printf("REG[%d] = ", iReg);
   memTracePrint(p);
   printf("\n");
+  sqlite3VdbeCheckMemInvariants(p);
 }
 #endif
 
@@ -78756,7 +79550,7 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
   int iCompare = 0;          /* Result of last comparison */
   unsigned nVmStep = 0;      /* Number of virtual machine steps */
 #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
-  unsigned nProgressLimit = 0;/* Invoke xProgress() when nVmStep reaches this */
+  unsigned nProgressLimit;   /* Invoke xProgress() when nVmStep reaches this */
 #endif
   Mem *aMem = p->aMem;       /* Copy of p->aMem */
   Mem *pIn1 = 0;             /* 1st input operand */
@@ -78788,6 +79582,8 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
     u32 iPrior = p->aCounter[SQLITE_STMTSTATUS_VM_STEP];
     assert( 0 < db->nProgressOps );
     nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);
+  }else{
+    nProgressLimit = 0xffffffff;
   }
 #endif
 #ifdef SQLITE_DEBUG
@@ -78947,7 +79743,7 @@ case OP_Goto: {             /* jump */
   pOp = &aOp[pOp->p2 - 1];
 
   /* Opcodes that are used as the bottom of a loop (OP_Next, OP_Prev,
-  ** OP_VNext, OP_RowSetNext, or OP_SorterNext) all jump here upon
+  ** OP_VNext, or OP_SorterNext) all jump here upon
   ** completion.  Check to see if sqlite3_interrupt() has been called
   ** or if the progress callback needs to be invoked. 
   **
@@ -78965,7 +79761,7 @@ case OP_Goto: {             /* jump */
   ** If the progress callback returns non-zero, exit the virtual machine with
   ** a return code SQLITE_ABORT.
   */
-  if( db->xProgress!=0 && nVmStep>=nProgressLimit ){
+  if( nVmStep>=nProgressLimit && db->xProgress!=0 ){
     assert( db->nProgressOps!=0 );
     nProgressLimit = nVmStep + db->nProgressOps - (nVmStep%db->nProgressOps);
     if( db->xProgress(db->pProgressArg) ){
@@ -79335,7 +80131,7 @@ case OP_Null: {           /* out2 */
 case OP_SoftNull: {
   assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );
   pOut = &aMem[pOp->p1];
-  pOut->flags = (pOut->flags|MEM_Null)&~MEM_Undefined;
+  pOut->flags = (pOut->flags&~(MEM_Undefined|MEM_AffMask))|MEM_Null;
   break;
 }
 
@@ -79507,7 +80303,7 @@ case OP_ResultRow: {
   /* Run the progress counter just before returning.
   */
   if( db->xProgress!=0
-   && nVmStep>=nProgressLimit
+   && nVmStep>=nProgressLimit 
    && db->xProgress(db->pProgressArg)!=0
   ){
     rc = SQLITE_INTERRUPT;
@@ -79678,7 +80474,6 @@ case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
   type2 = numericType(pIn2);
   pOut = &aMem[pOp->p3];
   flags = pIn1->flags | pIn2->flags;
-  if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null;
   if( (type1 & type2 & MEM_Int)!=0 ){
     iA = pIn1->u.i;
     iB = pIn2->u.i;
@@ -79702,6 +80497,8 @@ case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
     }
     pOut->u.i = iB;
     MemSetTypeFlag(pOut, MEM_Int);
+  }else if( (flags & MEM_Null)!=0 ){
+    goto arithmetic_result_is_null;
   }else{
     bIntint = 0;
 fp_math:
@@ -79749,7 +80546,7 @@ case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
 
 /* Opcode: CollSeq P1 * * P4
 **
-** P4 is a pointer to a CollSeq struct. If the next call to a user function
+** P4 is a pointer to a CollSeq object. If the next call to a user function
 ** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will
 ** be returned. This is used by the built-in min(), max() and nullif()
 ** functions.
@@ -79770,117 +80567,6 @@ case OP_CollSeq: {
   break;
 }
 
-/* Opcode: Function0 P1 P2 P3 P4 P5
-** Synopsis: r[P3]=func(r[P2@P5])
-**
-** Invoke a user function (P4 is a pointer to a FuncDef object that
-** defines the function) with P5 arguments taken from register P2 and
-** successors.  The result of the function is stored in register P3.
-** Register P3 must not be one of the function inputs.
-**
-** P1 is a 32-bit bitmask indicating whether or not each argument to the 
-** function was determined to be constant at compile time. If the first
-** argument was constant then bit 0 of P1 is set. This is used to determine
-** whether meta data associated with a user function argument using the
-** sqlite3_set_auxdata() API may be safely retained until the next
-** invocation of this opcode.
-**
-** See also: Function, AggStep, AggFinal
-*/
-/* Opcode: Function P1 P2 P3 P4 P5
-** Synopsis: r[P3]=func(r[P2@P5])
-**
-** Invoke a user function (P4 is a pointer to an sqlite3_context object that
-** contains a pointer to the function to be run) with P5 arguments taken
-** from register P2 and successors.  The result of the function is stored
-** in register P3.  Register P3 must not be one of the function inputs.
-**
-** P1 is a 32-bit bitmask indicating whether or not each argument to the 
-** function was determined to be constant at compile time. If the first
-** argument was constant then bit 0 of P1 is set. This is used to determine
-** whether meta data associated with a user function argument using the
-** sqlite3_set_auxdata() API may be safely retained until the next
-** invocation of this opcode.
-**
-** SQL functions are initially coded as OP_Function0 with P4 pointing
-** to a FuncDef object.  But on first evaluation, the P4 operand is
-** automatically converted into an sqlite3_context object and the operation
-** changed to this OP_Function opcode.  In this way, the initialization of
-** the sqlite3_context object occurs only once, rather than once for each
-** evaluation of the function.
-**
-** See also: Function0, AggStep, AggFinal
-*/
-case OP_Function0: {
-  int n;
-  sqlite3_context *pCtx;
-
-  assert( pOp->p4type==P4_FUNCDEF );
-  n = pOp->p5;
-  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );
-  assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );
-  assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );
-  pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));
-  if( pCtx==0 ) goto no_mem;
-  pCtx->pOut = 0;
-  pCtx->pFunc = pOp->p4.pFunc;
-  pCtx->iOp = (int)(pOp - aOp);
-  pCtx->pVdbe = p;
-  pCtx->argc = n;
-  pOp->p4type = P4_FUNCCTX;
-  pOp->p4.pCtx = pCtx;
-  pOp->opcode = OP_Function;
-  /* Fall through into OP_Function */
-}
-case OP_Function: {
-  int i;
-  sqlite3_context *pCtx;
-
-  assert( pOp->p4type==P4_FUNCCTX );
-  pCtx = pOp->p4.pCtx;
-
-  /* If this function is inside of a trigger, the register array in aMem[]
-  ** might change from one evaluation to the next.  The next block of code
-  ** checks to see if the register array has changed, and if so it
-  ** reinitializes the relavant parts of the sqlite3_context object */
-  pOut = &aMem[pOp->p3];
-  if( pCtx->pOut != pOut ){
-    pCtx->pOut = pOut;
-    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
-  }
-
-  memAboutToChange(p, pOut);
-#ifdef SQLITE_DEBUG
-  for(i=0; i<pCtx->argc; i++){
-    assert( memIsValid(pCtx->argv[i]) );
-    REGISTER_TRACE(pOp->p2+i, pCtx->argv[i]);
-  }
-#endif
-  MemSetTypeFlag(pOut, MEM_Null);
-  pCtx->fErrorOrAux = 0;
-  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);/* IMP: R-24505-23230 */
-
-  /* If the function returned an error, throw an exception */
-  if( pCtx->fErrorOrAux ){
-    if( pCtx->isError ){
-      sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));
-      rc = pCtx->isError;
-    }
-    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
-    if( rc ) goto abort_due_to_error;
-  }
-
-  /* Copy the result of the function into register P3 */
-  if( pOut->flags & (MEM_Str|MEM_Blob) ){
-    sqlite3VdbeChangeEncoding(pOut, encoding);
-    if( sqlite3VdbeMemTooBig(pOut) ) goto too_big;
-  }
-
-  REGISTER_TRACE(pOp->p3, pOut);
-  UPDATE_MAX_BLOBSIZE(pOut);
-  break;
-}
-
 /* Opcode: BitAnd P1 P2 P3 * *
 ** Synopsis: r[P3]=r[P1]&r[P2]
 **
@@ -80030,11 +80716,11 @@ case OP_RealAffinity: {                  /* in1 */
 ** Force the value in register P1 to be the type defined by P2.
 ** 
 ** <ul>
-** <li value="97"> TEXT
-** <li value="98"> BLOB
-** <li value="99"> NUMERIC
-** <li value="100"> INTEGER
-** <li value="101"> REAL
+** <li> P2=='A' &rarr; BLOB
+** <li> P2=='B' &rarr; TEXT
+** <li> P2=='C' &rarr; NUMERIC
+** <li> P2=='D' &rarr; INTEGER
+** <li> P2=='E' &rarr; REAL
 ** </ul>
 **
 ** A NULL value is not changed by this routine.  It remains NULL.
@@ -80613,6 +81299,24 @@ case OP_NotNull: {            /* same as TK_NOTNULL, jump, in1 */
   break;
 }
 
+/* Opcode: IfNullRow P1 P2 P3 * *
+** Synopsis: if P1.nullRow then r[P3]=NULL, goto P2
+**
+** Check the cursor P1 to see if it is currently pointing at a NULL row.
+** If it is, then set register P3 to NULL and jump immediately to P2.
+** If P1 is not on a NULL row, then fall through without making any
+** changes.
+*/
+case OP_IfNullRow: {         /* jump */
+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );
+  assert( p->apCsr[pOp->p1]!=0 );
+  if( p->apCsr[pOp->p1]->nullRow ){
+    sqlite3VdbeMemSetNull(aMem + pOp->p3);
+    goto jump_to_p2;
+  }
+  break;
+}
+
 /* Opcode: Column P1 P2 P3 P4 P5
 ** Synopsis: r[P3]=PX
 **
@@ -80624,7 +81328,7 @@ case OP_NotNull: {            /* same as TK_NOTNULL, jump, in1 */
 **
 ** The value extracted is stored in register P3.
 **
-** If the column contains fewer than P2 fields, then extract a NULL.  Or,
+** If the record contains fewer than P2 fields, then extract a NULL.  Or,
 ** if the P4 argument is a P4_MEM use the value of the P4 argument as
 ** the result.
 **
@@ -80633,7 +81337,7 @@ case OP_NotNull: {            /* same as TK_NOTNULL, jump, in1 */
 ** The first OP_Column against a pseudo-table after the value of the content
 ** register has changed should have this bit set.
 **
-** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 when
+** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then
 ** the result is guaranteed to only be used as the argument of a length()
 ** or typeof() function, respectively.  The loading of large blobs can be
 ** skipped for length() and all content loading can be skipped for typeof().
@@ -80659,7 +81363,9 @@ case OP_Column: {
   pC = p->apCsr[pOp->p1];
   p2 = pOp->p2;
 
-  /* If the cursor cache is stale, bring it up-to-date */
+  /* If the cursor cache is stale (meaning it is not currently point at
+  ** the correct row) then bring it up-to-date by doing the necessary 
+  ** B-Tree seek. */
   rc = sqlite3VdbeCursorMoveto(&pC, &p2);
   if( rc ) goto abort_due_to_error;
 
@@ -80888,24 +81594,24 @@ case OP_Column: {
 **
 ** Apply affinities to a range of P2 registers starting with P1.
 **
-** P4 is a string that is P2 characters long. The nth character of the
-** string indicates the column affinity that should be used for the nth
+** P4 is a string that is P2 characters long. The N-th character of the
+** string indicates the column affinity that should be used for the N-th
 ** memory cell in the range.
 */
 case OP_Affinity: {
   const char *zAffinity;   /* The affinity to be applied */
-  char cAff;               /* A single character of affinity */
 
   zAffinity = pOp->p4.z;
   assert( zAffinity!=0 );
+  assert( pOp->p2>0 );
   assert( zAffinity[pOp->p2]==0 );
   pIn1 = &aMem[pOp->p1];
-  while( (cAff = *(zAffinity++))!=0 ){
+  do{
     assert( pIn1 <= &p->aMem[(p->nMem+1 - p->nCursor)] );
     assert( memIsValid(pIn1) );
-    applyAffinity(pIn1, cAff, encoding);
+    applyAffinity(pIn1, *(zAffinity++), encoding);
     pIn1++;
-  }
+  }while( zAffinity[0] );
   break;
 }
 
@@ -80916,8 +81622,8 @@ case OP_Affinity: {
 ** use as a data record in a database table or as a key
 ** in an index.  The OP_Column opcode can decode the record later.
 **
-** P4 may be a string that is P2 characters long.  The nth character of the
-** string indicates the column affinity that should be used for the nth
+** P4 may be a string that is P2 characters long.  The N-th character of the
+** string indicates the column affinity that should be used for the N-th
 ** field of the index key.
 **
 ** The mapping from character to affinity is given by the SQLITE_AFF_
@@ -81076,7 +81782,6 @@ case OP_MakeRecord: {
     pOut->u.nZero = nZero;
     pOut->flags |= MEM_Zero;
   }
-  pOut->enc = SQLITE_UTF8;  /* In case the blob is ever converted to text */
   REGISTER_TRACE(pOp->p3, pOut);
   UPDATE_MAX_BLOBSIZE(pOut);
   break;
@@ -81706,6 +82411,37 @@ case OP_OpenWrite:
   break;
 }
 
+/* Opcode: OpenDup P1 P2 * * *
+**
+** Open a new cursor P1 that points to the same ephemeral table as
+** cursor P2.  The P2 cursor must have been opened by a prior OP_OpenEphemeral
+** opcode.  Only ephemeral cursors may be duplicated.
+**
+** Duplicate ephemeral cursors are used for self-joins of materialized views.
+*/
+case OP_OpenDup: {
+  VdbeCursor *pOrig;    /* The original cursor to be duplicated */
+  VdbeCursor *pCx;      /* The new cursor */
+
+  pOrig = p->apCsr[pOp->p2];
+  assert( pOrig->pBtx!=0 );  /* Only ephemeral cursors can be duplicated */
+
+  pCx = allocateCursor(p, pOp->p1, pOrig->nField, -1, CURTYPE_BTREE);
+  if( pCx==0 ) goto no_mem;
+  pCx->nullRow = 1;
+  pCx->isEphemeral = 1;
+  pCx->pKeyInfo = pOrig->pKeyInfo;
+  pCx->isTable = pOrig->isTable;
+  rc = sqlite3BtreeCursor(pOrig->pBtx, MASTER_ROOT, BTREE_WRCSR,
+                          pCx->pKeyInfo, pCx->uc.pCursor);
+  /* The sqlite3BtreeCursor() routine can only fail for the first cursor
+  ** opened for a database.  Since there is already an open cursor when this
+  ** opcode is run, the sqlite3BtreeCursor() cannot fail */
+  assert( rc==SQLITE_OK );
+  break;
+}
+
+
 /* Opcode: OpenEphemeral P1 P2 * P4 P5
 ** Synopsis: nColumn=P2
 **
@@ -82111,8 +82847,15 @@ case OP_SeekGT: {       /* jump, in3 */
   if( oc>=OP_SeekGE ){  assert( oc==OP_SeekGE || oc==OP_SeekGT );
     if( res<0 || (res==0 && oc==OP_SeekGT) ){
       res = 0;
-      rc = sqlite3BtreeNext(pC->uc.pCursor, &res);
-      if( rc!=SQLITE_OK ) goto abort_due_to_error;
+      rc = sqlite3BtreeNext(pC->uc.pCursor, 0);
+      if( rc!=SQLITE_OK ){
+        if( rc==SQLITE_DONE ){
+          rc = SQLITE_OK;
+          res = 1;
+        }else{
+          goto abort_due_to_error;
+        }
+      }
     }else{
       res = 0;
     }
@@ -82120,8 +82863,15 @@ case OP_SeekGT: {       /* jump, in3 */
     assert( oc==OP_SeekLT || oc==OP_SeekLE );
     if( res>0 || (res==0 && oc==OP_SeekLT) ){
       res = 0;
-      rc = sqlite3BtreePrevious(pC->uc.pCursor, &res);
-      if( rc!=SQLITE_OK ) goto abort_due_to_error;
+      rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);
+      if( rc!=SQLITE_OK ){
+        if( rc==SQLITE_DONE ){
+          rc = SQLITE_OK;
+          res = 1;
+        }else{
+          goto abort_due_to_error;
+        }
+      }
     }else{
       /* res might be negative because the table is empty.  Check to
       ** see if this is the case.
@@ -82241,10 +82991,12 @@ case OP_Found: {        /* jump, in3 */
     pIdxKey = &r;
     pFree = 0;
   }else{
+    assert( pIn3->flags & MEM_Blob );
+    rc = ExpandBlob(pIn3);
+    assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
+    if( rc ) goto no_mem;
     pFree = pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);
     if( pIdxKey==0 ) goto no_mem;
-    assert( pIn3->flags & MEM_Blob );
-    (void)ExpandBlob(pIn3);
     sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);
   }
   pIdxKey->default_rc = 0;
@@ -82261,7 +83013,7 @@ case OP_Found: {        /* jump, in3 */
     }
   }
   rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
-  if( pFree ) sqlite3DbFree(db, pFree);
+  if( pFree ) sqlite3DbFreeNN(db, pFree);
   if( rc!=SQLITE_OK ){
     goto abort_due_to_error;
   }
@@ -83225,12 +83977,10 @@ case OP_Rewind: {        /* jump */
 */
 case OP_SorterNext: {  /* jump */
   VdbeCursor *pC;
-  int res;
 
   pC = p->apCsr[pOp->p1];
   assert( isSorter(pC) );
-  res = 0;
-  rc = sqlite3VdbeSorterNext(db, pC, &res);
+  rc = sqlite3VdbeSorterNext(db, pC);
   goto next_tail;
 case OP_PrevIfOpen:    /* jump */
 case OP_NextIfOpen:    /* jump */
@@ -83241,12 +83991,9 @@ case OP_Next:          /* jump */
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   assert( pOp->p5<ArraySize(p->aCounter) );
   pC = p->apCsr[pOp->p1];
-  res = pOp->p3;
   assert( pC!=0 );
   assert( pC->deferredMoveto==0 );
   assert( pC->eCurType==CURTYPE_BTREE );
-  assert( res==0 || (res==1 && pC->isTable==0) );
-  testcase( res==1 );
   assert( pOp->opcode!=OP_Next || pOp->p4.xAdvance==sqlite3BtreeNext );
   assert( pOp->opcode!=OP_Prev || pOp->p4.xAdvance==sqlite3BtreePrevious );
   assert( pOp->opcode!=OP_NextIfOpen || pOp->p4.xAdvance==sqlite3BtreeNext );
@@ -83261,21 +84008,21 @@ case OP_Next:          /* jump */
        || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE
        || pC->seekOp==OP_Last );
 
-  rc = pOp->p4.xAdvance(pC->uc.pCursor, &res);
+  rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
 next_tail:
   pC->cacheStatus = CACHE_STALE;
-  VdbeBranchTaken(res==0,2);
-  if( rc ) goto abort_due_to_error;
-  if( res==0 ){
+  VdbeBranchTaken(rc==SQLITE_OK,2);
+  if( rc==SQLITE_OK ){
     pC->nullRow = 0;
     p->aCounter[pOp->p5]++;
 #ifdef SQLITE_TEST
     sqlite3_search_count++;
 #endif
     goto jump_to_p2_and_check_for_interrupt;
-  }else{
-    pC->nullRow = 1;
   }
+  if( rc!=SQLITE_DONE ) goto abort_due_to_error;
+  rc = SQLITE_OK;
+  pC->nullRow = 1;
   goto check_for_interrupt;
 }
 
@@ -83386,8 +84133,8 @@ case OP_IdxDelete: {
   break;
 }
 
-/* Opcode: Seek P1 * P3 P4 *
-** Synopsis: Move P3 to P1.rowid
+/* Opcode: DeferredSeek P1 * P3 P4 *
+** Synopsis: Move P3 to P1.rowid if needed
 **
 ** P1 is an open index cursor and P3 is a cursor on the corresponding
 ** table.  This opcode does a deferred seek of the P3 table cursor
@@ -83414,11 +84161,11 @@ case OP_IdxDelete: {
 **
 ** See also: Rowid, MakeRecord.
 */
-case OP_Seek:
-case OP_IdxRowid: {              /* out2 */
-  VdbeCursor *pC;                /* The P1 index cursor */
-  VdbeCursor *pTabCur;           /* The P2 table cursor (OP_Seek only) */
-  i64 rowid;                     /* Rowid that P1 current points to */
+case OP_DeferredSeek:
+case OP_IdxRowid: {           /* out2 */
+  VdbeCursor *pC;             /* The P1 index cursor */
+  VdbeCursor *pTabCur;        /* The P2 table cursor (OP_DeferredSeek only) */
+  i64 rowid;                  /* Rowid that P1 current points to */
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -83444,7 +84191,7 @@ case OP_IdxRowid: {              /* out2 */
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
     }
-    if( pOp->opcode==OP_Seek ){
+    if( pOp->opcode==OP_DeferredSeek ){
       assert( pOp->p3>=0 && pOp->p3<p->nCursor );
       pTabCur = p->apCsr[pOp->p3];
       assert( pTabCur!=0 );
@@ -83571,10 +84318,17 @@ case OP_IdxGE:  {       /* jump */
 ** might be moved into the newly deleted root page in order to keep all
 ** root pages contiguous at the beginning of the database.  The former
 ** value of the root page that moved - its value before the move occurred -
-** is stored in register P2.  If no page 
-** movement was required (because the table being dropped was already 
-** the last one in the database) then a zero is stored in register P2.
-** If AUTOVACUUM is disabled then a zero is stored in register P2.
+** is stored in register P2. If no page movement was required (because the
+** table being dropped was already the last one in the database) then a 
+** zero is stored in register P2.  If AUTOVACUUM is disabled then a zero 
+** is stored in register P2.
+**
+** This opcode throws an error if there are any active reader VMs when
+** it is invoked. This is done to avoid the difficulty associated with 
+** updating existing cursors when a root page is moved in an AUTOVACUUM 
+** database. This error is thrown even if the database is not an AUTOVACUUM 
+** db in order to avoid introducing an incompatibility between autovacuum 
+** and non-autovacuum modes.
 **
 ** See also: Clear
 */
@@ -83779,7 +84533,7 @@ case OP_ParseSchema: {
       assert( !db->mallocFailed );
       rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
       if( rc==SQLITE_OK ) rc = initData.rc;
-      sqlite3DbFree(db, zSql);
+      sqlite3DbFreeNN(db, zSql);
       db->init.busy = 0;
     }
   }
@@ -83907,7 +84661,7 @@ case OP_IntegrityCk: {
 /* Opcode: RowSetAdd P1 P2 * * *
 ** Synopsis: rowset(P1)=r[P2]
 **
-** Insert the integer value held by register P2 into a boolean index
+** Insert the integer value held by register P2 into a RowSet object
 ** held in register P1.
 **
 ** An assertion fails if P2 is not an integer.
@@ -83927,8 +84681,9 @@ case OP_RowSetAdd: {       /* in1, in2 */
 /* Opcode: RowSetRead P1 P2 P3 * *
 ** Synopsis: r[P3]=rowset(P1)
 **
-** Extract the smallest value from boolean index P1 and put that value into
-** register P3.  Or, if boolean index P1 is initially empty, leave P3
+** Extract the smallest value from the RowSet object in P1
+** and put that value into register P3.
+** Or, if RowSet object P1 is initially empty, leave P3
 ** unchanged and jump to instruction P2.
 */
 case OP_RowSetRead: {       /* jump, in1, out3 */
@@ -83959,15 +84714,14 @@ case OP_RowSetRead: {       /* jump, in1, out3 */
 ** integer in P3 into the RowSet and continue on to the
 ** next opcode.
 **
-** The RowSet object is optimized for the case where successive sets
-** of integers, where each set contains no duplicates. Each set
-** of values is identified by a unique P4 value. The first set
-** must have P4==0, the final set P4=-1.  P4 must be either -1 or
-** non-negative.  For non-negative values of P4 only the lower 4
-** bits are significant.
+** The RowSet object is optimized for the case where sets of integers
+** are inserted in distinct phases, which each set contains no duplicates.
+** Each set is identified by a unique P4 value. The first set
+** must have P4==0, the final set must have P4==-1, and for all other sets
+** must have P4>0.
 **
 ** This allows optimizations: (a) when P4==0 there is no need to test
-** the rowset object for P3, as it is guaranteed not to contain it,
+** the RowSet object for P3, as it is guaranteed not to contain it,
 ** (b) when P4==-1 there is no need to insert the value, as it will
 ** never be tested for, and (c) when a value that is part of set X is
 ** inserted, there is no need to search to see if the same value was
@@ -84683,7 +85437,7 @@ case OP_Expire: {
 */
 case OP_TableLock: {
   u8 isWriteLock = (u8)pOp->p3;
-  if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommitted) ){
+  if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommit) ){
     int p1 = pOp->p1; 
     assert( p1>=0 && p1<db->nDb );
     assert( DbMaskTest(p->btreeMask, p1) );
@@ -85112,6 +85866,121 @@ case OP_MaxPgcnt: {            /* out2 */
 }
 #endif
 
+/* Opcode: Function0 P1 P2 P3 P4 P5
+** Synopsis: r[P3]=func(r[P2@P5])
+**
+** Invoke a user function (P4 is a pointer to a FuncDef object that
+** defines the function) with P5 arguments taken from register P2 and
+** successors.  The result of the function is stored in register P3.
+** Register P3 must not be one of the function inputs.
+**
+** P1 is a 32-bit bitmask indicating whether or not each argument to the 
+** function was determined to be constant at compile time. If the first
+** argument was constant then bit 0 of P1 is set. This is used to determine
+** whether meta data associated with a user function argument using the
+** sqlite3_set_auxdata() API may be safely retained until the next
+** invocation of this opcode.
+**
+** See also: Function, AggStep, AggFinal
+*/
+/* Opcode: Function P1 P2 P3 P4 P5
+** Synopsis: r[P3]=func(r[P2@P5])
+**
+** Invoke a user function (P4 is a pointer to an sqlite3_context object that
+** contains a pointer to the function to be run) with P5 arguments taken
+** from register P2 and successors.  The result of the function is stored
+** in register P3.  Register P3 must not be one of the function inputs.
+**
+** P1 is a 32-bit bitmask indicating whether or not each argument to the 
+** function was determined to be constant at compile time. If the first
+** argument was constant then bit 0 of P1 is set. This is used to determine
+** whether meta data associated with a user function argument using the
+** sqlite3_set_auxdata() API may be safely retained until the next
+** invocation of this opcode.
+**
+** SQL functions are initially coded as OP_Function0 with P4 pointing
+** to a FuncDef object.  But on first evaluation, the P4 operand is
+** automatically converted into an sqlite3_context object and the operation
+** changed to this OP_Function opcode.  In this way, the initialization of
+** the sqlite3_context object occurs only once, rather than once for each
+** evaluation of the function.
+**
+** See also: Function0, AggStep, AggFinal
+*/
+case OP_PureFunc0:
+case OP_Function0: {
+  int n;
+  sqlite3_context *pCtx;
+
+  assert( pOp->p4type==P4_FUNCDEF );
+  n = pOp->p5;
+  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );
+  assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );
+  assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );
+  pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));
+  if( pCtx==0 ) goto no_mem;
+  pCtx->pOut = 0;
+  pCtx->pFunc = pOp->p4.pFunc;
+  pCtx->iOp = (int)(pOp - aOp);
+  pCtx->pVdbe = p;
+  pCtx->argc = n;
+  pOp->p4type = P4_FUNCCTX;
+  pOp->p4.pCtx = pCtx;
+  assert( OP_PureFunc == OP_PureFunc0+2 );
+  assert( OP_Function == OP_Function0+2 );
+  pOp->opcode += 2;
+  /* Fall through into OP_Function */
+}
+case OP_PureFunc:
+case OP_Function: {
+  int i;
+  sqlite3_context *pCtx;
+
+  assert( pOp->p4type==P4_FUNCCTX );
+  pCtx = pOp->p4.pCtx;
+
+  /* If this function is inside of a trigger, the register array in aMem[]
+  ** might change from one evaluation to the next.  The next block of code
+  ** checks to see if the register array has changed, and if so it
+  ** reinitializes the relavant parts of the sqlite3_context object */
+  pOut = &aMem[pOp->p3];
+  if( pCtx->pOut != pOut ){
+    pCtx->pOut = pOut;
+    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
+  }
+
+  memAboutToChange(p, pOut);
+#ifdef SQLITE_DEBUG
+  for(i=0; i<pCtx->argc; i++){
+    assert( memIsValid(pCtx->argv[i]) );
+    REGISTER_TRACE(pOp->p2+i, pCtx->argv[i]);
+  }
+#endif
+  MemSetTypeFlag(pOut, MEM_Null);
+  pCtx->fErrorOrAux = 0;
+  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);/* IMP: R-24505-23230 */
+
+  /* If the function returned an error, throw an exception */
+  if( pCtx->fErrorOrAux ){
+    if( pCtx->isError ){
+      sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));
+      rc = pCtx->isError;
+    }
+    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
+    if( rc ) goto abort_due_to_error;
+  }
+
+  /* Copy the result of the function into register P3 */
+  if( pOut->flags & (MEM_Str|MEM_Blob) ){
+    sqlite3VdbeChangeEncoding(pOut, encoding);
+    if( sqlite3VdbeMemTooBig(pOut) ) goto too_big;
+  }
+
+  REGISTER_TRACE(pOp->p3, pOut);
+  UPDATE_MAX_BLOBSIZE(pOut);
+  break;
+}
+
 
 /* Opcode: Init P1 P2 * P4 *
 ** Synopsis: Start at P2
@@ -85191,6 +86060,7 @@ case OP_Init: {          /* jump */
     pOp->p1 = 0;
   }
   pOp->p1++;
+  p->aCounter[SQLITE_STMTSTATUS_RUN]++;
   goto jump_to_p2;
 }
 
@@ -86664,9 +87534,9 @@ static int vdbeSorterCompareText(
   int n2;
   int res;
 
-  getVarint32(&p1[1], n1); n1 = (n1 - 13) / 2;
-  getVarint32(&p2[1], n2); n2 = (n2 - 13) / 2;
-  res = memcmp(v1, v2, MIN(n1, n2));
+  getVarint32(&p1[1], n1);
+  getVarint32(&p2[1], n2);
+  res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);
   if( res==0 ){
     res = n1 - n2;
   }
@@ -86707,37 +87577,36 @@ static int vdbeSorterCompareInt(
   assert( (s1>0 && s1<7) || s1==8 || s1==9 );
   assert( (s2>0 && s2<7) || s2==8 || s2==9 );
 
-  if( s1>7 && s2>7 ){
-    res = s1 - s2;
-  }else{
-    if( s1==s2 ){
-      if( (*v1 ^ *v2) & 0x80 ){
-        /* The two values have different signs */
-        res = (*v1 & 0x80) ? -1 : +1;
-      }else{
-        /* The two values have the same sign. Compare using memcmp(). */
-        static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8 };
-        int i;
-        res = 0;
-        for(i=0; i<aLen[s1]; i++){
-          if( (res = v1[i] - v2[i]) ) break;
+  if( s1==s2 ){
+    /* The two values have the same sign. Compare using memcmp(). */
+    static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };
+    const u8 n = aLen[s1];
+    int i;
+    res = 0;
+    for(i=0; i<n; i++){
+      if( (res = v1[i] - v2[i])!=0 ){
+        if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){
+          res = v1[0] & 0x80 ? -1 : +1;
         }
+        break;
       }
+    }
+  }else if( s1>7 && s2>7 ){
+    res = s1 - s2;
+  }else{
+    if( s2>7 ){
+      res = +1;
+    }else if( s1>7 ){
+      res = -1;
     }else{
-      if( s2>7 ){
-        res = +1;
-      }else if( s1>7 ){
-        res = -1;
-      }else{
-        res = s1 - s2;
-      }
-      assert( res!=0 );
+      res = s1 - s2;
+    }
+    assert( res!=0 );
 
-      if( res>0 ){
-        if( *v1 & 0x80 ) res = -1;
-      }else{
-        if( *v2 & 0x80 ) res = +1;
-      }
+    if( res>0 ){
+      if( *v1 & 0x80 ) res = -1;
+    }else{
+      if( *v2 & 0x80 ) res = +1;
     }
   }
 
@@ -88462,9 +89331,13 @@ SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){
 }
 
 /*
-** Advance to the next element in the sorter.
+** Advance to the next element in the sorter.  Return value:
+**
+**    SQLITE_OK     success
+**    SQLITE_DONE   end of data
+**    otherwise     some kind of error.
 */
-SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr, int *pbEof){
+SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){
   VdbeSorter *pSorter;
   int rc;                         /* Return code */
 
@@ -88478,21 +89351,22 @@ SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr, in
 #if SQLITE_MAX_WORKER_THREADS>0
     if( pSorter->bUseThreads ){
       rc = vdbePmaReaderNext(pSorter->pReader);
-      *pbEof = (pSorter->pReader->pFd==0);
+      if( rc==SQLITE_OK && pSorter->pReader->pFd==0 ) rc = SQLITE_DONE;
     }else
 #endif
     /*if( !pSorter->bUseThreads )*/ {
+      int res = 0;
       assert( pSorter->pMerger!=0 );
       assert( pSorter->pMerger->pTask==(&pSorter->aTask[0]) );
-      rc = vdbeMergeEngineStep(pSorter->pMerger, pbEof);
+      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);
+      if( rc==SQLITE_OK && res ) rc = SQLITE_DONE;
     }
   }else{
     SorterRecord *pFree = pSorter->list.pList;
     pSorter->list.pList = pFree->u.pNext;
     pFree->u.pNext = 0;
     if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);
-    *pbEof = !pSorter->list.pList;
-    rc = SQLITE_OK;
+    rc = pSorter->list.pList ? SQLITE_OK : SQLITE_DONE;
   }
   return rc;
 }
@@ -89063,15 +89937,17 @@ static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr){
   testcase( ExprHasProperty(pExpr, EP_TokenOnly) );
   testcase( ExprHasProperty(pExpr, EP_Reduced) );
   rc = pWalker->xExprCallback(pWalker, pExpr);
-  if( rc || ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){
-    return rc & WRC_Abort;
-  }
-  if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;
-  if( pExpr->pRight && walkExpr(pWalker, pExpr->pRight) ) return WRC_Abort;
-  if( ExprHasProperty(pExpr, EP_xIsSelect) ){
-    if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;
-  }else if( pExpr->x.pList ){
-    if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;
+  if( rc ) return rc & WRC_Abort;
+  if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){
+    if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;
+    assert( pExpr->x.pList==0 || pExpr->pRight==0 );
+    if( pExpr->pRight ){
+      if( walkExpr(pWalker, pExpr->pRight) ) return WRC_Abort;
+    }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){
+      if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;
+    }else if( pExpr->x.pList ){
+      if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;
+    }
   }
   return WRC_Continue;
 }
@@ -89126,7 +90002,7 @@ SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
   pSrc = p->pSrc;
   if( ALWAYS(pSrc) ){
     for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
-      if( sqlite3WalkSelect(pWalker, pItem->pSelect) ){
+      if( pItem->pSelect && sqlite3WalkSelect(pWalker, pItem->pSelect) ){
         return WRC_Abort;
       }
       if( pItem->fg.isTabFunc
@@ -89146,8 +90022,9 @@ SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
 **
 ** If it is not NULL, the xSelectCallback() callback is invoked before
 ** the walk of the expressions and FROM clause. The xSelectCallback2()
-** method, if it is not NULL, is invoked following the walk of the 
-** expressions and FROM clause.
+** method is invoked following the walk of the expressions and FROM clause,
+** but only if both xSelectCallback and xSelectCallback2 are both non-NULL
+** and if the expressions and FROM clause both return WRC_Continue;
 **
 ** Return WRC_Continue under normal conditions.  Return WRC_Abort if
 ** there is an abort request.
@@ -89157,29 +90034,22 @@ SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
 */
 SQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p){
   int rc;
-  if( p==0 || (pWalker->xSelectCallback==0 && pWalker->xSelectCallback2==0) ){
-    return WRC_Continue;
-  }
-  rc = WRC_Continue;
-  pWalker->walkerDepth++;
-  while( p ){
-    if( pWalker->xSelectCallback ){
-       rc = pWalker->xSelectCallback(pWalker, p);
-       if( rc ) break;
-    }
+  if( p==0 ) return WRC_Continue;
+  if( pWalker->xSelectCallback==0 ) return WRC_Continue;
+  do{
+    rc = pWalker->xSelectCallback(pWalker, p);
+    if( rc ) return rc & WRC_Abort;
     if( sqlite3WalkSelectExpr(pWalker, p)
      || sqlite3WalkSelectFrom(pWalker, p)
     ){
-      pWalker->walkerDepth--;
       return WRC_Abort;
     }
     if( pWalker->xSelectCallback2 ){
       pWalker->xSelectCallback2(pWalker, p);
     }
     p = p->pPrior;
-  }
-  pWalker->walkerDepth--;
-  return rc & WRC_Abort;
+  }while( p!=0 );
+  return WRC_Continue;
 }
 
 /************** End of walker.c **********************************************/
@@ -89664,6 +90534,7 @@ static int lookupName(
   sqlite3ExprDelete(db, pExpr->pRight);
   pExpr->pRight = 0;
   pExpr->op = (isTrigger ? TK_TRIGGER : TK_COLUMN);
+  ExprSetProperty(pExpr, EP_Leaf);
 lookupname_end:
   if( cnt==1 ){
     assert( pNC!=0 );
@@ -89702,7 +90573,6 @@ SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSr
       testcase( iCol==BMS-1 );
       pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);
     }
-    ExprSetProperty(p, EP_Resolved);
   }
   return p;
 }
@@ -89762,8 +90632,6 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
   pParse = pNC->pParse;
   assert( pParse==pWalker->pParse );
 
-  if( ExprHasProperty(pExpr, EP_Resolved) ) return WRC_Prune;
-  ExprSetProperty(pExpr, EP_Resolved);
 #ifndef NDEBUG
   if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){
     SrcList *pSrcList = pNC->pSrcList;
@@ -90096,7 +90964,7 @@ static int resolveOrderByTermToExprList(
   ** result-set entry.
   */
   for(i=0; i<pEList->nExpr; i++){
-    if( sqlite3ExprCompare(pEList->a[i].pExpr, pE, -1)<2 ){
+    if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){
       return i+1;
     }
   }
@@ -90330,7 +91198,7 @@ static int resolveOrderGroupBy(
       return 1;
     }
     for(j=0; j<pSelect->pEList->nExpr; j++){
-      if( sqlite3ExprCompare(pE, pSelect->pEList->a[j].pExpr, -1)==0 ){
+      if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){
         pItem->u.x.iOrderByCol = j+1;
       }
     }
@@ -90616,37 +91484,29 @@ SQLITE_PRIVATE int sqlite3ResolveExprNames(
   u16 savedHasAgg;
   Walker w;
 
-  if( pExpr==0 ) return 0;
-#if SQLITE_MAX_EXPR_DEPTH>0
-  {
-    Parse *pParse = pNC->pParse;
-    if( sqlite3ExprCheckHeight(pParse, pExpr->nHeight+pNC->pParse->nHeight) ){
-      return 1;
-    }
-    pParse->nHeight += pExpr->nHeight;
-  }
-#endif
+  if( pExpr==0 ) return SQLITE_OK;
   savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg);
   pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg);
   w.pParse = pNC->pParse;
   w.xExprCallback = resolveExprStep;
   w.xSelectCallback = resolveSelectStep;
   w.xSelectCallback2 = 0;
-  w.walkerDepth = 0;
-  w.eCode = 0;
   w.u.pNC = pNC;
+#if SQLITE_MAX_EXPR_DEPTH>0
+  w.pParse->nHeight += pExpr->nHeight;
+  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
+    return SQLITE_ERROR;
+  }
+#endif
   sqlite3WalkExpr(&w, pExpr);
 #if SQLITE_MAX_EXPR_DEPTH>0
-  pNC->pParse->nHeight -= pExpr->nHeight;
+  w.pParse->nHeight -= pExpr->nHeight;
 #endif
-  if( pNC->nErr>0 || w.pParse->nErr>0 ){
-    ExprSetProperty(pExpr, EP_Error);
-  }
   if( pNC->ncFlags & NC_HasAgg ){
     ExprSetProperty(pExpr, EP_Agg);
   }
   pNC->ncFlags |= savedHasAgg;
-  return ExprHasProperty(pExpr, EP_Error);
+  return pNC->nErr>0 || w.pParse->nErr>0;
 }
 
 /*
@@ -90687,9 +91547,9 @@ SQLITE_PRIVATE void sqlite3ResolveSelectNames(
   Walker w;
 
   assert( p!=0 );
-  memset(&w, 0, sizeof(w));
   w.xExprCallback = resolveExprStep;
   w.xSelectCallback = resolveSelectStep;
+  w.xSelectCallback2 = 0;
   w.pParse = pParse;
   w.u.pNC = pOuterNC;
   sqlite3WalkSelect(&w, p);
@@ -90792,7 +91652,7 @@ SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){
     return sqlite3AffinityType(pExpr->u.zToken, 0);
   }
 #endif
-  if( op==TK_AGG_COLUMN || op==TK_COLUMN ){
+  if( (op==TK_AGG_COLUMN || op==TK_COLUMN) && pExpr->pTab ){
     return sqlite3TableColumnAffinity(pExpr->pTab, pExpr->iColumn);
   }
   if( op==TK_SELECT_COLUMN ){
@@ -91086,7 +91946,6 @@ SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr){
   }
 }
 
-#ifndef SQLITE_OMIT_SUBQUERY
 /*
 ** Return a pointer to a subexpression of pVector that is the i-th
 ** column of the vector (numbered starting with 0).  The caller must
@@ -91114,9 +91973,7 @@ SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){
   }
   return pVector;
 }
-#endif /* !defined(SQLITE_OMIT_SUBQUERY) */
 
-#ifndef SQLITE_OMIT_SUBQUERY
 /*
 ** Compute and return a new Expr object which when passed to
 ** sqlite3ExprCode() will generate all necessary code to compute
@@ -91174,7 +92031,6 @@ SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(
   }
   return pRet;
 }
-#endif /* !define(SQLITE_OMIT_SUBQUERY) */
 
 /*
 ** If expression pExpr is of type TK_SELECT, generate code to evaluate
@@ -91482,7 +92338,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprAlloc(
     pNew->iAgg = -1;
     if( pToken ){
       if( nExtra==0 ){
-        pNew->flags |= EP_IntValue;
+        pNew->flags |= EP_IntValue|EP_Leaf;
         pNew->u.iValue = iValue;
       }else{
         pNew->u.zToken = (char*)&pNew[1];
@@ -91690,7 +92546,7 @@ SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n
   z = pExpr->u.zToken;
   assert( z!=0 );
   assert( z[0]!=0 );
-  assert( n==sqlite3Strlen30(z) );
+  assert( n==(u32)sqlite3Strlen30(z) );
   if( z[1]==0 ){
     /* Wildcard of the form "?".  Assign the next variable number */
     assert( z[0]=='?' );
@@ -91763,8 +92619,9 @@ static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){
     /* The Expr.x union is never used at the same time as Expr.pRight */
     assert( p->x.pList==0 || p->pRight==0 );
     if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);
-    sqlite3ExprDelete(db, p->pRight);
-    if( ExprHasProperty(p, EP_xIsSelect) ){
+    if( p->pRight ){
+      sqlite3ExprDeleteNN(db, p->pRight);
+    }else if( ExprHasProperty(p, EP_xIsSelect) ){
       sqlite3SelectDelete(db, p->x.pSelect);
     }else{
       sqlite3ExprListDelete(db, p->x.pList);
@@ -91772,7 +92629,7 @@ static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){
   }
   if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);
   if( !ExprHasProperty(p, EP_Static) ){
-    sqlite3DbFree(db, p);
+    sqlite3DbFreeNN(db, p);
   }
 }
 SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p){
@@ -92039,15 +92896,11 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags)
   Expr *pPriorSelectCol = 0;
   assert( db!=0 );
   if( p==0 ) return 0;
-  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );
+  pNew = sqlite3DbMallocRawNN(db, 
+             sizeof(*pNew)+sizeof(pNew->a[0])*(p->nExpr-1) );
   if( pNew==0 ) return 0;
-  pNew->nExpr = i = p->nExpr;
-  if( (flags & EXPRDUP_REDUCE)==0 ) for(i=1; i<p->nExpr; i+=i){}
-  pNew->a = pItem = sqlite3DbMallocRawNN(db,  i*sizeof(p->a[0]) );
-  if( pItem==0 ){
-    sqlite3DbFree(db, pNew);
-    return 0;
-  } 
+  pNew->nAlloc = pNew->nExpr = p->nExpr;
+  pItem = pNew->a;
   pOldItem = p->a;
   for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){
     Expr *pOldExpr = pOldItem->pExpr;
@@ -92138,7 +92991,7 @@ SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){
   pNew->nId = p->nId;
   pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );
   if( pNew->a==0 ){
-    sqlite3DbFree(db, pNew);
+    sqlite3DbFreeNN(db, pNew);
     return 0;
   }
   /* Note that because the size of the allocation for p->a[] is not
@@ -92209,6 +93062,7 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(
   ExprList *pList,        /* List to which to append. Might be NULL */
   Expr *pExpr             /* Expression to be appended. Might be NULL */
 ){
+  struct ExprList_item *pItem;
   sqlite3 *db = pParse->db;
   assert( db!=0 );
   if( pList==0 ){
@@ -92217,23 +93071,22 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(
       goto no_mem;
     }
     pList->nExpr = 0;
-    pList->a = sqlite3DbMallocRawNN(db, sizeof(pList->a[0]));
-    if( pList->a==0 ) goto no_mem;
-  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){
-    struct ExprList_item *a;
-    assert( pList->nExpr>0 );
-    a = sqlite3DbRealloc(db, pList->a, pList->nExpr*2*sizeof(pList->a[0]));
-    if( a==0 ){
+    pList->nAlloc = 1;
+  }else if( pList->nExpr==pList->nAlloc ){
+    ExprList *pNew;
+    pNew = sqlite3DbRealloc(db, pList, 
+             sizeof(*pList)+(2*pList->nAlloc - 1)*sizeof(pList->a[0]));
+    if( pNew==0 ){
       goto no_mem;
     }
-    pList->a = a;
-  }
-  assert( pList->a!=0 );
-  if( 1 ){
-    struct ExprList_item *pItem = &pList->a[pList->nExpr++];
-    memset(pItem, 0, sizeof(*pItem));
-    pItem->pExpr = pExpr;
+    pList = pNew;
+    pList->nAlloc *= 2;
   }
+  pItem = &pList->a[pList->nExpr++];
+  assert( offsetof(struct ExprList_item,zName)==sizeof(pItem->pExpr) );
+  assert( offsetof(struct ExprList_item,pExpr)==0 );
+  memset(&pItem->zName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zName));
+  pItem->pExpr = pExpr;
   return pList;
 
 no_mem:     
@@ -92290,20 +93143,19 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(
     }
   }
 
-  if( pExpr->op==TK_SELECT ){
-    if( pList && pList->a[iFirst].pExpr ){
-      Expr *pFirst = pList->a[iFirst].pExpr;
-      assert( pFirst->op==TK_SELECT_COLUMN );
+  if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){
+    Expr *pFirst = pList->a[iFirst].pExpr;
+    assert( pFirst!=0 );
+    assert( pFirst->op==TK_SELECT_COLUMN );
      
-      /* Store the SELECT statement in pRight so it will be deleted when
-      ** sqlite3ExprListDelete() is called */
-      pFirst->pRight = pExpr;
-      pExpr = 0;
+    /* Store the SELECT statement in pRight so it will be deleted when
+    ** sqlite3ExprListDelete() is called */
+    pFirst->pRight = pExpr;
+    pExpr = 0;
 
-      /* Remember the size of the LHS in iTable so that we can check that
-      ** the RHS and LHS sizes match during code generation. */
-      pFirst->iTable = pColumns->nId;
-    }
+    /* Remember the size of the LHS in iTable so that we can check that
+    ** the RHS and LHS sizes match during code generation. */
+    pFirst->iTable = pColumns->nId;
   }
 
 vector_append_error:
@@ -92397,16 +93249,16 @@ SQLITE_PRIVATE void sqlite3ExprListCheckLength(
 ** Delete an entire expression list.
 */
 static SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){
-  int i;
-  struct ExprList_item *pItem;
-  assert( pList->a!=0 || pList->nExpr==0 );
-  for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
+  int i = pList->nExpr;
+  struct ExprList_item *pItem =  pList->a;
+  assert( pList->nExpr>0 );
+  do{
     sqlite3ExprDelete(db, pItem->pExpr);
     sqlite3DbFree(db, pItem->zName);
     sqlite3DbFree(db, pItem->zSpan);
-  }
-  sqlite3DbFree(db, pList->a);
-  sqlite3DbFree(db, pList);
+    pItem++;
+  }while( --i>0 );
+  sqlite3DbFreeNN(db, pList);
 }
 SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
   if( pList ) exprListDeleteNN(db, pList);
@@ -92485,10 +93337,12 @@ static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){
       testcase( pExpr->op==TK_AGG_COLUMN );
       if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){
         return WRC_Continue;
-      }else{
-        pWalker->eCode = 0;
-        return WRC_Abort;
       }
+      /* Fall through */
+    case TK_IF_NULL_ROW:
+      testcase( pExpr->op==TK_IF_NULL_ROW );
+      pWalker->eCode = 0;
+      return WRC_Abort;
     case TK_VARIABLE:
       if( pWalker->eCode==5 ){
         /* Silently convert bound parameters that appear inside of CREATE
@@ -92515,10 +93369,12 @@ static int selectNodeIsConstant(Walker *pWalker, Select *NotUsed){
 }
 static int exprIsConst(Expr *p, int initFlag, int iCur){
   Walker w;
-  memset(&w, 0, sizeof(w));
   w.eCode = initFlag;
   w.xExprCallback = exprNodeIsConstant;
   w.xSelectCallback = selectNodeIsConstant;
+#ifdef SQLITE_DEBUG
+  w.xSelectCallback2 = sqlite3SelectWalkAssert2;
+#endif
   w.u.iCur = iCur;
   sqlite3WalkExpr(&w, p);
   return w.eCode;
@@ -92556,6 +93412,65 @@ SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr *p, int iCur){
   return exprIsConst(p, 3, iCur);
 }
 
+
+/*
+** sqlite3WalkExpr() callback used by sqlite3ExprIsConstantOrGroupBy().
+*/
+static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
+  ExprList *pGroupBy = pWalker->u.pGroupBy;
+  int i;
+
+  /* Check if pExpr is identical to any GROUP BY term. If so, consider
+  ** it constant.  */
+  for(i=0; i<pGroupBy->nExpr; i++){
+    Expr *p = pGroupBy->a[i].pExpr;
+    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){
+      CollSeq *pColl = sqlite3ExprCollSeq(pWalker->pParse, p);
+      if( pColl==0 || sqlite3_stricmp("BINARY", pColl->zName)==0 ){
+        return WRC_Prune;
+      }
+    }
+  }
+
+  /* Check if pExpr is a sub-select. If so, consider it variable. */
+  if( ExprHasProperty(pExpr, EP_xIsSelect) ){
+    pWalker->eCode = 0;
+    return WRC_Abort;
+  }
+
+  return exprNodeIsConstant(pWalker, pExpr);
+}
+
+/*
+** Walk the expression tree passed as the first argument. Return non-zero
+** if the expression consists entirely of constants or copies of terms 
+** in pGroupBy that sort with the BINARY collation sequence.
+**
+** This routine is used to determine if a term of the HAVING clause can
+** be promoted into the WHERE clause.  In order for such a promotion to work,
+** the value of the HAVING clause term must be the same for all members of
+** a "group".  The requirement that the GROUP BY term must be BINARY
+** assumes that no other collating sequence will have a finer-grained
+** grouping than binary.  In other words (A=B COLLATE binary) implies
+** A=B in every other collating sequence.  The requirement that the
+** GROUP BY be BINARY is stricter than necessary.  It would also work
+** to promote HAVING clauses that use the same alternative collating
+** sequence as the GROUP BY term, but that is much harder to check,
+** alternative collating sequences are uncommon, and this is only an
+** optimization, so we take the easy way out and simply require the
+** GROUP BY to use the BINARY collating sequence.
+*/
+SQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){
+  Walker w;
+  w.eCode = 1;
+  w.xExprCallback = exprNodeIsConstantOrGroupBy;
+  w.xSelectCallback = 0;
+  w.u.pGroupBy = pGroupBy;
+  w.pParse = pParse;
+  sqlite3WalkExpr(&w, p);
+  return w.eCode;
+}
+
 /*
 ** Walk an expression tree.  Return non-zero if the expression is constant
 ** or a function call with constant arguments.  Return and 0 if there
@@ -92577,10 +93492,12 @@ SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){
 */
 SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr *p){
   Walker w;
-  memset(&w, 0, sizeof(w));
   w.eCode = 1;
   w.xExprCallback = sqlite3ExprWalkNoop;
   w.xSelectCallback = selectNodeIsConstant;
+#ifdef SQLITE_DEBUG
+  w.xSelectCallback2 = sqlite3SelectWalkAssert2;
+#endif
   sqlite3WalkExpr(&w, p);
   return w.eCode==0;
 }
@@ -93915,8 +94832,9 @@ SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(
   if( iTabCol==XN_EXPR ){
     assert( pIdx->aColExpr );
     assert( pIdx->aColExpr->nExpr>iIdxCol );
-    pParse->iSelfTab = iTabCur;
+    pParse->iSelfTab = iTabCur + 1;
     sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
+    pParse->iSelfTab = 0;
   }else{
     sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
                                     iTabCol, regOut);
@@ -93933,6 +94851,10 @@ SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(
   int iCol,       /* Index of the column to extract */
   int regOut      /* Extract the value into this register */
 ){
+  if( pTab==0 ){
+    sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);
+    return;
+  }
   if( iCol<0 || iCol==pTab->iPKey ){
     sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);
   }else{
@@ -94089,7 +95011,11 @@ static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){
   }else{
     *piFreeable = 0;
     if( p->op==TK_SELECT ){
+#if SQLITE_OMIT_SUBQUERY
+      iResult = 0;
+#else
       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);
+#endif
     }else{
       int i;
       iResult = pParse->nMem+1;
@@ -94152,13 +95078,13 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
     case TK_COLUMN: {
       int iTab = pExpr->iTable;
       if( iTab<0 ){
-        if( pParse->ckBase>0 ){
+        if( pParse->iSelfTab<0 ){
           /* Generating CHECK constraints or inserting into partial index */
-          return pExpr->iColumn + pParse->ckBase;
+          return pExpr->iColumn - pParse->iSelfTab;
         }else{
           /* Coding an expression that is part of an index where column names
           ** in the index refer to the table to which the index belongs */
-          iTab = pParse->iSelfTab;
+          iTab = pParse->iSelfTab - 1;
         }
       }
       return sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,
@@ -94495,8 +95421,8 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
         if( !pColl ) pColl = db->pDfltColl; 
         sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);
       }
-      sqlite3VdbeAddOp4(v, OP_Function0, constMask, r1, target,
-                        (char*)pDef, P4_FUNCDEF);
+      sqlite3VdbeAddOp4(v, pParse->iSelfTab ? OP_PureFunc0 : OP_Function0,
+                        constMask, r1, target, (char*)pDef, P4_FUNCDEF);
       sqlite3VdbeChangeP5(v, (u8)nFarg);
       if( nFarg && constMask==0 ){
         sqlite3ReleaseTempRange(pParse, r1, nFarg);
@@ -94626,6 +95552,17 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
       break;
     }
 
+    case TK_IF_NULL_ROW: {
+      int addrINR;
+      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);
+      sqlite3ExprCachePush(pParse);
+      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
+      sqlite3ExprCachePop(pParse);
+      sqlite3VdbeJumpHere(v, addrINR);
+      sqlite3VdbeChangeP3(v, addrINR, inReg);
+      break;
+    }
+
     /*
     ** Form A:
     **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
@@ -94764,7 +95701,7 @@ SQLITE_PRIVATE int sqlite3ExprCodeAtInit(
     struct ExprList_item *pItem;
     int i;
     for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){
-      if( pItem->reusable && sqlite3ExprCompare(pItem->pExpr,pExpr,-1)==0 ){
+      if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){
         return pItem->u.iConstExprReg;
       }
     }
@@ -95319,6 +96256,41 @@ SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,i
   sqlite3ExprDelete(db, pCopy);
 }
 
+/*
+** Expression pVar is guaranteed to be an SQL variable. pExpr may be any
+** type of expression.
+**
+** If pExpr is a simple SQL value - an integer, real, string, blob
+** or NULL value - then the VDBE currently being prepared is configured
+** to re-prepare each time a new value is bound to variable pVar.
+**
+** Additionally, if pExpr is a simple SQL value and the value is the
+** same as that currently bound to variable pVar, non-zero is returned.
+** Otherwise, if the values are not the same or if pExpr is not a simple
+** SQL value, zero is returned.
+*/
+static int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){
+  int res = 0;
+  int iVar;
+  sqlite3_value *pL, *pR = 0;
+  
+  sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);
+  if( pR ){
+    iVar = pVar->iColumn;
+    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);
+    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);
+    if( pL ){
+      if( sqlite3_value_type(pL)==SQLITE_TEXT ){
+        sqlite3_value_text(pL); /* Make sure the encoding is UTF-8 */
+      }
+      res =  0==sqlite3MemCompare(pL, pR, 0);
+    }
+    sqlite3ValueFree(pR);
+    sqlite3ValueFree(pL);
+  }
+
+  return res;
+}
 
 /*
 ** Do a deep comparison of two expression trees.  Return 0 if the two
@@ -95341,12 +96313,22 @@ SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,i
 ** this routine is used, it does not hurt to get an extra 2 - that
 ** just might result in some slightly slower code.  But returning
 ** an incorrect 0 or 1 could lead to a malfunction.
+**
+** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in
+** pParse->pReprepare can be matched against literals in pB.  The 
+** pParse->pVdbe->expmask bitmask is updated for each variable referenced.
+** If pParse is NULL (the normal case) then any TK_VARIABLE term in 
+** Argument pParse should normally be NULL. If it is not NULL and pA or
+** pB causes a return value of 2.
 */
-SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){
+SQLITE_PRIVATE int sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){
   u32 combinedFlags;
   if( pA==0 || pB==0 ){
     return pB==pA ? 0 : 2;
   }
+  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){
+    return 0;
+  }
   combinedFlags = pA->flags | pB->flags;
   if( combinedFlags & EP_IntValue ){
     if( (pA->flags&pB->flags&EP_IntValue)!=0 && pA->u.iValue==pB->u.iValue ){
@@ -95355,10 +96337,10 @@ SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){
     return 2;
   }
   if( pA->op!=pB->op ){
-    if( pA->op==TK_COLLATE && sqlite3ExprCompare(pA->pLeft, pB, iTab)<2 ){
+    if( pA->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){
       return 1;
     }
-    if( pB->op==TK_COLLATE && sqlite3ExprCompare(pA, pB->pLeft, iTab)<2 ){
+    if( pB->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){
       return 1;
     }
     return 2;
@@ -95373,8 +96355,8 @@ SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){
   if( (pA->flags & EP_Distinct)!=(pB->flags & EP_Distinct) ) return 2;
   if( ALWAYS((combinedFlags & EP_TokenOnly)==0) ){
     if( combinedFlags & EP_xIsSelect ) return 2;
-    if( sqlite3ExprCompare(pA->pLeft, pB->pLeft, iTab) ) return 2;
-    if( sqlite3ExprCompare(pA->pRight, pB->pRight, iTab) ) return 2;
+    if( sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;
+    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;
     if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;
     if( ALWAYS((combinedFlags & EP_Reduced)==0) && pA->op!=TK_STRING ){
       if( pA->iColumn!=pB->iColumn ) return 2;
@@ -95409,7 +96391,7 @@ SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
     Expr *pExprA = pA->a[i].pExpr;
     Expr *pExprB = pB->a[i].pExpr;
     if( pA->a[i].sortOrder!=pB->a[i].sortOrder ) return 1;
-    if( sqlite3ExprCompare(pExprA, pExprB, iTab) ) return 1;
+    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
   }
   return 0;
 }
@@ -95419,7 +96401,7 @@ SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
 ** are ignored.
 */
 SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){
-  return sqlite3ExprCompare(
+  return sqlite3ExprCompare(0,
              sqlite3ExprSkipCollate(pA),
              sqlite3ExprSkipCollate(pB),
              iTab);
@@ -95441,24 +96423,29 @@ SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){
 ** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has
 ** Expr.iTable<0 then assume a table number given by iTab.
 **
+** If pParse is not NULL, then the values of bound variables in pE1 are 
+** compared against literal values in pE2 and pParse->pVdbe->expmask is
+** modified to record which bound variables are referenced.  If pParse 
+** is NULL, then false will be returned if pE1 contains any bound variables.
+**
 ** When in doubt, return false.  Returning true might give a performance
 ** improvement.  Returning false might cause a performance reduction, but
 ** it will always give the correct answer and is hence always safe.
 */
-SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Expr *pE1, Expr *pE2, int iTab){
-  if( sqlite3ExprCompare(pE1, pE2, iTab)==0 ){
+SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){
+  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){
     return 1;
   }
   if( pE2->op==TK_OR
-   && (sqlite3ExprImpliesExpr(pE1, pE2->pLeft, iTab)
-             || sqlite3ExprImpliesExpr(pE1, pE2->pRight, iTab) )
+   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)
+             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )
   ){
     return 1;
   }
   if( pE2->op==TK_NOTNULL && pE1->op!=TK_ISNULL && pE1->op!=TK_IS ){
     Expr *pX = sqlite3ExprSkipCollate(pE1->pLeft);
     testcase( pX!=pE1->pLeft );
-    if( sqlite3ExprCompare(pX, pE2->pLeft, iTab)==0 ) return 1;
+    if( sqlite3ExprCompare(pParse, pX, pE2->pLeft, iTab)==0 ) return 1;
   }
   return 0;
 }
@@ -95566,8 +96553,8 @@ SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){
   Walker w;
   struct SrcCount cnt;
   assert( pExpr->op==TK_AGG_FUNCTION );
-  memset(&w, 0, sizeof(w));
   w.xExprCallback = exprSrcCount;
+  w.xSelectCallback = 0;
   w.u.pSrcCount = &cnt;
   cnt.pSrc = pSrcList;
   cnt.nThis = 0;
@@ -95699,7 +96686,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
         */
         struct AggInfo_func *pItem = pAggInfo->aFunc;
         for(i=0; i<pAggInfo->nFunc; i++, pItem++){
-          if( sqlite3ExprCompare(pItem->pExpr, pExpr, -1)==0 ){
+          if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){
             break;
           }
         }
@@ -95739,10 +96726,14 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
   return WRC_Continue;
 }
 static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){
-  UNUSED_PARAMETER(pWalker);
   UNUSED_PARAMETER(pSelect);
+  pWalker->walkerDepth++;
   return WRC_Continue;
 }
+static void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){
+  UNUSED_PARAMETER(pSelect);
+  pWalker->walkerDepth--;
+}
 
 /*
 ** Analyze the pExpr expression looking for aggregate functions and
@@ -95755,9 +96746,10 @@ static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){
 */
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
   Walker w;
-  memset(&w, 0, sizeof(w));
   w.xExprCallback = analyzeAggregate;
   w.xSelectCallback = analyzeAggregatesInSelect;
+  w.xSelectCallback2 = analyzeAggregatesInSelectEnd;
+  w.walkerDepth = 0;
   w.u.pNC = pNC;
   assert( pNC->pSrcList!=0 );
   sqlite3WalkExpr(&w, pExpr);
@@ -95858,8 +96850,8 @@ SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse *pParse){
 SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast){
   int i;
   if( pParse->nRangeReg>0
-   && pParse->iRangeReg+pParse->nRangeReg<iLast
-   && pParse->iRangeReg>=iFirst
+   && pParse->iRangeReg+pParse->nRangeReg > iFirst
+   && pParse->iRangeReg <= iLast
   ){
      return 0;
   }
@@ -96251,7 +97243,7 @@ static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){
 ** Or, if zName is not a system table, zero is returned.
 */
 static int isSystemTable(Parse *pParse, const char *zName){
-  if( sqlite3Strlen30(zName)>6 && 0==sqlite3StrNICmp(zName, "sqlite_", 7) ){
+  if( 0==sqlite3StrNICmp(zName, "sqlite_", 7) ){
     sqlite3ErrorMsg(pParse, "table %s may not be altered", zName);
     return 1;
   }
@@ -98670,7 +99662,8 @@ static void attachFunc(
   char *zPath = 0;
   char *zErr = 0;
   unsigned int flags;
-  Db *aNew;
+  Db *aNew;                 /* New array of Db pointers */
+  Db *pNew;                 /* Db object for the newly attached database */
   char *zErrDyn = 0;
   sqlite3_vfs *pVfs;
 
@@ -98718,8 +99711,8 @@ static void attachFunc(
     if( aNew==0 ) return;
   }
   db->aDb = aNew;
-  aNew = &db->aDb[db->nDb];
-  memset(aNew, 0, sizeof(*aNew));
+  pNew = &db->aDb[db->nDb];
+  memset(pNew, 0, sizeof(*pNew));
 
   /* Open the database file. If the btree is successfully opened, use
   ** it to obtain the database schema. At this point the schema may
@@ -98735,7 +99728,7 @@ static void attachFunc(
   }
   assert( pVfs );
   flags |= SQLITE_OPEN_MAIN_DB;
-  rc = sqlite3BtreeOpen(pVfs, zPath, db, &aNew->pBt, 0, flags);
+  rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
   sqlite3_free( zPath );
   db->nDb++;
   db->skipBtreeMutex = 0;
@@ -98744,28 +99737,28 @@ static void attachFunc(
     zErrDyn = sqlite3MPrintf(db, "database is already attached");
   }else if( rc==SQLITE_OK ){
     Pager *pPager;
-    aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt);
-    if( !aNew->pSchema ){
+    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
+    if( !pNew->pSchema ){
       rc = SQLITE_NOMEM_BKPT;
-    }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=ENC(db) ){
+    }else if( pNew->pSchema->file_format && pNew->pSchema->enc!=ENC(db) ){
       zErrDyn = sqlite3MPrintf(db, 
         "attached databases must use the same text encoding as main database");
       rc = SQLITE_ERROR;
     }
-    sqlite3BtreeEnter(aNew->pBt);
-    pPager = sqlite3BtreePager(aNew->pBt);
+    sqlite3BtreeEnter(pNew->pBt);
+    pPager = sqlite3BtreePager(pNew->pBt);
     sqlite3PagerLockingMode(pPager, db->dfltLockMode);
-    sqlite3BtreeSecureDelete(aNew->pBt,
+    sqlite3BtreeSecureDelete(pNew->pBt,
                              sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );
 #ifndef SQLITE_OMIT_PAGER_PRAGMAS
-    sqlite3BtreeSetPagerFlags(aNew->pBt,
+    sqlite3BtreeSetPagerFlags(pNew->pBt,
                       PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));
 #endif
-    sqlite3BtreeLeave(aNew->pBt);
+    sqlite3BtreeLeave(pNew->pBt);
   }
-  aNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
-  aNew->zDbSName = sqlite3DbStrDup(db, zName);
-  if( rc==SQLITE_OK && aNew->zDbSName==0 ){
+  pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
+  pNew->zDbSName = sqlite3DbStrDup(db, zName);
+  if( rc==SQLITE_OK && pNew->zDbSName==0 ){
     rc = SQLITE_NOMEM_BKPT;
   }
 
@@ -99403,6 +100396,18 @@ SQLITE_PRIVATE int sqlite3AuthCheck(
   if( db->xAuth==0 ){
     return SQLITE_OK;
   }
+
+  /* EVIDENCE-OF: R-43249-19882 The third through sixth parameters to the
+  ** callback are either NULL pointers or zero-terminated strings that
+  ** contain additional details about the action to be authorized.
+  **
+  ** The following testcase() macros show that any of the 3rd through 6th
+  ** parameters can be either NULL or a string. */
+  testcase( zArg1==0 );
+  testcase( zArg2==0 );
+  testcase( zArg3==0 );
+  testcase( pParse->zAuthContext==0 );
+
   rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext
 #ifdef SQLITE_USER_AUTHENTICATION
                  ,db->auth.zAuthUser
@@ -100390,7 +101395,11 @@ SQLITE_PRIVATE void sqlite3StartTable(
   pTable->iPKey = -1;
   pTable->pSchema = db->aDb[iDb].pSchema;
   pTable->nTabRef = 1;
+#ifdef SQLITE_DEFAULT_ROWEST
+  pTable->nRowLogEst = sqlite3LogEst(SQLITE_DEFAULT_ROWEST);
+#else
   pTable->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
+#endif
   assert( pParse->pNewTable==0 );
   pParse->pNewTable = pTable;
 
@@ -101185,15 +102194,6 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   }else{
     pPk = sqlite3PrimaryKeyIndex(pTab);
 
-    /* Bypass the creation of the PRIMARY KEY btree and the sqlite_master
-    ** table entry. This is only required if currently generating VDBE
-    ** code for a CREATE TABLE (not when parsing one as part of reading
-    ** a database schema).  */
-    if( v ){
-      assert( db->init.busy==0 );
-      sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);
-    }
-
     /*
     ** Remove all redundant columns from the PRIMARY KEY.  For example, change
     ** "PRIMARY KEY(a,b,a,b,c,b,c,d)" into just "PRIMARY KEY(a,b,c,d)".  Later
@@ -101213,6 +102213,15 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   if( !db->init.imposterTable ) pPk->uniqNotNull = 1;
   nPk = pPk->nKeyCol;
 
+  /* Bypass the creation of the PRIMARY KEY btree and the sqlite_master
+  ** table entry. This is only required if currently generating VDBE
+  ** code for a CREATE TABLE (not when parsing one as part of reading
+  ** a database schema).  */
+  if( v && pPk->tnum>0 ){
+    assert( db->init.busy==0 );
+    sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);
+  }
+
   /* The root page of the PRIMARY KEY is the table root page */
   pPk->tnum = pTab->tnum;
 
@@ -103074,7 +104083,7 @@ SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
     sqlite3DbFree(db, pList->a[i].zName);
   }
   sqlite3DbFree(db, pList->a);
-  sqlite3DbFree(db, pList);
+  sqlite3DbFreeNN(db, pList);
 }
 
 /*
@@ -103219,12 +104228,12 @@ SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(
     pDatabase = 0;
   }
   if( pDatabase ){
-    Token *pTemp = pDatabase;
-    pDatabase = pTable;
-    pTable = pTemp;
+    pItem->zName = sqlite3NameFromToken(db, pDatabase);
+    pItem->zDatabase = sqlite3NameFromToken(db, pTable);
+  }else{
+    pItem->zName = sqlite3NameFromToken(db, pTable);
+    pItem->zDatabase = 0;
   }
-  pItem->zName = sqlite3NameFromToken(db, pTable);
-  pItem->zDatabase = sqlite3NameFromToken(db, pDatabase);
   return pList;
 }
 
@@ -103264,7 +104273,7 @@ SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
     sqlite3ExprDelete(db, pItem->pOn);
     sqlite3IdListDelete(db, pItem->pUsing);
   }
-  sqlite3DbFree(db, pList);
+  sqlite3DbFreeNN(db, pList);
 }
 
 /*
@@ -103413,36 +104422,25 @@ SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type){
 }
 
 /*
-** Generate VDBE code for a COMMIT statement.
-*/
-SQLITE_PRIVATE void sqlite3CommitTransaction(Parse *pParse){
-  Vdbe *v;
-
-  assert( pParse!=0 );
-  assert( pParse->db!=0 );
-  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "COMMIT", 0, 0) ){
-    return;
-  }
-  v = sqlite3GetVdbe(pParse);
-  if( v ){
-    sqlite3VdbeAddOp1(v, OP_AutoCommit, 1);
-  }
-}
-
-/*
-** Generate VDBE code for a ROLLBACK statement.
+** Generate VDBE code for a COMMIT or ROLLBACK statement.
+** Code for ROLLBACK is generated if eType==TK_ROLLBACK.  Otherwise
+** code is generated for a COMMIT.
 */
-SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse *pParse){
+SQLITE_PRIVATE void sqlite3EndTransaction(Parse *pParse, int eType){
   Vdbe *v;
+  int isRollback;
 
   assert( pParse!=0 );
   assert( pParse->db!=0 );
-  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "ROLLBACK", 0, 0) ){
+  assert( eType==TK_COMMIT || eType==TK_END || eType==TK_ROLLBACK );
+  isRollback = eType==TK_ROLLBACK;
+  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, 
+       isRollback ? "ROLLBACK" : "COMMIT", 0, 0) ){
     return;
   }
   v = sqlite3GetVdbe(pParse);
   if( v ){
-    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 1);
+    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, isRollback);
   }
 }
 
@@ -103632,7 +104630,9 @@ SQLITE_PRIVATE void sqlite3UniqueConstraint(
       assert( pIdx->aiColumn[j]>=0 );
       zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
       if( j ) sqlite3StrAccumAppend(&errMsg, ", ", 2);
-      sqlite3XPrintf(&errMsg, "%s.%s", pTab->zName, zCol);
+      sqlite3StrAccumAppendAll(&errMsg, pTab->zName);
+      sqlite3StrAccumAppend(&errMsg, ".", 1);
+      sqlite3StrAccumAppendAll(&errMsg, zCol);
     }
   }
   zErr = sqlite3StrAccumFinish(&errMsg);
@@ -104021,7 +105021,7 @@ SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(
 ** from the main database is substituted, if one is available.
 */
 SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){
-  if( pColl ){
+  if( pColl && pColl->xCmp==0 ){
     const char *zName = pColl->zName;
     sqlite3 *db = pParse->db;
     CollSeq *p = sqlite3GetCollSeq(pParse, ENC(db), pColl, zName);
@@ -104057,8 +105057,8 @@ static CollSeq *findCollSeqEntry(
   pColl = sqlite3HashFind(&db->aCollSeq, zName);
 
   if( 0==pColl && create ){
-    int nName = sqlite3Strlen30(zName);
-    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1);
+    int nName = sqlite3Strlen30(zName) + 1;
+    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName);
     if( pColl ){
       CollSeq *pDel = 0;
       pColl[0].zName = (char*)&pColl[3];
@@ -104068,7 +105068,6 @@ static CollSeq *findCollSeqEntry(
       pColl[2].zName = (char*)&pColl[3];
       pColl[2].enc = SQLITE_UTF16BE;
       memcpy(pColl[0].zName, zName, nName);
-      pColl[0].zName[nName] = 0;
       pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);
 
       /* If a malloc() failure occurred in sqlite3HashInsert(), it will 
@@ -104208,7 +105207,8 @@ SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(
     FuncDef *pOther;
     const char *zName = aDef[i].zName;
     int nName = sqlite3Strlen30(zName);
-    int h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % SQLITE_FUNC_HASH_SZ;
+    int h = (zName[0] + nName) % SQLITE_FUNC_HASH_SZ;
+    assert( zName[0]>='a' && zName[0]<='z' );
     pOther = functionSearch(h, zName);
     if( pOther ){
       assert( pOther!=&aDef[i] && pOther->pNext!=&aDef[i] );
@@ -104738,7 +105738,14 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
   /* Special case: A DELETE without a WHERE clause deletes everything.
   ** It is easier just to erase the whole table. Prior to version 3.6.5,
   ** this optimization caused the row change count (the value returned by 
-  ** API function sqlite3_count_changes) to be set incorrectly.  */
+  ** API function sqlite3_count_changes) to be set incorrectly.
+  **
+  ** The "rcauth==SQLITE_OK" terms is the
+  ** IMPLEMENTATION-OF: R-17228-37124 If the action code is SQLITE_DELETE and
+  ** the callback returns SQLITE_IGNORE then the DELETE operation proceeds but
+  ** the truncate optimization is disabled and all rows are deleted
+  ** individually.
+  */
   if( rcauth==SQLITE_OK
    && pWhere==0
    && !bComplex
@@ -104840,7 +105847,7 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEphCur, iKey, iPk, nPk);
       }else{
         /* Add the rowid of the row to be deleted to the RowSet */
-        nKey = 1;  /* OP_Seek always uses a single rowid */
+        nKey = 1;  /* OP_DeferredSeek always uses a single rowid */
         sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);
       }
     }
@@ -105233,10 +106240,11 @@ SQLITE_PRIVATE int sqlite3GenerateIndexKey(
   if( piPartIdxLabel ){
     if( pIdx->pPartIdxWhere ){
       *piPartIdxLabel = sqlite3VdbeMakeLabel(v);
-      pParse->iSelfTab = iDataCur;
+      pParse->iSelfTab = iDataCur + 1;
       sqlite3ExprCachePush(pParse);
       sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel, 
                             SQLITE_JUMPIFNULL);
+      pParse->iSelfTab = 0;
     }else{
       *piPartIdxLabel = 0;
     }
@@ -105364,16 +106372,20 @@ static void typeofFunc(
   int NotUsed,
   sqlite3_value **argv
 ){
-  const char *z = 0;
+  static const char *azType[] = { "integer", "real", "text", "blob", "null" };
+  int i = sqlite3_value_type(argv[0]) - 1;
   UNUSED_PARAMETER(NotUsed);
-  switch( sqlite3_value_type(argv[0]) ){
-    case SQLITE_INTEGER: z = "integer"; break;
-    case SQLITE_TEXT:    z = "text";    break;
-    case SQLITE_FLOAT:   z = "real";    break;
-    case SQLITE_BLOB:    z = "blob";    break;
-    default:             z = "null";    break;
-  }
-  sqlite3_result_text(context, z, -1, SQLITE_STATIC);
+  assert( i>=0 && i<ArraySize(azType) );
+  assert( SQLITE_INTEGER==1 );
+  assert( SQLITE_FLOAT==2 );
+  assert( SQLITE_TEXT==3 );
+  assert( SQLITE_BLOB==4 );
+  assert( SQLITE_NULL==5 );
+  /* EVIDENCE-OF: R-01470-60482 The sqlite3_value_type(V) interface returns
+  ** the datatype code for the initial datatype of the sqlite3_value object
+  ** V. The returned value is one of SQLITE_INTEGER, SQLITE_FLOAT,
+  ** SQLITE_TEXT, SQLITE_BLOB, or SQLITE_NULL. */
+  sqlite3_result_text(context, azType[i], -1, SQLITE_STATIC);
 }
 
 
@@ -107794,10 +108806,12 @@ static void fkScanChildren(
   /* Create VDBE to loop through the entries in pSrc that match the WHERE
   ** clause. For each row found, increment either the deferred or immediate
   ** foreign key constraint counter. */
-  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);
-  sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
-  if( pWInfo ){
-    sqlite3WhereEnd(pWInfo);
+  if( pParse->nErr==0 ){
+    pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);
+    sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
+    if( pWInfo ){
+      sqlite3WhereEnd(pWInfo);
+    }
   }
 
   /* Clean up the WHERE clause constructed above. */
@@ -108248,8 +109262,16 @@ SQLITE_PRIVATE u32 sqlite3FkOldmask(
 ** UPDATE statement modifies the rowid fields of the table.
 **
 ** If any foreign key processing will be required, this function returns
-** true. If there is no foreign key related processing, this function 
-** returns false.
+** non-zero. If there is no foreign key related processing, this function 
+** returns zero.
+**
+** For an UPDATE, this function returns 2 if:
+**
+**   * There are any FKs for which pTab is the child and the parent table, or
+**   * the UPDATE modifies one or more parent keys for which the action is
+**     not "NO ACTION" (i.e. is CASCADE, SET DEFAULT or SET NULL).
+**
+** Or, assuming some other foreign key processing is required, 1.
 */
 SQLITE_PRIVATE int sqlite3FkRequired(
   Parse *pParse,                  /* Parse context */
@@ -108257,12 +109279,13 @@ SQLITE_PRIVATE int sqlite3FkRequired(
   int *aChange,                   /* Non-NULL for UPDATE operations */
   int chngRowid                   /* True for UPDATE that affects rowid */
 ){
+  int eRet = 0;
   if( pParse->db->flags&SQLITE_ForeignKeys ){
     if( !aChange ){
       /* A DELETE operation. Foreign key processing is required if the 
       ** table in question is either the child or parent table for any 
       ** foreign key constraint.  */
-      return (sqlite3FkReferences(pTab) || pTab->pFKey);
+      eRet = (sqlite3FkReferences(pTab) || pTab->pFKey);
     }else{
       /* This is an UPDATE. Foreign key processing is only required if the
       ** operation modifies one or more child or parent key columns. */
@@ -108270,16 +109293,22 @@ SQLITE_PRIVATE int sqlite3FkRequired(
 
       /* Check if any child key columns are being modified. */
       for(p=pTab->pFKey; p; p=p->pNextFrom){
-        if( fkChildIsModified(pTab, p, aChange, chngRowid) ) return 1;
+        if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) return 2;
+        if( fkChildIsModified(pTab, p, aChange, chngRowid) ){
+          eRet = 1;
+        }
       }
 
       /* Check if any parent key columns are being modified. */
       for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
-        if( fkParentIsModified(pTab, p, aChange, chngRowid) ) return 1;
+        if( fkParentIsModified(pTab, p, aChange, chngRowid) ){
+          if( p->aAction[1]!=OE_None ) return 2;
+          eRet = 1;
+        }
       }
     }
   }
-  return 0;
+  return eRet;
 }
 
 /*
@@ -109089,10 +110118,10 @@ SQLITE_PRIVATE void sqlite3Insert(
 #endif
 
   db = pParse->db;
-  memset(&dest, 0, sizeof(dest));
   if( pParse->nErr || db->mallocFailed ){
     goto insert_cleanup;
   }
+  dest.iSDParm = 0;  /* Suppress a harmless compiler warning */
 
   /* If the Select object is really just a simple VALUES() list with a
   ** single row (the common case) then keep that one row of values
@@ -109901,7 +110930,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
 #ifndef SQLITE_OMIT_CHECK
   if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
     ExprList *pCheck = pTab->pCheck;
-    pParse->ckBase = regNewData+1;
+    pParse->iSelfTab = -(regNewData+1);
     onError = overrideError!=OE_Default ? overrideError : OE_Abort;
     for(i=0; i<pCheck->nExpr; i++){
       int allOk;
@@ -109921,6 +110950,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
       }
       sqlite3VdbeResolveLabel(v, allOk);
     }
+    pParse->iSelfTab = 0;
   }
 #endif /* !defined(SQLITE_OMIT_CHECK) */
 
@@ -110065,10 +111095,10 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
     /* Skip partial indices for which the WHERE clause is not true */
     if( pIdx->pPartIdxWhere ){
       sqlite3VdbeAddOp2(v, OP_Null, 0, aRegIdx[ix]);
-      pParse->ckBase = regNewData+1;
+      pParse->iSelfTab = -(regNewData+1);
       sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,
                             SQLITE_JUMPIFNULL);
-      pParse->ckBase = 0;
+      pParse->iSelfTab = 0;
     }
 
     /* Create a record for this index entry as it should appear after
@@ -110079,9 +111109,9 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
       int iField = pIdx->aiColumn[i];
       int x;
       if( iField==XN_EXPR ){
-        pParse->ckBase = regNewData+1;
+        pParse->iSelfTab = -(regNewData+1);
         sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
-        pParse->ckBase = 0;
+        pParse->iSelfTab = 0;
         VdbeComment((v, "%s column %d", pIdx->zName, i));
       }else{
         if( iField==XN_ROWID || iField==pTab->iPKey ){
@@ -110466,7 +111496,7 @@ static int xferCompatibleIndex(Index *pDest, Index *pSrc){
     }
     if( pSrc->aiColumn[i]==XN_EXPR ){
       assert( pSrc->aColExpr!=0 && pDest->aColExpr!=0 );
-      if( sqlite3ExprCompare(pSrc->aColExpr->a[i].pExpr,
+      if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,
                              pDest->aColExpr->a[i].pExpr, -1)!=0 ){
         return 0;   /* Different expressions in the index */
       }
@@ -110478,7 +111508,7 @@ static int xferCompatibleIndex(Index *pDest, Index *pSrc){
       return 0;   /* Different collating sequences */
     }
   }
-  if( sqlite3ExprCompare(pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){
+  if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){
     return 0;     /* Different WHERE clauses */
   }
 
@@ -110958,11 +111988,8 @@ SQLITE_API int sqlite3_exec(
 
   rc = sqlite3ApiExit(db, rc);
   if( rc!=SQLITE_OK && pzErrMsg ){
-    int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));
-    *pzErrMsg = sqlite3Malloc(nErrMsg);
-    if( *pzErrMsg ){
-      memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);
-    }else{
+    *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));
+    if( *pzErrMsg==0 ){
       rc = SQLITE_NOMEM_BKPT;
       sqlite3Error(db, SQLITE_NOMEM);
     }
@@ -111283,6 +112310,14 @@ struct sqlite3_api_routines {
   char *(*expanded_sql)(sqlite3_stmt*);
   /* Version 3.18.0 and later */
   void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);
+  /* Version 3.20.0 and later */
+  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,
+                    sqlite3_stmt**,const char**);
+  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,
+                      sqlite3_stmt**,const void**);
+  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));
+  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));
+  void *(*value_pointer)(sqlite3_value*,const char*);
 };
 
 /*
@@ -111543,6 +112578,12 @@ typedef int (*sqlite3_loadext_entry)(
 #define sqlite3_expanded_sql           sqlite3_api->expanded_sql
 /* Version 3.18.0 and later */
 #define sqlite3_set_last_insert_rowid  sqlite3_api->set_last_insert_rowid
+/* Version 3.20.0 and later */
+#define sqlite3_prepare_v3             sqlite3_api->prepare_v3
+#define sqlite3_prepare16_v3           sqlite3_api->prepare16_v3
+#define sqlite3_bind_pointer           sqlite3_api->bind_pointer
+#define sqlite3_result_pointer         sqlite3_api->result_pointer
+#define sqlite3_value_pointer          sqlite3_api->value_pointer
 #endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
 #if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
@@ -111598,6 +112639,7 @@ typedef int (*sqlite3_loadext_entry)(
 # define sqlite3_open16                 0
 # define sqlite3_prepare16              0
 # define sqlite3_prepare16_v2           0
+# define sqlite3_prepare16_v3           0
 # define sqlite3_result_error16         0
 # define sqlite3_result_text16          0
 # define sqlite3_result_text16be        0
@@ -111970,7 +113012,13 @@ static const sqlite3_api_routines sqlite3Apis = {
   sqlite3_trace_v2,
   sqlite3_expanded_sql,
   /* Version 3.18.0 and later */
-  sqlite3_set_last_insert_rowid
+  sqlite3_set_last_insert_rowid,
+  /* Version 3.20.0 and later */
+  sqlite3_prepare_v3,
+  sqlite3_prepare16_v3,
+  sqlite3_bind_pointer,
+  sqlite3_result_pointer,
+  sqlite3_value_pointer
 };
 
 /*
@@ -112392,35 +113440,38 @@ SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){
 #define PragTyp_ENCODING                      12
 #define PragTyp_FOREIGN_KEY_CHECK             13
 #define PragTyp_FOREIGN_KEY_LIST              14
-#define PragTyp_INCREMENTAL_VACUUM            15
-#define PragTyp_INDEX_INFO                    16
-#define PragTyp_INDEX_LIST                    17
-#define PragTyp_INTEGRITY_CHECK               18
-#define PragTyp_JOURNAL_MODE                  19
-#define PragTyp_JOURNAL_SIZE_LIMIT            20
-#define PragTyp_LOCK_PROXY_FILE               21
-#define PragTyp_LOCKING_MODE                  22
-#define PragTyp_PAGE_COUNT                    23
-#define PragTyp_MMAP_SIZE                     24
-#define PragTyp_OPTIMIZE                      25
-#define PragTyp_PAGE_SIZE                     26
-#define PragTyp_SECURE_DELETE                 27
-#define PragTyp_SHRINK_MEMORY                 28
-#define PragTyp_SOFT_HEAP_LIMIT               29
-#define PragTyp_SYNCHRONOUS                   30
-#define PragTyp_TABLE_INFO                    31
-#define PragTyp_TEMP_STORE                    32
-#define PragTyp_TEMP_STORE_DIRECTORY          33
-#define PragTyp_THREADS                       34
-#define PragTyp_WAL_AUTOCHECKPOINT            35
-#define PragTyp_WAL_CHECKPOINT                36
-#define PragTyp_ACTIVATE_EXTENSIONS           37
-#define PragTyp_HEXKEY                        38
-#define PragTyp_KEY                           39
-#define PragTyp_REKEY                         40
-#define PragTyp_LOCK_STATUS                   41
-#define PragTyp_PARSER_TRACE                  42
-#define PragTyp_STATS                         43
+#define PragTyp_FUNCTION_LIST                 15
+#define PragTyp_INCREMENTAL_VACUUM            16
+#define PragTyp_INDEX_INFO                    17
+#define PragTyp_INDEX_LIST                    18
+#define PragTyp_INTEGRITY_CHECK               19
+#define PragTyp_JOURNAL_MODE                  20
+#define PragTyp_JOURNAL_SIZE_LIMIT            21
+#define PragTyp_LOCK_PROXY_FILE               22
+#define PragTyp_LOCKING_MODE                  23
+#define PragTyp_PAGE_COUNT                    24
+#define PragTyp_MMAP_SIZE                     25
+#define PragTyp_MODULE_LIST                   26
+#define PragTyp_OPTIMIZE                      27
+#define PragTyp_PAGE_SIZE                     28
+#define PragTyp_PRAGMA_LIST                   29
+#define PragTyp_SECURE_DELETE                 30
+#define PragTyp_SHRINK_MEMORY                 31
+#define PragTyp_SOFT_HEAP_LIMIT               32
+#define PragTyp_SYNCHRONOUS                   33
+#define PragTyp_TABLE_INFO                    34
+#define PragTyp_TEMP_STORE                    35
+#define PragTyp_TEMP_STORE_DIRECTORY          36
+#define PragTyp_THREADS                       37
+#define PragTyp_WAL_AUTOCHECKPOINT            38
+#define PragTyp_WAL_CHECKPOINT                39
+#define PragTyp_ACTIVATE_EXTENSIONS           40
+#define PragTyp_HEXKEY                        41
+#define PragTyp_KEY                           42
+#define PragTyp_REKEY                         43
+#define PragTyp_LOCK_STATUS                   44
+#define PragTyp_PARSER_TRACE                  45
+#define PragTyp_STATS                         46
 
 /* Property flags associated with various pragma. */
 #define PragFlg_NeedSchema 0x01 /* Force schema load before running */
@@ -112466,26 +113517,29 @@ static const char *const pragCName[] = {
   /*  26 */ "seq",         /* Used by: database_list */
   /*  27 */ "name",       
   /*  28 */ "file",       
-  /*  29 */ "seq",         /* Used by: collation_list */
-  /*  30 */ "name",       
-  /*  31 */ "id",          /* Used by: foreign_key_list */
-  /*  32 */ "seq",        
-  /*  33 */ "table",      
-  /*  34 */ "from",       
-  /*  35 */ "to",         
-  /*  36 */ "on_update",  
-  /*  37 */ "on_delete",  
-  /*  38 */ "match",      
-  /*  39 */ "table",       /* Used by: foreign_key_check */
-  /*  40 */ "rowid",      
-  /*  41 */ "parent",     
-  /*  42 */ "fkid",       
-  /*  43 */ "busy",        /* Used by: wal_checkpoint */
-  /*  44 */ "log",        
-  /*  45 */ "checkpointed",
-  /*  46 */ "timeout",     /* Used by: busy_timeout */
-  /*  47 */ "database",    /* Used by: lock_status */
-  /*  48 */ "status",     
+  /*  29 */ "name",        /* Used by: function_list */
+  /*  30 */ "builtin",    
+  /*  31 */ "name",        /* Used by: module_list pragma_list */
+  /*  32 */ "seq",         /* Used by: collation_list */
+  /*  33 */ "name",       
+  /*  34 */ "id",          /* Used by: foreign_key_list */
+  /*  35 */ "seq",        
+  /*  36 */ "table",      
+  /*  37 */ "from",       
+  /*  38 */ "to",         
+  /*  39 */ "on_update",  
+  /*  40 */ "on_delete",  
+  /*  41 */ "match",      
+  /*  42 */ "table",       /* Used by: foreign_key_check */
+  /*  43 */ "rowid",      
+  /*  44 */ "parent",     
+  /*  45 */ "fkid",       
+  /*  46 */ "busy",        /* Used by: wal_checkpoint */
+  /*  47 */ "log",        
+  /*  48 */ "checkpointed",
+  /*  49 */ "timeout",     /* Used by: busy_timeout */
+  /*  50 */ "database",    /* Used by: lock_status */
+  /*  51 */ "status",     
 };
 
 /* Definitions of all built-in pragmas */
@@ -112531,7 +113585,7 @@ static const PragmaName aPragmaName[] = {
  {/* zName:     */ "busy_timeout",
   /* ePragTyp:  */ PragTyp_BUSY_TIMEOUT,
   /* ePragFlg:  */ PragFlg_Result0,
-  /* ColNames:  */ 46, 1,
+  /* ColNames:  */ 49, 1,
   /* iArg:      */ 0 },
 #if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
  {/* zName:     */ "cache_size",
@@ -112568,7 +113622,7 @@ static const PragmaName aPragmaName[] = {
  {/* zName:     */ "collation_list",
   /* ePragTyp:  */ PragTyp_COLLATION_LIST,
   /* ePragFlg:  */ PragFlg_Result0,
-  /* ColNames:  */ 29, 2,
+  /* ColNames:  */ 32, 2,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_COMPILEOPTION_DIAGS)
@@ -112639,15 +113693,15 @@ static const PragmaName aPragmaName[] = {
 #if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
  {/* zName:     */ "foreign_key_check",
   /* ePragTyp:  */ PragTyp_FOREIGN_KEY_CHECK,
-  /* ePragFlg:  */ PragFlg_NeedSchema,
-  /* ColNames:  */ 39, 4,
+  /* ePragFlg:  */ PragFlg_NeedSchema|PragFlg_Result0,
+  /* ColNames:  */ 42, 4,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_FOREIGN_KEY)
  {/* zName:     */ "foreign_key_list",
   /* ePragTyp:  */ PragTyp_FOREIGN_KEY_LIST,
   /* ePragFlg:  */ PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,
-  /* ColNames:  */ 31, 8,
+  /* ColNames:  */ 34, 8,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
@@ -112678,6 +113732,15 @@ static const PragmaName aPragmaName[] = {
   /* ColNames:  */ 0, 0,
   /* iArg:      */ SQLITE_FullFSync },
 #endif
+#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
+#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+ {/* zName:     */ "function_list",
+  /* ePragTyp:  */ PragTyp_FUNCTION_LIST,
+  /* ePragFlg:  */ PragFlg_Result0,
+  /* ColNames:  */ 29, 2,
+  /* iArg:      */ 0 },
+#endif
+#endif
 #if defined(SQLITE_HAS_CODEC)
  {/* zName:     */ "hexkey",
   /* ePragTyp:  */ PragTyp_HEXKEY,
@@ -112726,7 +113789,7 @@ static const PragmaName aPragmaName[] = {
 #if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
  {/* zName:     */ "integrity_check",
   /* ePragTyp:  */ PragTyp_INTEGRITY_CHECK,
-  /* ePragFlg:  */ PragFlg_NeedSchema,
+  /* ePragFlg:  */ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #endif
@@ -112767,7 +113830,7 @@ static const PragmaName aPragmaName[] = {
  {/* zName:     */ "lock_status",
   /* ePragTyp:  */ PragTyp_LOCK_STATUS,
   /* ePragFlg:  */ PragFlg_Result0,
-  /* ColNames:  */ 47, 2,
+  /* ColNames:  */ 50, 2,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
@@ -112786,10 +113849,21 @@ static const PragmaName aPragmaName[] = {
   /* ePragFlg:  */ 0,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
+#endif
+#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
+#if !defined(SQLITE_OMIT_VIRTUALTABLE)
+#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+ {/* zName:     */ "module_list",
+  /* ePragTyp:  */ PragTyp_MODULE_LIST,
+  /* ePragFlg:  */ PragFlg_Result0,
+  /* ColNames:  */ 31, 1,
+  /* iArg:      */ 0 },
+#endif
+#endif
 #endif
  {/* zName:     */ "optimize",
   /* ePragTyp:  */ PragTyp_OPTIMIZE,
-  /* ePragFlg:  */ PragFlg_Result1,
+  /* ePragFlg:  */ PragFlg_Result1|PragFlg_NeedSchema,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
@@ -112811,6 +113885,13 @@ static const PragmaName aPragmaName[] = {
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #endif
+#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+ {/* zName:     */ "pragma_list",
+  /* ePragTyp:  */ PragTyp_PRAGMA_LIST,
+  /* ePragFlg:  */ PragFlg_Result0,
+  /* ColNames:  */ 31, 1,
+  /* iArg:      */ 0 },
+#endif
 #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
  {/* zName:     */ "query_only",
   /* ePragTyp:  */ PragTyp_FLAG,
@@ -112821,7 +113902,7 @@ static const PragmaName aPragmaName[] = {
 #if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
  {/* zName:     */ "quick_check",
   /* ePragTyp:  */ PragTyp_INTEGRITY_CHECK,
-  /* ePragFlg:  */ PragFlg_NeedSchema,
+  /* ePragFlg:  */ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #endif
@@ -112830,7 +113911,7 @@ static const PragmaName aPragmaName[] = {
   /* ePragTyp:  */ PragTyp_FLAG,
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
-  /* iArg:      */ SQLITE_ReadUncommitted },
+  /* iArg:      */ SQLITE_ReadUncommit },
  {/* zName:     */ "recursive_triggers",
   /* ePragTyp:  */ PragTyp_FLAG,
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
@@ -112974,7 +114055,7 @@ static const PragmaName aPragmaName[] = {
  {/* zName:     */ "wal_checkpoint",
   /* ePragTyp:  */ PragTyp_WAL_CHECKPOINT,
   /* ePragFlg:  */ PragFlg_NeedSchema,
-  /* ColNames:  */ 43, 3,
+  /* ColNames:  */ 46, 3,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
@@ -112982,10 +114063,10 @@ static const PragmaName aPragmaName[] = {
   /* ePragTyp:  */ PragTyp_FLAG,
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
-  /* iArg:      */ SQLITE_WriteSchema|SQLITE_RecoveryMode },
+  /* iArg:      */ SQLITE_WriteSchema },
 #endif
 };
-/* Number of pragmas: 60 on by default, 74 total. */
+/* Number of pragmas: 60 on by default, 77 total. */
 
 /************** End of pragma.h **********************************************/
 /************** Continuing where we left off in pragma.c *********************/
@@ -113475,18 +114556,22 @@ SQLITE_PRIVATE void sqlite3Pragma(
 
   /*
   **  PRAGMA [schema.]secure_delete
-  **  PRAGMA [schema.]secure_delete=ON/OFF
+  **  PRAGMA [schema.]secure_delete=ON/OFF/FAST
   **
   ** The first form reports the current setting for the
   ** secure_delete flag.  The second form changes the secure_delete
-  ** flag setting and reports thenew value.
+  ** flag setting and reports the new value.
   */
   case PragTyp_SECURE_DELETE: {
     Btree *pBt = pDb->pBt;
     int b = -1;
     assert( pBt!=0 );
     if( zRight ){
-      b = sqlite3GetBoolean(zRight, 0);
+      if( sqlite3_stricmp(zRight, "fast")==0 ){
+        b = 2;
+      }else{
+        b = sqlite3GetBoolean(zRight, 0);
+      }
     }
     if( pId2->n==0 && b>=0 ){
       int ii;
@@ -114068,7 +115153,6 @@ SQLITE_PRIVATE void sqlite3Pragma(
                pCol->notNull ? 1 : 0,
                pCol->pDflt ? pCol->pDflt->u.zToken : 0,
                k);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6);
       }
     }
   }
@@ -114088,9 +115172,8 @@ SQLITE_PRIVATE void sqlite3Pragma(
            pTab->szTabRow,
            pTab->nRowLogEst,
            pTab->tabFlags);
-      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
       for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-        sqlite3VdbeMultiLoad(v, 2, "siii",
+        sqlite3VdbeMultiLoad(v, 2, "siiiX",
            pIdx->zName,
            pIdx->szIdxRow,
            pIdx->aiRowLogEst[0],
@@ -114123,10 +115206,10 @@ SQLITE_PRIVATE void sqlite3Pragma(
       assert( pParse->nMem<=pPragma->nPragCName );
       for(i=0; i<mx; i++){
         i16 cnum = pIdx->aiColumn[i];
-        sqlite3VdbeMultiLoad(v, 1, "iis", i, cnum,
+        sqlite3VdbeMultiLoad(v, 1, "iisX", i, cnum,
                              cnum<0 ? 0 : pTab->aCol[cnum].zName);
         if( pPragma->iArg ){
-          sqlite3VdbeMultiLoad(v, 4, "isi",
+          sqlite3VdbeMultiLoad(v, 4, "isiX",
             pIdx->aSortOrder[i],
             pIdx->azColl[i],
             i<pIdx->nKeyCol);
@@ -114153,7 +115236,6 @@ SQLITE_PRIVATE void sqlite3Pragma(
            IsUniqueIndex(pIdx),
            azOrigin[pIdx->idxType],
            pIdx->pPartIdxWhere!=0);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
       }
     }
   }
@@ -114169,7 +115251,6 @@ SQLITE_PRIVATE void sqlite3Pragma(
          i,
          db->aDb[i].zDbSName,
          sqlite3BtreeGetFilename(db->aDb[i].pBt));
-      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
     }
   }
   break;
@@ -114181,10 +115262,53 @@ SQLITE_PRIVATE void sqlite3Pragma(
     for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){
       CollSeq *pColl = (CollSeq *)sqliteHashData(p);
       sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
+    }
+  }
+  break;
+
+#ifdef SQLITE_INTROSPECTION_PRAGMAS
+  case PragTyp_FUNCTION_LIST: {
+    int i;
+    HashElem *j;
+    FuncDef *p;
+    pParse->nMem = 2;
+    for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){
+      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){
+        sqlite3VdbeMultiLoad(v, 1, "si", p->zName, 1);
+        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
+      }
+    }
+    for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){
+      p = (FuncDef*)sqliteHashData(j);
+      sqlite3VdbeMultiLoad(v, 1, "si", p->zName, 0);
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
     }
   }
   break;
+
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  case PragTyp_MODULE_LIST: {
+    HashElem *j;
+    pParse->nMem = 1;
+    for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){
+      Module *pMod = (Module*)sqliteHashData(j);
+      sqlite3VdbeMultiLoad(v, 1, "s", pMod->zName);
+      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+    }
+  }
+  break;
+#endif /* SQLITE_OMIT_VIRTUALTABLE */
+
+  case PragTyp_PRAGMA_LIST: {
+    int i;
+    for(i=0; i<ArraySize(aPragmaName); i++){
+      sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i].zName);
+      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+    }
+  }
+  break;
+#endif /* SQLITE_INTROSPECTION_PRAGMAS */
+
 #endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */
 
 #ifndef SQLITE_OMIT_FOREIGN_KEY
@@ -114210,7 +115334,6 @@ SQLITE_PRIVATE void sqlite3Pragma(
                    actionName(pFK->aAction[1]),  /* ON UPDATE */
                    actionName(pFK->aAction[0]),  /* ON DELETE */
                    "NONE");
-            sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 8);
           }
           ++i;
           pFK = pFK->pNextFrom;
@@ -114289,34 +115412,38 @@ SQLITE_PRIVATE void sqlite3Pragma(
           assert( x==0 );
         }
         addrOk = sqlite3VdbeMakeLabel(v);
-        if( pParent && pIdx==0 ){
-          int iKey = pFK->aCol[0].iFrom;
-          assert( iKey>=0 && iKey<pTab->nCol );
-          if( iKey!=pTab->iPKey ){
-            sqlite3VdbeAddOp3(v, OP_Column, 0, iKey, regRow);
-            sqlite3ColumnDefault(v, pTab, iKey, regRow);
-            sqlite3VdbeAddOp2(v, OP_IsNull, regRow, addrOk); VdbeCoverage(v);
-          }else{
-            sqlite3VdbeAddOp2(v, OP_Rowid, 0, regRow);
-          }
-          sqlite3VdbeAddOp3(v, OP_SeekRowid, i, 0, regRow); VdbeCoverage(v);
+
+        /* Generate code to read the child key values into registers
+        ** regRow..regRow+n. If any of the child key values are NULL, this 
+        ** row cannot cause an FK violation. Jump directly to addrOk in 
+        ** this case. */
+        for(j=0; j<pFK->nCol; j++){
+          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;
+          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);
+          sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);
+        }
+
+        /* Generate code to query the parent index for a matching parent
+        ** key. If a match is found, jump to addrOk. */
+        if( pIdx ){
+          sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,
+              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
+          sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);
+          VdbeCoverage(v);
+        }else if( pParent ){
+          int jmp = sqlite3VdbeCurrentAddr(v)+2;
+          sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);
           sqlite3VdbeGoto(v, addrOk);
-          sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
+          assert( pFK->nCol==1 );
+        }
+
+        /* Generate code to report an FK violation to the caller. */
+        if( HasRowid(pTab) ){
+          sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);
         }else{
-          for(j=0; j<pFK->nCol; j++){
-            sqlite3ExprCodeGetColumnOfTable(v, pTab, 0,
-                            aiCols ? aiCols[j] : pFK->aCol[j].iFrom, regRow+j);
-            sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);
-          }
-          if( pParent ){
-            sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,
-                              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
-            sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);
-            VdbeCoverage(v);
-          }
+          sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);
         }
-        sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);
-        sqlite3VdbeMultiLoad(v, regResult+2, "si", pFK->zTo, i-1);
+        sqlite3VdbeMultiLoad(v, regResult+2, "siX", pFK->zTo, i-1);
         sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);
         sqlite3VdbeResolveLabel(v, addrOk);
         sqlite3DbFree(db, aiCols);
@@ -114442,6 +115569,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
 
       /* Make sure sufficient number of registers have been allocated */
       pParse->nMem = MAX( pParse->nMem, 8+mxIdx );
+      sqlite3ClearTempRegCache(pParse);
 
       /* Do the b-tree integrity checks */
       sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);
@@ -114501,25 +115629,29 @@ SQLITE_PRIVATE void sqlite3Pragma(
         }
         /* Verify CHECK constraints */
         if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
-          int addrCkFault = sqlite3VdbeMakeLabel(v);
-          int addrCkOk = sqlite3VdbeMakeLabel(v);
-          ExprList *pCheck = pTab->pCheck;
-          char *zErr;
-          int k;
-          pParse->iSelfTab = iDataCur;
-          sqlite3ExprCachePush(pParse);
-          for(k=pCheck->nExpr-1; k>0; k--){
-            sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
+          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);
+          if( db->mallocFailed==0 ){
+            int addrCkFault = sqlite3VdbeMakeLabel(v);
+            int addrCkOk = sqlite3VdbeMakeLabel(v);
+            char *zErr;
+            int k;
+            pParse->iSelfTab = iDataCur + 1;
+            sqlite3ExprCachePush(pParse);
+            for(k=pCheck->nExpr-1; k>0; k--){
+              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
+            }
+            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 
+                SQLITE_JUMPIFNULL);
+            sqlite3VdbeResolveLabel(v, addrCkFault);
+            pParse->iSelfTab = 0;
+            zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s",
+                pTab->zName);
+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);
+            integrityCheckResultRow(v, 3);
+            sqlite3VdbeResolveLabel(v, addrCkOk);
+            sqlite3ExprCachePop(pParse);
           }
-          sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 
-                            SQLITE_JUMPIFNULL);
-          sqlite3VdbeResolveLabel(v, addrCkFault);
-          zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s",
-                                pTab->zName);
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);
-          integrityCheckResultRow(v, 3);
-          sqlite3VdbeResolveLabel(v, addrCkOk);
-          sqlite3ExprCachePop(pParse);
+          sqlite3ExprListDelete(db, pCheck);
         }
         /* Validate index entries for the current row */
         for(j=0, pIdx=pTab->pIndex; pIdx && !isQuick; pIdx=pIdx->pNext, j++){
@@ -114853,7 +115985,8 @@ SQLITE_PRIVATE void sqlite3Pragma(
   **    0x0008    (Not yet implemented) Create indexes that might have
   **              been helpful to recent queries
   **
-  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all    ** of the optimizations listed above except Debug Mode, including new
+  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all
+  ** of the optimizations listed above except Debug Mode, including new
   ** optimizations that have not yet been invented.  If new optimizations are
   ** ever added that should be off by default, those off-by-default 
   ** optimizations will have bitmasks of 0x10000 or larger.
@@ -115015,7 +116148,6 @@ SQLITE_PRIVATE void sqlite3Pragma(
          zState = azLockName[j];
       }
       sqlite3VdbeMultiLoad(v, 1, "ss", db->aDb[i].zDbSName, zState);
-      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
     }
     break;
   }
@@ -115281,10 +116413,14 @@ static int pragmaVtabFilter(
   pragmaVtabCursorClear(pCsr);
   j = (pTab->pName->mPragFlg & PragFlg_Result1)!=0 ? 0 : 1;
   for(i=0; i<argc; i++, j++){
+    const char *zText = (const char*)sqlite3_value_text(argv[i]);
     assert( j<ArraySize(pCsr->azArg) );
-    pCsr->azArg[j] = sqlite3_mprintf("%s", sqlite3_value_text(argv[i]));
-    if( pCsr->azArg[j]==0 ){
-      return SQLITE_NOMEM;
+    assert( pCsr->azArg[j]==0 );
+    if( zText ){
+      pCsr->azArg[j] = sqlite3_mprintf("%s", zText);
+      if( pCsr->azArg[j]==0 ){
+        return SQLITE_NOMEM;
+      }
     }
   }
   sqlite3StrAccumInit(&acc, 0, 0, 0, pTab->db->aLimit[SQLITE_LIMIT_SQL_LENGTH]);
@@ -115417,7 +116553,7 @@ static void corruptSchema(
   const char *zExtra   /* Error information */
 ){
   sqlite3 *db = pData->db;
-  if( !db->mallocFailed && (db->flags & SQLITE_RecoveryMode)==0 ){
+  if( !db->mallocFailed && (db->flags & SQLITE_WriteSchema)==0 ){
     char *z;
     if( zObj==0 ) zObj = "?";
     z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
@@ -115704,8 +116840,8 @@ static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){
     rc = SQLITE_NOMEM_BKPT;
     sqlite3ResetAllSchemasOfConnection(db);
   }
-  if( rc==SQLITE_OK || (db->flags&SQLITE_RecoveryMode)){
-    /* Black magic: If the SQLITE_RecoveryMode flag is set, then consider
+  if( rc==SQLITE_OK || (db->flags&SQLITE_WriteSchema)){
+    /* Black magic: If the SQLITE_WriteSchema flag is set, then consider
     ** the schema loaded, even if errors occurred. In this situation the 
     ** current sqlite3_prepare() operation will fail, but the following one
     ** will attempt to compile the supplied statement against whatever subset
@@ -115905,7 +117041,7 @@ static int sqlite3Prepare(
   sqlite3 *db,              /* Database handle. */
   const char *zSql,         /* UTF-8 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
-  int saveSqlFlag,          /* True to copy SQL text into the sqlite3_stmt */
+  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
   Vdbe *pReprepare,         /* VM being reprepared */
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
@@ -115922,6 +117058,14 @@ static int sqlite3Prepare(
   /* assert( !db->mallocFailed ); // not true with SQLITE_USE_ALLOCA */
   assert( sqlite3_mutex_held(db->mutex) );
 
+  /* For a long-term use prepared statement avoid the use of
+  ** lookaside memory.
+  */
+  if( prepFlags & SQLITE_PREPARE_PERSISTENT ){
+    sParse.disableLookaside++;
+    db->lookaside.bDisable++;
+  }
+
   /* Check to verify that it is possible to get a read lock on all
   ** database schemas.  The inability to get a read lock indicates that
   ** some other database connection is holding a write-lock, which in
@@ -115953,7 +117097,7 @@ static int sqlite3Prepare(
       if( rc ){
         const char *zDb = db->aDb[i].zDbSName;
         sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
-        testcase( db->flags & SQLITE_ReadUncommitted );
+        testcase( db->flags & SQLITE_ReadUncommit );
         goto end_prepare;
       }
     }
@@ -116021,8 +117165,7 @@ static int sqlite3Prepare(
 #endif
 
   if( db->init.busy==0 ){
-    Vdbe *pVdbe = sParse.pVdbe;
-    sqlite3VdbeSetSql(pVdbe, zSql, (int)(sParse.zTail-zSql), saveSqlFlag);
+    sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);
   }
   if( sParse.pVdbe && (rc!=SQLITE_OK || db->mallocFailed) ){
     sqlite3VdbeFinalize(sParse.pVdbe);
@@ -116056,7 +117199,7 @@ static int sqlite3LockAndPrepare(
   sqlite3 *db,              /* Database handle. */
   const char *zSql,         /* UTF-8 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
-  int saveSqlFlag,          /* True to copy SQL text into the sqlite3_stmt */
+  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
   Vdbe *pOld,               /* VM being reprepared */
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
@@ -116072,10 +117215,10 @@ static int sqlite3LockAndPrepare(
   }
   sqlite3_mutex_enter(db->mutex);
   sqlite3BtreeEnterAll(db);
-  rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
+  rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
   if( rc==SQLITE_SCHEMA ){
     sqlite3_finalize(*ppStmt);
-    rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
+    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
   }
   sqlite3BtreeLeaveAll(db);
   sqlite3_mutex_leave(db->mutex);
@@ -116096,13 +117239,15 @@ SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){
   sqlite3_stmt *pNew;
   const char *zSql;
   sqlite3 *db;
+  u8 prepFlags;
 
   assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );
   zSql = sqlite3_sql((sqlite3_stmt *)p);
   assert( zSql!=0 );  /* Reprepare only called for prepare_v2() statements */
   db = sqlite3VdbeDb(p);
   assert( sqlite3_mutex_held(db->mutex) );
-  rc = sqlite3LockAndPrepare(db, zSql, -1, 0, p, &pNew, 0);
+  prepFlags = sqlite3VdbePrepareFlags(p);
+  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);
   if( rc ){
     if( rc==SQLITE_NOMEM ){
       sqlite3OomFault(db);
@@ -116148,8 +117293,36 @@ SQLITE_API int sqlite3_prepare_v2(
   const char **pzTail       /* OUT: End of parsed string */
 ){
   int rc;
-  rc = sqlite3LockAndPrepare(db,zSql,nBytes,1,0,ppStmt,pzTail);
-  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
+  /* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works
+  ** exactly the same as sqlite3_prepare_v3() with a zero prepFlags
+  ** parameter.
+  **
+  ** Proof in that the 5th parameter to sqlite3LockAndPrepare is 0 */
+  rc = sqlite3LockAndPrepare(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,0,
+                             ppStmt,pzTail);
+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );
+  return rc;
+}
+SQLITE_API int sqlite3_prepare_v3(
+  sqlite3 *db,              /* Database handle. */
+  const char *zSql,         /* UTF-8 encoded SQL statement. */
+  int nBytes,               /* Length of zSql in bytes. */
+  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
+  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
+  const char **pzTail       /* OUT: End of parsed string */
+){
+  int rc;
+  /* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from
+  ** sqlite3_prepare_v2() only in having the extra prepFlags parameter,
+  ** which is a bit array consisting of zero or more of the
+  ** SQLITE_PREPARE_* flags.
+  **
+  ** Proof by comparison to the implementation of sqlite3_prepare_v2()
+  ** directly above. */
+  rc = sqlite3LockAndPrepare(db,zSql,nBytes,
+                 SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),
+                 0,ppStmt,pzTail);
+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );
   return rc;
 }
 
@@ -116162,7 +117335,7 @@ static int sqlite3Prepare16(
   sqlite3 *db,              /* Database handle. */ 
   const void *zSql,         /* UTF-16 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
-  int saveSqlFlag,          /* True to save SQL text into the sqlite3_stmt */
+  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const void **pzTail       /* OUT: End of parsed string */
 ){
@@ -116190,7 +117363,7 @@ static int sqlite3Prepare16(
   sqlite3_mutex_enter(db->mutex);
   zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);
   if( zSql8 ){
-    rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, 0, ppStmt, &zTail8);
+    rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);
   }
 
   if( zTail8 && pzTail ){
@@ -116236,7 +117409,22 @@ SQLITE_API int sqlite3_prepare16_v2(
   const void **pzTail       /* OUT: End of parsed string */
 ){
   int rc;
-  rc = sqlite3Prepare16(db,zSql,nBytes,1,ppStmt,pzTail);
+  rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);
+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
+  return rc;
+}
+SQLITE_API int sqlite3_prepare16_v3(
+  sqlite3 *db,              /* Database handle. */ 
+  const void *zSql,         /* UTF-16 encoded SQL statement. */
+  int nBytes,               /* Length of zSql in bytes. */
+  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
+  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
+  const void **pzTail       /* OUT: End of parsed string */
+){
+  int rc;
+  rc = sqlite3Prepare16(db,zSql,nBytes,
+         SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),
+         ppStmt,pzTail);
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
 }
@@ -116323,7 +117511,7 @@ static void clearSelect(sqlite3 *db, Select *p, int bFree){
     sqlite3ExprDelete(db, p->pLimit);
     sqlite3ExprDelete(db, p->pOffset);
     if( p->pWith ) sqlite3WithDelete(db, p->pWith);
-    if( bFree ) sqlite3DbFree(db, p);
+    if( bFree ) sqlite3DbFreeNN(db, p);
     p = pPrior;
     bFree = 1;
   }
@@ -116359,14 +117547,13 @@ SQLITE_PRIVATE Select *sqlite3SelectNew(
 ){
   Select *pNew;
   Select standin;
-  sqlite3 *db = pParse->db;
-  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );
+  pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );
   if( pNew==0 ){
-    assert( db->mallocFailed );
+    assert( pParse->db->mallocFailed );
     pNew = &standin;
   }
   if( pEList==0 ){
-    pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db,TK_ASTERISK,0));
+    pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(pParse->db,TK_ASTERISK,0));
   }
   pNew->pEList = pEList;
   pNew->op = TK_SELECT;
@@ -116379,7 +117566,7 @@ SQLITE_PRIVATE Select *sqlite3SelectNew(
   pNew->addrOpenEphm[0] = -1;
   pNew->addrOpenEphm[1] = -1;
   pNew->nSelectRow = 0;
-  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(db, sizeof(*pSrc));
+  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));
   pNew->pSrc = pSrc;
   pNew->pWhere = pWhere;
   pNew->pGroupBy = pGroupBy;
@@ -116390,9 +117577,9 @@ SQLITE_PRIVATE Select *sqlite3SelectNew(
   pNew->pLimit = pLimit;
   pNew->pOffset = pOffset;
   pNew->pWith = 0;
-  assert( pOffset==0 || pLimit!=0 || pParse->nErr>0 || db->mallocFailed!=0 );
-  if( db->mallocFailed ) {
-    clearSelect(db, pNew, pNew!=&standin);
+  assert( pOffset==0 || pLimit!=0 || pParse->nErr>0 || pParse->db->mallocFailed!=0 );
+  if( pParse->db->mallocFailed ) {
+    clearSelect(pParse->db, pNew, pNew!=&standin);
     pNew = 0;
   }else{
     assert( pNew->pSrc!=0 || pParse->nErr>0 );
@@ -117279,7 +118466,7 @@ static void selectInnerLoop(
 ** X extra columns.
 */
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){
-  int nExtra = (N+X)*(sizeof(CollSeq*)+1);
+  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);
   KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);
   if( p ){
     p->aSortOrder = (u8*)&p->aColl[N+X];
@@ -117302,7 +118489,7 @@ SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo *p){
   if( p ){
     assert( p->nRef>0 );
     p->nRef--;
-    if( p->nRef==0 ) sqlite3DbFree(p->db, p);
+    if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);
   }
 }
 
@@ -117686,13 +118873,10 @@ static const char *columnTypeImpl(
         ** of the SELECT statement. Return the declaration type and origin
         ** data for the result-set column of the sub-select.
         */
-        if( iCol>=0 && ALWAYS(iCol<pS->pEList->nExpr) ){
+        if( iCol>=0 && iCol<pS->pEList->nExpr ){
           /* If iCol is less than zero, then the expression requests the
           ** rowid of the sub-select or view. This expression is legal (see 
           ** test case misc2.2.2) - it always evaluates to NULL.
-          **
-          ** The ALWAYS() is because iCol>=pS->pEList->nExpr will have been
-          ** caught already by name resolution.
           */
           NameContext sNC;
           Expr *p = pS->pEList->a[iCol].pExpr;
@@ -117777,6 +118961,7 @@ static void generateColumnTypes(
   NameContext sNC;
   sNC.pSrcList = pTabList;
   sNC.pParse = pParse;
+  sNC.pNext = 0;
   for(i=0; i<pEList->nExpr; i++){
     Expr *p = pEList->a[i].pExpr;
     const char *zType;
@@ -117801,20 +118986,49 @@ static void generateColumnTypes(
 #endif /* !defined(SQLITE_OMIT_DECLTYPE) */
 }
 
+
 /*
-** Generate code that will tell the VDBE the names of columns
-** in the result set.  This information is used to provide the
-** azCol[] values in the callback.
+** Compute the column names for a SELECT statement.
+**
+** The only guarantee that SQLite makes about column names is that if the
+** column has an AS clause assigning it a name, that will be the name used.
+** That is the only documented guarantee.  However, countless applications
+** developed over the years have made baseless assumptions about column names
+** and will break if those assumptions changes.  Hence, use extreme caution
+** when modifying this routine to avoid breaking legacy.
+**
+** See Also: sqlite3ColumnsFromExprList()
+**
+** The PRAGMA short_column_names and PRAGMA full_column_names settings are
+** deprecated.  The default setting is short=ON, full=OFF.  99.9% of all
+** applications should operate this way.  Nevertheless, we need to support the
+** other modes for legacy:
+**
+**    short=OFF, full=OFF:      Column name is the text of the expression has it
+**                              originally appears in the SELECT statement.  In
+**                              other words, the zSpan of the result expression.
+**
+**    short=ON, full=OFF:       (This is the default setting).  If the result
+**                              refers directly to a table column, then the result
+**                              column name is just the table column name: COLUMN. 
+**                              Otherwise use zSpan.
+**
+**    full=ON, short=ANY:       If the result refers directly to a table column,
+**                              then the result column name with the table name
+**                              prefix, ex: TABLE.COLUMN.  Otherwise use zSpan.
 */
 static void generateColumnNames(
   Parse *pParse,      /* Parser context */
-  SrcList *pTabList,  /* List of tables */
-  ExprList *pEList    /* Expressions defining the result set */
+  Select *pSelect     /* Generate column names for this SELECT statement */
 ){
   Vdbe *v = pParse->pVdbe;
-  int i, j;
+  int i;
+  Table *pTab;
+  SrcList *pTabList;
+  ExprList *pEList;
   sqlite3 *db = pParse->db;
-  int fullNames, shortNames;
+  int fullName;    /* TABLE.COLUMN if no AS clause and is a direct table ref */
+  int srcName;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */
 
 #ifndef SQLITE_OMIT_EXPLAIN
   /* If this is an EXPLAIN, skip this step */
@@ -117824,28 +119038,29 @@ static void generateColumnNames(
 #endif
 
   if( pParse->colNamesSet || db->mallocFailed ) return;
+  /* Column names are determined by the left-most term of a compound select */
+  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
+  pTabList = pSelect->pSrc;
+  pEList = pSelect->pEList;
   assert( v!=0 );
   assert( pTabList!=0 );
   pParse->colNamesSet = 1;
-  fullNames = (db->flags & SQLITE_FullColNames)!=0;
-  shortNames = (db->flags & SQLITE_ShortColNames)!=0;
+  fullName = (db->flags & SQLITE_FullColNames)!=0;
+  srcName = (db->flags & SQLITE_ShortColNames)!=0 || fullName;
   sqlite3VdbeSetNumCols(v, pEList->nExpr);
   for(i=0; i<pEList->nExpr; i++){
-    Expr *p;
-    p = pEList->a[i].pExpr;
-    if( NEVER(p==0) ) continue;
+    Expr *p = pEList->a[i].pExpr;
+
+    assert( p!=0 );
     if( pEList->a[i].zName ){
+      /* An AS clause always takes first priority */
       char *zName = pEList->a[i].zName;
       sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);
-    }else if( p->op==TK_COLUMN || p->op==TK_AGG_COLUMN ){
-      Table *pTab;
+    }else if( srcName && p->op==TK_COLUMN ){
       char *zCol;
       int iCol = p->iColumn;
-      for(j=0; ALWAYS(j<pTabList->nSrc); j++){
-        if( pTabList->a[j].iCursor==p->iTable ) break;
-      }
-      assert( j<pTabList->nSrc );
-      pTab = pTabList->a[j].pTab;
+      pTab = p->pTab;
+      assert( pTab!=0 );
       if( iCol<0 ) iCol = pTab->iPKey;
       assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );
       if( iCol<0 ){
@@ -117853,10 +119068,7 @@ static void generateColumnNames(
       }else{
         zCol = pTab->aCol[iCol].zName;
       }
-      if( !shortNames && !fullNames ){
-        sqlite3VdbeSetColName(v, i, COLNAME_NAME, 
-            sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);
-      }else if( fullNames ){
+      if( fullName ){
         char *zName = 0;
         zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
@@ -117884,6 +119096,15 @@ static void generateColumnNames(
 **
 ** Return SQLITE_OK on success.  If a memory allocation error occurs,
 ** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.
+**
+** The only guarantee that SQLite makes about column names is that if the
+** column has an AS clause assigning it a name, that will be the name used.
+** That is the only documented guarantee.  However, countless applications
+** developed over the years have made baseless assumptions about column names
+** and will break if those assumptions changes.  Hence, use extreme caution
+** when modifying this routine to avoid breaking legacy.
+**
+** See Also: generateColumnNames()
 */
 SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
   Parse *pParse,          /* Parsing context */
@@ -117896,7 +119117,6 @@ SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
   u32 cnt;                    /* Index added to make the name unique */
   Column *aCol, *pCol;        /* For looping over result columns */
   int nCol;                   /* Number of columns in the result set */
-  Expr *p;                    /* Expression for a single result column */
   char *zName;                /* Column name */
   int nName;                  /* Size of name in zName[] */
   Hash ht;                    /* Hash table of column names */
@@ -117917,20 +119137,18 @@ SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
   for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){
     /* Get an appropriate name for the column
     */
-    p = sqlite3ExprSkipCollate(pEList->a[i].pExpr);
     if( (zName = pEList->a[i].zName)!=0 ){
       /* If the column contains an "AS <name>" phrase, use <name> as the name */
     }else{
-      Expr *pColExpr = p;  /* The expression that is the result column name */
-      Table *pTab;         /* Table associated with this expression */
+      Expr *pColExpr = sqlite3ExprSkipCollate(pEList->a[i].pExpr);
       while( pColExpr->op==TK_DOT ){
         pColExpr = pColExpr->pRight;
         assert( pColExpr!=0 );
       }
-      if( pColExpr->op==TK_COLUMN && ALWAYS(pColExpr->pTab!=0) ){
+      if( pColExpr->op==TK_COLUMN && pColExpr->pTab!=0 ){
         /* For columns use the column name name */
         int iCol = pColExpr->iColumn;
-        pTab = pColExpr->pTab;
+        Table *pTab = pColExpr->pTab;
         if( iCol<0 ) iCol = pTab->iPKey;
         zName = iCol>=0 ? pTab->aCol[iCol].zName : "rowid";
       }else if( pColExpr->op==TK_ID ){
@@ -117941,7 +119159,11 @@ SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
         zName = pEList->a[i].zSpan;
       }
     }
-    zName = sqlite3MPrintf(db, "%s", zName);
+    if( zName ){
+      zName = sqlite3DbStrDup(db, zName);
+    }else{
+      zName = sqlite3MPrintf(db,"column%d",i+1);
+    }
 
     /* Make sure the column name is unique.  If the name is not unique,
     ** append an integer to the name so that it becomes unique.
@@ -118670,11 +119892,6 @@ static int multiSelect(
       if( dest.eDest!=priorOp ){
         int iCont, iBreak, iStart;
         assert( p->pEList );
-        if( dest.eDest==SRT_Output ){
-          Select *pFirst = p;
-          while( pFirst->pPrior ) pFirst = pFirst->pPrior;
-          generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
-        }
         iBreak = sqlite3VdbeMakeLabel(v);
         iCont = sqlite3VdbeMakeLabel(v);
         computeLimitRegisters(pParse, p, iBreak);
@@ -118745,11 +119962,6 @@ static int multiSelect(
       ** tables.
       */
       assert( p->pEList );
-      if( dest.eDest==SRT_Output ){
-        Select *pFirst = p;
-        while( pFirst->pPrior ) pFirst = pFirst->pPrior;
-        generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
-      }
       iBreak = sqlite3VdbeMakeLabel(v);
       iCont = sqlite3VdbeMakeLabel(v);
       computeLimitRegisters(pParse, p, iBreak);
@@ -119147,7 +120359,7 @@ static int multiSelectOrderBy(
         if( pNew==0 ) return SQLITE_NOMEM_BKPT;
         pNew->flags |= EP_IntValue;
         pNew->u.iValue = i;
-        pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
+        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
         if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;
       }
     }
@@ -119357,14 +120569,6 @@ static int multiSelectOrderBy(
   */
   sqlite3VdbeResolveLabel(v, labelEnd);
 
-  /* Set the number of output columns
-  */
-  if( pDest->eDest==SRT_Output ){
-    Select *pFirst = pPrior;
-    while( pFirst->pPrior ) pFirst = pFirst->pPrior;
-    generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
-  }
-
   /* Reassembly the compound query so that it will be freed correctly
   ** by the calling function */
   if( p->pPrior ){
@@ -119381,9 +120585,24 @@ static int multiSelectOrderBy(
 #endif
 
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
+
+/* An instance of the SubstContext object describes an substitution edit
+** to be performed on a parse tree.
+**
+** All references to columns in table iTable are to be replaced by corresponding
+** expressions in pEList.
+*/
+typedef struct SubstContext {
+  Parse *pParse;            /* The parsing context */
+  int iTable;               /* Replace references to this table */
+  int iNewTable;            /* New table number */
+  int isLeftJoin;           /* Add TK_IF_NULL_ROW opcodes on each replacement */
+  ExprList *pEList;         /* Replacement expressions */
+} SubstContext;
+
 /* Forward Declarations */
-static void substExprList(Parse*, ExprList*, int, ExprList*);
-static void substSelect(Parse*, Select *, int, ExprList*, int);
+static void substExprList(SubstContext*, ExprList*);
+static void substSelect(SubstContext*, Select*, int);
 
 /*
 ** Scan through the expression pExpr.  Replace every reference to
@@ -119394,84 +120613,95 @@ static void substSelect(Parse*, Select *, int, ExprList*, int);
 ** This routine is part of the flattening procedure.  A subquery
 ** whose result set is defined by pEList appears as entry in the
 ** FROM clause of a SELECT such that the VDBE cursor assigned to that
-** FORM clause entry is iTable.  This routine make the necessary 
+** FORM clause entry is iTable.  This routine makes the necessary 
 ** changes to pExpr so that it refers directly to the source table
 ** of the subquery rather the result set of the subquery.
 */
 static Expr *substExpr(
-  Parse *pParse,      /* Report errors here */
-  Expr *pExpr,        /* Expr in which substitution occurs */
-  int iTable,         /* Table to be substituted */
-  ExprList *pEList    /* Substitute expressions */
+  SubstContext *pSubst,  /* Description of the substitution */
+  Expr *pExpr            /* Expr in which substitution occurs */
 ){
-  sqlite3 *db = pParse->db;
   if( pExpr==0 ) return 0;
-  if( pExpr->op==TK_COLUMN && pExpr->iTable==iTable ){
+  if( ExprHasProperty(pExpr, EP_FromJoin) && pExpr->iRightJoinTable==pSubst->iTable ){
+    pExpr->iRightJoinTable = pSubst->iNewTable;
+  }
+  if( pExpr->op==TK_COLUMN && pExpr->iTable==pSubst->iTable ){
     if( pExpr->iColumn<0 ){
       pExpr->op = TK_NULL;
     }else{
       Expr *pNew;
-      Expr *pCopy = pEList->a[pExpr->iColumn].pExpr;
-      assert( pEList!=0 && pExpr->iColumn<pEList->nExpr );
+      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;
+      Expr ifNullRow;
+      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );
       assert( pExpr->pLeft==0 && pExpr->pRight==0 );
       if( sqlite3ExprIsVector(pCopy) ){
-        sqlite3VectorErrorMsg(pParse, pCopy);
+        sqlite3VectorErrorMsg(pSubst->pParse, pCopy);
       }else{
+        sqlite3 *db = pSubst->pParse->db;
+        if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){
+          memset(&ifNullRow, 0, sizeof(ifNullRow));
+          ifNullRow.op = TK_IF_NULL_ROW;
+          ifNullRow.pLeft = pCopy;
+          ifNullRow.iTable = pSubst->iNewTable;
+          pCopy = &ifNullRow;
+        }
         pNew = sqlite3ExprDup(db, pCopy, 0);
-        if( pNew && (pExpr->flags & EP_FromJoin) ){
+        if( pNew && pSubst->isLeftJoin ){
+          ExprSetProperty(pNew, EP_CanBeNull);
+        }
+        if( pNew && ExprHasProperty(pExpr,EP_FromJoin) ){
           pNew->iRightJoinTable = pExpr->iRightJoinTable;
-          pNew->flags |= EP_FromJoin;
+          ExprSetProperty(pNew, EP_FromJoin);
         }
         sqlite3ExprDelete(db, pExpr);
         pExpr = pNew;
       }
     }
   }else{
-    pExpr->pLeft = substExpr(pParse, pExpr->pLeft, iTable, pEList);
-    pExpr->pRight = substExpr(pParse, pExpr->pRight, iTable, pEList);
+    if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){
+      pExpr->iTable = pSubst->iNewTable;
+    }
+    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
+    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
     if( ExprHasProperty(pExpr, EP_xIsSelect) ){
-      substSelect(pParse, pExpr->x.pSelect, iTable, pEList, 1);
+      substSelect(pSubst, pExpr->x.pSelect, 1);
     }else{
-      substExprList(pParse, pExpr->x.pList, iTable, pEList);
+      substExprList(pSubst, pExpr->x.pList);
     }
   }
   return pExpr;
 }
 static void substExprList(
-  Parse *pParse,       /* Report errors here */
-  ExprList *pList,     /* List to scan and in which to make substitutes */
-  int iTable,          /* Table to be substituted */
-  ExprList *pEList     /* Substitute values */
+  SubstContext *pSubst, /* Description of the substitution */
+  ExprList *pList       /* List to scan and in which to make substitutes */
 ){
   int i;
   if( pList==0 ) return;
   for(i=0; i<pList->nExpr; i++){
-    pList->a[i].pExpr = substExpr(pParse, pList->a[i].pExpr, iTable, pEList);
+    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
   }
 }
 static void substSelect(
-  Parse *pParse,       /* Report errors here */
-  Select *p,           /* SELECT statement in which to make substitutions */
-  int iTable,          /* Table to be replaced */
-  ExprList *pEList,    /* Substitute values */
-  int doPrior          /* Do substitutes on p->pPrior too */
+  SubstContext *pSubst, /* Description of the substitution */
+  Select *p,            /* SELECT statement in which to make substitutions */
+  int doPrior           /* Do substitutes on p->pPrior too */
 ){
   SrcList *pSrc;
   struct SrcList_item *pItem;
   int i;
   if( !p ) return;
   do{
-    substExprList(pParse, p->pEList, iTable, pEList);
-    substExprList(pParse, p->pGroupBy, iTable, pEList);
-    substExprList(pParse, p->pOrderBy, iTable, pEList);
-    p->pHaving = substExpr(pParse, p->pHaving, iTable, pEList);
-    p->pWhere = substExpr(pParse, p->pWhere, iTable, pEList);
+    substExprList(pSubst, p->pEList);
+    substExprList(pSubst, p->pGroupBy);
+    substExprList(pSubst, p->pOrderBy);
+    p->pHaving = substExpr(pSubst, p->pHaving);
+    p->pWhere = substExpr(pSubst, p->pWhere);
     pSrc = p->pSrc;
     assert( pSrc!=0 );
     for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
-      substSelect(pParse, pItem->pSelect, iTable, pEList, 1);
+      substSelect(pSubst, pItem->pSelect, 1);
       if( pItem->fg.isTabFunc ){
-        substExprList(pParse, pItem->u1.pFuncArg, iTable, pEList);
+        substExprList(pSubst, pItem->u1.pFuncArg);
       }
     }
   }while( doPrior && (p = p->pPrior)!=0 );
@@ -119514,8 +120744,10 @@ static void substSelect(
 **        FROM-clause subquery that is a candidate for flattening.  (2b is
 **        due to ticket [2f7170d73bf9abf80] from 2015-02-09.)
 **
-**   (3)  The subquery is not the right operand of a left outer join
-**        (Originally ticket #306.  Strengthened by ticket #3300)
+**   (3)  The subquery is not the right operand of a LEFT JOIN
+**        or (a) the subquery is not itself a join and (b) the FROM clause
+**        of the subquery does not contain a virtual table and (c) the 
+**        outer query is not an aggregate.
 **
 **   (4)  The subquery is not DISTINCT.
 **
@@ -119527,7 +120759,7 @@ static void substSelect(
 **        DISTINCT.
 **
 **   (7)  The subquery has a FROM clause.  TODO:  For subqueries without
-**        A FROM clause, consider adding a FROM close with the special
+**        A FROM clause, consider adding a FROM clause with the special
 **        table sqlite_once that consists of a single row containing a
 **        single NULL.
 **
@@ -119631,8 +120863,9 @@ static int flattenSubquery(
   Select *pSub1;      /* Pointer to the rightmost select in sub-query */
   SrcList *pSrc;      /* The FROM clause of the outer query */
   SrcList *pSubSrc;   /* The FROM clause of the subquery */
-  ExprList *pList;    /* The result set of the outer query */
   int iParent;        /* VDBE cursor number of the pSub result set temp table */
+  int iNewParent = -1;/* Replacement table for iParent */
+  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    
   int i;              /* Loop counter */
   Expr *pWhere;                    /* The WHERE clause */
   struct SrcList_item *pSubitem;   /* The subquery */
@@ -119659,7 +120892,7 @@ static int flattenSubquery(
       return 0;                                          /* Restriction (2b)  */
     }
   }
-    
+
   pSubSrc = pSub->pSrc;
   assert( pSubSrc );
   /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,
@@ -119697,10 +120930,9 @@ static int flattenSubquery(
     return 0; /* Restriction (23) */
   }
 
-  /* OBSOLETE COMMENT 1:
-  ** Restriction 3:  If the subquery is a join, make sure the subquery is 
-  ** not used as the right operand of an outer join.  Examples of why this
-  ** is not allowed:
+  /*
+  ** If the subquery is the right operand of a LEFT JOIN, then the
+  ** subquery may not be a join itself.  Example of why this is not allowed:
   **
   **         t1 LEFT OUTER JOIN (t2 JOIN t3)
   **
@@ -119710,28 +120942,27 @@ static int flattenSubquery(
   **
   ** which is not at all the same thing.
   **
-  ** OBSOLETE COMMENT 2:
-  ** Restriction 12:  If the subquery is the right operand of a left outer
-  ** join, make sure the subquery has no WHERE clause.
-  ** An examples of why this is not allowed:
-  **
-  **         t1 LEFT OUTER JOIN (SELECT * FROM t2 WHERE t2.x>0)
-  **
-  ** If we flatten the above, we would get
-  **
-  **         (t1 LEFT OUTER JOIN t2) WHERE t2.x>0
-  **
-  ** But the t2.x>0 test will always fail on a NULL row of t2, which
-  ** effectively converts the OUTER JOIN into an INNER JOIN.
+  ** If the subquery is the right operand of a LEFT JOIN, then the outer
+  ** query cannot be an aggregate.  This is an artifact of the way aggregates
+  ** are processed - there is no mechanism to determine if the LEFT JOIN
+  ** table should be all-NULL.
   **
-  ** THIS OVERRIDES OBSOLETE COMMENTS 1 AND 2 ABOVE:
-  ** Ticket #3300 shows that flattening the right term of a LEFT JOIN
-  ** is fraught with danger.  Best to avoid the whole thing.  If the
-  ** subquery is the right term of a LEFT JOIN, then do not flatten.
+  ** See also tickets #306, #350, and #3300.
   */
   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
-    return 0;
+    isLeftJoin = 1;
+    if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){
+      return 0; /* Restriction (3) */
+    }
   }
+#ifdef SQLITE_EXTRA_IFNULLROW
+  else if( iFrom>0 && !isAgg ){
+    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for
+    ** every reference to any result column from subquery in a join, even though
+    ** they are not necessary.  This will stress-test the OP_IfNullRow opcode. */
+    isLeftJoin = -1;
+  }
+#endif
 
   /* Restriction 17: If the sub-query is a compound SELECT, then it must
   ** use only the UNION ALL operator. And none of the simple select queries
@@ -119939,6 +121170,7 @@ static int flattenSubquery(
       sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
       assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );
       pSrc->a[i+iFrom] = pSubSrc->a[i];
+      iNewParent = pSubSrc->a[i].iCursor;
       memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
     }
     pSrc->a[iFrom].fg.jointype = jointype;
@@ -119955,14 +121187,6 @@ static int flattenSubquery(
     ** We look at every expression in the outer query and every place we see
     ** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".
     */
-    pList = pParent->pEList;
-    for(i=0; i<pList->nExpr; i++){
-      if( pList->a[i].zName==0 ){
-        char *zName = sqlite3DbStrDup(db, pList->a[i].zSpan);
-        sqlite3Dequote(zName);
-        pList->a[i].zName = zName;
-      }
-    }
     if( pSub->pOrderBy ){
       /* At this point, any non-zero iOrderByCol values indicate that the
       ** ORDER BY column expression is identical to the iOrderByCol'th
@@ -119984,6 +121208,9 @@ static int flattenSubquery(
       pSub->pOrderBy = 0;
     }
     pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);
+    if( isLeftJoin>0 ){
+      setJoinExpr(pWhere, iNewParent);
+    }
     if( subqueryIsAgg ){
       assert( pParent->pHaving==0 );
       pParent->pHaving = pParent->pWhere;
@@ -119997,7 +121224,13 @@ static int flattenSubquery(
       pParent->pWhere = sqlite3ExprAnd(db, pWhere, pParent->pWhere);
     }
     if( db->mallocFailed==0 ){
-      substSelect(pParse, pParent, iParent, pSub->pEList, 0);
+      SubstContext x;
+      x.pParse = pParse;
+      x.iTable = iParent;
+      x.iNewTable = iNewParent;
+      x.isLeftJoin = isLeftJoin;
+      x.pEList = pSub->pEList;
+      substSelect(&x, pParent, 0);
     }
   
     /* The flattened query is distinct if either the inner or the
@@ -120100,8 +121333,14 @@ static int pushDownWhereTerms(
   if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){
     nChng++;
     while( pSubq ){
+      SubstContext x;
       pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
-      pNew = substExpr(pParse, pNew, iCursor, pSubq->pEList);
+      x.pParse = pParse;
+      x.iTable = iCursor;
+      x.iNewTable = iCursor;
+      x.isLeftJoin = 0;
+      x.pEList = pSubq->pEList;
+      pNew = substExpr(&x, pNew);
       pSubq->pWhere = sqlite3ExprAnd(pParse->db, pSubq->pWhere, pNew);
       pSubq = pSubq->pPrior;
     }
@@ -120807,6 +122046,25 @@ SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
   return WRC_Continue;
 }
 
+/*
+** No-op routine for the parse-tree walker for SELECT statements.
+** subquery in the parser tree.
+*/
+SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){
+  UNUSED_PARAMETER2(NotUsed, NotUsed2);
+  return WRC_Continue;
+}
+
+#if SQLITE_DEBUG
+/*
+** Always assert.  This xSelectCallback2 implementation proves that the
+** xSelectCallback2 is never invoked.
+*/
+SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker *NotUsed, Select *NotUsed2){
+  UNUSED_PARAMETER2(NotUsed, NotUsed2);
+  assert( 0 );
+}
+#endif
 /*
 ** This routine "expands" a SELECT statement and all of its subqueries.
 ** For additional information on what it means to "expand" a SELECT
@@ -120822,11 +122080,11 @@ SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
 */
 static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
   Walker w;
-  memset(&w, 0, sizeof(w));
   w.xExprCallback = sqlite3ExprWalkNoop;
   w.pParse = pParse;
   if( pParse->hasCompound ){
     w.xSelectCallback = convertCompoundSelectToSubquery;
+    w.xSelectCallback2 = 0;
     sqlite3WalkSelect(&w, pSelect);
   }
   w.xSelectCallback = selectExpander;
@@ -120886,7 +122144,7 @@ static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
 static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){
 #ifndef SQLITE_OMIT_SUBQUERY
   Walker w;
-  memset(&w, 0, sizeof(w));
+  w.xSelectCallback = sqlite3SelectWalkNoop;
   w.xSelectCallback2 = selectAddSubqueryTypeInfo;
   w.xExprCallback = sqlite3ExprWalkNoop;
   w.pParse = pParse;
@@ -121093,6 +122351,187 @@ static void explainSimpleCount(
 # define explainSimpleCount(a,b,c)
 #endif
 
+/*
+** Context object for havingToWhereExprCb().
+*/
+struct HavingToWhereCtx {
+  Expr **ppWhere;
+  ExprList *pGroupBy;
+};
+
+/*
+** sqlite3WalkExpr() callback used by havingToWhere().
+**
+** If the node passed to the callback is a TK_AND node, return 
+** WRC_Continue to tell sqlite3WalkExpr() to iterate through child nodes.
+**
+** Otherwise, return WRC_Prune. In this case, also check if the 
+** sub-expression matches the criteria for being moved to the WHERE
+** clause. If so, add it to the WHERE clause and replace the sub-expression
+** within the HAVING expression with a constant "1".
+*/
+static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
+  if( pExpr->op!=TK_AND ){
+    struct HavingToWhereCtx *p = pWalker->u.pHavingCtx;
+    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, p->pGroupBy) ){
+      sqlite3 *db = pWalker->pParse->db;
+      Expr *pNew = sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[1], 0);
+      if( pNew ){
+        Expr *pWhere = *(p->ppWhere);
+        SWAP(Expr, *pNew, *pExpr);
+        pNew = sqlite3ExprAnd(db, pWhere, pNew);
+        *(p->ppWhere) = pNew;
+      }
+    }
+    return WRC_Prune;
+  }
+  return WRC_Continue;
+}
+
+/*
+** Transfer eligible terms from the HAVING clause of a query, which is
+** processed after grouping, to the WHERE clause, which is processed before
+** grouping. For example, the query:
+**
+**   SELECT * FROM <tables> WHERE a=? GROUP BY b HAVING b=? AND c=?
+**
+** can be rewritten as:
+**
+**   SELECT * FROM <tables> WHERE a=? AND b=? GROUP BY b HAVING c=?
+**
+** A term of the HAVING expression is eligible for transfer if it consists
+** entirely of constants and expressions that are also GROUP BY terms that
+** use the "BINARY" collation sequence.
+*/
+static void havingToWhere(
+  Parse *pParse,
+  ExprList *pGroupBy,
+  Expr *pHaving, 
+  Expr **ppWhere
+){
+  struct HavingToWhereCtx sCtx;
+  Walker sWalker;
+
+  sCtx.ppWhere = ppWhere;
+  sCtx.pGroupBy = pGroupBy;
+
+  memset(&sWalker, 0, sizeof(sWalker));
+  sWalker.pParse = pParse;
+  sWalker.xExprCallback = havingToWhereExprCb;
+  sWalker.u.pHavingCtx = &sCtx;
+  sqlite3WalkExpr(&sWalker, pHaving);
+}
+
+/*
+** Check to see if the pThis entry of pTabList is a self-join of a prior view.
+** If it is, then return the SrcList_item for the prior view.  If it is not,
+** then return 0.
+*/
+static struct SrcList_item *isSelfJoinView(
+  SrcList *pTabList,           /* Search for self-joins in this FROM clause */
+  struct SrcList_item *pThis   /* Search for prior reference to this subquery */
+){
+  struct SrcList_item *pItem;
+  for(pItem = pTabList->a; pItem<pThis; pItem++){
+    if( pItem->pSelect==0 ) continue;
+    if( pItem->fg.viaCoroutine ) continue;
+    if( pItem->zName==0 ) continue;
+    if( sqlite3_stricmp(pItem->zDatabase, pThis->zDatabase)!=0 ) continue;
+    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;
+    if( sqlite3ExprCompare(0, 
+          pThis->pSelect->pWhere, pItem->pSelect->pWhere, -1) 
+    ){
+      /* The view was modified by some other optimization such as
+      ** pushDownWhereTerms() */
+      continue;
+    }
+    return pItem;
+  }
+  return 0;
+}
+
+#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
+/*
+** Attempt to transform a query of the form
+**
+**    SELECT count(*) FROM (SELECT x FROM t1 UNION ALL SELECT y FROM t2)
+**
+** Into this:
+**
+**    SELECT (SELECT count(*) FROM t1)+(SELECT count(*) FROM t2)
+**
+** The transformation only works if all of the following are true:
+**
+**   *  The subquery is a UNION ALL of two or more terms
+**   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries
+**   *  The outer query is a simple count(*)
+**
+** Return TRUE if the optimization is undertaken.
+*/
+static int countOfViewOptimization(Parse *pParse, Select *p){
+  Select *pSub, *pPrior;
+  Expr *pExpr;
+  Expr *pCount;
+  sqlite3 *db;
+  if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate query */
+  if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */
+  pExpr = p->pEList->a[0].pExpr;
+  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */
+  if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  /* Must be count() */
+  if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */
+  if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in the FROM clause */
+  pSub = p->pSrc->a[0].pSelect;
+  if( pSub==0 ) return 0;                           /* The FROM is a subquery */
+  if( pSub->pPrior==0 ) return 0;                   /* Must be a compound subquery */
+  do{
+    if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  /* Must be UNION ALL */
+    if( pSub->pWhere ) return 0;                      /* No WHERE clause */
+    if( pSub->selFlags & SF_Aggregate ) return 0;     /* Not an aggregate */
+    pSub = pSub->pPrior;                              /* Repeat over compound terms */
+  }while( pSub );
+
+  /* If we reach this point, that means it is OK to perform the transformation */
+
+  db = pParse->db;
+  pCount = pExpr;
+  pExpr = 0;
+  pSub = p->pSrc->a[0].pSelect;
+  p->pSrc->a[0].pSelect = 0;
+  sqlite3SrcListDelete(db, p->pSrc);
+  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));
+  while( pSub ){
+    Expr *pTerm;
+    pPrior = pSub->pPrior;
+    pSub->pPrior = 0;
+    pSub->pNext = 0;
+    pSub->selFlags |= SF_Aggregate;
+    pSub->selFlags &= ~SF_Compound;
+    pSub->nSelectRow = 0;
+    sqlite3ExprListDelete(db, pSub->pEList);
+    pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;
+    pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);
+    pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
+    sqlite3PExprAddSelect(pParse, pTerm, pSub);
+    if( pExpr==0 ){
+      pExpr = pTerm;
+    }else{
+      pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);
+    }
+    pSub = pPrior;
+  }
+  p->pEList->a[0].pExpr = pExpr;
+  p->selFlags &= ~SF_Aggregate;
+
+#if SELECTTRACE_ENABLED
+  if( sqlite3SelectTrace & 0x400 ){
+    SELECTTRACE(0x400,pParse,p,("After count-of-view optimization:\n"));
+    sqlite3TreeViewSelect(0, p, 0);
+  }
+#endif
+  return 1;
+}
+#endif /* SQLITE_COUNTOFVIEW_OPTIMIZATION */
+
 /*
 ** Generate code for the SELECT statement given in the p argument.  
 **
@@ -121177,6 +122616,14 @@ SQLITE_PRIVATE int sqlite3Select(
   }
 #endif
 
+  /* Get a pointer the VDBE under construction, allocating a new VDBE if one
+  ** does not already exist */
+  v = sqlite3GetVdbe(pParse);
+  if( v==0 ) goto select_end;
+  if( pDest->eDest==SRT_Output ){
+    generateColumnNames(pParse, p);
+  }
+
   /* Try to flatten subqueries in the FROM clause up into the main query
   */
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
@@ -121212,11 +122659,6 @@ SQLITE_PRIVATE int sqlite3Select(
   }
 #endif
 
-  /* Get a pointer the VDBE under construction, allocating a new VDBE if one
-  ** does not already exist */
-  v = sqlite3GetVdbe(pParse);
-  if( v==0 ) goto select_end;
-
 #ifndef SQLITE_OMIT_COMPOUND_SELECT
   /* Handle compound SELECT statements using the separate multiSelect()
   ** procedure.
@@ -121232,13 +122674,38 @@ SQLITE_PRIVATE int sqlite3Select(
   }
 #endif
 
-  /* Generate code for all sub-queries in the FROM clause
+  /* For each term in the FROM clause, do two things:
+  ** (1) Authorized unreferenced tables
+  ** (2) Generate code for all sub-queries
   */
-#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
   for(i=0; i<pTabList->nSrc; i++){
     struct SrcList_item *pItem = &pTabList->a[i];
     SelectDest dest;
-    Select *pSub = pItem->pSelect;
+    Select *pSub;
+
+    /* Issue SQLITE_READ authorizations with a fake column name for any tables that
+    ** are referenced but from which no values are extracted. Examples of where these
+    ** kinds of null SQLITE_READ authorizations would occur:
+    **
+    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.""
+    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.""
+    **
+    ** The fake column name is an empty string.  It is possible for a table to
+    ** have a column named by the empty string, in which case there is no way to
+    ** distinguish between an unreferenced table and an actual reference to the
+    ** "" column.  The original design was for the fake column name to be a NULL,
+    ** which would be unambiguous.  But legacy authorization callbacks might
+    ** assume the column name is non-NULL and segfault.  The use of an empty string
+    ** for the fake column name seems safer.
+    */
+    if( pItem->colUsed==0 ){
+      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, "", pItem->zDatabase);
+    }
+
+#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
+    /* Generate code for all sub-queries in the FROM clause
+    */
+    pSub = pItem->pSelect;
     if( pSub==0 ) continue;
 
     /* Sometimes the code for a subquery will be generated more than
@@ -121249,6 +122716,10 @@ SQLITE_PRIVATE int sqlite3Select(
     ** to be invoked again. */
     if( pItem->addrFillSub ){
       if( pItem->fg.viaCoroutine==0 ){
+        /* The subroutine that manifests the view might be a one-time routine,
+        ** or it might need to be rerun on each iteration because it
+        ** encodes a correlated subquery. */
+        testcase( sqlite3VdbeGetOp(v, pItem->addrFillSub)->opcode==OP_Once );
         sqlite3VdbeAddOp2(v, OP_Gosub, pItem->regReturn, pItem->addrFillSub);
       }
       continue;
@@ -121323,6 +122794,8 @@ SQLITE_PRIVATE int sqlite3Select(
       int topAddr;
       int onceAddr = 0;
       int retAddr;
+      struct SrcList_item *pPrior;
+
       assert( pItem->addrFillSub==0 );
       pItem->regReturn = ++pParse->nMem;
       topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
@@ -121336,9 +122809,17 @@ SQLITE_PRIVATE int sqlite3Select(
       }else{
         VdbeNoopComment((v, "materialize \"%s\"", pItem->pTab->zName));
       }
-      sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);
-      explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);
-      sqlite3Select(pParse, pSub, &dest);
+      pPrior = isSelfJoinView(pTabList, pItem);
+      if( pPrior ){
+        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);
+        explainSetInteger(pItem->iSelectId, pPrior->iSelectId);
+        assert( pPrior->pSelect!=0 );
+        pSub->nSelectRow = pPrior->pSelect->nSelectRow;
+      }else{
+        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);
+        explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);
+        sqlite3Select(pParse, pSub, &dest);
+      }
       pItem->pTab->nRowLogEst = pSub->nSelectRow;
       if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);
       retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);
@@ -121348,8 +122829,8 @@ SQLITE_PRIVATE int sqlite3Select(
     }
     if( db->mallocFailed ) goto select_end;
     pParse->nHeight -= sqlite3SelectExprHeight(p);
-  }
 #endif
+  }
 
   /* Various elements of the SELECT copied into local variables for
   ** convenience */
@@ -121366,6 +122847,16 @@ SQLITE_PRIVATE int sqlite3Select(
   }
 #endif
 
+#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
+  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)
+   && countOfViewOptimization(pParse, p)
+  ){
+    if( db->mallocFailed ) goto select_end;
+    pEList = p->pEList;
+    pTabList = p->pSrc;
+  }
+#endif
+
   /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and 
   ** if the select-list is the same as the ORDER BY list, then this query
   ** can be rewritten as a GROUP BY. In other words, this:
@@ -121557,6 +123048,11 @@ SQLITE_PRIVATE int sqlite3Select(
     sqlite3ExprAnalyzeAggList(&sNC, pEList);
     sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
     if( pHaving ){
+      if( pGroupBy ){
+        assert( pWhere==p->pWhere );
+        havingToWhere(pParse, pGroupBy, pHaving, &p->pWhere);
+        pWhere = p->pWhere;
+      }
       sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
     }
     sAggInfo.nAccumulator = sAggInfo.nColumn;
@@ -121962,12 +123458,6 @@ SQLITE_PRIVATE int sqlite3Select(
 select_end:
   explainSetInteger(pParse->iSelectId, iRestoreSelectId);
 
-  /* Identify column names if results of the SELECT are to be output.
-  */
-  if( rc==SQLITE_OK && pDest->eDest==SRT_Output ){
-    generateColumnNames(pParse, pTabList, pEList);
-  }
-
   sqlite3DbFree(db, sAggInfo.aCol);
   sqlite3DbFree(db, sAggInfo.aFunc);
 #if SELECTTRACE_ENABLED
@@ -122488,6 +123978,7 @@ SQLITE_PRIVATE void sqlite3FinishTrigger(
     if( v==0 ) goto triggerfinish_cleanup;
     sqlite3BeginWriteOperation(pParse, 0, iDb);
     z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);
+    testcase( z==0 );
     sqlite3NestedParse(pParse,
        "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",
        db->aDb[iDb].zDbSName, MASTER_NAME, zName,
@@ -123569,7 +125060,7 @@ SQLITE_PRIVATE void sqlite3Update(
   */
   for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
     int reg;
-    if( chngKey || hasFK || pIdx->pPartIdxWhere || pIdx==pPk ){
+    if( chngKey || hasFK>1 || pIdx->pPartIdxWhere || pIdx==pPk ){
       reg = ++pParse->nMem;
       pParse->nMem += pIdx->nColumn;
     }else{
@@ -123924,7 +125415,7 @@ SQLITE_PRIVATE void sqlite3Update(
     assert( regNew==regNewRowid+1 );
 #ifdef SQLITE_ENABLE_PREUPDATE_HOOK
     sqlite3VdbeAddOp3(v, OP_Delete, iDataCur,
-        OPFLAG_ISUPDATE | ((hasFK || chngKey) ? 0 : OPFLAG_ISNOOP),
+        OPFLAG_ISUPDATE | ((hasFK>1 || chngKey) ? 0 : OPFLAG_ISNOOP),
         regNewRowid
     );
     if( eOnePass==ONEPASS_MULTI ){
@@ -123935,7 +125426,7 @@ SQLITE_PRIVATE void sqlite3Update(
       sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
     }
 #else
-    if( hasFK || chngKey ){
+    if( hasFK>1 || chngKey ){
       sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);
     }
 #endif
@@ -124355,7 +125846,7 @@ SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db, int iDb){
     extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);
     int nKey;
     char *zKey;
-    sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);
+    sqlite3CodecGetKey(db, iDb, (void**)&zKey, &nKey);
     if( nKey ) db->nextPagesize = 0;
   }
 #endif
@@ -125578,7 +127069,7 @@ SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(
   if( NEVER(pExpr==0) ) return pDef;
   if( pExpr->op!=TK_COLUMN ) return pDef;
   pTab = pExpr->pTab;
-  if( NEVER(pTab==0) ) return pDef;
+  if( pTab==0 ) return pDef;
   if( !IsVirtual(pTab) ) return pDef;
   pVtab = sqlite3GetVTable(db, pTab)->pVtab;
   assert( pVtab!=0 );
@@ -125913,6 +127404,7 @@ struct WhereLoop {
       u16 nEq;               /* Number of equality constraints */
       u16 nBtm;              /* Size of BTM vector */
       u16 nTop;              /* Size of TOP vector */
+      u16 nIdxCol;           /* Index column used for ORDER BY */
       Index *pIndex;         /* Index used, or NULL */
     } btree;
     struct {               /* Information for virtual tables */
@@ -126072,6 +127564,7 @@ struct WhereTerm {
 #define TERM_LIKECOND   0x200  /* Conditionally this LIKE operator term */
 #define TERM_LIKE       0x400  /* The original LIKE operator */
 #define TERM_IS         0x800  /* Term.pExpr is an IS operator */
+#define TERM_VARSELECT  0x1000 /* Term.pExpr contains a correlated sub-query */
 
 /*
 ** An instance of the WhereScan object is used as an iterator for locating
@@ -126161,6 +127654,7 @@ struct WhereAndInfo {
 ** no gaps.
 */
 struct WhereMaskSet {
+  int bVarSelect;               /* Used by sqlite3WhereExprUsage() */
   int n;                        /* Number of assigned cursor values */
   int ix[BMS];                  /* Cursor assigned to each bit */
 };
@@ -126206,6 +127700,7 @@ struct WhereInfo {
   SrcList *pTabList;        /* List of tables in the join */
   ExprList *pOrderBy;       /* The ORDER BY clause or NULL */
   ExprList *pResultSet;     /* Result set of the query */
+  Expr *pWhere;             /* The complete WHERE clause */
   LogEst iLimit;            /* LIMIT if wctrlFlags has WHERE_USE_LIMIT */
   int aiCurOnePass[2];      /* OP_OpenWrite cursors for the ONEPASS opt */
   int iContinue;            /* Jump here to continue with next record */
@@ -127293,10 +128788,10 @@ static void codeCursorHint(
 **
 ** Normally, this is just:
 **
-**   OP_Seek $iCur $iRowid
+**   OP_DeferredSeek $iCur $iRowid
 **
 ** However, if the scan currently being coded is a branch of an OR-loop and
-** the statement currently being coded is a SELECT, then P3 of the OP_Seek
+** the statement currently being coded is a SELECT, then P3 of OP_DeferredSeek
 ** is set to iIdxCur and P4 is set to point to an array of integers
 ** containing one entry for each column of the table cursor iCur is open 
 ** on. For each table column, if the column is the i'th column of the 
@@ -127315,7 +128810,7 @@ static void codeDeferredSeek(
   assert( iIdxCur>0 );
   assert( pIdx->aiColumn[pIdx->nColumn-1]==-1 );
   
-  sqlite3VdbeAddOp3(v, OP_Seek, iIdxCur, 0, iCur);
+  sqlite3VdbeAddOp3(v, OP_DeferredSeek, iIdxCur, 0, iCur);
   if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)
    && DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)
   ){
@@ -127366,6 +128861,69 @@ static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){
   }
 }
 
+/* An instance of the IdxExprTrans object carries information about a
+** mapping from an expression on table columns into a column in an index
+** down through the Walker.
+*/
+typedef struct IdxExprTrans {
+  Expr *pIdxExpr;    /* The index expression */
+  int iTabCur;       /* The cursor of the corresponding table */
+  int iIdxCur;       /* The cursor for the index */
+  int iIdxCol;       /* The column for the index */
+} IdxExprTrans;
+
+/* The walker node callback used to transform matching expressions into
+** a reference to an index column for an index on an expression.
+**
+** If pExpr matches, then transform it into a reference to the index column
+** that contains the value of pExpr.
+*/
+static int whereIndexExprTransNode(Walker *p, Expr *pExpr){
+  IdxExprTrans *pX = p->u.pIdxTrans;
+  if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){
+    pExpr->op = TK_COLUMN;
+    pExpr->iTable = pX->iIdxCur;
+    pExpr->iColumn = pX->iIdxCol;
+    pExpr->pTab = 0;
+    return WRC_Prune;
+  }else{
+    return WRC_Continue;
+  }
+}
+
+/*
+** For an indexes on expression X, locate every instance of expression X in pExpr
+** and change that subexpression into a reference to the appropriate column of
+** the index.
+*/
+static void whereIndexExprTrans(
+  Index *pIdx,      /* The Index */
+  int iTabCur,      /* Cursor of the table that is being indexed */
+  int iIdxCur,      /* Cursor of the index itself */
+  WhereInfo *pWInfo /* Transform expressions in this WHERE clause */
+){
+  int iIdxCol;               /* Column number of the index */
+  ExprList *aColExpr;        /* Expressions that are indexed */
+  Walker w;
+  IdxExprTrans x;
+  aColExpr = pIdx->aColExpr;
+  if( aColExpr==0 ) return;  /* Not an index on expressions */
+  memset(&w, 0, sizeof(w));
+  w.xExprCallback = whereIndexExprTransNode;
+  w.u.pIdxTrans = &x;
+  x.iTabCur = iTabCur;
+  x.iIdxCur = iIdxCur;
+  for(iIdxCol=0; iIdxCol<aColExpr->nExpr; iIdxCol++){
+    if( pIdx->aiColumn[iIdxCol]!=XN_EXPR ) continue;
+    assert( aColExpr->a[iIdxCol].pExpr!=0 );
+    x.iIdxCol = iIdxCol;
+    x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;
+    sqlite3WalkExpr(&w, pWInfo->pWhere);
+    sqlite3WalkExprList(&w, pWInfo->pOrderBy);
+    sqlite3WalkExprList(&w, pWInfo->pResultSet);
+  }
+}
+
 /*
 ** Generate code for the start of the iLevel-th loop in the WHERE clause
 ** implementation described by pWInfo.
@@ -127393,6 +128951,8 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
   int addrCont;                   /* Jump here to continue with next cycle */
   int iRowidReg = 0;        /* Rowid is stored in this register, if not zero */
   int iReleaseReg = 0;      /* Temp register to free before returning */
+  Index *pIdx = 0;          /* Index used by loop (if any) */
+  int iLoop;                /* Iteration of constraint generator loop */
 
   pParse = pWInfo->pParse;
   v = pParse->pVdbe;
@@ -127718,7 +129278,6 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
     int endEq;                   /* True if range end uses ==, >= or <= */
     int start_constraints;       /* Start of range is constrained */
     int nConstraint;             /* Number of constraint terms */
-    Index *pIdx;                 /* The index we will be using */
     int iIdxCur;                 /* The VDBE cursor for the index */
     int nExtraReg = 0;           /* Number of extra registers needed */
     int op;                      /* Instruction opcode */
@@ -127947,6 +129506,13 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
                            iRowidReg, pPk->nKeyCol); VdbeCoverage(v);
     }
 
+    /* If pIdx is an index on one or more expressions, then look through
+    ** all the expressions in pWInfo and try to transform matching expressions
+    ** into reference to index columns.
+    */
+    whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);
+
+
     /* Record the instruction used to terminate the loop. */
     if( pLoop->wsFlags & WHERE_ONEROW ){
       pLevel->op = OP_Noop;
@@ -127962,6 +129528,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
     }else{
       assert( pLevel->p5==0 );
     }
+    if( omitTable ) pIdx = 0;
   }else
 
 #ifndef SQLITE_OMIT_OR_OPTIMIZATION
@@ -128279,43 +129846,75 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
 
   /* Insert code to test every subexpression that can be completely
   ** computed using the current set of tables.
+  **
+  ** This loop may run between one and three times, depending on the
+  ** constraints to be generated. The value of stack variable iLoop
+  ** determines the constraints coded by each iteration, as follows:
+  **
+  ** iLoop==1: Code only expressions that are entirely covered by pIdx.
+  ** iLoop==2: Code remaining expressions that do not contain correlated
+  **           sub-queries.  
+  ** iLoop==3: Code all remaining expressions.
+  **
+  ** An effort is made to skip unnecessary iterations of the loop.
   */
-  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
-    Expr *pE;
-    int skipLikeAddr = 0;
-    testcase( pTerm->wtFlags & TERM_VIRTUAL );
-    testcase( pTerm->wtFlags & TERM_CODED );
-    if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;
-    if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
-      testcase( pWInfo->untestedTerms==0
-               && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)!=0 );
-      pWInfo->untestedTerms = 1;
-      continue;
-    }
-    pE = pTerm->pExpr;
-    assert( pE!=0 );
-    if( pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin) ){
-      continue;
-    }
-    if( pTerm->wtFlags & TERM_LIKECOND ){
-      /* If the TERM_LIKECOND flag is set, that means that the range search
-      ** is sufficient to guarantee that the LIKE operator is true, so we
-      ** can skip the call to the like(A,B) function.  But this only works
-      ** for strings.  So do not skip the call to the function on the pass
-      ** that compares BLOBs. */
+  iLoop = (pIdx ? 1 : 2);
+  do{
+    int iNext = 0;                /* Next value for iLoop */
+    for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
+      Expr *pE;
+      int skipLikeAddr = 0;
+      testcase( pTerm->wtFlags & TERM_VIRTUAL );
+      testcase( pTerm->wtFlags & TERM_CODED );
+      if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;
+      if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
+        testcase( pWInfo->untestedTerms==0
+            && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)!=0 );
+        pWInfo->untestedTerms = 1;
+        continue;
+      }
+      pE = pTerm->pExpr;
+      assert( pE!=0 );
+      if( pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin) ){
+        continue;
+      }
+      
+      if( iLoop==1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx) ){
+        iNext = 2;
+        continue;
+      }
+      if( iLoop<3 && (pTerm->wtFlags & TERM_VARSELECT) ){
+        if( iNext==0 ) iNext = 3;
+        continue;
+      }
+
+      if( pTerm->wtFlags & TERM_LIKECOND ){
+        /* If the TERM_LIKECOND flag is set, that means that the range search
+        ** is sufficient to guarantee that the LIKE operator is true, so we
+        ** can skip the call to the like(A,B) function.  But this only works
+        ** for strings.  So do not skip the call to the function on the pass
+        ** that compares BLOBs. */
 #ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
-      continue;
+        continue;
 #else
-      u32 x = pLevel->iLikeRepCntr;
-      assert( x>0 );
-      skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)? OP_IfNot : OP_If, (int)(x>>1));
-      VdbeCoverage(v);
+        u32 x = pLevel->iLikeRepCntr;
+        assert( x>0 );
+        skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?OP_IfNot:OP_If, (int)(x>>1));
+        VdbeCoverage(v);
 #endif
+      }
+#ifdef WHERETRACE_ENABLED /* 0xffff */
+      if( sqlite3WhereTrace ){
+        VdbeNoopComment((v, "WhereTerm[%d] (%p) priority=%d",
+                         pWC->nTerm-j, pTerm, iLoop));
+      }
+#endif
+      sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);
+      if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);
+      pTerm->wtFlags |= TERM_CODED;
     }
-    sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);
-    if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);
-    pTerm->wtFlags |= TERM_CODED;
-  }
+    iLoop = iNext;
+  }while( iLoop>0 );
 
   /* Insert code to test for implied constraints based on transitivity
   ** of the "==" operator.
@@ -128594,7 +130193,7 @@ static int isLikeOrGlob(
 
   pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);
   op = pRight->op;
-  if( op==TK_VARIABLE ){
+  if( op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){
     Vdbe *pReprepare = pParse->pReprepare;
     int iCol = pRight->iColumn;
     pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, SQLITE_AFF_BLOB);
@@ -128784,8 +130383,8 @@ static void whereCombineDisjuncts(
    && (eOp & (WO_EQ|WO_GT|WO_GE))!=eOp ) return;
   assert( pOne->pExpr->pLeft!=0 && pOne->pExpr->pRight!=0 );
   assert( pTwo->pExpr->pLeft!=0 && pTwo->pExpr->pRight!=0 );
-  if( sqlite3ExprCompare(pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
-  if( sqlite3ExprCompare(pOne->pExpr->pRight, pTwo->pExpr->pRight, -1) )return;
+  if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
+  if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;
   /* If we reach this point, it means the two subterms can be combined */
   if( (eOp & (eOp-1))!=0 ){
     if( eOp & (WO_LT|WO_LE) ){
@@ -129208,8 +130807,8 @@ static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){
 ** Expression pExpr is one operand of a comparison operator that might
 ** be useful for indexing.  This routine checks to see if pExpr appears
 ** in any index.  Return TRUE (1) if pExpr is an indexed term and return
-** FALSE (0) if not.  If TRUE is returned, also set *piCur to the cursor
-** number of the table that is indexed and *piColumn to the column number
+** FALSE (0) if not.  If TRUE is returned, also set aiCurCol[0] to the cursor
+** number of the table that is indexed and aiCurCol[1] to the column number
 ** of the column that is indexed, or XN_EXPR (-2) if an expression is being
 ** indexed.
 **
@@ -129217,18 +130816,37 @@ static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){
 ** true even if that particular column is not indexed, because the column
 ** might be added to an automatic index later.
 */
-static int exprMightBeIndexed(
+static SQLITE_NOINLINE int exprMightBeIndexed2(
   SrcList *pFrom,        /* The FROM clause */
-  int op,                /* The specific comparison operator */
   Bitmask mPrereq,       /* Bitmask of FROM clause terms referenced by pExpr */
-  Expr *pExpr,           /* An operand of a comparison operator */
-  int *piCur,            /* Write the referenced table cursor number here */
-  int *piColumn          /* Write the referenced table column number here */
+  int *aiCurCol,         /* Write the referenced table cursor and column here */
+  Expr *pExpr            /* An operand of a comparison operator */
 ){
   Index *pIdx;
   int i;
   int iCur;
-
+  for(i=0; mPrereq>1; i++, mPrereq>>=1){}
+  iCur = pFrom->a[i].iCursor;
+  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){
+    if( pIdx->aColExpr==0 ) continue;
+    for(i=0; i<pIdx->nKeyCol; i++){
+      if( pIdx->aiColumn[i]!=XN_EXPR ) continue;
+      if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){
+        aiCurCol[0] = iCur;
+        aiCurCol[1] = XN_EXPR;
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+static int exprMightBeIndexed(
+  SrcList *pFrom,        /* The FROM clause */
+  Bitmask mPrereq,       /* Bitmask of FROM clause terms referenced by pExpr */
+  int *aiCurCol,         /* Write the referenced table cursor & column here */
+  Expr *pExpr,           /* An operand of a comparison operator */
+  int op                 /* The specific comparison operator */
+){
   /* If this expression is a vector to the left or right of a 
   ** inequality constraint (>, <, >= or <=), perform the processing 
   ** on the first element of the vector.  */
@@ -129240,26 +130858,13 @@ static int exprMightBeIndexed(
   }
 
   if( pExpr->op==TK_COLUMN ){
-    *piCur = pExpr->iTable;
-    *piColumn = pExpr->iColumn;
+    aiCurCol[0] = pExpr->iTable;
+    aiCurCol[1] = pExpr->iColumn;
     return 1;
   }
   if( mPrereq==0 ) return 0;                 /* No table references */
   if( (mPrereq&(mPrereq-1))!=0 ) return 0;   /* Refs more than one table */
-  for(i=0; mPrereq>1; i++, mPrereq>>=1){}
-  iCur = pFrom->a[i].iCursor;
-  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-    if( pIdx->aColExpr==0 ) continue;
-    for(i=0; i<pIdx->nKeyCol; i++){
-      if( pIdx->aiColumn[i]!=XN_EXPR ) continue;
-      if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){
-        *piCur = iCur;
-        *piColumn = XN_EXPR;
-        return 1;
-      }
-    }
-  }
-  return 0;
+  return exprMightBeIndexed2(pFrom,mPrereq,aiCurCol,pExpr);
 }
 
 /*
@@ -129323,7 +130928,9 @@ static void exprAnalyze(
   }else{
     pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
   }
+  pMaskSet->bVarSelect = 0;
   prereqAll = sqlite3WhereExprUsage(pMaskSet, pExpr);
+  if( pMaskSet->bVarSelect ) pTerm->wtFlags |= TERM_VARSELECT;
   if( ExprHasProperty(pExpr, EP_FromJoin) ){
     Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->iRightJoinTable);
     prereqAll |= x;
@@ -129339,7 +130946,7 @@ static void exprAnalyze(
   pTerm->iParent = -1;
   pTerm->eOperator = 0;
   if( allowedOp(op) ){
-    int iCur, iColumn;
+    int aiCurCol[2];
     Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
     Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
     u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? WO_ALL : WO_EQUIV;
@@ -129350,14 +130957,14 @@ static void exprAnalyze(
       pLeft = pLeft->x.pList->a[pTerm->iField-1].pExpr;
     }
 
-    if( exprMightBeIndexed(pSrc, op, prereqLeft, pLeft, &iCur, &iColumn) ){
-      pTerm->leftCursor = iCur;
-      pTerm->u.leftColumn = iColumn;
+    if( exprMightBeIndexed(pSrc, prereqLeft, aiCurCol, pLeft, op) ){
+      pTerm->leftCursor = aiCurCol[0];
+      pTerm->u.leftColumn = aiCurCol[1];
       pTerm->eOperator = operatorMask(op) & opMask;
     }
     if( op==TK_IS ) pTerm->wtFlags |= TERM_IS;
     if( pRight 
-     && exprMightBeIndexed(pSrc, op, pTerm->prereqRight, pRight, &iCur,&iColumn)
+     && exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op)
     ){
       WhereTerm *pNew;
       Expr *pDup;
@@ -129387,8 +130994,8 @@ static void exprAnalyze(
         pNew = pTerm;
       }
       exprCommute(pParse, pDup);
-      pNew->leftCursor = iCur;
-      pNew->u.leftColumn = iColumn;
+      pNew->leftCursor = aiCurCol[0];
+      pNew->u.leftColumn = aiCurCol[1];
       testcase( (prereqLeft | extraRight) != prereqLeft );
       pNew->prereqRight = prereqLeft | extraRight;
       pNew->prereqAll = prereqAll;
@@ -129550,6 +131157,9 @@ static void exprAnalyze(
       Expr *pNewExpr;
       pNewExpr = sqlite3PExpr(pParse, TK_MATCH, 
                               0, sqlite3ExprDup(db, pRight, 0));
+      if( ExprHasProperty(pExpr, EP_FromJoin) && pNewExpr ){
+        ExprSetProperty(pNewExpr, EP_FromJoin);
+      }
       idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);
       testcase( idxNew==0 );
       pNewTerm = &pWC->a[idxNew];
@@ -129747,13 +131357,16 @@ SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){
   Bitmask mask;
   if( p==0 ) return 0;
   if( p->op==TK_COLUMN ){
-    mask = sqlite3WhereGetMask(pMaskSet, p->iTable);
-    return mask;
+    return sqlite3WhereGetMask(pMaskSet, p->iTable);
   }
+  mask = (p->op==TK_IF_NULL_ROW) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;
   assert( !ExprHasProperty(p, EP_TokenOnly) );
-  mask = p->pRight ? sqlite3WhereExprUsage(pMaskSet, p->pRight) : 0;
   if( p->pLeft ) mask |= sqlite3WhereExprUsage(pMaskSet, p->pLeft);
-  if( ExprHasProperty(p, EP_xIsSelect) ){
+  if( p->pRight ){
+    mask |= sqlite3WhereExprUsage(pMaskSet, p->pRight);
+    assert( p->x.pList==0 );
+  }else if( ExprHasProperty(p, EP_xIsSelect) ){
+    if( ExprHasProperty(p, EP_VarSelect) ) pMaskSet->bVarSelect = 1;
     mask |= exprSelectUsage(pMaskSet, p->x.pSelect);
   }else if( p->x.pList ){
     mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);
@@ -130442,6 +132055,15 @@ static int termCanDriveIndex(
   char aff;
   if( pTerm->leftCursor!=pSrc->iCursor ) return 0;
   if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) return 0;
+  if( (pSrc->fg.jointype & JT_LEFT) 
+   && !ExprHasProperty(pTerm->pExpr, EP_FromJoin)
+   && (pTerm->eOperator & WO_IS)
+  ){
+    /* Cannot use an IS term from the WHERE clause as an index driver for
+    ** the RHS of a LEFT JOIN. Such a term can only be used if it is from
+    ** the ON clause.  */
+    return 0;
+  }
   if( (pTerm->prereqRight & notReady)!=0 ) return 0;
   if( pTerm->u.leftColumn<0 ) return 0;
   aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;
@@ -131026,7 +132648,7 @@ static int whereKeyStats(
       iGap = iGap/3;
     }
     aStat[0] = iLower + iGap;
-    aStat[1] = pIdx->aAvgEq[iCol];
+    aStat[1] = pIdx->aAvgEq[nField-1];
   }
 
   /* Restore the pRec->nField value before returning.  */
@@ -131620,7 +133242,7 @@ static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){
       p->u.vtab.idxStr = 0;
     }else if( (p->wsFlags & WHERE_AUTO_INDEX)!=0 && p->u.btree.pIndex!=0 ){
       sqlite3DbFree(db, p->u.btree.pIndex->zColAff);
-      sqlite3DbFree(db, p->u.btree.pIndex);
+      sqlite3DbFreeNN(db, p->u.btree.pIndex);
       p->u.btree.pIndex = 0;
     }
   }
@@ -131630,7 +133252,7 @@ static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){
 ** Deallocate internal memory used by a WhereLoop object
 */
 static void whereLoopClear(sqlite3 *db, WhereLoop *p){
-  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFree(db, p->aLTerm);
+  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);
   whereLoopClearUnion(db, p);
   whereLoopInit(p);
 }
@@ -131645,7 +133267,7 @@ static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){
   paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);
   if( paNew==0 ) return SQLITE_NOMEM_BKPT;
   memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
-  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFree(db, p->aLTerm);
+  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);
   p->aLTerm = paNew;
   p->nLSlot = n;
   return SQLITE_OK;
@@ -131675,7 +133297,7 @@ static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){
 */
 static void whereLoopDelete(sqlite3 *db, WhereLoop *p){
   whereLoopClear(db, p);
-  sqlite3DbFree(db, p);
+  sqlite3DbFreeNN(db, p);
 }
 
 /*
@@ -131696,7 +133318,7 @@ static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
       pWInfo->pLoops = p->pNextLoop;
       whereLoopDelete(db, p);
     }
-    sqlite3DbFree(db, pWInfo);
+    sqlite3DbFreeNN(db, pWInfo);
   }
 }
 
@@ -131779,16 +133401,17 @@ static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){
 
 /*
 ** Search the list of WhereLoops in *ppPrev looking for one that can be
-** supplanted by pTemplate.
+** replaced by pTemplate.
 **
-** Return NULL if the WhereLoop list contains an entry that can supplant
-** pTemplate, in other words if pTemplate does not belong on the list.
+** Return NULL if pTemplate does not belong on the WhereLoop list.
+** In other words if pTemplate ought to be dropped from further consideration.
 **
-** If pX is a WhereLoop that pTemplate can supplant, then return the
+** If pX is a WhereLoop that pTemplate can replace, then return the
 ** link that points to pX.
 **
-** If pTemplate cannot supplant any existing element of the list but needs
-** to be added to the list, then return a pointer to the tail of the list.
+** If pTemplate cannot replace any existing element of the list but needs
+** to be added to the list as a new entry, then return a pointer to the
+** tail of the list.
 */
 static WhereLoop **whereLoopFindLesser(
   WhereLoop **ppPrev,
@@ -131933,8 +133556,10 @@ static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){
     if( p!=0 ){
       sqlite3DebugPrintf("replace: ");
       whereLoopPrint(p, pBuilder->pWC);
+      sqlite3DebugPrintf("   with: ");
+    }else{
+      sqlite3DebugPrintf("    add: ");
     }
-    sqlite3DebugPrintf("    add: ");
     whereLoopPrint(pTemplate, pBuilder->pWC);
   }
 #endif
@@ -132485,7 +134110,7 @@ static int indexMightHelpWithOrderBy(
     }else if( (aColExpr = pIndex->aColExpr)!=0 ){
       for(jj=0; jj<pIndex->nKeyCol; jj++){
         if( pIndex->aiColumn[jj]!=XN_EXPR ) continue;
-        if( sqlite3ExprCompare(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
+        if( sqlite3ExprCompare(0, pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
           return 1;
         }
       }
@@ -132518,14 +134143,16 @@ static Bitmask columnsInIndex(Index *pIdx){
 static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){
   int i;
   WhereTerm *pTerm;
+  Parse *pParse = pWC->pWInfo->pParse;
   while( pWhere->op==TK_AND ){
     if( !whereUsablePartialIndex(iTab,pWC,pWhere->pLeft) ) return 0;
     pWhere = pWhere->pRight;
   }
+  if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
     Expr *pExpr = pTerm->pExpr;
-    if( sqlite3ExprImpliesExpr(pExpr, pWhere, iTab) 
-     && (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)
+    if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)
+     && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab) 
     ){
       return 1;
     }
@@ -133087,7 +134714,7 @@ static int whereLoopAddVirtual(
   }
 
   if( p->needToFreeIdxStr ) sqlite3_free(p->idxStr);
-  sqlite3DbFree(pParse->db, p);
+  sqlite3DbFreeNN(pParse->db, p);
   return rc;
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
@@ -133271,7 +134898,7 @@ static int whereLoopAddAll(WhereLoopBuilder *pBuilder){
 }
 
 /*
-** Examine a WherePath (with the addition of the extra WhereLoop of the 5th
+** Examine a WherePath (with the addition of the extra WhereLoop of the 6th
 ** parameters) to see if it outputs rows in the requested ORDER BY
 ** (or GROUP BY) without requiring a separate sort operation.  Return N:
 ** 
@@ -133366,6 +134993,8 @@ static i8 wherePathSatisfiesOrderBy(
     if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){
       if( pLoop->u.vtab.isOrdered ) obSat = obDone;
       break;
+    }else{
+      pLoop->u.btree.nIdxCol = 0;
     }
     iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;
 
@@ -133502,7 +135131,8 @@ static i8 wherePathSatisfiesOrderBy(
             if( pOBExpr->iTable!=iCur ) continue;
             if( pOBExpr->iColumn!=iColumn ) continue;
           }else{
-            if( sqlite3ExprCompare(pOBExpr,pIndex->aColExpr->a[j].pExpr,iCur) ){
+            if( sqlite3ExprCompare(0,
+                  pOBExpr,pIndex->aColExpr->a[j].pExpr,iCur) ){
               continue;
             }
           }
@@ -133511,6 +135141,7 @@ static i8 wherePathSatisfiesOrderBy(
             if( !pColl ) pColl = db->pDfltColl;
             if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;
           }
+          pLoop->u.btree.nIdxCol = j+1;
           isMatch = 1;
           break;
         }
@@ -133800,6 +135431,7 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
                rUnsorted, rCost));
         }else{
           rCost = rUnsorted;
+          rUnsorted -= 2;  /* TUNING:  Slight bias in favor of no-sort plans */
         }
 
         /* Check to see if pWLoop should be added to the set of
@@ -133831,8 +135463,8 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
             ** this candidate as not viable. */
 #ifdef WHERETRACE_ENABLED /* 0x4 */
             if( sqlite3WhereTrace&0x4 ){
-              sqlite3DebugPrintf("Skip   %s cost=%-3d,%3d order=%c\n",
-                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
+              sqlite3DebugPrintf("Skip   %s cost=%-3d,%3d,%3d order=%c\n",
+                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,
                   isOrdered>=0 ? isOrdered+'0' : '?');
             }
 #endif
@@ -133850,26 +135482,36 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
           pTo = &aTo[jj];
 #ifdef WHERETRACE_ENABLED /* 0x4 */
           if( sqlite3WhereTrace&0x4 ){
-            sqlite3DebugPrintf("New    %s cost=%-3d,%3d order=%c\n",
-                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
+            sqlite3DebugPrintf("New    %s cost=%-3d,%3d,%3d order=%c\n",
+                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,
                 isOrdered>=0 ? isOrdered+'0' : '?');
           }
 #endif
         }else{
           /* Control reaches here if best-so-far path pTo=aTo[jj] covers the
-          ** same set of loops and has the sam isOrdered setting as the
+          ** same set of loops and has the same isOrdered setting as the
           ** candidate path.  Check to see if the candidate should replace
-          ** pTo or if the candidate should be skipped */
-          if( pTo->rCost<rCost || (pTo->rCost==rCost && pTo->nRow<=nOut) ){
+          ** pTo or if the candidate should be skipped.
+          ** 
+          ** The conditional is an expanded vector comparison equivalent to:
+          **   (pTo->rCost,pTo->nRow,pTo->rUnsorted) <= (rCost,nOut,rUnsorted)
+          */
+          if( pTo->rCost<rCost 
+           || (pTo->rCost==rCost
+               && (pTo->nRow<nOut
+                   || (pTo->nRow==nOut && pTo->rUnsorted<=rUnsorted)
+                  )
+              )
+          ){
 #ifdef WHERETRACE_ENABLED /* 0x4 */
             if( sqlite3WhereTrace&0x4 ){
               sqlite3DebugPrintf(
-                  "Skip   %s cost=%-3d,%3d order=%c",
-                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
+                  "Skip   %s cost=%-3d,%3d,%3d order=%c",
+                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,
                   isOrdered>=0 ? isOrdered+'0' : '?');
-              sqlite3DebugPrintf("   vs %s cost=%-3d,%d order=%c\n",
+              sqlite3DebugPrintf("   vs %s cost=%-3d,%3d,%3d order=%c\n",
                   wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,
-                  pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');
+                  pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');
             }
 #endif
             /* Discard the candidate path from further consideration */
@@ -133882,12 +135524,12 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
 #ifdef WHERETRACE_ENABLED /* 0x4 */
           if( sqlite3WhereTrace&0x4 ){
             sqlite3DebugPrintf(
-                "Update %s cost=%-3d,%3d order=%c",
-                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
+                "Update %s cost=%-3d,%3d,%3d order=%c",
+                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,
                 isOrdered>=0 ? isOrdered+'0' : '?');
-            sqlite3DebugPrintf("  was %s cost=%-3d,%3d order=%c\n",
+            sqlite3DebugPrintf("  was %s cost=%-3d,%3d,%3d order=%c\n",
                 wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,
-                pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');
+                pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');
           }
 #endif
         }
@@ -133942,7 +135584,7 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
 
   if( nFrom==0 ){
     sqlite3ErrorMsg(pParse, "no query solution");
-    sqlite3DbFree(db, pSpace);
+    sqlite3DbFreeNN(db, pSpace);
     return SQLITE_ERROR;
   }
   
@@ -134018,7 +135660,7 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
   pWInfo->nRowOut = pFrom->nRow;
 
   /* Free temporary memory and return success */
-  sqlite3DbFree(db, pSpace);
+  sqlite3DbFreeNN(db, pSpace);
   return SQLITE_OK;
 }
 
@@ -134096,7 +135738,8 @@ static int whereShortCut(WhereLoopBuilder *pBuilder){
   if( pLoop->wsFlags ){
     pLoop->nOut = (LogEst)1;
     pWInfo->a[0].pWLoop = pLoop;
-    pLoop->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
+    assert( pWInfo->sMaskSet.n==1 && iCur==pWInfo->sMaskSet.ix[0] );
+    pLoop->maskSelf = 1; /* sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur); */
     pWInfo->a[0].iTabCur = iCur;
     pWInfo->nRowOut = 1;
     if( pWInfo->pOrderBy ) pWInfo->nOBSat =  pWInfo->pOrderBy->nExpr;
@@ -134111,6 +135754,31 @@ static int whereShortCut(WhereLoopBuilder *pBuilder){
   return 0;
 }
 
+/*
+** Helper function for exprIsDeterministic().
+*/
+static int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){
+  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_ConstFunc)==0 ){
+    pWalker->eCode = 0;
+    return WRC_Abort;
+  }
+  return WRC_Continue;
+}
+
+/*
+** Return true if the expression contains no non-deterministic SQL 
+** functions. Do not consider non-deterministic SQL functions that are 
+** part of sub-select statements.
+*/
+static int exprIsDeterministic(Expr *p){
+  Walker w;
+  memset(&w, 0, sizeof(w));
+  w.eCode = 1;
+  w.xExprCallback = exprNodeIsDeterministic;
+  sqlite3WalkExpr(&w, p);
+  return w.eCode;
+}
+
 /*
 ** Generate the beginning of the loop used for WHERE clause processing.
 ** The return value is a pointer to an opaque structure that contains
@@ -134280,6 +135948,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   pWInfo->pParse = pParse;
   pWInfo->pTabList = pTabList;
   pWInfo->pOrderBy = pOrderBy;
+  pWInfo->pWhere = pWhere;
   pWInfo->pResultSet = pResultSet;
   pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;
   pWInfo->nLevel = nTabList;
@@ -134308,17 +135977,6 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);
   sqlite3WhereSplit(&pWInfo->sWC, pWhere, TK_AND);
     
-  /* Special case: a WHERE clause that is constant.  Evaluate the
-  ** expression and either jump over all of the code or fall thru.
-  */
-  for(ii=0; ii<sWLB.pWC->nTerm; ii++){
-    if( nTabList==0 || sqlite3ExprIsConstantNotJoin(sWLB.pWC->a[ii].pExpr) ){
-      sqlite3ExprIfFalse(pParse, sWLB.pWC->a[ii].pExpr, pWInfo->iBreak,
-                         SQLITE_JUMPIFNULL);
-      sWLB.pWC->a[ii].wtFlags |= TERM_CODED;
-    }
-  }
-
   /* Special case: No FROM clause
   */
   if( nTabList==0 ){
@@ -134347,9 +136005,13 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
     sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);
   }
 #ifdef SQLITE_DEBUG
-  for(ii=0; ii<pTabList->nSrc; ii++){
-    Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);
-    assert( m==MASKBIT(ii) );
+  {
+    Bitmask mx = 0;
+    for(ii=0; ii<pTabList->nSrc; ii++){
+      Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);
+      assert( m>=mx );
+      mx = m;
+    }
   }
 #endif
 
@@ -134357,6 +136019,25 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);
   if( db->mallocFailed ) goto whereBeginError;
 
+  /* Special case: WHERE terms that do not refer to any tables in the join
+  ** (constant expressions). Evaluate each such term, and jump over all the
+  ** generated code if the result is not true.  
+  **
+  ** Do not do this if the expression contains non-deterministic functions
+  ** that are not within a sub-select. This is not strictly required, but
+  ** preserves SQLite's legacy behaviour in the following two cases:
+  **
+  **   FROM ... WHERE random()>0;           -- eval random() once per row
+  **   FROM ... WHERE (SELECT random())>0;  -- eval random() once overall
+  */
+  for(ii=0; ii<sWLB.pWC->nTerm; ii++){
+    WhereTerm *pT = &sWLB.pWC->a[ii];
+    if( pT->prereqAll==0 && (nTabList==0 || exprIsDeterministic(pT->pExpr)) ){
+      sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, SQLITE_JUMPIFNULL);
+      pT->wtFlags |= TERM_CODED;
+    }
+  }
+
   if( wctrlFlags & WHERE_WANT_DISTINCT ){
     if( isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet) ){
       /* The DISTINCT marking is pointless.  Ignore it. */
@@ -134393,7 +136074,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
       static const char zLabel[] = "0123456789abcdefghijklmnopqrstuvwyxz"
                                              "ABCDEFGHIJKLMNOPQRSTUVWYXZ";
       for(p=pWInfo->pLoops, i=0; p; p=p->pNextLoop, i++){
-        p->cId = zLabel[i%sizeof(zLabel)];
+        p->cId = zLabel[i%(sizeof(zLabel)-1)];
         whereLoopPrint(p, sWLB.pWC);
       }
     }
@@ -134590,6 +136271,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
         if( (pLoop->wsFlags & WHERE_CONSTRAINT)!=0
          && (pLoop->wsFlags & (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0
          && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0
+         && pWInfo->eDistinct!=WHERE_DISTINCT_ORDERED
         ){
           sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ); /* Hint to COMDB2 */
         }
@@ -134678,14 +136360,43 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
     int addr;
     pLevel = &pWInfo->a[i];
     pLoop = pLevel->pWLoop;
-    sqlite3VdbeResolveLabel(v, pLevel->addrCont);
     if( pLevel->op!=OP_Noop ){
+#ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
+      int addrSeek = 0;
+      Index *pIdx;
+      int n;
+      if( pWInfo->eDistinct==WHERE_DISTINCT_ORDERED
+       && (pLoop->wsFlags & WHERE_INDEXED)!=0
+       && (pIdx = pLoop->u.btree.pIndex)->hasStat1
+       && (n = pLoop->u.btree.nIdxCol)>0
+       && pIdx->aiRowLogEst[n]>=36
+      ){
+        int r1 = pParse->nMem+1;
+        int j, op;
+        for(j=0; j<n; j++){
+          sqlite3VdbeAddOp3(v, OP_Column, pLevel->iIdxCur, j, r1+j);
+        }
+        pParse->nMem += n+1;
+        op = pLevel->op==OP_Prev ? OP_SeekLT : OP_SeekGT;
+        addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel->iIdxCur, 0, r1, n);
+        VdbeCoverageIf(v, op==OP_SeekLT);
+        VdbeCoverageIf(v, op==OP_SeekGT);
+        sqlite3VdbeAddOp2(v, OP_Goto, 1, pLevel->p2);
+      }
+#endif /* SQLITE_DISABLE_SKIPAHEAD_DISTINCT */
+      /* The common case: Advance to the next row */
+      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
       sqlite3VdbeAddOp3(v, pLevel->op, pLevel->p1, pLevel->p2, pLevel->p3);
       sqlite3VdbeChangeP5(v, pLevel->p5);
       VdbeCoverage(v);
       VdbeCoverageIf(v, pLevel->op==OP_Next);
       VdbeCoverageIf(v, pLevel->op==OP_Prev);
       VdbeCoverageIf(v, pLevel->op==OP_VNext);
+#ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
+      if( addrSeek ) sqlite3VdbeJumpHere(v, addrSeek);
+#endif
+    }else{
+      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
     }
     if( pLoop->wsFlags & WHERE_IN_ABLE && pLevel->u.in.nIn>0 ){
       struct InLoop *pIn;
@@ -134808,6 +136519,8 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
         }else if( pOp->opcode==OP_Rowid ){
           pOp->p1 = pLevel->iIdxCur;
           pOp->opcode = OP_IdxRowid;
+        }else if( pOp->opcode==OP_IfNullRow ){
+          pOp->p1 = pLevel->iIdxCur;
         }
       }
     }
@@ -135117,7 +136830,7 @@ static void disableLookaside(Parse *pParse){
 #define YYCODETYPE unsigned char
 #define YYNOCODE 252
 #define YYACTIONTYPE unsigned short int
-#define YYWILDCARD 96
+#define YYWILDCARD 69
 #define sqlite3ParserTOKENTYPE Token
 typedef union {
   int yyinit;
@@ -135143,16 +136856,16 @@ typedef union {
 #define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse
 #define sqlite3ParserARG_STORE yypParser->pParse = pParse
 #define YYFALLBACK 1
-#define YYNSTATE             456
-#define YYNRULE              332
-#define YY_MAX_SHIFT         455
-#define YY_MIN_SHIFTREDUCE   668
-#define YY_MAX_SHIFTREDUCE   999
-#define YY_MIN_REDUCE        1000
-#define YY_MAX_REDUCE        1331
-#define YY_ERROR_ACTION      1332
-#define YY_ACCEPT_ACTION     1333
-#define YY_NO_ACTION         1334
+#define YYNSTATE             455
+#define YYNRULE              329
+#define YY_MAX_SHIFT         454
+#define YY_MIN_SHIFTREDUCE   664
+#define YY_MAX_SHIFTREDUCE   992
+#define YY_MIN_REDUCE        993
+#define YY_MAX_REDUCE        1321
+#define YY_ERROR_ACTION      1322
+#define YY_ACCEPT_ACTION     1323
+#define YY_NO_ACTION         1324
 /************* End control #defines *******************************************/
 
 /* Define the yytestcase() macro to be a no-op if is not already defined
@@ -135224,463 +136937,463 @@ typedef union {
 **  yy_default[]       Default action for each state.
 **
 *********** Begin parsing tables **********************************************/
-#define YY_ACTTAB_COUNT (1567)
+#define YY_ACTTAB_COUNT (1565)
 static const YYACTIONTYPE yy_action[] = {
- /*     0 */   325,  832,  351,  825,    5,  203,  203,  819,   99,  100,
- /*    10 */    90,  978,  978,  853,  856,  845,  845,   97,   97,   98,
- /*    20 */    98,   98,   98,  301,   96,   96,   96,   96,   95,   95,
- /*    30 */    94,   94,   94,   93,  351,  325,  976,  976,  824,  824,
- /*    40 */   826,  946,  354,   99,  100,   90,  978,  978,  853,  856,
- /*    50 */   845,  845,   97,   97,   98,   98,   98,   98,  338,   96,
- /*    60 */    96,   96,   96,   95,   95,   94,   94,   94,   93,  351,
- /*    70 */    95,   95,   94,   94,   94,   93,  351,  791,  976,  976,
- /*    80 */   325,   94,   94,   94,   93,  351,  792,   75,   99,  100,
- /*    90 */    90,  978,  978,  853,  856,  845,  845,   97,   97,   98,
- /*   100 */    98,   98,   98,  450,   96,   96,   96,   96,   95,   95,
- /*   110 */    94,   94,   94,   93,  351, 1333,  155,  155,    2,  325,
- /*   120 */   275,  146,  132,   52,   52,   93,  351,   99,  100,   90,
- /*   130 */   978,  978,  853,  856,  845,  845,   97,   97,   98,   98,
- /*   140 */    98,   98,  101,   96,   96,   96,   96,   95,   95,   94,
- /*   150 */    94,   94,   93,  351,  957,  957,  325,  268,  428,  413,
- /*   160 */   411,   61,  752,  752,   99,  100,   90,  978,  978,  853,
- /*   170 */   856,  845,  845,   97,   97,   98,   98,   98,   98,   60,
- /*   180 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*   190 */   351,  325,  270,  329,  273,  277,  958,  959,  250,   99,
- /*   200 */   100,   90,  978,  978,  853,  856,  845,  845,   97,   97,
- /*   210 */    98,   98,   98,   98,  301,   96,   96,   96,   96,   95,
- /*   220 */    95,   94,   94,   94,   93,  351,  325,  937, 1326,  698,
- /*   230 */   706, 1326,  242,  412,   99,  100,   90,  978,  978,  853,
- /*   240 */   856,  845,  845,   97,   97,   98,   98,   98,   98,  347,
- /*   250 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*   260 */   351,  325,  937, 1327,  384,  699, 1327,  381,  379,   99,
- /*   270 */   100,   90,  978,  978,  853,  856,  845,  845,   97,   97,
- /*   280 */    98,   98,   98,   98,  701,   96,   96,   96,   96,   95,
- /*   290 */    95,   94,   94,   94,   93,  351,  325,   92,   89,  178,
- /*   300 */   833,  935,  373,  700,   99,  100,   90,  978,  978,  853,
- /*   310 */   856,  845,  845,   97,   97,   98,   98,   98,   98,  375,
- /*   320 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*   330 */   351,  325, 1275,  946,  354,  818,  935,  739,  739,   99,
- /*   340 */   100,   90,  978,  978,  853,  856,  845,  845,   97,   97,
- /*   350 */    98,   98,   98,   98,  230,   96,   96,   96,   96,   95,
- /*   360 */    95,   94,   94,   94,   93,  351,  325,  968,  227,   92,
- /*   370 */    89,  178,  373,  300,   99,  100,   90,  978,  978,  853,
- /*   380 */   856,  845,  845,   97,   97,   98,   98,   98,   98,  920,
- /*   390 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*   400 */   351,  325,  449,  447,  447,  447,  147,  737,  737,   99,
- /*   410 */   100,   90,  978,  978,  853,  856,  845,  845,   97,   97,
- /*   420 */    98,   98,   98,   98,  296,   96,   96,   96,   96,   95,
- /*   430 */    95,   94,   94,   94,   93,  351,  325,  419,  231,  957,
- /*   440 */   957,  158,   25,  422,   99,  100,   90,  978,  978,  853,
- /*   450 */   856,  845,  845,   97,   97,   98,   98,   98,   98,  450,
- /*   460 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*   470 */   351,  443,  224,  224,  420,  957,  957,  961,  325,   52,
- /*   480 */    52,  958,  959,  176,  415,   78,   99,  100,   90,  978,
- /*   490 */   978,  853,  856,  845,  845,   97,   97,   98,   98,   98,
- /*   500 */    98,  379,   96,   96,   96,   96,   95,   95,   94,   94,
- /*   510 */    94,   93,  351,  325,  428,  418,  298,  958,  959,  961,
- /*   520 */    81,   99,   88,   90,  978,  978,  853,  856,  845,  845,
- /*   530 */    97,   97,   98,   98,   98,   98,  717,   96,   96,   96,
- /*   540 */    96,   95,   95,   94,   94,   94,   93,  351,  325,  842,
- /*   550 */   842,  854,  857,  996,  318,  343,  379,  100,   90,  978,
- /*   560 */   978,  853,  856,  845,  845,   97,   97,   98,   98,   98,
- /*   570 */    98,  450,   96,   96,   96,   96,   95,   95,   94,   94,
- /*   580 */    94,   93,  351,  325,  350,  350,  350,  260,  377,  340,
- /*   590 */   928,   52,   52,   90,  978,  978,  853,  856,  845,  845,
- /*   600 */    97,   97,   98,   98,   98,   98,  361,   96,   96,   96,
- /*   610 */    96,   95,   95,   94,   94,   94,   93,  351,   86,  445,
- /*   620 */   846,    3, 1202,  361,  360,  378,  344,  813,  957,  957,
- /*   630 */  1299,   86,  445,  729,    3,  212,  169,  287,  405,  282,
- /*   640 */   404,  199,  232,  450,  300,  760,   83,   84,  280,  245,
- /*   650 */   262,  365,  251,   85,  352,  352,   92,   89,  178,   83,
- /*   660 */    84,  242,  412,   52,   52,  448,   85,  352,  352,  246,
- /*   670 */   958,  959,  194,  455,  670,  402,  399,  398,  448,  243,
- /*   680 */   221,  114,  434,  776,  361,  450,  397,  268,  747,  224,
- /*   690 */   224,  132,  132,  198,  832,  434,  452,  451,  428,  427,
- /*   700 */   819,  415,  734,  713,  132,   52,   52,  832,  268,  452,
- /*   710 */   451,  734,  194,  819,  363,  402,  399,  398,  450, 1270,
- /*   720 */  1270,   23,  957,  957,   86,  445,  397,    3,  228,  429,
- /*   730 */   894,  824,  824,  826,  827,   19,  203,  720,   52,   52,
- /*   740 */   428,  408,  439,  249,  824,  824,  826,  827,   19,  229,
- /*   750 */   403,  153,   83,   84,  761,  177,  241,  450,  721,   85,
- /*   760 */   352,  352,  120,  157,  958,  959,   58,  976,  409,  355,
- /*   770 */   330,  448,  268,  428,  430,  320,  790,   32,   32,   86,
- /*   780 */   445,  776,    3,  341,   98,   98,   98,   98,  434,   96,
- /*   790 */    96,   96,   96,   95,   95,   94,   94,   94,   93,  351,
- /*   800 */   832,  120,  452,  451,  813,  886,  819,   83,   84,  976,
- /*   810 */   813,  132,  410,  919,   85,  352,  352,  132,  407,  789,
- /*   820 */   957,  957,   92,   89,  178,  916,  448,  262,  370,  261,
- /*   830 */    82,  913,   80,  262,  370,  261,  776,  824,  824,  826,
- /*   840 */   827,   19,  933,  434,   96,   96,   96,   96,   95,   95,
- /*   850 */    94,   94,   94,   93,  351,  832,   74,  452,  451,  957,
- /*   860 */   957,  819,  958,  959,  120,   92,   89,  178,  944,    2,
- /*   870 */   917,  964,  268,    1,  975,   76,  445,  762,    3,  708,
- /*   880 */   900,  900,  387,  957,  957,  757,  918,  371,  740,  778,
- /*   890 */   756,  257,  824,  824,  826,  827,   19,  417,  741,  450,
- /*   900 */    24,  958,  959,   83,   84,  369,  957,  957,  177,  226,
- /*   910 */    85,  352,  352,  884,  315,  314,  313,  215,  311,   10,
- /*   920 */    10,  683,  448,  349,  348,  958,  959,  908,  777,  157,
- /*   930 */   120,  957,  957,  337,  776,  416,  711,  310,  450,  434,
- /*   940 */   450,  321,  450,  791,  103,  200,  175,  450,  958,  959,
- /*   950 */   907,  832,  792,  452,  451,    9,    9,  819,   10,   10,
- /*   960 */    52,   52,   51,   51,  180,  716,  248,   10,   10,  171,
- /*   970 */   170,  167,  339,  958,  959,  247,  984,  702,  702,  450,
- /*   980 */   715,  233,  686,  982,  888,  983,  182,  913,  824,  824,
- /*   990 */   826,  827,   19,  183,  256,  423,  132,  181,  394,   10,
- /*  1000 */    10,  888,  890,  749,  957,  957,  916,  268,  985,  198,
- /*  1010 */   985,  349,  348,  425,  415,  299,  817,  832,  326,  825,
- /*  1020 */   120,  332,  133,  819,  268,   98,   98,   98,   98,   91,
- /*  1030 */    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
- /*  1040 */   351,  157,  810,  371,  382,  359,  958,  959,  358,  268,
- /*  1050 */   450,  917,  368,  324,  824,  824,  826,  450,  709,  450,
- /*  1060 */   264,  380,  888,  450,  876,  746,  253,  918,  255,  433,
- /*  1070 */    36,   36,  234,  450,  234,  120,  269,   37,   37,   12,
- /*  1080 */    12,  334,  272,   27,   27,  450,  330,  118,  450,  162,
- /*  1090 */   742,  280,  450,   38,   38,  450,  985,  356,  985,  450,
- /*  1100 */   709, 1209,  450,  132,  450,   39,   39,  450,   40,   40,
- /*  1110 */   450,  362,   41,   41,  450,   42,   42,  450,  254,   28,
- /*  1120 */    28,  450,   29,   29,   31,   31,  450,   43,   43,  450,
- /*  1130 */    44,   44,  450,  714,   45,   45,  450,   11,   11,  767,
- /*  1140 */   450,   46,   46,  450,  268,  450,  105,  105,  450,   47,
- /*  1150 */    47,  450,   48,   48,  450,  237,   33,   33,  450,  172,
- /*  1160 */    49,   49,  450,   50,   50,   34,   34,  274,  122,  122,
- /*  1170 */   450,  123,  123,  450,  124,  124,  450,  897,   56,   56,
- /*  1180 */   450,  896,   35,   35,  450,  267,  450,  817,  450,  817,
- /*  1190 */   106,  106,  450,   53,   53,  385,  107,  107,  450,  817,
- /*  1200 */   108,  108,  817,  450,  104,  104,  121,  121,  119,  119,
- /*  1210 */   450,  117,  112,  112,  450,  276,  450,  225,  111,  111,
- /*  1220 */   450,  730,  450,  109,  109,  450,  673,  674,  675,  911,
- /*  1230 */   110,  110,  317,  998,   55,   55,   57,   57,  692,  331,
- /*  1240 */    54,   54,   26,   26,  696,   30,   30,  317,  936,  197,
- /*  1250 */   196,  195,  335,  281,  336,  446,  331,  745,  689,  436,
- /*  1260 */   440,  444,  120,   72,  386,  223,  175,  345,  757,  932,
- /*  1270 */    20,  286,  319,  756,  815,  372,  374,  202,  202,  202,
- /*  1280 */   263,  395,  285,   74,  208,   21,  696,  719,  718,  883,
- /*  1290 */   120,  120,  120,  120,  120,  754,  278,  828,   77,   74,
- /*  1300 */   726,  727,  785,  783,  879,  202,  999,  208,  893,  892,
- /*  1310 */   893,  892,  694,  816,  763,  116,  774, 1289,  431,  432,
- /*  1320 */   302,  999,  390,  303,  823,  697,  691,  680,  159,  289,
- /*  1330 */   679,  883,  681,  951,  291,  218,  293,    7,  316,  828,
- /*  1340 */   173,  805,  259,  364,  252,  910,  376,  713,  295,  435,
- /*  1350 */   308,  168,  954,  993,  135,  400,  990,  284,  881,  880,
- /*  1360 */   205,  927,  925,   59,  333,   62,  144,  156,  130,   72,
- /*  1370 */   802,  366,  367,  393,  137,  185,  189,  160,  139,  383,
- /*  1380 */    67,  895,  140,  141,  142,  148,  389,  812,  775,  266,
- /*  1390 */   219,  190,  154,  391,  912,  875,  271,  406,  191,  322,
- /*  1400 */   682,  733,  192,  342,  732,  724,  731,  711,  723,  421,
- /*  1410 */   705,   71,  323,    6,  204,  771,  288,   79,  297,  346,
- /*  1420 */   772,  704,  290,  283,  703,  770,  292,  294,  966,  239,
- /*  1430 */   769,  102,  861,  438,  426,  240,  424,  442,   73,  213,
- /*  1440 */   688,  238,   22,  453,  952,  214,  217,  216,  454,  677,
- /*  1450 */   676,  671,  753,  125,  115,  235,  126,  669,  353,  166,
- /*  1460 */   127,  244,  179,  357,  306,  304,  305,  307,  113,  891,
- /*  1470 */   327,  889,  811,  328,  134,  128,  136,  138,  743,  258,
- /*  1480 */   906,  184,  143,  129,  909,  186,   63,   64,  145,  187,
- /*  1490 */   905,   65,    8,   66,   13,  188,  202,  898,  265,  149,
- /*  1500 */   987,  388,  150,  685,  161,  392,  285,  193,  279,  396,
- /*  1510 */   151,  401,   68,   14,   15,  722,   69,  236,  831,  131,
- /*  1520 */   830,  859,   70,  751,   16,  414,  755,    4,  174,  220,
- /*  1530 */   222,  784,  201,  152,  779,   77,   74,   17,   18,  874,
- /*  1540 */   860,  858,  915,  863,  914,  207,  206,  941,  163,  437,
- /*  1550 */   947,  942,  164,  209, 1002,  441,  862,  165,  210,  829,
- /*  1560 */   695,   87,  312,  211, 1291, 1290,  309,
+ /*     0 */   324,  410,  342,  747,  747,  203,  939,  353,  969,   98,
+ /*    10 */    98,   98,   98,   91,   96,   96,   96,   96,   95,   95,
+ /*    20 */    94,   94,   94,   93,  350, 1323,  155,  155,    2,  808,
+ /*    30 */   971,  971,   98,   98,   98,   98,   20,   96,   96,   96,
+ /*    40 */    96,   95,   95,   94,   94,   94,   93,  350,   92,   89,
+ /*    50 */   178,   99,  100,   90,  847,  850,  839,  839,   97,   97,
+ /*    60 */    98,   98,   98,   98,  350,   96,   96,   96,   96,   95,
+ /*    70 */    95,   94,   94,   94,   93,  350,  324,  339,  969,  262,
+ /*    80 */   364,  251,  212,  169,  287,  404,  282,  403,  199,  786,
+ /*    90 */   242,  411,   21,  950,  378,  280,   93,  350,  787,   95,
+ /*   100 */    95,   94,   94,   94,   93,  350,  971,  971,   96,   96,
+ /*   110 */    96,   96,   95,   95,   94,   94,   94,   93,  350,  808,
+ /*   120 */   328,  242,  411, 1235,  826, 1235,  132,   99,  100,   90,
+ /*   130 */   847,  850,  839,  839,   97,   97,   98,   98,   98,   98,
+ /*   140 */   449,   96,   96,   96,   96,   95,   95,   94,   94,   94,
+ /*   150 */    93,  350,  324,  819,  348,  347,  120,  818,  120,   75,
+ /*   160 */    52,   52,  950,  951,  952, 1084,  977,  146,  360,  262,
+ /*   170 */   369,  261,  950,  975,  954,  976,   92,   89,  178,  370,
+ /*   180 */   230,  370,  971,  971, 1141,  360,  359,  101,  818,  818,
+ /*   190 */   820,  383,   24, 1286,  380,  427,  412,  368,  978,  379,
+ /*   200 */   978, 1032,  324,   99,  100,   90,  847,  850,  839,  839,
+ /*   210 */    97,   97,   98,   98,   98,   98,  372,   96,   96,   96,
+ /*   220 */    96,   95,   95,   94,   94,   94,   93,  350,  950,  132,
+ /*   230 */   890,  449,  971,  971,  890,   60,   94,   94,   94,   93,
+ /*   240 */   350,  950,  951,  952,  954,  103,  360,  950,  384,  333,
+ /*   250 */   697,   52,   52,   99,  100,   90,  847,  850,  839,  839,
+ /*   260 */    97,   97,   98,   98,   98,   98, 1022,   96,   96,   96,
+ /*   270 */    96,   95,   95,   94,   94,   94,   93,  350,  324,  454,
+ /*   280 */   995,  449,  227,   61,  157,  243,  343,  114, 1025, 1211,
+ /*   290 */   147,  826,  950,  372, 1071,  950,  319,  950,  951,  952,
+ /*   300 */   194,   10,   10,  401,  398,  397, 1211, 1213,  971,  971,
+ /*   310 */   757,  171,  170,  157,  396,  336,  950,  951,  952,  697,
+ /*   320 */   819,  310,  153,  950,  818,  320,   82,   23,   80,   99,
+ /*   330 */   100,   90,  847,  850,  839,  839,   97,   97,   98,   98,
+ /*   340 */    98,   98,  888,   96,   96,   96,   96,   95,   95,   94,
+ /*   350 */    94,   94,   93,  350,  324,  818,  818,  820,  277,  231,
+ /*   360 */   300,  950,  951,  952,  950,  951,  952, 1211,  194,   25,
+ /*   370 */   449,  401,  398,  397,  950,  354,  300,  449,  950,   74,
+ /*   380 */   449,    1,  396,  132,  971,  971,  950,  224,  224,  808,
+ /*   390 */    10,   10,  950,  951,  952, 1290,  132,   52,   52,  414,
+ /*   400 */    52,   52, 1063, 1063,  338,   99,  100,   90,  847,  850,
+ /*   410 */   839,  839,   97,   97,   98,   98,   98,   98, 1114,   96,
+ /*   420 */    96,   96,   96,   95,   95,   94,   94,   94,   93,  350,
+ /*   430 */   324, 1113,  427,  417,  701,  427,  426, 1260, 1260,  262,
+ /*   440 */   369,  261,  950,  950,  951,  952,  752,  950,  951,  952,
+ /*   450 */   449,  751,  449, 1058, 1037,  950,  951,  952,  442,  706,
+ /*   460 */   971,  971, 1058,  393,   92,   89,  178,  446,  446,  446,
+ /*   470 */    51,   51,   52,   52,  438,  773, 1024,   92,   89,  178,
+ /*   480 */   172,   99,  100,   90,  847,  850,  839,  839,   97,   97,
+ /*   490 */    98,   98,   98,   98,  198,   96,   96,   96,   96,   95,
+ /*   500 */    95,   94,   94,   94,   93,  350,  324,  427,  407,  909,
+ /*   510 */   694,  950,  951,  952,   92,   89,  178,  224,  224,  157,
+ /*   520 */   241,  221,  418,  299,  771,  910,  415,  374,  449,  414,
+ /*   530 */    58,  323, 1061, 1061, 1242,  378,  971,  971,  378,  772,
+ /*   540 */   448,  911,  362,  735,  296,  681,    9,    9,   52,   52,
+ /*   550 */   234,  329,  234,  256,  416,  736,  280,   99,  100,   90,
+ /*   560 */   847,  850,  839,  839,   97,   97,   98,   98,   98,   98,
+ /*   570 */   449,   96,   96,   96,   96,   95,   95,   94,   94,   94,
+ /*   580 */    93,  350,  324,  422,   72,  449,  827,  120,  367,  449,
+ /*   590 */    10,   10,    5,  301,  203,  449,  177,  969,  253,  419,
+ /*   600 */   255,  771,  200,  175,  233,   10,   10,  836,  836,   36,
+ /*   610 */    36, 1289,  971,  971,  724,   37,   37,  348,  347,  424,
+ /*   620 */   203,  260,  771,  969,  232,  930, 1316,  870,  337, 1316,
+ /*   630 */   421,  848,  851,   99,  100,   90,  847,  850,  839,  839,
+ /*   640 */    97,   97,   98,   98,   98,   98,  268,   96,   96,   96,
+ /*   650 */    96,   95,   95,   94,   94,   94,   93,  350,  324,  840,
+ /*   660 */   449,  978,  813,  978, 1200,  449,  909,  969,  715,  349,
+ /*   670 */   349,  349,  928,  177,  449,  930, 1317,  254,  198, 1317,
+ /*   680 */    12,   12,  910,  402,  449,   27,   27,  250,  971,  971,
+ /*   690 */   118,  716,  162,  969,   38,   38,  268,  176,  911,  771,
+ /*   700 */   432, 1265,  939,  353,   39,   39,  316,  991,  324,   99,
+ /*   710 */   100,   90,  847,  850,  839,  839,   97,   97,   98,   98,
+ /*   720 */    98,   98,  928,   96,   96,   96,   96,   95,   95,   94,
+ /*   730 */    94,   94,   93,  350,  449,  329,  449,  357,  971,  971,
+ /*   740 */  1041,  316,  929,  340,  893,  893,  386,  669,  670,  671,
+ /*   750 */   275, 1318,  317,  992,   40,   40,   41,   41,  268,   99,
+ /*   760 */   100,   90,  847,  850,  839,  839,   97,   97,   98,   98,
+ /*   770 */    98,   98,  449,   96,   96,   96,   96,   95,   95,   94,
+ /*   780 */    94,   94,   93,  350,  324,  449,  355,  449,  992,  449,
+ /*   790 */  1016,  330,   42,   42,  786,  270,  449,  273,  449,  228,
+ /*   800 */   449,  298,  449,  787,  449,   28,   28,   29,   29,   31,
+ /*   810 */    31,  449, 1141,  449,  971,  971,   43,   43,   44,   44,
+ /*   820 */    45,   45,   11,   11,   46,   46,  887,   78,  887,  268,
+ /*   830 */   268,  105,  105,   47,   47,   99,  100,   90,  847,  850,
+ /*   840 */   839,  839,   97,   97,   98,   98,   98,   98,  449,   96,
+ /*   850 */    96,   96,   96,   95,   95,   94,   94,   94,   93,  350,
+ /*   860 */   324,  449,  117,  449, 1073,  158,  449,  691,   48,   48,
+ /*   870 */   229, 1241,  449, 1250,  449,  414,  449,  334,  449,  245,
+ /*   880 */   449,   33,   33,   49,   49,  449,   50,   50,  246, 1141,
+ /*   890 */   971,  971,   34,   34,  122,  122,  123,  123,  124,  124,
+ /*   900 */    56,   56,  268,   81,  249,   35,   35,  197,  196,  195,
+ /*   910 */   324,   99,  100,   90,  847,  850,  839,  839,   97,   97,
+ /*   920 */    98,   98,   98,   98,  449,   96,   96,   96,   96,   95,
+ /*   930 */    95,   94,   94,   94,   93,  350,  449,  691,  449, 1141,
+ /*   940 */   971,  971,  968, 1207,  106,  106,  268, 1209,  268, 1266,
+ /*   950 */     2,  886,  268,  886,  335, 1040,   53,   53,  107,  107,
+ /*   960 */   324,   99,  100,   90,  847,  850,  839,  839,   97,   97,
+ /*   970 */    98,   98,   98,   98,  449,   96,   96,   96,   96,   95,
+ /*   980 */    95,   94,   94,   94,   93,  350,  449, 1070,  449, 1066,
+ /*   990 */   971,  971, 1039,  267,  108,  108,  445,  330,  331,  133,
+ /*  1000 */   223,  175,  301,  225,  385, 1255,  104,  104,  121,  121,
+ /*  1010 */   324,   99,   88,   90,  847,  850,  839,  839,   97,   97,
+ /*  1020 */    98,   98,   98,   98, 1141,   96,   96,   96,   96,   95,
+ /*  1030 */    95,   94,   94,   94,   93,  350,  449,  346,  449,  167,
+ /*  1040 */   971,  971,  925,  810,  371,  318,  202,  202,  373,  263,
+ /*  1050 */   394,  202,   74,  208,  721,  722,  119,  119,  112,  112,
+ /*  1060 */   324,  406,  100,   90,  847,  850,  839,  839,   97,   97,
+ /*  1070 */    98,   98,   98,   98,  449,   96,   96,   96,   96,   95,
+ /*  1080 */    95,   94,   94,   94,   93,  350,  449,  752,  449,  344,
+ /*  1090 */   971,  971,  751,  278,  111,  111,   74,  714,  713,  704,
+ /*  1100 */   286,  877,  749, 1279,  257,   77,  109,  109,  110,  110,
+ /*  1110 */  1230,  285, 1134,   90,  847,  850,  839,  839,   97,   97,
+ /*  1120 */    98,   98,   98,   98, 1233,   96,   96,   96,   96,   95,
+ /*  1130 */    95,   94,   94,   94,   93,  350,   86,  444,  449,    3,
+ /*  1140 */  1193,  449, 1069,  132,  351,  120, 1013,   86,  444,  780,
+ /*  1150 */     3, 1091,  202,  376,  447,  351, 1229,  120,   55,   55,
+ /*  1160 */   449,   57,   57,  822,  873,  447,  449,  208,  449,  704,
+ /*  1170 */   449,  877,  237,  433,  435,  120,  439,  428,  361,  120,
+ /*  1180 */    54,   54,  132,  449,  433,  826,   52,   52,   26,   26,
+ /*  1190 */    30,   30,  381,  132,  408,  443,  826,  689,  264,  389,
+ /*  1200 */   116,  269,  272,   32,   32,   83,   84,  120,  274,  120,
+ /*  1210 */   120,  276,   85,  351,  451,  450,   83,   84,  818, 1054,
+ /*  1220 */  1038,  427,  429,   85,  351,  451,  450,  120,  120,  818,
+ /*  1230 */   377,  218,  281,  822, 1107, 1140,   86,  444,  409,    3,
+ /*  1240 */  1087, 1098,  430,  431,  351,  302,  303, 1146, 1021,  818,
+ /*  1250 */   818,  820,  821,   19,  447, 1015, 1004, 1003, 1005, 1273,
+ /*  1260 */   818,  818,  820,  821,   19,  289,  159,  291,  293,    7,
+ /*  1270 */   315,  173,  259,  433, 1129,  363,  252, 1232,  375, 1037,
+ /*  1280 */   295,  434,  168,  986,  399,  826,  284, 1204, 1203,  205,
+ /*  1290 */  1276,  308, 1249,   86,  444,  983,    3, 1247,  332,  144,
+ /*  1300 */   130,  351,   72,  135,   59,   83,   84,  756,  137,  365,
+ /*  1310 */  1126,  447,   85,  351,  451,  450,  139,  226,  818,  140,
+ /*  1320 */   156,   62,  314,  314,  313,  215,  311,  366,  392,  678,
+ /*  1330 */   433,  185,  141, 1234,  142,  160,  148, 1136, 1198,  382,
+ /*  1340 */   189,   67,  826,  180,  388,  248, 1218, 1099,  219,  818,
+ /*  1350 */   818,  820,  821,   19,  247,  190,  266,  154,  390,  271,
+ /*  1360 */   191,  192,   83,   84, 1006,  405, 1057,  182,  321,   85,
+ /*  1370 */   351,  451,  450, 1056,  183,  818,  341,  132,  181,  706,
+ /*  1380 */  1055,  420,   76,  444, 1029,    3,  322, 1028,  283, 1048,
+ /*  1390 */   351, 1095, 1027, 1288, 1047,   71,  204,    6,  288,  290,
+ /*  1400 */   447, 1096, 1094, 1093,   79,  292,  818,  818,  820,  821,
+ /*  1410 */    19,  294,  297,  437,  345,  441,  102, 1184, 1077,  433,
+ /*  1420 */   238,  425,   73,  305,  239,  304,  325,  240,  423,  306,
+ /*  1430 */   307,  826,  213, 1012,   22,  945,  452,  214,  216,  217,
+ /*  1440 */   453, 1001,  115,  996,  125,  126,  235,  127,  665,  352,
+ /*  1450 */   326,   83,   84,  358,  166,  244,  179,  327,   85,  351,
+ /*  1460 */   451,  450,  134,  356,  818,  113,  885,  806,  883,  136,
+ /*  1470 */   128,  138,  738,  258,  184,  899,  143,  145,   63,   64,
+ /*  1480 */    65,   66,  129,  902,  187,  186,  898,    8,   13,  188,
+ /*  1490 */   265,  891,  149,  202,  980,  818,  818,  820,  821,   19,
+ /*  1500 */   150,  387,  161,  680,  285,  391,  151,  395,  400,  193,
+ /*  1510 */    68,   14,  236,  279,   15,   69,  717,  825,  131,  824,
+ /*  1520 */   853,   70,  746,   16,  413,  750,    4,  174,  220,  222,
+ /*  1530 */   152,  779,  857,  774,  201,   77,   74,  868,   17,  854,
+ /*  1540 */   852,  908,   18,  907,  207,  206,  934,  163,  436,  210,
+ /*  1550 */   935,  164,  209,  165,  440,  856,  823,  690,   87,  211,
+ /*  1560 */   309,  312, 1281,  940, 1280,
 };
 static const YYCODETYPE yy_lookahead[] = {
- /*     0 */    19,   95,   53,   97,   22,   24,   24,  101,   27,   28,
- /*    10 */    29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
- /*    20 */    39,   40,   41,  152,   43,   44,   45,   46,   47,   48,
- /*    30 */    49,   50,   51,   52,   53,   19,   55,   55,  132,  133,
- /*    40 */   134,    1,    2,   27,   28,   29,   30,   31,   32,   33,
- /*    50 */    34,   35,   36,   37,   38,   39,   40,   41,  187,   43,
- /*    60 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
- /*    70 */    47,   48,   49,   50,   51,   52,   53,   61,   97,   97,
- /*    80 */    19,   49,   50,   51,   52,   53,   70,   26,   27,   28,
- /*    90 */    29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
- /*   100 */    39,   40,   41,  152,   43,   44,   45,   46,   47,   48,
- /*   110 */    49,   50,   51,   52,   53,  144,  145,  146,  147,   19,
- /*   120 */    16,   22,   92,  172,  173,   52,   53,   27,   28,   29,
- /*   130 */    30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
- /*   140 */    40,   41,   81,   43,   44,   45,   46,   47,   48,   49,
- /*   150 */    50,   51,   52,   53,   55,   56,   19,  152,  207,  208,
- /*   160 */   115,   24,  117,  118,   27,   28,   29,   30,   31,   32,
- /*   170 */    33,   34,   35,   36,   37,   38,   39,   40,   41,   79,
- /*   180 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   190 */    53,   19,   88,  157,   90,   23,   97,   98,  193,   27,
- /*   200 */    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
- /*   210 */    38,   39,   40,   41,  152,   43,   44,   45,   46,   47,
- /*   220 */    48,   49,   50,   51,   52,   53,   19,   22,   23,  172,
- /*   230 */    23,   26,  119,  120,   27,   28,   29,   30,   31,   32,
- /*   240 */    33,   34,   35,   36,   37,   38,   39,   40,   41,  187,
- /*   250 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   260 */    53,   19,   22,   23,  228,   23,   26,  231,  152,   27,
- /*   270 */    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
- /*   280 */    38,   39,   40,   41,  172,   43,   44,   45,   46,   47,
- /*   290 */    48,   49,   50,   51,   52,   53,   19,  221,  222,  223,
- /*   300 */    23,   96,  152,  172,   27,   28,   29,   30,   31,   32,
- /*   310 */    33,   34,   35,   36,   37,   38,   39,   40,   41,  152,
- /*   320 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   330 */    53,   19,    0,    1,    2,   23,   96,  190,  191,   27,
- /*   340 */    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
- /*   350 */    38,   39,   40,   41,  238,   43,   44,   45,   46,   47,
- /*   360 */    48,   49,   50,   51,   52,   53,   19,  185,  218,  221,
- /*   370 */   222,  223,  152,  152,   27,   28,   29,   30,   31,   32,
- /*   380 */    33,   34,   35,   36,   37,   38,   39,   40,   41,  241,
- /*   390 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   400 */    53,   19,  152,  168,  169,  170,   22,  190,  191,   27,
- /*   410 */    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
- /*   420 */    38,   39,   40,   41,  152,   43,   44,   45,   46,   47,
- /*   430 */    48,   49,   50,   51,   52,   53,   19,   19,  218,   55,
- /*   440 */    56,   24,   22,  152,   27,   28,   29,   30,   31,   32,
- /*   450 */    33,   34,   35,   36,   37,   38,   39,   40,   41,  152,
- /*   460 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   470 */    53,  250,  194,  195,   56,   55,   56,   55,   19,  172,
- /*   480 */   173,   97,   98,  152,  206,  138,   27,   28,   29,   30,
- /*   490 */    31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
- /*   500 */    41,  152,   43,   44,   45,   46,   47,   48,   49,   50,
- /*   510 */    51,   52,   53,   19,  207,  208,  152,   97,   98,   97,
- /*   520 */   138,   27,   28,   29,   30,   31,   32,   33,   34,   35,
- /*   530 */    36,   37,   38,   39,   40,   41,  181,   43,   44,   45,
- /*   540 */    46,   47,   48,   49,   50,   51,   52,   53,   19,   30,
- /*   550 */    31,   32,   33,  247,  248,   19,  152,   28,   29,   30,
- /*   560 */    31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
- /*   570 */    41,  152,   43,   44,   45,   46,   47,   48,   49,   50,
- /*   580 */    51,   52,   53,   19,  168,  169,  170,  238,   19,   53,
- /*   590 */   152,  172,  173,   29,   30,   31,   32,   33,   34,   35,
- /*   600 */    36,   37,   38,   39,   40,   41,  152,   43,   44,   45,
- /*   610 */    46,   47,   48,   49,   50,   51,   52,   53,   19,   20,
- /*   620 */   101,   22,   23,  169,  170,   56,  207,   85,   55,   56,
- /*   630 */    23,   19,   20,   26,   22,   99,  100,  101,  102,  103,
- /*   640 */   104,  105,  238,  152,  152,  210,   47,   48,  112,  152,
- /*   650 */   108,  109,  110,   54,   55,   56,  221,  222,  223,   47,
- /*   660 */    48,  119,  120,  172,  173,   66,   54,   55,   56,  152,
- /*   670 */    97,   98,   99,  148,  149,  102,  103,  104,   66,  154,
- /*   680 */    23,  156,   83,   26,  230,  152,  113,  152,  163,  194,
- /*   690 */   195,   92,   92,   30,   95,   83,   97,   98,  207,  208,
- /*   700 */   101,  206,  179,  180,   92,  172,  173,   95,  152,   97,
- /*   710 */    98,  188,   99,  101,  219,  102,  103,  104,  152,  119,
- /*   720 */   120,  196,   55,   56,   19,   20,  113,   22,  193,  163,
- /*   730 */    11,  132,  133,  134,  135,  136,   24,   65,  172,  173,
- /*   740 */   207,  208,  250,  152,  132,  133,  134,  135,  136,  193,
- /*   750 */    78,   84,   47,   48,   49,   98,  199,  152,   86,   54,
- /*   760 */    55,   56,  196,  152,   97,   98,  209,   55,  163,  244,
- /*   770 */   107,   66,  152,  207,  208,  164,  175,  172,  173,   19,
- /*   780 */    20,  124,   22,  111,   38,   39,   40,   41,   83,   43,
- /*   790 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
- /*   800 */    95,  196,   97,   98,   85,  152,  101,   47,   48,   97,
- /*   810 */    85,   92,  207,  193,   54,   55,   56,   92,   49,  175,
- /*   820 */    55,   56,  221,  222,  223,   12,   66,  108,  109,  110,
- /*   830 */   137,  163,  139,  108,  109,  110,   26,  132,  133,  134,
- /*   840 */   135,  136,  152,   83,   43,   44,   45,   46,   47,   48,
- /*   850 */    49,   50,   51,   52,   53,   95,   26,   97,   98,   55,
- /*   860 */    56,  101,   97,   98,  196,  221,  222,  223,  146,  147,
- /*   870 */    57,  171,  152,   22,   26,   19,   20,   49,   22,  179,
- /*   880 */   108,  109,  110,   55,   56,  116,   73,  219,   75,  124,
- /*   890 */   121,  152,  132,  133,  134,  135,  136,  163,   85,  152,
- /*   900 */   232,   97,   98,   47,   48,  237,   55,   56,   98,    5,
- /*   910 */    54,   55,   56,  193,   10,   11,   12,   13,   14,  172,
- /*   920 */   173,   17,   66,   47,   48,   97,   98,  152,  124,  152,
- /*   930 */   196,   55,   56,  186,  124,  152,  106,  160,  152,   83,
- /*   940 */   152,  164,  152,   61,   22,  211,  212,  152,   97,   98,
- /*   950 */   152,   95,   70,   97,   98,  172,  173,  101,  172,  173,
- /*   960 */   172,  173,  172,  173,   60,  181,   62,  172,  173,   47,
- /*   970 */    48,  123,  186,   97,   98,   71,  100,   55,   56,  152,
- /*   980 */   181,  186,   21,  107,  152,  109,   82,  163,  132,  133,
- /*   990 */   134,  135,  136,   89,   16,  207,   92,   93,   19,  172,
- /*  1000 */   173,  169,  170,  195,   55,   56,   12,  152,  132,   30,
- /*  1010 */   134,   47,   48,  186,  206,  225,  152,   95,  114,   97,
- /*  1020 */   196,  245,  246,  101,  152,   38,   39,   40,   41,   42,
- /*  1030 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*  1040 */    53,  152,  163,  219,  152,  141,   97,   98,  193,  152,
- /*  1050 */   152,   57,   91,  164,  132,  133,  134,  152,   55,  152,
- /*  1060 */   152,  237,  230,  152,  103,  193,   88,   73,   90,   75,
- /*  1070 */   172,  173,  183,  152,  185,  196,  152,  172,  173,  172,
- /*  1080 */   173,  217,  152,  172,  173,  152,  107,   22,  152,   24,
- /*  1090 */   193,  112,  152,  172,  173,  152,  132,  242,  134,  152,
- /*  1100 */    97,  140,  152,   92,  152,  172,  173,  152,  172,  173,
- /*  1110 */   152,  100,  172,  173,  152,  172,  173,  152,  140,  172,
- /*  1120 */   173,  152,  172,  173,  172,  173,  152,  172,  173,  152,
- /*  1130 */   172,  173,  152,  152,  172,  173,  152,  172,  173,  213,
- /*  1140 */   152,  172,  173,  152,  152,  152,  172,  173,  152,  172,
- /*  1150 */   173,  152,  172,  173,  152,  210,  172,  173,  152,   26,
- /*  1160 */   172,  173,  152,  172,  173,  172,  173,  152,  172,  173,
- /*  1170 */   152,  172,  173,  152,  172,  173,  152,   59,  172,  173,
- /*  1180 */   152,   63,  172,  173,  152,  193,  152,  152,  152,  152,
- /*  1190 */   172,  173,  152,  172,  173,   77,  172,  173,  152,  152,
- /*  1200 */   172,  173,  152,  152,  172,  173,  172,  173,  172,  173,
- /*  1210 */   152,   22,  172,  173,  152,  152,  152,   22,  172,  173,
- /*  1220 */   152,  152,  152,  172,  173,  152,    7,    8,    9,  163,
- /*  1230 */   172,  173,   22,   23,  172,  173,  172,  173,  166,  167,
- /*  1240 */   172,  173,  172,  173,   55,  172,  173,   22,   23,  108,
- /*  1250 */   109,  110,  217,  152,  217,  166,  167,  163,  163,  163,
- /*  1260 */   163,  163,  196,  130,  217,  211,  212,  217,  116,   23,
- /*  1270 */    22,  101,   26,  121,   23,   23,   23,   26,   26,   26,
- /*  1280 */    23,   23,  112,   26,   26,   37,   97,  100,  101,   55,
- /*  1290 */   196,  196,  196,  196,  196,   23,   23,   55,   26,   26,
- /*  1300 */     7,    8,   23,  152,   23,   26,   96,   26,  132,  132,
- /*  1310 */   134,  134,   23,  152,  152,   26,  152,  122,  152,  191,
- /*  1320 */   152,   96,  234,  152,  152,  152,  152,  152,  197,  210,
- /*  1330 */   152,   97,  152,  152,  210,  233,  210,  198,  150,   97,
- /*  1340 */   184,  201,  239,  214,  214,  201,  239,  180,  214,  227,
- /*  1350 */   200,  198,  155,   67,  243,  176,   69,  175,  175,  175,
- /*  1360 */   122,  159,  159,  240,  159,  240,   22,  220,   27,  130,
- /*  1370 */   201,   18,  159,   18,  189,  158,  158,  220,  192,  159,
- /*  1380 */   137,  236,  192,  192,  192,  189,   74,  189,  159,  235,
- /*  1390 */   159,  158,   22,  177,  201,  201,  159,  107,  158,  177,
- /*  1400 */   159,  174,  158,   76,  174,  182,  174,  106,  182,  125,
- /*  1410 */   174,  107,  177,   22,  159,  216,  215,  137,  159,   53,
- /*  1420 */   216,  176,  215,  174,  174,  216,  215,  215,  174,  229,
- /*  1430 */   216,  129,  224,  177,  126,  229,  127,  177,  128,   25,
- /*  1440 */   162,  226,   26,  161,   13,  153,    6,  153,  151,  151,
- /*  1450 */   151,  151,  205,  165,  178,  178,  165,    4,    3,   22,
- /*  1460 */   165,  142,   15,   94,  202,  204,  203,  201,   16,   23,
- /*  1470 */   249,   23,  120,  249,  246,  111,  131,  123,   20,   16,
- /*  1480 */     1,  125,  123,  111,   56,   64,   37,   37,  131,  122,
- /*  1490 */     1,   37,    5,   37,   22,  107,   26,   80,  140,   80,
- /*  1500 */    87,   72,  107,   20,   24,   19,  112,  105,   23,   79,
- /*  1510 */    22,   79,   22,   22,   22,   58,   22,   79,   23,   68,
- /*  1520 */    23,   23,   26,  116,   22,   26,   23,   22,  122,   23,
- /*  1530 */    23,   56,   64,   22,  124,   26,   26,   64,   64,   23,
- /*  1540 */    23,   23,   23,   11,   23,   22,   26,   23,   22,   24,
- /*  1550 */     1,   23,   22,   26,  251,   24,   23,   22,  122,   23,
- /*  1560 */    23,   22,   15,  122,  122,  122,   23,
+ /*     0 */    19,  115,   19,  117,  118,   24,    1,    2,   27,   79,
+ /*    10 */    80,   81,   82,   83,   84,   85,   86,   87,   88,   89,
+ /*    20 */    90,   91,   92,   93,   94,  144,  145,  146,  147,   58,
+ /*    30 */    49,   50,   79,   80,   81,   82,   22,   84,   85,   86,
+ /*    40 */    87,   88,   89,   90,   91,   92,   93,   94,  221,  222,
+ /*    50 */   223,   70,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*    60 */    79,   80,   81,   82,   94,   84,   85,   86,   87,   88,
+ /*    70 */    89,   90,   91,   92,   93,   94,   19,   94,   97,  108,
+ /*    80 */   109,  110,   99,  100,  101,  102,  103,  104,  105,   32,
+ /*    90 */   119,  120,   78,   27,  152,  112,   93,   94,   41,   88,
+ /*   100 */    89,   90,   91,   92,   93,   94,   49,   50,   84,   85,
+ /*   110 */    86,   87,   88,   89,   90,   91,   92,   93,   94,   58,
+ /*   120 */   157,  119,  120,  163,   68,  163,   65,   70,   71,   72,
+ /*   130 */    73,   74,   75,   76,   77,   78,   79,   80,   81,   82,
+ /*   140 */   152,   84,   85,   86,   87,   88,   89,   90,   91,   92,
+ /*   150 */    93,   94,   19,   97,   88,   89,  196,  101,  196,   26,
+ /*   160 */   172,  173,   96,   97,   98,  210,  100,   22,  152,  108,
+ /*   170 */   109,  110,   27,  107,   27,  109,  221,  222,  223,  219,
+ /*   180 */   238,  219,   49,   50,  152,  169,  170,   54,  132,  133,
+ /*   190 */   134,  228,  232,  171,  231,  207,  208,  237,  132,  237,
+ /*   200 */   134,  179,   19,   70,   71,   72,   73,   74,   75,   76,
+ /*   210 */    77,   78,   79,   80,   81,   82,  152,   84,   85,   86,
+ /*   220 */    87,   88,   89,   90,   91,   92,   93,   94,   27,   65,
+ /*   230 */    30,  152,   49,   50,   34,   52,   90,   91,   92,   93,
+ /*   240 */    94,   96,   97,   98,   97,   22,  230,   27,   48,  217,
+ /*   250 */    27,  172,  173,   70,   71,   72,   73,   74,   75,   76,
+ /*   260 */    77,   78,   79,   80,   81,   82,  172,   84,   85,   86,
+ /*   270 */    87,   88,   89,   90,   91,   92,   93,   94,   19,  148,
+ /*   280 */   149,  152,  218,   24,  152,  154,  207,  156,  172,  152,
+ /*   290 */    22,   68,   27,  152,  163,   27,  164,   96,   97,   98,
+ /*   300 */    99,  172,  173,  102,  103,  104,  169,  170,   49,   50,
+ /*   310 */    90,   88,   89,  152,  113,  186,   96,   97,   98,   96,
+ /*   320 */    97,  160,   57,   27,  101,  164,  137,  196,  139,   70,
+ /*   330 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,
+ /*   340 */    81,   82,   11,   84,   85,   86,   87,   88,   89,   90,
+ /*   350 */    91,   92,   93,   94,   19,  132,  133,  134,   23,  218,
+ /*   360 */   152,   96,   97,   98,   96,   97,   98,  230,   99,   22,
+ /*   370 */   152,  102,  103,  104,   27,  244,  152,  152,   27,   26,
+ /*   380 */   152,   22,  113,   65,   49,   50,   27,  194,  195,   58,
+ /*   390 */   172,  173,   96,   97,   98,  185,   65,  172,  173,  206,
+ /*   400 */   172,  173,  190,  191,  186,   70,   71,   72,   73,   74,
+ /*   410 */    75,   76,   77,   78,   79,   80,   81,   82,  175,   84,
+ /*   420 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
+ /*   430 */    19,  175,  207,  208,   23,  207,  208,  119,  120,  108,
+ /*   440 */   109,  110,   27,   96,   97,   98,  116,   96,   97,   98,
+ /*   450 */   152,  121,  152,  179,  180,   96,   97,   98,  250,  106,
+ /*   460 */    49,   50,  188,   19,  221,  222,  223,  168,  169,  170,
+ /*   470 */   172,  173,  172,  173,  250,  124,  172,  221,  222,  223,
+ /*   480 */    26,   70,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*   490 */    79,   80,   81,   82,   50,   84,   85,   86,   87,   88,
+ /*   500 */    89,   90,   91,   92,   93,   94,   19,  207,  208,   12,
+ /*   510 */    23,   96,   97,   98,  221,  222,  223,  194,  195,  152,
+ /*   520 */   199,   23,   19,  225,   26,   28,  152,  152,  152,  206,
+ /*   530 */   209,  164,  190,  191,  241,  152,   49,   50,  152,  124,
+ /*   540 */   152,   44,  219,   46,  152,   21,  172,  173,  172,  173,
+ /*   550 */   183,  107,  185,   16,  163,   58,  112,   70,   71,   72,
+ /*   560 */    73,   74,   75,   76,   77,   78,   79,   80,   81,   82,
+ /*   570 */   152,   84,   85,   86,   87,   88,   89,   90,   91,   92,
+ /*   580 */    93,   94,   19,  207,  130,  152,   23,  196,   64,  152,
+ /*   590 */   172,  173,   22,  152,   24,  152,   98,   27,   61,   96,
+ /*   600 */    63,   26,  211,  212,  186,  172,  173,   49,   50,  172,
+ /*   610 */   173,   23,   49,   50,   26,  172,  173,   88,   89,  186,
+ /*   620 */    24,  238,  124,   27,  238,   22,   23,  103,  187,   26,
+ /*   630 */   152,   73,   74,   70,   71,   72,   73,   74,   75,   76,
+ /*   640 */    77,   78,   79,   80,   81,   82,  152,   84,   85,   86,
+ /*   650 */    87,   88,   89,   90,   91,   92,   93,   94,   19,  101,
+ /*   660 */   152,  132,   23,  134,  140,  152,   12,   97,   36,  168,
+ /*   670 */   169,  170,   69,   98,  152,   22,   23,  140,   50,   26,
+ /*   680 */   172,  173,   28,   51,  152,  172,  173,  193,   49,   50,
+ /*   690 */    22,   59,   24,   97,  172,  173,  152,  152,   44,  124,
+ /*   700 */    46,    0,    1,    2,  172,  173,   22,   23,   19,   70,
+ /*   710 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,
+ /*   720 */    81,   82,   69,   84,   85,   86,   87,   88,   89,   90,
+ /*   730 */    91,   92,   93,   94,  152,  107,  152,  193,   49,   50,
+ /*   740 */   181,   22,   23,  111,  108,  109,  110,    7,    8,    9,
+ /*   750 */    16,  247,  248,   69,  172,  173,  172,  173,  152,   70,
+ /*   760 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,
+ /*   770 */    81,   82,  152,   84,   85,   86,   87,   88,   89,   90,
+ /*   780 */    91,   92,   93,   94,   19,  152,  242,  152,   69,  152,
+ /*   790 */   166,  167,  172,  173,   32,   61,  152,   63,  152,  193,
+ /*   800 */   152,  152,  152,   41,  152,  172,  173,  172,  173,  172,
+ /*   810 */   173,  152,  152,  152,   49,   50,  172,  173,  172,  173,
+ /*   820 */   172,  173,  172,  173,  172,  173,  132,  138,  134,  152,
+ /*   830 */   152,  172,  173,  172,  173,   70,   71,   72,   73,   74,
+ /*   840 */    75,   76,   77,   78,   79,   80,   81,   82,  152,   84,
+ /*   850 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
+ /*   860 */    19,  152,   22,  152,  195,   24,  152,   27,  172,  173,
+ /*   870 */   193,  193,  152,  152,  152,  206,  152,  217,  152,  152,
+ /*   880 */   152,  172,  173,  172,  173,  152,  172,  173,  152,  152,
+ /*   890 */    49,   50,  172,  173,  172,  173,  172,  173,  172,  173,
+ /*   900 */   172,  173,  152,  138,  152,  172,  173,  108,  109,  110,
+ /*   910 */    19,   70,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*   920 */    79,   80,   81,   82,  152,   84,   85,   86,   87,   88,
+ /*   930 */    89,   90,   91,   92,   93,   94,  152,   97,  152,  152,
+ /*   940 */    49,   50,   26,  193,  172,  173,  152,  152,  152,  146,
+ /*   950 */   147,  132,  152,  134,  217,  181,  172,  173,  172,  173,
+ /*   960 */    19,   70,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*   970 */    79,   80,   81,   82,  152,   84,   85,   86,   87,   88,
+ /*   980 */    89,   90,   91,   92,   93,   94,  152,  193,  152,  193,
+ /*   990 */    49,   50,  181,  193,  172,  173,  166,  167,  245,  246,
+ /*  1000 */   211,  212,  152,   22,  217,  152,  172,  173,  172,  173,
+ /*  1010 */    19,   70,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*  1020 */    79,   80,   81,   82,  152,   84,   85,   86,   87,   88,
+ /*  1030 */    89,   90,   91,   92,   93,   94,  152,  187,  152,  123,
+ /*  1040 */    49,   50,   23,   23,   23,   26,   26,   26,   23,   23,
+ /*  1050 */    23,   26,   26,   26,    7,    8,  172,  173,  172,  173,
+ /*  1060 */    19,   90,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*  1070 */    79,   80,   81,   82,  152,   84,   85,   86,   87,   88,
+ /*  1080 */    89,   90,   91,   92,   93,   94,  152,  116,  152,  217,
+ /*  1090 */    49,   50,  121,   23,  172,  173,   26,  100,  101,   27,
+ /*  1100 */   101,   27,   23,  122,  152,   26,  172,  173,  172,  173,
+ /*  1110 */   152,  112,  163,   72,   73,   74,   75,   76,   77,   78,
+ /*  1120 */    79,   80,   81,   82,  163,   84,   85,   86,   87,   88,
+ /*  1130 */    89,   90,   91,   92,   93,   94,   19,   20,  152,   22,
+ /*  1140 */    23,  152,  163,   65,   27,  196,  163,   19,   20,   23,
+ /*  1150 */    22,  213,   26,   19,   37,   27,  152,  196,  172,  173,
+ /*  1160 */   152,  172,  173,   27,   23,   37,  152,   26,  152,   97,
+ /*  1170 */   152,   97,  210,   56,  163,  196,  163,  163,  100,  196,
+ /*  1180 */   172,  173,   65,  152,   56,   68,  172,  173,  172,  173,
+ /*  1190 */   172,  173,  152,   65,  163,  163,   68,   23,  152,  234,
+ /*  1200 */    26,  152,  152,  172,  173,   88,   89,  196,  152,  196,
+ /*  1210 */   196,  152,   95,   96,   97,   98,   88,   89,  101,  152,
+ /*  1220 */   152,  207,  208,   95,   96,   97,   98,  196,  196,  101,
+ /*  1230 */    96,  233,  152,   97,  152,  152,   19,   20,  207,   22,
+ /*  1240 */   152,  152,  152,  191,   27,  152,  152,  152,  152,  132,
+ /*  1250 */   133,  134,  135,  136,   37,  152,  152,  152,  152,  152,
+ /*  1260 */   132,  133,  134,  135,  136,  210,  197,  210,  210,  198,
+ /*  1270 */   150,  184,  239,   56,  201,  214,  214,  201,  239,  180,
+ /*  1280 */   214,  227,  198,   38,  176,   68,  175,  175,  175,  122,
+ /*  1290 */   155,  200,  159,   19,   20,   40,   22,  159,  159,   22,
+ /*  1300 */    70,   27,  130,  243,  240,   88,   89,   90,  189,   18,
+ /*  1310 */   201,   37,   95,   96,   97,   98,  192,    5,  101,  192,
+ /*  1320 */   220,  240,   10,   11,   12,   13,   14,  159,   18,   17,
+ /*  1330 */    56,  158,  192,  201,  192,  220,  189,  189,  201,  159,
+ /*  1340 */   158,  137,   68,   31,   45,   33,  236,  159,  159,  132,
+ /*  1350 */   133,  134,  135,  136,   42,  158,  235,   22,  177,  159,
+ /*  1360 */   158,  158,   88,   89,  159,  107,  174,   55,  177,   95,
+ /*  1370 */    96,   97,   98,  174,   62,  101,   47,   65,   66,  106,
+ /*  1380 */   174,  125,   19,   20,  174,   22,  177,  176,  174,  182,
+ /*  1390 */    27,  216,  174,  174,  182,  107,  159,   22,  215,  215,
+ /*  1400 */    37,  216,  216,  216,  137,  215,  132,  133,  134,  135,
+ /*  1410 */   136,  215,  159,  177,   94,  177,  129,  224,  205,   56,
+ /*  1420 */   226,  126,  128,  203,  229,  204,  114,  229,  127,  202,
+ /*  1430 */   201,   68,   25,  162,   26,   13,  161,  153,  153,    6,
+ /*  1440 */   151,  151,  178,  151,  165,  165,  178,  165,    4,    3,
+ /*  1450 */   249,   88,   89,  141,   22,  142,   15,  249,   95,   96,
+ /*  1460 */    97,   98,  246,   67,  101,   16,   23,  120,   23,  131,
+ /*  1470 */   111,  123,   20,   16,  125,    1,  123,  131,   78,   78,
+ /*  1480 */    78,   78,  111,   96,  122,   35,    1,    5,   22,  107,
+ /*  1490 */   140,   53,   53,   26,   60,  132,  133,  134,  135,  136,
+ /*  1500 */   107,   43,   24,   20,  112,   19,   22,   52,   52,  105,
+ /*  1510 */    22,   22,   52,   23,   22,   22,   29,   23,   39,   23,
+ /*  1520 */    23,   26,  116,   22,   26,   23,   22,  122,   23,   23,
+ /*  1530 */    22,   96,   11,  124,   35,   26,   26,   23,   35,   23,
+ /*  1540 */    23,   23,   35,   23,   22,   26,   23,   22,   24,  122,
+ /*  1550 */    23,   22,   26,   22,   24,   23,   23,   23,   22,  122,
+ /*  1560 */    23,   15,  122,    1,  122,
 };
-#define YY_SHIFT_USE_DFLT (1567)
-#define YY_SHIFT_COUNT    (455)
-#define YY_SHIFT_MIN      (-94)
-#define YY_SHIFT_MAX      (1549)
+#define YY_SHIFT_USE_DFLT (1565)
+#define YY_SHIFT_COUNT    (454)
+#define YY_SHIFT_MIN      (-114)
+#define YY_SHIFT_MAX      (1562)
 static const short yy_shift_ofst[] = {
- /*     0 */    40,  599,  904,  612,  760,  760,  760,  760,  725,  -19,
- /*    10 */    16,   16,  100,  760,  760,  760,  760,  760,  760,  760,
- /*    20 */   876,  876,  573,  542,  719,  600,   61,  137,  172,  207,
- /*    30 */   242,  277,  312,  347,  382,  417,  459,  459,  459,  459,
- /*    40 */   459,  459,  459,  459,  459,  459,  459,  459,  459,  459,
- /*    50 */   459,  459,  459,  494,  459,  529,  564,  564,  705,  760,
- /*    60 */   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
- /*    70 */   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
- /*    80 */   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
- /*    90 */   856,  760,  760,  760,  760,  760,  760,  760,  760,  760,
- /*   100 */   760,  760,  760,  760,  987,  746,  746,  746,  746,  746,
- /*   110 */   801,   23,   32,  949,  961,  979,  964,  964,  949,   73,
- /*   120 */   113,  -51, 1567, 1567, 1567,  536,  536,  536,   99,   99,
- /*   130 */   813,  813,  667,  205,  240,  949,  949,  949,  949,  949,
- /*   140 */   949,  949,  949,  949,  949,  949,  949,  949,  949,  949,
- /*   150 */   949,  949,  949,  949,  949,  332, 1011,  422,  422,  113,
- /*   160 */    30,   30,   30,   30,   30,   30, 1567, 1567, 1567,  922,
- /*   170 */   -94,  -94,  384,  613,  828,  420,  765,  804,  851,  949,
- /*   180 */   949,  949,  949,  949,  949,  949,  949,  949,  949,  949,
- /*   190 */   949,  949,  949,  949,  949,  672,  672,  672,  949,  949,
- /*   200 */   657,  949,  949,  949,  -18,  949,  949,  994,  949,  949,
- /*   210 */   949,  949,  949,  949,  949,  949,  949,  949,  772, 1118,
- /*   220 */   712,  712,  712,  810,   45,  769, 1219, 1133,  418,  418,
- /*   230 */   569, 1133,  569,  830,  607,  663,  882,  418,  693,  882,
- /*   240 */   882,  848, 1152, 1065, 1286, 1238, 1238, 1287, 1287, 1238,
- /*   250 */  1344, 1341, 1239, 1353, 1353, 1353, 1353, 1238, 1355, 1239,
- /*   260 */  1344, 1341, 1341, 1239, 1238, 1355, 1243, 1312, 1238, 1238,
- /*   270 */  1355, 1370, 1238, 1355, 1238, 1355, 1370, 1290, 1290, 1290,
- /*   280 */  1327, 1370, 1290, 1301, 1290, 1327, 1290, 1290, 1284, 1304,
- /*   290 */  1284, 1304, 1284, 1304, 1284, 1304, 1238, 1391, 1238, 1280,
- /*   300 */  1370, 1366, 1366, 1370, 1302, 1308, 1310, 1309, 1239, 1414,
- /*   310 */  1416, 1431, 1431, 1440, 1440, 1440, 1440, 1567, 1567, 1567,
- /*   320 */  1567, 1567, 1567, 1567, 1567,  519,  978, 1210, 1225,  104,
- /*   330 */  1141, 1189, 1246, 1248, 1251, 1252, 1253, 1257, 1258, 1273,
- /*   340 */  1003, 1187, 1293, 1170, 1272, 1279, 1234, 1281, 1176, 1177,
- /*   350 */  1289, 1242, 1195, 1453, 1455, 1437, 1319, 1447, 1369, 1452,
- /*   360 */  1446, 1448, 1352, 1345, 1364, 1354, 1458, 1356, 1463, 1479,
- /*   370 */  1359, 1357, 1449, 1450, 1454, 1456, 1372, 1428, 1421, 1367,
- /*   380 */  1489, 1487, 1472, 1388, 1358, 1417, 1470, 1419, 1413, 1429,
- /*   390 */  1395, 1480, 1483, 1486, 1394, 1402, 1488, 1430, 1490, 1491,
- /*   400 */  1485, 1492, 1432, 1457, 1494, 1438, 1451, 1495, 1497, 1498,
- /*   410 */  1496, 1407, 1502, 1503, 1505, 1499, 1406, 1506, 1507, 1475,
- /*   420 */  1468, 1511, 1410, 1509, 1473, 1510, 1474, 1516, 1509, 1517,
- /*   430 */  1518, 1519, 1520, 1521, 1523, 1532, 1524, 1526, 1525, 1527,
- /*   440 */  1528, 1530, 1531, 1527, 1533, 1535, 1536, 1537, 1539, 1436,
- /*   450 */  1441, 1442, 1443, 1543, 1547, 1549,
+ /*     0 */     5, 1117, 1312, 1128, 1274, 1274, 1274, 1274,   61,  -19,
+ /*    10 */    57,   57,  183, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
+ /*    20 */    66,   66,  201,  -29,  331,  318,  133,  259,  335,  411,
+ /*    30 */   487,  563,  639,  689,  765,  841,  891,  891,  891,  891,
+ /*    40 */   891,  891,  891,  891,  891,  891,  891,  891,  891,  891,
+ /*    50 */   891,  891,  891,  941,  891,  991, 1041, 1041, 1217, 1274,
+ /*    60 */  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
+ /*    70 */  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
+ /*    80 */  1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
+ /*    90 */  1363, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274, 1274,
+ /*   100 */  1274, 1274, 1274, 1274,  -70,  -47,  -47,  -47,  -47,  -47,
+ /*   110 */    24,   11,  146,  296,  524,  444,  529,  529,  296,    3,
+ /*   120 */     2,  -30, 1565, 1565, 1565,  -17,  -17,  -17,  145,  145,
+ /*   130 */   497,  497,  265,  603,  653,  296,  296,  296,  296,  296,
+ /*   140 */   296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
+ /*   150 */   296,  296,  296,  296,  296,  701, 1078,  147,  147,    2,
+ /*   160 */   164,  164,  164,  164,  164,  164, 1565, 1565, 1565,  223,
+ /*   170 */    56,   56,  268,  269,  220,  347,  351,  415,  359,  296,
+ /*   180 */   296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
+ /*   190 */   296,  296,  296,  296,  296,  632,  632,  632,  296,  296,
+ /*   200 */   498,  296,  296,  296,  570,  296,  296,  654,  296,  296,
+ /*   210 */   296,  296,  296,  296,  296,  296,  296,  296,  636,  200,
+ /*   220 */   596,  596,  596,  575, -114,  971,  740,  454,  503,  503,
+ /*   230 */  1134,  454, 1134,  353,  588,  628,  762,  503,  189,  762,
+ /*   240 */   762,  916,  330,  668, 1245, 1167, 1167, 1255, 1255, 1167,
+ /*   250 */  1277, 1230, 1172, 1291, 1291, 1291, 1291, 1167, 1310, 1172,
+ /*   260 */  1277, 1230, 1230, 1172, 1167, 1310, 1204, 1299, 1167, 1167,
+ /*   270 */  1310, 1335, 1167, 1310, 1167, 1310, 1335, 1258, 1258, 1258,
+ /*   280 */  1329, 1335, 1258, 1273, 1258, 1329, 1258, 1258, 1256, 1288,
+ /*   290 */  1256, 1288, 1256, 1288, 1256, 1288, 1167, 1375, 1167, 1267,
+ /*   300 */  1335, 1320, 1320, 1335, 1287, 1295, 1294, 1301, 1172, 1407,
+ /*   310 */  1408, 1422, 1422, 1433, 1433, 1433, 1565, 1565, 1565, 1565,
+ /*   320 */  1565, 1565, 1565, 1565,  558,  537,  684,  719,  734,  799,
+ /*   330 */   840, 1019,   14, 1020, 1021, 1025, 1026, 1027, 1070, 1072,
+ /*   340 */   997, 1047,  999, 1079, 1126, 1074, 1141,  694,  819, 1174,
+ /*   350 */  1136,  981, 1444, 1446, 1432, 1313, 1441, 1396, 1449, 1443,
+ /*   360 */  1445, 1347, 1338, 1359, 1348, 1452, 1349, 1457, 1474, 1353,
+ /*   370 */  1346, 1400, 1401, 1402, 1403, 1371, 1387, 1450, 1362, 1485,
+ /*   380 */  1482, 1466, 1382, 1350, 1438, 1467, 1439, 1434, 1458, 1393,
+ /*   390 */  1478, 1483, 1486, 1392, 1404, 1484, 1455, 1488, 1489, 1490,
+ /*   400 */  1492, 1456, 1487, 1493, 1460, 1479, 1494, 1496, 1497, 1495,
+ /*   410 */  1406, 1501, 1502, 1504, 1498, 1405, 1505, 1506, 1435, 1499,
+ /*   420 */  1508, 1409, 1509, 1503, 1510, 1507, 1514, 1509, 1516, 1517,
+ /*   430 */  1518, 1519, 1520, 1522, 1521, 1523, 1525, 1524, 1526, 1527,
+ /*   440 */  1529, 1530, 1526, 1532, 1531, 1533, 1534, 1536, 1427, 1437,
+ /*   450 */  1440, 1442, 1537, 1546, 1562,
 };
-#define YY_REDUCE_USE_DFLT (-130)
-#define YY_REDUCE_COUNT (324)
-#define YY_REDUCE_MIN   (-129)
-#define YY_REDUCE_MAX   (1300)
+#define YY_REDUCE_USE_DFLT (-174)
+#define YY_REDUCE_COUNT (323)
+#define YY_REDUCE_MIN   (-173)
+#define YY_REDUCE_MAX   (1292)
 static const short yy_reduce_ofst[] = {
- /*     0 */   -29,  566,  525,  605,  -49,  307,  491,  533,  668,  435,
- /*    10 */   601,  644,  148,  747,  786,  795,  419,  788,  827,  790,
- /*    20 */   454,  832,  889,  495,  824,  734,   76,   76,   76,   76,
- /*    30 */    76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
- /*    40 */    76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
- /*    50 */    76,   76,   76,   76,   76,   76,   76,   76,  783,  898,
- /*    60 */   905,  907,  911,  921,  933,  936,  940,  943,  947,  950,
- /*    70 */   952,  955,  958,  962,  965,  969,  974,  977,  980,  984,
- /*    80 */   988,  991,  993,  996,  999, 1002, 1006, 1010, 1018, 1021,
- /*    90 */  1024, 1028, 1032, 1034, 1036, 1040, 1046, 1051, 1058, 1062,
- /*   100 */  1064, 1068, 1070, 1073,   76,   76,   76,   76,   76,   76,
- /*   110 */    76,   76,   76,  855,   36,  523,  235,  416,  777,   76,
- /*   120 */   278,   76,   76,   76,   76,  700,  700,  700,  150,  220,
- /*   130 */   147,  217,  221,  306,  306,  611,    5,  535,  556,  620,
- /*   140 */   720,  872,  897,  116,  864,  349, 1035, 1037,  404, 1047,
- /*   150 */   992, -129, 1050,  492,   62,  722,  879, 1072, 1089,  808,
- /*   160 */  1066, 1094, 1095, 1096, 1097, 1098,  776, 1054,  557,   57,
- /*   170 */   112,  131,  167,  182,  250,  272,  291,  331,  364,  438,
- /*   180 */   497,  517,  591,  653,  690,  739,  775,  798,  892,  908,
- /*   190 */   924,  930, 1015, 1063, 1069,  355,  784,  799,  981, 1101,
- /*   200 */   926, 1151, 1161, 1162,  945, 1164, 1166, 1128, 1168, 1171,
- /*   210 */  1172,  250, 1173, 1174, 1175, 1178, 1180, 1181, 1088, 1102,
- /*   220 */  1119, 1124, 1126,  926, 1131, 1139, 1188, 1140, 1129, 1130,
- /*   230 */  1103, 1144, 1107, 1179, 1156, 1167, 1182, 1134, 1122, 1183,
- /*   240 */  1184, 1150, 1153, 1197, 1111, 1202, 1203, 1123, 1125, 1205,
- /*   250 */  1147, 1185, 1169, 1186, 1190, 1191, 1192, 1213, 1217, 1193,
- /*   260 */  1157, 1196, 1198, 1194, 1220, 1218, 1145, 1154, 1229, 1231,
- /*   270 */  1233, 1216, 1237, 1240, 1241, 1244, 1222, 1227, 1230, 1232,
- /*   280 */  1223, 1235, 1236, 1245, 1249, 1226, 1250, 1254, 1199, 1201,
- /*   290 */  1204, 1207, 1209, 1211, 1214, 1212, 1255, 1208, 1259, 1215,
- /*   300 */  1256, 1200, 1206, 1260, 1247, 1261, 1263, 1262, 1266, 1278,
- /*   310 */  1282, 1292, 1294, 1297, 1298, 1299, 1300, 1221, 1224, 1228,
- /*   320 */  1288, 1291, 1276, 1277, 1295,
+ /*     0 */  -119, 1014,  131, 1031,  -12,  225,  228,  300,  -40,  -45,
+ /*    10 */   243,  256,  293,  129,  218,  418,   79,  376,  433,  298,
+ /*    20 */    16,  137,  367,  323,  -38,  391, -173, -173, -173, -173,
+ /*    30 */  -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+ /*    40 */  -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+ /*    50 */  -173, -173, -173, -173, -173, -173, -173, -173,  374,  437,
+ /*    60 */   443,  508,  513,  522,  532,  582,  584,  620,  633,  635,
+ /*    70 */   637,  644,  646,  648,  650,  652,  659,  661,  696,  709,
+ /*    80 */   711,  714,  720,  722,  724,  726,  728,  733,  772,  784,
+ /*    90 */   786,  822,  834,  836,  884,  886,  922,  934,  936,  986,
+ /*   100 */   989, 1008, 1016, 1018, -173, -173, -173, -173, -173, -173,
+ /*   110 */  -173, -173, -173,  544,  -37,  274,  299,  501,  161, -173,
+ /*   120 */   193, -173, -173, -173, -173,   22,   22,   22,   64,  141,
+ /*   130 */   212,  342,  208,  504,  504,  132,  494,  606,  677,  678,
+ /*   140 */   750,  794,  796,  -58,   32,  383,  660,  737,  386,  787,
+ /*   150 */   800,  441,  872,  224,  850,  803,  949,  624,  830,  669,
+ /*   160 */   961,  979,  983, 1011, 1013, 1032,  753,  789,  321,   94,
+ /*   170 */   116,  304,  375,  210,  388,  392,  478,  545,  649,  721,
+ /*   180 */   727,  736,  752,  795,  853,  952,  958, 1004, 1040, 1046,
+ /*   190 */  1049, 1050, 1056, 1059, 1067,  559,  774,  811, 1068, 1080,
+ /*   200 */   938, 1082, 1083, 1088,  962, 1089, 1090, 1052, 1093, 1094,
+ /*   210 */  1095,  388, 1096, 1103, 1104, 1105, 1106, 1107,  965,  998,
+ /*   220 */  1055, 1057, 1058,  938, 1069, 1071, 1120, 1073, 1061, 1062,
+ /*   230 */  1033, 1076, 1039, 1108, 1087, 1099, 1111, 1066, 1054, 1112,
+ /*   240 */  1113, 1091, 1084, 1135, 1060, 1133, 1138, 1064, 1081, 1139,
+ /*   250 */  1100, 1119, 1109, 1124, 1127, 1140, 1142, 1168, 1173, 1132,
+ /*   260 */  1115, 1147, 1148, 1137, 1180, 1182, 1110, 1121, 1188, 1189,
+ /*   270 */  1197, 1181, 1200, 1202, 1205, 1203, 1191, 1192, 1199, 1206,
+ /*   280 */  1207, 1209, 1210, 1211, 1214, 1212, 1218, 1219, 1175, 1183,
+ /*   290 */  1185, 1184, 1186, 1190, 1187, 1196, 1237, 1193, 1253, 1194,
+ /*   300 */  1236, 1195, 1198, 1238, 1213, 1221, 1220, 1227, 1229, 1271,
+ /*   310 */  1275, 1284, 1285, 1289, 1290, 1292, 1201, 1208, 1216, 1279,
+ /*   320 */  1280, 1264, 1268, 1282,
 };
 static const YYACTIONTYPE yy_default[] = {
- /*     0 */  1280, 1270, 1270, 1270, 1202, 1202, 1202, 1202, 1270, 1096,
- /*    10 */  1125, 1125, 1254, 1332, 1332, 1332, 1332, 1332, 1332, 1201,
- /*    20 */  1332, 1332, 1332, 1332, 1270, 1100, 1131, 1332, 1332, 1332,
- /*    30 */  1332, 1203, 1204, 1332, 1332, 1332, 1253, 1255, 1141, 1140,
- /*    40 */  1139, 1138, 1236, 1112, 1136, 1129, 1133, 1203, 1197, 1198,
- /*    50 */  1196, 1200, 1204, 1332, 1132, 1167, 1181, 1166, 1332, 1332,
- /*    60 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*    70 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*    80 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*    90 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   100 */  1332, 1332, 1332, 1332, 1175, 1180, 1187, 1179, 1176, 1169,
- /*   110 */  1168, 1170, 1171, 1332, 1019, 1067, 1332, 1332, 1332, 1172,
- /*   120 */  1332, 1173, 1184, 1183, 1182, 1261, 1288, 1287, 1332, 1332,
- /*   130 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   140 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   150 */  1332, 1332, 1332, 1332, 1332, 1280, 1270, 1025, 1025, 1332,
- /*   160 */  1270, 1270, 1270, 1270, 1270, 1270, 1266, 1100, 1091, 1332,
- /*   170 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   180 */  1258, 1256, 1332, 1217, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   190 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   200 */  1332, 1332, 1332, 1332, 1096, 1332, 1332, 1332, 1332, 1332,
- /*   210 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1282, 1332, 1231,
- /*   220 */  1096, 1096, 1096, 1098, 1080, 1090, 1004, 1135, 1114, 1114,
- /*   230 */  1321, 1135, 1321, 1042, 1302, 1039, 1125, 1114, 1199, 1125,
- /*   240 */  1125, 1097, 1090, 1332, 1324, 1105, 1105, 1323, 1323, 1105,
- /*   250 */  1146, 1070, 1135, 1076, 1076, 1076, 1076, 1105, 1016, 1135,
- /*   260 */  1146, 1070, 1070, 1135, 1105, 1016, 1235, 1318, 1105, 1105,
- /*   270 */  1016, 1210, 1105, 1016, 1105, 1016, 1210, 1068, 1068, 1068,
- /*   280 */  1057, 1210, 1068, 1042, 1068, 1057, 1068, 1068, 1118, 1113,
- /*   290 */  1118, 1113, 1118, 1113, 1118, 1113, 1105, 1205, 1105, 1332,
- /*   300 */  1210, 1214, 1214, 1210, 1130, 1119, 1128, 1126, 1135, 1022,
- /*   310 */  1060, 1285, 1285, 1281, 1281, 1281, 1281, 1329, 1329, 1266,
- /*   320 */  1297, 1297, 1044, 1044, 1297, 1332, 1332, 1332, 1332, 1332,
- /*   330 */  1332, 1292, 1332, 1219, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   340 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   350 */  1332, 1332, 1152, 1332, 1000, 1263, 1332, 1332, 1262, 1332,
- /*   360 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   370 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1320,
- /*   380 */  1332, 1332, 1332, 1332, 1332, 1332, 1234, 1233, 1332, 1332,
- /*   390 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   400 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
- /*   410 */  1332, 1082, 1332, 1332, 1332, 1306, 1332, 1332, 1332, 1332,
- /*   420 */  1332, 1332, 1332, 1127, 1332, 1120, 1332, 1332, 1311, 1332,
- /*   430 */  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1272,
- /*   440 */  1332, 1332, 1332, 1271, 1332, 1332, 1332, 1332, 1332, 1154,
- /*   450 */  1332, 1153, 1157, 1332, 1010, 1332,
+ /*     0 */  1270, 1260, 1260, 1260, 1193, 1193, 1193, 1193, 1260, 1088,
+ /*    10 */  1117, 1117, 1244, 1322, 1322, 1322, 1322, 1322, 1322, 1192,
+ /*    20 */  1322, 1322, 1322, 1322, 1260, 1092, 1123, 1322, 1322, 1322,
+ /*    30 */  1322, 1194, 1195, 1322, 1322, 1322, 1243, 1245, 1133, 1132,
+ /*    40 */  1131, 1130, 1226, 1104, 1128, 1121, 1125, 1194, 1188, 1189,
+ /*    50 */  1187, 1191, 1195, 1322, 1124, 1158, 1172, 1157, 1322, 1322,
+ /*    60 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*    70 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*    80 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*    90 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   100 */  1322, 1322, 1322, 1322, 1166, 1171, 1178, 1170, 1167, 1160,
+ /*   110 */  1159, 1161, 1162, 1322, 1011, 1059, 1322, 1322, 1322, 1163,
+ /*   120 */  1322, 1164, 1175, 1174, 1173, 1251, 1278, 1277, 1322, 1322,
+ /*   130 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   140 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   150 */  1322, 1322, 1322, 1322, 1322, 1270, 1260, 1017, 1017, 1322,
+ /*   160 */  1260, 1260, 1260, 1260, 1260, 1260, 1256, 1092, 1083, 1322,
+ /*   170 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   180 */  1248, 1246, 1322, 1208, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   190 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   200 */  1322, 1322, 1322, 1322, 1088, 1322, 1322, 1322, 1322, 1322,
+ /*   210 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1272, 1322, 1221,
+ /*   220 */  1088, 1088, 1088, 1090, 1072, 1082,  997, 1127, 1106, 1106,
+ /*   230 */  1311, 1127, 1311, 1034, 1292, 1031, 1117, 1106, 1190, 1117,
+ /*   240 */  1117, 1089, 1082, 1322, 1314, 1097, 1097, 1313, 1313, 1097,
+ /*   250 */  1138, 1062, 1127, 1068, 1068, 1068, 1068, 1097, 1008, 1127,
+ /*   260 */  1138, 1062, 1062, 1127, 1097, 1008, 1225, 1308, 1097, 1097,
+ /*   270 */  1008, 1201, 1097, 1008, 1097, 1008, 1201, 1060, 1060, 1060,
+ /*   280 */  1049, 1201, 1060, 1034, 1060, 1049, 1060, 1060, 1110, 1105,
+ /*   290 */  1110, 1105, 1110, 1105, 1110, 1105, 1097, 1196, 1097, 1322,
+ /*   300 */  1201, 1205, 1205, 1201, 1122, 1111, 1120, 1118, 1127, 1014,
+ /*   310 */  1052, 1275, 1275, 1271, 1271, 1271, 1319, 1319, 1256, 1287,
+ /*   320 */  1287, 1036, 1036, 1287, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   330 */  1282, 1322, 1210, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   340 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   350 */  1322, 1143, 1322,  993, 1253, 1322, 1322, 1252, 1322, 1322,
+ /*   360 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   370 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1310, 1322,
+ /*   380 */  1322, 1322, 1322, 1322, 1322, 1224, 1223, 1322, 1322, 1322,
+ /*   390 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   400 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   410 */  1074, 1322, 1322, 1322, 1296, 1322, 1322, 1322, 1322, 1322,
+ /*   420 */  1322, 1322, 1119, 1322, 1112, 1322, 1322, 1301, 1322, 1322,
+ /*   430 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1262, 1322,
+ /*   440 */  1322, 1322, 1261, 1322, 1322, 1322, 1322, 1322, 1145, 1322,
+ /*   450 */  1144, 1148, 1322, 1002, 1322,
 };
 /********** End of lemon-generated parsing tables *****************************/
 
@@ -135702,100 +137415,73 @@ static const YYACTIONTYPE yy_default[] = {
 static const YYCODETYPE yyFallback[] = {
     0,  /*          $ => nothing */
     0,  /*       SEMI => nothing */
-   55,  /*    EXPLAIN => ID */
-   55,  /*      QUERY => ID */
-   55,  /*       PLAN => ID */
-   55,  /*      BEGIN => ID */
+   27,  /*    EXPLAIN => ID */
+   27,  /*      QUERY => ID */
+   27,  /*       PLAN => ID */
+   27,  /*      BEGIN => ID */
     0,  /* TRANSACTION => nothing */
-   55,  /*   DEFERRED => ID */
-   55,  /*  IMMEDIATE => ID */
-   55,  /*  EXCLUSIVE => ID */
+   27,  /*   DEFERRED => ID */
+   27,  /*  IMMEDIATE => ID */
+   27,  /*  EXCLUSIVE => ID */
     0,  /*     COMMIT => nothing */
-   55,  /*        END => ID */
-   55,  /*   ROLLBACK => ID */
-   55,  /*  SAVEPOINT => ID */
-   55,  /*    RELEASE => ID */
+   27,  /*        END => ID */
+   27,  /*   ROLLBACK => ID */
+   27,  /*  SAVEPOINT => ID */
+   27,  /*    RELEASE => ID */
     0,  /*         TO => nothing */
     0,  /*      TABLE => nothing */
     0,  /*     CREATE => nothing */
-   55,  /*         IF => ID */
+   27,  /*         IF => ID */
     0,  /*        NOT => nothing */
     0,  /*     EXISTS => nothing */
-   55,  /*       TEMP => ID */
+   27,  /*       TEMP => ID */
     0,  /*         LP => nothing */
     0,  /*         RP => nothing */
     0,  /*         AS => nothing */
-   55,  /*    WITHOUT => ID */
+   27,  /*    WITHOUT => ID */
     0,  /*      COMMA => nothing */
-    0,  /*         OR => nothing */
-    0,  /*        AND => nothing */
-    0,  /*         IS => nothing */
-   55,  /*      MATCH => ID */
-   55,  /*    LIKE_KW => ID */
-    0,  /*    BETWEEN => nothing */
-    0,  /*         IN => nothing */
-    0,  /*     ISNULL => nothing */
-    0,  /*    NOTNULL => nothing */
-    0,  /*         NE => nothing */
-    0,  /*         EQ => nothing */
-    0,  /*         GT => nothing */
-    0,  /*         LE => nothing */
-    0,  /*         LT => nothing */
-    0,  /*         GE => nothing */
-    0,  /*     ESCAPE => nothing */
-    0,  /*     BITAND => nothing */
-    0,  /*      BITOR => nothing */
-    0,  /*     LSHIFT => nothing */
-    0,  /*     RSHIFT => nothing */
-    0,  /*       PLUS => nothing */
-    0,  /*      MINUS => nothing */
-    0,  /*       STAR => nothing */
-    0,  /*      SLASH => nothing */
-    0,  /*        REM => nothing */
-    0,  /*     CONCAT => nothing */
-    0,  /*    COLLATE => nothing */
-    0,  /*     BITNOT => nothing */
     0,  /*         ID => nothing */
-    0,  /*    INDEXED => nothing */
-   55,  /*      ABORT => ID */
-   55,  /*     ACTION => ID */
-   55,  /*      AFTER => ID */
-   55,  /*    ANALYZE => ID */
-   55,  /*        ASC => ID */
-   55,  /*     ATTACH => ID */
-   55,  /*     BEFORE => ID */
-   55,  /*         BY => ID */
-   55,  /*    CASCADE => ID */
-   55,  /*       CAST => ID */
-   55,  /*   COLUMNKW => ID */
-   55,  /*   CONFLICT => ID */
-   55,  /*   DATABASE => ID */
-   55,  /*       DESC => ID */
-   55,  /*     DETACH => ID */
-   55,  /*       EACH => ID */
-   55,  /*       FAIL => ID */
-   55,  /*        FOR => ID */
-   55,  /*     IGNORE => ID */
-   55,  /*  INITIALLY => ID */
-   55,  /*    INSTEAD => ID */
-   55,  /*         NO => ID */
-   55,  /*        KEY => ID */
-   55,  /*         OF => ID */
-   55,  /*     OFFSET => ID */
-   55,  /*     PRAGMA => ID */
-   55,  /*      RAISE => ID */
-   55,  /*  RECURSIVE => ID */
-   55,  /*    REPLACE => ID */
-   55,  /*   RESTRICT => ID */
-   55,  /*        ROW => ID */
-   55,  /*    TRIGGER => ID */
-   55,  /*     VACUUM => ID */
-   55,  /*       VIEW => ID */
-   55,  /*    VIRTUAL => ID */
-   55,  /*       WITH => ID */
-   55,  /*    REINDEX => ID */
-   55,  /*     RENAME => ID */
-   55,  /*   CTIME_KW => ID */
+   27,  /*      ABORT => ID */
+   27,  /*     ACTION => ID */
+   27,  /*      AFTER => ID */
+   27,  /*    ANALYZE => ID */
+   27,  /*        ASC => ID */
+   27,  /*     ATTACH => ID */
+   27,  /*     BEFORE => ID */
+   27,  /*         BY => ID */
+   27,  /*    CASCADE => ID */
+   27,  /*       CAST => ID */
+   27,  /*   COLUMNKW => ID */
+   27,  /*   CONFLICT => ID */
+   27,  /*   DATABASE => ID */
+   27,  /*       DESC => ID */
+   27,  /*     DETACH => ID */
+   27,  /*       EACH => ID */
+   27,  /*       FAIL => ID */
+   27,  /*        FOR => ID */
+   27,  /*     IGNORE => ID */
+   27,  /*  INITIALLY => ID */
+   27,  /*    INSTEAD => ID */
+   27,  /*    LIKE_KW => ID */
+   27,  /*      MATCH => ID */
+   27,  /*         NO => ID */
+   27,  /*        KEY => ID */
+   27,  /*         OF => ID */
+   27,  /*     OFFSET => ID */
+   27,  /*     PRAGMA => ID */
+   27,  /*      RAISE => ID */
+   27,  /*  RECURSIVE => ID */
+   27,  /*    REPLACE => ID */
+   27,  /*   RESTRICT => ID */
+   27,  /*        ROW => ID */
+   27,  /*    TRIGGER => ID */
+   27,  /*     VACUUM => ID */
+   27,  /*       VIEW => ID */
+   27,  /*    VIRTUAL => ID */
+   27,  /*       WITH => ID */
+   27,  /*    REINDEX => ID */
+   27,  /*     RENAME => ID */
+   27,  /*   CTIME_KW => ID */
 };
 #endif /* YYFALLBACK */
 
@@ -135841,6 +137527,7 @@ struct yyParser {
   yyStackEntry yystk0;          /* First stack entry */
 #else
   yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
+  yyStackEntry *yystackEnd;            /* Last entry in the stack */
 #endif
 };
 typedef struct yyParser yyParser;
@@ -135887,25 +137574,25 @@ static const char *const yyTokenName[] = {
   "ROLLBACK",      "SAVEPOINT",     "RELEASE",       "TO",          
   "TABLE",         "CREATE",        "IF",            "NOT",         
   "EXISTS",        "TEMP",          "LP",            "RP",          
-  "AS",            "WITHOUT",       "COMMA",         "OR",          
-  "AND",           "IS",            "MATCH",         "LIKE_KW",     
-  "BETWEEN",       "IN",            "ISNULL",        "NOTNULL",     
-  "NE",            "EQ",            "GT",            "LE",          
-  "LT",            "GE",            "ESCAPE",        "BITAND",      
-  "BITOR",         "LSHIFT",        "RSHIFT",        "PLUS",        
-  "MINUS",         "STAR",          "SLASH",         "REM",         
-  "CONCAT",        "COLLATE",       "BITNOT",        "ID",          
-  "INDEXED",       "ABORT",         "ACTION",        "AFTER",       
-  "ANALYZE",       "ASC",           "ATTACH",        "BEFORE",      
-  "BY",            "CASCADE",       "CAST",          "COLUMNKW",    
-  "CONFLICT",      "DATABASE",      "DESC",          "DETACH",      
-  "EACH",          "FAIL",          "FOR",           "IGNORE",      
-  "INITIALLY",     "INSTEAD",       "NO",            "KEY",         
-  "OF",            "OFFSET",        "PRAGMA",        "RAISE",       
-  "RECURSIVE",     "REPLACE",       "RESTRICT",      "ROW",         
-  "TRIGGER",       "VACUUM",        "VIEW",          "VIRTUAL",     
-  "WITH",          "REINDEX",       "RENAME",        "CTIME_KW",    
-  "ANY",           "STRING",        "JOIN_KW",       "CONSTRAINT",  
+  "AS",            "WITHOUT",       "COMMA",         "ID",          
+  "ABORT",         "ACTION",        "AFTER",         "ANALYZE",     
+  "ASC",           "ATTACH",        "BEFORE",        "BY",          
+  "CASCADE",       "CAST",          "COLUMNKW",      "CONFLICT",    
+  "DATABASE",      "DESC",          "DETACH",        "EACH",        
+  "FAIL",          "FOR",           "IGNORE",        "INITIALLY",   
+  "INSTEAD",       "LIKE_KW",       "MATCH",         "NO",          
+  "KEY",           "OF",            "OFFSET",        "PRAGMA",      
+  "RAISE",         "RECURSIVE",     "REPLACE",       "RESTRICT",    
+  "ROW",           "TRIGGER",       "VACUUM",        "VIEW",        
+  "VIRTUAL",       "WITH",          "REINDEX",       "RENAME",      
+  "CTIME_KW",      "ANY",           "OR",            "AND",         
+  "IS",            "BETWEEN",       "IN",            "ISNULL",      
+  "NOTNULL",       "NE",            "EQ",            "GT",          
+  "LE",            "LT",            "GE",            "ESCAPE",      
+  "BITAND",        "BITOR",         "LSHIFT",        "RSHIFT",      
+  "PLUS",          "MINUS",         "STAR",          "SLASH",       
+  "REM",           "CONCAT",        "COLLATE",       "BITNOT",      
+  "INDEXED",       "STRING",        "JOIN_KW",       "CONSTRAINT",  
   "DEFAULT",       "NULL",          "PRIMARY",       "UNIQUE",      
   "CHECK",         "REFERENCES",    "AUTOINCR",      "ON",          
   "INSERT",        "DELETE",        "UPDATE",        "SET",         
@@ -135959,330 +137646,327 @@ static const char *const yyRuleName[] = {
  /*   5 */ "transtype ::= DEFERRED",
  /*   6 */ "transtype ::= IMMEDIATE",
  /*   7 */ "transtype ::= EXCLUSIVE",
- /*   8 */ "cmd ::= COMMIT trans_opt",
- /*   9 */ "cmd ::= END trans_opt",
- /*  10 */ "cmd ::= ROLLBACK trans_opt",
- /*  11 */ "cmd ::= SAVEPOINT nm",
- /*  12 */ "cmd ::= RELEASE savepoint_opt nm",
- /*  13 */ "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm",
- /*  14 */ "create_table ::= createkw temp TABLE ifnotexists nm dbnm",
- /*  15 */ "createkw ::= CREATE",
- /*  16 */ "ifnotexists ::=",
- /*  17 */ "ifnotexists ::= IF NOT EXISTS",
- /*  18 */ "temp ::= TEMP",
- /*  19 */ "temp ::=",
- /*  20 */ "create_table_args ::= LP columnlist conslist_opt RP table_options",
- /*  21 */ "create_table_args ::= AS select",
- /*  22 */ "table_options ::=",
- /*  23 */ "table_options ::= WITHOUT nm",
- /*  24 */ "columnname ::= nm typetoken",
- /*  25 */ "typetoken ::=",
- /*  26 */ "typetoken ::= typename LP signed RP",
- /*  27 */ "typetoken ::= typename LP signed COMMA signed RP",
- /*  28 */ "typename ::= typename ID|STRING",
- /*  29 */ "ccons ::= CONSTRAINT nm",
- /*  30 */ "ccons ::= DEFAULT term",
- /*  31 */ "ccons ::= DEFAULT LP expr RP",
- /*  32 */ "ccons ::= DEFAULT PLUS term",
- /*  33 */ "ccons ::= DEFAULT MINUS term",
- /*  34 */ "ccons ::= DEFAULT ID|INDEXED",
- /*  35 */ "ccons ::= NOT NULL onconf",
- /*  36 */ "ccons ::= PRIMARY KEY sortorder onconf autoinc",
- /*  37 */ "ccons ::= UNIQUE onconf",
- /*  38 */ "ccons ::= CHECK LP expr RP",
- /*  39 */ "ccons ::= REFERENCES nm eidlist_opt refargs",
- /*  40 */ "ccons ::= defer_subclause",
- /*  41 */ "ccons ::= COLLATE ID|STRING",
- /*  42 */ "autoinc ::=",
- /*  43 */ "autoinc ::= AUTOINCR",
- /*  44 */ "refargs ::=",
- /*  45 */ "refargs ::= refargs refarg",
- /*  46 */ "refarg ::= MATCH nm",
- /*  47 */ "refarg ::= ON INSERT refact",
- /*  48 */ "refarg ::= ON DELETE refact",
- /*  49 */ "refarg ::= ON UPDATE refact",
- /*  50 */ "refact ::= SET NULL",
- /*  51 */ "refact ::= SET DEFAULT",
- /*  52 */ "refact ::= CASCADE",
- /*  53 */ "refact ::= RESTRICT",
- /*  54 */ "refact ::= NO ACTION",
- /*  55 */ "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
- /*  56 */ "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
- /*  57 */ "init_deferred_pred_opt ::=",
- /*  58 */ "init_deferred_pred_opt ::= INITIALLY DEFERRED",
- /*  59 */ "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
- /*  60 */ "conslist_opt ::=",
- /*  61 */ "tconscomma ::= COMMA",
- /*  62 */ "tcons ::= CONSTRAINT nm",
- /*  63 */ "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
- /*  64 */ "tcons ::= UNIQUE LP sortlist RP onconf",
- /*  65 */ "tcons ::= CHECK LP expr RP onconf",
- /*  66 */ "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
- /*  67 */ "defer_subclause_opt ::=",
- /*  68 */ "onconf ::=",
- /*  69 */ "onconf ::= ON CONFLICT resolvetype",
- /*  70 */ "orconf ::=",
- /*  71 */ "orconf ::= OR resolvetype",
- /*  72 */ "resolvetype ::= IGNORE",
- /*  73 */ "resolvetype ::= REPLACE",
- /*  74 */ "cmd ::= DROP TABLE ifexists fullname",
- /*  75 */ "ifexists ::= IF EXISTS",
- /*  76 */ "ifexists ::=",
- /*  77 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
- /*  78 */ "cmd ::= DROP VIEW ifexists fullname",
- /*  79 */ "cmd ::= select",
- /*  80 */ "select ::= with selectnowith",
- /*  81 */ "selectnowith ::= selectnowith multiselect_op oneselect",
- /*  82 */ "multiselect_op ::= UNION",
- /*  83 */ "multiselect_op ::= UNION ALL",
- /*  84 */ "multiselect_op ::= EXCEPT|INTERSECT",
- /*  85 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",
- /*  86 */ "values ::= VALUES LP nexprlist RP",
- /*  87 */ "values ::= values COMMA LP exprlist RP",
- /*  88 */ "distinct ::= DISTINCT",
- /*  89 */ "distinct ::= ALL",
- /*  90 */ "distinct ::=",
- /*  91 */ "sclp ::=",
- /*  92 */ "selcollist ::= sclp expr as",
- /*  93 */ "selcollist ::= sclp STAR",
- /*  94 */ "selcollist ::= sclp nm DOT STAR",
- /*  95 */ "as ::= AS nm",
- /*  96 */ "as ::=",
- /*  97 */ "from ::=",
- /*  98 */ "from ::= FROM seltablist",
- /*  99 */ "stl_prefix ::= seltablist joinop",
- /* 100 */ "stl_prefix ::=",
- /* 101 */ "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
- /* 102 */ "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
- /* 103 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
- /* 104 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
- /* 105 */ "dbnm ::=",
- /* 106 */ "dbnm ::= DOT nm",
- /* 107 */ "fullname ::= nm dbnm",
- /* 108 */ "joinop ::= COMMA|JOIN",
- /* 109 */ "joinop ::= JOIN_KW JOIN",
- /* 110 */ "joinop ::= JOIN_KW nm JOIN",
- /* 111 */ "joinop ::= JOIN_KW nm nm JOIN",
- /* 112 */ "on_opt ::= ON expr",
- /* 113 */ "on_opt ::=",
- /* 114 */ "indexed_opt ::=",
- /* 115 */ "indexed_opt ::= INDEXED BY nm",
- /* 116 */ "indexed_opt ::= NOT INDEXED",
- /* 117 */ "using_opt ::= USING LP idlist RP",
- /* 118 */ "using_opt ::=",
- /* 119 */ "orderby_opt ::=",
- /* 120 */ "orderby_opt ::= ORDER BY sortlist",
- /* 121 */ "sortlist ::= sortlist COMMA expr sortorder",
- /* 122 */ "sortlist ::= expr sortorder",
- /* 123 */ "sortorder ::= ASC",
- /* 124 */ "sortorder ::= DESC",
- /* 125 */ "sortorder ::=",
- /* 126 */ "groupby_opt ::=",
- /* 127 */ "groupby_opt ::= GROUP BY nexprlist",
- /* 128 */ "having_opt ::=",
- /* 129 */ "having_opt ::= HAVING expr",
- /* 130 */ "limit_opt ::=",
- /* 131 */ "limit_opt ::= LIMIT expr",
- /* 132 */ "limit_opt ::= LIMIT expr OFFSET expr",
- /* 133 */ "limit_opt ::= LIMIT expr COMMA expr",
- /* 134 */ "cmd ::= with DELETE FROM fullname indexed_opt where_opt",
- /* 135 */ "where_opt ::=",
- /* 136 */ "where_opt ::= WHERE expr",
- /* 137 */ "cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt",
- /* 138 */ "setlist ::= setlist COMMA nm EQ expr",
- /* 139 */ "setlist ::= setlist COMMA LP idlist RP EQ expr",
- /* 140 */ "setlist ::= nm EQ expr",
- /* 141 */ "setlist ::= LP idlist RP EQ expr",
- /* 142 */ "cmd ::= with insert_cmd INTO fullname idlist_opt select",
- /* 143 */ "cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES",
- /* 144 */ "insert_cmd ::= INSERT orconf",
- /* 145 */ "insert_cmd ::= REPLACE",
- /* 146 */ "idlist_opt ::=",
- /* 147 */ "idlist_opt ::= LP idlist RP",
- /* 148 */ "idlist ::= idlist COMMA nm",
- /* 149 */ "idlist ::= nm",
- /* 150 */ "expr ::= LP expr RP",
- /* 151 */ "term ::= NULL",
- /* 152 */ "expr ::= ID|INDEXED",
- /* 153 */ "expr ::= JOIN_KW",
- /* 154 */ "expr ::= nm DOT nm",
- /* 155 */ "expr ::= nm DOT nm DOT nm",
- /* 156 */ "term ::= FLOAT|BLOB",
- /* 157 */ "term ::= STRING",
- /* 158 */ "term ::= INTEGER",
- /* 159 */ "expr ::= VARIABLE",
- /* 160 */ "expr ::= expr COLLATE ID|STRING",
- /* 161 */ "expr ::= CAST LP expr AS typetoken RP",
- /* 162 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
- /* 163 */ "expr ::= ID|INDEXED LP STAR RP",
- /* 164 */ "term ::= CTIME_KW",
- /* 165 */ "expr ::= LP nexprlist COMMA expr RP",
- /* 166 */ "expr ::= expr AND expr",
- /* 167 */ "expr ::= expr OR expr",
- /* 168 */ "expr ::= expr LT|GT|GE|LE expr",
- /* 169 */ "expr ::= expr EQ|NE expr",
- /* 170 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
- /* 171 */ "expr ::= expr PLUS|MINUS expr",
- /* 172 */ "expr ::= expr STAR|SLASH|REM expr",
- /* 173 */ "expr ::= expr CONCAT expr",
- /* 174 */ "likeop ::= NOT LIKE_KW|MATCH",
- /* 175 */ "expr ::= expr likeop expr",
- /* 176 */ "expr ::= expr likeop expr ESCAPE expr",
- /* 177 */ "expr ::= expr ISNULL|NOTNULL",
- /* 178 */ "expr ::= expr NOT NULL",
- /* 179 */ "expr ::= expr IS expr",
- /* 180 */ "expr ::= expr IS NOT expr",
- /* 181 */ "expr ::= NOT expr",
- /* 182 */ "expr ::= BITNOT expr",
- /* 183 */ "expr ::= MINUS expr",
- /* 184 */ "expr ::= PLUS expr",
- /* 185 */ "between_op ::= BETWEEN",
- /* 186 */ "between_op ::= NOT BETWEEN",
- /* 187 */ "expr ::= expr between_op expr AND expr",
- /* 188 */ "in_op ::= IN",
- /* 189 */ "in_op ::= NOT IN",
- /* 190 */ "expr ::= expr in_op LP exprlist RP",
- /* 191 */ "expr ::= LP select RP",
- /* 192 */ "expr ::= expr in_op LP select RP",
- /* 193 */ "expr ::= expr in_op nm dbnm paren_exprlist",
- /* 194 */ "expr ::= EXISTS LP select RP",
- /* 195 */ "expr ::= CASE case_operand case_exprlist case_else END",
- /* 196 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
- /* 197 */ "case_exprlist ::= WHEN expr THEN expr",
- /* 198 */ "case_else ::= ELSE expr",
- /* 199 */ "case_else ::=",
- /* 200 */ "case_operand ::= expr",
- /* 201 */ "case_operand ::=",
- /* 202 */ "exprlist ::=",
- /* 203 */ "nexprlist ::= nexprlist COMMA expr",
- /* 204 */ "nexprlist ::= expr",
- /* 205 */ "paren_exprlist ::=",
- /* 206 */ "paren_exprlist ::= LP exprlist RP",
- /* 207 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
- /* 208 */ "uniqueflag ::= UNIQUE",
- /* 209 */ "uniqueflag ::=",
- /* 210 */ "eidlist_opt ::=",
- /* 211 */ "eidlist_opt ::= LP eidlist RP",
- /* 212 */ "eidlist ::= eidlist COMMA nm collate sortorder",
- /* 213 */ "eidlist ::= nm collate sortorder",
- /* 214 */ "collate ::=",
- /* 215 */ "collate ::= COLLATE ID|STRING",
- /* 216 */ "cmd ::= DROP INDEX ifexists fullname",
- /* 217 */ "cmd ::= VACUUM",
- /* 218 */ "cmd ::= VACUUM nm",
- /* 219 */ "cmd ::= PRAGMA nm dbnm",
- /* 220 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
- /* 221 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
- /* 222 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
- /* 223 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
- /* 224 */ "plus_num ::= PLUS INTEGER|FLOAT",
- /* 225 */ "minus_num ::= MINUS INTEGER|FLOAT",
- /* 226 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
- /* 227 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
- /* 228 */ "trigger_time ::= BEFORE",
- /* 229 */ "trigger_time ::= AFTER",
- /* 230 */ "trigger_time ::= INSTEAD OF",
- /* 231 */ "trigger_time ::=",
- /* 232 */ "trigger_event ::= DELETE|INSERT",
- /* 233 */ "trigger_event ::= UPDATE",
- /* 234 */ "trigger_event ::= UPDATE OF idlist",
- /* 235 */ "when_clause ::=",
- /* 236 */ "when_clause ::= WHEN expr",
- /* 237 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
- /* 238 */ "trigger_cmd_list ::= trigger_cmd SEMI",
- /* 239 */ "trnm ::= nm DOT nm",
- /* 240 */ "tridxby ::= INDEXED BY nm",
- /* 241 */ "tridxby ::= NOT INDEXED",
- /* 242 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt",
- /* 243 */ "trigger_cmd ::= insert_cmd INTO trnm idlist_opt select",
- /* 244 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt",
- /* 245 */ "trigger_cmd ::= select",
- /* 246 */ "expr ::= RAISE LP IGNORE RP",
- /* 247 */ "expr ::= RAISE LP raisetype COMMA nm RP",
- /* 248 */ "raisetype ::= ROLLBACK",
- /* 249 */ "raisetype ::= ABORT",
- /* 250 */ "raisetype ::= FAIL",
- /* 251 */ "cmd ::= DROP TRIGGER ifexists fullname",
- /* 252 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
- /* 253 */ "cmd ::= DETACH database_kw_opt expr",
- /* 254 */ "key_opt ::=",
- /* 255 */ "key_opt ::= KEY expr",
- /* 256 */ "cmd ::= REINDEX",
- /* 257 */ "cmd ::= REINDEX nm dbnm",
- /* 258 */ "cmd ::= ANALYZE",
- /* 259 */ "cmd ::= ANALYZE nm dbnm",
- /* 260 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
- /* 261 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",
- /* 262 */ "add_column_fullname ::= fullname",
- /* 263 */ "cmd ::= create_vtab",
- /* 264 */ "cmd ::= create_vtab LP vtabarglist RP",
- /* 265 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
- /* 266 */ "vtabarg ::=",
- /* 267 */ "vtabargtoken ::= ANY",
- /* 268 */ "vtabargtoken ::= lp anylist RP",
- /* 269 */ "lp ::= LP",
- /* 270 */ "with ::=",
- /* 271 */ "with ::= WITH wqlist",
- /* 272 */ "with ::= WITH RECURSIVE wqlist",
- /* 273 */ "wqlist ::= nm eidlist_opt AS LP select RP",
- /* 274 */ "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
- /* 275 */ "input ::= cmdlist",
- /* 276 */ "cmdlist ::= cmdlist ecmd",
- /* 277 */ "cmdlist ::= ecmd",
- /* 278 */ "ecmd ::= SEMI",
- /* 279 */ "ecmd ::= explain cmdx SEMI",
- /* 280 */ "explain ::=",
- /* 281 */ "trans_opt ::=",
- /* 282 */ "trans_opt ::= TRANSACTION",
- /* 283 */ "trans_opt ::= TRANSACTION nm",
- /* 284 */ "savepoint_opt ::= SAVEPOINT",
- /* 285 */ "savepoint_opt ::=",
- /* 286 */ "cmd ::= create_table create_table_args",
- /* 287 */ "columnlist ::= columnlist COMMA columnname carglist",
- /* 288 */ "columnlist ::= columnname carglist",
- /* 289 */ "nm ::= ID|INDEXED",
- /* 290 */ "nm ::= STRING",
- /* 291 */ "nm ::= JOIN_KW",
- /* 292 */ "typetoken ::= typename",
- /* 293 */ "typename ::= ID|STRING",
- /* 294 */ "signed ::= plus_num",
- /* 295 */ "signed ::= minus_num",
- /* 296 */ "carglist ::= carglist ccons",
- /* 297 */ "carglist ::=",
- /* 298 */ "ccons ::= NULL onconf",
- /* 299 */ "conslist_opt ::= COMMA conslist",
- /* 300 */ "conslist ::= conslist tconscomma tcons",
- /* 301 */ "conslist ::= tcons",
- /* 302 */ "tconscomma ::=",
- /* 303 */ "defer_subclause_opt ::= defer_subclause",
- /* 304 */ "resolvetype ::= raisetype",
- /* 305 */ "selectnowith ::= oneselect",
- /* 306 */ "oneselect ::= values",
- /* 307 */ "sclp ::= selcollist COMMA",
- /* 308 */ "as ::= ID|STRING",
- /* 309 */ "expr ::= term",
- /* 310 */ "likeop ::= LIKE_KW|MATCH",
- /* 311 */ "exprlist ::= nexprlist",
- /* 312 */ "nmnum ::= plus_num",
- /* 313 */ "nmnum ::= nm",
- /* 314 */ "nmnum ::= ON",
- /* 315 */ "nmnum ::= DELETE",
- /* 316 */ "nmnum ::= DEFAULT",
- /* 317 */ "plus_num ::= INTEGER|FLOAT",
- /* 318 */ "foreach_clause ::=",
- /* 319 */ "foreach_clause ::= FOR EACH ROW",
- /* 320 */ "trnm ::= nm",
- /* 321 */ "tridxby ::=",
- /* 322 */ "database_kw_opt ::= DATABASE",
- /* 323 */ "database_kw_opt ::=",
- /* 324 */ "kwcolumn_opt ::=",
- /* 325 */ "kwcolumn_opt ::= COLUMNKW",
- /* 326 */ "vtabarglist ::= vtabarg",
- /* 327 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
- /* 328 */ "vtabarg ::= vtabarg vtabargtoken",
- /* 329 */ "anylist ::=",
- /* 330 */ "anylist ::= anylist LP anylist RP",
- /* 331 */ "anylist ::= anylist ANY",
+ /*   8 */ "cmd ::= COMMIT|END trans_opt",
+ /*   9 */ "cmd ::= ROLLBACK trans_opt",
+ /*  10 */ "cmd ::= SAVEPOINT nm",
+ /*  11 */ "cmd ::= RELEASE savepoint_opt nm",
+ /*  12 */ "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm",
+ /*  13 */ "create_table ::= createkw temp TABLE ifnotexists nm dbnm",
+ /*  14 */ "createkw ::= CREATE",
+ /*  15 */ "ifnotexists ::=",
+ /*  16 */ "ifnotexists ::= IF NOT EXISTS",
+ /*  17 */ "temp ::= TEMP",
+ /*  18 */ "temp ::=",
+ /*  19 */ "create_table_args ::= LP columnlist conslist_opt RP table_options",
+ /*  20 */ "create_table_args ::= AS select",
+ /*  21 */ "table_options ::=",
+ /*  22 */ "table_options ::= WITHOUT nm",
+ /*  23 */ "columnname ::= nm typetoken",
+ /*  24 */ "typetoken ::=",
+ /*  25 */ "typetoken ::= typename LP signed RP",
+ /*  26 */ "typetoken ::= typename LP signed COMMA signed RP",
+ /*  27 */ "typename ::= typename ID|STRING",
+ /*  28 */ "ccons ::= CONSTRAINT nm",
+ /*  29 */ "ccons ::= DEFAULT term",
+ /*  30 */ "ccons ::= DEFAULT LP expr RP",
+ /*  31 */ "ccons ::= DEFAULT PLUS term",
+ /*  32 */ "ccons ::= DEFAULT MINUS term",
+ /*  33 */ "ccons ::= DEFAULT ID|INDEXED",
+ /*  34 */ "ccons ::= NOT NULL onconf",
+ /*  35 */ "ccons ::= PRIMARY KEY sortorder onconf autoinc",
+ /*  36 */ "ccons ::= UNIQUE onconf",
+ /*  37 */ "ccons ::= CHECK LP expr RP",
+ /*  38 */ "ccons ::= REFERENCES nm eidlist_opt refargs",
+ /*  39 */ "ccons ::= defer_subclause",
+ /*  40 */ "ccons ::= COLLATE ID|STRING",
+ /*  41 */ "autoinc ::=",
+ /*  42 */ "autoinc ::= AUTOINCR",
+ /*  43 */ "refargs ::=",
+ /*  44 */ "refargs ::= refargs refarg",
+ /*  45 */ "refarg ::= MATCH nm",
+ /*  46 */ "refarg ::= ON INSERT refact",
+ /*  47 */ "refarg ::= ON DELETE refact",
+ /*  48 */ "refarg ::= ON UPDATE refact",
+ /*  49 */ "refact ::= SET NULL",
+ /*  50 */ "refact ::= SET DEFAULT",
+ /*  51 */ "refact ::= CASCADE",
+ /*  52 */ "refact ::= RESTRICT",
+ /*  53 */ "refact ::= NO ACTION",
+ /*  54 */ "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
+ /*  55 */ "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
+ /*  56 */ "init_deferred_pred_opt ::=",
+ /*  57 */ "init_deferred_pred_opt ::= INITIALLY DEFERRED",
+ /*  58 */ "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
+ /*  59 */ "conslist_opt ::=",
+ /*  60 */ "tconscomma ::= COMMA",
+ /*  61 */ "tcons ::= CONSTRAINT nm",
+ /*  62 */ "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
+ /*  63 */ "tcons ::= UNIQUE LP sortlist RP onconf",
+ /*  64 */ "tcons ::= CHECK LP expr RP onconf",
+ /*  65 */ "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
+ /*  66 */ "defer_subclause_opt ::=",
+ /*  67 */ "onconf ::=",
+ /*  68 */ "onconf ::= ON CONFLICT resolvetype",
+ /*  69 */ "orconf ::=",
+ /*  70 */ "orconf ::= OR resolvetype",
+ /*  71 */ "resolvetype ::= IGNORE",
+ /*  72 */ "resolvetype ::= REPLACE",
+ /*  73 */ "cmd ::= DROP TABLE ifexists fullname",
+ /*  74 */ "ifexists ::= IF EXISTS",
+ /*  75 */ "ifexists ::=",
+ /*  76 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
+ /*  77 */ "cmd ::= DROP VIEW ifexists fullname",
+ /*  78 */ "cmd ::= select",
+ /*  79 */ "select ::= with selectnowith",
+ /*  80 */ "selectnowith ::= selectnowith multiselect_op oneselect",
+ /*  81 */ "multiselect_op ::= UNION",
+ /*  82 */ "multiselect_op ::= UNION ALL",
+ /*  83 */ "multiselect_op ::= EXCEPT|INTERSECT",
+ /*  84 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",
+ /*  85 */ "values ::= VALUES LP nexprlist RP",
+ /*  86 */ "values ::= values COMMA LP exprlist RP",
+ /*  87 */ "distinct ::= DISTINCT",
+ /*  88 */ "distinct ::= ALL",
+ /*  89 */ "distinct ::=",
+ /*  90 */ "sclp ::=",
+ /*  91 */ "selcollist ::= sclp expr as",
+ /*  92 */ "selcollist ::= sclp STAR",
+ /*  93 */ "selcollist ::= sclp nm DOT STAR",
+ /*  94 */ "as ::= AS nm",
+ /*  95 */ "as ::=",
+ /*  96 */ "from ::=",
+ /*  97 */ "from ::= FROM seltablist",
+ /*  98 */ "stl_prefix ::= seltablist joinop",
+ /*  99 */ "stl_prefix ::=",
+ /* 100 */ "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
+ /* 101 */ "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
+ /* 102 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
+ /* 103 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
+ /* 104 */ "dbnm ::=",
+ /* 105 */ "dbnm ::= DOT nm",
+ /* 106 */ "fullname ::= nm dbnm",
+ /* 107 */ "joinop ::= COMMA|JOIN",
+ /* 108 */ "joinop ::= JOIN_KW JOIN",
+ /* 109 */ "joinop ::= JOIN_KW nm JOIN",
+ /* 110 */ "joinop ::= JOIN_KW nm nm JOIN",
+ /* 111 */ "on_opt ::= ON expr",
+ /* 112 */ "on_opt ::=",
+ /* 113 */ "indexed_opt ::=",
+ /* 114 */ "indexed_opt ::= INDEXED BY nm",
+ /* 115 */ "indexed_opt ::= NOT INDEXED",
+ /* 116 */ "using_opt ::= USING LP idlist RP",
+ /* 117 */ "using_opt ::=",
+ /* 118 */ "orderby_opt ::=",
+ /* 119 */ "orderby_opt ::= ORDER BY sortlist",
+ /* 120 */ "sortlist ::= sortlist COMMA expr sortorder",
+ /* 121 */ "sortlist ::= expr sortorder",
+ /* 122 */ "sortorder ::= ASC",
+ /* 123 */ "sortorder ::= DESC",
+ /* 124 */ "sortorder ::=",
+ /* 125 */ "groupby_opt ::=",
+ /* 126 */ "groupby_opt ::= GROUP BY nexprlist",
+ /* 127 */ "having_opt ::=",
+ /* 128 */ "having_opt ::= HAVING expr",
+ /* 129 */ "limit_opt ::=",
+ /* 130 */ "limit_opt ::= LIMIT expr",
+ /* 131 */ "limit_opt ::= LIMIT expr OFFSET expr",
+ /* 132 */ "limit_opt ::= LIMIT expr COMMA expr",
+ /* 133 */ "cmd ::= with DELETE FROM fullname indexed_opt where_opt",
+ /* 134 */ "where_opt ::=",
+ /* 135 */ "where_opt ::= WHERE expr",
+ /* 136 */ "cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt",
+ /* 137 */ "setlist ::= setlist COMMA nm EQ expr",
+ /* 138 */ "setlist ::= setlist COMMA LP idlist RP EQ expr",
+ /* 139 */ "setlist ::= nm EQ expr",
+ /* 140 */ "setlist ::= LP idlist RP EQ expr",
+ /* 141 */ "cmd ::= with insert_cmd INTO fullname idlist_opt select",
+ /* 142 */ "cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES",
+ /* 143 */ "insert_cmd ::= INSERT orconf",
+ /* 144 */ "insert_cmd ::= REPLACE",
+ /* 145 */ "idlist_opt ::=",
+ /* 146 */ "idlist_opt ::= LP idlist RP",
+ /* 147 */ "idlist ::= idlist COMMA nm",
+ /* 148 */ "idlist ::= nm",
+ /* 149 */ "expr ::= LP expr RP",
+ /* 150 */ "expr ::= ID|INDEXED",
+ /* 151 */ "expr ::= JOIN_KW",
+ /* 152 */ "expr ::= nm DOT nm",
+ /* 153 */ "expr ::= nm DOT nm DOT nm",
+ /* 154 */ "term ::= NULL|FLOAT|BLOB",
+ /* 155 */ "term ::= STRING",
+ /* 156 */ "term ::= INTEGER",
+ /* 157 */ "expr ::= VARIABLE",
+ /* 158 */ "expr ::= expr COLLATE ID|STRING",
+ /* 159 */ "expr ::= CAST LP expr AS typetoken RP",
+ /* 160 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
+ /* 161 */ "expr ::= ID|INDEXED LP STAR RP",
+ /* 162 */ "term ::= CTIME_KW",
+ /* 163 */ "expr ::= LP nexprlist COMMA expr RP",
+ /* 164 */ "expr ::= expr AND expr",
+ /* 165 */ "expr ::= expr OR expr",
+ /* 166 */ "expr ::= expr LT|GT|GE|LE expr",
+ /* 167 */ "expr ::= expr EQ|NE expr",
+ /* 168 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
+ /* 169 */ "expr ::= expr PLUS|MINUS expr",
+ /* 170 */ "expr ::= expr STAR|SLASH|REM expr",
+ /* 171 */ "expr ::= expr CONCAT expr",
+ /* 172 */ "likeop ::= NOT LIKE_KW|MATCH",
+ /* 173 */ "expr ::= expr likeop expr",
+ /* 174 */ "expr ::= expr likeop expr ESCAPE expr",
+ /* 175 */ "expr ::= expr ISNULL|NOTNULL",
+ /* 176 */ "expr ::= expr NOT NULL",
+ /* 177 */ "expr ::= expr IS expr",
+ /* 178 */ "expr ::= expr IS NOT expr",
+ /* 179 */ "expr ::= NOT expr",
+ /* 180 */ "expr ::= BITNOT expr",
+ /* 181 */ "expr ::= MINUS expr",
+ /* 182 */ "expr ::= PLUS expr",
+ /* 183 */ "between_op ::= BETWEEN",
+ /* 184 */ "between_op ::= NOT BETWEEN",
+ /* 185 */ "expr ::= expr between_op expr AND expr",
+ /* 186 */ "in_op ::= IN",
+ /* 187 */ "in_op ::= NOT IN",
+ /* 188 */ "expr ::= expr in_op LP exprlist RP",
+ /* 189 */ "expr ::= LP select RP",
+ /* 190 */ "expr ::= expr in_op LP select RP",
+ /* 191 */ "expr ::= expr in_op nm dbnm paren_exprlist",
+ /* 192 */ "expr ::= EXISTS LP select RP",
+ /* 193 */ "expr ::= CASE case_operand case_exprlist case_else END",
+ /* 194 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
+ /* 195 */ "case_exprlist ::= WHEN expr THEN expr",
+ /* 196 */ "case_else ::= ELSE expr",
+ /* 197 */ "case_else ::=",
+ /* 198 */ "case_operand ::= expr",
+ /* 199 */ "case_operand ::=",
+ /* 200 */ "exprlist ::=",
+ /* 201 */ "nexprlist ::= nexprlist COMMA expr",
+ /* 202 */ "nexprlist ::= expr",
+ /* 203 */ "paren_exprlist ::=",
+ /* 204 */ "paren_exprlist ::= LP exprlist RP",
+ /* 205 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
+ /* 206 */ "uniqueflag ::= UNIQUE",
+ /* 207 */ "uniqueflag ::=",
+ /* 208 */ "eidlist_opt ::=",
+ /* 209 */ "eidlist_opt ::= LP eidlist RP",
+ /* 210 */ "eidlist ::= eidlist COMMA nm collate sortorder",
+ /* 211 */ "eidlist ::= nm collate sortorder",
+ /* 212 */ "collate ::=",
+ /* 213 */ "collate ::= COLLATE ID|STRING",
+ /* 214 */ "cmd ::= DROP INDEX ifexists fullname",
+ /* 215 */ "cmd ::= VACUUM",
+ /* 216 */ "cmd ::= VACUUM nm",
+ /* 217 */ "cmd ::= PRAGMA nm dbnm",
+ /* 218 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
+ /* 219 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
+ /* 220 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
+ /* 221 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
+ /* 222 */ "plus_num ::= PLUS INTEGER|FLOAT",
+ /* 223 */ "minus_num ::= MINUS INTEGER|FLOAT",
+ /* 224 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
+ /* 225 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
+ /* 226 */ "trigger_time ::= BEFORE|AFTER",
+ /* 227 */ "trigger_time ::= INSTEAD OF",
+ /* 228 */ "trigger_time ::=",
+ /* 229 */ "trigger_event ::= DELETE|INSERT",
+ /* 230 */ "trigger_event ::= UPDATE",
+ /* 231 */ "trigger_event ::= UPDATE OF idlist",
+ /* 232 */ "when_clause ::=",
+ /* 233 */ "when_clause ::= WHEN expr",
+ /* 234 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
+ /* 235 */ "trigger_cmd_list ::= trigger_cmd SEMI",
+ /* 236 */ "trnm ::= nm DOT nm",
+ /* 237 */ "tridxby ::= INDEXED BY nm",
+ /* 238 */ "tridxby ::= NOT INDEXED",
+ /* 239 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt",
+ /* 240 */ "trigger_cmd ::= insert_cmd INTO trnm idlist_opt select",
+ /* 241 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt",
+ /* 242 */ "trigger_cmd ::= select",
+ /* 243 */ "expr ::= RAISE LP IGNORE RP",
+ /* 244 */ "expr ::= RAISE LP raisetype COMMA nm RP",
+ /* 245 */ "raisetype ::= ROLLBACK",
+ /* 246 */ "raisetype ::= ABORT",
+ /* 247 */ "raisetype ::= FAIL",
+ /* 248 */ "cmd ::= DROP TRIGGER ifexists fullname",
+ /* 249 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
+ /* 250 */ "cmd ::= DETACH database_kw_opt expr",
+ /* 251 */ "key_opt ::=",
+ /* 252 */ "key_opt ::= KEY expr",
+ /* 253 */ "cmd ::= REINDEX",
+ /* 254 */ "cmd ::= REINDEX nm dbnm",
+ /* 255 */ "cmd ::= ANALYZE",
+ /* 256 */ "cmd ::= ANALYZE nm dbnm",
+ /* 257 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
+ /* 258 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",
+ /* 259 */ "add_column_fullname ::= fullname",
+ /* 260 */ "cmd ::= create_vtab",
+ /* 261 */ "cmd ::= create_vtab LP vtabarglist RP",
+ /* 262 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
+ /* 263 */ "vtabarg ::=",
+ /* 264 */ "vtabargtoken ::= ANY",
+ /* 265 */ "vtabargtoken ::= lp anylist RP",
+ /* 266 */ "lp ::= LP",
+ /* 267 */ "with ::=",
+ /* 268 */ "with ::= WITH wqlist",
+ /* 269 */ "with ::= WITH RECURSIVE wqlist",
+ /* 270 */ "wqlist ::= nm eidlist_opt AS LP select RP",
+ /* 271 */ "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
+ /* 272 */ "input ::= cmdlist",
+ /* 273 */ "cmdlist ::= cmdlist ecmd",
+ /* 274 */ "cmdlist ::= ecmd",
+ /* 275 */ "ecmd ::= SEMI",
+ /* 276 */ "ecmd ::= explain cmdx SEMI",
+ /* 277 */ "explain ::=",
+ /* 278 */ "trans_opt ::=",
+ /* 279 */ "trans_opt ::= TRANSACTION",
+ /* 280 */ "trans_opt ::= TRANSACTION nm",
+ /* 281 */ "savepoint_opt ::= SAVEPOINT",
+ /* 282 */ "savepoint_opt ::=",
+ /* 283 */ "cmd ::= create_table create_table_args",
+ /* 284 */ "columnlist ::= columnlist COMMA columnname carglist",
+ /* 285 */ "columnlist ::= columnname carglist",
+ /* 286 */ "nm ::= ID|INDEXED",
+ /* 287 */ "nm ::= STRING",
+ /* 288 */ "nm ::= JOIN_KW",
+ /* 289 */ "typetoken ::= typename",
+ /* 290 */ "typename ::= ID|STRING",
+ /* 291 */ "signed ::= plus_num",
+ /* 292 */ "signed ::= minus_num",
+ /* 293 */ "carglist ::= carglist ccons",
+ /* 294 */ "carglist ::=",
+ /* 295 */ "ccons ::= NULL onconf",
+ /* 296 */ "conslist_opt ::= COMMA conslist",
+ /* 297 */ "conslist ::= conslist tconscomma tcons",
+ /* 298 */ "conslist ::= tcons",
+ /* 299 */ "tconscomma ::=",
+ /* 300 */ "defer_subclause_opt ::= defer_subclause",
+ /* 301 */ "resolvetype ::= raisetype",
+ /* 302 */ "selectnowith ::= oneselect",
+ /* 303 */ "oneselect ::= values",
+ /* 304 */ "sclp ::= selcollist COMMA",
+ /* 305 */ "as ::= ID|STRING",
+ /* 306 */ "expr ::= term",
+ /* 307 */ "likeop ::= LIKE_KW|MATCH",
+ /* 308 */ "exprlist ::= nexprlist",
+ /* 309 */ "nmnum ::= plus_num",
+ /* 310 */ "nmnum ::= nm",
+ /* 311 */ "nmnum ::= ON",
+ /* 312 */ "nmnum ::= DELETE",
+ /* 313 */ "nmnum ::= DEFAULT",
+ /* 314 */ "plus_num ::= INTEGER|FLOAT",
+ /* 315 */ "foreach_clause ::=",
+ /* 316 */ "foreach_clause ::= FOR EACH ROW",
+ /* 317 */ "trnm ::= nm",
+ /* 318 */ "tridxby ::=",
+ /* 319 */ "database_kw_opt ::= DATABASE",
+ /* 320 */ "database_kw_opt ::=",
+ /* 321 */ "kwcolumn_opt ::=",
+ /* 322 */ "kwcolumn_opt ::= COLUMNKW",
+ /* 323 */ "vtabarglist ::= vtabarg",
+ /* 324 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
+ /* 325 */ "vtabarg ::= vtabarg vtabargtoken",
+ /* 326 */ "anylist ::=",
+ /* 327 */ "anylist ::= anylist LP anylist RP",
+ /* 328 */ "anylist ::= anylist ANY",
 };
 #endif /* NDEBUG */
 
@@ -136351,6 +138035,9 @@ SQLITE_PRIVATE void sqlite3ParserInit(void *yypParser){
   pParser->yytos = pParser->yystack;
   pParser->yystack[0].stateno = 0;
   pParser->yystack[0].major = 0;
+#if YYSTACKDEPTH>0
+  pParser->yystackEnd = &pParser->yystack[YYSTACKDEPTH-1];
+#endif
 }
 
 #ifndef sqlite3Parser_ENGINEALWAYSONSTACK
@@ -136693,7 +138380,7 @@ static void yy_shift(
   }
 #endif
 #if YYSTACKDEPTH>0 
-  if( yypParser->yytos>=&yypParser->yystack[YYSTACKDEPTH] ){
+  if( yypParser->yytos>yypParser->yystackEnd ){
     yypParser->yytos--;
     yyStackOverflow(yypParser);
     return;
@@ -136721,341 +138408,338 @@ static void yy_shift(
 ** is used during the reduce.
 */
 static const struct {
-  YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
-  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
+  YYCODETYPE lhs;       /* Symbol on the left-hand side of the rule */
+  signed char nrhs;     /* Negative of the number of RHS symbols in the rule */
 } yyRuleInfo[] = {
-  { 147, 1 },
-  { 147, 3 },
-  { 148, 1 },
-  { 149, 3 },
+  { 147, -1 },
+  { 147, -3 },
+  { 148, -1 },
+  { 149, -3 },
   { 150, 0 },
-  { 150, 1 },
-  { 150, 1 },
-  { 150, 1 },
-  { 149, 2 },
-  { 149, 2 },
-  { 149, 2 },
-  { 149, 2 },
-  { 149, 3 },
-  { 149, 5 },
-  { 154, 6 },
-  { 156, 1 },
+  { 150, -1 },
+  { 150, -1 },
+  { 150, -1 },
+  { 149, -2 },
+  { 149, -2 },
+  { 149, -2 },
+  { 149, -3 },
+  { 149, -5 },
+  { 154, -6 },
+  { 156, -1 },
   { 158, 0 },
-  { 158, 3 },
-  { 157, 1 },
+  { 158, -3 },
+  { 157, -1 },
   { 157, 0 },
-  { 155, 5 },
-  { 155, 2 },
+  { 155, -5 },
+  { 155, -2 },
   { 162, 0 },
-  { 162, 2 },
-  { 164, 2 },
+  { 162, -2 },
+  { 164, -2 },
   { 166, 0 },
-  { 166, 4 },
-  { 166, 6 },
-  { 167, 2 },
-  { 171, 2 },
-  { 171, 2 },
-  { 171, 4 },
-  { 171, 3 },
-  { 171, 3 },
-  { 171, 2 },
-  { 171, 3 },
-  { 171, 5 },
-  { 171, 2 },
-  { 171, 4 },
-  { 171, 4 },
-  { 171, 1 },
-  { 171, 2 },
+  { 166, -4 },
+  { 166, -6 },
+  { 167, -2 },
+  { 171, -2 },
+  { 171, -2 },
+  { 171, -4 },
+  { 171, -3 },
+  { 171, -3 },
+  { 171, -2 },
+  { 171, -3 },
+  { 171, -5 },
+  { 171, -2 },
+  { 171, -4 },
+  { 171, -4 },
+  { 171, -1 },
+  { 171, -2 },
   { 176, 0 },
-  { 176, 1 },
+  { 176, -1 },
   { 178, 0 },
-  { 178, 2 },
-  { 180, 2 },
-  { 180, 3 },
-  { 180, 3 },
-  { 180, 3 },
-  { 181, 2 },
-  { 181, 2 },
-  { 181, 1 },
-  { 181, 1 },
-  { 181, 2 },
-  { 179, 3 },
-  { 179, 2 },
+  { 178, -2 },
+  { 180, -2 },
+  { 180, -3 },
+  { 180, -3 },
+  { 180, -3 },
+  { 181, -2 },
+  { 181, -2 },
+  { 181, -1 },
+  { 181, -1 },
+  { 181, -2 },
+  { 179, -3 },
+  { 179, -2 },
   { 182, 0 },
-  { 182, 2 },
-  { 182, 2 },
+  { 182, -2 },
+  { 182, -2 },
   { 161, 0 },
-  { 184, 1 },
-  { 185, 2 },
-  { 185, 7 },
-  { 185, 5 },
-  { 185, 5 },
-  { 185, 10 },
+  { 184, -1 },
+  { 185, -2 },
+  { 185, -7 },
+  { 185, -5 },
+  { 185, -5 },
+  { 185, -10 },
   { 188, 0 },
   { 174, 0 },
-  { 174, 3 },
+  { 174, -3 },
   { 189, 0 },
-  { 189, 2 },
-  { 190, 1 },
-  { 190, 1 },
-  { 149, 4 },
-  { 192, 2 },
+  { 189, -2 },
+  { 190, -1 },
+  { 190, -1 },
+  { 149, -4 },
+  { 192, -2 },
   { 192, 0 },
-  { 149, 9 },
-  { 149, 4 },
-  { 149, 1 },
-  { 163, 2 },
-  { 194, 3 },
-  { 197, 1 },
-  { 197, 2 },
-  { 197, 1 },
-  { 195, 9 },
-  { 206, 4 },
-  { 206, 5 },
-  { 198, 1 },
-  { 198, 1 },
+  { 149, -9 },
+  { 149, -4 },
+  { 149, -1 },
+  { 163, -2 },
+  { 194, -3 },
+  { 197, -1 },
+  { 197, -2 },
+  { 197, -1 },
+  { 195, -9 },
+  { 206, -4 },
+  { 206, -5 },
+  { 198, -1 },
+  { 198, -1 },
   { 198, 0 },
   { 209, 0 },
-  { 199, 3 },
-  { 199, 2 },
-  { 199, 4 },
-  { 210, 2 },
+  { 199, -3 },
+  { 199, -2 },
+  { 199, -4 },
+  { 210, -2 },
   { 210, 0 },
   { 200, 0 },
-  { 200, 2 },
-  { 212, 2 },
+  { 200, -2 },
+  { 212, -2 },
   { 212, 0 },
-  { 211, 7 },
-  { 211, 9 },
-  { 211, 7 },
-  { 211, 7 },
+  { 211, -7 },
+  { 211, -9 },
+  { 211, -7 },
+  { 211, -7 },
   { 159, 0 },
-  { 159, 2 },
-  { 193, 2 },
-  { 213, 1 },
-  { 213, 2 },
-  { 213, 3 },
-  { 213, 4 },
-  { 215, 2 },
+  { 159, -2 },
+  { 193, -2 },
+  { 213, -1 },
+  { 213, -2 },
+  { 213, -3 },
+  { 213, -4 },
+  { 215, -2 },
   { 215, 0 },
   { 214, 0 },
-  { 214, 3 },
-  { 214, 2 },
-  { 216, 4 },
+  { 214, -3 },
+  { 214, -2 },
+  { 216, -4 },
   { 216, 0 },
   { 204, 0 },
-  { 204, 3 },
-  { 186, 4 },
-  { 186, 2 },
-  { 175, 1 },
-  { 175, 1 },
+  { 204, -3 },
+  { 186, -4 },
+  { 186, -2 },
+  { 175, -1 },
+  { 175, -1 },
   { 175, 0 },
   { 202, 0 },
-  { 202, 3 },
+  { 202, -3 },
   { 203, 0 },
-  { 203, 2 },
+  { 203, -2 },
   { 205, 0 },
-  { 205, 2 },
-  { 205, 4 },
-  { 205, 4 },
-  { 149, 6 },
+  { 205, -2 },
+  { 205, -4 },
+  { 205, -4 },
+  { 149, -6 },
   { 201, 0 },
-  { 201, 2 },
-  { 149, 8 },
-  { 218, 5 },
-  { 218, 7 },
-  { 218, 3 },
-  { 218, 5 },
-  { 149, 6 },
-  { 149, 7 },
-  { 219, 2 },
-  { 219, 1 },
+  { 201, -2 },
+  { 149, -8 },
+  { 218, -5 },
+  { 218, -7 },
+  { 218, -3 },
+  { 218, -5 },
+  { 149, -6 },
+  { 149, -7 },
+  { 219, -2 },
+  { 219, -1 },
   { 220, 0 },
-  { 220, 3 },
-  { 217, 3 },
-  { 217, 1 },
-  { 173, 3 },
-  { 172, 1 },
-  { 173, 1 },
-  { 173, 1 },
-  { 173, 3 },
-  { 173, 5 },
-  { 172, 1 },
-  { 172, 1 },
-  { 172, 1 },
-  { 173, 1 },
-  { 173, 3 },
-  { 173, 6 },
-  { 173, 5 },
-  { 173, 4 },
-  { 172, 1 },
-  { 173, 5 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 3 },
-  { 221, 2 },
-  { 173, 3 },
-  { 173, 5 },
-  { 173, 2 },
-  { 173, 3 },
-  { 173, 3 },
-  { 173, 4 },
-  { 173, 2 },
-  { 173, 2 },
-  { 173, 2 },
-  { 173, 2 },
-  { 222, 1 },
-  { 222, 2 },
-  { 173, 5 },
-  { 223, 1 },
-  { 223, 2 },
-  { 173, 5 },
-  { 173, 3 },
-  { 173, 5 },
-  { 173, 5 },
-  { 173, 4 },
-  { 173, 5 },
-  { 226, 5 },
-  { 226, 4 },
-  { 227, 2 },
+  { 220, -3 },
+  { 217, -3 },
+  { 217, -1 },
+  { 173, -3 },
+  { 173, -1 },
+  { 173, -1 },
+  { 173, -3 },
+  { 173, -5 },
+  { 172, -1 },
+  { 172, -1 },
+  { 172, -1 },
+  { 173, -1 },
+  { 173, -3 },
+  { 173, -6 },
+  { 173, -5 },
+  { 173, -4 },
+  { 172, -1 },
+  { 173, -5 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -3 },
+  { 221, -2 },
+  { 173, -3 },
+  { 173, -5 },
+  { 173, -2 },
+  { 173, -3 },
+  { 173, -3 },
+  { 173, -4 },
+  { 173, -2 },
+  { 173, -2 },
+  { 173, -2 },
+  { 173, -2 },
+  { 222, -1 },
+  { 222, -2 },
+  { 173, -5 },
+  { 223, -1 },
+  { 223, -2 },
+  { 173, -5 },
+  { 173, -3 },
+  { 173, -5 },
+  { 173, -5 },
+  { 173, -4 },
+  { 173, -5 },
+  { 226, -5 },
+  { 226, -4 },
+  { 227, -2 },
   { 227, 0 },
-  { 225, 1 },
+  { 225, -1 },
   { 225, 0 },
   { 208, 0 },
-  { 207, 3 },
-  { 207, 1 },
+  { 207, -3 },
+  { 207, -1 },
   { 224, 0 },
-  { 224, 3 },
-  { 149, 12 },
-  { 228, 1 },
+  { 224, -3 },
+  { 149, -12 },
+  { 228, -1 },
   { 228, 0 },
   { 177, 0 },
-  { 177, 3 },
-  { 187, 5 },
-  { 187, 3 },
+  { 177, -3 },
+  { 187, -5 },
+  { 187, -3 },
   { 229, 0 },
-  { 229, 2 },
-  { 149, 4 },
-  { 149, 1 },
-  { 149, 2 },
-  { 149, 3 },
-  { 149, 5 },
-  { 149, 6 },
-  { 149, 5 },
-  { 149, 6 },
-  { 169, 2 },
-  { 170, 2 },
-  { 149, 5 },
-  { 231, 11 },
-  { 233, 1 },
-  { 233, 1 },
-  { 233, 2 },
+  { 229, -2 },
+  { 149, -4 },
+  { 149, -1 },
+  { 149, -2 },
+  { 149, -3 },
+  { 149, -5 },
+  { 149, -6 },
+  { 149, -5 },
+  { 149, -6 },
+  { 169, -2 },
+  { 170, -2 },
+  { 149, -5 },
+  { 231, -11 },
+  { 233, -1 },
+  { 233, -2 },
   { 233, 0 },
-  { 234, 1 },
-  { 234, 1 },
-  { 234, 3 },
+  { 234, -1 },
+  { 234, -1 },
+  { 234, -3 },
   { 236, 0 },
-  { 236, 2 },
-  { 232, 3 },
-  { 232, 2 },
-  { 238, 3 },
-  { 239, 3 },
-  { 239, 2 },
-  { 237, 7 },
-  { 237, 5 },
-  { 237, 5 },
-  { 237, 1 },
-  { 173, 4 },
-  { 173, 6 },
-  { 191, 1 },
-  { 191, 1 },
-  { 191, 1 },
-  { 149, 4 },
-  { 149, 6 },
-  { 149, 3 },
+  { 236, -2 },
+  { 232, -3 },
+  { 232, -2 },
+  { 238, -3 },
+  { 239, -3 },
+  { 239, -2 },
+  { 237, -7 },
+  { 237, -5 },
+  { 237, -5 },
+  { 237, -1 },
+  { 173, -4 },
+  { 173, -6 },
+  { 191, -1 },
+  { 191, -1 },
+  { 191, -1 },
+  { 149, -4 },
+  { 149, -6 },
+  { 149, -3 },
   { 241, 0 },
-  { 241, 2 },
-  { 149, 1 },
-  { 149, 3 },
-  { 149, 1 },
-  { 149, 3 },
-  { 149, 6 },
-  { 149, 7 },
-  { 242, 1 },
-  { 149, 1 },
-  { 149, 4 },
-  { 244, 8 },
+  { 241, -2 },
+  { 149, -1 },
+  { 149, -3 },
+  { 149, -1 },
+  { 149, -3 },
+  { 149, -6 },
+  { 149, -7 },
+  { 242, -1 },
+  { 149, -1 },
+  { 149, -4 },
+  { 244, -8 },
   { 246, 0 },
-  { 247, 1 },
-  { 247, 3 },
-  { 248, 1 },
+  { 247, -1 },
+  { 247, -3 },
+  { 248, -1 },
   { 196, 0 },
-  { 196, 2 },
-  { 196, 3 },
-  { 250, 6 },
-  { 250, 8 },
-  { 144, 1 },
-  { 145, 2 },
-  { 145, 1 },
-  { 146, 1 },
-  { 146, 3 },
+  { 196, -2 },
+  { 196, -3 },
+  { 250, -6 },
+  { 250, -8 },
+  { 144, -1 },
+  { 145, -2 },
+  { 145, -1 },
+  { 146, -1 },
+  { 146, -3 },
   { 147, 0 },
   { 151, 0 },
-  { 151, 1 },
-  { 151, 2 },
-  { 153, 1 },
+  { 151, -1 },
+  { 151, -2 },
+  { 153, -1 },
   { 153, 0 },
-  { 149, 2 },
-  { 160, 4 },
-  { 160, 2 },
-  { 152, 1 },
-  { 152, 1 },
-  { 152, 1 },
-  { 166, 1 },
-  { 167, 1 },
-  { 168, 1 },
-  { 168, 1 },
-  { 165, 2 },
+  { 149, -2 },
+  { 160, -4 },
+  { 160, -2 },
+  { 152, -1 },
+  { 152, -1 },
+  { 152, -1 },
+  { 166, -1 },
+  { 167, -1 },
+  { 168, -1 },
+  { 168, -1 },
+  { 165, -2 },
   { 165, 0 },
-  { 171, 2 },
-  { 161, 2 },
-  { 183, 3 },
-  { 183, 1 },
+  { 171, -2 },
+  { 161, -2 },
+  { 183, -3 },
+  { 183, -1 },
   { 184, 0 },
-  { 188, 1 },
-  { 190, 1 },
-  { 194, 1 },
-  { 195, 1 },
-  { 209, 2 },
-  { 210, 1 },
-  { 173, 1 },
-  { 221, 1 },
-  { 208, 1 },
-  { 230, 1 },
-  { 230, 1 },
-  { 230, 1 },
-  { 230, 1 },
-  { 230, 1 },
-  { 169, 1 },
+  { 188, -1 },
+  { 190, -1 },
+  { 194, -1 },
+  { 195, -1 },
+  { 209, -2 },
+  { 210, -1 },
+  { 173, -1 },
+  { 221, -1 },
+  { 208, -1 },
+  { 230, -1 },
+  { 230, -1 },
+  { 230, -1 },
+  { 230, -1 },
+  { 230, -1 },
+  { 169, -1 },
   { 235, 0 },
-  { 235, 3 },
-  { 238, 1 },
+  { 235, -3 },
+  { 238, -1 },
   { 239, 0 },
-  { 240, 1 },
+  { 240, -1 },
   { 240, 0 },
   { 243, 0 },
-  { 243, 1 },
-  { 245, 1 },
-  { 245, 3 },
-  { 246, 2 },
+  { 243, -1 },
+  { 245, -1 },
+  { 245, -3 },
+  { 246, -2 },
   { 249, 0 },
-  { 249, 4 },
-  { 249, 2 },
+  { 249, -4 },
+  { 249, -2 },
 };
 
 static void yy_accept(yyParser*);  /* Forward Declaration */
@@ -137078,7 +138762,7 @@ static void yy_reduce(
   if( yyTraceFILE && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){
     yysize = yyRuleInfo[yyruleno].nrhs;
     fprintf(yyTraceFILE, "%sReduce [%s], go to state %d.\n", yyTracePrompt,
-      yyRuleName[yyruleno], yymsp[-yysize].stateno);
+      yyRuleName[yyruleno], yymsp[yysize].stateno);
   }
 #endif /* NDEBUG */
 
@@ -137093,7 +138777,7 @@ static void yy_reduce(
     }
 #endif
 #if YYSTACKDEPTH>0 
-    if( yypParser->yytos>=&yypParser->yystack[YYSTACKDEPTH-1] ){
+    if( yypParser->yytos>=yypParser->yystackEnd ){
       yyStackOverflow(yypParser);
       return;
     }
@@ -137139,66 +138823,63 @@ static void yy_reduce(
       case 7: /* transtype ::= EXCLUSIVE */ yytestcase(yyruleno==7);
 {yymsp[0].minor.yy194 = yymsp[0].major; /*A-overwrites-X*/}
         break;
-      case 8: /* cmd ::= COMMIT trans_opt */
-      case 9: /* cmd ::= END trans_opt */ yytestcase(yyruleno==9);
-{sqlite3CommitTransaction(pParse);}
-        break;
-      case 10: /* cmd ::= ROLLBACK trans_opt */
-{sqlite3RollbackTransaction(pParse);}
+      case 8: /* cmd ::= COMMIT|END trans_opt */
+      case 9: /* cmd ::= ROLLBACK trans_opt */ yytestcase(yyruleno==9);
+{sqlite3EndTransaction(pParse,yymsp[-1].major);}
         break;
-      case 11: /* cmd ::= SAVEPOINT nm */
+      case 10: /* cmd ::= SAVEPOINT nm */
 {
   sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &yymsp[0].minor.yy0);
 }
         break;
-      case 12: /* cmd ::= RELEASE savepoint_opt nm */
+      case 11: /* cmd ::= RELEASE savepoint_opt nm */
 {
   sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &yymsp[0].minor.yy0);
 }
         break;
-      case 13: /* cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */
+      case 12: /* cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */
 {
   sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0);
 }
         break;
-      case 14: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */
+      case 13: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */
 {
    sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy194,0,0,yymsp[-2].minor.yy194);
 }
         break;
-      case 15: /* createkw ::= CREATE */
+      case 14: /* createkw ::= CREATE */
 {disableLookaside(pParse);}
         break;
-      case 16: /* ifnotexists ::= */
-      case 19: /* temp ::= */ yytestcase(yyruleno==19);
-      case 22: /* table_options ::= */ yytestcase(yyruleno==22);
-      case 42: /* autoinc ::= */ yytestcase(yyruleno==42);
-      case 57: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==57);
-      case 67: /* defer_subclause_opt ::= */ yytestcase(yyruleno==67);
-      case 76: /* ifexists ::= */ yytestcase(yyruleno==76);
-      case 90: /* distinct ::= */ yytestcase(yyruleno==90);
-      case 214: /* collate ::= */ yytestcase(yyruleno==214);
+      case 15: /* ifnotexists ::= */
+      case 18: /* temp ::= */ yytestcase(yyruleno==18);
+      case 21: /* table_options ::= */ yytestcase(yyruleno==21);
+      case 41: /* autoinc ::= */ yytestcase(yyruleno==41);
+      case 56: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==56);
+      case 66: /* defer_subclause_opt ::= */ yytestcase(yyruleno==66);
+      case 75: /* ifexists ::= */ yytestcase(yyruleno==75);
+      case 89: /* distinct ::= */ yytestcase(yyruleno==89);
+      case 212: /* collate ::= */ yytestcase(yyruleno==212);
 {yymsp[1].minor.yy194 = 0;}
         break;
-      case 17: /* ifnotexists ::= IF NOT EXISTS */
+      case 16: /* ifnotexists ::= IF NOT EXISTS */
 {yymsp[-2].minor.yy194 = 1;}
         break;
-      case 18: /* temp ::= TEMP */
-      case 43: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==43);
+      case 17: /* temp ::= TEMP */
+      case 42: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==42);
 {yymsp[0].minor.yy194 = 1;}
         break;
-      case 20: /* create_table_args ::= LP columnlist conslist_opt RP table_options */
+      case 19: /* create_table_args ::= LP columnlist conslist_opt RP table_options */
 {
   sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy194,0);
 }
         break;
-      case 21: /* create_table_args ::= AS select */
+      case 20: /* create_table_args ::= AS select */
 {
   sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy243);
   sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy243);
 }
         break;
-      case 23: /* table_options ::= WITHOUT nm */
+      case 22: /* table_options ::= WITHOUT nm */
 {
   if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){
     yymsp[-1].minor.yy194 = TF_WithoutRowid | TF_NoVisibleRowid;
@@ -137208,39 +138889,39 @@ static void yy_reduce(
   }
 }
         break;
-      case 24: /* columnname ::= nm typetoken */
+      case 23: /* columnname ::= nm typetoken */
 {sqlite3AddColumn(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}
         break;
-      case 25: /* typetoken ::= */
-      case 60: /* conslist_opt ::= */ yytestcase(yyruleno==60);
-      case 96: /* as ::= */ yytestcase(yyruleno==96);
+      case 24: /* typetoken ::= */
+      case 59: /* conslist_opt ::= */ yytestcase(yyruleno==59);
+      case 95: /* as ::= */ yytestcase(yyruleno==95);
 {yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}
         break;
-      case 26: /* typetoken ::= typename LP signed RP */
+      case 25: /* typetoken ::= typename LP signed RP */
 {
   yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
 }
         break;
-      case 27: /* typetoken ::= typename LP signed COMMA signed RP */
+      case 26: /* typetoken ::= typename LP signed COMMA signed RP */
 {
   yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);
 }
         break;
-      case 28: /* typename ::= typename ID|STRING */
+      case 27: /* typename ::= typename ID|STRING */
 {yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}
         break;
-      case 29: /* ccons ::= CONSTRAINT nm */
-      case 62: /* tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==62);
+      case 28: /* ccons ::= CONSTRAINT nm */
+      case 61: /* tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==61);
 {pParse->constraintName = yymsp[0].minor.yy0;}
         break;
-      case 30: /* ccons ::= DEFAULT term */
-      case 32: /* ccons ::= DEFAULT PLUS term */ yytestcase(yyruleno==32);
+      case 29: /* ccons ::= DEFAULT term */
+      case 31: /* ccons ::= DEFAULT PLUS term */ yytestcase(yyruleno==31);
 {sqlite3AddDefaultValue(pParse,&yymsp[0].minor.yy190);}
         break;
-      case 31: /* ccons ::= DEFAULT LP expr RP */
+      case 30: /* ccons ::= DEFAULT LP expr RP */
 {sqlite3AddDefaultValue(pParse,&yymsp[-1].minor.yy190);}
         break;
-      case 33: /* ccons ::= DEFAULT MINUS term */
+      case 32: /* ccons ::= DEFAULT MINUS term */
 {
   ExprSpan v;
   v.pExpr = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy190.pExpr, 0);
@@ -137249,142 +138930,142 @@ static void yy_reduce(
   sqlite3AddDefaultValue(pParse,&v);
 }
         break;
-      case 34: /* ccons ::= DEFAULT ID|INDEXED */
+      case 33: /* ccons ::= DEFAULT ID|INDEXED */
 {
   ExprSpan v;
   spanExpr(&v, pParse, TK_STRING, yymsp[0].minor.yy0);
   sqlite3AddDefaultValue(pParse,&v);
 }
         break;
-      case 35: /* ccons ::= NOT NULL onconf */
+      case 34: /* ccons ::= NOT NULL onconf */
 {sqlite3AddNotNull(pParse, yymsp[0].minor.yy194);}
         break;
-      case 36: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */
+      case 35: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */
 {sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy194,yymsp[0].minor.yy194,yymsp[-2].minor.yy194);}
         break;
-      case 37: /* ccons ::= UNIQUE onconf */
+      case 36: /* ccons ::= UNIQUE onconf */
 {sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy194,0,0,0,0,
                                    SQLITE_IDXTYPE_UNIQUE);}
         break;
-      case 38: /* ccons ::= CHECK LP expr RP */
+      case 37: /* ccons ::= CHECK LP expr RP */
 {sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy190.pExpr);}
         break;
-      case 39: /* ccons ::= REFERENCES nm eidlist_opt refargs */
+      case 38: /* ccons ::= REFERENCES nm eidlist_opt refargs */
 {sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy148,yymsp[0].minor.yy194);}
         break;
-      case 40: /* ccons ::= defer_subclause */
+      case 39: /* ccons ::= defer_subclause */
 {sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy194);}
         break;
-      case 41: /* ccons ::= COLLATE ID|STRING */
+      case 40: /* ccons ::= COLLATE ID|STRING */
 {sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}
         break;
-      case 44: /* refargs ::= */
+      case 43: /* refargs ::= */
 { yymsp[1].minor.yy194 = OE_None*0x0101; /* EV: R-19803-45884 */}
         break;
-      case 45: /* refargs ::= refargs refarg */
+      case 44: /* refargs ::= refargs refarg */
 { yymsp[-1].minor.yy194 = (yymsp[-1].minor.yy194 & ~yymsp[0].minor.yy497.mask) | yymsp[0].minor.yy497.value; }
         break;
-      case 46: /* refarg ::= MATCH nm */
+      case 45: /* refarg ::= MATCH nm */
 { yymsp[-1].minor.yy497.value = 0;     yymsp[-1].minor.yy497.mask = 0x000000; }
         break;
-      case 47: /* refarg ::= ON INSERT refact */
+      case 46: /* refarg ::= ON INSERT refact */
 { yymsp[-2].minor.yy497.value = 0;     yymsp[-2].minor.yy497.mask = 0x000000; }
         break;
-      case 48: /* refarg ::= ON DELETE refact */
+      case 47: /* refarg ::= ON DELETE refact */
 { yymsp[-2].minor.yy497.value = yymsp[0].minor.yy194;     yymsp[-2].minor.yy497.mask = 0x0000ff; }
         break;
-      case 49: /* refarg ::= ON UPDATE refact */
+      case 48: /* refarg ::= ON UPDATE refact */
 { yymsp[-2].minor.yy497.value = yymsp[0].minor.yy194<<8;  yymsp[-2].minor.yy497.mask = 0x00ff00; }
         break;
-      case 50: /* refact ::= SET NULL */
+      case 49: /* refact ::= SET NULL */
 { yymsp[-1].minor.yy194 = OE_SetNull;  /* EV: R-33326-45252 */}
         break;
-      case 51: /* refact ::= SET DEFAULT */
+      case 50: /* refact ::= SET DEFAULT */
 { yymsp[-1].minor.yy194 = OE_SetDflt;  /* EV: R-33326-45252 */}
         break;
-      case 52: /* refact ::= CASCADE */
+      case 51: /* refact ::= CASCADE */
 { yymsp[0].minor.yy194 = OE_Cascade;  /* EV: R-33326-45252 */}
         break;
-      case 53: /* refact ::= RESTRICT */
+      case 52: /* refact ::= RESTRICT */
 { yymsp[0].minor.yy194 = OE_Restrict; /* EV: R-33326-45252 */}
         break;
-      case 54: /* refact ::= NO ACTION */
+      case 53: /* refact ::= NO ACTION */
 { yymsp[-1].minor.yy194 = OE_None;     /* EV: R-33326-45252 */}
         break;
-      case 55: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
+      case 54: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
 {yymsp[-2].minor.yy194 = 0;}
         break;
-      case 56: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
-      case 71: /* orconf ::= OR resolvetype */ yytestcase(yyruleno==71);
-      case 144: /* insert_cmd ::= INSERT orconf */ yytestcase(yyruleno==144);
+      case 55: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
+      case 70: /* orconf ::= OR resolvetype */ yytestcase(yyruleno==70);
+      case 143: /* insert_cmd ::= INSERT orconf */ yytestcase(yyruleno==143);
 {yymsp[-1].minor.yy194 = yymsp[0].minor.yy194;}
         break;
-      case 58: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */
-      case 75: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==75);
-      case 186: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==186);
-      case 189: /* in_op ::= NOT IN */ yytestcase(yyruleno==189);
-      case 215: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==215);
+      case 57: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */
+      case 74: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==74);
+      case 184: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==184);
+      case 187: /* in_op ::= NOT IN */ yytestcase(yyruleno==187);
+      case 213: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==213);
 {yymsp[-1].minor.yy194 = 1;}
         break;
-      case 59: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
+      case 58: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
 {yymsp[-1].minor.yy194 = 0;}
         break;
-      case 61: /* tconscomma ::= COMMA */
+      case 60: /* tconscomma ::= COMMA */
 {pParse->constraintName.n = 0;}
         break;
-      case 63: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
+      case 62: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
 {sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy148,yymsp[0].minor.yy194,yymsp[-2].minor.yy194,0);}
         break;
-      case 64: /* tcons ::= UNIQUE LP sortlist RP onconf */
+      case 63: /* tcons ::= UNIQUE LP sortlist RP onconf */
 {sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy148,yymsp[0].minor.yy194,0,0,0,0,
                                        SQLITE_IDXTYPE_UNIQUE);}
         break;
-      case 65: /* tcons ::= CHECK LP expr RP onconf */
+      case 64: /* tcons ::= CHECK LP expr RP onconf */
 {sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy190.pExpr);}
         break;
-      case 66: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
+      case 65: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
 {
     sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy148, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy148, yymsp[-1].minor.yy194);
     sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy194);
 }
         break;
-      case 68: /* onconf ::= */
-      case 70: /* orconf ::= */ yytestcase(yyruleno==70);
+      case 67: /* onconf ::= */
+      case 69: /* orconf ::= */ yytestcase(yyruleno==69);
 {yymsp[1].minor.yy194 = OE_Default;}
         break;
-      case 69: /* onconf ::= ON CONFLICT resolvetype */
+      case 68: /* onconf ::= ON CONFLICT resolvetype */
 {yymsp[-2].minor.yy194 = yymsp[0].minor.yy194;}
         break;
-      case 72: /* resolvetype ::= IGNORE */
+      case 71: /* resolvetype ::= IGNORE */
 {yymsp[0].minor.yy194 = OE_Ignore;}
         break;
-      case 73: /* resolvetype ::= REPLACE */
-      case 145: /* insert_cmd ::= REPLACE */ yytestcase(yyruleno==145);
+      case 72: /* resolvetype ::= REPLACE */
+      case 144: /* insert_cmd ::= REPLACE */ yytestcase(yyruleno==144);
 {yymsp[0].minor.yy194 = OE_Replace;}
         break;
-      case 74: /* cmd ::= DROP TABLE ifexists fullname */
+      case 73: /* cmd ::= DROP TABLE ifexists fullname */
 {
   sqlite3DropTable(pParse, yymsp[0].minor.yy185, 0, yymsp[-1].minor.yy194);
 }
         break;
-      case 77: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
+      case 76: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
 {
   sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy148, yymsp[0].minor.yy243, yymsp[-7].minor.yy194, yymsp[-5].minor.yy194);
 }
         break;
-      case 78: /* cmd ::= DROP VIEW ifexists fullname */
+      case 77: /* cmd ::= DROP VIEW ifexists fullname */
 {
   sqlite3DropTable(pParse, yymsp[0].minor.yy185, 1, yymsp[-1].minor.yy194);
 }
         break;
-      case 79: /* cmd ::= select */
+      case 78: /* cmd ::= select */
 {
   SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0};
   sqlite3Select(pParse, yymsp[0].minor.yy243, &dest);
   sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy243);
 }
         break;
-      case 80: /* select ::= with selectnowith */
+      case 79: /* select ::= with selectnowith */
 {
   Select *p = yymsp[0].minor.yy243;
   if( p ){
@@ -137396,7 +139077,7 @@ static void yy_reduce(
   yymsp[-1].minor.yy243 = p; /*A-overwrites-W*/
 }
         break;
-      case 81: /* selectnowith ::= selectnowith multiselect_op oneselect */
+      case 80: /* selectnowith ::= selectnowith multiselect_op oneselect */
 {
   Select *pRhs = yymsp[0].minor.yy243;
   Select *pLhs = yymsp[-2].minor.yy243;
@@ -137420,14 +139101,14 @@ static void yy_reduce(
   yymsp[-2].minor.yy243 = pRhs;
 }
         break;
-      case 82: /* multiselect_op ::= UNION */
-      case 84: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==84);
+      case 81: /* multiselect_op ::= UNION */
+      case 83: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==83);
 {yymsp[0].minor.yy194 = yymsp[0].major; /*A-overwrites-OP*/}
         break;
-      case 83: /* multiselect_op ::= UNION ALL */
+      case 82: /* multiselect_op ::= UNION ALL */
 {yymsp[-1].minor.yy194 = TK_ALL;}
         break;
-      case 85: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
+      case 84: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
 {
 #if SELECTTRACE_ENABLED
   Token s = yymsp[-8].minor.yy0; /*A-overwrites-S*/
@@ -137459,12 +139140,12 @@ static void yy_reduce(
 #endif /* SELECTRACE_ENABLED */
 }
         break;
-      case 86: /* values ::= VALUES LP nexprlist RP */
+      case 85: /* values ::= VALUES LP nexprlist RP */
 {
   yymsp[-3].minor.yy243 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy148,0,0,0,0,0,SF_Values,0,0);
 }
         break;
-      case 87: /* values ::= values COMMA LP exprlist RP */
+      case 86: /* values ::= values COMMA LP exprlist RP */
 {
   Select *pRight, *pLeft = yymsp[-4].minor.yy243;
   pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy148,0,0,0,0,0,SF_Values|SF_MultiValue,0,0);
@@ -137478,34 +139159,34 @@ static void yy_reduce(
   }
 }
         break;
-      case 88: /* distinct ::= DISTINCT */
+      case 87: /* distinct ::= DISTINCT */
 {yymsp[0].minor.yy194 = SF_Distinct;}
         break;
-      case 89: /* distinct ::= ALL */
+      case 88: /* distinct ::= ALL */
 {yymsp[0].minor.yy194 = SF_All;}
         break;
-      case 91: /* sclp ::= */
-      case 119: /* orderby_opt ::= */ yytestcase(yyruleno==119);
-      case 126: /* groupby_opt ::= */ yytestcase(yyruleno==126);
-      case 202: /* exprlist ::= */ yytestcase(yyruleno==202);
-      case 205: /* paren_exprlist ::= */ yytestcase(yyruleno==205);
-      case 210: /* eidlist_opt ::= */ yytestcase(yyruleno==210);
+      case 90: /* sclp ::= */
+      case 118: /* orderby_opt ::= */ yytestcase(yyruleno==118);
+      case 125: /* groupby_opt ::= */ yytestcase(yyruleno==125);
+      case 200: /* exprlist ::= */ yytestcase(yyruleno==200);
+      case 203: /* paren_exprlist ::= */ yytestcase(yyruleno==203);
+      case 208: /* eidlist_opt ::= */ yytestcase(yyruleno==208);
 {yymsp[1].minor.yy148 = 0;}
         break;
-      case 92: /* selcollist ::= sclp expr as */
+      case 91: /* selcollist ::= sclp expr as */
 {
    yymsp[-2].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy148, yymsp[-1].minor.yy190.pExpr);
    if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-2].minor.yy148, &yymsp[0].minor.yy0, 1);
    sqlite3ExprListSetSpan(pParse,yymsp[-2].minor.yy148,&yymsp[-1].minor.yy190);
 }
         break;
-      case 93: /* selcollist ::= sclp STAR */
+      case 92: /* selcollist ::= sclp STAR */
 {
   Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);
   yymsp[-1].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy148, p);
 }
         break;
-      case 94: /* selcollist ::= sclp nm DOT STAR */
+      case 93: /* selcollist ::= sclp nm DOT STAR */
 {
   Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);
   Expr *pLeft = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
@@ -137513,47 +139194,47 @@ static void yy_reduce(
   yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy148, pDot);
 }
         break;
-      case 95: /* as ::= AS nm */
-      case 106: /* dbnm ::= DOT nm */ yytestcase(yyruleno==106);
-      case 224: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==224);
-      case 225: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==225);
+      case 94: /* as ::= AS nm */
+      case 105: /* dbnm ::= DOT nm */ yytestcase(yyruleno==105);
+      case 222: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==222);
+      case 223: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==223);
 {yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}
         break;
-      case 97: /* from ::= */
+      case 96: /* from ::= */
 {yymsp[1].minor.yy185 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy185));}
         break;
-      case 98: /* from ::= FROM seltablist */
+      case 97: /* from ::= FROM seltablist */
 {
   yymsp[-1].minor.yy185 = yymsp[0].minor.yy185;
   sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy185);
 }
         break;
-      case 99: /* stl_prefix ::= seltablist joinop */
+      case 98: /* stl_prefix ::= seltablist joinop */
 {
    if( ALWAYS(yymsp[-1].minor.yy185 && yymsp[-1].minor.yy185->nSrc>0) ) yymsp[-1].minor.yy185->a[yymsp[-1].minor.yy185->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy194;
 }
         break;
-      case 100: /* stl_prefix ::= */
+      case 99: /* stl_prefix ::= */
 {yymsp[1].minor.yy185 = 0;}
         break;
-      case 101: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
+      case 100: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
 {
   yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy185,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy72,yymsp[0].minor.yy254);
   sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy185, &yymsp[-2].minor.yy0);
 }
         break;
-      case 102: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
+      case 101: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
 {
   yymsp[-8].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy185,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy72,yymsp[0].minor.yy254);
   sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy185, yymsp[-4].minor.yy148);
 }
         break;
-      case 103: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
+      case 102: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
 {
     yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy185,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy243,yymsp[-1].minor.yy72,yymsp[0].minor.yy254);
   }
         break;
-      case 104: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
+      case 103: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
 {
     if( yymsp[-6].minor.yy185==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy72==0 && yymsp[0].minor.yy254==0 ){
       yymsp[-6].minor.yy185 = yymsp[-4].minor.yy185;
@@ -137577,96 +139258,96 @@ static void yy_reduce(
     }
   }
         break;
-      case 105: /* dbnm ::= */
-      case 114: /* indexed_opt ::= */ yytestcase(yyruleno==114);
+      case 104: /* dbnm ::= */
+      case 113: /* indexed_opt ::= */ yytestcase(yyruleno==113);
 {yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}
         break;
-      case 107: /* fullname ::= nm dbnm */
+      case 106: /* fullname ::= nm dbnm */
 {yymsp[-1].minor.yy185 = sqlite3SrcListAppend(pParse->db,0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-X*/}
         break;
-      case 108: /* joinop ::= COMMA|JOIN */
+      case 107: /* joinop ::= COMMA|JOIN */
 { yymsp[0].minor.yy194 = JT_INNER; }
         break;
-      case 109: /* joinop ::= JOIN_KW JOIN */
+      case 108: /* joinop ::= JOIN_KW JOIN */
 {yymsp[-1].minor.yy194 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  /*X-overwrites-A*/}
         break;
-      case 110: /* joinop ::= JOIN_KW nm JOIN */
+      case 109: /* joinop ::= JOIN_KW nm JOIN */
 {yymsp[-2].minor.yy194 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); /*X-overwrites-A*/}
         break;
-      case 111: /* joinop ::= JOIN_KW nm nm JOIN */
+      case 110: /* joinop ::= JOIN_KW nm nm JOIN */
 {yymsp[-3].minor.yy194 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);/*X-overwrites-A*/}
         break;
-      case 112: /* on_opt ::= ON expr */
-      case 129: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==129);
-      case 136: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==136);
-      case 198: /* case_else ::= ELSE expr */ yytestcase(yyruleno==198);
+      case 111: /* on_opt ::= ON expr */
+      case 128: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==128);
+      case 135: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==135);
+      case 196: /* case_else ::= ELSE expr */ yytestcase(yyruleno==196);
 {yymsp[-1].minor.yy72 = yymsp[0].minor.yy190.pExpr;}
         break;
-      case 113: /* on_opt ::= */
-      case 128: /* having_opt ::= */ yytestcase(yyruleno==128);
-      case 135: /* where_opt ::= */ yytestcase(yyruleno==135);
-      case 199: /* case_else ::= */ yytestcase(yyruleno==199);
-      case 201: /* case_operand ::= */ yytestcase(yyruleno==201);
+      case 112: /* on_opt ::= */
+      case 127: /* having_opt ::= */ yytestcase(yyruleno==127);
+      case 134: /* where_opt ::= */ yytestcase(yyruleno==134);
+      case 197: /* case_else ::= */ yytestcase(yyruleno==197);
+      case 199: /* case_operand ::= */ yytestcase(yyruleno==199);
 {yymsp[1].minor.yy72 = 0;}
         break;
-      case 115: /* indexed_opt ::= INDEXED BY nm */
+      case 114: /* indexed_opt ::= INDEXED BY nm */
 {yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}
         break;
-      case 116: /* indexed_opt ::= NOT INDEXED */
+      case 115: /* indexed_opt ::= NOT INDEXED */
 {yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}
         break;
-      case 117: /* using_opt ::= USING LP idlist RP */
+      case 116: /* using_opt ::= USING LP idlist RP */
 {yymsp[-3].minor.yy254 = yymsp[-1].minor.yy254;}
         break;
-      case 118: /* using_opt ::= */
-      case 146: /* idlist_opt ::= */ yytestcase(yyruleno==146);
+      case 117: /* using_opt ::= */
+      case 145: /* idlist_opt ::= */ yytestcase(yyruleno==145);
 {yymsp[1].minor.yy254 = 0;}
         break;
-      case 120: /* orderby_opt ::= ORDER BY sortlist */
-      case 127: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==127);
+      case 119: /* orderby_opt ::= ORDER BY sortlist */
+      case 126: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==126);
 {yymsp[-2].minor.yy148 = yymsp[0].minor.yy148;}
         break;
-      case 121: /* sortlist ::= sortlist COMMA expr sortorder */
+      case 120: /* sortlist ::= sortlist COMMA expr sortorder */
 {
   yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy148,yymsp[-1].minor.yy190.pExpr);
   sqlite3ExprListSetSortOrder(yymsp[-3].minor.yy148,yymsp[0].minor.yy194);
 }
         break;
-      case 122: /* sortlist ::= expr sortorder */
+      case 121: /* sortlist ::= expr sortorder */
 {
   yymsp[-1].minor.yy148 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy190.pExpr); /*A-overwrites-Y*/
   sqlite3ExprListSetSortOrder(yymsp[-1].minor.yy148,yymsp[0].minor.yy194);
 }
         break;
-      case 123: /* sortorder ::= ASC */
+      case 122: /* sortorder ::= ASC */
 {yymsp[0].minor.yy194 = SQLITE_SO_ASC;}
         break;
-      case 124: /* sortorder ::= DESC */
+      case 123: /* sortorder ::= DESC */
 {yymsp[0].minor.yy194 = SQLITE_SO_DESC;}
         break;
-      case 125: /* sortorder ::= */
+      case 124: /* sortorder ::= */
 {yymsp[1].minor.yy194 = SQLITE_SO_UNDEFINED;}
         break;
-      case 130: /* limit_opt ::= */
+      case 129: /* limit_opt ::= */
 {yymsp[1].minor.yy354.pLimit = 0; yymsp[1].minor.yy354.pOffset = 0;}
         break;
-      case 131: /* limit_opt ::= LIMIT expr */
+      case 130: /* limit_opt ::= LIMIT expr */
 {yymsp[-1].minor.yy354.pLimit = yymsp[0].minor.yy190.pExpr; yymsp[-1].minor.yy354.pOffset = 0;}
         break;
-      case 132: /* limit_opt ::= LIMIT expr OFFSET expr */
+      case 131: /* limit_opt ::= LIMIT expr OFFSET expr */
 {yymsp[-3].minor.yy354.pLimit = yymsp[-2].minor.yy190.pExpr; yymsp[-3].minor.yy354.pOffset = yymsp[0].minor.yy190.pExpr;}
         break;
-      case 133: /* limit_opt ::= LIMIT expr COMMA expr */
+      case 132: /* limit_opt ::= LIMIT expr COMMA expr */
 {yymsp[-3].minor.yy354.pOffset = yymsp[-2].minor.yy190.pExpr; yymsp[-3].minor.yy354.pLimit = yymsp[0].minor.yy190.pExpr;}
         break;
-      case 134: /* cmd ::= with DELETE FROM fullname indexed_opt where_opt */
+      case 133: /* cmd ::= with DELETE FROM fullname indexed_opt where_opt */
 {
   sqlite3WithPush(pParse, yymsp[-5].minor.yy285, 1);
   sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy185, &yymsp[-1].minor.yy0);
   sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy185,yymsp[0].minor.yy72);
 }
         break;
-      case 137: /* cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt */
+      case 136: /* cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt */
 {
   sqlite3WithPush(pParse, yymsp[-7].minor.yy285, 1);
   sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy185, &yymsp[-3].minor.yy0);
@@ -137674,63 +139355,58 @@ static void yy_reduce(
   sqlite3Update(pParse,yymsp[-4].minor.yy185,yymsp[-1].minor.yy148,yymsp[0].minor.yy72,yymsp[-5].minor.yy194);
 }
         break;
-      case 138: /* setlist ::= setlist COMMA nm EQ expr */
+      case 137: /* setlist ::= setlist COMMA nm EQ expr */
 {
   yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy148, yymsp[0].minor.yy190.pExpr);
   sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy148, &yymsp[-2].minor.yy0, 1);
 }
         break;
-      case 139: /* setlist ::= setlist COMMA LP idlist RP EQ expr */
+      case 138: /* setlist ::= setlist COMMA LP idlist RP EQ expr */
 {
   yymsp[-6].minor.yy148 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy148, yymsp[-3].minor.yy254, yymsp[0].minor.yy190.pExpr);
 }
         break;
-      case 140: /* setlist ::= nm EQ expr */
+      case 139: /* setlist ::= nm EQ expr */
 {
   yylhsminor.yy148 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy190.pExpr);
   sqlite3ExprListSetName(pParse, yylhsminor.yy148, &yymsp[-2].minor.yy0, 1);
 }
   yymsp[-2].minor.yy148 = yylhsminor.yy148;
         break;
-      case 141: /* setlist ::= LP idlist RP EQ expr */
+      case 140: /* setlist ::= LP idlist RP EQ expr */
 {
   yymsp[-4].minor.yy148 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy254, yymsp[0].minor.yy190.pExpr);
 }
         break;
-      case 142: /* cmd ::= with insert_cmd INTO fullname idlist_opt select */
+      case 141: /* cmd ::= with insert_cmd INTO fullname idlist_opt select */
 {
   sqlite3WithPush(pParse, yymsp[-5].minor.yy285, 1);
   sqlite3Insert(pParse, yymsp[-2].minor.yy185, yymsp[0].minor.yy243, yymsp[-1].minor.yy254, yymsp[-4].minor.yy194);
 }
         break;
-      case 143: /* cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES */
+      case 142: /* cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES */
 {
   sqlite3WithPush(pParse, yymsp[-6].minor.yy285, 1);
   sqlite3Insert(pParse, yymsp[-3].minor.yy185, 0, yymsp[-2].minor.yy254, yymsp[-5].minor.yy194);
 }
         break;
-      case 147: /* idlist_opt ::= LP idlist RP */
+      case 146: /* idlist_opt ::= LP idlist RP */
 {yymsp[-2].minor.yy254 = yymsp[-1].minor.yy254;}
         break;
-      case 148: /* idlist ::= idlist COMMA nm */
+      case 147: /* idlist ::= idlist COMMA nm */
 {yymsp[-2].minor.yy254 = sqlite3IdListAppend(pParse->db,yymsp[-2].minor.yy254,&yymsp[0].minor.yy0);}
         break;
-      case 149: /* idlist ::= nm */
+      case 148: /* idlist ::= nm */
 {yymsp[0].minor.yy254 = sqlite3IdListAppend(pParse->db,0,&yymsp[0].minor.yy0); /*A-overwrites-Y*/}
         break;
-      case 150: /* expr ::= LP expr RP */
+      case 149: /* expr ::= LP expr RP */
 {spanSet(&yymsp[-2].minor.yy190,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-B*/  yymsp[-2].minor.yy190.pExpr = yymsp[-1].minor.yy190.pExpr;}
         break;
-      case 151: /* term ::= NULL */
-      case 156: /* term ::= FLOAT|BLOB */ yytestcase(yyruleno==156);
-      case 157: /* term ::= STRING */ yytestcase(yyruleno==157);
-{spanExpr(&yymsp[0].minor.yy190,pParse,yymsp[0].major,yymsp[0].minor.yy0);/*A-overwrites-X*/}
-        break;
-      case 152: /* expr ::= ID|INDEXED */
-      case 153: /* expr ::= JOIN_KW */ yytestcase(yyruleno==153);
+      case 150: /* expr ::= ID|INDEXED */
+      case 151: /* expr ::= JOIN_KW */ yytestcase(yyruleno==151);
 {spanExpr(&yymsp[0].minor.yy190,pParse,TK_ID,yymsp[0].minor.yy0); /*A-overwrites-X*/}
         break;
-      case 154: /* expr ::= nm DOT nm */
+      case 152: /* expr ::= nm DOT nm */
 {
   Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
   Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);
@@ -137738,7 +139414,7 @@ static void yy_reduce(
   yymsp[-2].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);
 }
         break;
-      case 155: /* expr ::= nm DOT nm DOT nm */
+      case 153: /* expr ::= nm DOT nm DOT nm */
 {
   Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-4].minor.yy0, 1);
   Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
@@ -137748,16 +139424,19 @@ static void yy_reduce(
   yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);
 }
         break;
-      case 158: /* term ::= INTEGER */
+      case 154: /* term ::= NULL|FLOAT|BLOB */
+      case 155: /* term ::= STRING */ yytestcase(yyruleno==155);
+{spanExpr(&yymsp[0].minor.yy190,pParse,yymsp[0].major,yymsp[0].minor.yy0); /*A-overwrites-X*/}
+        break;
+      case 156: /* term ::= INTEGER */
 {
   yylhsminor.yy190.pExpr = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);
   yylhsminor.yy190.zStart = yymsp[0].minor.yy0.z;
   yylhsminor.yy190.zEnd = yymsp[0].minor.yy0.z + yymsp[0].minor.yy0.n;
-  if( yylhsminor.yy190.pExpr ) yylhsminor.yy190.pExpr->flags |= EP_Leaf|EP_Resolved;
 }
   yymsp[0].minor.yy190 = yylhsminor.yy190;
         break;
-      case 159: /* expr ::= VARIABLE */
+      case 157: /* expr ::= VARIABLE */
 {
   if( !(yymsp[0].minor.yy0.z[0]=='#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1])) ){
     u32 n = yymsp[0].minor.yy0.n;
@@ -137780,20 +139459,20 @@ static void yy_reduce(
   }
 }
         break;
-      case 160: /* expr ::= expr COLLATE ID|STRING */
+      case 158: /* expr ::= expr COLLATE ID|STRING */
 {
   yymsp[-2].minor.yy190.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy190.pExpr, &yymsp[0].minor.yy0, 1);
   yymsp[-2].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
         break;
-      case 161: /* expr ::= CAST LP expr AS typetoken RP */
+      case 159: /* expr ::= CAST LP expr AS typetoken RP */
 {
   spanSet(&yymsp[-5].minor.yy190,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-X*/
   yymsp[-5].minor.yy190.pExpr = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);
   sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy190.pExpr, yymsp[-3].minor.yy190.pExpr, 0);
 }
         break;
-      case 162: /* expr ::= ID|INDEXED LP distinct exprlist RP */
+      case 160: /* expr ::= ID|INDEXED LP distinct exprlist RP */
 {
   if( yymsp[-1].minor.yy148 && yymsp[-1].minor.yy148->nExpr>pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){
     sqlite3ErrorMsg(pParse, "too many arguments on function %T", &yymsp[-4].minor.yy0);
@@ -137806,21 +139485,21 @@ static void yy_reduce(
 }
   yymsp[-4].minor.yy190 = yylhsminor.yy190;
         break;
-      case 163: /* expr ::= ID|INDEXED LP STAR RP */
+      case 161: /* expr ::= ID|INDEXED LP STAR RP */
 {
   yylhsminor.yy190.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0);
   spanSet(&yylhsminor.yy190,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0);
 }
   yymsp[-3].minor.yy190 = yylhsminor.yy190;
         break;
-      case 164: /* term ::= CTIME_KW */
+      case 162: /* term ::= CTIME_KW */
 {
   yylhsminor.yy190.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0);
   spanSet(&yylhsminor.yy190, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
 }
   yymsp[0].minor.yy190 = yylhsminor.yy190;
         break;
-      case 165: /* expr ::= LP nexprlist COMMA expr RP */
+      case 163: /* expr ::= LP nexprlist COMMA expr RP */
 {
   ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy148, yymsp[-1].minor.yy190.pExpr);
   yylhsminor.yy190.pExpr = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);
@@ -137833,20 +139512,20 @@ static void yy_reduce(
 }
   yymsp[-4].minor.yy190 = yylhsminor.yy190;
         break;
-      case 166: /* expr ::= expr AND expr */
-      case 167: /* expr ::= expr OR expr */ yytestcase(yyruleno==167);
-      case 168: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==168);
-      case 169: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==169);
-      case 170: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==170);
-      case 171: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==171);
-      case 172: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==172);
-      case 173: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==173);
+      case 164: /* expr ::= expr AND expr */
+      case 165: /* expr ::= expr OR expr */ yytestcase(yyruleno==165);
+      case 166: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==166);
+      case 167: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==167);
+      case 168: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==168);
+      case 169: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==169);
+      case 170: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==170);
+      case 171: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==171);
 {spanBinaryExpr(pParse,yymsp[-1].major,&yymsp[-2].minor.yy190,&yymsp[0].minor.yy190);}
         break;
-      case 174: /* likeop ::= NOT LIKE_KW|MATCH */
+      case 172: /* likeop ::= NOT LIKE_KW|MATCH */
 {yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; /*yymsp[-1].minor.yy0-overwrite-yymsp[0].minor.yy0*/}
         break;
-      case 175: /* expr ::= expr likeop expr */
+      case 173: /* expr ::= expr likeop expr */
 {
   ExprList *pList;
   int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
@@ -137859,7 +139538,7 @@ static void yy_reduce(
   if( yymsp[-2].minor.yy190.pExpr ) yymsp[-2].minor.yy190.pExpr->flags |= EP_InfixFunc;
 }
         break;
-      case 176: /* expr ::= expr likeop expr ESCAPE expr */
+      case 174: /* expr ::= expr likeop expr ESCAPE expr */
 {
   ExprList *pList;
   int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
@@ -137873,39 +139552,39 @@ static void yy_reduce(
   if( yymsp[-4].minor.yy190.pExpr ) yymsp[-4].minor.yy190.pExpr->flags |= EP_InfixFunc;
 }
         break;
-      case 177: /* expr ::= expr ISNULL|NOTNULL */
+      case 175: /* expr ::= expr ISNULL|NOTNULL */
 {spanUnaryPostfix(pParse,yymsp[0].major,&yymsp[-1].minor.yy190,&yymsp[0].minor.yy0);}
         break;
-      case 178: /* expr ::= expr NOT NULL */
+      case 176: /* expr ::= expr NOT NULL */
 {spanUnaryPostfix(pParse,TK_NOTNULL,&yymsp[-2].minor.yy190,&yymsp[0].minor.yy0);}
         break;
-      case 179: /* expr ::= expr IS expr */
+      case 177: /* expr ::= expr IS expr */
 {
   spanBinaryExpr(pParse,TK_IS,&yymsp[-2].minor.yy190,&yymsp[0].minor.yy190);
   binaryToUnaryIfNull(pParse, yymsp[0].minor.yy190.pExpr, yymsp[-2].minor.yy190.pExpr, TK_ISNULL);
 }
         break;
-      case 180: /* expr ::= expr IS NOT expr */
+      case 178: /* expr ::= expr IS NOT expr */
 {
   spanBinaryExpr(pParse,TK_ISNOT,&yymsp[-3].minor.yy190,&yymsp[0].minor.yy190);
   binaryToUnaryIfNull(pParse, yymsp[0].minor.yy190.pExpr, yymsp[-3].minor.yy190.pExpr, TK_NOTNULL);
 }
         break;
-      case 181: /* expr ::= NOT expr */
-      case 182: /* expr ::= BITNOT expr */ yytestcase(yyruleno==182);
+      case 179: /* expr ::= NOT expr */
+      case 180: /* expr ::= BITNOT expr */ yytestcase(yyruleno==180);
 {spanUnaryPrefix(&yymsp[-1].minor.yy190,pParse,yymsp[-1].major,&yymsp[0].minor.yy190,&yymsp[-1].minor.yy0);/*A-overwrites-B*/}
         break;
-      case 183: /* expr ::= MINUS expr */
+      case 181: /* expr ::= MINUS expr */
 {spanUnaryPrefix(&yymsp[-1].minor.yy190,pParse,TK_UMINUS,&yymsp[0].minor.yy190,&yymsp[-1].minor.yy0);/*A-overwrites-B*/}
         break;
-      case 184: /* expr ::= PLUS expr */
+      case 182: /* expr ::= PLUS expr */
 {spanUnaryPrefix(&yymsp[-1].minor.yy190,pParse,TK_UPLUS,&yymsp[0].minor.yy190,&yymsp[-1].minor.yy0);/*A-overwrites-B*/}
         break;
-      case 185: /* between_op ::= BETWEEN */
-      case 188: /* in_op ::= IN */ yytestcase(yyruleno==188);
+      case 183: /* between_op ::= BETWEEN */
+      case 186: /* in_op ::= IN */ yytestcase(yyruleno==186);
 {yymsp[0].minor.yy194 = 0;}
         break;
-      case 187: /* expr ::= expr between_op expr AND expr */
+      case 185: /* expr ::= expr between_op expr AND expr */
 {
   ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy190.pExpr);
   pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy190.pExpr);
@@ -137919,7 +139598,7 @@ static void yy_reduce(
   yymsp[-4].minor.yy190.zEnd = yymsp[0].minor.yy190.zEnd;
 }
         break;
-      case 190: /* expr ::= expr in_op LP exprlist RP */
+      case 188: /* expr ::= expr in_op LP exprlist RP */
 {
     if( yymsp[-1].minor.yy148==0 ){
       /* Expressions of the form
@@ -137972,14 +139651,14 @@ static void yy_reduce(
     yymsp[-4].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 191: /* expr ::= LP select RP */
+      case 189: /* expr ::= LP select RP */
 {
     spanSet(&yymsp[-2].minor.yy190,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-B*/
     yymsp[-2].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
     sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy190.pExpr, yymsp[-1].minor.yy243);
   }
         break;
-      case 192: /* expr ::= expr in_op LP select RP */
+      case 190: /* expr ::= expr in_op LP select RP */
 {
     yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy190.pExpr, 0);
     sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy190.pExpr, yymsp[-1].minor.yy243);
@@ -137987,7 +139666,7 @@ static void yy_reduce(
     yymsp[-4].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 193: /* expr ::= expr in_op nm dbnm paren_exprlist */
+      case 191: /* expr ::= expr in_op nm dbnm paren_exprlist */
 {
     SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);
     Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0);
@@ -137998,7 +139677,7 @@ static void yy_reduce(
     yymsp[-4].minor.yy190.zEnd = yymsp[-1].minor.yy0.z ? &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n] : &yymsp[-2].minor.yy0.z[yymsp[-2].minor.yy0.n];
   }
         break;
-      case 194: /* expr ::= EXISTS LP select RP */
+      case 192: /* expr ::= EXISTS LP select RP */
 {
     Expr *p;
     spanSet(&yymsp[-3].minor.yy190,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-B*/
@@ -138006,7 +139685,7 @@ static void yy_reduce(
     sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy243);
   }
         break;
-      case 195: /* expr ::= CASE case_operand case_exprlist case_else END */
+      case 193: /* expr ::= CASE case_operand case_exprlist case_else END */
 {
   spanSet(&yymsp[-4].minor.yy190,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);  /*A-overwrites-C*/
   yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy72, 0);
@@ -138019,80 +139698,80 @@ static void yy_reduce(
   }
 }
         break;
-      case 196: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
+      case 194: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
 {
   yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy148, yymsp[-2].minor.yy190.pExpr);
   yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy148, yymsp[0].minor.yy190.pExpr);
 }
         break;
-      case 197: /* case_exprlist ::= WHEN expr THEN expr */
+      case 195: /* case_exprlist ::= WHEN expr THEN expr */
 {
   yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy190.pExpr);
   yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy148, yymsp[0].minor.yy190.pExpr);
 }
         break;
-      case 200: /* case_operand ::= expr */
+      case 198: /* case_operand ::= expr */
 {yymsp[0].minor.yy72 = yymsp[0].minor.yy190.pExpr; /*A-overwrites-X*/}
         break;
-      case 203: /* nexprlist ::= nexprlist COMMA expr */
+      case 201: /* nexprlist ::= nexprlist COMMA expr */
 {yymsp[-2].minor.yy148 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy148,yymsp[0].minor.yy190.pExpr);}
         break;
-      case 204: /* nexprlist ::= expr */
+      case 202: /* nexprlist ::= expr */
 {yymsp[0].minor.yy148 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy190.pExpr); /*A-overwrites-Y*/}
         break;
-      case 206: /* paren_exprlist ::= LP exprlist RP */
-      case 211: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==211);
+      case 204: /* paren_exprlist ::= LP exprlist RP */
+      case 209: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==209);
 {yymsp[-2].minor.yy148 = yymsp[-1].minor.yy148;}
         break;
-      case 207: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
+      case 205: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
 {
   sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, 
                      sqlite3SrcListAppend(pParse->db,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy148, yymsp[-10].minor.yy194,
                       &yymsp[-11].minor.yy0, yymsp[0].minor.yy72, SQLITE_SO_ASC, yymsp[-8].minor.yy194, SQLITE_IDXTYPE_APPDEF);
 }
         break;
-      case 208: /* uniqueflag ::= UNIQUE */
-      case 249: /* raisetype ::= ABORT */ yytestcase(yyruleno==249);
+      case 206: /* uniqueflag ::= UNIQUE */
+      case 246: /* raisetype ::= ABORT */ yytestcase(yyruleno==246);
 {yymsp[0].minor.yy194 = OE_Abort;}
         break;
-      case 209: /* uniqueflag ::= */
+      case 207: /* uniqueflag ::= */
 {yymsp[1].minor.yy194 = OE_None;}
         break;
-      case 212: /* eidlist ::= eidlist COMMA nm collate sortorder */
+      case 210: /* eidlist ::= eidlist COMMA nm collate sortorder */
 {
   yymsp[-4].minor.yy148 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy148, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy194, yymsp[0].minor.yy194);
 }
         break;
-      case 213: /* eidlist ::= nm collate sortorder */
+      case 211: /* eidlist ::= nm collate sortorder */
 {
   yymsp[-2].minor.yy148 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy194, yymsp[0].minor.yy194); /*A-overwrites-Y*/
 }
         break;
-      case 216: /* cmd ::= DROP INDEX ifexists fullname */
+      case 214: /* cmd ::= DROP INDEX ifexists fullname */
 {sqlite3DropIndex(pParse, yymsp[0].minor.yy185, yymsp[-1].minor.yy194);}
         break;
-      case 217: /* cmd ::= VACUUM */
+      case 215: /* cmd ::= VACUUM */
 {sqlite3Vacuum(pParse,0);}
         break;
-      case 218: /* cmd ::= VACUUM nm */
+      case 216: /* cmd ::= VACUUM nm */
 {sqlite3Vacuum(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 219: /* cmd ::= PRAGMA nm dbnm */
+      case 217: /* cmd ::= PRAGMA nm dbnm */
 {sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
         break;
-      case 220: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
+      case 218: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
         break;
-      case 221: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
+      case 219: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
         break;
-      case 222: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
+      case 220: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
         break;
-      case 223: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
+      case 221: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
         break;
-      case 226: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
+      case 224: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
 {
   Token all;
   all.z = yymsp[-3].minor.yy0.z;
@@ -138100,53 +139779,50 @@ static void yy_reduce(
   sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy145, &all);
 }
         break;
-      case 227: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
+      case 225: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
 {
   sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy194, yymsp[-4].minor.yy332.a, yymsp[-4].minor.yy332.b, yymsp[-2].minor.yy185, yymsp[0].minor.yy72, yymsp[-10].minor.yy194, yymsp[-8].minor.yy194);
   yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0); /*A-overwrites-T*/
 }
         break;
-      case 228: /* trigger_time ::= BEFORE */
-{ yymsp[0].minor.yy194 = TK_BEFORE; }
-        break;
-      case 229: /* trigger_time ::= AFTER */
-{ yymsp[0].minor.yy194 = TK_AFTER;  }
+      case 226: /* trigger_time ::= BEFORE|AFTER */
+{ yymsp[0].minor.yy194 = yymsp[0].major; /*A-overwrites-X*/ }
         break;
-      case 230: /* trigger_time ::= INSTEAD OF */
+      case 227: /* trigger_time ::= INSTEAD OF */
 { yymsp[-1].minor.yy194 = TK_INSTEAD;}
         break;
-      case 231: /* trigger_time ::= */
+      case 228: /* trigger_time ::= */
 { yymsp[1].minor.yy194 = TK_BEFORE; }
         break;
-      case 232: /* trigger_event ::= DELETE|INSERT */
-      case 233: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==233);
+      case 229: /* trigger_event ::= DELETE|INSERT */
+      case 230: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==230);
 {yymsp[0].minor.yy332.a = yymsp[0].major; /*A-overwrites-X*/ yymsp[0].minor.yy332.b = 0;}
         break;
-      case 234: /* trigger_event ::= UPDATE OF idlist */
+      case 231: /* trigger_event ::= UPDATE OF idlist */
 {yymsp[-2].minor.yy332.a = TK_UPDATE; yymsp[-2].minor.yy332.b = yymsp[0].minor.yy254;}
         break;
-      case 235: /* when_clause ::= */
-      case 254: /* key_opt ::= */ yytestcase(yyruleno==254);
+      case 232: /* when_clause ::= */
+      case 251: /* key_opt ::= */ yytestcase(yyruleno==251);
 { yymsp[1].minor.yy72 = 0; }
         break;
-      case 236: /* when_clause ::= WHEN expr */
-      case 255: /* key_opt ::= KEY expr */ yytestcase(yyruleno==255);
+      case 233: /* when_clause ::= WHEN expr */
+      case 252: /* key_opt ::= KEY expr */ yytestcase(yyruleno==252);
 { yymsp[-1].minor.yy72 = yymsp[0].minor.yy190.pExpr; }
         break;
-      case 237: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
+      case 234: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
 {
   assert( yymsp[-2].minor.yy145!=0 );
   yymsp[-2].minor.yy145->pLast->pNext = yymsp[-1].minor.yy145;
   yymsp[-2].minor.yy145->pLast = yymsp[-1].minor.yy145;
 }
         break;
-      case 238: /* trigger_cmd_list ::= trigger_cmd SEMI */
+      case 235: /* trigger_cmd_list ::= trigger_cmd SEMI */
 { 
   assert( yymsp[-1].minor.yy145!=0 );
   yymsp[-1].minor.yy145->pLast = yymsp[-1].minor.yy145;
 }
         break;
-      case 239: /* trnm ::= nm DOT nm */
+      case 236: /* trnm ::= nm DOT nm */
 {
   yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;
   sqlite3ErrorMsg(pParse, 
@@ -138154,33 +139830,33 @@ static void yy_reduce(
         "statements within triggers");
 }
         break;
-      case 240: /* tridxby ::= INDEXED BY nm */
+      case 237: /* tridxby ::= INDEXED BY nm */
 {
   sqlite3ErrorMsg(pParse,
         "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 241: /* tridxby ::= NOT INDEXED */
+      case 238: /* tridxby ::= NOT INDEXED */
 {
   sqlite3ErrorMsg(pParse,
         "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 242: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt */
+      case 239: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt */
 {yymsp[-6].minor.yy145 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-4].minor.yy0, yymsp[-1].minor.yy148, yymsp[0].minor.yy72, yymsp[-5].minor.yy194);}
         break;
-      case 243: /* trigger_cmd ::= insert_cmd INTO trnm idlist_opt select */
+      case 240: /* trigger_cmd ::= insert_cmd INTO trnm idlist_opt select */
 {yymsp[-4].minor.yy145 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy254, yymsp[0].minor.yy243, yymsp[-4].minor.yy194);/*A-overwrites-R*/}
         break;
-      case 244: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt */
+      case 241: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt */
 {yymsp[-4].minor.yy145 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[0].minor.yy72);}
         break;
-      case 245: /* trigger_cmd ::= select */
+      case 242: /* trigger_cmd ::= select */
 {yymsp[0].minor.yy145 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy243); /*A-overwrites-X*/}
         break;
-      case 246: /* expr ::= RAISE LP IGNORE RP */
+      case 243: /* expr ::= RAISE LP IGNORE RP */
 {
   spanSet(&yymsp[-3].minor.yy190,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0);  /*A-overwrites-X*/
   yymsp[-3].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0); 
@@ -138189,7 +139865,7 @@ static void yy_reduce(
   }
 }
         break;
-      case 247: /* expr ::= RAISE LP raisetype COMMA nm RP */
+      case 244: /* expr ::= RAISE LP raisetype COMMA nm RP */
 {
   spanSet(&yymsp[-5].minor.yy190,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0);  /*A-overwrites-X*/
   yymsp[-5].minor.yy190.pExpr = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1); 
@@ -138198,172 +139874,176 @@ static void yy_reduce(
   }
 }
         break;
-      case 248: /* raisetype ::= ROLLBACK */
+      case 245: /* raisetype ::= ROLLBACK */
 {yymsp[0].minor.yy194 = OE_Rollback;}
         break;
-      case 250: /* raisetype ::= FAIL */
+      case 247: /* raisetype ::= FAIL */
 {yymsp[0].minor.yy194 = OE_Fail;}
         break;
-      case 251: /* cmd ::= DROP TRIGGER ifexists fullname */
+      case 248: /* cmd ::= DROP TRIGGER ifexists fullname */
 {
   sqlite3DropTrigger(pParse,yymsp[0].minor.yy185,yymsp[-1].minor.yy194);
 }
         break;
-      case 252: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
+      case 249: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
 {
   sqlite3Attach(pParse, yymsp[-3].minor.yy190.pExpr, yymsp[-1].minor.yy190.pExpr, yymsp[0].minor.yy72);
 }
         break;
-      case 253: /* cmd ::= DETACH database_kw_opt expr */
+      case 250: /* cmd ::= DETACH database_kw_opt expr */
 {
   sqlite3Detach(pParse, yymsp[0].minor.yy190.pExpr);
 }
         break;
-      case 256: /* cmd ::= REINDEX */
+      case 253: /* cmd ::= REINDEX */
 {sqlite3Reindex(pParse, 0, 0);}
         break;
-      case 257: /* cmd ::= REINDEX nm dbnm */
+      case 254: /* cmd ::= REINDEX nm dbnm */
 {sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 258: /* cmd ::= ANALYZE */
+      case 255: /* cmd ::= ANALYZE */
 {sqlite3Analyze(pParse, 0, 0);}
         break;
-      case 259: /* cmd ::= ANALYZE nm dbnm */
+      case 256: /* cmd ::= ANALYZE nm dbnm */
 {sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 260: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
+      case 257: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
 {
   sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy185,&yymsp[0].minor.yy0);
 }
         break;
-      case 261: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
+      case 258: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
 {
   yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;
   sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);
 }
         break;
-      case 262: /* add_column_fullname ::= fullname */
+      case 259: /* add_column_fullname ::= fullname */
 {
   disableLookaside(pParse);
   sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy185);
 }
         break;
-      case 263: /* cmd ::= create_vtab */
+      case 260: /* cmd ::= create_vtab */
 {sqlite3VtabFinishParse(pParse,0);}
         break;
-      case 264: /* cmd ::= create_vtab LP vtabarglist RP */
+      case 261: /* cmd ::= create_vtab LP vtabarglist RP */
 {sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 265: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
+      case 262: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
 {
     sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy194);
 }
         break;
-      case 266: /* vtabarg ::= */
+      case 263: /* vtabarg ::= */
 {sqlite3VtabArgInit(pParse);}
         break;
-      case 267: /* vtabargtoken ::= ANY */
-      case 268: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==268);
-      case 269: /* lp ::= LP */ yytestcase(yyruleno==269);
+      case 264: /* vtabargtoken ::= ANY */
+      case 265: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==265);
+      case 266: /* lp ::= LP */ yytestcase(yyruleno==266);
 {sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 270: /* with ::= */
+      case 267: /* with ::= */
 {yymsp[1].minor.yy285 = 0;}
         break;
-      case 271: /* with ::= WITH wqlist */
+      case 268: /* with ::= WITH wqlist */
 { yymsp[-1].minor.yy285 = yymsp[0].minor.yy285; }
         break;
-      case 272: /* with ::= WITH RECURSIVE wqlist */
+      case 269: /* with ::= WITH RECURSIVE wqlist */
 { yymsp[-2].minor.yy285 = yymsp[0].minor.yy285; }
         break;
-      case 273: /* wqlist ::= nm eidlist_opt AS LP select RP */
+      case 270: /* wqlist ::= nm eidlist_opt AS LP select RP */
 {
   yymsp[-5].minor.yy285 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy148, yymsp[-1].minor.yy243); /*A-overwrites-X*/
 }
         break;
-      case 274: /* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
+      case 271: /* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
 {
   yymsp[-7].minor.yy285 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy285, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy148, yymsp[-1].minor.yy243);
 }
         break;
       default:
-      /* (275) input ::= cmdlist */ yytestcase(yyruleno==275);
-      /* (276) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==276);
-      /* (277) cmdlist ::= ecmd (OPTIMIZED OUT) */ assert(yyruleno!=277);
-      /* (278) ecmd ::= SEMI */ yytestcase(yyruleno==278);
-      /* (279) ecmd ::= explain cmdx SEMI */ yytestcase(yyruleno==279);
-      /* (280) explain ::= */ yytestcase(yyruleno==280);
-      /* (281) trans_opt ::= */ yytestcase(yyruleno==281);
-      /* (282) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==282);
-      /* (283) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==283);
-      /* (284) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==284);
-      /* (285) savepoint_opt ::= */ yytestcase(yyruleno==285);
-      /* (286) cmd ::= create_table create_table_args */ yytestcase(yyruleno==286);
-      /* (287) columnlist ::= columnlist COMMA columnname carglist */ yytestcase(yyruleno==287);
-      /* (288) columnlist ::= columnname carglist */ yytestcase(yyruleno==288);
-      /* (289) nm ::= ID|INDEXED */ yytestcase(yyruleno==289);
-      /* (290) nm ::= STRING */ yytestcase(yyruleno==290);
-      /* (291) nm ::= JOIN_KW */ yytestcase(yyruleno==291);
-      /* (292) typetoken ::= typename */ yytestcase(yyruleno==292);
-      /* (293) typename ::= ID|STRING */ yytestcase(yyruleno==293);
-      /* (294) signed ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=294);
-      /* (295) signed ::= minus_num (OPTIMIZED OUT) */ assert(yyruleno!=295);
-      /* (296) carglist ::= carglist ccons */ yytestcase(yyruleno==296);
-      /* (297) carglist ::= */ yytestcase(yyruleno==297);
-      /* (298) ccons ::= NULL onconf */ yytestcase(yyruleno==298);
-      /* (299) conslist_opt ::= COMMA conslist */ yytestcase(yyruleno==299);
-      /* (300) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==300);
-      /* (301) conslist ::= tcons (OPTIMIZED OUT) */ assert(yyruleno!=301);
-      /* (302) tconscomma ::= */ yytestcase(yyruleno==302);
-      /* (303) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) */ assert(yyruleno!=303);
-      /* (304) resolvetype ::= raisetype (OPTIMIZED OUT) */ assert(yyruleno!=304);
-      /* (305) selectnowith ::= oneselect (OPTIMIZED OUT) */ assert(yyruleno!=305);
-      /* (306) oneselect ::= values */ yytestcase(yyruleno==306);
-      /* (307) sclp ::= selcollist COMMA */ yytestcase(yyruleno==307);
-      /* (308) as ::= ID|STRING */ yytestcase(yyruleno==308);
-      /* (309) expr ::= term (OPTIMIZED OUT) */ assert(yyruleno!=309);
-      /* (310) likeop ::= LIKE_KW|MATCH */ yytestcase(yyruleno==310);
-      /* (311) exprlist ::= nexprlist */ yytestcase(yyruleno==311);
-      /* (312) nmnum ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=312);
-      /* (313) nmnum ::= nm (OPTIMIZED OUT) */ assert(yyruleno!=313);
-      /* (314) nmnum ::= ON */ yytestcase(yyruleno==314);
-      /* (315) nmnum ::= DELETE */ yytestcase(yyruleno==315);
-      /* (316) nmnum ::= DEFAULT */ yytestcase(yyruleno==316);
-      /* (317) plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==317);
-      /* (318) foreach_clause ::= */ yytestcase(yyruleno==318);
-      /* (319) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==319);
-      /* (320) trnm ::= nm */ yytestcase(yyruleno==320);
-      /* (321) tridxby ::= */ yytestcase(yyruleno==321);
-      /* (322) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==322);
-      /* (323) database_kw_opt ::= */ yytestcase(yyruleno==323);
-      /* (324) kwcolumn_opt ::= */ yytestcase(yyruleno==324);
-      /* (325) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==325);
-      /* (326) vtabarglist ::= vtabarg */ yytestcase(yyruleno==326);
-      /* (327) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==327);
-      /* (328) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==328);
-      /* (329) anylist ::= */ yytestcase(yyruleno==329);
-      /* (330) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==330);
-      /* (331) anylist ::= anylist ANY */ yytestcase(yyruleno==331);
+      /* (272) input ::= cmdlist */ yytestcase(yyruleno==272);
+      /* (273) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==273);
+      /* (274) cmdlist ::= ecmd (OPTIMIZED OUT) */ assert(yyruleno!=274);
+      /* (275) ecmd ::= SEMI */ yytestcase(yyruleno==275);
+      /* (276) ecmd ::= explain cmdx SEMI */ yytestcase(yyruleno==276);
+      /* (277) explain ::= */ yytestcase(yyruleno==277);
+      /* (278) trans_opt ::= */ yytestcase(yyruleno==278);
+      /* (279) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==279);
+      /* (280) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==280);
+      /* (281) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==281);
+      /* (282) savepoint_opt ::= */ yytestcase(yyruleno==282);
+      /* (283) cmd ::= create_table create_table_args */ yytestcase(yyruleno==283);
+      /* (284) columnlist ::= columnlist COMMA columnname carglist */ yytestcase(yyruleno==284);
+      /* (285) columnlist ::= columnname carglist */ yytestcase(yyruleno==285);
+      /* (286) nm ::= ID|INDEXED */ yytestcase(yyruleno==286);
+      /* (287) nm ::= STRING */ yytestcase(yyruleno==287);
+      /* (288) nm ::= JOIN_KW */ yytestcase(yyruleno==288);
+      /* (289) typetoken ::= typename */ yytestcase(yyruleno==289);
+      /* (290) typename ::= ID|STRING */ yytestcase(yyruleno==290);
+      /* (291) signed ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=291);
+      /* (292) signed ::= minus_num (OPTIMIZED OUT) */ assert(yyruleno!=292);
+      /* (293) carglist ::= carglist ccons */ yytestcase(yyruleno==293);
+      /* (294) carglist ::= */ yytestcase(yyruleno==294);
+      /* (295) ccons ::= NULL onconf */ yytestcase(yyruleno==295);
+      /* (296) conslist_opt ::= COMMA conslist */ yytestcase(yyruleno==296);
+      /* (297) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==297);
+      /* (298) conslist ::= tcons (OPTIMIZED OUT) */ assert(yyruleno!=298);
+      /* (299) tconscomma ::= */ yytestcase(yyruleno==299);
+      /* (300) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) */ assert(yyruleno!=300);
+      /* (301) resolvetype ::= raisetype (OPTIMIZED OUT) */ assert(yyruleno!=301);
+      /* (302) selectnowith ::= oneselect (OPTIMIZED OUT) */ assert(yyruleno!=302);
+      /* (303) oneselect ::= values */ yytestcase(yyruleno==303);
+      /* (304) sclp ::= selcollist COMMA */ yytestcase(yyruleno==304);
+      /* (305) as ::= ID|STRING */ yytestcase(yyruleno==305);
+      /* (306) expr ::= term (OPTIMIZED OUT) */ assert(yyruleno!=306);
+      /* (307) likeop ::= LIKE_KW|MATCH */ yytestcase(yyruleno==307);
+      /* (308) exprlist ::= nexprlist */ yytestcase(yyruleno==308);
+      /* (309) nmnum ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=309);
+      /* (310) nmnum ::= nm (OPTIMIZED OUT) */ assert(yyruleno!=310);
+      /* (311) nmnum ::= ON */ yytestcase(yyruleno==311);
+      /* (312) nmnum ::= DELETE */ yytestcase(yyruleno==312);
+      /* (313) nmnum ::= DEFAULT */ yytestcase(yyruleno==313);
+      /* (314) plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==314);
+      /* (315) foreach_clause ::= */ yytestcase(yyruleno==315);
+      /* (316) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==316);
+      /* (317) trnm ::= nm */ yytestcase(yyruleno==317);
+      /* (318) tridxby ::= */ yytestcase(yyruleno==318);
+      /* (319) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==319);
+      /* (320) database_kw_opt ::= */ yytestcase(yyruleno==320);
+      /* (321) kwcolumn_opt ::= */ yytestcase(yyruleno==321);
+      /* (322) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==322);
+      /* (323) vtabarglist ::= vtabarg */ yytestcase(yyruleno==323);
+      /* (324) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==324);
+      /* (325) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==325);
+      /* (326) anylist ::= */ yytestcase(yyruleno==326);
+      /* (327) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==327);
+      /* (328) anylist ::= anylist ANY */ yytestcase(yyruleno==328);
         break;
 /********** End reduce actions ************************************************/
   };
   assert( yyruleno<sizeof(yyRuleInfo)/sizeof(yyRuleInfo[0]) );
   yygoto = yyRuleInfo[yyruleno].lhs;
   yysize = yyRuleInfo[yyruleno].nrhs;
-  yyact = yy_find_reduce_action(yymsp[-yysize].stateno,(YYCODETYPE)yygoto);
-  if( yyact <= YY_MAX_SHIFTREDUCE ){
-    if( yyact>YY_MAX_SHIFT ){
-      yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
-    }
-    yymsp -= yysize-1;
+  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);
+
+  /* There are no SHIFTREDUCE actions on nonterminals because the table
+  ** generator has simplified them to pure REDUCE actions. */
+  assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );
+
+  /* It is not possible for a REDUCE to be followed by an error */
+  assert( yyact!=YY_ERROR_ACTION );
+
+  if( yyact==YY_ACCEPT_ACTION ){
+    yypParser->yytos += yysize;
+    yy_accept(yypParser);
+  }else{
+    yymsp += yysize+1;
     yypParser->yytos = yymsp;
     yymsp->stateno = (YYACTIONTYPE)yyact;
     yymsp->major = (YYCODETYPE)yygoto;
     yyTraceShift(yypParser, yyact);
-  }else{
-    assert( yyact == YY_ACCEPT_ACTION );
-    yypParser->yytos -= yysize;
-    yy_accept(yypParser);
   }
 }
 
@@ -138769,134 +140449,145 @@ const unsigned char ebcdicToAscii[] = {
 ** on platforms with limited memory.
 */
 /* Hash score: 182 */
+/* zKWText[] encodes 834 bytes of keyword text in 554 bytes */
+/*   REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECT       */
+/*   ABLEFTHENDEFERRABLELSEXCEPTRANSACTIONATURALTERAISEXCLUSIVE         */
+/*   XISTSAVEPOINTERSECTRIGGEREFERENCESCONSTRAINTOFFSETEMPORARY         */
+/*   UNIQUERYWITHOUTERELEASEATTACHAVINGROUPDATEBEGINNERECURSIVE         */
+/*   BETWEENOTNULLIKECASCADELETECASECOLLATECREATECURRENT_DATEDETACH     */
+/*   IMMEDIATEJOINSERTMATCHPLANALYZEPRAGMABORTVALUESVIRTUALIMITWHEN     */
+/*   WHERENAMEAFTEREPLACEANDEFAULTAUTOINCREMENTCASTCOLUMNCOMMIT         */
+/*   CONFLICTCROSSCURRENT_TIMESTAMPRIMARYDEFERREDISTINCTDROPFAIL        */
+/*   FROMFULLGLOBYIFISNULLORDERESTRICTRIGHTROLLBACKROWUNIONUSING        */
+/*   VACUUMVIEWINITIALLY                                                */
+static const char zKWText[553] = {
+  'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
+  'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
+  'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
+  'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
+  'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
+  'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
+  'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
+  'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
+  'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
+  'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
+  'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
+  'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
+  'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
+  'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
+  'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
+  'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
+  'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
+  'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
+  'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
+  'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
+  'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
+  'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
+  'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
+  'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
+  'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
+  'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
+  'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
+  'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
+  'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
+  'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
+  'V','I','E','W','I','N','I','T','I','A','L','L','Y',
+};
+/* aKWHash[i] is the hash value for the i-th keyword */
+static const unsigned char aKWHash[127] = {
+    76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
+    42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
+   121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
+     0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
+     0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
+    96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
+   100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
+    39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
+    62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
+    29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
+};
+/* aKWNext[] forms the hash collision chain.  If aKWHash[i]==0
+** then the i-th keyword has no more hash collisions.  Otherwise,
+** the next keyword with the same hash is aKWHash[i]-1. */
+static const unsigned char aKWNext[124] = {
+     0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
+     0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
+     0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+     0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
+     0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
+     0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
+     0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
+    10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
+     0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
+    73,  83,   0,  35,  68,   0,   0,
+};
+/* aKWLen[i] is the length (in bytes) of the i-th keyword */
+static const unsigned char aKWLen[124] = {
+     7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
+     7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
+    11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
+     4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
+     6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
+     7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
+     7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
+    13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
+     2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
+     3,   5,   5,   6,   4,   9,   3,
+};
+/* aKWOffset[i] is the index into zKWText[] of the start of
+** the text for the i-th keyword. */
+static const unsigned short int aKWOffset[124] = {
+     0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
+    36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
+    86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
+   159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
+   199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
+   250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
+   320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
+   387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
+   460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
+   521, 524, 529, 534, 540, 544, 549,
+};
+/* aKWCode[i] is the parser symbol code for the i-th keyword */
+static const unsigned char aKWCode[124] = {
+  TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,     
+  TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,    
+  TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,    
+  TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,      
+  TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,       
+  TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,    
+  TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  
+  TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       
+  TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       
+  TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,       
+  TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,      
+  TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,    
+  TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,    
+  TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,    
+  TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       
+  TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     
+  TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,       
+  TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,        
+  TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       
+  TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   
+  TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,         
+  TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    
+  TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   
+  TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,      
+  TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,        
+};
+/* Check to see if z[0..n-1] is a keyword. If it is, write the
+** parser symbol code for that keyword into *pType.  Always
+** return the integer n (the length of the token). */
 static int keywordCode(const char *z, int n, int *pType){
-  /* zText[] encodes 834 bytes of keywords in 554 bytes */
-  /*   REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECT       */
-  /*   ABLEFTHENDEFERRABLELSEXCEPTRANSACTIONATURALTERAISEXCLUSIVE         */
-  /*   XISTSAVEPOINTERSECTRIGGEREFERENCESCONSTRAINTOFFSETEMPORARY         */
-  /*   UNIQUERYWITHOUTERELEASEATTACHAVINGROUPDATEBEGINNERECURSIVE         */
-  /*   BETWEENOTNULLIKECASCADELETECASECOLLATECREATECURRENT_DATEDETACH     */
-  /*   IMMEDIATEJOINSERTMATCHPLANALYZEPRAGMABORTVALUESVIRTUALIMITWHEN     */
-  /*   WHERENAMEAFTEREPLACEANDEFAULTAUTOINCREMENTCASTCOLUMNCOMMIT         */
-  /*   CONFLICTCROSSCURRENT_TIMESTAMPRIMARYDEFERREDISTINCTDROPFAIL        */
-  /*   FROMFULLGLOBYIFISNULLORDERESTRICTRIGHTROLLBACKROWUNIONUSING        */
-  /*   VACUUMVIEWINITIALLY                                                */
-  static const char zText[553] = {
-    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
-    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
-    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
-    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
-    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
-    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
-    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
-    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
-    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
-    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
-    'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
-    'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
-    'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
-    'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
-    'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
-    'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
-    'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
-    'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
-    'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
-    'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
-    'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
-    'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
-    'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
-    'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
-    'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
-    'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
-    'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
-    'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
-    'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
-    'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
-    'V','I','E','W','I','N','I','T','I','A','L','L','Y',
-  };
-  static const unsigned char aHash[127] = {
-      76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
-      42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
-     121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
-       0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
-       0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
-      96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
-     100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
-      39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
-      62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
-      29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
-  };
-  static const unsigned char aNext[124] = {
-       0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
-       0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
-       0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
-       0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
-       0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
-       0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
-       0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
-      10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
-       0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
-      73,  83,   0,  35,  68,   0,   0,
-  };
-  static const unsigned char aLen[124] = {
-       7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
-       7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
-      11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
-       4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
-       6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
-       7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
-       7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
-      13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
-       2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
-       3,   5,   5,   6,   4,   9,   3,
-  };
-  static const unsigned short int aOffset[124] = {
-       0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
-      36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
-      86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
-     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
-     199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
-     250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
-     320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
-     387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
-     460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
-     521, 524, 529, 534, 540, 544, 549,
-  };
-  static const unsigned char aCode[124] = {
-    TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,     
-    TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,    
-    TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,    
-    TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,      
-    TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,       
-    TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,    
-    TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  
-    TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       
-    TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       
-    TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,       
-    TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,      
-    TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,    
-    TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,    
-    TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,    
-    TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       
-    TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     
-    TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,       
-    TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,        
-    TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       
-    TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   
-    TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,         
-    TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    
-    TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   
-    TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,      
-    TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,        
-  };
   int i, j;
   const char *zKW;
   if( n>=2 ){
     i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127;
-    for(i=((int)aHash[i])-1; i>=0; i=((int)aNext[i])-1){
-      if( aLen[i]!=n ) continue;
+    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){
+      if( aKWLen[i]!=n ) continue;
       j = 0;
-      zKW = &zText[aOffset[i]];
+      zKW = &zKWText[aKWOffset[i]];
 #ifdef SQLITE_ASCII
       while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }
 #endif
@@ -139028,7 +140719,7 @@ static int keywordCode(const char *z, int n, int *pType){
       testcase( i==121 ); /* VIEW */
       testcase( i==122 ); /* INITIALLY */
       testcase( i==123 ); /* ALL */
-      *pType = aCode[i];
+      *pType = aKWCode[i];
       break;
     }
   }
@@ -139382,7 +141073,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
   sqlite3 *db = pParse->db;       /* The database connection */
   int mxSqlLen;                   /* Max length of an SQL string */
 #ifdef sqlite3Parser_ENGINEALWAYSONSTACK
-  unsigned char zSpace[sizeof(yyParser)];  /* Space for parser engine object */
+  yyParser sEngine;    /* Space to hold the Lemon-generated Parser object */
 #endif
 
   assert( zSql!=0 );
@@ -139395,7 +141086,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
   assert( pzErrMsg!=0 );
   /* sqlite3ParserTrace(stdout, "parser: "); */
 #ifdef sqlite3Parser_ENGINEALWAYSONSTACK
-  pEngine = zSpace;
+  pEngine = &sEngine;
   sqlite3ParserInit(pEngine);
 #else
   pEngine = sqlite3ParserAlloc(sqlite3Malloc);
@@ -139504,7 +141195,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
   while( pParse->pAinc ){
     AutoincInfo *p = pParse->pAinc;
     pParse->pAinc = p->pNext;
-    sqlite3DbFree(db, p);
+    sqlite3DbFreeNN(db, p);
   }
   while( pParse->pZombieTab ){
     Table *p = pParse->pZombieTab;
@@ -139931,6 +141622,9 @@ SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db);
 #ifdef SQLITE_ENABLE_JSON1
 SQLITE_PRIVATE int sqlite3Json1Init(sqlite3*);
 #endif
+#ifdef SQLITE_ENABLE_STMTVTAB
+SQLITE_PRIVATE int sqlite3StmtVtabInit(sqlite3*);
+#endif
 #ifdef SQLITE_ENABLE_FTS5
 SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);
 #endif
@@ -140693,6 +142387,8 @@ SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){
   va_start(ap, op);
   switch( op ){
     case SQLITE_DBCONFIG_MAINDBNAME: {
+      /* IMP: R-06824-28531 */
+      /* IMP: R-36257-52125 */
       db->aDb[0].zDbSName = va_arg(ap,char*);
       rc = SQLITE_OK;
       break;
@@ -140714,6 +142410,7 @@ SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){
         { SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_Fts3Tokenizer  },
         { SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_LoadExtension  },
         { SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE,      SQLITE_NoCkptOnClose  },
+        { SQLITE_DBCONFIG_ENABLE_QPSG,           SQLITE_EnableQPSG     },
       };
       unsigned int i;
       rc = SQLITE_ERROR; /* IMP: R-42790-23372 */
@@ -140770,6 +142467,7 @@ static int binCollFunc(
   /* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
   ** strings byte by byte using the memcmp() function from the standard C
   ** library. */
+  assert( pKey1 && pKey2 );
   rc = memcmp(pKey1, pKey2, n);
   if( rc==0 ){
     if( padFlag
@@ -141302,10 +143000,10 @@ SQLITE_PRIVATE const char *sqlite3ErrName(int rc){
 SQLITE_PRIVATE const char *sqlite3ErrStr(int rc){
   static const char* const aMsg[] = {
     /* SQLITE_OK          */ "not an error",
-    /* SQLITE_ERROR       */ "SQL logic error or missing database",
+    /* SQLITE_ERROR       */ "SQL logic error",
     /* SQLITE_INTERNAL    */ 0,
     /* SQLITE_PERM        */ "access permission denied",
-    /* SQLITE_ABORT       */ "callback requested query abort",
+    /* SQLITE_ABORT       */ "query aborted",
     /* SQLITE_BUSY        */ "database is locked",
     /* SQLITE_LOCKED      */ "database table is locked",
     /* SQLITE_NOMEM       */ "out of memory",
@@ -141317,17 +143015,21 @@ SQLITE_PRIVATE const char *sqlite3ErrStr(int rc){
     /* SQLITE_FULL        */ "database or disk is full",
     /* SQLITE_CANTOPEN    */ "unable to open database file",
     /* SQLITE_PROTOCOL    */ "locking protocol",
-    /* SQLITE_EMPTY       */ "table contains no data",
+    /* SQLITE_EMPTY       */ 0,
     /* SQLITE_SCHEMA      */ "database schema has changed",
     /* SQLITE_TOOBIG      */ "string or blob too big",
     /* SQLITE_CONSTRAINT  */ "constraint failed",
     /* SQLITE_MISMATCH    */ "datatype mismatch",
-    /* SQLITE_MISUSE      */ "library routine called out of sequence",
+    /* SQLITE_MISUSE      */ "bad parameter or other API misuse",
+#ifdef SQLITE_DISABLE_LFS
     /* SQLITE_NOLFS       */ "large file support is disabled",
+#else
+    /* SQLITE_NOLFS       */ 0,
+#endif
     /* SQLITE_AUTH        */ "authorization denied",
-    /* SQLITE_FORMAT      */ "auxiliary database format error",
-    /* SQLITE_RANGE       */ "bind or column index out of range",
-    /* SQLITE_NOTADB      */ "file is encrypted or is not a database",
+    /* SQLITE_FORMAT      */ 0,
+    /* SQLITE_RANGE       */ "column index out of range",
+    /* SQLITE_NOTADB      */ "file is not a database",
   };
   const char *zErr = "unknown error";
   switch( rc ){
@@ -142167,12 +143869,9 @@ SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){
     'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
   };
   static const u16 misuse[] = {
-    'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ', 
-    'r', 'o', 'u', 't', 'i', 'n', 'e', ' ', 
-    'c', 'a', 'l', 'l', 'e', 'd', ' ', 
-    'o', 'u', 't', ' ', 
-    'o', 'f', ' ', 
-    's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0
+    'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ',
+    'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ',
+    'm', 'i', 's', 'u', 's', 'e', 0
   };
 
   const void *z;
@@ -142707,26 +144406,6 @@ static int openDatabase(
   if( rc ) return rc;
 #endif
 
-  /* Only allow sensible combinations of bits in the flags argument.  
-  ** Throw an error if any non-sense combination is used.  If we
-  ** do not block illegal combinations here, it could trigger
-  ** assert() statements in deeper layers.  Sensible combinations
-  ** are:
-  **
-  **  1:  SQLITE_OPEN_READONLY
-  **  2:  SQLITE_OPEN_READWRITE
-  **  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
-  */
-  assert( SQLITE_OPEN_READONLY  == 0x01 );
-  assert( SQLITE_OPEN_READWRITE == 0x02 );
-  assert( SQLITE_OPEN_CREATE    == 0x04 );
-  testcase( (1<<(flags&7))==0x02 ); /* READONLY */
-  testcase( (1<<(flags&7))==0x04 ); /* READWRITE */
-  testcase( (1<<(flags&7))==0x40 ); /* READWRITE | CREATE */
-  if( ((1<<(flags&7)) & 0x46)==0 ){
-    return SQLITE_MISUSE_BKPT;  /* IMP: R-65497-44594 */
-  }
-
   if( sqlite3GlobalConfig.bCoreMutex==0 ){
     isThreadsafe = 0;
   }else if( flags & SQLITE_OPEN_NOMUTEX ){
@@ -142817,6 +144496,9 @@ static int openDatabase(
 #endif
 #if defined(SQLITE_ENABLE_FTS3_TOKENIZER)
                  | SQLITE_Fts3Tokenizer
+#endif
+#if defined(SQLITE_ENABLE_QPSG)
+                 | SQLITE_EnableQPSG
 #endif
       ;
   sqlite3HashInit(&db->aCollSeq);
@@ -142845,9 +144527,30 @@ static int openDatabase(
   db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, sqlite3StrBINARY, 0);
   assert( db->pDfltColl!=0 );
 
-  /* Parse the filename/URI argument. */
+  /* Parse the filename/URI argument
+  **
+  ** Only allow sensible combinations of bits in the flags argument.  
+  ** Throw an error if any non-sense combination is used.  If we
+  ** do not block illegal combinations here, it could trigger
+  ** assert() statements in deeper layers.  Sensible combinations
+  ** are:
+  **
+  **  1:  SQLITE_OPEN_READONLY
+  **  2:  SQLITE_OPEN_READWRITE
+  **  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
+  */
   db->openFlags = flags;
-  rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);
+  assert( SQLITE_OPEN_READONLY  == 0x01 );
+  assert( SQLITE_OPEN_READWRITE == 0x02 );
+  assert( SQLITE_OPEN_CREATE    == 0x04 );
+  testcase( (1<<(flags&7))==0x02 ); /* READONLY */
+  testcase( (1<<(flags&7))==0x04 ); /* READWRITE */
+  testcase( (1<<(flags&7))==0x40 ); /* READWRITE | CREATE */
+  if( ((1<<(flags&7)) & 0x46)==0 ){
+    rc = SQLITE_MISUSE_BKPT;  /* IMP: R-65497-44594 */
+  }else{
+    rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);
+  }
   if( rc!=SQLITE_OK ){
     if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);
     sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);
@@ -142956,6 +144659,12 @@ static int openDatabase(
   }
 #endif
 
+#ifdef SQLITE_ENABLE_STMTVTAB
+  if( !db->mallocFailed && rc==SQLITE_OK){
+    rc = sqlite3StmtVtabInit(db);
+  }
+#endif
+
   /* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
   ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
   ** mode.  Doing nothing at all also makes NORMAL the default.
@@ -142998,16 +144707,18 @@ static int openDatabase(
 #endif
 #if defined(SQLITE_HAS_CODEC)
   if( rc==SQLITE_OK ){
-    const char *zHexKey = sqlite3_uri_parameter(zOpen, "hexkey");
-    if( zHexKey && zHexKey[0] ){
+    const char *zKey;
+    if( (zKey = sqlite3_uri_parameter(zOpen, "hexkey"))!=0 && zKey[0] ){
       u8 iByte;
       int i;
-      char zKey[40];
-      for(i=0, iByte=0; i<sizeof(zKey)*2 && sqlite3Isxdigit(zHexKey[i]); i++){
-        iByte = (iByte<<4) + sqlite3HexToInt(zHexKey[i]);
-        if( (i&1)!=0 ) zKey[i/2] = iByte;
+      char zDecoded[40];
+      for(i=0, iByte=0; i<sizeof(zDecoded)*2 && sqlite3Isxdigit(zKey[i]); i++){
+        iByte = (iByte<<4) + sqlite3HexToInt(zKey[i]);
+        if( (i&1)!=0 ) zDecoded[i/2] = iByte;
       }
-      sqlite3_key_v2(db, 0, zKey, i/2);
+      sqlite3_key_v2(db, 0, zDecoded, i/2);
+    }else if( (zKey = sqlite3_uri_parameter(zOpen, "key"))!=0 ){
+      sqlite3_key_v2(db, 0, zKey, sqlite3Strlen30(zKey));
     }
   }
 #endif
@@ -143238,6 +144949,12 @@ SQLITE_PRIVATE int sqlite3CantopenError(int lineno){
   return reportError(SQLITE_CANTOPEN, lineno, "cannot open file");
 }
 #ifdef SQLITE_DEBUG
+SQLITE_PRIVATE int sqlite3CorruptPgnoError(int lineno, Pgno pgno){
+  char zMsg[100];
+  sqlite3_snprintf(sizeof(zMsg), zMsg, "database corruption page %d", pgno);
+  testcase( sqlite3GlobalConfig.xLog!=0 );
+  return reportError(SQLITE_CORRUPT, lineno, zMsg);
+}
 SQLITE_PRIVATE int sqlite3NomemError(int lineno){
   testcase( sqlite3GlobalConfig.xLog!=0 );
   return reportError(SQLITE_NOMEM, lineno, "OOM");
@@ -143997,6 +145714,58 @@ SQLITE_API void sqlite3_snapshot_free(sqlite3_snapshot *pSnapshot){
 }
 #endif /* SQLITE_ENABLE_SNAPSHOT */
 
+#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
+/*
+** Given the name of a compile-time option, return true if that option
+** was used and false if not.
+**
+** The name can optionally begin with "SQLITE_" but the "SQLITE_" prefix
+** is not required for a match.
+*/
+SQLITE_API int sqlite3_compileoption_used(const char *zOptName){
+  int i, n;
+  int nOpt;
+  const char **azCompileOpt;
+ 
+#if SQLITE_ENABLE_API_ARMOR
+  if( zOptName==0 ){
+    (void)SQLITE_MISUSE_BKPT;
+    return 0;
+  }
+#endif
+
+  azCompileOpt = sqlite3CompileOptions(&nOpt);
+
+  if( sqlite3StrNICmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;
+  n = sqlite3Strlen30(zOptName);
+
+  /* Since nOpt is normally in single digits, a linear search is 
+  ** adequate. No need for a binary search. */
+  for(i=0; i<nOpt; i++){
+    if( sqlite3StrNICmp(zOptName, azCompileOpt[i], n)==0
+     && sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0
+    ){
+      return 1;
+    }
+  }
+  return 0;
+}
+
+/*
+** Return the N-th compile-time option string.  If N is out of range,
+** return a NULL pointer.
+*/
+SQLITE_API const char *sqlite3_compileoption_get(int N){
+  int nOpt;
+  const char **azCompileOpt;
+  azCompileOpt = sqlite3CompileOptions(&nOpt);
+  if( N>=0 && N<nOpt ){
+    return azCompileOpt[N];
+  }
+  return 0;
+}
+#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
+
 /************** End of main.c ************************************************/
 /************** Begin file notify.c ******************************************/
 /*
@@ -145612,8 +147381,8 @@ SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *pBuf, sqlite_int64 *v){
 }
 
 /*
-** Similar to sqlite3Fts3GetVarint(), except that the output is truncated to a
-** 32-bit integer before it is returned.
+** Similar to sqlite3Fts3GetVarint(), except that the output is truncated to 
+** a non-negative 32-bit integer before it is returned.
 */
 SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *p, int *pi){
   u32 a;
@@ -145629,7 +147398,9 @@ SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *p, int *pi){
   GETVARINT_STEP(a, p, 14, 0x3FFF,   0x200000, *pi, 3);
   GETVARINT_STEP(a, p, 21, 0x1FFFFF, 0x10000000, *pi, 4);
   a = (a & 0x0FFFFFFF );
-  *pi = (int)(a | ((u32)(*p & 0x0F) << 28));
+  *pi = (int)(a | ((u32)(*p & 0x07) << 28));
+  assert( 0==(a & 0x80000000) );
+  assert( *pi>=0 );
   return 5;
 }
 
@@ -146459,65 +148230,66 @@ static int fts3InitVtab(
             break;
           }
         }
-        if( iOpt==SizeofArray(aFts4Opt) ){
-          sqlite3Fts3ErrMsg(pzErr, "unrecognized parameter: %s", z);
-          rc = SQLITE_ERROR;
-        }else{
-          switch( iOpt ){
-            case 0:               /* MATCHINFO */
-              if( strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "fts3", 4) ){
-                sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo: %s", zVal);
-                rc = SQLITE_ERROR;
-              }
-              bNoDocsize = 1;
-              break;
+        switch( iOpt ){
+          case 0:               /* MATCHINFO */
+            if( strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "fts3", 4) ){
+              sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo: %s", zVal);
+              rc = SQLITE_ERROR;
+            }
+            bNoDocsize = 1;
+            break;
 
-            case 1:               /* PREFIX */
-              sqlite3_free(zPrefix);
-              zPrefix = zVal;
-              zVal = 0;
-              break;
+          case 1:               /* PREFIX */
+            sqlite3_free(zPrefix);
+            zPrefix = zVal;
+            zVal = 0;
+            break;
 
-            case 2:               /* COMPRESS */
-              sqlite3_free(zCompress);
-              zCompress = zVal;
-              zVal = 0;
-              break;
+          case 2:               /* COMPRESS */
+            sqlite3_free(zCompress);
+            zCompress = zVal;
+            zVal = 0;
+            break;
 
-            case 3:               /* UNCOMPRESS */
-              sqlite3_free(zUncompress);
-              zUncompress = zVal;
-              zVal = 0;
-              break;
+          case 3:               /* UNCOMPRESS */
+            sqlite3_free(zUncompress);
+            zUncompress = zVal;
+            zVal = 0;
+            break;
 
-            case 4:               /* ORDER */
-              if( (strlen(zVal)!=3 || sqlite3_strnicmp(zVal, "asc", 3)) 
-               && (strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "desc", 4)) 
-              ){
-                sqlite3Fts3ErrMsg(pzErr, "unrecognized order: %s", zVal);
-                rc = SQLITE_ERROR;
-              }
-              bDescIdx = (zVal[0]=='d' || zVal[0]=='D');
-              break;
+          case 4:               /* ORDER */
+            if( (strlen(zVal)!=3 || sqlite3_strnicmp(zVal, "asc", 3)) 
+             && (strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "desc", 4)) 
+            ){
+              sqlite3Fts3ErrMsg(pzErr, "unrecognized order: %s", zVal);
+              rc = SQLITE_ERROR;
+            }
+            bDescIdx = (zVal[0]=='d' || zVal[0]=='D');
+            break;
 
-            case 5:              /* CONTENT */
-              sqlite3_free(zContent);
-              zContent = zVal;
-              zVal = 0;
-              break;
+          case 5:              /* CONTENT */
+            sqlite3_free(zContent);
+            zContent = zVal;
+            zVal = 0;
+            break;
 
-            case 6:              /* LANGUAGEID */
-              assert( iOpt==6 );
-              sqlite3_free(zLanguageid);
-              zLanguageid = zVal;
-              zVal = 0;
-              break;
+          case 6:              /* LANGUAGEID */
+            assert( iOpt==6 );
+            sqlite3_free(zLanguageid);
+            zLanguageid = zVal;
+            zVal = 0;
+            break;
 
-            case 7:              /* NOTINDEXED */
-              azNotindexed[nNotindexed++] = zVal;
-              zVal = 0;
-              break;
-          }
+          case 7:              /* NOTINDEXED */
+            azNotindexed[nNotindexed++] = zVal;
+            zVal = 0;
+            break;
+
+          default:
+            assert( iOpt==SizeofArray(aFts4Opt) );
+            sqlite3Fts3ErrMsg(pzErr, "unrecognized parameter: %s", z);
+            rc = SQLITE_ERROR;
+            break;
         }
         sqlite3_free(zVal);
       }
@@ -146944,6 +148716,19 @@ static void fts3CursorFinalizeStmt(Fts3Cursor *pCsr){
   sqlite3_finalize(pCsr->pStmt);
 }
 
+/*
+** Free all resources currently held by the cursor passed as the only
+** argument.
+*/
+static void fts3ClearCursor(Fts3Cursor *pCsr){
+  fts3CursorFinalizeStmt(pCsr);
+  sqlite3Fts3FreeDeferredTokens(pCsr);
+  sqlite3_free(pCsr->aDoclist);
+  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
+  sqlite3Fts3ExprFree(pCsr->pExpr);
+  memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
+}
+
 /*
 ** Close the cursor.  For additional information see the documentation
 ** on the xClose method of the virtual table interface.
@@ -146951,11 +148736,7 @@ static void fts3CursorFinalizeStmt(Fts3Cursor *pCsr){
 static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){
   Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
   assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
-  fts3CursorFinalizeStmt(pCsr);
-  sqlite3Fts3ExprFree(pCsr->pExpr);
-  sqlite3Fts3FreeDeferredTokens(pCsr);
-  sqlite3_free(pCsr->aDoclist);
-  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
+  fts3ClearCursor(pCsr);
   assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
   sqlite3_free(pCsr);
   return SQLITE_OK;
@@ -146981,7 +148762,7 @@ static int fts3CursorSeekStmt(Fts3Cursor *pCsr){
     }else{
       zSql = sqlite3_mprintf("SELECT %s WHERE rowid = ?", p->zReadExprlist);
       if( !zSql ) return SQLITE_NOMEM;
-      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
+      rc = sqlite3_prepare_v3(p->db, zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0);
       sqlite3_free(zSql);
     }
     if( rc==SQLITE_OK ) pCsr->bSeekStmt = 1;
@@ -147086,7 +148867,8 @@ static int fts3ScanInteriorNode(
     isFirstTerm = 0;
     zCsr += fts3GetVarint32(zCsr, &nSuffix);
     
-    if( nPrefix<0 || nSuffix<0 || &zCsr[nSuffix]>zEnd ){
+    assert( nPrefix>=0 && nSuffix>=0 );
+    if( &zCsr[nSuffix]>zEnd ){
       rc = FTS_CORRUPT_VTAB;
       goto finish_scan;
     }
@@ -147896,7 +149678,7 @@ SQLITE_PRIVATE int sqlite3Fts3FirstFilter(
     fts3ColumnlistCopy(0, &p);
   }
 
-  while( p<pEnd && *p==0x01 ){
+  while( p<pEnd ){
     sqlite3_int64 iCol;
     p++;
     p += sqlite3Fts3GetVarint(p, &iCol);
@@ -148455,11 +150237,7 @@ static int fts3FilterMethod(
   assert( iIdx==nVal );
 
   /* In case the cursor has been used before, clear it now. */
-  fts3CursorFinalizeStmt(pCsr);
-  sqlite3_free(pCsr->aDoclist);
-  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
-  sqlite3Fts3ExprFree(pCsr->pExpr);
-  memset(&pCursor[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
+  fts3ClearCursor(pCsr);
 
   /* Set the lower and upper bounds on docids to return */
   pCsr->iMinDocid = fts3DocidRange(pDocidGe, SMALLEST_INT64);
@@ -148517,7 +150295,7 @@ static int fts3FilterMethod(
       );
     }
     if( zSql ){
-      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
+      rc = sqlite3_prepare_v3(p->db,zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0);
       sqlite3_free(zSql);
     }else{
       rc = SQLITE_NOMEM;
@@ -148538,7 +150316,12 @@ static int fts3FilterMethod(
 ** routine to find out if it has reached the end of a result set.
 */
 static int fts3EofMethod(sqlite3_vtab_cursor *pCursor){
-  return ((Fts3Cursor *)pCursor)->isEof;
+  Fts3Cursor *pCsr = (Fts3Cursor*)pCursor;
+  if( pCsr->isEof ){
+    fts3ClearCursor(pCsr);
+    pCsr->isEof = 1;
+  }
+  return pCsr->isEof;
 }
 
 /* 
@@ -148576,33 +150359,37 @@ static int fts3ColumnMethod(
   /* The column value supplied by SQLite must be in range. */
   assert( iCol>=0 && iCol<=p->nColumn+2 );
 
-  if( iCol==p->nColumn+1 ){
-    /* This call is a request for the "docid" column. Since "docid" is an 
-    ** alias for "rowid", use the xRowid() method to obtain the value.
-    */
-    sqlite3_result_int64(pCtx, pCsr->iPrevId);
-  }else if( iCol==p->nColumn ){
-    /* The extra column whose name is the same as the table.
-    ** Return a blob which is a pointer to the cursor.  */
-    sqlite3_result_blob(pCtx, &pCsr, sizeof(pCsr), SQLITE_TRANSIENT);
-  }else if( iCol==p->nColumn+2 && pCsr->pExpr ){
-    sqlite3_result_int64(pCtx, pCsr->iLangid);
-  }else{
-    /* The requested column is either a user column (one that contains 
-    ** indexed data), or the language-id column.  */
-    rc = fts3CursorSeek(0, pCsr);
+  switch( iCol-p->nColumn ){
+    case 0:
+      /* The special 'table-name' column */
+      sqlite3_result_pointer(pCtx, pCsr, "fts3cursor", 0);
+      break;
 
-    if( rc==SQLITE_OK ){
-      if( iCol==p->nColumn+2 ){
-        int iLangid = 0;
-        if( p->zLanguageid ){
-          iLangid = sqlite3_column_int(pCsr->pStmt, p->nColumn+1);
-        }
-        sqlite3_result_int(pCtx, iLangid);
-      }else if( sqlite3_data_count(pCsr->pStmt)>(iCol+1) ){
+    case 1:
+      /* The docid column */
+      sqlite3_result_int64(pCtx, pCsr->iPrevId);
+      break;
+
+    case 2:
+      if( pCsr->pExpr ){
+        sqlite3_result_int64(pCtx, pCsr->iLangid);
+        break;
+      }else if( p->zLanguageid==0 ){
+        sqlite3_result_int(pCtx, 0);
+        break;
+      }else{
+        iCol = p->nColumn;
+        /* fall-through */
+      }
+
+    default:
+      /* A user column. Or, if this is a full-table scan, possibly the
+      ** language-id column. Seek the cursor. */
+      rc = fts3CursorSeek(0, pCsr);
+      if( rc==SQLITE_OK && sqlite3_data_count(pCsr->pStmt)-1>iCol ){
         sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));
       }
-    }
+      break;
   }
 
   assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
@@ -148682,17 +150469,11 @@ static int fts3SyncMethod(sqlite3_vtab *pVtab){
 static int fts3SetHasStat(Fts3Table *p){
   int rc = SQLITE_OK;
   if( p->bHasStat==2 ){
-    const char *zFmt ="SELECT 1 FROM %Q.sqlite_master WHERE tbl_name='%q_stat'";
-    char *zSql = sqlite3_mprintf(zFmt, p->zDb, p->zName);
-    if( zSql ){
-      sqlite3_stmt *pStmt = 0;
-      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
-      if( rc==SQLITE_OK ){
-        int bHasStat = (sqlite3_step(pStmt)==SQLITE_ROW);
-        rc = sqlite3_finalize(pStmt);
-        if( rc==SQLITE_OK ) p->bHasStat = (u8)bHasStat;
-      }
-      sqlite3_free(zSql);
+    char *zTbl = sqlite3_mprintf("%s_stat", p->zName);
+    if( zTbl ){
+      int res = sqlite3_table_column_metadata(p->db, p->zDb, zTbl, 0,0,0,0,0,0);
+      sqlite3_free(zTbl);
+      p->bHasStat = (res==SQLITE_OK);
     }else{
       rc = SQLITE_NOMEM;
     }
@@ -148799,18 +150580,17 @@ static int fts3FunctionArg(
   sqlite3_value *pVal,            /* argv[0] passed to function */
   Fts3Cursor **ppCsr              /* OUT: Store cursor handle here */
 ){
-  Fts3Cursor *pRet;
-  if( sqlite3_value_type(pVal)!=SQLITE_BLOB 
-   || sqlite3_value_bytes(pVal)!=sizeof(Fts3Cursor *)
-  ){
+  int rc;
+  *ppCsr = (Fts3Cursor*)sqlite3_value_pointer(pVal, "fts3cursor");
+  if( (*ppCsr)!=0 ){
+    rc = SQLITE_OK;
+  }else{
     char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
     sqlite3_result_error(pContext, zErr, -1);
     sqlite3_free(zErr);
-    return SQLITE_ERROR;
+    rc = SQLITE_ERROR;
   }
-  memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
-  *ppCsr = pRet;
-  return SQLITE_OK;
+  return rc;
 }
 
 /*
@@ -149197,7 +150977,7 @@ SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db){
 #endif
 
   /* Create the virtual table wrapper around the hash-table and overload 
-  ** the two scalar functions. If this is successful, register the
+  ** the four scalar functions. If this is successful, register the
   ** module with sqlite.
   */
   if( SQLITE_OK==rc 
@@ -149780,7 +151560,7 @@ static int fts3EvalIncrPhraseNext(
   ** one incremental token. In which case the bIncr flag is set. */
   assert( p->bIncr==1 );
 
-  if( p->nToken==1 && p->bIncr ){
+  if( p->nToken==1 ){
     rc = sqlite3Fts3MsrIncrNext(pTab, p->aToken[0].pSegcsr, 
         &pDL->iDocid, &pDL->pList, &pDL->nList
     );
@@ -150013,6 +151793,7 @@ static void fts3EvalTokenCosts(
 ** the number of overflow pages consumed by a record B bytes in size.
 */
 static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){
+  int rc = SQLITE_OK;
   if( pCsr->nRowAvg==0 ){
     /* The average document size, which is required to calculate the cost
     ** of each doclist, has not yet been determined. Read the required 
@@ -150025,7 +151806,6 @@ static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){
     ** data stored in all rows of each column of the table, from left
     ** to right.
     */
-    int rc;
     Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
     sqlite3_stmt *pStmt;
     sqlite3_int64 nDoc = 0;
@@ -150052,11 +151832,10 @@ static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){
     pCsr->nRowAvg = (int)(((nByte / nDoc) + p->nPgsz) / p->nPgsz);
     assert( pCsr->nRowAvg>0 ); 
     rc = sqlite3_reset(pStmt);
-    if( rc!=SQLITE_OK ) return rc;
   }
 
   *pnPage = pCsr->nRowAvg;
-  return SQLITE_OK;
+  return rc;
 }
 
 /*
@@ -150406,7 +152185,8 @@ static void fts3EvalNextRow(
           pExpr->iDocid = pLeft->iDocid;
           pExpr->bEof = (pLeft->bEof || pRight->bEof);
           if( pExpr->eType==FTSQUERY_NEAR && pExpr->bEof ){
-            if( pRight->pPhrase && pRight->pPhrase->doclist.aAll ){
+            assert( pRight->eType==FTSQUERY_PHRASE );
+            if( pRight->pPhrase->doclist.aAll ){
               Fts3Doclist *pDl = &pRight->pPhrase->doclist;
               while( *pRc==SQLITE_OK && pRight->bEof==0 ){
                 memset(pDl->pList, 0, pDl->nList);
@@ -150435,7 +152215,7 @@ static void fts3EvalNextRow(
 
         if( pRight->bEof || (pLeft->bEof==0 && iCmp<0) ){
           fts3EvalNextRow(pCsr, pLeft, pRc);
-        }else if( pLeft->bEof || (pRight->bEof==0 && iCmp>0) ){
+        }else if( pLeft->bEof || iCmp>0 ){
           fts3EvalNextRow(pCsr, pRight, pRc);
         }else{
           fts3EvalNextRow(pCsr, pLeft, pRc);
@@ -150527,7 +152307,6 @@ static int fts3EvalNearTest(Fts3Expr *pExpr, int *pRc){
   */
   if( *pRc==SQLITE_OK 
    && pExpr->eType==FTSQUERY_NEAR 
-   && pExpr->bEof==0
    && (pExpr->pParent==0 || pExpr->pParent->eType!=FTSQUERY_NEAR)
   ){
     Fts3Expr *p; 
@@ -150536,42 +152315,39 @@ static int fts3EvalNearTest(Fts3Expr *pExpr, int *pRc){
 
     /* Allocate temporary working space. */
     for(p=pExpr; p->pLeft; p=p->pLeft){
+      assert( p->pRight->pPhrase->doclist.nList>0 );
       nTmp += p->pRight->pPhrase->doclist.nList;
     }
     nTmp += p->pPhrase->doclist.nList;
-    if( nTmp==0 ){
+    aTmp = sqlite3_malloc(nTmp*2);
+    if( !aTmp ){
+      *pRc = SQLITE_NOMEM;
       res = 0;
     }else{
-      aTmp = sqlite3_malloc(nTmp*2);
-      if( !aTmp ){
-        *pRc = SQLITE_NOMEM;
-        res = 0;
-      }else{
-        char *aPoslist = p->pPhrase->doclist.pList;
-        int nToken = p->pPhrase->nToken;
-
-        for(p=p->pParent;res && p && p->eType==FTSQUERY_NEAR; p=p->pParent){
-          Fts3Phrase *pPhrase = p->pRight->pPhrase;
-          int nNear = p->nNear;
-          res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
-        }
-
-        aPoslist = pExpr->pRight->pPhrase->doclist.pList;
-        nToken = pExpr->pRight->pPhrase->nToken;
-        for(p=pExpr->pLeft; p && res; p=p->pLeft){
-          int nNear;
-          Fts3Phrase *pPhrase;
-          assert( p->pParent && p->pParent->pLeft==p );
-          nNear = p->pParent->nNear;
-          pPhrase = (
-              p->eType==FTSQUERY_NEAR ? p->pRight->pPhrase : p->pPhrase
-              );
-          res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
-        }
+      char *aPoslist = p->pPhrase->doclist.pList;
+      int nToken = p->pPhrase->nToken;
+
+      for(p=p->pParent;res && p && p->eType==FTSQUERY_NEAR; p=p->pParent){
+        Fts3Phrase *pPhrase = p->pRight->pPhrase;
+        int nNear = p->nNear;
+        res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
       }
 
-      sqlite3_free(aTmp);
+      aPoslist = pExpr->pRight->pPhrase->doclist.pList;
+      nToken = pExpr->pRight->pPhrase->nToken;
+      for(p=pExpr->pLeft; p && res; p=p->pLeft){
+        int nNear;
+        Fts3Phrase *pPhrase;
+        assert( p->pParent && p->pParent->pLeft==p );
+        nNear = p->pParent->nNear;
+        pPhrase = (
+            p->eType==FTSQUERY_NEAR ? p->pRight->pPhrase : p->pPhrase
+        );
+        res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
+      }
     }
+
+    sqlite3_free(aTmp);
   }
 
   return res;
@@ -155731,7 +157507,8 @@ static int fts3SqlStmt(
     if( !zSql ){
       rc = SQLITE_NOMEM;
     }else{
-      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, NULL);
+      rc = sqlite3_prepare_v3(p->db, zSql, -1, SQLITE_PREPARE_PERSISTENT,
+                              &pStmt, NULL);
       sqlite3_free(zSql);
       assert( rc==SQLITE_OK || pStmt==0 );
       p->aStmt[eStmt] = pStmt;
@@ -163819,14 +165596,6 @@ struct RtreeGeomCallback {
   void *pContext;
 };
 
-
-/*
-** Value for the first field of every RtreeMatchArg object. The MATCH
-** operator tests that the first field of a blob operand matches this
-** value to avoid operating on invalid blobs (which could cause a segfault).
-*/
-#define RTREE_GEOMETRY_MAGIC 0x891245AB
-
 /*
 ** An instance of this structure (in the form of a BLOB) is returned by
 ** the SQL functions that sqlite3_rtree_geometry_callback() and
@@ -163834,7 +165603,7 @@ struct RtreeGeomCallback {
 ** operand to the MATCH operator of an R-Tree.
 */
 struct RtreeMatchArg {
-  u32 magic;                  /* Always RTREE_GEOMETRY_MAGIC */
+  u32 iSize;                  /* Size of this object */
   RtreeGeomCallback cb;       /* Info about the callback functions */
   int nParam;                 /* Number of parameters to the SQL function */
   sqlite3_value **apSqlParam; /* Original SQL parameter values */
@@ -165129,33 +166898,17 @@ static int findLeafNode(
 ** operator.
 */
 static int deserializeGeometry(sqlite3_value *pValue, RtreeConstraint *pCons){
-  RtreeMatchArg *pBlob;              /* BLOB returned by geometry function */
+  RtreeMatchArg *pBlob, *pSrc;       /* BLOB returned by geometry function */
   sqlite3_rtree_query_info *pInfo;   /* Callback information */
-  int nBlob;                         /* Size of the geometry function blob */
-  int nExpected;                     /* Expected size of the BLOB */
 
-  /* Check that value is actually a blob. */
-  if( sqlite3_value_type(pValue)!=SQLITE_BLOB ) return SQLITE_ERROR;
-
-  /* Check that the blob is roughly the right size. */
-  nBlob = sqlite3_value_bytes(pValue);
-  if( nBlob<(int)sizeof(RtreeMatchArg) ){
-    return SQLITE_ERROR;
-  }
-
-  pInfo = (sqlite3_rtree_query_info*)sqlite3_malloc( sizeof(*pInfo)+nBlob );
+  pSrc = sqlite3_value_pointer(pValue, "RtreeMatchArg");
+  if( pSrc==0 ) return SQLITE_ERROR;
+  pInfo = (sqlite3_rtree_query_info*)
+                sqlite3_malloc64( sizeof(*pInfo)+pSrc->iSize );
   if( !pInfo ) return SQLITE_NOMEM;
   memset(pInfo, 0, sizeof(*pInfo));
   pBlob = (RtreeMatchArg*)&pInfo[1];
-
-  memcpy(pBlob, sqlite3_value_blob(pValue), nBlob);
-  nExpected = (int)(sizeof(RtreeMatchArg) +
-                    pBlob->nParam*sizeof(sqlite3_value*) +
-                    (pBlob->nParam-1)*sizeof(RtreeDValue));
-  if( pBlob->magic!=RTREE_GEOMETRY_MAGIC || nBlob!=nExpected ){
-    sqlite3_free(pInfo);
-    return SQLITE_ERROR;
-  }
+  memcpy(pBlob, pSrc, pSrc->iSize);
   pInfo->pContext = pBlob->cb.pContext;
   pInfo->nParam = pBlob->nParam;
   pInfo->aParam = pBlob->aParam;
@@ -166678,12 +168431,36 @@ static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){
     , pRtree->zDb, pRtree->zName, zNewName
   );
   if( zSql ){
+    nodeBlobReset(pRtree);
     rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0);
     sqlite3_free(zSql);
   }
   return rc;
 }
 
+/*
+** The xSavepoint method.
+**
+** This module does not need to do anything to support savepoints. However,
+** it uses this hook to close any open blob handle. This is done because a 
+** DROP TABLE command - which fortunately always opens a savepoint - cannot 
+** succeed if there are any open blob handles. i.e. if the blob handle were
+** not closed here, the following would fail:
+**
+**   BEGIN;
+**     INSERT INTO rtree...
+**     DROP TABLE <tablename>;    -- Would fail with SQLITE_LOCKED
+**   COMMIT;
+*/
+static int rtreeSavepoint(sqlite3_vtab *pVtab, int iSavepoint){
+  Rtree *pRtree = (Rtree *)pVtab;
+  int iwt = pRtree->inWrTrans;
+  UNUSED_PARAMETER(iSavepoint);
+  pRtree->inWrTrans = 0;
+  nodeBlobReset(pRtree);
+  pRtree->inWrTrans = iwt;
+  return SQLITE_OK;
+}
 
 /*
 ** This function populates the pRtree->nRowEst variable with an estimate
@@ -166730,7 +168507,7 @@ static int rtreeQueryStat1(sqlite3 *db, Rtree *pRtree){
 }
 
 static sqlite3_module rtreeModule = {
-  0,                          /* iVersion */
+  2,                          /* iVersion */
   rtreeCreate,                /* xCreate - create a table */
   rtreeConnect,               /* xConnect - connect to an existing table */
   rtreeBestIndex,             /* xBestIndex - Determine search strategy */
@@ -166750,7 +168527,7 @@ static sqlite3_module rtreeModule = {
   rtreeEndTransaction,        /* xRollback - rollback transaction */
   0,                          /* xFindFunction - function overloading */
   rtreeRename,                /* xRename - rename the table */
-  0,                          /* xSavepoint */
+  rtreeSavepoint,             /* xSavepoint */
   0,                          /* xRelease */
   0,                          /* xRollbackTo */
 };
@@ -166817,7 +168594,8 @@ static int rtreeSqlInit(
   for(i=0; i<N_STATEMENT && rc==SQLITE_OK; i++){
     char *zSql = sqlite3_mprintf(azSql[i], zDb, zPrefix);
     if( zSql ){
-      rc = sqlite3_prepare_v2(db, zSql, -1, appStmt[i], 0); 
+      rc = sqlite3_prepare_v3(db, zSql, -1, SQLITE_PREPARE_PERSISTENT,
+                              appStmt[i], 0); 
     }else{
       rc = SQLITE_NOMEM;
     }
@@ -166892,6 +168670,10 @@ static int getNodeSize(
     rc = getIntFromStmt(db, zSql, &pRtree->iNodeSize);
     if( rc!=SQLITE_OK ){
       *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
+    }else if( pRtree->iNodeSize<(512-64) ){
+      rc = SQLITE_CORRUPT;
+      *pzErr = sqlite3_mprintf("undersize RTree blobs in \"%q_node\"",
+                               pRtree->zName);
     }
   }
 
@@ -167164,7 +168946,7 @@ static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){
     sqlite3_result_error_nomem(ctx);
   }else{
     int i;
-    pBlob->magic = RTREE_GEOMETRY_MAGIC;
+    pBlob->iSize = nBlob;
     pBlob->cb = pGeomCtx[0];
     pBlob->apSqlParam = (sqlite3_value**)&pBlob->aParam[nArg];
     pBlob->nParam = nArg;
@@ -167181,7 +168963,7 @@ static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){
       sqlite3_result_error_nomem(ctx);
       rtreeMatchArgFree(pBlob);
     }else{
-      sqlite3_result_blob(ctx, pBlob, nBlob, rtreeMatchArgFree);
+      sqlite3_result_pointer(ctx, pBlob, "RtreeMatchArg", rtreeMatchArgFree);
     }
   }
 }
@@ -168579,10 +170361,10 @@ SQLITE_API int sqlite3rbu_savestate(sqlite3rbu *pRbu);
 **
 ** If an error has already occurred as part of an sqlite3rbu_step()
 ** or sqlite3rbu_open() call, or if one occurs within this function, an
-** SQLite error code is returned. Additionally, *pzErrmsg may be set to
-** point to a buffer containing a utf-8 formatted English language error
-** message. It is the responsibility of the caller to eventually free any 
-** such buffer using sqlite3_free().
+** SQLite error code is returned. Additionally, if pzErrmsg is not NULL,
+** *pzErrmsg may be set to point to a buffer containing a utf-8 formatted
+** English language error message. It is the responsibility of the caller to
+** eventually free any such buffer using sqlite3_free().
 **
 ** Otherwise, if no error occurs, this function returns SQLITE_OK if the
 ** update has been partially applied, or SQLITE_DONE if it has been 
@@ -172438,7 +174220,11 @@ SQLITE_API int sqlite3rbu_close(sqlite3rbu *p, char **pzErrmsg){
 
     rbuEditErrmsg(p);
     rc = p->rc;
-    *pzErrmsg = p->zErrmsg;
+    if( pzErrmsg ){
+      *pzErrmsg = p->zErrmsg;
+    }else{
+      sqlite3_free(p->zErrmsg);
+    }
     sqlite3_free(p->zState);
     sqlite3_free(p);
   }else{
@@ -174149,6 +175935,9 @@ SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db){
     0,                            /* xRollback */
     0,                            /* xFindMethod */
     0,                            /* xRename */
+    0,                            /* xSavepoint */
+    0,                            /* xRelease */
+    0,                            /* xRollbackTo */
   };
   return sqlite3_create_module(db, "dbstat", &dbstat_module, 0);
 }
@@ -176996,11 +178785,12 @@ static int sessionChangesetNext(
   p->in.iCurrent = p->in.iNext;
 
   op = p->in.aData[p->in.iNext++];
-  if( op=='T' || op=='P' ){
+  while( op=='T' || op=='P' ){
     p->bPatchset = (op=='P');
     if( sessionChangesetReadTblhdr(p) ) return p->rc;
     if( (p->rc = sessionInputBuffer(&p->in, 2)) ) return p->rc;
     p->in.iCurrent = p->in.iNext;
+    if( p->in.iNext>=p->in.nData ) return SQLITE_DONE;
     op = p->in.aData[p->in.iNext++];
   }
 
@@ -178907,6 +180697,7 @@ static const char jsonIsSpace[] = {
   ** but the definitions need to be repeated for separate compilation. */
   typedef sqlite3_uint64 u64;
   typedef unsigned int u32;
+  typedef unsigned short int u16;
   typedef unsigned char u8;
 #endif
 
@@ -178986,8 +180777,19 @@ struct JsonParse {
   u32 *aUp;          /* Index of parent of each node */
   u8 oom;            /* Set to true if out of memory */
   u8 nErr;           /* Number of errors seen */
+  u16 iDepth;        /* Nesting depth */
+  int nJson;         /* Length of the zJson string in bytes */
 };
 
+/*
+** Maximum nesting depth of JSON for this implementation.
+**
+** This limit is needed to avoid a stack overflow in the recursive
+** descent parser.  A depth of 2000 is far deeper than any sane JSON
+** should go.
+*/
+#define JSON_MAX_DEPTH  2000
+
 /**************************************************************************
 ** Utility routines for dealing with JsonString objects
 **************************************************************************/
@@ -179219,6 +181021,14 @@ static void jsonParseReset(JsonParse *pParse){
   pParse->aUp = 0;
 }
 
+/*
+** Free a JsonParse object that was obtained from sqlite3_malloc().
+*/
+static void jsonParseFree(JsonParse *pParse){
+  jsonParseReset(pParse);
+  sqlite3_free(pParse);
+}
+
 /*
 ** Convert the JsonNode pNode into a pure JSON string and
 ** append to pOut.  Subsubstructure is also included.  Return
@@ -179544,15 +181354,18 @@ static int jsonParseValue(JsonParse *pParse, u32 i){
   int iThis;
   int x;
   JsonNode *pNode;
-  while( safe_isspace(pParse->zJson[i]) ){ i++; }
-  if( (c = pParse->zJson[i])=='{' ){
+  const char *z = pParse->zJson;
+  while( safe_isspace(z[i]) ){ i++; }
+  if( (c = z[i])=='{' ){
     /* Parse object */
     iThis = jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);
     if( iThis<0 ) return -1;
     for(j=i+1;;j++){
-      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      while( safe_isspace(z[j]) ){ j++; }
+      if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;
       x = jsonParseValue(pParse, j);
       if( x<0 ){
+        pParse->iDepth--;
         if( x==(-2) && pParse->nNode==(u32)iThis+1 ) return j+1;
         return -1;
       }
@@ -179561,14 +181374,15 @@ static int jsonParseValue(JsonParse *pParse, u32 i){
       if( pNode->eType!=JSON_STRING ) return -1;
       pNode->jnFlags |= JNODE_LABEL;
       j = x;
-      while( safe_isspace(pParse->zJson[j]) ){ j++; }
-      if( pParse->zJson[j]!=':' ) return -1;
+      while( safe_isspace(z[j]) ){ j++; }
+      if( z[j]!=':' ) return -1;
       j++;
       x = jsonParseValue(pParse, j);
+      pParse->iDepth--;
       if( x<0 ) return -1;
       j = x;
-      while( safe_isspace(pParse->zJson[j]) ){ j++; }
-      c = pParse->zJson[j];
+      while( safe_isspace(z[j]) ){ j++; }
+      c = z[j];
       if( c==',' ) continue;
       if( c!='}' ) return -1;
       break;
@@ -179580,15 +181394,17 @@ static int jsonParseValue(JsonParse *pParse, u32 i){
     iThis = jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);
     if( iThis<0 ) return -1;
     for(j=i+1;;j++){
-      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      while( safe_isspace(z[j]) ){ j++; }
+      if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;
       x = jsonParseValue(pParse, j);
+      pParse->iDepth--;
       if( x<0 ){
         if( x==(-3) && pParse->nNode==(u32)iThis+1 ) return j+1;
         return -1;
       }
       j = x;
-      while( safe_isspace(pParse->zJson[j]) ){ j++; }
-      c = pParse->zJson[j];
+      while( safe_isspace(z[j]) ){ j++; }
+      c = z[j];
       if( c==',' ) continue;
       if( c!=']' ) return -1;
       break;
@@ -179600,13 +181416,16 @@ static int jsonParseValue(JsonParse *pParse, u32 i){
     u8 jnFlags = 0;
     j = i+1;
     for(;;){
-      c = pParse->zJson[j];
-      if( c==0 ) return -1;
+      c = z[j];
+      if( (c & ~0x1f)==0 ){
+        /* Control characters are not allowed in strings */
+        return -1;
+      }
       if( c=='\\' ){
-        c = pParse->zJson[++j];
+        c = z[++j];
         if( c=='"' || c=='\\' || c=='/' || c=='b' || c=='f'
            || c=='n' || c=='r' || c=='t'
-           || (c=='u' && jsonIs4Hex(pParse->zJson+j+1)) ){
+           || (c=='u' && jsonIs4Hex(z+j+1)) ){
           jnFlags = JNODE_ESCAPE;
         }else{
           return -1;
@@ -179616,55 +181435,60 @@ static int jsonParseValue(JsonParse *pParse, u32 i){
       }
       j++;
     }
-    jsonParseAddNode(pParse, JSON_STRING, j+1-i, &pParse->zJson[i]);
+    jsonParseAddNode(pParse, JSON_STRING, j+1-i, &z[i]);
     if( !pParse->oom ) pParse->aNode[pParse->nNode-1].jnFlags = jnFlags;
     return j+1;
   }else if( c=='n'
-         && strncmp(pParse->zJson+i,"null",4)==0
-         && !safe_isalnum(pParse->zJson[i+4]) ){
+         && strncmp(z+i,"null",4)==0
+         && !safe_isalnum(z[i+4]) ){
     jsonParseAddNode(pParse, JSON_NULL, 0, 0);
     return i+4;
   }else if( c=='t'
-         && strncmp(pParse->zJson+i,"true",4)==0
-         && !safe_isalnum(pParse->zJson[i+4]) ){
+         && strncmp(z+i,"true",4)==0
+         && !safe_isalnum(z[i+4]) ){
     jsonParseAddNode(pParse, JSON_TRUE, 0, 0);
     return i+4;
   }else if( c=='f'
-         && strncmp(pParse->zJson+i,"false",5)==0
-         && !safe_isalnum(pParse->zJson[i+5]) ){
+         && strncmp(z+i,"false",5)==0
+         && !safe_isalnum(z[i+5]) ){
     jsonParseAddNode(pParse, JSON_FALSE, 0, 0);
     return i+5;
   }else if( c=='-' || (c>='0' && c<='9') ){
     /* Parse number */
     u8 seenDP = 0;
     u8 seenE = 0;
+    assert( '-' < '0' );
+    if( c<='0' ){
+      j = c=='-' ? i+1 : i;
+      if( z[j]=='0' && z[j+1]>='0' && z[j+1]<='9' ) return -1;
+    }
     j = i+1;
     for(;; j++){
-      c = pParse->zJson[j];
+      c = z[j];
       if( c>='0' && c<='9' ) continue;
       if( c=='.' ){
-        if( pParse->zJson[j-1]=='-' ) return -1;
+        if( z[j-1]=='-' ) return -1;
         if( seenDP ) return -1;
         seenDP = 1;
         continue;
       }
       if( c=='e' || c=='E' ){
-        if( pParse->zJson[j-1]<'0' ) return -1;
+        if( z[j-1]<'0' ) return -1;
         if( seenE ) return -1;
         seenDP = seenE = 1;
-        c = pParse->zJson[j+1];
+        c = z[j+1];
         if( c=='+' || c=='-' ){
           j++;
-          c = pParse->zJson[j+1];
+          c = z[j+1];
         }
         if( c<'0' || c>'9' ) return -1;
         continue;
       }
       break;
     }
-    if( pParse->zJson[j-1]<'0' ) return -1;
+    if( z[j-1]<'0' ) return -1;
     jsonParseAddNode(pParse, seenDP ? JSON_REAL : JSON_INT,
-                        j - i, &pParse->zJson[i]);
+                        j - i, &z[i]);
     return j;
   }else if( c=='}' ){
     return -2;  /* End of {...} */
@@ -179696,6 +181520,7 @@ static int jsonParse(
   i = jsonParseValue(pParse, 0);
   if( pParse->oom ) i = -1;
   if( i>0 ){
+    assert( pParse->iDepth==0 );
     while( safe_isspace(zJson[i]) ) i++;
     if( zJson[i] ) i = -1;
   }
@@ -179755,6 +181580,49 @@ static int jsonParseFindParents(JsonParse *pParse){
   return SQLITE_OK;
 }
 
+/*
+** Magic number used for the JSON parse cache in sqlite3_get_auxdata()
+*/
+#define JSON_CACHE_ID  (-429938)
+
+/*
+** Obtain a complete parse of the JSON found in the first argument
+** of the argv array.  Use the sqlite3_get_auxdata() cache for this
+** parse if it is available.  If the cache is not available or if it
+** is no longer valid, parse the JSON again and return the new parse,
+** and also register the new parse so that it will be available for
+** future sqlite3_get_auxdata() calls.
+*/
+static JsonParse *jsonParseCached(
+  sqlite3_context *pCtx,
+  sqlite3_value **argv
+){
+  const char *zJson = (const char*)sqlite3_value_text(argv[0]);
+  int nJson = sqlite3_value_bytes(argv[0]);
+  JsonParse *p;
+  if( zJson==0 ) return 0;
+  p = (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID);
+  if( p && p->nJson==nJson && memcmp(p->zJson,zJson,nJson)==0 ){
+    p->nErr = 0;
+    return p; /* The cached entry matches, so return it */
+  }
+  p = sqlite3_malloc( sizeof(*p) + nJson + 1 );
+  if( p==0 ){
+    sqlite3_result_error_nomem(pCtx);
+    return 0;
+  }
+  memset(p, 0, sizeof(*p));
+  p->zJson = (char*)&p[1];
+  memcpy((char*)p->zJson, zJson, nJson+1);
+  if( jsonParse(p, pCtx, p->zJson) ){
+    sqlite3_free(p);
+    return 0;
+  }
+  p->nJson = nJson;
+  sqlite3_set_auxdata(pCtx, JSON_CACHE_ID, p, (void(*)(void*))jsonParseFree);
+  return (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID);
+}
+
 /*
 ** Compare the OBJECT label at pNode against zKey,nKey.  Return true on
 ** a match.
@@ -180120,29 +181988,30 @@ static void jsonArrayLengthFunc(
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse x;          /* The parse */
+  JsonParse *p;          /* The parse */
   sqlite3_int64 n = 0;
   u32 i;
   JsonNode *pNode;
 
-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
-  assert( x.nNode );
+  p = jsonParseCached(ctx, argv);
+  if( p==0 ) return;
+  assert( p->nNode );
   if( argc==2 ){
     const char *zPath = (const char*)sqlite3_value_text(argv[1]);
-    pNode = jsonLookup(&x, zPath, 0, ctx);
+    pNode = jsonLookup(p, zPath, 0, ctx);
   }else{
-    pNode = x.aNode;
+    pNode = p->aNode;
   }
   if( pNode==0 ){
-    x.nErr = 1;
-  }else if( pNode->eType==JSON_ARRAY ){
+    return;
+  }
+  if( pNode->eType==JSON_ARRAY ){
     assert( (pNode->jnFlags & JNODE_APPEND)==0 );
     for(i=1; i<=pNode->n; n++){
       i += jsonNodeSize(&pNode[i]);
     }
   }
-  if( x.nErr==0 ) sqlite3_result_int64(ctx, n);
-  jsonParseReset(&x);
+  sqlite3_result_int64(ctx, n);
 }
 
 /*
@@ -180158,20 +182027,21 @@ static void jsonExtractFunc(
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse x;          /* The parse */
+  JsonParse *p;          /* The parse */
   JsonNode *pNode;
   const char *zPath;
   JsonString jx;
   int i;
 
   if( argc<2 ) return;
-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  p = jsonParseCached(ctx, argv);
+  if( p==0 ) return;
   jsonInit(&jx, ctx);
   jsonAppendChar(&jx, '[');
   for(i=1; i<argc; i++){
     zPath = (const char*)sqlite3_value_text(argv[i]);
-    pNode = jsonLookup(&x, zPath, 0, ctx);
-    if( x.nErr ) break;
+    pNode = jsonLookup(p, zPath, 0, ctx);
+    if( p->nErr ) break;
     if( argc>2 ){
       jsonAppendSeparator(&jx);
       if( pNode ){
@@ -180189,14 +182059,13 @@ static void jsonExtractFunc(
     sqlite3_result_subtype(ctx, JSON_SUBTYPE);
   }
   jsonReset(&jx);
-  jsonParseReset(&x);
 }
 
 /* This is the RFC 7396 MergePatch algorithm.
 */
 static JsonNode *jsonMergePatch(
   JsonParse *pParse,   /* The JSON parser that contains the TARGET */
-  int iTarget,         /* Node of the TARGET in pParse */
+  u32 iTarget,         /* Node of the TARGET in pParse */
   JsonNode *pPatch     /* The PATCH */
 ){
   u32 i, j;
@@ -182205,9 +184074,9 @@ static int sqlite3Fts5IndexBeginWrite(
 
 /*
 ** Flush any data stored in the in-memory hash tables to the database.
-** If the bCommit flag is true, also close any open blob handles.
+** Also close any open blob handles.
 */
-static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit);
+static int sqlite3Fts5IndexSync(Fts5Index *p);
 
 /*
 ** Discard any data stored in the in-memory hash tables. Do not write it
@@ -182377,7 +184246,7 @@ static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol);
 static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnAvg);
 static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow);
 
-static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit);
+static int sqlite3Fts5StorageSync(Fts5Storage *p);
 static int sqlite3Fts5StorageRollback(Fts5Storage *p);
 
 static int sqlite3Fts5StorageConfigValue(
@@ -182413,6 +184282,7 @@ struct Fts5Token {
 /* Parse a MATCH expression. */
 static int sqlite3Fts5ExprNew(
   Fts5Config *pConfig, 
+  int iCol,                       /* Column on LHS of MATCH operator */
   const char *zExpr,
   Fts5Expr **ppNew, 
   char **pzErr
@@ -182497,7 +184367,7 @@ static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset*);
 static void sqlite3Fts5ParseNodeFree(Fts5ExprNode*);
 
 static void sqlite3Fts5ParseSetDistance(Fts5Parse*, Fts5ExprNearset*, Fts5Token*);
-static void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNearset*, Fts5Colset*);
+static void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNode*, Fts5Colset*);
 static Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse*, Fts5Colset*);
 static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p);
 static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token*);
@@ -182554,12 +184424,12 @@ static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic);
 #define FTS5_NOT                              3
 #define FTS5_TERM                             4
 #define FTS5_COLON                            5
-#define FTS5_LP                               6
-#define FTS5_RP                               7
-#define FTS5_MINUS                            8
-#define FTS5_LCP                              9
-#define FTS5_RCP                             10
-#define FTS5_STRING                          11
+#define FTS5_MINUS                            6
+#define FTS5_LCP                              7
+#define FTS5_RCP                              8
+#define FTS5_STRING                           9
+#define FTS5_LP                              10
+#define FTS5_RP                              11
 #define FTS5_COMMA                           12
 #define FTS5_PLUS                            13
 #define FTS5_STAR                            14
@@ -182695,16 +184565,16 @@ typedef union {
 #define sqlite3Fts5ParserARG_PDECL ,Fts5Parse *pParse
 #define sqlite3Fts5ParserARG_FETCH Fts5Parse *pParse = fts5yypParser->pParse
 #define sqlite3Fts5ParserARG_STORE fts5yypParser->pParse = pParse
-#define fts5YYNSTATE             29
-#define fts5YYNRULE              26
-#define fts5YY_MAX_SHIFT         28
-#define fts5YY_MIN_SHIFTREDUCE   45
-#define fts5YY_MAX_SHIFTREDUCE   70
-#define fts5YY_MIN_REDUCE        71
-#define fts5YY_MAX_REDUCE        96
-#define fts5YY_ERROR_ACTION      97
-#define fts5YY_ACCEPT_ACTION     98
-#define fts5YY_NO_ACTION         99
+#define fts5YYNSTATE             33
+#define fts5YYNRULE              27
+#define fts5YY_MAX_SHIFT         32
+#define fts5YY_MIN_SHIFTREDUCE   50
+#define fts5YY_MAX_SHIFTREDUCE   76
+#define fts5YY_MIN_REDUCE        77
+#define fts5YY_MAX_REDUCE        103
+#define fts5YY_ERROR_ACTION      104
+#define fts5YY_ACCEPT_ACTION     105
+#define fts5YY_NO_ACTION         106
 /************* End control #defines *******************************************/
 
 /* Define the fts5yytestcase() macro to be a no-op if is not already defined
@@ -182776,50 +184646,54 @@ typedef union {
 **  fts5yy_default[]       Default action for each state.
 **
 *********** Begin parsing tables **********************************************/
-#define fts5YY_ACTTAB_COUNT (85)
+#define fts5YY_ACTTAB_COUNT (98)
 static const fts5YYACTIONTYPE fts5yy_action[] = {
- /*     0 */    98,   16,   51,    5,   53,   27,   83,    7,   26,   15,
- /*    10 */    51,    5,   53,   27,   13,   69,   26,   48,   51,    5,
- /*    20 */    53,   27,   19,   11,   26,    9,   20,   51,    5,   53,
- /*    30 */    27,   13,   22,   26,   28,   51,    5,   53,   27,   68,
- /*    40 */     1,   26,   19,   11,   17,    9,   52,   10,   53,   27,
- /*    50 */    23,   24,   26,   54,    3,    4,    2,   26,    6,   21,
- /*    60 */    49,   71,    3,    4,    2,    7,   56,   59,   55,   59,
- /*    70 */     4,    2,   12,   69,   58,   60,   18,   67,   62,   69,
- /*    80 */    25,   66,    8,   14,    2,
+ /*     0 */   105,   19,   90,    6,   26,   93,   92,   24,   24,   17,
+ /*    10 */    90,    6,   26,   16,   92,   54,   24,   18,   90,    6,
+ /*    20 */    26,   10,   92,   12,   24,   75,   86,   90,    6,   26,
+ /*    30 */    13,   92,   75,   24,   20,   90,    6,   26,  101,   92,
+ /*    40 */    56,   24,   27,   90,    6,   26,  100,   92,   21,   24,
+ /*    50 */    23,   15,   30,   11,    1,   91,   22,   25,    9,   92,
+ /*    60 */     7,   24,    3,    4,    5,    3,    4,    5,    3,   77,
+ /*    70 */     4,    5,    3,   61,   23,   15,   60,   11,   80,   12,
+ /*    80 */     2,   13,   68,   10,   29,   52,   55,   75,   31,   32,
+ /*    90 */     8,   28,    5,    3,   51,   55,   72,   14,
 };
 static const fts5YYCODETYPE fts5yy_lookahead[] = {
- /*     0 */    16,   17,   18,   19,   20,   21,    5,    6,   24,   17,
- /*    10 */    18,   19,   20,   21,   11,   14,   24,   17,   18,   19,
- /*    20 */    20,   21,    8,    9,   24,   11,   17,   18,   19,   20,
- /*    30 */    21,   11,   12,   24,   17,   18,   19,   20,   21,   26,
- /*    40 */     6,   24,    8,    9,   22,   11,   18,   11,   20,   21,
- /*    50 */    24,   25,   24,   20,    1,    2,    3,   24,   23,   24,
- /*    60 */     7,    0,    1,    2,    3,    6,   10,   11,   10,   11,
- /*    70 */     2,    3,    9,   14,   11,   11,   22,   26,    7,   14,
- /*    80 */    13,   11,    5,   11,    3,
+ /*     0 */    16,   17,   18,   19,   20,   22,   22,   24,   24,   17,
+ /*    10 */    18,   19,   20,    7,   22,    9,   24,   17,   18,   19,
+ /*    20 */    20,   10,   22,    9,   24,   14,   17,   18,   19,   20,
+ /*    30 */     9,   22,   14,   24,   17,   18,   19,   20,   26,   22,
+ /*    40 */     9,   24,   17,   18,   19,   20,   26,   22,   21,   24,
+ /*    50 */     6,    7,   13,    9,   10,   18,   21,   20,    5,   22,
+ /*    60 */     5,   24,    3,    1,    2,    3,    1,    2,    3,    0,
+ /*    70 */     1,    2,    3,   11,    6,    7,   11,    9,    5,    9,
+ /*    80 */    10,    9,   11,   10,   12,    8,    9,   14,   24,   25,
+ /*    90 */    23,   24,    2,    3,    8,    9,    9,    9,
 };
-#define fts5YY_SHIFT_USE_DFLT (85)
-#define fts5YY_SHIFT_COUNT    (28)
+#define fts5YY_SHIFT_USE_DFLT (98)
+#define fts5YY_SHIFT_COUNT    (32)
 #define fts5YY_SHIFT_MIN      (0)
-#define fts5YY_SHIFT_MAX      (81)
+#define fts5YY_SHIFT_MAX      (90)
 static const unsigned char fts5yy_shift_ofst[] = {
- /*     0 */    34,   34,   34,   34,   34,   14,   20,    3,   36,    1,
- /*    10 */    59,   64,   64,   65,   65,   53,   61,   56,   58,   63,
- /*    20 */    68,   67,   70,   67,   71,   72,   67,   77,   81,
+ /*     0 */    44,   44,   44,   44,   44,   44,   68,   70,   72,   14,
+ /*    10 */    21,   73,   11,   18,   18,   31,   31,   62,   65,   69,
+ /*    20 */    90,   77,   86,    6,   39,   53,   55,   59,   39,   87,
+ /*    30 */    88,   39,   71,
 };
-#define fts5YY_REDUCE_USE_DFLT (-17)
-#define fts5YY_REDUCE_COUNT (14)
-#define fts5YY_REDUCE_MIN   (-16)
-#define fts5YY_REDUCE_MAX   (54)
+#define fts5YY_REDUCE_USE_DFLT (-18)
+#define fts5YY_REDUCE_COUNT (16)
+#define fts5YY_REDUCE_MIN   (-17)
+#define fts5YY_REDUCE_MAX   (67)
 static const signed char fts5yy_reduce_ofst[] = {
- /*     0 */   -16,   -8,    0,    9,   17,   28,   26,   35,   33,   13,
- /*    10 */    13,   22,   54,   13,   51,
+ /*     0 */   -16,   -8,    0,    9,   17,   25,   37,  -17,   64,  -17,
+ /*    10 */    67,   12,   12,   12,   20,   27,   35,
 };
 static const fts5YYACTIONTYPE fts5yy_default[] = {
- /*     0 */    97,   97,   97,   97,   97,   76,   91,   97,   97,   96,
- /*    10 */    96,   97,   97,   96,   96,   97,   97,   97,   97,   97,
- /*    20 */    73,   89,   97,   90,   97,   97,   87,   97,   72,
+ /*     0 */   104,  104,  104,  104,  104,  104,   89,  104,   98,  104,
+ /*    10 */   104,  103,  103,  103,  103,  104,  104,  104,  104,  104,
+ /*    20 */    85,  104,  104,  104,   94,  104,  104,   84,   96,  104,
+ /*    30 */   104,   97,  104,
 };
 /********** End of lemon-generated parsing tables *****************************/
 
@@ -182884,6 +184758,7 @@ struct fts5yyParser {
   fts5yyStackEntry fts5yystk0;          /* First stack entry */
 #else
   fts5yyStackEntry fts5yystack[fts5YYSTACKDEPTH];  /* The parser's stack */
+  fts5yyStackEntry *fts5yystackEnd;            /* Last entry in the stack */
 #endif
 };
 typedef struct fts5yyParser fts5yyParser;
@@ -182925,11 +184800,11 @@ static void sqlite3Fts5ParserTrace(FILE *TraceFILE, char *zTracePrompt){
 ** are required.  The following table supplies these names */
 static const char *const fts5yyTokenName[] = { 
   "$",             "OR",            "AND",           "NOT",         
-  "TERM",          "COLON",         "LP",            "RP",          
-  "MINUS",         "LCP",           "RCP",           "STRING",      
+  "TERM",          "COLON",         "MINUS",         "LCP",         
+  "RCP",           "STRING",        "LP",            "RP",          
   "COMMA",         "PLUS",          "STAR",          "error",       
   "input",         "expr",          "cnearset",      "exprlist",    
-  "nearset",       "colset",        "colsetlist",    "nearphrases", 
+  "colset",        "colsetlist",    "nearset",       "nearphrases", 
   "phrase",        "neardist_opt",  "star_opt",    
 };
 #endif /* NDEBUG */
@@ -182939,31 +184814,32 @@ static const char *const fts5yyTokenName[] = {
 */
 static const char *const fts5yyRuleName[] = {
  /*   0 */ "input ::= expr",
- /*   1 */ "expr ::= expr AND expr",
- /*   2 */ "expr ::= expr OR expr",
- /*   3 */ "expr ::= expr NOT expr",
- /*   4 */ "expr ::= LP expr RP",
- /*   5 */ "expr ::= exprlist",
- /*   6 */ "exprlist ::= cnearset",
- /*   7 */ "exprlist ::= exprlist cnearset",
- /*   8 */ "cnearset ::= nearset",
- /*   9 */ "cnearset ::= colset COLON nearset",
- /*  10 */ "colset ::= MINUS LCP colsetlist RCP",
- /*  11 */ "colset ::= LCP colsetlist RCP",
- /*  12 */ "colset ::= STRING",
- /*  13 */ "colset ::= MINUS STRING",
- /*  14 */ "colsetlist ::= colsetlist STRING",
- /*  15 */ "colsetlist ::= STRING",
- /*  16 */ "nearset ::= phrase",
- /*  17 */ "nearset ::= STRING LP nearphrases neardist_opt RP",
- /*  18 */ "nearphrases ::= phrase",
- /*  19 */ "nearphrases ::= nearphrases phrase",
- /*  20 */ "neardist_opt ::=",
- /*  21 */ "neardist_opt ::= COMMA STRING",
- /*  22 */ "phrase ::= phrase PLUS STRING star_opt",
- /*  23 */ "phrase ::= STRING star_opt",
- /*  24 */ "star_opt ::= STAR",
- /*  25 */ "star_opt ::=",
+ /*   1 */ "colset ::= MINUS LCP colsetlist RCP",
+ /*   2 */ "colset ::= LCP colsetlist RCP",
+ /*   3 */ "colset ::= STRING",
+ /*   4 */ "colset ::= MINUS STRING",
+ /*   5 */ "colsetlist ::= colsetlist STRING",
+ /*   6 */ "colsetlist ::= STRING",
+ /*   7 */ "expr ::= expr AND expr",
+ /*   8 */ "expr ::= expr OR expr",
+ /*   9 */ "expr ::= expr NOT expr",
+ /*  10 */ "expr ::= colset COLON LP expr RP",
+ /*  11 */ "expr ::= LP expr RP",
+ /*  12 */ "expr ::= exprlist",
+ /*  13 */ "exprlist ::= cnearset",
+ /*  14 */ "exprlist ::= exprlist cnearset",
+ /*  15 */ "cnearset ::= nearset",
+ /*  16 */ "cnearset ::= colset COLON nearset",
+ /*  17 */ "nearset ::= phrase",
+ /*  18 */ "nearset ::= STRING LP nearphrases neardist_opt RP",
+ /*  19 */ "nearphrases ::= phrase",
+ /*  20 */ "nearphrases ::= nearphrases phrase",
+ /*  21 */ "neardist_opt ::=",
+ /*  22 */ "neardist_opt ::= COMMA STRING",
+ /*  23 */ "phrase ::= phrase PLUS STRING star_opt",
+ /*  24 */ "phrase ::= STRING star_opt",
+ /*  25 */ "star_opt ::= STAR",
+ /*  26 */ "star_opt ::=",
 };
 #endif /* NDEBUG */
 
@@ -183032,6 +184908,9 @@ static void sqlite3Fts5ParserInit(void *fts5yypParser){
   pParser->fts5yytos = pParser->fts5yystack;
   pParser->fts5yystack[0].stateno = 0;
   pParser->fts5yystack[0].major = 0;
+#if fts5YYSTACKDEPTH>0
+  pParser->fts5yystackEnd = &pParser->fts5yystack[fts5YYSTACKDEPTH-1];
+#endif
 }
 
 #ifndef sqlite3Fts5Parser_ENGINEALWAYSONSTACK
@@ -183093,16 +184972,16 @@ static void fts5yy_destructor(
  sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24)); 
 }
       break;
-    case 20: /* nearset */
-    case 23: /* nearphrases */
+    case 20: /* colset */
+    case 21: /* colsetlist */
 {
- sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46)); 
+ sqlite3_free((fts5yypminor->fts5yy11)); 
 }
       break;
-    case 21: /* colset */
-    case 22: /* colsetlist */
+    case 22: /* nearset */
+    case 23: /* nearphrases */
 {
- sqlite3_free((fts5yypminor->fts5yy11)); 
+ sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46)); 
 }
       break;
     case 24: /* phrase */
@@ -183330,7 +185209,7 @@ static void fts5yy_shift(
   }
 #endif
 #if fts5YYSTACKDEPTH>0 
-  if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5YYSTACKDEPTH] ){
+  if( fts5yypParser->fts5yytos>fts5yypParser->fts5yystackEnd ){
     fts5yypParser->fts5yytos--;
     fts5yyStackOverflow(fts5yypParser);
     return;
@@ -183358,34 +185237,35 @@ static void fts5yy_shift(
 ** is used during the reduce.
 */
 static const struct {
-  fts5YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
-  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
+  fts5YYCODETYPE lhs;       /* Symbol on the left-hand side of the rule */
+  signed char nrhs;     /* Negative of the number of RHS symbols in the rule */
 } fts5yyRuleInfo[] = {
-  { 16, 1 },
-  { 17, 3 },
-  { 17, 3 },
-  { 17, 3 },
-  { 17, 3 },
-  { 17, 1 },
-  { 19, 1 },
-  { 19, 2 },
-  { 18, 1 },
-  { 18, 3 },
-  { 21, 4 },
-  { 21, 3 },
-  { 21, 1 },
-  { 21, 2 },
-  { 22, 2 },
-  { 22, 1 },
-  { 20, 1 },
-  { 20, 5 },
-  { 23, 1 },
-  { 23, 2 },
+  { 16, -1 },
+  { 20, -4 },
+  { 20, -3 },
+  { 20, -1 },
+  { 20, -2 },
+  { 21, -2 },
+  { 21, -1 },
+  { 17, -3 },
+  { 17, -3 },
+  { 17, -3 },
+  { 17, -5 },
+  { 17, -3 },
+  { 17, -1 },
+  { 19, -1 },
+  { 19, -2 },
+  { 18, -1 },
+  { 18, -3 },
+  { 22, -1 },
+  { 22, -5 },
+  { 23, -1 },
+  { 23, -2 },
   { 25, 0 },
-  { 25, 2 },
-  { 24, 4 },
-  { 24, 2 },
-  { 26, 1 },
+  { 25, -2 },
+  { 24, -4 },
+  { 24, -2 },
+  { 26, -1 },
   { 26, 0 },
 };
 
@@ -183409,7 +185289,7 @@ static void fts5yy_reduce(
   if( fts5yyTraceFILE && fts5yyruleno<(int)(sizeof(fts5yyRuleName)/sizeof(fts5yyRuleName[0])) ){
     fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
     fprintf(fts5yyTraceFILE, "%sReduce [%s], go to state %d.\n", fts5yyTracePrompt,
-      fts5yyRuleName[fts5yyruleno], fts5yymsp[-fts5yysize].stateno);
+      fts5yyRuleName[fts5yyruleno], fts5yymsp[fts5yysize].stateno);
   }
 #endif /* NDEBUG */
 
@@ -183424,7 +185304,7 @@ static void fts5yy_reduce(
     }
 #endif
 #if fts5YYSTACKDEPTH>0 
-    if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5YYSTACKDEPTH-1] ){
+    if( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystackEnd ){
       fts5yyStackOverflow(fts5yypParser);
       return;
     }
@@ -183453,87 +185333,94 @@ static void fts5yy_reduce(
       case 0: /* input ::= expr */
 { sqlite3Fts5ParseFinished(pParse, fts5yymsp[0].minor.fts5yy24); }
         break;
-      case 1: /* expr ::= expr AND expr */
+      case 1: /* colset ::= MINUS LCP colsetlist RCP */
+{ 
+    fts5yymsp[-3].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
+}
+        break;
+      case 2: /* colset ::= LCP colsetlist RCP */
+{ fts5yymsp[-2].minor.fts5yy11 = fts5yymsp[-1].minor.fts5yy11; }
+        break;
+      case 3: /* colset ::= STRING */
+{
+  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
+}
+  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
+        break;
+      case 4: /* colset ::= MINUS STRING */
+{
+  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
+  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
+}
+        break;
+      case 5: /* colsetlist ::= colsetlist STRING */
+{ 
+  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, fts5yymsp[-1].minor.fts5yy11, &fts5yymsp[0].minor.fts5yy0); }
+  fts5yymsp[-1].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
+        break;
+      case 6: /* colsetlist ::= STRING */
+{ 
+  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0); 
+}
+  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
+        break;
+      case 7: /* expr ::= expr AND expr */
 {
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_AND, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
 }
   fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 2: /* expr ::= expr OR expr */
+      case 8: /* expr ::= expr OR expr */
 {
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_OR, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
 }
   fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 3: /* expr ::= expr NOT expr */
+      case 9: /* expr ::= expr NOT expr */
 {
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_NOT, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
 }
   fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 4: /* expr ::= LP expr RP */
+      case 10: /* expr ::= colset COLON LP expr RP */
+{
+  sqlite3Fts5ParseSetColset(pParse, fts5yymsp[-1].minor.fts5yy24, fts5yymsp[-4].minor.fts5yy11);
+  fts5yylhsminor.fts5yy24 = fts5yymsp[-1].minor.fts5yy24;
+}
+  fts5yymsp[-4].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
+        break;
+      case 11: /* expr ::= LP expr RP */
 {fts5yymsp[-2].minor.fts5yy24 = fts5yymsp[-1].minor.fts5yy24;}
         break;
-      case 5: /* expr ::= exprlist */
-      case 6: /* exprlist ::= cnearset */ fts5yytestcase(fts5yyruleno==6);
+      case 12: /* expr ::= exprlist */
+      case 13: /* exprlist ::= cnearset */ fts5yytestcase(fts5yyruleno==13);
 {fts5yylhsminor.fts5yy24 = fts5yymsp[0].minor.fts5yy24;}
   fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 7: /* exprlist ::= exprlist cnearset */
+      case 14: /* exprlist ::= exprlist cnearset */
 {
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseImplicitAnd(pParse, fts5yymsp[-1].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24);
 }
   fts5yymsp[-1].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 8: /* cnearset ::= nearset */
+      case 15: /* cnearset ::= nearset */
 { 
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46); 
 }
   fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 9: /* cnearset ::= colset COLON nearset */
+      case 16: /* cnearset ::= colset COLON nearset */
 { 
-  sqlite3Fts5ParseSetColset(pParse, fts5yymsp[0].minor.fts5yy46, fts5yymsp[-2].minor.fts5yy11);
   fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46); 
+  sqlite3Fts5ParseSetColset(pParse, fts5yylhsminor.fts5yy24, fts5yymsp[-2].minor.fts5yy11);
 }
   fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
         break;
-      case 10: /* colset ::= MINUS LCP colsetlist RCP */
-{ 
-    fts5yymsp[-3].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
-}
-        break;
-      case 11: /* colset ::= LCP colsetlist RCP */
-{ fts5yymsp[-2].minor.fts5yy11 = fts5yymsp[-1].minor.fts5yy11; }
-        break;
-      case 12: /* colset ::= STRING */
-{
-  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
-}
-  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
-        break;
-      case 13: /* colset ::= MINUS STRING */
-{
-  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
-  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
-}
-        break;
-      case 14: /* colsetlist ::= colsetlist STRING */
-{ 
-  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, fts5yymsp[-1].minor.fts5yy11, &fts5yymsp[0].minor.fts5yy0); }
-  fts5yymsp[-1].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
-        break;
-      case 15: /* colsetlist ::= STRING */
-{ 
-  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0); 
-}
-  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
-        break;
-      case 16: /* nearset ::= phrase */
+      case 17: /* nearset ::= phrase */
 { fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); }
   fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
         break;
-      case 17: /* nearset ::= STRING LP nearphrases neardist_opt RP */
+      case 18: /* nearset ::= STRING LP nearphrases neardist_opt RP */
 {
   sqlite3Fts5ParseNear(pParse, &fts5yymsp[-4].minor.fts5yy0);
   sqlite3Fts5ParseSetDistance(pParse, fts5yymsp[-2].minor.fts5yy46, &fts5yymsp[-1].minor.fts5yy0);
@@ -183541,40 +185428,40 @@ static void fts5yy_reduce(
 }
   fts5yymsp[-4].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
         break;
-      case 18: /* nearphrases ::= phrase */
+      case 19: /* nearphrases ::= phrase */
 { 
   fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); 
 }
   fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
         break;
-      case 19: /* nearphrases ::= nearphrases phrase */
+      case 20: /* nearphrases ::= nearphrases phrase */
 {
   fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, fts5yymsp[-1].minor.fts5yy46, fts5yymsp[0].minor.fts5yy53);
 }
   fts5yymsp[-1].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
         break;
-      case 20: /* neardist_opt ::= */
+      case 21: /* neardist_opt ::= */
 { fts5yymsp[1].minor.fts5yy0.p = 0; fts5yymsp[1].minor.fts5yy0.n = 0; }
         break;
-      case 21: /* neardist_opt ::= COMMA STRING */
+      case 22: /* neardist_opt ::= COMMA STRING */
 { fts5yymsp[-1].minor.fts5yy0 = fts5yymsp[0].minor.fts5yy0; }
         break;
-      case 22: /* phrase ::= phrase PLUS STRING star_opt */
+      case 23: /* phrase ::= phrase PLUS STRING star_opt */
 { 
   fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, fts5yymsp[-3].minor.fts5yy53, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4);
 }
   fts5yymsp[-3].minor.fts5yy53 = fts5yylhsminor.fts5yy53;
         break;
-      case 23: /* phrase ::= STRING star_opt */
+      case 24: /* phrase ::= STRING star_opt */
 { 
   fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, 0, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4);
 }
   fts5yymsp[-1].minor.fts5yy53 = fts5yylhsminor.fts5yy53;
         break;
-      case 24: /* star_opt ::= STAR */
+      case 25: /* star_opt ::= STAR */
 { fts5yymsp[0].minor.fts5yy4 = 1; }
         break;
-      case 25: /* star_opt ::= */
+      case 26: /* star_opt ::= */
 { fts5yymsp[1].minor.fts5yy4 = 0; }
         break;
       default:
@@ -183584,20 +185471,24 @@ static void fts5yy_reduce(
   assert( fts5yyruleno<sizeof(fts5yyRuleInfo)/sizeof(fts5yyRuleInfo[0]) );
   fts5yygoto = fts5yyRuleInfo[fts5yyruleno].lhs;
   fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
-  fts5yyact = fts5yy_find_reduce_action(fts5yymsp[-fts5yysize].stateno,(fts5YYCODETYPE)fts5yygoto);
-  if( fts5yyact <= fts5YY_MAX_SHIFTREDUCE ){
-    if( fts5yyact>fts5YY_MAX_SHIFT ){
-      fts5yyact += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;
-    }
-    fts5yymsp -= fts5yysize-1;
+  fts5yyact = fts5yy_find_reduce_action(fts5yymsp[fts5yysize].stateno,(fts5YYCODETYPE)fts5yygoto);
+
+  /* There are no SHIFTREDUCE actions on nonterminals because the table
+  ** generator has simplified them to pure REDUCE actions. */
+  assert( !(fts5yyact>fts5YY_MAX_SHIFT && fts5yyact<=fts5YY_MAX_SHIFTREDUCE) );
+
+  /* It is not possible for a REDUCE to be followed by an error */
+  assert( fts5yyact!=fts5YY_ERROR_ACTION );
+
+  if( fts5yyact==fts5YY_ACCEPT_ACTION ){
+    fts5yypParser->fts5yytos += fts5yysize;
+    fts5yy_accept(fts5yypParser);
+  }else{
+    fts5yymsp += fts5yysize+1;
     fts5yypParser->fts5yytos = fts5yymsp;
     fts5yymsp->stateno = (fts5YYACTIONTYPE)fts5yyact;
     fts5yymsp->major = (fts5YYCODETYPE)fts5yygoto;
     fts5yyTraceShift(fts5yypParser, fts5yyact);
-  }else{
-    assert( fts5yyact == fts5YY_ACCEPT_ACTION );
-    fts5yypParser->fts5yytos -= fts5yysize;
-    fts5yy_accept(fts5yypParser);
   }
 }
 
@@ -184616,9 +186507,11 @@ static void sqlite3Fts5BufferAppendBlob(
   const u8 *pData
 ){
   assert_nc( *pRc || nData>=0 );
-  if( fts5BufferGrow(pRc, pBuf, nData) ) return;
-  memcpy(&pBuf->p[pBuf->n], pData, nData);
-  pBuf->n += nData;
+  if( nData ){
+    if( fts5BufferGrow(pRc, pBuf, nData) ) return;
+    memcpy(&pBuf->p[pBuf->n], pData, nData);
+    pBuf->n += nData;
+  }
 }
 
 /*
@@ -184795,8 +186688,8 @@ static void *sqlite3Fts5MallocZero(int *pRc, int nByte){
   void *pRet = 0;
   if( *pRc==SQLITE_OK ){
     pRet = sqlite3_malloc(nByte);
-    if( pRet==0 && nByte>0 ){
-      *pRc = SQLITE_NOMEM;
+    if( pRet==0 ){
+      if( nByte>0 ) *pRc = SQLITE_NOMEM;
     }else{
       memset(pRet, 0, nByte);
     }
@@ -186117,6 +188010,7 @@ static void fts5ParseFree(void *p){ sqlite3_free(p); }
 
 static int sqlite3Fts5ExprNew(
   Fts5Config *pConfig,            /* FTS5 Configuration */
+  int iCol,
   const char *zExpr,              /* Expression text */
   Fts5Expr **ppNew, 
   char **pzErr
@@ -186141,6 +188035,18 @@ static int sqlite3Fts5ExprNew(
   }while( sParse.rc==SQLITE_OK && t!=FTS5_EOF );
   sqlite3Fts5ParserFree(pEngine, fts5ParseFree);
 
+  /* If the LHS of the MATCH expression was a user column, apply the
+  ** implicit column-filter.  */
+  if( iCol<pConfig->nCol && sParse.pExpr && sParse.rc==SQLITE_OK ){
+    int n = sizeof(Fts5Colset);
+    Fts5Colset *pColset = (Fts5Colset*)sqlite3Fts5MallocZero(&sParse.rc, n);
+    if( pColset ){
+      pColset->nCol = 1;
+      pColset->aiCol[0] = iCol;
+      sqlite3Fts5ParseSetColset(&sParse, sParse.pExpr, pColset);
+    }
+  }
+
   assert( sParse.rc!=SQLITE_OK || sParse.zErr==0 );
   if( sParse.rc==SQLITE_OK ){
     *ppNew = pNew = sqlite3_malloc(sizeof(Fts5Expr));
@@ -187790,25 +189696,110 @@ static Fts5Colset *sqlite3Fts5ParseColset(
   return pRet;
 }
 
+/*
+** If argument pOrig is NULL, or if (*pRc) is set to anything other than
+** SQLITE_OK when this function is called, NULL is returned. 
+**
+** Otherwise, a copy of (*pOrig) is made into memory obtained from
+** sqlite3Fts5MallocZero() and a pointer to it returned. If the allocation
+** fails, (*pRc) is set to SQLITE_NOMEM and NULL is returned.
+*/
+static Fts5Colset *fts5CloneColset(int *pRc, Fts5Colset *pOrig){
+  Fts5Colset *pRet;
+  if( pOrig ){
+    int nByte = sizeof(Fts5Colset) + (pOrig->nCol-1) * sizeof(int);
+    pRet = (Fts5Colset*)sqlite3Fts5MallocZero(pRc, nByte);
+    if( pRet ){ 
+      memcpy(pRet, pOrig, nByte);
+    }
+  }else{
+    pRet = 0;
+  }
+  return pRet;
+}
+
+/*
+** Remove from colset pColset any columns that are not also in colset pMerge.
+*/
+static void fts5MergeColset(Fts5Colset *pColset, Fts5Colset *pMerge){
+  int iIn = 0;          /* Next input in pColset */
+  int iMerge = 0;       /* Next input in pMerge */
+  int iOut = 0;         /* Next output slot in pColset */
+
+  while( iIn<pColset->nCol && iMerge<pMerge->nCol ){
+    int iDiff = pColset->aiCol[iIn] - pMerge->aiCol[iMerge];
+    if( iDiff==0 ){
+      pColset->aiCol[iOut++] = pMerge->aiCol[iMerge];
+      iMerge++;
+      iIn++;
+    }else if( iDiff>0 ){
+      iMerge++;
+    }else{
+      iIn++;
+    }
+  }
+  pColset->nCol = iOut;
+}
+
+/*
+** Recursively apply colset pColset to expression node pNode and all of
+** its decendents. If (*ppFree) is not NULL, it contains a spare copy
+** of pColset. This function may use the spare copy and set (*ppFree) to
+** zero, or it may create copies of pColset using fts5CloneColset().
+*/
+static void fts5ParseSetColset(
+  Fts5Parse *pParse, 
+  Fts5ExprNode *pNode, 
+  Fts5Colset *pColset,
+  Fts5Colset **ppFree
+){
+  if( pParse->rc==SQLITE_OK ){
+    assert( pNode->eType==FTS5_TERM || pNode->eType==FTS5_STRING 
+         || pNode->eType==FTS5_AND  || pNode->eType==FTS5_OR
+         || pNode->eType==FTS5_NOT  || pNode->eType==FTS5_EOF
+    );
+    if( pNode->eType==FTS5_STRING || pNode->eType==FTS5_TERM ){
+      Fts5ExprNearset *pNear = pNode->pNear;
+      if( pNear->pColset ){
+        fts5MergeColset(pNear->pColset, pColset);
+        if( pNear->pColset->nCol==0 ){
+          pNode->eType = FTS5_EOF;
+          pNode->xNext = 0;
+        }
+      }else if( *ppFree ){
+        pNear->pColset = pColset;
+        *ppFree = 0;
+      }else{
+        pNear->pColset = fts5CloneColset(&pParse->rc, pColset);
+      }
+    }else{
+      int i;
+      assert( pNode->eType!=FTS5_EOF || pNode->nChild==0 );
+      for(i=0; i<pNode->nChild; i++){
+        fts5ParseSetColset(pParse, pNode->apChild[i], pColset, ppFree);
+      }
+    }
+  }
+}
+
+/*
+** Apply colset pColset to expression node pExpr and all of its descendents.
+*/
 static void sqlite3Fts5ParseSetColset(
   Fts5Parse *pParse, 
-  Fts5ExprNearset *pNear, 
+  Fts5ExprNode *pExpr, 
   Fts5Colset *pColset 
 ){
+  Fts5Colset *pFree = pColset;
   if( pParse->pConfig->eDetail==FTS5_DETAIL_NONE ){
     pParse->rc = SQLITE_ERROR;
     pParse->zErr = sqlite3_mprintf(
       "fts5: column queries are not supported (detail=none)"
     );
-    sqlite3_free(pColset);
-    return;
-  }
-
-  if( pNear ){
-    pNear->pColset = pColset;
   }else{
-    sqlite3_free(pColset);
+    fts5ParseSetColset(pParse, pExpr, pColset, &pFree);
   }
+  sqlite3_free(pFree);
 }
 
 static void fts5ExprAssignXNext(Fts5ExprNode *pNode){
@@ -188262,7 +190253,7 @@ static void fts5ExprFunction(
 
   rc = sqlite3Fts5ConfigParse(pGlobal, db, nConfig, azConfig, &pConfig, &zErr);
   if( rc==SQLITE_OK ){
-    rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pExpr, &zErr);
+    rc = sqlite3Fts5ExprNew(pConfig, pConfig->nCol, zExpr, &pExpr, &zErr);
   }
   if( rc==SQLITE_OK ){
     char *zText;
@@ -188659,9 +190650,10 @@ struct Fts5Hash {
 
 /*
 ** Each entry in the hash table is represented by an object of the 
-** following type. Each object, its key (zKey[]) and its current data
-** are stored in a single memory allocation. The position list data 
-** immediately follows the key data in memory.
+** following type. Each object, its key (a nul-terminated string) and 
+** its current data are stored in a single memory allocation. The 
+** key immediately follows the object in memory. The position list
+** data immediately follows the key data in memory.
 **
 ** The data that follows the key is in a similar, but not identical format
 ** to the doclist data stored in the database. It is:
@@ -188685,20 +190677,20 @@ struct Fts5HashEntry {
   int nAlloc;                     /* Total size of allocation */
   int iSzPoslist;                 /* Offset of space for 4-byte poslist size */
   int nData;                      /* Total bytes of data (incl. structure) */
-  int nKey;                       /* Length of zKey[] in bytes */
+  int nKey;                       /* Length of key in bytes */
   u8 bDel;                        /* Set delete-flag @ iSzPoslist */
   u8 bContent;                    /* Set content-flag (detail=none mode) */
   i16 iCol;                       /* Column of last value written */
   int iPos;                       /* Position of last value written */
   i64 iRowid;                     /* Rowid of last value written */
-  char zKey[8];                   /* Nul-terminated entry key */
 };
 
 /*
-** Size of Fts5HashEntry without the zKey[] array.
+** Eqivalent to:
+**
+**   char *fts5EntryKey(Fts5HashEntry *pEntry){ return zKey; }
 */
-#define FTS5_HASHENTRYSIZE (sizeof(Fts5HashEntry)-8)
-
+#define fts5EntryKey(p) ( ((char *)(&(p)[1])) )
 
 
 /*
@@ -188793,10 +190785,11 @@ static int fts5HashResize(Fts5Hash *pHash){
 
   for(i=0; i<pHash->nSlot; i++){
     while( apOld[i] ){
-      int iHash;
+      unsigned int iHash;
       Fts5HashEntry *p = apOld[i];
       apOld[i] = p->pHashNext;
-      iHash = fts5HashKey(nNew, (u8*)p->zKey, (int)strlen(p->zKey));
+      iHash = fts5HashKey(nNew, (u8*)fts5EntryKey(p),
+                          (int)strlen(fts5EntryKey(p)));
       p->pHashNext = apNew[iHash];
       apNew[iHash] = p;
     }
@@ -188867,9 +190860,10 @@ static int sqlite3Fts5HashWrite(
   /* Attempt to locate an existing hash entry */
   iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);
   for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){
-    if( p->zKey[0]==bByte 
+    char *zKey = fts5EntryKey(p);
+    if( zKey[0]==bByte 
      && p->nKey==nToken
-     && memcmp(&p->zKey[1], pToken, nToken)==0 
+     && memcmp(&zKey[1], pToken, nToken)==0 
     ){
       break;
     }
@@ -188878,7 +190872,8 @@ static int sqlite3Fts5HashWrite(
   /* If an existing hash entry cannot be found, create a new one. */
   if( p==0 ){
     /* Figure out how much space to allocate */
-    int nByte = FTS5_HASHENTRYSIZE + (nToken+1) + 1 + 64;
+    char *zKey;
+    int nByte = sizeof(Fts5HashEntry) + (nToken+1) + 1 + 64;
     if( nByte<128 ) nByte = 128;
 
     /* Grow the Fts5Hash.aSlot[] array if necessary. */
@@ -188891,14 +190886,15 @@ static int sqlite3Fts5HashWrite(
     /* Allocate new Fts5HashEntry and add it to the hash table. */
     p = (Fts5HashEntry*)sqlite3_malloc(nByte);
     if( !p ) return SQLITE_NOMEM;
-    memset(p, 0, FTS5_HASHENTRYSIZE);
+    memset(p, 0, sizeof(Fts5HashEntry));
     p->nAlloc = nByte;
-    p->zKey[0] = bByte;
-    memcpy(&p->zKey[1], pToken, nToken);
-    assert( iHash==fts5HashKey(pHash->nSlot, (u8*)p->zKey, nToken+1) );
+    zKey = fts5EntryKey(p);
+    zKey[0] = bByte;
+    memcpy(&zKey[1], pToken, nToken);
+    assert( iHash==fts5HashKey(pHash->nSlot, (u8*)zKey, nToken+1) );
     p->nKey = nToken;
-    p->zKey[nToken+1] = '\0';
-    p->nData = nToken+1 + 1 + FTS5_HASHENTRYSIZE;
+    zKey[nToken+1] = '\0';
+    p->nData = nToken+1 + 1 + sizeof(Fts5HashEntry);
     p->pHashNext = pHash->aSlot[iHash];
     pHash->aSlot[iHash] = p;
     pHash->nEntry++;
@@ -189016,9 +191012,11 @@ static Fts5HashEntry *fts5HashEntryMerge(
       p1 = 0;
     }else{
       int i = 0;
-      while( p1->zKey[i]==p2->zKey[i] ) i++;
+      char *zKey1 = fts5EntryKey(p1);
+      char *zKey2 = fts5EntryKey(p2);
+      while( zKey1[i]==zKey2[i] ) i++;
 
-      if( ((u8)p1->zKey[i])>((u8)p2->zKey[i]) ){
+      if( ((u8)zKey1[i])>((u8)zKey2[i]) ){
         /* p2 is smaller */
         *ppOut = p2;
         ppOut = &p2->pScanNext;
@@ -189061,7 +191059,7 @@ static int fts5HashEntrySort(
   for(iSlot=0; iSlot<pHash->nSlot; iSlot++){
     Fts5HashEntry *pIter;
     for(pIter=pHash->aSlot[iSlot]; pIter; pIter=pIter->pHashNext){
-      if( pTerm==0 || 0==memcmp(pIter->zKey, pTerm, nTerm) ){
+      if( pTerm==0 || 0==memcmp(fts5EntryKey(pIter), pTerm, nTerm) ){
         Fts5HashEntry *pEntry = pIter;
         pEntry->pScanNext = 0;
         for(i=0; ap[i]; i++){
@@ -189094,16 +191092,18 @@ static int sqlite3Fts5HashQuery(
   int *pnDoclist                  /* OUT: Size of doclist in bytes */
 ){
   unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);
+  char *zKey = 0;
   Fts5HashEntry *p;
 
   for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){
-    if( memcmp(p->zKey, pTerm, nTerm)==0 && p->zKey[nTerm]==0 ) break;
+    zKey = fts5EntryKey(p);
+    if( memcmp(zKey, pTerm, nTerm)==0 && zKey[nTerm]==0 ) break;
   }
 
   if( p ){
     fts5HashAddPoslistSize(pHash, p);
-    *ppDoclist = (const u8*)&p->zKey[nTerm+1];
-    *pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
+    *ppDoclist = (const u8*)&zKey[nTerm+1];
+    *pnDoclist = p->nData - (sizeof(Fts5HashEntry) + nTerm + 1);
   }else{
     *ppDoclist = 0;
     *pnDoclist = 0;
@@ -189136,11 +191136,12 @@ static void sqlite3Fts5HashScanEntry(
 ){
   Fts5HashEntry *p;
   if( (p = pHash->pScan) ){
-    int nTerm = (int)strlen(p->zKey);
+    char *zKey = fts5EntryKey(p);
+    int nTerm = (int)strlen(zKey);
     fts5HashAddPoslistSize(pHash, p);
-    *pzTerm = p->zKey;
-    *ppDoclist = (const u8*)&p->zKey[nTerm+1];
-    *pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
+    *pzTerm = zKey;
+    *ppDoclist = (const u8*)&zKey[nTerm+1];
+    *pnDoclist = p->nData - (sizeof(Fts5HashEntry) + nTerm + 1);
   }else{
     *pzTerm = 0;
     *ppDoclist = 0;
@@ -189779,7 +191780,6 @@ static void fts5CloseReader(Fts5Index *p){
   }
 }
 
-
 /*
 ** Retrieve a record from the %_data table.
 **
@@ -189880,7 +191880,8 @@ static int fts5IndexPrepareStmt(
 ){
   if( p->rc==SQLITE_OK ){
     if( zSql ){
-      p->rc = sqlite3_prepare_v2(p->pConfig->db, zSql, -1, ppStmt, 0);
+      p->rc = sqlite3_prepare_v3(p->pConfig->db, zSql, -1,
+                                 SQLITE_PREPARE_PERSISTENT, ppStmt, 0);
     }else{
       p->rc = SQLITE_NOMEM;
     }
@@ -189929,7 +191930,8 @@ static void fts5DataDelete(Fts5Index *p, i64 iFirst, i64 iLast){
     if( zSql==0 ){
       rc = SQLITE_NOMEM;
     }else{
-      rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p->pDeleter, 0);
+      rc = sqlite3_prepare_v3(pConfig->db, zSql, -1,
+                              SQLITE_PREPARE_PERSISTENT, &p->pDeleter, 0);
       sqlite3_free(zSql);
     }
     if( rc!=SQLITE_OK ){
@@ -192030,7 +194032,8 @@ static void fts5MultiIterNext2(
 ){
   assert( pIter->bSkipEmpty );
   if( p->rc==SQLITE_OK ){
-    do {
+    *pbNewTerm = 0;
+    do{
       int iFirst = pIter->aFirst[1].iFirst;
       Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
       int bNewTerm = 0;
@@ -192043,8 +194046,6 @@ static void fts5MultiIterNext2(
         fts5MultiIterAdvanced(p, pIter, iFirst, 1);
         fts5MultiIterSetEof(pIter);
         *pbNewTerm = 1;
-      }else{
-        *pbNewTerm = 0;
       }
       fts5AssertMultiIterSetup(p, pIter);
 
@@ -192310,23 +194311,23 @@ static int fts5IndexExtractCol(
   return p - (*pa);
 }
 
-static int fts5IndexExtractColset (
+static void fts5IndexExtractColset(
+  int *pRc,
   Fts5Colset *pColset,            /* Colset to filter on */
   const u8 *pPos, int nPos,       /* Position list */
   Fts5Buffer *pBuf                /* Output buffer */
 ){
-  int rc = SQLITE_OK;
-  int i;
-
-  fts5BufferZero(pBuf);
-  for(i=0; i<pColset->nCol; i++){
-    const u8 *pSub = pPos;
-    int nSub = fts5IndexExtractCol(&pSub, nPos, pColset->aiCol[i]);
-    if( nSub ){
-      fts5BufferAppendBlob(&rc, pBuf, nSub, pSub);
+  if( *pRc==SQLITE_OK ){
+    int i;
+    fts5BufferZero(pBuf);
+    for(i=0; i<pColset->nCol; i++){
+      const u8 *pSub = pPos;
+      int nSub = fts5IndexExtractCol(&pSub, nPos, pColset->aiCol[i]);
+      if( nSub ){
+        fts5BufferAppendBlob(pRc, pBuf, nSub, pSub);
+      }
     }
   }
-  return rc;
 }
 
 /*
@@ -192450,8 +194451,9 @@ static void fts5IterSetOutputs_Full(Fts5Iter *pIter, Fts5SegIter *pSeg){
       pIter->base.nData = fts5IndexExtractCol(&a, pSeg->nPos,pColset->aiCol[0]);
       pIter->base.pData = a;
     }else{
+      int *pRc = &pIter->pIndex->rc;
       fts5BufferZero(&pIter->poslist);
-      fts5IndexExtractColset(pColset, a, pSeg->nPos, &pIter->poslist);
+      fts5IndexExtractColset(pRc, pColset, a, pSeg->nPos, &pIter->poslist);
       pIter->base.pData = pIter->poslist.p;
       pIter->base.nData = pIter->poslist.n;
     }
@@ -192996,9 +194998,6 @@ static void fts5WriteFlushLeaf(Fts5Index *p, Fts5SegWriter *pWriter){
   Fts5PageWriter *pPage = &pWriter->writer;
   i64 iRowid;
 
-static int nCall = 0;
-nCall++;
-
   assert( (pPage->pgidx.n==0)==(pWriter->bFirstTermInPage) );
 
   /* Set the szLeaf header field. */
@@ -193347,6 +195346,7 @@ static void fts5IndexMergeLevel(
   int bOldest;                    /* True if the output segment is the oldest */
   int eDetail = p->pConfig->eDetail;
   const int flags = FTS5INDEX_QUERY_NOOUTPUT;
+  int bTermWritten = 0;           /* True if current term already output */
 
   assert( iLvl<pStruct->nLevel );
   assert( pLvl->nMerge<=pLvl->nSeg );
@@ -193400,18 +195400,22 @@ static void fts5IndexMergeLevel(
     int nTerm;
     const u8 *pTerm;
 
-    /* Check for key annihilation. */
-    if( pSegIter->nPos==0 && (bOldest || pSegIter->bDel==0) ) continue;
-
     pTerm = fts5MultiIterTerm(pIter, &nTerm);
     if( nTerm!=term.n || memcmp(pTerm, term.p, nTerm) ){
       if( pnRem && writer.nLeafWritten>nRem ){
         break;
       }
+      fts5BufferSet(&p->rc, &term, nTerm, pTerm);
+      bTermWritten =0;
+    }
+
+    /* Check for key annihilation. */
+    if( pSegIter->nPos==0 && (bOldest || pSegIter->bDel==0) ) continue;
 
+    if( p->rc==SQLITE_OK && bTermWritten==0 ){
       /* This is a new term. Append a term to the output segment. */
       fts5WriteAppendTerm(p, &writer, nTerm, pTerm);
-      fts5BufferSet(&p->rc, &term, nTerm, pTerm);
+      bTermWritten = 1;
     }
 
     /* Append the rowid to the output */
@@ -194243,7 +196247,7 @@ static void fts5SetupPrefixIter(
     if( pData ){
       pData->p = (u8*)&pData[1];
       pData->nn = pData->szLeaf = doclist.n;
-      memcpy(pData->p, doclist.p, doclist.n);
+      if( doclist.n ) memcpy(pData->p, doclist.p, doclist.n);
       fts5MultiIterNew2(p, pData, bDesc, ppIter);
     }
     fts5BufferFree(&doclist);
@@ -194282,10 +196286,10 @@ static int sqlite3Fts5IndexBeginWrite(Fts5Index *p, int bDelete, i64 iRowid){
 /*
 ** Commit data to disk.
 */
-static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit){
+static int sqlite3Fts5IndexSync(Fts5Index *p){
   assert( p->rc==SQLITE_OK );
   fts5IndexFlush(p);
-  if( bCommit ) fts5CloseReader(p);
+  fts5CloseReader(p);
   return fts5IndexReturn(p);
 }
 
@@ -194482,7 +196486,7 @@ static int sqlite3Fts5IndexQuery(
 
   if( sqlite3Fts5BufferSize(&p->rc, &buf, nToken+1)==0 ){
     int iIdx = 0;                 /* Index to search */
-    memcpy(&buf.p[1], pToken, nToken);
+    if( nToken ) memcpy(&buf.p[1], pToken, nToken);
 
     /* Figure out which index to search and set iIdx accordingly. If this
     ** is a prefix query for which there is no prefix index, set iIdx to
@@ -194531,7 +196535,7 @@ static int sqlite3Fts5IndexQuery(
     }
 
     if( p->rc ){
-      sqlite3Fts5IterClose(&pRet->base);
+      sqlite3Fts5IterClose((Fts5IndexIter*)pRet);
       pRet = 0;
       fts5CloseReader(p);
     }
@@ -196149,6 +198153,7 @@ static void fts5SetUniqueFlag(sqlite3_index_info *pIdxInfo){
 static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
   Fts5Table *pTab = (Fts5Table*)pVTab;
   Fts5Config *pConfig = pTab->pConfig;
+  const int nCol = pConfig->nCol;
   int idxFlags = 0;               /* Parameter passed through to xFilter() */
   int bHasMatch;
   int iNext;
@@ -196174,24 +198179,34 @@ static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
 
   int aColMap[3];
   aColMap[0] = -1;
-  aColMap[1] = pConfig->nCol;
-  aColMap[2] = pConfig->nCol+1;
+  aColMap[1] = nCol;
+  aColMap[2] = nCol+1;
 
   /* Set idxFlags flags for all WHERE clause terms that will be used. */
   for(i=0; i<pInfo->nConstraint; i++){
     struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
-    int j;
-    for(j=0; j<ArraySize(aConstraint); j++){
-      struct Constraint *pC = &aConstraint[j];
-      if( p->iColumn==aColMap[pC->iCol] && p->op & pC->op ){
-        if( p->usable ){
+    int iCol = p->iColumn;
+
+    if( (p->op==SQLITE_INDEX_CONSTRAINT_MATCH && iCol>=0 && iCol<=nCol)
+     || (p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol==nCol)
+    ){
+      /* A MATCH operator or equivalent */
+      if( p->usable ){
+        idxFlags = (idxFlags & 0xFFFF) | FTS5_BI_MATCH | (iCol << 16);
+        aConstraint[0].iConsIndex = i;
+      }else{
+        /* As there exists an unusable MATCH constraint this is an 
+        ** unusable plan. Set a prohibitively high cost. */
+        pInfo->estimatedCost = 1e50;
+        return SQLITE_OK;
+      }
+    }else{
+      int j;
+      for(j=1; j<ArraySize(aConstraint); j++){
+        struct Constraint *pC = &aConstraint[j];
+        if( iCol==aColMap[pC->iCol] && p->op & pC->op && p->usable ){
           pC->iConsIndex = i;
           idxFlags |= pC->fts5op;
-        }else if( j==0 ){
-          /* As there exists an unusable MATCH constraint this is an 
-          ** unusable plan. Set a prohibitively high cost. */
-          pInfo->estimatedCost = 1e50;
-          return SQLITE_OK;
         }
       }
     }
@@ -196515,7 +198530,8 @@ static int fts5PrepareStatement(
   if( zSql==0 ){
     rc = SQLITE_NOMEM; 
   }else{
-    rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pRet, 0);
+    rc = sqlite3_prepare_v3(pConfig->db, zSql, -1, 
+                            SQLITE_PREPARE_PERSISTENT, &pRet, 0);
     if( rc!=SQLITE_OK ){
       *pConfig->pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(pConfig->db));
     }
@@ -196651,7 +198667,8 @@ static int fts5FindRankFunction(Fts5Cursor *pCsr){
     char *zSql = sqlite3Fts5Mprintf(&rc, "SELECT %s", zRankArgs);
     if( zSql ){
       sqlite3_stmt *pStmt = 0;
-      rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pStmt, 0);
+      rc = sqlite3_prepare_v3(pConfig->db, zSql, -1,
+                              SQLITE_PREPARE_PERSISTENT, &pStmt, 0);
       sqlite3_free(zSql);
       assert( rc==SQLITE_OK || pCsr->pRankArgStmt==0 );
       if( rc==SQLITE_OK ){
@@ -196766,6 +198783,7 @@ static int fts5FilterMethod(
   sqlite3_value *pRowidEq = 0;    /* rowid = ? expression (or NULL) */
   sqlite3_value *pRowidLe = 0;    /* rowid <= ? expression (or NULL) */
   sqlite3_value *pRowidGe = 0;    /* rowid >= ? expression (or NULL) */
+  int iCol;                       /* Column on LHS of MATCH operator */
   char **pzErrmsg = pConfig->pzErrmsg;
 
   UNUSED_PARAM(zUnused);
@@ -196796,6 +198814,8 @@ static int fts5FilterMethod(
   if( BitFlagTest(idxNum, FTS5_BI_ROWID_EQ) ) pRowidEq = apVal[iVal++];
   if( BitFlagTest(idxNum, FTS5_BI_ROWID_LE) ) pRowidLe = apVal[iVal++];
   if( BitFlagTest(idxNum, FTS5_BI_ROWID_GE) ) pRowidGe = apVal[iVal++];
+  iCol = (idxNum>>16);
+  assert( iCol>=0 && iCol<=pConfig->nCol );
   assert( iVal==nVal );
   bOrderByRank = ((idxNum & FTS5_BI_ORDER_RANK) ? 1 : 0);
   pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);
@@ -196842,7 +198862,7 @@ static int fts5FilterMethod(
         rc = fts5SpecialMatch(pTab, pCsr, &zExpr[1]);
       }else{
         char **pzErr = &pTab->base.zErrMsg;
-        rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pCsr->pExpr, pzErr);
+        rc = sqlite3Fts5ExprNew(pConfig, iCol, zExpr, &pCsr->pExpr, pzErr);
         if( rc==SQLITE_OK ){
           if( bOrderByRank ){
             pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
@@ -197222,7 +199242,7 @@ static int fts5SyncMethod(sqlite3_vtab *pVtab){
   fts5CheckTransactionState(pTab, FTS5_SYNC, 0);
   pTab->pConfig->pzErrmsg = &pTab->base.zErrMsg;
   fts5TripCursors(pTab);
-  rc = sqlite3Fts5StorageSync(pTab->pStorage, 1);
+  rc = sqlite3Fts5StorageSync(pTab->pStorage);
   pTab->pConfig->pzErrmsg = 0;
   return rc;
 }
@@ -198033,7 +200053,7 @@ static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){
   UNUSED_PARAM(iSavepoint);  /* Call below is a no-op for NDEBUG builds */
   fts5CheckTransactionState(pTab, FTS5_SAVEPOINT, iSavepoint);
   fts5TripCursors(pTab);
-  return sqlite3Fts5StorageSync(pTab->pStorage, 0);
+  return sqlite3Fts5StorageSync(pTab->pStorage);
 }
 
 /*
@@ -198046,7 +200066,7 @@ static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){
   UNUSED_PARAM(iSavepoint);  /* Call below is a no-op for NDEBUG builds */
   fts5CheckTransactionState(pTab, FTS5_RELEASE, iSavepoint);
   fts5TripCursors(pTab);
-  return sqlite3Fts5StorageSync(pTab->pStorage, 0);
+  return sqlite3Fts5StorageSync(pTab->pStorage);
 }
 
 /*
@@ -198236,15 +200256,14 @@ static void fts5ModuleDestroy(void *pCtx){
 static void fts5Fts5Func(
   sqlite3_context *pCtx,          /* Function call context */
   int nArg,                       /* Number of args */
-  sqlite3_value **apUnused        /* Function arguments */
+  sqlite3_value **apArg           /* Function arguments */
 ){
   Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);
-  char buf[8];
-  UNUSED_PARAM2(nArg, apUnused);
-  assert( nArg==0 );
-  assert( sizeof(buf)>=sizeof(pGlobal) );
-  memcpy(buf, (void*)&pGlobal, sizeof(pGlobal));
-  sqlite3_result_blob(pCtx, buf, sizeof(pGlobal), SQLITE_TRANSIENT);
+  fts5_api **ppApi;
+  UNUSED_PARAM(nArg);
+  assert( nArg==1 );
+  ppApi = (fts5_api**)sqlite3_value_pointer(apArg[0], "fts5_api_ptr");
+  if( ppApi ) *ppApi = &pGlobal->api;
 }
 
 /*
@@ -198257,7 +200276,7 @@ static void fts5SourceIdFunc(
 ){
   assert( nArg==0 );
   UNUSED_PARAM2(nArg, apUnused);
-  sqlite3_result_text(pCtx, "fts5: 2017-03-28 18:48:43 424a0d380332858ee55bdebc4af3789f74e70a2b3ba1cf29d84b9b4bcf3e2e37", -1, SQLITE_TRANSIENT);
+  sqlite3_result_text(pCtx, "fts5: 2017-08-24 16:21:36 8d3a7ea6c5690d6b7c3767558f4f01b511c55463e3f9e64506801fe9b74dce34", -1, SQLITE_TRANSIENT);
 }
 
 static int fts5Init(sqlite3 *db){
@@ -198309,7 +200328,7 @@ static int fts5Init(sqlite3 *db){
     if( rc==SQLITE_OK ) rc = sqlite3Fts5VocabInit(pGlobal, db);
     if( rc==SQLITE_OK ){
       rc = sqlite3_create_function(
-          db, "fts5", 0, SQLITE_UTF8, p, fts5Fts5Func, 0, 0
+          db, "fts5", 1, SQLITE_UTF8, p, fts5Fts5Func, 0, 0
       );
     }
     if( rc==SQLITE_OK ){
@@ -198511,7 +200530,8 @@ static int fts5StorageGetStmt(
     if( zSql==0 ){
       rc = SQLITE_NOMEM;
     }else{
-      rc = sqlite3_prepare_v2(pC->db, zSql, -1, &p->aStmt[eStmt], 0);
+      rc = sqlite3_prepare_v3(pC->db, zSql, -1,
+                              SQLITE_PREPARE_PERSISTENT, &p->aStmt[eStmt], 0);
       sqlite3_free(zSql);
       if( rc!=SQLITE_OK && pzErrMsg ){
         *pzErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pC->db));
@@ -198593,7 +200613,7 @@ static void fts5StorageRenameOne(
 
 static int sqlite3Fts5StorageRename(Fts5Storage *pStorage, const char *zName){
   Fts5Config *pConfig = pStorage->pConfig;
-  int rc = sqlite3Fts5StorageSync(pStorage, 1);
+  int rc = sqlite3Fts5StorageSync(pStorage);
 
   fts5StorageRenameOne(pConfig, &rc, "data", zName);
   fts5StorageRenameOne(pConfig, &rc, "idx", zName);
@@ -199456,15 +201476,15 @@ static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow){
 /*
 ** Flush any data currently held in-memory to disk.
 */
-static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit){
+static int sqlite3Fts5StorageSync(Fts5Storage *p){
   int rc = SQLITE_OK;
   i64 iLastRowid = sqlite3_last_insert_rowid(p->pConfig->db);
   if( p->bTotalsValid ){
     rc = fts5StorageSaveTotals(p);
-    if( bCommit ) p->bTotalsValid = 0;
+    p->bTotalsValid = 0;
   }
   if( rc==SQLITE_OK ){
-    rc = sqlite3Fts5IndexSync(p->pIndex, bCommit);
+    rc = sqlite3Fts5IndexSync(p->pIndex);
   }
   sqlite3_set_last_insert_rowid(p->pConfig->db, iLastRowid);
   return rc;
@@ -202111,3 +204131,304 @@ static int sqlite3Fts5VocabInit(Fts5Global *pGlobal, sqlite3 *db){
 #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS5) */
 
 /************** End of fts5.c ************************************************/
+/************** Begin file stmt.c ********************************************/
+/*
+** 2017-05-31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+*************************************************************************
+**
+** This file demonstrates an eponymous virtual table that returns information
+** about all prepared statements for the database connection.
+**
+** Usage example:
+**
+**     .load ./stmt
+**     .mode line
+**     .header on
+**     SELECT * FROM stmt;
+*/
+#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB)
+#if !defined(SQLITEINT_H)
+/* #include "sqlite3ext.h" */
+#endif
+SQLITE_EXTENSION_INIT1
+/* #include <assert.h> */
+/* #include <string.h> */
+
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+
+/* stmt_vtab is a subclass of sqlite3_vtab which will
+** serve as the underlying representation of a stmt virtual table
+*/
+typedef struct stmt_vtab stmt_vtab;
+struct stmt_vtab {
+  sqlite3_vtab base;  /* Base class - must be first */
+  sqlite3 *db;        /* Database connection for this stmt vtab */
+};
+
+/* stmt_cursor is a subclass of sqlite3_vtab_cursor which will
+** serve as the underlying representation of a cursor that scans
+** over rows of the result
+*/
+typedef struct stmt_cursor stmt_cursor;
+struct stmt_cursor {
+  sqlite3_vtab_cursor base;  /* Base class - must be first */
+  sqlite3 *db;               /* Database connection for this cursor */
+  sqlite3_stmt *pStmt;       /* Statement cursor is currently pointing at */
+  sqlite3_int64 iRowid;      /* The rowid */
+};
+
+/*
+** The stmtConnect() method is invoked to create a new
+** stmt_vtab that describes the stmt virtual table.
+**
+** Think of this routine as the constructor for stmt_vtab objects.
+**
+** All this routine needs to do is:
+**
+**    (1) Allocate the stmt_vtab object and initialize all fields.
+**
+**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
+**        result set of queries against stmt will look like.
+*/
+static int stmtConnect(
+  sqlite3 *db,
+  void *pAux,
+  int argc, const char *const*argv,
+  sqlite3_vtab **ppVtab,
+  char **pzErr
+){
+  stmt_vtab *pNew;
+  int rc;
+
+/* Column numbers */
+#define STMT_COLUMN_SQL     0   /* SQL for the statement */
+#define STMT_COLUMN_NCOL    1   /* Number of result columns */
+#define STMT_COLUMN_RO      2   /* True if read-only */
+#define STMT_COLUMN_BUSY    3   /* True if currently busy */
+#define STMT_COLUMN_NSCAN   4   /* SQLITE_STMTSTATUS_FULLSCAN_STEP */
+#define STMT_COLUMN_NSORT   5   /* SQLITE_STMTSTATUS_SORT */
+#define STMT_COLUMN_NAIDX   6   /* SQLITE_STMTSTATUS_AUTOINDEX */
+#define STMT_COLUMN_NSTEP   7   /* SQLITE_STMTSTATUS_VM_STEP */
+#define STMT_COLUMN_REPREP  8   /* SQLITE_STMTSTATUS_REPREPARE */
+#define STMT_COLUMN_RUN     9   /* SQLITE_STMTSTATUS_RUN */
+#define STMT_COLUMN_MEM    10   /* SQLITE_STMTSTATUS_MEMUSED */
+
+
+  rc = sqlite3_declare_vtab(db,
+     "CREATE TABLE x(sql,ncol,ro,busy,nscan,nsort,naidx,nstep,"
+                    "reprep,run,mem)");
+  if( rc==SQLITE_OK ){
+    pNew = sqlite3_malloc( sizeof(*pNew) );
+    *ppVtab = (sqlite3_vtab*)pNew;
+    if( pNew==0 ) return SQLITE_NOMEM;
+    memset(pNew, 0, sizeof(*pNew));
+    pNew->db = db;
+  }
+  return rc;
+}
+
+/*
+** This method is the destructor for stmt_cursor objects.
+*/
+static int stmtDisconnect(sqlite3_vtab *pVtab){
+  sqlite3_free(pVtab);
+  return SQLITE_OK;
+}
+
+/*
+** Constructor for a new stmt_cursor object.
+*/
+static int stmtOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
+  stmt_cursor *pCur;
+  pCur = sqlite3_malloc( sizeof(*pCur) );
+  if( pCur==0 ) return SQLITE_NOMEM;
+  memset(pCur, 0, sizeof(*pCur));
+  pCur->db = ((stmt_vtab*)p)->db;
+  *ppCursor = &pCur->base;
+  return SQLITE_OK;
+}
+
+/*
+** Destructor for a stmt_cursor.
+*/
+static int stmtClose(sqlite3_vtab_cursor *cur){
+  sqlite3_free(cur);
+  return SQLITE_OK;
+}
+
+
+/*
+** Advance a stmt_cursor to its next row of output.
+*/
+static int stmtNext(sqlite3_vtab_cursor *cur){
+  stmt_cursor *pCur = (stmt_cursor*)cur;
+  pCur->iRowid++;
+  pCur->pStmt = sqlite3_next_stmt(pCur->db, pCur->pStmt);
+  return SQLITE_OK;
+}
+
+/*
+** Return values of columns for the row at which the stmt_cursor
+** is currently pointing.
+*/
+static int stmtColumn(
+  sqlite3_vtab_cursor *cur,   /* The cursor */
+  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
+  int i                       /* Which column to return */
+){
+  stmt_cursor *pCur = (stmt_cursor*)cur;
+  switch( i ){
+    case STMT_COLUMN_SQL: {
+      sqlite3_result_text(ctx, sqlite3_sql(pCur->pStmt), -1, SQLITE_TRANSIENT);
+      break;
+    }
+    case STMT_COLUMN_NCOL: {
+      sqlite3_result_int(ctx, sqlite3_column_count(pCur->pStmt));
+      break;
+    }
+    case STMT_COLUMN_RO: {
+      sqlite3_result_int(ctx, sqlite3_stmt_readonly(pCur->pStmt));
+      break;
+    }
+    case STMT_COLUMN_BUSY: {
+      sqlite3_result_int(ctx, sqlite3_stmt_busy(pCur->pStmt));
+      break;
+    }
+    case STMT_COLUMN_MEM: {
+      i = SQLITE_STMTSTATUS_MEMUSED + 
+            STMT_COLUMN_NSCAN - SQLITE_STMTSTATUS_FULLSCAN_STEP;
+      /* Fall thru */
+    }
+    case STMT_COLUMN_NSCAN:
+    case STMT_COLUMN_NSORT:
+    case STMT_COLUMN_NAIDX:
+    case STMT_COLUMN_NSTEP:
+    case STMT_COLUMN_REPREP:
+    case STMT_COLUMN_RUN: {
+      sqlite3_result_int(ctx, sqlite3_stmt_status(pCur->pStmt,
+                      i-STMT_COLUMN_NSCAN+SQLITE_STMTSTATUS_FULLSCAN_STEP, 0));
+      break;
+    }
+  }
+  return SQLITE_OK;
+}
+
+/*
+** Return the rowid for the current row.  In this implementation, the
+** rowid is the same as the output value.
+*/
+static int stmtRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
+  stmt_cursor *pCur = (stmt_cursor*)cur;
+  *pRowid = pCur->iRowid;
+  return SQLITE_OK;
+}
+
+/*
+** Return TRUE if the cursor has been moved off of the last
+** row of output.
+*/
+static int stmtEof(sqlite3_vtab_cursor *cur){
+  stmt_cursor *pCur = (stmt_cursor*)cur;
+  return pCur->pStmt==0;
+}
+
+/*
+** This method is called to "rewind" the stmt_cursor object back
+** to the first row of output.  This method is always called at least
+** once prior to any call to stmtColumn() or stmtRowid() or 
+** stmtEof().
+*/
+static int stmtFilter(
+  sqlite3_vtab_cursor *pVtabCursor, 
+  int idxNum, const char *idxStr,
+  int argc, sqlite3_value **argv
+){
+  stmt_cursor *pCur = (stmt_cursor *)pVtabCursor;
+  pCur->pStmt = 0;
+  pCur->iRowid = 0;
+  return stmtNext(pVtabCursor);
+}
+
+/*
+** SQLite will invoke this method one or more times while planning a query
+** that uses the stmt virtual table.  This routine needs to create
+** a query plan for each invocation and compute an estimated cost for that
+** plan.
+*/
+static int stmtBestIndex(
+  sqlite3_vtab *tab,
+  sqlite3_index_info *pIdxInfo
+){
+  pIdxInfo->estimatedCost = (double)500;
+  pIdxInfo->estimatedRows = 500;
+  return SQLITE_OK;
+}
+
+/*
+** This following structure defines all the methods for the 
+** stmt virtual table.
+*/
+static sqlite3_module stmtModule = {
+  0,                         /* iVersion */
+  0,                         /* xCreate */
+  stmtConnect,               /* xConnect */
+  stmtBestIndex,             /* xBestIndex */
+  stmtDisconnect,            /* xDisconnect */
+  0,                         /* xDestroy */
+  stmtOpen,                  /* xOpen - open a cursor */
+  stmtClose,                 /* xClose - close a cursor */
+  stmtFilter,                /* xFilter - configure scan constraints */
+  stmtNext,                  /* xNext - advance a cursor */
+  stmtEof,                   /* xEof - check for end of scan */
+  stmtColumn,                /* xColumn - read data */
+  stmtRowid,                 /* xRowid - read data */
+  0,                         /* xUpdate */
+  0,                         /* xBegin */
+  0,                         /* xSync */
+  0,                         /* xCommit */
+  0,                         /* xRollback */
+  0,                         /* xFindMethod */
+  0,                         /* xRename */
+  0,                         /* xSavepoint */
+  0,                         /* xRelease */
+  0,                         /* xRollbackTo */
+};
+
+#endif /* SQLITE_OMIT_VIRTUALTABLE */
+
+SQLITE_PRIVATE int sqlite3StmtVtabInit(sqlite3 *db){
+  int rc = SQLITE_OK;
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  rc = sqlite3_create_module(db, "sqlite_stmt", &stmtModule, 0);
+#endif
+  return rc;
+}
+
+#ifndef SQLITE_CORE
+#ifdef _WIN32
+__declspec(dllexport)
+#endif
+SQLITE_API int sqlite3_stmt_init(
+  sqlite3 *db, 
+  char **pzErrMsg, 
+  const sqlite3_api_routines *pApi
+){
+  int rc = SQLITE_OK;
+  SQLITE_EXTENSION_INIT2(pApi);
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  rc = sqlite3StmtVtabInit(db);
+#endif
+  return rc;
+}
+#endif /* SQLITE_CORE */
+#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB) */
+
+/************** End of stmt.c ************************************************/
diff --git a/TMessagesProj/jni/sqlite/sqlite3.h b/TMessagesProj/jni/sqlite/sqlite3.h
index 7e6afcbf6..41ccc2198 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.h
+++ b/TMessagesProj/jni/sqlite/sqlite3.h
@@ -1,5 +1,5 @@
 /*
-** 2001 September 15
+** 2001-09-15
 **
 ** The author disclaims copyright to this source code.  In place of
 ** a legal notice, here is a blessing:
@@ -121,9 +121,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.18.0"
-#define SQLITE_VERSION_NUMBER 3018000
-#define SQLITE_SOURCE_ID      "2017-03-28 18:48:43 424a0d380332858ee55bdebc4af3789f74e70a2b3ba1cf29d84b9b4bcf3e2e37"
+#define SQLITE_VERSION        "3.20.1"
+#define SQLITE_VERSION_NUMBER 3020001
+#define SQLITE_SOURCE_ID      "2017-08-24 16:21:36 8d3a7ea6c5690d6b7c3767558f4f01b511c55463e3f9e64506801fe9b74dce34"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -417,7 +417,7 @@ SQLITE_API int sqlite3_exec(
 */
 #define SQLITE_OK           0   /* Successful result */
 /* beginning-of-error-codes */
-#define SQLITE_ERROR        1   /* SQL error or missing database */
+#define SQLITE_ERROR        1   /* Generic error */
 #define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */
 #define SQLITE_PERM         3   /* Access permission denied */
 #define SQLITE_ABORT        4   /* Callback routine requested an abort */
@@ -432,7 +432,7 @@ SQLITE_API int sqlite3_exec(
 #define SQLITE_FULL        13   /* Insertion failed because database is full */
 #define SQLITE_CANTOPEN    14   /* Unable to open the database file */
 #define SQLITE_PROTOCOL    15   /* Database lock protocol error */
-#define SQLITE_EMPTY       16   /* Database is empty */
+#define SQLITE_EMPTY       16   /* Not used */
 #define SQLITE_SCHEMA      17   /* The database schema changed */
 #define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */
 #define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */
@@ -440,7 +440,7 @@ SQLITE_API int sqlite3_exec(
 #define SQLITE_MISUSE      21   /* Library used incorrectly */
 #define SQLITE_NOLFS       22   /* Uses OS features not supported on host */
 #define SQLITE_AUTH        23   /* Authorization denied */
-#define SQLITE_FORMAT      24   /* Auxiliary database format error */
+#define SQLITE_FORMAT      24   /* Not used */
 #define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */
 #define SQLITE_NOTADB      26   /* File opened that is not a database file */
 #define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */
@@ -857,7 +857,7 @@ struct sqlite3_io_methods {
 ** opcode allows these two values (10 retries and 25 milliseconds of delay)
 ** to be adjusted.  The values are changed for all database connections
 ** within the same process.  The argument is a pointer to an array of two
-** integers where the first integer i the new retry count and the second
+** integers where the first integer is the new retry count and the second
 ** integer is the delay.  If either integer is negative, then the setting
 ** is not changed but instead the prior value of that setting is written
 ** into the array entry, allowing the current retry settings to be
@@ -2007,6 +2007,17 @@ struct sqlite3_mem_methods {
 ** have been disabled - 0 if they are not disabled, 1 if they are.
 ** </dd>
 **
+** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>
+** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates
+** the [query planner stability guarantee] (QPSG).  When the QPSG is active,
+** a single SQL query statement will always use the same algorithm regardless
+** of values of [bound parameters].)^ The QPSG disables some query optimizations
+** that look at the values of bound parameters, which can make some queries
+** slower.  But the QPSG has the advantage of more predictable behavior.  With
+** the QPSG active, SQLite will always use the same query plan in the field as
+** was used during testing in the lab.
+** </dd>
+**
 ** </dl>
 */
 #define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */
@@ -2016,6 +2027,7 @@ struct sqlite3_mem_methods {
 #define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 /* int int* */
 #define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 /* int int* */
 #define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006 /* int int* */
+#define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */
 
 
 /*
@@ -2211,9 +2223,6 @@ SQLITE_API int sqlite3_total_changes(sqlite3*);
 ** ^A call to sqlite3_interrupt(D) that occurs when there are no running
 ** SQL statements is a no-op and has no effect on SQL statements
 ** that are started after the sqlite3_interrupt() call returns.
-**
-** If the database connection closes while [sqlite3_interrupt()]
-** is running then bad things will likely happen.
 */
 SQLITE_API void sqlite3_interrupt(sqlite3*);
 
@@ -2676,12 +2685,14 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 /*
 ** CAPI3REF: Compile-Time Authorization Callbacks
 ** METHOD: sqlite3
+** KEYWORDS: {authorizer callback}
 **
 ** ^This routine registers an authorizer callback with a particular
 ** [database connection], supplied in the first argument.
 ** ^The authorizer callback is invoked as SQL statements are being compiled
 ** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],
-** [sqlite3_prepare16()] and [sqlite3_prepare16_v2()].  ^At various
+** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],
+** and [sqlite3_prepare16_v3()].  ^At various
 ** points during the compilation process, as logic is being created
 ** to perform various actions, the authorizer callback is invoked to
 ** see if those actions are allowed.  ^The authorizer callback should
@@ -2703,8 +2714,10 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** parameter to the sqlite3_set_authorizer() interface. ^The second parameter
 ** to the callback is an integer [SQLITE_COPY | action code] that specifies
 ** the particular action to be authorized. ^The third through sixth parameters
-** to the callback are zero-terminated strings that contain additional
-** details about the action to be authorized.
+** to the callback are either NULL pointers or zero-terminated strings
+** that contain additional details about the action to be authorized.
+** Applications must always be prepared to encounter a NULL pointer in any
+** of the third through the sixth parameters of the authorization callback.
 **
 ** ^If the action code is [SQLITE_READ]
 ** and the callback returns [SQLITE_IGNORE] then the
@@ -2713,6 +2726,10 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]
 ** return can be used to deny an untrusted user access to individual
 ** columns of a table.
+** ^When a table is referenced by a [SELECT] but no column values are
+** extracted from that table (for example in a query like
+** "SELECT count(*) FROM tab") then the [SQLITE_READ] authorizer callback
+** is invoked once for that table with a column name that is an empty string.
 ** ^If the action code is [SQLITE_DELETE] and the callback returns
 ** [SQLITE_IGNORE] then the [DELETE] operation proceeds but the
 ** [truncate optimization] is disabled and all rows are deleted individually.
@@ -3464,6 +3481,29 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 #define SQLITE_LIMIT_TRIGGER_DEPTH            10
 #define SQLITE_LIMIT_WORKER_THREADS           11
 
+/*
+** CAPI3REF: Prepare Flags
+**
+** These constants define various flags that can be passed into
+** "prepFlags" parameter of the [sqlite3_prepare_v3()] and
+** [sqlite3_prepare16_v3()] interfaces.
+**
+** New flags may be added in future releases of SQLite.
+**
+** <dl>
+** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>
+** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner
+** that the prepared statement will be retained for a long time and
+** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]
+** and [sqlite3_prepare16_v3()] assume that the prepared statement will 
+** be used just once or at most a few times and then destroyed using
+** [sqlite3_finalize()] relatively soon. The current implementation acts
+** on this hint by avoiding the use of [lookaside memory] so as not to
+** deplete the limited store of lookaside memory. Future versions of
+** SQLite may act on this hint differently.
+** </dl>
+*/
+#define SQLITE_PREPARE_PERSISTENT              0x01
 
 /*
 ** CAPI3REF: Compiling An SQL Statement
@@ -3471,17 +3511,29 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** METHOD: sqlite3
 ** CONSTRUCTOR: sqlite3_stmt
 **
-** To execute an SQL query, it must first be compiled into a byte-code
-** program using one of these routines.
+** To execute an SQL statement, it must first be compiled into a byte-code
+** program using one of these routines.  Or, in other words, these routines
+** are constructors for the [prepared statement] object.
+**
+** The preferred routine to use is [sqlite3_prepare_v2()].  The
+** [sqlite3_prepare()] interface is legacy and should be avoided.
+** [sqlite3_prepare_v3()] has an extra "prepFlags" option that is used
+** for special purposes.
+**
+** The use of the UTF-8 interfaces is preferred, as SQLite currently
+** does all parsing using UTF-8.  The UTF-16 interfaces are provided
+** as a convenience.  The UTF-16 interfaces work by converting the
+** input text into UTF-8, then invoking the corresponding UTF-8 interface.
 **
 ** The first argument, "db", is a [database connection] obtained from a
 ** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or
 ** [sqlite3_open16()].  The database connection must not have been closed.
 **
 ** The second argument, "zSql", is the statement to be compiled, encoded
-** as either UTF-8 or UTF-16.  The sqlite3_prepare() and sqlite3_prepare_v2()
-** interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()
-** use UTF-16.
+** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),
+** and sqlite3_prepare_v3()
+** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),
+** and sqlite3_prepare16_v3() use UTF-16.
 **
 ** ^If the nByte argument is negative, then zSql is read up to the
 ** first zero terminator. ^If nByte is positive, then it is the
@@ -3508,10 +3560,11 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];
 ** otherwise an [error code] is returned.
 **
-** The sqlite3_prepare_v2() and sqlite3_prepare16_v2() interfaces are
-** recommended for all new programs. The two older interfaces are retained
-** for backwards compatibility, but their use is discouraged.
-** ^In the "v2" interfaces, the prepared statement
+** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),
+** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.
+** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())
+** are retained for backwards compatibility, but their use is discouraged.
+** ^In the "vX" interfaces, the prepared statement
 ** that is returned (the [sqlite3_stmt] object) contains a copy of the
 ** original SQL text. This causes the [sqlite3_step()] interface to
 ** behave differently in three ways:
@@ -3544,6 +3597,12 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** or [GLOB] operator or if the parameter is compared to an indexed column
 ** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
 ** </li>
+**
+** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
+** the extra prepFlags parameter, which is a bit array consisting of zero or
+** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The
+** sqlite3_prepare_v2() interface works exactly the same as
+** sqlite3_prepare_v3() with a zero prepFlags parameter.
 ** </ol>
 */
 SQLITE_API int sqlite3_prepare(
@@ -3560,6 +3619,14 @@ SQLITE_API int sqlite3_prepare_v2(
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
+SQLITE_API int sqlite3_prepare_v3(
+  sqlite3 *db,            /* Database handle */
+  const char *zSql,       /* SQL statement, UTF-8 encoded */
+  int nByte,              /* Maximum length of zSql in bytes. */
+  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
+  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
+  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
+);
 SQLITE_API int sqlite3_prepare16(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
@@ -3574,6 +3641,14 @@ SQLITE_API int sqlite3_prepare16_v2(
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const void **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
+SQLITE_API int sqlite3_prepare16_v3(
+  sqlite3 *db,            /* Database handle */
+  const void *zSql,       /* SQL statement, UTF-16 encoded */
+  int nByte,              /* Maximum length of zSql in bytes. */
+  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
+  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
+  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
+);
 
 /*
 ** CAPI3REF: Retrieving Statement SQL
@@ -3581,7 +3656,8 @@ SQLITE_API int sqlite3_prepare16_v2(
 **
 ** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8
 ** SQL text used to create [prepared statement] P if P was
-** created by either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].
+** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],
+** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
 ** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8
 ** string containing the SQL text of prepared statement P with
 ** [bound parameters] expanded.
@@ -3705,7 +3781,7 @@ SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
 ** The [sqlite3_value_blob | sqlite3_value_type()] family of
 ** interfaces require protected sqlite3_value objects.
 */
-typedef struct Mem sqlite3_value;
+typedef struct sqlite3_value sqlite3_value;
 
 /*
 ** CAPI3REF: SQL Function Context Object
@@ -3807,6 +3883,15 @@ typedef struct sqlite3_context sqlite3_context;
 ** [sqlite3_blob_open | incremental BLOB I/O] routines.
 ** ^A negative value for the zeroblob results in a zero-length BLOB.
 **
+** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in
+** [prepared statement] S to have an SQL value of NULL, but to also be
+** associated with the pointer P of type T.  ^D is either a NULL pointer or
+** a pointer to a destructor function for P. ^SQLite will invoke the
+** destructor D with a single argument of P when it is finished using
+** P.  The T parameter should be a static string, preferably a string
+** literal. The sqlite3_bind_pointer() routine is part of the
+** [pointer passing interface] added for SQLite 3.20.0.
+**
 ** ^If any of the sqlite3_bind_*() routines are called with a NULL pointer
 ** for the [prepared statement] or with a prepared statement for which
 ** [sqlite3_step()] has been called more recently than [sqlite3_reset()],
@@ -3840,6 +3925,7 @@ SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)
 SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                          void(*)(void*), unsigned char encoding);
 SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
+SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
 SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
 
@@ -3883,8 +3969,8 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
 ** ^If the value N is out of range or if the N-th parameter is
 ** nameless, then NULL is returned.  ^The returned string is
 ** always in UTF-8 encoding even if the named parameter was
-** originally specified as UTF-16 in [sqlite3_prepare16()] or
-** [sqlite3_prepare16_v2()].
+** originally specified as UTF-16 in [sqlite3_prepare16()],
+** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
@@ -3901,7 +3987,8 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 ** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero
 ** is returned if no matching parameter is found.  ^The parameter
 ** name must be given in UTF-8 even if the original statement
-** was prepared from UTF-16 text using [sqlite3_prepare16_v2()].
+** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] or
+** [sqlite3_prepare16_v3()].
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
@@ -4055,16 +4142,18 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** CAPI3REF: Evaluate An SQL Statement
 ** METHOD: sqlite3_stmt
 **
-** After a [prepared statement] has been prepared using either
-** [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy
+** After a [prepared statement] has been prepared using any of
+** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],
+** or [sqlite3_prepare16_v3()] or one of the legacy
 ** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function
 ** must be called one or more times to evaluate the statement.
 **
 ** The details of the behavior of the sqlite3_step() interface depend
-** on whether the statement was prepared using the newer "v2" interface
-** [sqlite3_prepare_v2()] and [sqlite3_prepare16_v2()] or the older legacy
-** interface [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
-** new "v2" interface is recommended for new applications but the legacy
+** on whether the statement was prepared using the newer "vX" interfaces
+** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],
+** [sqlite3_prepare16_v2()] or the older legacy
+** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
+** new "vX" interface is recommended for new applications but the legacy
 ** interface will continue to be supported.
 **
 ** ^In the legacy interface, the return value will be either [SQLITE_BUSY],
@@ -4110,7 +4199,7 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** other than [SQLITE_ROW] before any subsequent invocation of
 ** sqlite3_step().  Failure to reset the prepared statement using 
 ** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from
-** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],
+** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1]),
 ** sqlite3_step() began
 ** calling [sqlite3_reset()] automatically in this circumstance rather
 ** than returning [SQLITE_MISUSE].  This is not considered a compatibility
@@ -4125,10 +4214,11 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** specific [error codes] that better describes the error.
 ** We admit that this is a goofy design.  The problem has been fixed
 ** with the "v2" interface.  If you prepare all of your SQL statements
-** using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] instead
+** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]
+** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead
 ** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,
 ** then the more specific [error codes] are returned directly
-** by sqlite3_step().  The use of the "v2" interface is recommended.
+** by sqlite3_step().  The use of the "vX" interfaces is recommended.
 */
 SQLITE_API int sqlite3_step(sqlite3_stmt*);
 
@@ -4190,6 +4280,28 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** KEYWORDS: {column access functions}
 ** METHOD: sqlite3_stmt
 **
+** <b>Summary:</b>
+** <blockquote><table border=0 cellpadding=0 cellspacing=0>
+** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB result
+** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL result
+** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER result
+** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER result
+** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT result
+** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT result
+** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an 
+** [sqlite3_value|unprotected sqlite3_value] object.
+** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
+** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOB
+** or a UTF-8 TEXT result in bytes
+** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
+** TEXT in bytes
+** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Default
+** datatype of the result
+** </table></blockquote>
+**
+** <b>Details:</b>
+**
 ** ^These routines return information about a single column of the current
 ** result row of a query.  ^In every case the first argument is a pointer
 ** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]
@@ -4211,16 +4323,29 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** are called from a different thread while any of these routines
 ** are pending, then the results are undefined.
 **
+** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)
+** each return the value of a result column in a specific data format.  If
+** the result column is not initially in the requested format (for example,
+** if the query returns an integer but the sqlite3_column_text() interface
+** is used to extract the value) then an automatic type conversion is performed.
+**
 ** ^The sqlite3_column_type() routine returns the
 ** [SQLITE_INTEGER | datatype code] for the initial data type
 ** of the result column.  ^The returned value is one of [SQLITE_INTEGER],
-** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].  The value
-** returned by sqlite3_column_type() is only meaningful if no type
-** conversions have occurred as described below.  After a type conversion,
-** the value returned by sqlite3_column_type() is undefined.  Future
+** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].
+** The return value of sqlite3_column_type() can be used to decide which
+** of the first six interface should be used to extract the column value.
+** The value returned by sqlite3_column_type() is only meaningful if no
+** automatic type conversions have occurred for the value in question.  
+** After a type conversion, the result of calling sqlite3_column_type()
+** is undefined, though harmless.  Future
 ** versions of SQLite may change the behavior of sqlite3_column_type()
 ** following a type conversion.
 **
+** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()
+** or sqlite3_column_bytes16() interfaces can be used to determine the size
+** of that BLOB or string.
+**
 ** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()
 ** routine returns the number of bytes in that BLOB or string.
 ** ^If the result is a UTF-16 string, then sqlite3_column_bytes() converts
@@ -4257,9 +4382,13 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** [sqlite3_column_value()] is used in any other way, including calls
 ** to routines like [sqlite3_value_int()], [sqlite3_value_text()],
 ** or [sqlite3_value_bytes()], the behavior is not threadsafe.
+** Hence, the sqlite3_column_value() interface
+** is normally only useful within the implementation of 
+** [application-defined SQL functions] or [virtual tables], not within
+** top-level application code.
 **
-** These routines attempt to convert the value where appropriate.  ^For
-** example, if the internal representation is FLOAT and a text result
+** The these routines may attempt to convert the datatype of the result.
+** ^For example, if the internal representation is FLOAT and a text result
 ** is requested, [sqlite3_snprintf()] is used internally to perform the
 ** conversion automatically.  ^(The following table details the conversions
 ** that are applied:
@@ -4331,7 +4460,7 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** ^The pointers returned are valid until a type conversion occurs as
 ** described above, or until [sqlite3_step()] or [sqlite3_reset()] or
 ** [sqlite3_finalize()] is called.  ^The memory space used to hold strings
-** and BLOBs is freed automatically.  Do <em>not</em> pass the pointers returned
+** and BLOBs is freed automatically.  Do not pass the pointers returned
 ** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into
 ** [sqlite3_free()].
 **
@@ -4342,15 +4471,15 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** [SQLITE_NOMEM].)^
 */
 SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
 SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
 SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
 SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
 SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
 SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
 SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
+SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
 
 /*
 ** CAPI3REF: Destroy A Prepared Statement Object
@@ -4584,21 +4713,40 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** CAPI3REF: Obtaining SQL Values
 ** METHOD: sqlite3_value
 **
-** The C-language implementation of SQL functions and aggregates uses
-** this set of interface routines to access the parameter values on
-** the function or aggregate.  
-**
-** The xFunc (for scalar functions) or xStep (for aggregates) parameters
-** to [sqlite3_create_function()] and [sqlite3_create_function16()]
-** define callbacks that implement the SQL functions and aggregates.
-** The 3rd parameter to these callbacks is an array of pointers to
-** [protected sqlite3_value] objects.  There is one [sqlite3_value] object for
-** each parameter to the SQL function.  These routines are used to
-** extract values from the [sqlite3_value] objects.
+** <b>Summary:</b>
+** <blockquote><table border=0 cellpadding=0 cellspacing=0>
+** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB value
+** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL value
+** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER value
+** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER value
+** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer value
+** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT value
+** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in
+** the native byteorder
+** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT value
+** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT value
+** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
+** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOB
+** or a UTF-8 TEXT in bytes
+** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
+** TEXT in bytes
+** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default
+** datatype of the value
+** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>
+** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the value
+** </table></blockquote>
+**
+** <b>Details:</b>
+**
+** These routines extract type, size, and content information from
+** [protected sqlite3_value] objects.  Protected sqlite3_value objects
+** are used to pass parameter information into implementation of
+** [application-defined SQL functions] and [virtual tables].
 **
 ** These routines work only with [protected sqlite3_value] objects.
 ** Any attempt to use these routines on an [unprotected sqlite3_value]
-** object results in undefined behavior.
+** is not threadsafe.
 **
 ** ^These routines work just like the corresponding [column access functions]
 ** except that these routines take a single [protected sqlite3_value] object
@@ -4609,6 +4757,24 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** sqlite3_value_text16be() and sqlite3_value_text16le() interfaces
 ** extract UTF-16 strings as big-endian and little-endian respectively.
 **
+** ^If [sqlite3_value] object V was initialized 
+** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]
+** and if X and Y are strings that compare equal according to strcmp(X,Y),
+** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,
+** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() 
+** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
+**
+** ^(The sqlite3_value_type(V) interface returns the
+** [SQLITE_INTEGER | datatype code] for the initial datatype of the
+** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],
+** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^
+** Other interfaces might change the datatype for an sqlite3_value object.
+** For example, if the datatype is initially SQLITE_INTEGER and
+** sqlite3_value_text(V) is called to extract a text value for that
+** integer, then subsequent calls to sqlite3_value_type(V) might return
+** SQLITE_TEXT.  Whether or not a persistent internal datatype conversion
+** occurs is undefined and may change from one release of SQLite to the next.
+**
 ** ^(The sqlite3_value_numeric_type() interface attempts to apply
 ** numeric affinity to the value.  This means that an attempt is
 ** made to convert the value to an integer or floating point.  If
@@ -4627,15 +4793,16 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** the SQL function that supplied the [sqlite3_value*] parameters.
 */
 SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
 SQLITE_API double sqlite3_value_double(sqlite3_value*);
 SQLITE_API int sqlite3_value_int(sqlite3_value*);
 SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
+SQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);
 SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
 SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
+SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
+SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
 SQLITE_API int sqlite3_value_type(sqlite3_value*);
 SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 
@@ -4648,10 +4815,6 @@ SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 ** information can be used to pass a limited amount of context from
 ** one SQL function to another.  Use the [sqlite3_result_subtype()]
 ** routine to set the subtype for the return value of an SQL function.
-**
-** SQLite makes no use of subtype itself.  It merely passes the subtype
-** from the result of one [application-defined SQL function] into the
-** input of another.
 */
 SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);
 
@@ -4759,10 +4922,11 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** the compiled regular expression can be reused on multiple
 ** invocations of the same function.
 **
-** ^The sqlite3_get_auxdata() interface returns a pointer to the metadata
-** associated by the sqlite3_set_auxdata() function with the Nth argument
-** value to the application-defined function. ^If there is no metadata
-** associated with the function argument, this sqlite3_get_auxdata() interface
+** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata
+** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument
+** value to the application-defined function.  ^N is zero for the left-most
+** function argument.  ^If there is no metadata
+** associated with the function argument, the sqlite3_get_auxdata(C,N) interface
 ** returns a NULL pointer.
 **
 ** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th
@@ -4793,6 +4957,10 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** function parameters that are compile-time constants, including literal
 ** values and [parameters] and expressions composed from the same.)^
 **
+** The value of the N parameter to these interfaces should be non-negative.
+** Future enhancements may make use of negative N values to define new
+** kinds of function caching behavior.
+**
 ** These routines must be called from the same thread in which
 ** the SQL function is running.
 */
@@ -4916,7 +5084,7 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** when it has finished using that result.
 ** ^If the 4th parameter to the sqlite3_result_text* interfaces
 ** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT
-** then SQLite makes a copy of the result into space obtained from
+** then SQLite makes a copy of the result into space obtained
 ** from [sqlite3_malloc()] before it returns.
 **
 ** ^The sqlite3_result_value() interface sets the result of
@@ -4929,6 +5097,17 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** [unprotected sqlite3_value] object is required, so either
 ** kind of [sqlite3_value] object can be used with this interface.
 **
+** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to an
+** SQL NULL value, just like [sqlite3_result_null(C)], except that it
+** also associates the host-language pointer P or type T with that 
+** NULL value such that the pointer can be retrieved within an
+** [application-defined SQL function] using [sqlite3_value_pointer()].
+** ^If the D parameter is not NULL, then it is a pointer to a destructor
+** for the P parameter.  ^SQLite invokes D with P as its only argument
+** when SQLite is finished with P.  The T parameter should be a static
+** string and preferably a string literal. The sqlite3_result_pointer()
+** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
+**
 ** If these routines are called from within the different thread
 ** than the one containing the application-defined function that received
 ** the [sqlite3_context] pointer, the results are undefined.
@@ -4952,6 +5131,7 @@ SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*
 SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
 SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
 SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
+SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));
 SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
 SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
 
@@ -5611,7 +5791,9 @@ SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
 ** ^If the column-name parameter to sqlite3_table_column_metadata() is a
 ** NULL pointer, then this routine simply checks for the existence of the
 ** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it
-** does not.
+** does not.  If the table name parameter T in a call to
+** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is
+** undefined behavior.
 **
 ** ^The column is identified by the second, third and fourth parameters to
 ** this function. ^(The second parameter is either the name of the database
@@ -7124,6 +7306,24 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 ** used as a proxy for the total work done by the prepared statement.
 ** If the number of virtual machine operations exceeds 2147483647
 ** then the value returned by this statement status code is undefined.
+**
+** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>
+** <dd>^This is the number of times that the prepare statement has been
+** automatically regenerated due to schema changes or change to 
+** [bound parameters] that might affect the query plan.
+**
+** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>
+** <dd>^This is the number of times that the prepared statement has
+** been run.  A single "run" for the purposes of this counter is one
+** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].
+** The counter is incremented on the first [sqlite3_step()] call of each
+** cycle.
+**
+** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>
+** <dd>^This is the approximate number of bytes of heap memory
+** used to store the prepared statement.  ^This value is not actually
+** a counter, and so the resetFlg parameter to sqlite3_stmt_status()
+** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.
 ** </dd>
 ** </dl>
 */
@@ -7131,6 +7331,9 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 #define SQLITE_STMTSTATUS_SORT              2
 #define SQLITE_STMTSTATUS_AUTOINDEX         3
 #define SQLITE_STMTSTATUS_VM_STEP           4
+#define SQLITE_STMTSTATUS_REPREPARE         5
+#define SQLITE_STMTSTATUS_RUN               6
+#define SQLITE_STMTSTATUS_MEMUSED           99
 
 /*
 ** CAPI3REF: Custom Page Cache Object
@@ -9387,7 +9590,7 @@ typedef struct sqlite3_changegroup sqlite3_changegroup;
 ** sqlite3changegroup_output() functions, also available are the streaming
 ** versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().
 */
-int sqlite3changegroup_new(sqlite3_changegroup **pp);
+SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp);
 
 /*
 ** CAPI3REF: Add A Changeset To A Changegroup
@@ -9464,7 +9667,7 @@ int sqlite3changegroup_new(sqlite3_changegroup **pp);
 **
 ** If no error occurs, SQLITE_OK is returned.
 */
-int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
+SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
 
 /*
 ** CAPI3REF: Obtain A Composite Changeset From A Changegroup
@@ -9490,7 +9693,7 @@ int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
 ** responsibility of the caller to eventually free the buffer using a
 ** call to sqlite3_free().
 */
-int sqlite3changegroup_output(
+SQLITE_API int sqlite3changegroup_output(
   sqlite3_changegroup*,
   int *pnData,                    /* OUT: Size of output buffer in bytes */
   void **ppData                   /* OUT: Pointer to output buffer */
@@ -9499,7 +9702,7 @@ int sqlite3changegroup_output(
 /*
 ** CAPI3REF: Delete A Changegroup Object
 */
-void sqlite3changegroup_delete(sqlite3_changegroup*);
+SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);
 
 /*
 ** CAPI3REF: Apply A Changeset To A Database
@@ -9888,11 +10091,11 @@ SQLITE_API int sqlite3session_patchset_strm(
   int (*xOutput)(void *pOut, const void *pData, int nData),
   void *pOut
 );
-int sqlite3changegroup_add_strm(sqlite3_changegroup*, 
+SQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*, 
     int (*xInput)(void *pIn, void *pData, int *pnData),
     void *pIn
 );
-int sqlite3changegroup_output_strm(sqlite3_changegroup*,
+SQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,
     int (*xOutput)(void *pOut, const void *pData, int nData), 
     void *pOut
 );
diff --git a/TMessagesProj/jni/tgnet/ApiScheme.cpp b/TMessagesProj/jni/tgnet/ApiScheme.cpp
index 0e2b47c72..2ec339007 100644
--- a/TMessagesProj/jni/tgnet/ApiScheme.cpp
+++ b/TMessagesProj/jni/tgnet/ApiScheme.cpp
@@ -50,6 +50,11 @@ TL_dcOption *TL_dcOption::TLdeserialize(NativeByteBuffer *stream, uint32_t const
 
 void TL_dcOption::readParams(NativeByteBuffer *stream, bool &error) {
     flags = stream->readInt32(&error);
+    ipv6 = (flags & 1) != 0;
+    media_only = (flags & 2) != 0;
+    tcpo_only = (flags & 4) != 0;
+    cdn = (flags & 8) != 0;
+    isStatic = (flags & 16) != 0;
     id = stream->readInt32(&error);
     ip_address = stream->readString(&error);
     port = stream->readInt32(&error);
@@ -57,12 +62,89 @@ void TL_dcOption::readParams(NativeByteBuffer *stream, bool &error) {
 
 void TL_dcOption::serializeToStream(NativeByteBuffer *stream) {
     stream->writeInt32(constructor);
+    flags = ipv6 ? (flags | 1) : (flags &~ 1);
+    flags = media_only ? (flags | 2) : (flags &~ 2);
+    flags = tcpo_only ? (flags | 4) : (flags &~ 4);
+    flags = cdn ? (flags | 8) : (flags &~ 8);
+    flags = isStatic ? (flags | 16) : (flags &~ 16);
     stream->writeInt32(flags);
     stream->writeInt32(id);
     stream->writeString(ip_address);
     stream->writeInt32(port);
 }
 
+TL_cdnPublicKey *TL_cdnPublicKey::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
+    if (TL_cdnPublicKey::constructor != constructor) {
+        error = true;
+        DEBUG_E("can't parse magic %x in TL_cdnPublicKey", constructor);
+        return nullptr;
+    }
+    TL_cdnPublicKey *result = new TL_cdnPublicKey();
+    result->readParams(stream, error);
+    return result;
+}
+
+void TL_cdnPublicKey::readParams(NativeByteBuffer *stream, bool &error) {
+    dc_id = stream->readInt32(&error);
+    public_key = stream->readString(&error);
+}
+
+void TL_cdnPublicKey::serializeToStream(NativeByteBuffer *stream) {
+    stream->writeInt32(constructor);
+    stream->writeInt32(dc_id);
+    stream->writeString(public_key);
+}
+
+TL_cdnConfig *TL_cdnConfig::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
+    if (TL_cdnConfig::constructor != constructor) {
+        error = true;
+        DEBUG_E("can't parse magic %x in TL_cdnConfig", constructor);
+        return nullptr;
+    }
+    TL_cdnConfig *result = new TL_cdnConfig();
+    result->readParams(stream, error);
+    return result;
+}
+
+void TL_cdnConfig::readParams(NativeByteBuffer *stream, bool &error) {
+    int magic = stream->readInt32(&error);
+    if (magic != 0x1cb5c415) {
+        error = true;
+        DEBUG_E("wrong Vector magic, got %x", magic);
+        return;
+    }
+    int count = stream->readInt32(&error);
+    for (int a = 0; a < count; a++) {
+        TL_cdnPublicKey *object = TL_cdnPublicKey::TLdeserialize(stream, stream->readUint32(&error), error);
+        if (object == nullptr) {
+            return;
+        }
+        public_keys.push_back(std::unique_ptr<TL_cdnPublicKey>(object));
+    }
+}
+
+void TL_cdnConfig::serializeToStream(NativeByteBuffer *stream) {
+    stream->writeInt32(constructor);
+    stream->writeInt32(0x1cb5c415);
+    int count = public_keys.size();
+    stream->writeInt32(count);
+    for (int a = 0; a < count; a++) {
+        public_keys[a]->serializeToStream(stream);
+    }
+}
+
+bool TL_help_getCdnConfig::isNeedLayer() {
+    return true;
+}
+
+TLObject *TL_help_getCdnConfig::deserializeResponse(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
+    return TL_cdnConfig::TLdeserialize(stream, constructor, error);
+}
+
+void TL_help_getCdnConfig::serializeToStream(NativeByteBuffer *stream) {
+    stream->writeInt32(constructor);
+}
+
 TL_disabledFeature *TL_disabledFeature::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
     if (TL_disabledFeature::constructor != constructor) {
         error = true;
@@ -132,6 +214,8 @@ void TL_config::readParams(NativeByteBuffer *stream, bool &error) {
     edit_time_limit = stream->readInt32(&error);
     rating_e_decay = stream->readInt32(&error);
     stickers_recent_limit = stream->readInt32(&error);
+    stickers_faved_limit = stream->readInt32(&error);
+    channels_read_media_period = stream->readInt32(&error);
     if ((flags & 1) != 0) {
         tmp_sessions = stream->readInt32(&error);
     }
@@ -141,6 +225,12 @@ void TL_config::readParams(NativeByteBuffer *stream, bool &error) {
     call_connect_timeout_ms = stream->readInt32(&error);
     call_packet_timeout_ms = stream->readInt32(&error);
     me_url_prefix = stream->readString(&error);
+    if ((flags & 4) != 0) {
+        suggested_lang_code = stream->readString(&error);
+    }
+    if ((flags & 4) != 0) {
+        lang_pack_version = stream->readInt32(&error);
+    }
     magic = stream->readUint32(&error);
     if (magic != 0x1cb5c415) {
         error = true;
@@ -186,6 +276,8 @@ void TL_config::serializeToStream(NativeByteBuffer *stream) {
     stream->writeInt32(edit_time_limit);
     stream->writeInt32(rating_e_decay);
     stream->writeInt32(stickers_recent_limit);
+    stream->writeInt32(stickers_faved_limit);
+    stream->writeInt32(channels_read_media_period);
     if ((flags & 1) != 0) {
         stream->writeInt32(tmp_sessions);
     }
@@ -195,6 +287,12 @@ void TL_config::serializeToStream(NativeByteBuffer *stream) {
     stream->writeInt32(call_connect_timeout_ms);
     stream->writeInt32(call_packet_timeout_ms);
     stream->writeString(me_url_prefix);
+    if ((flags & 4) != 0) {
+        stream->writeString(suggested_lang_code);
+    }
+    if ((flags & 4) != 0) {
+        stream->writeInt32(lang_pack_version);
+    }
     stream->writeInt32(0x1cb5c415);
     count = (uint32_t) disabled_features.size();
     stream->writeInt32(count);
@@ -235,7 +333,7 @@ User *User::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &
         case 0x200250ba:
             result = new TL_userEmpty();
             break;
-        case 0xd10d979a:
+        case 0x2e13f4c3:
             result = new TL_user();
             break;
         default:
@@ -289,6 +387,9 @@ void TL_user::readParams(NativeByteBuffer *stream, bool &error) {
     if ((flags & 524288) != 0) {
         bot_inline_placeholder = stream->readString(&error);
     }
+    if ((flags & 4194304) != 0) {
+        lang_code = stream->readString(&error);
+    }
 }
 
 void TL_user::serializeToStream(NativeByteBuffer *stream) {
@@ -325,6 +426,9 @@ void TL_user::serializeToStream(NativeByteBuffer *stream) {
     if ((flags & 524288) != 0) {
         stream->writeString(bot_inline_placeholder);
     }
+    if ((flags & 4194304) != 0) {
+        stream->writeString(lang_code);
+    }
 }
 
 TL_auth_authorization *TL_auth_authorization::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
@@ -640,7 +744,7 @@ TL_upload_file::~TL_upload_file() {
 }
 
 void TL_upload_file::readParams(NativeByteBuffer *stream, bool &error) {
-    type = std::unique_ptr<storage_FileType>(storage_FileType::TLdeserialize(stream, stream->readInt32(&error), error));
+    type = std::unique_ptr<storage_FileType>(storage_FileType::TLdeserialize(stream, stream->readUint32(&error), error));
     mtime = stream->readInt32(&error);
     bytes = stream->readByteBuffer(true, &error);
 }
diff --git a/TMessagesProj/jni/tgnet/ApiScheme.h b/TMessagesProj/jni/tgnet/ApiScheme.h
index 66c82baf1..a0fb93df3 100644
--- a/TMessagesProj/jni/tgnet/ApiScheme.h
+++ b/TMessagesProj/jni/tgnet/ApiScheme.h
@@ -45,6 +45,11 @@ class TL_dcOption : public TLObject {
     static const uint32_t constructor = 0x5d8c6cc;
 
     int32_t flags;
+    bool ipv6;
+    bool media_only;
+    bool tcpo_only;
+    bool cdn;
+    bool isStatic;
     int32_t id;
     std::string ip_address;
     int32_t port;
@@ -54,6 +59,41 @@ class TL_dcOption : public TLObject {
     void serializeToStream(NativeByteBuffer *stream);
 };
 
+class TL_cdnPublicKey : public TLObject {
+
+public:
+    static const uint32_t constructor = 0xc982eaba;
+
+    int32_t dc_id;
+    std::string public_key;
+
+    static TL_cdnPublicKey *TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error);
+    void readParams(NativeByteBuffer *stream, bool &error);
+    void serializeToStream(NativeByteBuffer *stream);
+};
+
+class TL_cdnConfig : public TLObject {
+
+public:
+    static const uint32_t constructor = 0x5725e40a;
+
+    std::vector<std::unique_ptr<TL_cdnPublicKey>> public_keys;
+
+    static TL_cdnConfig *TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error);
+    void readParams(NativeByteBuffer *stream, bool &error);
+    void serializeToStream(NativeByteBuffer *stream);
+};
+
+class TL_help_getCdnConfig : public TLObject {
+
+public:
+    static const uint32_t constructor = 0x52029342;
+
+    bool isNeedLayer();
+    TLObject *deserializeResponse(NativeByteBuffer *stream, uint32_t constructor, bool &error);
+    void serializeToStream(NativeByteBuffer *stream);
+};
+
 class TL_disabledFeature : public TLObject {
 
 public:
@@ -70,7 +110,7 @@ class TL_disabledFeature : public TLObject {
 class TL_config : public TLObject {
 
 public:
-    static const uint32_t constructor = 0xcb601684;
+    static const uint32_t constructor = 0x9c840964;
 
     int32_t flags;
     int32_t date;
@@ -94,6 +134,8 @@ class TL_config : public TLObject {
     int32_t edit_time_limit;
     int32_t rating_e_decay;
     int32_t stickers_recent_limit;
+    int32_t stickers_faved_limit;
+    int32_t channels_read_media_period;
     int32_t tmp_sessions;
     int32_t pinned_dialogs_count_max;
     int32_t call_receive_timeout_ms;
@@ -101,6 +143,8 @@ class TL_config : public TLObject {
     int32_t call_connect_timeout_ms;
     int32_t call_packet_timeout_ms;
     std::string me_url_prefix;
+    std::string suggested_lang_code;
+    int32_t lang_pack_version;
     std::vector<std::unique_ptr<TL_disabledFeature>> disabled_features;
 
     static TL_config *TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error);
@@ -271,6 +315,7 @@ class User : public TLObject {
     int32_t bot_info_version;
     std::string restriction_reason;
     std::string bot_inline_placeholder;
+    std::string lang_code;
 
     static User *TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error);
 };
@@ -287,7 +332,7 @@ class TL_userEmpty : public User {
 class TL_user : public User {
 
 public:
-    static const uint32_t constructor = 0xd10d979a;
+    static const uint32_t constructor = 0x2e13f4c3;
 
     void readParams(NativeByteBuffer *stream, bool &error);
     void serializeToStream(NativeByteBuffer *stream);
diff --git a/TMessagesProj/jni/tgnet/ByteStream.h b/TMessagesProj/jni/tgnet/ByteStream.h
index 56c3e4401..e417c6395 100644
--- a/TMessagesProj/jni/tgnet/ByteStream.h
+++ b/TMessagesProj/jni/tgnet/ByteStream.h
@@ -20,6 +20,7 @@ class ByteStream {
     ByteStream();
     ~ByteStream();
     void append(NativeByteBuffer *buffer);
+    void append(uint8_t *buffer, uint32_t size);
     bool hasData();
     void get(NativeByteBuffer *dst);
     void discard(uint32_t count);
diff --git a/TMessagesProj/jni/tgnet/Connection.cpp b/TMessagesProj/jni/tgnet/Connection.cpp
index 3848d29a3..ea7b73be2 100644
--- a/TMessagesProj/jni/tgnet/Connection.cpp
+++ b/TMessagesProj/jni/tgnet/Connection.cpp
@@ -38,14 +38,18 @@ Connection::~Connection() {
 }
 
 void Connection::suspendConnection() {
+    suspendConnection(false);
+}
+
+void Connection::suspendConnection(bool idle) {
     reconnectTimer->stop();
     if (connectionState == TcpConnectionStageIdle || connectionState == TcpConnectionStageSuspended) {
         return;
     }
     DEBUG_D("connection(%p, dc%u, type %d) suspend", this, currentDatacenter->getDatacenterId(), connectionType);
-    connectionState = TcpConnectionStageSuspended;
+    connectionState = idle ? TcpConnectionStageIdle : TcpConnectionStageSuspended;
     dropConnection();
-    ConnectionsManager::getInstance().onConnectionClosed(this);
+    ConnectionsManager::getInstance().onConnectionClosed(this, 0);
     firstPacketSent = false;
     if (restOfTheData != nullptr) {
         restOfTheData->reuse();
@@ -216,33 +220,36 @@ void Connection::onReceivedData(NativeByteBuffer *buffer) {
 
 void Connection::connect() {
     if (!ConnectionsManager::getInstance().isNetworkAvailable()) {
-        ConnectionsManager::getInstance().onConnectionClosed(this);
+        ConnectionsManager::getInstance().onConnectionClosed(this, 0);
         return;
     }
     if ((connectionState == TcpConnectionStageConnected || connectionState == TcpConnectionStageConnecting)) {
         return;
     }
     connectionState = TcpConnectionStageConnecting;
-    bool ipv6 = ConnectionsManager::getInstance().isIpv6Enabled();
+    uint32_t ipv6 = ConnectionsManager::getInstance().isIpv6Enabled() ? TcpAddressFlagIpv6 : 0;
+    uint32_t isStatic = !ConnectionsManager::getInstance().proxyAddress.empty() ? TcpAddressFlagStatic : 0;
     if (connectionType == ConnectionTypeDownload) {
-        currentAddressFlags = 2;
-        hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | (ipv6 ? 1 : 0));
+        currentAddressFlags = TcpAddressFlagDownload | isStatic;
+        hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | ipv6);
         if (hostAddress.empty()) {
-            currentAddressFlags = 0;
-            hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | (ipv6 ? 1 : 0));
+            currentAddressFlags = isStatic;
+            hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | ipv6);
         }
         if (hostAddress.empty() && ipv6) {
-            currentAddressFlags = 2;
+            ipv6 = 0;
+            currentAddressFlags = TcpAddressFlagDownload | isStatic;
             hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags);
             if (hostAddress.empty()) {
-                currentAddressFlags = 0;
+                currentAddressFlags = isStatic;
                 hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags);
             }
         }
     } else {
-        currentAddressFlags = 0;
-        hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | (ipv6 ? 1 : 0));
-        if (ipv6 && hostAddress.empty()) {
+        currentAddressFlags = isStatic;
+        hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags | ipv6);
+        if (hostAddress.empty() && ipv6) {
+            ipv6 = 0;
             hostAddress = currentDatacenter->getCurrentAddress(currentAddressFlags);
         }
     }
@@ -259,7 +266,7 @@ void Connection::connect() {
     lastPacketLength = 0;
     wasConnected = false;
     hasSomeDataSinceLastConnect = false;
-    openConnection(hostAddress, hostPort, ipv6, ConnectionsManager::getInstance().currentNetworkType);
+    openConnection(hostAddress, hostPort, ipv6 != 0, ConnectionsManager::getInstance().currentNetworkType);
     if (connectionType == ConnectionTypePush) {
         if (isTryingNextPort) {
             setTimeout(20);
@@ -273,18 +280,26 @@ void Connection::connect() {
             if (connectionType == ConnectionTypeUpload) {
                 setTimeout(25);
             } else {
-                setTimeout(15);
+                setTimeout(12);
             }
         }
     }
 }
 
 void Connection::reconnect() {
-    suspendConnection();
-    connectionState = TcpConnectionStageReconnecting;
+    forceNextPort = true;
+    suspendConnection(true);
     connect();
 }
 
+bool Connection::hasUsefullData() {
+    return usefullData;
+}
+
+void Connection::setHasUsefullData() {
+    usefullData = true;
+}
+
 void Connection::sendData(NativeByteBuffer *buff, bool reportAck) {
     if (buff == nullptr) {
         return;
@@ -379,7 +394,7 @@ void Connection::sendData(NativeByteBuffer *buff, bool reportAck) {
 void Connection::onDisconnected(int reason) {
     reconnectTimer->stop();
     DEBUG_D("connection(%p, dc%u, type %d) disconnected with reason %d", this, currentDatacenter->getDatacenterId(), connectionType, reason);
-    bool switchToNextPort = wasConnected && !hasSomeDataSinceLastConnect && reason == 2;
+    bool switchToNextPort = wasConnected && !hasSomeDataSinceLastConnect && reason == 2 || forceNextPort;
     firstPacketSent = false;
     if (restOfTheData != nullptr) {
         restOfTheData->reuse();
@@ -391,15 +406,15 @@ void Connection::onDisconnected(int reason) {
     if (connectionState != TcpConnectionStageSuspended && connectionState != TcpConnectionStageIdle) {
         connectionState = TcpConnectionStageIdle;
     }
-    ConnectionsManager::getInstance().onConnectionClosed(this);
+    ConnectionsManager::getInstance().onConnectionClosed(this, reason);
 
     uint32_t datacenterId = currentDatacenter->getDatacenterId();
-    if (connectionState == TcpConnectionStageIdle && connectionType == ConnectionTypeGeneric && (currentDatacenter->isHandshaking() || datacenterId == ConnectionsManager::getInstance().currentDatacenterId || datacenterId == ConnectionsManager::getInstance().movingToDatacenterId)) {
+    if (connectionState == TcpConnectionStageIdle) {
         connectionState = TcpConnectionStageReconnecting;
         failedConnectionCount++;
         if (failedConnectionCount == 1) {
-            if (hasSomeDataSinceLastConnect) {
-                willRetryConnectCount = 5;
+            if (usefullData) {
+                willRetryConnectCount = 3;
             } else {
                 willRetryConnectCount = 1;
             }
@@ -411,10 +426,14 @@ void Connection::onDisconnected(int reason) {
                 failedConnectionCount = 0;
             }
         }
-        DEBUG_D("connection(%p, dc%u, type %d) reconnect %s:%hu", this, currentDatacenter->getDatacenterId(), connectionType, hostAddress.c_str(), hostPort);
-        reconnectTimer->setTimeout(1000, false);
-        reconnectTimer->start();
+        if (connectionType == ConnectionTypeGeneric && (currentDatacenter->isHandshaking() || datacenterId == ConnectionsManager::getInstance().currentDatacenterId || datacenterId == ConnectionsManager::getInstance().movingToDatacenterId)) {
+            DEBUG_D("connection(%p, dc%u, type %d) reconnect %s:%hu", this, currentDatacenter->getDatacenterId(), connectionType, hostAddress.c_str(), hostPort);
+            reconnectTimer->setTimeout(1000, false);
+            reconnectTimer->start();
+        }
+
     }
+    usefullData = false;
 }
 
 void Connection::onConnected() {
diff --git a/TMessagesProj/jni/tgnet/Connection.h b/TMessagesProj/jni/tgnet/Connection.h
index 76da54f4f..7d1e0fc55 100644
--- a/TMessagesProj/jni/tgnet/Connection.h
+++ b/TMessagesProj/jni/tgnet/Connection.h
@@ -30,7 +30,10 @@ class Connection : public ConnectionSession, public ConnectionSocket {
 
     void connect();
     void suspendConnection();
+    void suspendConnection(bool idle);
     void sendData(NativeByteBuffer *buffer, bool reportAck);
+    bool hasUsefullData();
+    void setHasUsefullData();
     uint32_t getConnectionToken();
     ConnectionType getConnectionType();
     Datacenter *getDatacenter();
@@ -68,6 +71,8 @@ class Connection : public ConnectionSession, public ConnectionSocket {
     bool wasConnected = false;
     uint32_t willRetryConnectCount = 5;
     Timer *reconnectTimer;
+    bool usefullData = false;
+    bool forceNextPort = false;
     
     AES_KEY encryptKey;
     uint8_t encryptIv[16];
diff --git a/TMessagesProj/jni/tgnet/ConnectionSocket.cpp b/TMessagesProj/jni/tgnet/ConnectionSocket.cpp
index 227ab5e10..131190534 100644
--- a/TMessagesProj/jni/tgnet/ConnectionSocket.cpp
+++ b/TMessagesProj/jni/tgnet/ConnectionSocket.cpp
@@ -13,6 +13,7 @@
 #include <memory.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
+#include <netdb.h>
 #include "ByteStream.h"
 #include "ConnectionSocket.h"
 #include "FileLog.h"
@@ -21,6 +22,7 @@
 #include "EventObject.h"
 #include "Timer.h"
 #include "NativeByteBuffer.h"
+#include "BuffersStorage.h"
 
 #ifndef EPOLLRDHUP
 #define EPOLLRDHUP 0x2000
@@ -45,34 +47,81 @@ ConnectionSocket::~ConnectionSocket() {
 
 void ConnectionSocket::openConnection(std::string address, uint16_t port, bool ipv6, int32_t networkType) {
     currentNetworkType = networkType;
+    isIpv6 = ipv6;
+    currentAddress = address;
+    currentPort = port;
     int epolFd = ConnectionsManager::getInstance().epolFd;
     ConnectionsManager::getInstance().attachConnection(this);
 
-    if ((socketFd = socket(ipv6 ? AF_INET6 : AF_INET, SOCK_STREAM, 0)) < 0) {
-        DEBUG_E("connection(%p) can't create socket", this);
-        closeSocket(1);
-        return;
-    }
-
     memset(&socketAddress, 0, sizeof(sockaddr_in));
     memset(&socketAddress6, 0, sizeof(sockaddr_in6));
 
-    if (ipv6) {
-        socketAddress6.sin6_family = AF_INET6;
-        socketAddress6.sin6_port = htons(port);
-        if (inet_pton(AF_INET6, address.c_str(), &socketAddress6.sin6_addr.s6_addr) != 1) {
-            DEBUG_E("connection(%p) bad ipv6 %s", this, address.c_str());
+    if (!ConnectionsManager::getInstance().proxyAddress.empty()) {
+        std::string &proxyAddress = ConnectionsManager::getInstance().proxyAddress;
+        if ((socketFd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+            DEBUG_E("connection(%p) can't create proxy socket", this);
             closeSocket(1);
             return;
         }
-    } else {
+        proxyAuthState = 1;
         socketAddress.sin_family = AF_INET;
-        socketAddress.sin_port = htons(port);
-        if (inet_pton(AF_INET, address.c_str(), &socketAddress.sin_addr.s_addr) != 1) {
-            DEBUG_E("connection(%p) bad ipv4 %s", this, address.c_str());
+        socketAddress.sin_port = htons(ConnectionsManager::getInstance().proxyPort);
+        bool continueCheckAddress;
+        if (inet_pton(AF_INET, proxyAddress.c_str(), &socketAddress.sin_addr.s_addr) != 1) {
+            continueCheckAddress = true;
+            DEBUG_D("connection(%p) not ipv4 address %s", this, proxyAddress.c_str());
+        } else {
+            continueCheckAddress = false;
+        }
+        if (continueCheckAddress) {
+            if (inet_pton(AF_INET6, proxyAddress.c_str(), &socketAddress.sin_addr.s_addr) != 1) {
+                continueCheckAddress = true;
+                DEBUG_D("connection(%p) not ipv6 address %s", this, proxyAddress.c_str());
+            } else {
+                continueCheckAddress = false;
+            }
+            if (continueCheckAddress) {
+                struct hostent *he;
+                if ((he = gethostbyname(proxyAddress.c_str())) == nullptr) {
+                    DEBUG_E("connection(%p) can't resolve host %s address", this, proxyAddress.c_str());
+                    closeSocket(1);
+                    return;
+                }
+                struct in_addr **addr_list = (struct in_addr **) he->h_addr_list;
+                if (addr_list[0] != nullptr) {
+                    socketAddress.sin_addr.s_addr = addr_list[0]->s_addr;
+                    DEBUG_D("connection(%p) resolved host %s address %x", this, proxyAddress.c_str(), addr_list[0]->s_addr);
+                } else {
+                    DEBUG_E("connection(%p) can't resolve host %s address", this, proxyAddress.c_str());
+                    closeSocket(1);
+                    return;
+                }
+            }
+        }
+    } else {
+        proxyAuthState = 0;
+        if ((socketFd = socket(ipv6 ? AF_INET6 : AF_INET, SOCK_STREAM, 0)) < 0) {
+            DEBUG_E("connection(%p) can't create socket", this);
             closeSocket(1);
             return;
         }
+        if (ipv6) {
+            socketAddress6.sin6_family = AF_INET6;
+            socketAddress6.sin6_port = htons(port);
+            if (inet_pton(AF_INET6, address.c_str(), &socketAddress6.sin6_addr.s6_addr) != 1) {
+                DEBUG_E("connection(%p) bad ipv6 %s", this, address.c_str());
+                closeSocket(1);
+                return;
+            }
+        } else {
+            socketAddress.sin_family = AF_INET;
+            socketAddress.sin_port = htons(port);
+            if (inet_pton(AF_INET, address.c_str(), &socketAddress.sin_addr.s_addr) != 1) {
+                DEBUG_E("connection(%p) bad ipv4 %s", this, address.c_str());
+                closeSocket(1);
+                return;
+            }
+        }
     }
 
     int yes = 1;
@@ -106,6 +155,9 @@ bool ConnectionSocket::checkSocketError() {
     int code;
     socklen_t len = sizeof(int);
     ret = getsockopt(socketFd, SOL_SOCKET, SO_ERROR, &code, &len);
+    if (ret != 0 || code != 0) {
+        DEBUG_E("socket error 0x%x code 0x%x", ret, code);
+    }
     return (ret || code) != 0;
 }
 
@@ -119,6 +171,7 @@ void ConnectionSocket::closeSocket(int reason) {
         }
         socketFd = -1;
     }
+    proxyAuthState = 0;
     onConnectedSent = false;
     outgoingByteStream->clean();
     onDisconnected(reason);
@@ -143,10 +196,58 @@ void ConnectionSocket::onEvent(uint32_t events) {
                 if (readCount > 0) {
                     buffer->limit((uint32_t) readCount);
                     lastEventTime = ConnectionsManager::getInstance().getCurrentTimeMonotonicMillis();
-                    if (ConnectionsManager::getInstance().delegate != nullptr) {
-                        ConnectionsManager::getInstance().delegate->onBytesReceived(readCount, currentNetworkType);
+                    if (proxyAuthState == 2) {
+                        if (readCount == 2) {
+                            uint8_t auth_method = buffer->bytes()[1];
+                            if (auth_method == 0xff) {
+                                closeSocket(1);
+                                DEBUG_E("connection(%p) unsupported proxy auth method", this);
+                            } else if (auth_method == 0x02) {
+                                DEBUG_D("connection(%p) proxy auth required", this);
+                                proxyAuthState = 3;
+                            } else if (auth_method == 0x00) {
+                                proxyAuthState = 5;
+                            }
+                            adjustWriteOp();
+                        } else {
+                            closeSocket(1);
+                            DEBUG_E("connection(%p) invalid proxy response on state 2", this);
+                        }
+                    } else if (proxyAuthState == 4) {
+                        if (readCount == 2) {
+                            uint8_t auth_method = buffer->bytes()[1];
+                            if (auth_method != 0x00) {
+                                closeSocket(1);
+                                DEBUG_E("connection(%p) auth invalid", this);
+                            } else {
+                                proxyAuthState = 5;
+                            }
+                            adjustWriteOp();
+                        } else {
+                            closeSocket(1);
+                            DEBUG_E("connection(%p) invalid proxy response on state 4", this);
+                        }
+                    } else if (proxyAuthState == 6) {
+                        if (readCount > 2) {
+                            uint8_t status = buffer->bytes()[1];
+                            if (status == 0x00) {
+                                DEBUG_D("connection(%p) connected via proxy", this);
+                                proxyAuthState = 0;
+                                adjustWriteOp();
+                            } else {
+                                closeSocket(1);
+                                DEBUG_E("connection(%p) invalid proxy status on state 6, 0x%x", this, status);
+                            }
+                        } else {
+                            closeSocket(1);
+                            DEBUG_E("connection(%p) invalid proxy response on state 6", this);
+                        }
+                    } else if (proxyAuthState == 0) {
+                        if (ConnectionsManager::getInstance().delegate != nullptr) {
+                            ConnectionsManager::getInstance().delegate->onBytesReceived(readCount, currentNetworkType);
+                        }
+                        onReceivedData(buffer);
                     }
-                    onReceivedData(buffer);
                 }
                 if (readCount != READ_BUFFER_SIZE) {
                     break;
@@ -159,34 +260,83 @@ void ConnectionSocket::onEvent(uint32_t events) {
             closeSocket(1);
             return;
         } else {
-            if (!onConnectedSent) {
-                lastEventTime = ConnectionsManager::getInstance().getCurrentTimeMonotonicMillis();
-                onConnected();
-                onConnectedSent = true;
-            }
-            NativeByteBuffer *buffer = ConnectionsManager::getInstance().networkBuffer;
-            buffer->clear();
-            outgoingByteStream->get(buffer);
-            buffer->flip();
-
-            uint32_t remaining = buffer->remaining();
-            if (remaining) {
-                ssize_t sentLength;
-                if ((sentLength = send(socketFd, buffer->bytes(), remaining, 0)) < 0) {
-                    DEBUG_E("connection(%p) send failed", this);
-                    closeSocket(1);
-                    return;
-                } else {
-                    if (ConnectionsManager::getInstance().delegate != nullptr) {
-                        ConnectionsManager::getInstance().delegate->onBytesSent(sentLength, currentNetworkType);
+            if (proxyAuthState != 0) {
+                static uint8_t buffer[1024];
+                if (proxyAuthState == 1) {
+                    lastEventTime = ConnectionsManager::getInstance().getCurrentTimeMonotonicMillis();
+                    proxyAuthState = 2;
+                    buffer[0] = 0x05;
+                    buffer[1] = 0x02;
+                    buffer[2] = 0x00;
+                    buffer[3] = 0x02;
+                    if (send(socketFd, buffer, 4, 0) < 0) {
+                        DEBUG_E("connection(%p) send failed", this);
+                        closeSocket(1);
+                        return;
+                    }
+                    adjustWriteOp();
+                } else if (proxyAuthState == 3) {
+                    buffer[0] = 0x01;
+                    uint8_t len1 = (uint8_t) ConnectionsManager::getInstance().proxyUser.length();
+                    uint8_t len2 = (uint8_t) ConnectionsManager::getInstance().proxyPassword.length();
+                    buffer[1] = len1;
+                    memcpy(&buffer[2], ConnectionsManager::getInstance().proxyUser.c_str(), len1);
+                    buffer[2 + len1] = len2;
+                    memcpy(&buffer[3 + len1], ConnectionsManager::getInstance().proxyPassword.c_str(), len2);
+                    proxyAuthState = 4;
+                    if (send(socketFd, buffer, 3 + len1 + len2, 0) < 0) {
+                        DEBUG_E("connection(%p) send failed", this);
+                        closeSocket(1);
+                        return;
+                    }
+                    adjustWriteOp();
+                } else if (proxyAuthState == 5) {
+                    buffer[0] = 0x05;
+                    buffer[1] = 0x01;
+                    buffer[2] = 0x00;
+                    buffer[3] = (uint8_t) (isIpv6 ? 0x04 : 0x01);
+                    uint16_t networkPort = ntohs(currentPort);
+                    inet_pton(isIpv6 ? AF_INET6 : AF_INET, currentAddress.c_str(), &buffer[4]);
+                    memcpy(&buffer[4 + (isIpv6 ? 16 : 4)], &networkPort, sizeof(uint16_t));
+                    proxyAuthState = 6;
+                    if (send(socketFd, buffer, 4 + (isIpv6 ? 16 : 4) + 2, 0) < 0) {
+                        DEBUG_E("connection(%p) send failed", this);
+                        closeSocket(1);
+                        return;
                     }
-                    outgoingByteStream->discard((uint32_t) sentLength);
                     adjustWriteOp();
                 }
+            } else {
+                if (!onConnectedSent) {
+                    lastEventTime = ConnectionsManager::getInstance().getCurrentTimeMonotonicMillis();
+                    onConnected();
+                    onConnectedSent = true;
+                }
+                NativeByteBuffer *buffer = ConnectionsManager::getInstance().networkBuffer;
+                buffer->clear();
+                outgoingByteStream->get(buffer);
+                buffer->flip();
+
+                uint32_t remaining = buffer->remaining();
+                if (remaining) {
+                    ssize_t sentLength;
+                    if ((sentLength = send(socketFd, buffer->bytes(), remaining, 0)) < 0) {
+                        DEBUG_E("connection(%p) send failed", this);
+                        closeSocket(1);
+                        return;
+                    } else {
+                        if (ConnectionsManager::getInstance().delegate != nullptr) {
+                            ConnectionsManager::getInstance().delegate->onBytesSent(sentLength, currentNetworkType);
+                        }
+                        outgoingByteStream->discard((uint32_t) sentLength);
+                        adjustWriteOp();
+                    }
+                }
             }
         }
     }
     if ((events & EPOLLRDHUP) || (events & EPOLLHUP)) {
+        DEBUG_E("socket event has EPOLLHUP");
         closeSocket(1);
         return;
     }
@@ -196,6 +346,13 @@ void ConnectionSocket::onEvent(uint32_t events) {
     }
 }
 
+void ConnectionSocket::writeBuffer(uint8_t *data, uint32_t size) {
+    NativeByteBuffer *buffer = BuffersStorage::getInstance().getFreeBuffer(size);
+    buffer->writeBytes(data, size);
+    outgoingByteStream->append(buffer);
+    adjustWriteOp();
+}
+
 void ConnectionSocket::writeBuffer(NativeByteBuffer *buffer) {
     outgoingByteStream->append(buffer);
     adjustWriteOp();
@@ -203,7 +360,7 @@ void ConnectionSocket::writeBuffer(NativeByteBuffer *buffer) {
 
 void ConnectionSocket::adjustWriteOp() {
     eventMask.events = EPOLLIN | EPOLLRDHUP | EPOLLERR | EPOLLET;
-    if (outgoingByteStream->hasData()) {
+    if (proxyAuthState == 0 && (outgoingByteStream->hasData() || !onConnectedSent) || proxyAuthState == 1 || proxyAuthState == 3 || proxyAuthState == 5) {
         eventMask.events |= EPOLLOUT;
     }
     eventMask.data.ptr = eventObject;
@@ -218,6 +375,10 @@ void ConnectionSocket::setTimeout(time_t time) {
     lastEventTime = ConnectionsManager::getInstance().getCurrentTimeMonotonicMillis();
 }
 
+time_t ConnectionSocket::getTimeout() {
+    return timeout;
+}
+
 void ConnectionSocket::checkTimeout(int64_t now) {
     if (timeout != 0 && (now - lastEventTime) > (int64_t) timeout * 1000) {
         closeSocket(2);
diff --git a/TMessagesProj/jni/tgnet/ConnectionSocket.h b/TMessagesProj/jni/tgnet/ConnectionSocket.h
index 6b44560af..7656dee5a 100644
--- a/TMessagesProj/jni/tgnet/ConnectionSocket.h
+++ b/TMessagesProj/jni/tgnet/ConnectionSocket.h
@@ -24,9 +24,11 @@ class ConnectionSocket {
     ConnectionSocket();
     virtual ~ConnectionSocket();
 
+    void writeBuffer(uint8_t *data, uint32_t size);
     void writeBuffer(NativeByteBuffer *buffer);
     void openConnection(std::string address, uint16_t port, bool ipv6, int32_t networkType);
     void setTimeout(time_t timeout);
+    time_t getTimeout();
     bool isDisconnected();
     void dropConnection();
 
@@ -43,11 +45,16 @@ class ConnectionSocket {
     struct sockaddr_in socketAddress;
     struct sockaddr_in6 socketAddress6;
     int socketFd = -1;
-    time_t timeout = 15;
+    time_t timeout = 12;
     bool onConnectedSent = false;
     int64_t lastEventTime = 0;
     EventObject *eventObject;
     int32_t currentNetworkType;
+    bool isIpv6;
+    std::string currentAddress;
+    uint16_t currentPort;
+
+    uint8_t proxyAuthState;
 
     bool checkSocketError();
     void closeSocket(int reason);
diff --git a/TMessagesProj/jni/tgnet/ConnectionsManager.cpp b/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
index 2f4ebf088..6772aed15 100644
--- a/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
+++ b/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
@@ -144,7 +144,7 @@ int ConnectionsManager::callEvents(int64_t now) {
     if (!networkPaused) {
         return 1000;
     }
-    int32_t timeToPushPing = (sendingPushPing ? 30000 : 60000 * 3) - abs(now - lastPushPingTime);
+    int32_t timeToPushPing = (sendingPushPing ? 30000 : 60000 * 3) - llabs(now - lastPushPingTime);
     if (timeToPushPing <= 0) {
         return 1000;
     }
@@ -253,7 +253,7 @@ void ConnectionsManager::select() {
                 sendPing(datacenter, false);
             }
             if (abs((int32_t) (now / 1000) - lastDcUpdateTime) >= DC_UPDATE_TIME) {
-                updateDcSettings(0);
+                updateDcSettings(0, false);
             }
             processRequestQueue(0, 0);
         } else if (!datacenter->isHandshaking()) {
@@ -384,11 +384,7 @@ void ConnectionsManager::loadConfig() {
     movingToDatacenterId = DEFAULT_DATACENTER_ID;
 }
 
-void ConnectionsManager::saveConfig() {
-    if (config == nullptr) {
-        config = new Config("tgnet.dat");
-    }
-    NativeByteBuffer *buffer = BuffersStorage::getInstance().getFreeBuffer(32 * 1024);
+void ConnectionsManager::saveConfigInternal(NativeByteBuffer *buffer) {
     buffer->writeInt32(configVersion);
     buffer->writeBool(testBackend);
     Datacenter *currentDatacenter = getDatacenterWithId(currentDatacenterId);
@@ -414,6 +410,17 @@ void ConnectionsManager::saveConfig() {
             iter->second->serializeToStream(buffer);
         }
     }
+}
+
+void ConnectionsManager::saveConfig() {
+    if (config == nullptr) {
+        config = new Config("tgnet.dat");
+    }
+    static NativeByteBuffer *sizeCalculator = new NativeByteBuffer(true);
+    sizeCalculator->clearCapacity();
+    saveConfigInternal(sizeCalculator);
+    NativeByteBuffer *buffer = BuffersStorage::getInstance().getFreeBuffer(sizeCalculator->capacity());
+    saveConfigInternal(buffer);
     config->writeConfig(buffer);
     buffer->reuse();
 }
@@ -507,6 +514,10 @@ int32_t ConnectionsManager::getCurrentTime() {
     return (int32_t) (getCurrentTimeMillis() / 1000) + timeDifference;
 }
 
+bool ConnectionsManager::isTestBackend() {
+    return testBackend;
+}
+
 int32_t ConnectionsManager::getTimeDifference() {
     return timeDifference;
 }
@@ -572,18 +583,41 @@ void ConnectionsManager::cleanUp() {
     });
 }
 
-void ConnectionsManager::onConnectionClosed(Connection *connection) {
+void ConnectionsManager::onConnectionClosed(Connection *connection, int reason) {
     Datacenter *datacenter = connection->getDatacenter();
     if (connection->getConnectionType() == ConnectionTypeGeneric) {
+        if (proxyAddress.empty()) {
+            if (reason == 2) {
+                disconnectTimeoutAmount += connection->getTimeout();
+            } else {
+                disconnectTimeoutAmount += 4;
+            }
+            if (disconnectTimeoutAmount >= 20) {
+                if (!connection->hasUsefullData()) {
+                    requestingSecondAddress = 0;
+                    delegate->onRequestNewServerIpAndPort(requestingSecondAddress);
+                }
+                disconnectTimeoutAmount = 0;
+            }
+        }
         if (datacenter->isHandshaking()) {
             datacenter->onHandshakeConnectionClosed(connection);
         }
         if (datacenter->getDatacenterId() == currentDatacenterId) {
             if (networkAvailable) {
-                if (connectionState != ConnectionStateConnecting) {
-                    connectionState = ConnectionStateConnecting;
-                    if (delegate != nullptr) {
-                        delegate->onConnectionStateChanged(connectionState);
+                if (proxyAddress.empty()) {
+                    if (connectionState != ConnectionStateConnecting) {
+                        connectionState = ConnectionStateConnecting;
+                        if (delegate != nullptr) {
+                            delegate->onConnectionStateChanged(connectionState);
+                        }
+                    }
+                } else {
+                    if (connectionState != ConnectionStateConnectingViaProxy) {
+                        connectionState = ConnectionStateConnectingViaProxy;
+                        if (delegate != nullptr) {
+                            delegate->onConnectionStateChanged(connectionState);
+                        }
                     }
                 }
             } else {
@@ -643,7 +677,13 @@ void ConnectionsManager::onConnectionDataReceived(Connection *connection, Native
     bool error = false;
     if (length == 4) {
         int32_t code = data->readInt32(&error);
-        DEBUG_E("mtproto error = %d", code);
+        Datacenter *datacenter = connection->getDatacenter();
+        if (code == -404 && datacenter->isCdnDatacenter) {
+            datacenter->clear();
+            DEBUG_D("connection(%p, dc%u, type %d) reset auth key duo to -404 error", connection, datacenter->getDatacenterId(), connection->getConnectionType());
+        } else {
+            DEBUG_E("mtproto error = %d", code);
+        }
         connection->reconnect();
         return;
     }
@@ -703,14 +743,16 @@ void ConnectionsManager::onConnectionDataReceived(Connection *connection, Native
                 processServerResponse(object, messageId, 0, 0, connection, 0, 0);
                 connection->addProcessedMessageId(messageId);
             }
+            connection->setHasUsefullData();
+            if (connection->getConnectionType() == ConnectionTypeGeneric) {
+                disconnectTimeoutAmount = 0;
+            }
             delete object;
         }
     } else {
         if (length < 24 + 32 || (length - 24) % 16 != 0 || !datacenter->decryptServerResponse(keyId, data->bytes() + mark + 8, data->bytes() + mark + 24, length - 24)) {
             DEBUG_E("connection(%p) unable to decrypt server response", connection);
-            datacenter->switchTo443Port();
-            connection->suspendConnection();
-            connection->connect();
+            connection->reconnect();
             return;
         }
         data->position(mark + 24);
@@ -740,6 +782,10 @@ void ConnectionsManager::onConnectionDataReceived(Connection *connection, Native
         if (!doNotProcess) {
             TLObject *object = TLdeserialize(nullptr, messageLength, data);
             if (object != nullptr) {
+                connection->setHasUsefullData();
+                if (connection->getConnectionType() == ConnectionTypeGeneric) {
+                    disconnectTimeoutAmount = 0;
+                }
                 DEBUG_D("connection(%p, dc%u, type %d) received object %s", connection, datacenter->getDatacenterId(), connection->getConnectionType(), typeid(*object).name());
                 processServerResponse(object, messageId, messageSeqNo, messageServerSalt, connection, 0, 0);
                 connection->addProcessedMessageId(messageId);
@@ -980,9 +1026,11 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                         TL_error *error2 = hasResult ? dynamic_cast<TL_error *>(response->result.get()) : nullptr;
                         if (error != nullptr) {
                             allowInitConnection = false;
+                            static std::string authRestart = "AUTH_RESTART";
+                            bool processEvenFailed = error->error_code == 500 && error->error_message.find(authRestart) != std::string::npos;
                             DEBUG_E("request %p rpc error %d: %s", request, error->error_code, error->error_message.c_str());
 
-                            if ((request->requestFlags & RequestFlagFailOnServerErrors) == 0) {
+                            if ((request->requestFlags & RequestFlagFailOnServerErrors) == 0 || processEvenFailed) {
                                 if (error->error_code == 500 || error->error_code < 0) {
                                     discardResponse = true;
                                     request->minStartTime = request->startTime + (request->serverFailureCount > 10 ? 10 : request->serverFailureCount);
@@ -1103,7 +1151,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
 
     } else if (typeInfo == typeid(TL_bad_msg_notification)) {
         TL_bad_msg_notification *result = (TL_bad_msg_notification *) message;
-        DEBUG_E("bad message: %d", result->error_code);
+        DEBUG_E("bad message notification %d for messageId 0x%llx, seqno %d", result->error_code, result->bad_msg_id, result->bad_msg_seqno);
         switch (result->error_code) {
             case 16:
             case 17:
@@ -1129,6 +1177,19 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                 clearRequestsForDatacenter(datacenter);
                 break;
             }
+            case 20: {
+                for (requestsIter iter = runningRequests.begin(); iter != runningRequests.end(); iter++) {
+                    Request *request = iter->get();
+                    if (request->respondsToMessageId(result->bad_msg_id)) {
+                        if (request->completed) {
+                            break;
+                        }
+                        connection->addMessageToConfirm(result->bad_msg_id);
+                        request->clear(true);
+                        break;
+                    }
+                }
+            }
             default:
                 break;
         }
@@ -1168,12 +1229,33 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
         if (datacenter->hasAuthKey()) {
             processRequestQueue(AllConnectionTypes, datacenter->getDatacenterId());
         }
+    } else if (typeInfo == typeid(MsgsStateInfo)) {
+        MsgsStateInfo *response = (MsgsStateInfo *) message;
+        DEBUG_D("connection(%p, dc%u, type %d) got %s for messageId 0x%llx", connection, datacenter->getDatacenterId(), connection->getConnectionType(), typeInfo.name(), response->req_msg_id);
+
+        std::map<int64_t, int64_t>::iterator mIter = resendRequests.find(response->req_msg_id);
+        if (mIter != resendRequests.end()) {
+            DEBUG_D("found resend for messageId 0x%llx", mIter->second);
+            connection->addMessageToConfirm(mIter->second);
+            for (requestsIter iter = runningRequests.begin(); iter != runningRequests.end(); iter++) {
+                Request *request = iter->get();
+                if (request->respondsToMessageId(mIter->second)) {
+                    if (request->completed) {
+                        break;
+                    }
+                    request->clear(true);
+                    break;
+                }
+            }
+            resendRequests.erase(mIter);
+        }
     } else if (dynamic_cast<MsgDetailedInfo *>(message)) {
         MsgDetailedInfo *response = (MsgDetailedInfo *) message;
 
         bool requestResend = false;
         bool confirm = true;
 
+        DEBUG_D("connection(%p, dc%u, type %d) got %s for messageId 0x%llx", connection, datacenter->getDatacenterId(), connection->getConnectionType(), typeInfo.name(), response->msg_id);
         if (typeInfo == typeid(TL_msg_detailed_info)) {
             for (requestsIter iter = runningRequests.begin(); iter != runningRequests.end(); iter++) {
                 Request *request = iter->get();
@@ -1181,6 +1263,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                     if (request->completed) {
                         break;
                     }
+                    DEBUG_D("got TL_msg_detailed_info for rpc request %p - %s", request->rawRequest, typeid(*request->rawRequest).name());
                     int32_t currentTime = (int32_t) (getCurrentTimeMonotonicMillis() / 1000);
                     if (request->lastResendTime == 0 || abs(currentTime - request->lastResendTime) >= 60) {
                         request->lastResendTime = currentTime;
@@ -1206,6 +1289,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
             networkMessage->message->bytes = request->getObjectSize();
             networkMessage->message->body = std::unique_ptr<TLObject>(request);
             networkMessage->message->seqno = connection->generateMessageSeqNo(false);
+            resendRequests[networkMessage->message->msg_id] = response->answer_msg_id;
 
             std::vector<std::unique_ptr<NetworkMessage>> array;
             array.push_back(std::unique_ptr<NetworkMessage>(networkMessage));
@@ -1378,7 +1462,7 @@ int32_t ConnectionsManager::sendRequestInternal(TLObject *object, onCompleteFunc
         delete object;
         return 0;
     }
-    Request *request = new Request(lastRequestToken++, connetionType, flags, datacenterId, onComplete, onQuickAck);
+    Request *request = new Request(lastRequestToken++, connetionType, flags, datacenterId, onComplete, onQuickAck, nullptr);
     request->rawRequest = object;
     request->rpcRequest = wrapInLayer(object, getDatacenterWithId(datacenterId), request);
     requestsQueue.push_back(std::unique_ptr<Request>(request));
@@ -1401,7 +1485,7 @@ void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete
         return;
     }
     scheduleTask([&, requestToken, object, onComplete, onQuickAck, flags, datacenterId, connetionType, immediate] {
-        Request *request = new Request(requestToken, connetionType, flags, datacenterId, onComplete, onQuickAck);
+        Request *request = new Request(requestToken, connetionType, flags, datacenterId, onComplete, onQuickAck, nullptr);
         request->rawRequest = object;
         request->rpcRequest = wrapInLayer(object, getDatacenterWithId(datacenterId), request);
         requestsQueue.push_back(std::unique_ptr<Request>(request));
@@ -1412,7 +1496,7 @@ void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete
 }
 
 #ifdef ANDROID
-void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2) {
+void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, onWriteToSocketFunc onWriteToSocket, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2, jobject ptr3) {
     if (!currentUserId && !(flags & RequestFlagWithoutLogin)) {
         DEBUG_D("can't do request without login %s", typeid(*object).name());
         delete object;
@@ -1429,14 +1513,19 @@ void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete
             env->DeleteGlobalRef(ptr2);
             ptr2 = nullptr;
         }
+        if (ptr3 != nullptr) {
+            env->DeleteGlobalRef(ptr3);
+            ptr3 = nullptr;
+        }
         return;
     }
-    scheduleTask([&, requestToken, object, onComplete, onQuickAck, flags, datacenterId, connetionType, immediate, ptr1, ptr2] {
+    scheduleTask([&, requestToken, object, onComplete, onQuickAck, onWriteToSocket, flags, datacenterId, connetionType, immediate, ptr1, ptr2, ptr3] {
         DEBUG_D("send request %p - %s", object, typeid(*object).name());
-        Request *request = new Request(requestToken, connetionType, flags, datacenterId, onComplete, onQuickAck);
+        Request *request = new Request(requestToken, connetionType, flags, datacenterId, onComplete, onQuickAck, onWriteToSocket);
         request->rawRequest = object;
         request->ptr1 = ptr1;
         request->ptr2 = ptr2;
+        request->ptr3 = ptr3;
         request->rpcRequest = wrapInLayer(object, getDatacenterWithId(datacenterId), request);
         DEBUG_D("send request wrapped %p - %s", request->rpcRequest.get(), typeid(*(request->rpcRequest.get())).name());
         requestsQueue.push_back(std::unique_ptr<Request>(request));
@@ -1487,7 +1576,7 @@ void ConnectionsManager::setUserId(int32_t userId) {
             registerForInternalPushUpdates();
         }
         if (currentUserId != userId && userId != 0) {
-            updateDcSettings(0);
+            updateDcSettings(0, false);
         }
         if (currentUserId != 0 && pushConnectionEnabled) {
             Datacenter *datacenter = getDatacenterWithId(currentDatacenterId);
@@ -1501,6 +1590,7 @@ void ConnectionsManager::setUserId(int32_t userId) {
 
 void ConnectionsManager::switchBackend() {
     scheduleTask([&] {
+        currentDatacenterId = 1;
         testBackend = !testBackend;
         datacenters.clear();
         initDatacenters();
@@ -1699,10 +1789,10 @@ void ConnectionsManager::registerForInternalPushUpdates() {
 }
 
 
-inline void addMessageToDatacenter(uint32_t datacenterId, NetworkMessage *networkMessage, std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>> &genericMessagesToDatacenters) {
-    std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>>::iterator iter = genericMessagesToDatacenters.find(datacenterId);
-    if (iter == genericMessagesToDatacenters.end()) {
-        std::vector<std::unique_ptr<NetworkMessage>> &array = genericMessagesToDatacenters[datacenterId] = std::vector<std::unique_ptr<NetworkMessage>>();
+inline void addMessageToDatacenter(uint32_t datacenterId, NetworkMessage *networkMessage, std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>> &messagesToDatacenters) {
+    std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>>::iterator iter = messagesToDatacenters.find(datacenterId);
+    if (iter == messagesToDatacenters.end()) {
+        std::vector<std::unique_ptr<NetworkMessage>> &array = messagesToDatacenters[datacenterId] = std::vector<std::unique_ptr<NetworkMessage>>();
         array.push_back(std::unique_ptr<NetworkMessage>(networkMessage));
     } else {
         iter->second.push_back(std::unique_ptr<NetworkMessage>(networkMessage));
@@ -1711,11 +1801,13 @@ inline void addMessageToDatacenter(uint32_t datacenterId, NetworkMessage *networ
 
 void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t dc) {
     static std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>> genericMessagesToDatacenters;
+    static std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>> tempMessagesToDatacenters;
     static std::vector<uint32_t> unknownDatacenterIds;
     static std::vector<Datacenter *> neededDatacenters;
     static std::vector<Datacenter *> unauthorizedDatacenters;
 
     genericMessagesToDatacenters.clear();
+    tempMessagesToDatacenters.clear();
     unknownDatacenterIds.clear();
     neededDatacenters.clear();
     unauthorizedDatacenters.clear();
@@ -1775,30 +1867,36 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
         }
 
         Datacenter *requestDatacenter = getDatacenterWithId(datacenterId);
-        if (requestDatacenter->lastInitVersion != currentVersion && !request->isInitRequest) {
-            request->rpcRequest.release();
-            request->rpcRequest = wrapInLayer(request->rawRequest, requestDatacenter, request);
-            request->serializedLength = request->getRpcRequest()->getObjectSize();
-        }
-
         if (requestDatacenter == nullptr) {
             if (std::find(unknownDatacenterIds.begin(), unknownDatacenterIds.end(), datacenterId) == unknownDatacenterIds.end()) {
                 unknownDatacenterIds.push_back(datacenterId);
             }
             iter++;
             continue;
-        } else if (!requestDatacenter->hasAuthKey()) {
-            if (std::find(neededDatacenters.begin(), neededDatacenters.end(), requestDatacenter) == neededDatacenters.end()) {
-                neededDatacenters.push_back(requestDatacenter);
+        } else {
+            if (requestDatacenter->isCdnDatacenter) {
+                request->requestFlags |= RequestFlagEnableUnauthorized;
             }
-            iter++;
-            continue;
-        } else if (!(request->requestFlags & RequestFlagEnableUnauthorized) && !requestDatacenter->authorized && request->datacenterId != DEFAULT_DATACENTER_ID && request->datacenterId != currentDatacenterId) {
-            if (std::find(unauthorizedDatacenters.begin(), unauthorizedDatacenters.end(), requestDatacenter) == unauthorizedDatacenters.end()) {
-                unauthorizedDatacenters.push_back(requestDatacenter);
+            if (requestDatacenter->lastInitVersion != currentVersion && !request->isInitRequest && request->rawRequest->isNeedLayer()) {
+                DEBUG_D("move %p - %s to requestsQueue because of initConnection", request->rawRequest, typeid(*request->rawRequest).name());
+                requestsQueue.push_back(std::move(*iter));
+                iter = runningRequests.erase(iter);
+                continue;
+            }
+
+            if (!requestDatacenter->hasAuthKey()) {
+                if (std::find(neededDatacenters.begin(), neededDatacenters.end(), requestDatacenter) == neededDatacenters.end()) {
+                    neededDatacenters.push_back(requestDatacenter);
+                }
+                iter++;
+                continue;
+            } else if (!(request->requestFlags & RequestFlagEnableUnauthorized) && !requestDatacenter->authorized && request->datacenterId != DEFAULT_DATACENTER_ID && request->datacenterId != currentDatacenterId) {
+                if (std::find(unauthorizedDatacenters.begin(), unauthorizedDatacenters.end(), requestDatacenter) == unauthorizedDatacenters.end()) {
+                    unauthorizedDatacenters.push_back(requestDatacenter);
+                }
+                iter++;
+                continue;
             }
-            iter++;
-            continue;
         }
 
         Connection *connection = requestDatacenter->getConnectionByType(request->connectionType, true);
@@ -1827,7 +1925,7 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
                                  )
             ) {
             if (!forceThisRequest && request->connectionToken > 0) {
-                if (request->connectionType & ConnectionTypeGeneric && request->connectionToken == connection->getConnectionToken()) {
+                if ((request->connectionType & ConnectionTypeGeneric || request->connectionType & ConnectionTypeTemp) && request->connectionToken == connection->getConnectionToken()) {
                     DEBUG_D("request token is valid, not retrying %s", typeInfo.name());
                     iter++;
                     continue;
@@ -1892,11 +1990,15 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
                 case ConnectionTypeGeneric:
                     addMessageToDatacenter(requestDatacenter->getDatacenterId(), networkMessage, genericMessagesToDatacenters);
                     break;
+                case ConnectionTypeTemp:
+                    addMessageToDatacenter(requestDatacenter->getDatacenterId(), networkMessage, tempMessagesToDatacenters);
+                    break;
                 case ConnectionTypeDownload:
                 case ConnectionTypeUpload: {
                     std::vector<std::unique_ptr<NetworkMessage>> array;
                     array.push_back(std::unique_ptr<NetworkMessage>(networkMessage));
                     sendMessagesToConnectionWithConfirmation(array, connection, false);
+                    request->onWriteToSocket();
                     break;
                 }
                 default:
@@ -1954,7 +2056,7 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
             if (requestStartTime != 0 && abs(currentTime - requestStartTime) >= timeout) {
                 std::vector<uint32_t> allDc;
                 for (std::map<uint32_t, Datacenter *>::iterator iter2 = datacenters.begin(); iter2 != datacenters.end(); iter2++) {
-                    if (iter2->first == datacenterId) {
+                    if (iter2->first == datacenterId || iter2->second->isCdnDatacenter) {
                         continue;
                     }
                     allDc.push_back(iter2->first);
@@ -1972,29 +2074,31 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
         }
 
         Datacenter *requestDatacenter = getDatacenterWithId(datacenterId);
-        if (requestDatacenter->lastInitVersion != currentVersion && !request->isInitRequest) {
-            request->rpcRequest.release();
-            request->rpcRequest = wrapInLayer(request->rawRequest, requestDatacenter, request);
-        }
-
         if (requestDatacenter == nullptr) {
             if (std::find(unknownDatacenterIds.begin(), unknownDatacenterIds.end(), datacenterId) == unknownDatacenterIds.end()) {
                 unknownDatacenterIds.push_back(datacenterId);
             }
             iter++;
             continue;
-        } else if (!requestDatacenter->hasAuthKey()) {
-            if (std::find(neededDatacenters.begin(), neededDatacenters.end(), requestDatacenter) == neededDatacenters.end()) {
-                neededDatacenters.push_back(requestDatacenter);
+        } else {
+            if (requestDatacenter->lastInitVersion != currentVersion && !request->isInitRequest) {
+                request->rpcRequest.release();
+                request->rpcRequest = wrapInLayer(request->rawRequest, requestDatacenter, request);
             }
-            iter++;
-            continue;
-        } else if (!(request->requestFlags & RequestFlagEnableUnauthorized) && !requestDatacenter->authorized && request->datacenterId != DEFAULT_DATACENTER_ID && request->datacenterId != currentDatacenterId) {
-            if (std::find(unauthorizedDatacenters.begin(), unauthorizedDatacenters.end(), requestDatacenter) == unauthorizedDatacenters.end()) {
-                unauthorizedDatacenters.push_back(requestDatacenter);
+
+            if (!requestDatacenter->hasAuthKey()) {
+                if (std::find(neededDatacenters.begin(), neededDatacenters.end(), requestDatacenter) == neededDatacenters.end()) {
+                    neededDatacenters.push_back(requestDatacenter);
+                }
+                iter++;
+                continue;
+            } else if (!(request->requestFlags & RequestFlagEnableUnauthorized) && !requestDatacenter->authorized && request->datacenterId != DEFAULT_DATACENTER_ID && request->datacenterId != currentDatacenterId) {
+                if (std::find(unauthorizedDatacenters.begin(), unauthorizedDatacenters.end(), requestDatacenter) == unauthorizedDatacenters.end()) {
+                    unauthorizedDatacenters.push_back(requestDatacenter);
+                }
+                iter++;
+                continue;
             }
-            iter++;
-            continue;
         }
 
         Connection *connection = requestDatacenter->getConnectionByType(request->connectionType, true);
@@ -2067,6 +2171,9 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
             case ConnectionTypeGeneric:
                 addMessageToDatacenter(requestDatacenter->getDatacenterId(), networkMessage, genericMessagesToDatacenters);
                 break;
+            case ConnectionTypeTemp:
+                addMessageToDatacenter(requestDatacenter->getDatacenterId(), networkMessage, tempMessagesToDatacenters);
+                break;
             case ConnectionTypeDownload:
             case ConnectionTypeUpload: {
                 std::vector<std::unique_ptr<NetworkMessage>> array;
@@ -2090,6 +2197,14 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
                 genericMessagesToDatacenters[datacenter->getDatacenterId()] = std::vector<std::unique_ptr<NetworkMessage>>();
             }
         }
+
+        iter2 = tempMessagesToDatacenters.find(datacenter->getDatacenterId());
+        if (iter2 == tempMessagesToDatacenters.end()) {
+            Connection *connection = datacenter->getTempConnection(false);
+            if (connection != nullptr && connection->getConnectionToken() != 0 && connection->hasMessagesToConfirm()) {
+                tempMessagesToDatacenters[datacenter->getDatacenterId()] = std::vector<std::unique_ptr<NetworkMessage>>();
+            }
+        }
     }
 
     for (std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>>::iterator iter = genericMessagesToDatacenters.begin(); iter != genericMessagesToDatacenters.end(); iter++) {
@@ -2156,6 +2271,14 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
         }
     }
 
+    for (std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>>::iterator iter = tempMessagesToDatacenters.begin(); iter != tempMessagesToDatacenters.end(); iter++) {
+        Datacenter *datacenter = getDatacenterWithId(iter->first);
+        if (datacenter != nullptr) {
+            std::vector<std::unique_ptr<NetworkMessage>> &array = iter->second;
+            sendMessagesToConnectionWithConfirmation(array, datacenter->getTempConnection(true), false);
+        }
+    }
+
     if (connectionTypes == ConnectionTypeGeneric && dc == currentDatacenterId) {
         std::map<uint32_t, std::vector<std::unique_ptr<NetworkMessage>>>::iterator iter2 = genericMessagesToDatacenters.find(currentDatacenterId);
         if (iter2 == genericMessagesToDatacenters.end()) {
@@ -2164,7 +2287,7 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
     }
 
     if (!unknownDatacenterIds.empty()) {
-        updateDcSettings(0);
+        updateDcSettings(0, false);
     }
 
     size_t count = neededDatacenters.size();
@@ -2198,7 +2321,7 @@ Datacenter *ConnectionsManager::getDatacenterWithId(uint32_t datacenterId) {
 std::unique_ptr<TLObject> ConnectionsManager::wrapInLayer(TLObject *object, Datacenter *datacenter, Request *baseRequest) {
     if (object->isNeedLayer()) {
         if (datacenter == nullptr || datacenter->lastInitVersion != currentVersion) {
-            if (datacenter->getDatacenterId() == currentDatacenterId) {
+            if (datacenter != nullptr && datacenter->getDatacenterId() == currentDatacenterId) {
                 registerForInternalPushUpdates();
             }
             baseRequest->isInitRequest = true;
@@ -2206,20 +2329,29 @@ std::unique_ptr<TLObject> ConnectionsManager::wrapInLayer(TLObject *object, Data
             request->query = std::unique_ptr<TLObject>(object);
             request->api_id = currentApiId;
             request->app_version = currentAppVersion;
-            request->device_model = currentDeviceModel;
             request->lang_code = currentLangCode;
-            request->system_version = currentSystemVersion;
+            request->system_lang_code = currentLangCode;
+            request->lang_pack = "android";
+            request->system_lang_code = currentSystemLangCode;
+
+            if (datacenter == nullptr || datacenter->isCdnDatacenter) {
+                request->device_model = "n/a";
+                request->system_version = "n/a";
+            } else {
+                request->device_model = currentDeviceModel;
+                request->system_version = currentSystemVersion;
+            }
             if (request->lang_code.empty()) {
                 request->lang_code = "en";
             }
             if (request->device_model.empty()) {
-                request->device_model = "device model unknown";
+                request->device_model = "n/a";
             }
             if (request->app_version.empty()) {
-                request->app_version = "app version unknown";
+                request->app_version = "n/a";
             }
             if (request->system_version.empty()) {
-                request->system_version = "system version unknown";
+                request->system_version = "n/a";
             }
             invokeWithLayer *request2 = new invokeWithLayer();
             request2->layer = currentLayer;
@@ -2231,54 +2363,68 @@ std::unique_ptr<TLObject> ConnectionsManager::wrapInLayer(TLObject *object, Data
     return std::unique_ptr<TLObject>(object);
 }
 
-void ConnectionsManager::updateDcSettings(uint32_t dcNum) {
-    if (updatingDcSettings) {
-        return;
+void ConnectionsManager::updateDcSettings(uint32_t dcNum, bool workaround) {
+    if (workaround) {
+        if (updatingDcSettingsWorkaround) {
+            return;
+        }
+        updatingDcSettingsWorkaround = true;
+    } else {
+        if (updatingDcSettings) {
+            return;
+        }
+        updatingDcSettings = true;
+        updatingDcStartTime = (int32_t) (getCurrentTimeMonotonicMillis() / 1000);
     }
-    updatingDcStartTime = (int32_t) (getCurrentTimeMonotonicMillis() / 1000);
-    updatingDcSettings = true;
-    TL_help_getConfig *request = new TL_help_getConfig();
 
-    sendRequest(request, [&](TLObject *response, TL_error *error, int32_t networkType) {
-        if (!updatingDcSettings) {
+    TL_help_getConfig *request = new TL_help_getConfig();
+    sendRequest(request, [&, workaround](TLObject *response, TL_error *error, int32_t networkType) {
+        if (!workaround && !updatingDcSettings || workaround && !updatingDcSettingsWorkaround) {
             return;
         }
 
         if (response != nullptr) {
             TL_config *config = (TL_config *) response;
-            int32_t updateIn = config->expires - getCurrentTime();
-            if (updateIn <= 0) {
-                updateIn = 120;
+            if (!workaround) {
+                int32_t updateIn = config->expires - getCurrentTime();
+                if (updateIn <= 0) {
+                    updateIn = 120;
+                }
+                lastDcUpdateTime = (int32_t) (getCurrentTimeMonotonicMillis() / 1000) - DC_UPDATE_TIME + updateIn;
             }
-            lastDcUpdateTime = (int32_t) (getCurrentTimeMonotonicMillis() / 1000) - DC_UPDATE_TIME + updateIn;
 
             struct DatacenterInfo {
-                std::vector<std::string> addressesIpv4;
-                std::vector<std::string> addressesIpv6;
-                std::vector<std::string> addressesIpv4Download;
-                std::vector<std::string> addressesIpv6Download;
-                std::map<std::string, uint32_t> ports;
-
-                void addAddressAndPort(std::string address, uint32_t port, uint32_t flags) {
-                    std::vector<std::string> *addresses;
-                    if ((flags & 2) != 0) {
-                        if ((flags & 1) != 0) {
+                std::vector<TcpAddress> addressesIpv4;
+                std::vector<TcpAddress> addressesIpv6;
+                std::vector<TcpAddress> addressesIpv4Download;
+                std::vector<TcpAddress> addressesIpv6Download;
+                bool isCdn = false;
+
+                void addAddressAndPort(TL_dcOption *dcOption) {
+                    std::vector<TcpAddress> *addresses;
+                    if (!isCdn) {
+                        isCdn = dcOption->cdn;
+                    }
+                    if (dcOption->media_only) {
+                        if (dcOption->ipv6) {
                             addresses = &addressesIpv6Download;
                         } else {
                             addresses = &addressesIpv4Download;
                         }
                     } else {
-                        if ((flags & 1) != 0) {
+                        if (dcOption->ipv6) {
                             addresses = &addressesIpv6;
                         } else {
                             addresses = &addressesIpv4;
                         }
                     }
-                    if (std::find(addresses->begin(), addresses->end(), address) != addresses->end()) {
-                        return;
+                    for (std::vector<TcpAddress>::iterator iter = addresses->begin(); iter != addresses->end(); iter++) {
+                        if (iter->address == dcOption->ip_address && iter->port == dcOption->port) {
+                            return;
+                        }
                     }
-                    addresses->push_back(address);
-                    ports[address] = port;
+                    DEBUG_D("getConfig add %s:%d to dc%d", dcOption->ip_address.c_str(), dcOption->port, dcOption->id);
+                    addresses->push_back(TcpAddress(dcOption->ip_address, dcOption->port, dcOption->flags));
                 }
             };
 
@@ -2293,7 +2439,7 @@ void ConnectionsManager::updateDcSettings(uint32_t dcNum) {
                 } else {
                     info = iter->second.get();
                 }
-                info->addAddressAndPort(dcOption->ip_address, (uint32_t) dcOption->port, (uint32_t) dcOption->flags);
+                info->addAddressAndPort(dcOption);
             }
 
             if (!map.empty()) {
@@ -2304,10 +2450,10 @@ void ConnectionsManager::updateDcSettings(uint32_t dcNum) {
                         datacenter = new Datacenter(iter->first);
                         datacenters[iter->first] = datacenter;
                     }
-                    datacenter->replaceAddressesAndPorts(info->addressesIpv4, info->ports, 0);
-                    datacenter->replaceAddressesAndPorts(info->addressesIpv6, info->ports, 1);
-                    datacenter->replaceAddressesAndPorts(info->addressesIpv4Download, info->ports, 2);
-                    datacenter->replaceAddressesAndPorts(info->addressesIpv6Download, info->ports, 3);
+                    datacenter->replaceAddresses(info->addressesIpv4, info->isCdn ? 8 : 0);
+                    datacenter->replaceAddresses(info->addressesIpv6, info->isCdn ? 9 : 1);
+                    datacenter->replaceAddresses(info->addressesIpv4Download, info->isCdn ? 10 : 2);
+                    datacenter->replaceAddresses(info->addressesIpv6Download, info->isCdn ? 11 : 3);
                     if (iter->first == movingToDatacenterId) {
                         movingToDatacenterId = DEFAULT_DATACENTER_ID;
                         moveToDatacenter(iter->first);
@@ -2320,8 +2466,12 @@ void ConnectionsManager::updateDcSettings(uint32_t dcNum) {
                 delegate->onUpdateConfig(config);
             }
         }
-        updatingDcSettings = false;
-    }, nullptr, RequestFlagEnableUnauthorized  | RequestFlagWithoutLogin | RequestFlagTryDifferentDc, dcNum == 0 ? currentDatacenterId : dcNum, ConnectionTypeGeneric, true);
+        if (workaround) {
+            updatingDcSettingsWorkaround = false;
+        } else {
+            updatingDcSettings = false;
+        }
+    }, nullptr, RequestFlagEnableUnauthorized | RequestFlagWithoutLogin | (workaround ? 0 : RequestFlagTryDifferentDc), dcNum == 0 ? currentDatacenterId : dcNum, workaround ? ConnectionTypeTemp : ConnectionTypeGeneric, true);
 }
 
 void ConnectionsManager::moveToDatacenter(uint32_t datacenterId) {
@@ -2352,7 +2502,7 @@ void ConnectionsManager::moveToDatacenter(uint32_t datacenterId) {
 void ConnectionsManager::authorizeOnMovingDatacenter() {
     Datacenter *datacenter = getDatacenterWithId(movingToDatacenterId);
     if (datacenter == nullptr) {
-        updateDcSettings(0);
+        updateDcSettings(0, false);
         return;
     }
     datacenter->recreateSessions();
@@ -2391,15 +2541,16 @@ void ConnectionsManager::applyDatacenterAddress(uint32_t datacenterId, std::stri
     scheduleTask([&, datacenterId, ipAddress, port] {
         Datacenter *datacenter = getDatacenterWithId(datacenterId);
         if (datacenter != nullptr) {
-            std::vector<std::string> addresses;
-            std::map<std::string, uint32_t> ports;
-            addresses.push_back(ipAddress);
-            ports[ipAddress] = port;
+            std::vector<TcpAddress> addresses;
+            addresses.push_back(TcpAddress(ipAddress, port, 0));
             datacenter->suspendConnections();
-            datacenter->replaceAddressesAndPorts(addresses, ports, 0);
+            datacenter->replaceAddresses(addresses, 0);
             datacenter->resetAddressAndPortNum();
             saveConfig();
-            updateDcSettings(datacenterId);
+            if (datacenter->isHandshaking()) {
+                datacenter->beginHandshake(true);
+            }
+            updateDcSettings(datacenterId, false);
         }
     });
 }
@@ -2428,7 +2579,41 @@ void ConnectionsManager::setPushConnectionEnabled(bool value) {
     }
 }
 
-void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused, bool enablePushConnection, bool hasNetwork, int32_t networkType) {
+void ConnectionsManager::applyDnsConfig(NativeByteBuffer *buffer) {
+    scheduleTask([&, buffer] {
+        TL_help_configSimple *config = Datacenter::decodeSimpleConfig(buffer);
+        int currentDate = getCurrentTime();
+        if (config != nullptr && config->date <= currentDate && currentDate <= config->expires) {
+            Datacenter *datacenter = getDatacenterWithId(config->dc_id);
+            if (datacenter != nullptr) {
+                std::vector<TcpAddress> addresses;
+                for (std::vector<std::unique_ptr<TL_ipPort>>::iterator iter = config->ip_port_list.begin(); iter != config->ip_port_list.end(); iter++) {
+                    TL_ipPort *ipPort = iter->get();
+                    addresses.push_back(TcpAddress(ipPort->ipv4, ipPort->port, 0));
+                    DEBUG_D("got address %s and port %d for dc%d", ipPort->ipv4.c_str(), ipPort->port, config->dc_id);
+                }
+                if (!addresses.empty()) {
+                    datacenter->replaceAddresses(addresses, TcpAddressFlagTemp);
+                    Connection *connection = datacenter->getTempConnection(false);
+                    if (connection != nullptr) {
+                        connection->suspendConnection();
+                    }
+                    if (datacenter->isHandshaking()) {
+                        datacenter->beginHandshake(true);
+                    }
+                    updateDcSettings(config->dc_id, true);
+                }
+            }
+            delete config;
+        } else if (requestingSecondAddress == 0) {
+            requestingSecondAddress = 1;
+            delegate->onRequestNewServerIpAndPort(requestingSecondAddress);
+        }
+        buffer->reuse();
+    });
+}
+
+void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string systemLangCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused, bool enablePushConnection, bool hasNetwork, int32_t networkType) {
     currentVersion = version;
     currentLayer = layer;
     currentApiId = apiId;
@@ -2437,6 +2622,7 @@ void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, st
     currentSystemVersion = systemVersion;
     currentAppVersion = appVersion;
     currentLangCode = langCode;
+    currentSystemLangCode = systemLangCode;
     currentUserId = userId;
     currentLogPath = logPath;
     pushConnectionEnabled = enablePushConnection;
@@ -2459,6 +2645,35 @@ void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, st
     pthread_create(&networkThread, NULL, (ConnectionsManager::ThreadProc), this);
 }
 
+void ConnectionsManager::setProxySettings(std::string address, uint16_t port, std::string username, std::string password) {
+    scheduleTask([&, address, port, username, password] {
+        bool reconnect = proxyAddress != address;
+        proxyAddress = address;
+        proxyPort = port;
+        proxyUser = username;
+        proxyPassword = password;
+        if (reconnect) {
+            for (std::map<uint32_t, Datacenter *>::iterator iter = datacenters.begin(); iter != datacenters.end(); iter++) {
+                iter->second->suspendConnections();
+            }
+            processRequestQueue(0, 0);
+        }
+    });
+}
+
+void ConnectionsManager::setLangCode(std::string langCode) {
+    scheduleTask([&, langCode] {
+        if (currentLangCode.compare(langCode) == 0) {
+            return;
+        }
+        currentLangCode = langCode;
+        for (std::map<uint32_t, Datacenter *>::iterator iter = datacenters.begin(); iter != datacenters.end(); iter++) {
+            iter->second->lastInitVersion = 0;
+        }
+        saveConfig();
+    });
+}
+
 void ConnectionsManager::resumeNetwork(bool partial) {
     scheduleTask([&, partial] {
         if (partial) {
diff --git a/TMessagesProj/jni/tgnet/ConnectionsManager.h b/TMessagesProj/jni/tgnet/ConnectionsManager.h
index dacfdb15d..8f5e5b4b7 100644
--- a/TMessagesProj/jni/tgnet/ConnectionsManager.h
+++ b/TMessagesProj/jni/tgnet/ConnectionsManager.h
@@ -45,6 +45,7 @@ class ConnectionsManager {
     int64_t getCurrentTimeMillis();
     int64_t getCurrentTimeMonotonicMillis();
     int32_t getCurrentTime();
+    bool isTestBackend();
     int32_t getTimeDifference();
     int32_t sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate);
     void sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken);
@@ -61,14 +62,17 @@ class ConnectionsManager {
     void pauseNetwork();
     void setNetworkAvailable(bool value, int32_t type);
     void setUseIpv6(bool value);
-    void init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused, bool enablePushConnection, bool hasNetwork, int32_t networkType);
-    void updateDcSettings(uint32_t datacenterId);
+    void init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string systemLangCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused, bool enablePushConnection, bool hasNetwork, int32_t networkType);
+    void setProxySettings(std::string address, uint16_t port, std::string username, std::string password);
+    void setLangCode(std::string langCode);
+    void updateDcSettings(uint32_t datacenterId, bool workaround);
     void setPushConnectionEnabled(bool value);
+    void applyDnsConfig(NativeByteBuffer *buffer);
     void setMtProtoVersion(int version);
     int32_t getMtProtoVersion();
 
 #ifdef ANDROID
-    void sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2);
+    void sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, onWriteToSocketFunc onWriteToSocket, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2, jobject ptr3);
     static void useJavaVM(JavaVM *vm, bool useJavaByteBuffers);
 #endif
 
@@ -78,6 +82,7 @@ class ConnectionsManager {
     void initDatacenters();
     void loadConfig();
     void saveConfig();
+    void saveConfigInternal(NativeByteBuffer *buffer);
     void select();
     void wakeup();
     void processServerResponse(TLObject *message, int64_t messageId, int32_t messageSeqNo, int64_t messageSalt, Connection *connection, int64_t innerMsgId, int64_t containerMessageId);
@@ -102,7 +107,7 @@ class ConnectionsManager {
     void scheduleTask(std::function<void()> task);
     void scheduleEvent(EventObject *eventObject, uint32_t time);
     void removeEvent(EventObject *eventObject);
-    void onConnectionClosed(Connection *connection);
+    void onConnectionClosed(Connection *connection, int reason);
     void onConnectionConnected(Connection *connection);
     void onConnectionQuickAckReceived(Connection *connection, int32_t ack);
     void onConnectionDataReceived(Connection *connection, NativeByteBuffer *data, uint32_t length);
@@ -134,6 +139,9 @@ class ConnectionsManager {
     int64_t lastPushPingTime = 0;
     bool sendingPushPing = false;
     bool updatingDcSettings = false;
+    bool updatingDcSettingsWorkaround = false;
+    int32_t disconnectTimeoutAmount = 0;
+    int32_t requestingSecondAddress = 0;
     int32_t updatingDcStartTime = 0;
     int32_t lastDcUpdateTime = 0;
     int64_t lastPingTime = getCurrentTimeMonotonicMillis();
@@ -146,6 +154,12 @@ class ConnectionsManager {
     int32_t lastDestroySessionRequestTime;
     std::map<int32_t, std::vector<int32_t>> requestsByGuids;
     std::map<int32_t, int32_t> guidsByRequests;
+    std::map<int64_t, int64_t> resendRequests;
+
+    std::string proxyUser = "";
+    std::string proxyPassword = "";
+    std::string proxyAddress = "";
+    std::uint16_t proxyPort = 1080;
 
     pthread_t networkThread;
     pthread_mutex_t mutex;
@@ -176,6 +190,7 @@ class ConnectionsManager {
     std::string currentSystemVersion;
     std::string currentAppVersion;
     std::string currentLangCode;
+    std::string currentSystemLangCode;
     std::string currentConfigPath;
     std::string currentLogPath;
     int32_t currentUserId = 0;
diff --git a/TMessagesProj/jni/tgnet/Datacenter.cpp b/TMessagesProj/jni/tgnet/Datacenter.cpp
index 0cb457ed2..ffa66fa54 100644
--- a/TMessagesProj/jni/tgnet/Datacenter.cpp
+++ b/TMessagesProj/jni/tgnet/Datacenter.cpp
@@ -27,28 +27,33 @@
 
 static std::vector<std::string> serverPublicKeys;
 static std::vector<uint64_t> serverPublicKeysFingerprints;
-static BN_CTX *bnContext;
+static std::map<int32_t, std::string> cdnPublicKeys;
+static std::map<int32_t, uint64_t> cdnPublicKeysFingerprints;
+static std::vector<Datacenter *> cdnWaitingDatacenters;
+static bool loadingCdnKeys = false;
+static BN_CTX *bnContext = nullptr;
 static SHA256_CTX sha256Ctx;
+static Config *cdnConfig = nullptr;
 
 Datacenter::Datacenter(uint32_t id) {
     datacenterId = id;
-    for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
+    for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
         uploadConnection[a] = nullptr;
     }
-    for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
-        downloadConnections[a] = nullptr;
+    for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
+        downloadConnection[a] = nullptr;
     }
 }
 
 Datacenter::Datacenter(NativeByteBuffer *data) {
-    for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
+    for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
         uploadConnection[a] = nullptr;
     }
-    for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
-        downloadConnections[a] = nullptr;
+    for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
+        downloadConnection[a] = nullptr;
     }
     uint32_t currentVersion = data->readUint32(nullptr);
-    if (currentVersion >= 2 && currentVersion <= 5) {
+    if (currentVersion >= 2 && currentVersion <= 7) {
         datacenterId = data->readUint32(nullptr);
         if (currentVersion >= 3) {
             lastInitVersion = data->readUint32(nullptr);
@@ -56,35 +61,63 @@ Datacenter::Datacenter(NativeByteBuffer *data) {
         uint32_t len = data->readUint32(nullptr);
         for (uint32_t a = 0; a < len; a++) {
             std::string address = data->readString(nullptr);
-            addressesIpv4.push_back(address);
-            ports[address] = data->readUint32(nullptr);
+            uint32_t port = data->readUint32(nullptr);
+            int32_t flags;
+            if (currentVersion >= 7) {
+                flags = data->readInt32(nullptr);
+            } else {
+                flags = 0;
+            }
+            addressesIpv4.push_back(TcpAddress(address, port, flags));
         }
         if (currentVersion >= 5) {
             len = data->readUint32(nullptr);
             for (uint32_t a = 0; a < len; a++) {
                 std::string address = data->readString(nullptr);
-                addressesIpv6.push_back(address);
-                ports[address] = data->readUint32(nullptr);
+                uint32_t port = data->readUint32(nullptr);
+                int32_t flags;
+                if (currentVersion >= 7) {
+                    flags = data->readInt32(nullptr);
+                } else {
+                    flags = 0;
+                }
+                addressesIpv6.push_back(TcpAddress(address, port, flags));
             }
             len = data->readUint32(nullptr);
             for (uint32_t a = 0; a < len; a++) {
                 std::string address = data->readString(nullptr);
-                addressesIpv4Download.push_back(address);
-                ports[address] = data->readUint32(nullptr);
+                uint32_t port = data->readUint32(nullptr);
+                int32_t flags;
+                if (currentVersion >= 7) {
+                    flags = data->readInt32(nullptr);
+                } else {
+                    flags = 0;
+                }
+                addressesIpv4Download.push_back(TcpAddress(address, port, flags));
             }
             len = data->readUint32(nullptr);
             for (uint32_t a = 0; a < len; a++) {
                 std::string address = data->readString(nullptr);
-                addressesIpv6Download.push_back(address);
-                ports[address] = data->readUint32(nullptr);
+                uint32_t port = data->readUint32(nullptr);
+                int32_t flags;
+                if (currentVersion >= 7) {
+                    flags = data->readInt32(nullptr);
+                } else {
+                    flags = 0;
+                }
+                addressesIpv6Download.push_back(TcpAddress(address, port, flags));
             }
         }
+        if (currentVersion >= 6) {
+            isCdnDatacenter = data->readBool(nullptr);
+        }
         len = data->readUint32(nullptr);
         if (len != 0) {
             authKey = data->readBytes(len, nullptr);
         }
         if (currentVersion >= 4) {
             authKeyId = data->readInt64(nullptr);
+            DEBUG_D("dc%d key = 0x%llx", datacenterId, authKeyId);
         } else {
             len = data->readUint32(nullptr);
             if (len != 0) {
@@ -108,7 +141,7 @@ Datacenter::Datacenter(NativeByteBuffer *data) {
     NativeByteBuffer *buffer = config->readConfig();
     if (buffer != nullptr) {
         uint32_t version = buffer->readUint32(nullptr);
-        if (version <= paramsConfigVersion) {
+        if (version >= 1) {
             currentPortNumIpv4 = buffer->readUint32(nullptr);
             currentAddressNumIpv4 = buffer->readUint32(nullptr);
             currentPortNumIpv6 = buffer->readUint32(nullptr);
@@ -131,42 +164,17 @@ Datacenter::Datacenter(NativeByteBuffer *data) {
     }
 }
 
-void Datacenter::switchTo443Port() {
-    for (uint32_t a = 0; a < addressesIpv4.size(); a++) {
-        if (ports[addressesIpv4[a]] == 443) {
-            currentAddressNumIpv4 = a;
-            currentPortNumIpv4 = 0;
-            break;
-        }
-    }
-    for (uint32_t a = 0; a < addressesIpv6.size(); a++) {
-        if (ports[addressesIpv6[a]] == 443) {
-            currentAddressNumIpv6 = a;
-            currentPortNumIpv6 = 0;
-            break;
-        }
-    }
-    for (uint32_t a = 0; a < addressesIpv4Download.size(); a++) {
-        if (ports[addressesIpv4Download[a]] == 443) {
-            currentAddressNumIpv4Download = a;
-            currentPortNumIpv4Download = 0;
-            break;
-        }
-    }
-    for (uint32_t a = 0; a < addressesIpv6Download.size(); a++) {
-        if (ports[addressesIpv6Download[a]] == 443) {
-            currentAddressNumIpv6Download = a;
-            currentPortNumIpv6Download = 0;
-            break;
-        }
-    }
-}
-
 std::string Datacenter::getCurrentAddress(uint32_t flags) {
     uint32_t currentAddressNum;
-    std::vector<std::string> *addresses;
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+    std::vector<TcpAddress> *addresses;
+    if (flags == 0 && !hasAuthKey() && !addressesIpv4Temp.empty()) {
+        flags = TcpAddressFlagTemp;
+    }
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        currentAddressNum = currentAddressNumIpv4Temp;
+        addresses = &addressesIpv4Temp;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentAddressNum = currentAddressNumIpv6Download;
             addresses = &addressesIpv6Download;
         } else {
@@ -174,7 +182,7 @@ std::string Datacenter::getCurrentAddress(uint32_t flags) {
             addresses = &addressesIpv4Download;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentAddressNum = currentAddressNumIpv6;
             addresses = &addressesIpv6;
         } else {
@@ -185,57 +193,111 @@ std::string Datacenter::getCurrentAddress(uint32_t flags) {
     if (addresses->empty()) {
         return std::string("");
     }
+    if ((flags & TcpAddressFlagStatic) != 0) {
+        for (std::vector<TcpAddress>::iterator iter = addresses->begin(); iter != addresses->end(); iter++) {
+            if ((iter->flags & TcpAddressFlagStatic) != 0) {
+                return iter->address;
+            }
+        }
+    }
     if (currentAddressNum >= addresses->size()) {
         currentAddressNum = 0;
-        if ((flags & 2) != 0) {
-            if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagTemp) != 0) {
+            currentAddressNumIpv4Temp = currentAddressNum;
+        } else if ((flags & TcpAddressFlagDownload) != 0) {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
                 currentAddressNumIpv6Download = currentAddressNum;
             } else {
                 currentAddressNumIpv4Download = currentAddressNum;
             }
         } else {
-            if ((flags & 1) != 0) {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
                 currentAddressNumIpv6 = currentAddressNum;
             } else {
                 currentAddressNumIpv4 = currentAddressNum;
             }
         }
     }
-    return (*addresses)[currentAddressNum];
+    return (*addresses)[currentAddressNum].address;
 }
 
 int32_t Datacenter::getCurrentPort(uint32_t flags) {
-    if (ports.empty()) {
-        return overridePort == -1 ? 443 : overridePort;
-    }
-
-    const int32_t *portsArray = overridePort == 8888 ? defaultPorts8888 : defaultPorts;
-
+    uint32_t currentAddressNum;
     uint32_t currentPortNum;
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+    std::vector<TcpAddress> *addresses;
+    if (flags == 0 && !hasAuthKey() && !addressesIpv4Temp.empty()) {
+        flags = TcpAddressFlagTemp;
+    }
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        currentAddressNum = currentAddressNumIpv4Temp;
+        currentPortNum = currentPortNumIpv4Temp;
+        addresses = &addressesIpv4Temp;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
+            currentAddressNum = currentAddressNumIpv6Download;
             currentPortNum = currentPortNumIpv6Download;
+            addresses = &addressesIpv6Download;
         } else {
+            currentAddressNum = currentAddressNumIpv4Download;
             currentPortNum = currentPortNumIpv4Download;
+            addresses = &addressesIpv4Download;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
+            currentAddressNum = currentAddressNumIpv6;
             currentPortNum = currentPortNumIpv6;
+            addresses = &addressesIpv6;
         } else {
+            currentAddressNum = currentAddressNumIpv4;
             currentPortNum = currentPortNumIpv4;
+            addresses = &addressesIpv4;
         }
     }
+    if (addresses->empty()) {
+        return overridePort == -1 ? 443 : overridePort;
+    }
+    const int32_t *portsArray = overridePort == 8888 ? defaultPorts8888 : defaultPorts;
 
-    if (currentPortNum >= 11) {
+    if ((flags & TcpAddressFlagStatic) != 0) {
+        uint32_t num = 0;
+        for (std::vector<TcpAddress>::iterator iter = addresses->begin(); iter != addresses->end(); iter++) {
+            if ((iter->flags & TcpAddressFlagStatic) != 0) {
+                currentAddressNum = num;
+                break;
+            }
+            num++;
+        }
+    }
+    if (currentAddressNum >= addresses->size()) {
+        currentAddressNum = 0;
+        if ((flags & TcpAddressFlagTemp) != 0) {
+            currentAddressNumIpv4Temp = currentAddressNum;
+        } else if ((flags & TcpAddressFlagDownload) != 0) {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
+                currentAddressNumIpv6Download = currentAddressNum;
+            } else {
+                currentAddressNumIpv4Download = currentAddressNum;
+            }
+        } else {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
+                currentAddressNumIpv6 = currentAddressNum;
+            } else {
+                currentAddressNumIpv4 = currentAddressNum;
+            }
+        }
+    }
+    if (currentPortNum >= 15) {
         currentPortNum = 0;
-        if ((flags & 2) != 0) {
-            if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagTemp) != 0) {
+            currentPortNumIpv4Temp = currentAddressNum;
+        } else if ((flags & TcpAddressFlagDownload) != 0) {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
                 currentPortNumIpv6Download = currentPortNum;
             } else {
                 currentPortNumIpv4Download = currentPortNum;
             }
         } else {
-            if ((flags & 1) != 0) {
+            if ((flags & TcpAddressFlagIpv6) != 0) {
                 currentPortNumIpv6 = currentPortNum;
             } else {
                 currentPortNumIpv4 = currentPortNum;
@@ -247,40 +309,49 @@ int32_t Datacenter::getCurrentPort(uint32_t flags) {
         if (overridePort != -1) {
             return overridePort;
         }
-        std::string address = getCurrentAddress(flags);
-        return ports[address];
+        return ((*addresses) [currentAddressNum]).port;
     }
     return port;
 }
 
 void Datacenter::addAddressAndPort(std::string address, uint32_t port, uint32_t flags) {
-    std::vector<std::string> *addresses;
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+    std::vector<TcpAddress> *addresses;
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        addresses = &addressesIpv4Temp;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             addresses = &addressesIpv6Download;
         } else {
             addresses = &addressesIpv4Download;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             addresses = &addressesIpv6;
         } else {
             addresses = &addressesIpv4;
         }
     }
-    if (std::find(addresses->begin(), addresses->end(), address) != addresses->end()) {
-        return;
+    for (std::vector<TcpAddress>::iterator iter = addresses->begin(); iter != addresses->end(); iter++) {
+        if (iter->address == address && iter->port == port) {
+            return;
+        }
     }
-    addresses->push_back(address);
-    ports[address] = port;
+    addresses->push_back(TcpAddress(address, port, flags));
 }
 
 void Datacenter::nextAddressOrPort(uint32_t flags) {
     uint32_t currentPortNum;
     uint32_t currentAddressNum;
-    std::vector<std::string> *addresses;
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+    std::vector<TcpAddress> *addresses;
+    if (flags == 0 && !hasAuthKey() && !addressesIpv4Temp.empty()) {
+        flags = TcpAddressFlagTemp;
+    }
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        currentPortNum = currentPortNumIpv4Temp;
+        currentAddressNum = currentAddressNumIpv4Temp;
+        addresses = &addressesIpv4Temp;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentPortNum = currentPortNumIpv6Download;
             currentAddressNum = currentAddressNumIpv6Download;
             addresses = &addressesIpv6Download;
@@ -290,7 +361,7 @@ void Datacenter::nextAddressOrPort(uint32_t flags) {
             addresses = &addressesIpv4Download;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentPortNum = currentPortNumIpv6;
             currentAddressNum = currentAddressNumIpv6;
             addresses = &addressesIpv6;
@@ -300,7 +371,7 @@ void Datacenter::nextAddressOrPort(uint32_t flags) {
             addresses = &addressesIpv4;
         }
     }
-    if (currentPortNum + 1 < 11) {
+    if (currentPortNum + 1 < 15) {
         currentPortNum++;
     } else {
         if (currentAddressNum + 1 < addresses->size()) {
@@ -310,8 +381,11 @@ void Datacenter::nextAddressOrPort(uint32_t flags) {
         }
         currentPortNum = 0;
     }
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        currentPortNumIpv4Temp = currentPortNum;
+        currentAddressNumIpv4Temp = currentAddressNum;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentPortNumIpv6Download = currentPortNum;
             currentAddressNumIpv6Download = currentAddressNum;
         } else {
@@ -319,7 +393,7 @@ void Datacenter::nextAddressOrPort(uint32_t flags) {
             currentAddressNumIpv4Download = currentAddressNum;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             currentPortNumIpv6 = currentPortNum;
             currentAddressNumIpv6 = currentAddressNum;
         } else {
@@ -359,42 +433,23 @@ void Datacenter::resetAddressAndPortNum() {
     storeCurrentAddressAndPortNum();
 }
 
-void Datacenter::replaceAddressesAndPorts(std::vector<std::string> &newAddresses, std::map<std::string, uint32_t> &newPorts, uint32_t flags) {
-    std::vector<std::string> *addresses;
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
-            addresses = &addressesIpv6Download;
-        } else {
-            addresses = &addressesIpv4Download;
-        }
-    } else {
-        if ((flags & 1) != 0) {
-            addresses = &addressesIpv6;
-        } else {
-            addresses = &addressesIpv4;
-        }
-    }
-    size_t size = addresses->size();
-    for (uint32_t a = 0; a < size; a++) {
-        std::map<std::string, uint32_t>::iterator iter = ports.find((*addresses)[a]);
-        if (iter != ports.end()) {
-            ports.erase(iter);
-        }
-    }
-    if ((flags & 2) != 0) {
-        if ((flags & 1) != 0) {
+void Datacenter::replaceAddresses(std::vector<TcpAddress> &newAddresses, uint32_t flags) {
+    isCdnDatacenter = (flags & 8) != 0;
+    if ((flags & TcpAddressFlagTemp) != 0) {
+        addressesIpv4Temp = newAddresses;
+    } else if ((flags & TcpAddressFlagDownload) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             addressesIpv6Download = newAddresses;
         } else {
             addressesIpv4Download = newAddresses;
         }
     } else {
-        if ((flags & 1) != 0) {
+        if ((flags & TcpAddressFlagIpv6) != 0) {
             addressesIpv6 = newAddresses;
         } else {
             addressesIpv4 = newAddresses;
         }
     }
-    ports.insert(newPorts.begin(), newPorts.end());
 }
 
 void Datacenter::serializeToStream(NativeByteBuffer *stream) {
@@ -404,24 +459,29 @@ void Datacenter::serializeToStream(NativeByteBuffer *stream) {
     size_t size;
     stream->writeInt32((int32_t) (size = addressesIpv4.size()));
     for (uint32_t a = 0; a < size; a++) {
-        stream->writeString(addressesIpv4[a]);
-        stream->writeInt32(ports[addressesIpv4[a]]);
+        stream->writeString(addressesIpv4[a].address);
+        stream->writeInt32(addressesIpv4[a].port);
+        stream->writeInt32(addressesIpv4[a].flags);
     }
     stream->writeInt32((int32_t) (size = addressesIpv6.size()));
     for (uint32_t a = 0; a < size; a++) {
-        stream->writeString(addressesIpv6[a]);
-        stream->writeInt32(ports[addressesIpv6[a]]);
+        stream->writeString(addressesIpv6[a].address);
+        stream->writeInt32(addressesIpv6[a].port);
+        stream->writeInt32(addressesIpv6[a].flags);
     }
     stream->writeInt32((int32_t) (size = addressesIpv4Download.size()));
     for (uint32_t a = 0; a < size; a++) {
-        stream->writeString(addressesIpv4Download[a]);
-        stream->writeInt32(ports[addressesIpv4Download[a]]);
+        stream->writeString(addressesIpv4Download[a].address);
+        stream->writeInt32(addressesIpv4Download[a].port);
+        stream->writeInt32(addressesIpv4Download[a].flags);
     }
     stream->writeInt32((int32_t) (size = addressesIpv6Download.size()));
     for (uint32_t a = 0; a < size; a++) {
-        stream->writeString(addressesIpv6Download[a]);
-        stream->writeInt32(ports[addressesIpv6Download[a]]);
+        stream->writeString(addressesIpv6Download[a].address);
+        stream->writeInt32(addressesIpv6Download[a].port);
+        stream->writeInt32(addressesIpv6Download[a].flags);
     }
+    stream->writeBool(isCdnDatacenter);
     if (authKey != nullptr) {
         stream->writeInt32(authKey->length);
         stream->writeBytes(authKey);
@@ -439,7 +499,10 @@ void Datacenter::serializeToStream(NativeByteBuffer *stream) {
 }
 
 void Datacenter::clear() {
-    authKey = nullptr;
+    if (authKey != nullptr) {
+        delete authKey;
+        authKey = nullptr;
+    }
     authKeyId = 0;
     authorized = false;
     serverSalts.clear();
@@ -537,14 +600,17 @@ void Datacenter::suspendConnections() {
     if (genericConnection != nullptr) {
         genericConnection->suspendConnection();
     }
+    if (tempConnection != nullptr) {
+        tempConnection->suspendConnection();
+    }
     for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
         if (uploadConnection[a] != nullptr) {
             uploadConnection[a]->suspendConnection();
         }
     }
     for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
-        if (downloadConnections[a] != nullptr) {
-            downloadConnections[a]->suspendConnection();
+        if (downloadConnection[a] != nullptr) {
+            downloadConnection[a]->suspendConnection();
         }
     }
 }
@@ -553,14 +619,17 @@ void Datacenter::getSessions(std::vector<int64_t> &sessions) {
     if (genericConnection != nullptr) {
         sessions.push_back(genericConnection->getSissionId());
     }
+    if (tempConnection != nullptr) {
+        sessions.push_back(tempConnection->getSissionId());
+    }
     for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
         if (uploadConnection[a] != nullptr) {
             sessions.push_back(uploadConnection[a]->getSissionId());
         }
     }
     for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
-        if (downloadConnections[a] != nullptr) {
-            sessions.push_back(downloadConnections[a]->getSissionId());
+        if (downloadConnection[a] != nullptr) {
+            sessions.push_back(downloadConnection[a]->getSissionId());
         }
     }
 }
@@ -569,23 +638,26 @@ void Datacenter::recreateSessions() {
     if (genericConnection != nullptr) {
         genericConnection->recreateSession();
     }
+    if (tempConnection != nullptr) {
+        tempConnection->recreateSession();
+    }
     for (uint32_t a = 0; a < UPLOAD_CONNECTIONS_COUNT; a++) {
         if (uploadConnection[a] != nullptr) {
             uploadConnection[a]->recreateSession();
         }
     }
     for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
-        if (downloadConnections[a] != nullptr) {
-            downloadConnections[a]->recreateSession();
+        if (downloadConnection[a] != nullptr) {
+            downloadConnection[a]->recreateSession();
         }
     }
 }
 
 Connection *Datacenter::createDownloadConnection(uint8_t num) {
-    if (downloadConnections[num] == nullptr) {
-        downloadConnections[num] = new Connection(this, ConnectionTypeDownload);
+    if (downloadConnection[num] == nullptr) {
+        downloadConnection[num] = new Connection(this, ConnectionTypeDownload);
     }
-    return downloadConnections[num];
+    return downloadConnection[num];
 }
 
 Connection *Datacenter::createUploadConnection(uint8_t num) {
@@ -609,6 +681,13 @@ Connection *Datacenter::createPushConnection() {
     return pushConnection;
 }
 
+Connection *Datacenter::createTempConnection() {
+    if (tempConnection == nullptr) {
+        tempConnection = new Connection(this, ConnectionTypeTemp);
+    }
+    return tempConnection;
+}
+
 uint32_t Datacenter::getDatacenterId() {
     return datacenterId;
 }
@@ -908,61 +987,6 @@ void Datacenter::aesIgeEncryption(uint8_t *buffer, uint8_t *key, uint8_t *iv, bo
     }
 }
 
-int32_t Datacenter::selectPublicKey(std::vector<int64_t> &fingerprints) {
-    if (serverPublicKeys.empty()) {
-        serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
-                                           "MIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\n"
-                                           "lyDONS789sVoD/xCS9Y0hkkC3gtL1tSfTlgCMOOul9lcixlEKzwKENj1Yz/s7daS\n"
-                                           "an9tqw3bfUV/nqgbhGX81v/+7RFAEd+RwFnK7a+XYl9sluzHRyVVaTTveB2GazTw\n"
-                                           "Efzk2DWgkBluml8OREmvfraX3bkHZJTKX4EQSjBbbdJ2ZXIsRrYOXfaA+xayEGB+\n"
-                                           "8hdlLmAjbCVfaigxX0CDqWeR1yFL9kwd9P0NsZRPsmoqVwMbMu7mStFai6aIhc3n\n"
-                                           "Slv8kg9qv1m6XHVQY3PnEw+QQtqSIXklHwIDAQAB\n"
-                                           "-----END RSA PUBLIC KEY-----");
-        serverPublicKeysFingerprints.push_back(0xc3b42b026ce86b21LL);
-
-        serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
-                                           "MIIBCgKCAQEAxq7aeLAqJR20tkQQMfRn+ocfrtMlJsQ2Uksfs7Xcoo77jAid0bRt\n"
-                                           "ksiVmT2HEIJUlRxfABoPBV8wY9zRTUMaMA654pUX41mhyVN+XoerGxFvrs9dF1Ru\n"
-                                           "vCHbI02dM2ppPvyytvvMoefRoL5BTcpAihFgm5xCaakgsJ/tH5oVl74CdhQw8J5L\n"
-                                           "xI/K++KJBUyZ26Uba1632cOiq05JBUW0Z2vWIOk4BLysk7+U9z+SxynKiZR3/xdi\n"
-                                           "XvFKk01R3BHV+GUKM2RYazpS/P8v7eyKhAbKxOdRcFpHLlVwfjyM1VlDQrEZxsMp\n"
-                                           "NTLYXb6Sce1Uov0YtNx5wEowlREH1WOTlwIDAQAB\n"
-                                           "-----END RSA PUBLIC KEY-----");
-        serverPublicKeysFingerprints.push_back(0x9a996a1db11c729bLL);
-
-        serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
-                                           "MIIBCgKCAQEAsQZnSWVZNfClk29RcDTJQ76n8zZaiTGuUsi8sUhW8AS4PSbPKDm+\n"
-                                           "DyJgdHDWdIF3HBzl7DHeFrILuqTs0vfS7Pa2NW8nUBwiaYQmPtwEa4n7bTmBVGsB\n"
-                                           "1700/tz8wQWOLUlL2nMv+BPlDhxq4kmJCyJfgrIrHlX8sGPcPA4Y6Rwo0MSqYn3s\n"
-                                           "g1Pu5gOKlaT9HKmE6wn5Sut6IiBjWozrRQ6n5h2RXNtO7O2qCDqjgB2vBxhV7B+z\n"
-                                           "hRbLbCmW0tYMDsvPpX5M8fsO05svN+lKtCAuz1leFns8piZpptpSCFn7bWxiA9/f\n"
-                                           "x5x17D7pfah3Sy2pA+NDXyzSlGcKdaUmwQIDAQAB\n"
-                                           "-----END RSA PUBLIC KEY-----");
-        serverPublicKeysFingerprints.push_back(0xb05b2a6f70cdea78LL);
-
-        serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
-                                           "MIIBCgKCAQEAwqjFW0pi4reKGbkc9pK83Eunwj/k0G8ZTioMMPbZmW99GivMibwa\n"
-                                           "xDM9RDWabEMyUtGoQC2ZcDeLWRK3W8jMP6dnEKAlvLkDLfC4fXYHzFO5KHEqF06i\n"
-                                           "qAqBdmI1iBGdQv/OQCBcbXIWCGDY2AsiqLhlGQfPOI7/vvKc188rTriocgUtoTUc\n"
-                                           "/n/sIUzkgwTqRyvWYynWARWzQg0I9olLBBC2q5RQJJlnYXZwyTL3y9tdb7zOHkks\n"
-                                           "WV9IMQmZmyZh/N7sMbGWQpt4NMchGpPGeJ2e5gHBjDnlIf2p1yZOYeUYrdbwcS0t\n"
-                                           "UiggS4UeE8TzIuXFQxw7fzEIlmhIaq3FnwIDAQAB\n"
-                                           "-----END RSA PUBLIC KEY-----");
-        serverPublicKeysFingerprints.push_back(0x71e025b6c76033e3LL);
-    }
-
-    size_t count1 = fingerprints.size();
-    size_t count2 = serverPublicKeysFingerprints.size();
-    for (uint32_t a = 0; a < count1; a++) {
-        for (uint32_t b = 0; b < count2; b++) {
-            if ((uint64_t) fingerprints[a] == serverPublicKeysFingerprints[b]) {
-                return b;
-            }
-        }
-    }
-    return -1;
-}
-
 void Datacenter::processHandshakeResponse(TLObject *message, int64_t messageId) {
     if (handshakeState == 0) {
         return;
@@ -977,10 +1001,126 @@ void Datacenter::processHandshakeResponse(TLObject *message, int64_t messageId)
         handshakeState = 2;
         TL_resPQ *result = (TL_resPQ *) message;
         if (authNonce->isEqualTo(result->nonce.get())) {
-            int32_t keyIndex = selectPublicKey(result->server_public_key_fingerprints);
-            if (keyIndex < 0) {
-                DEBUG_E("dc%u handshake: can't find valid server public key", datacenterId);
-                beginHandshake(false);
+            std::string key;
+            int64_t keyFingerprint = 0;
+
+            size_t count1 = result->server_public_key_fingerprints.size();
+            if (isCdnDatacenter) {
+                std::map<int32_t, uint64_t>::iterator iter = cdnPublicKeysFingerprints.find(datacenterId);
+                if (iter != cdnPublicKeysFingerprints.end()) {
+                    for (uint32_t a = 0; a < count1; a++) {
+                        if ((uint64_t) result->server_public_key_fingerprints[a] == iter->second) {
+                            keyFingerprint = iter->second;
+                            key = cdnPublicKeys[datacenterId];
+                        }
+                    }
+                }
+            } else {
+                if (serverPublicKeys.empty()) {
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\n"
+                                                       "lyDONS789sVoD/xCS9Y0hkkC3gtL1tSfTlgCMOOul9lcixlEKzwKENj1Yz/s7daS\n"
+                                                       "an9tqw3bfUV/nqgbhGX81v/+7RFAEd+RwFnK7a+XYl9sluzHRyVVaTTveB2GazTw\n"
+                                                       "Efzk2DWgkBluml8OREmvfraX3bkHZJTKX4EQSjBbbdJ2ZXIsRrYOXfaA+xayEGB+\n"
+                                                       "8hdlLmAjbCVfaigxX0CDqWeR1yFL9kwd9P0NsZRPsmoqVwMbMu7mStFai6aIhc3n\n"
+                                                       "Slv8kg9qv1m6XHVQY3PnEw+QQtqSIXklHwIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0xc3b42b026ce86b21LL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAxq7aeLAqJR20tkQQMfRn+ocfrtMlJsQ2Uksfs7Xcoo77jAid0bRt\n"
+                                                       "ksiVmT2HEIJUlRxfABoPBV8wY9zRTUMaMA654pUX41mhyVN+XoerGxFvrs9dF1Ru\n"
+                                                       "vCHbI02dM2ppPvyytvvMoefRoL5BTcpAihFgm5xCaakgsJ/tH5oVl74CdhQw8J5L\n"
+                                                       "xI/K++KJBUyZ26Uba1632cOiq05JBUW0Z2vWIOk4BLysk7+U9z+SxynKiZR3/xdi\n"
+                                                       "XvFKk01R3BHV+GUKM2RYazpS/P8v7eyKhAbKxOdRcFpHLlVwfjyM1VlDQrEZxsMp\n"
+                                                       "NTLYXb6Sce1Uov0YtNx5wEowlREH1WOTlwIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0x9a996a1db11c729bLL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAsQZnSWVZNfClk29RcDTJQ76n8zZaiTGuUsi8sUhW8AS4PSbPKDm+\n"
+                                                       "DyJgdHDWdIF3HBzl7DHeFrILuqTs0vfS7Pa2NW8nUBwiaYQmPtwEa4n7bTmBVGsB\n"
+                                                       "1700/tz8wQWOLUlL2nMv+BPlDhxq4kmJCyJfgrIrHlX8sGPcPA4Y6Rwo0MSqYn3s\n"
+                                                       "g1Pu5gOKlaT9HKmE6wn5Sut6IiBjWozrRQ6n5h2RXNtO7O2qCDqjgB2vBxhV7B+z\n"
+                                                       "hRbLbCmW0tYMDsvPpX5M8fsO05svN+lKtCAuz1leFns8piZpptpSCFn7bWxiA9/f\n"
+                                                       "x5x17D7pfah3Sy2pA+NDXyzSlGcKdaUmwQIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0xb05b2a6f70cdea78LL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAwqjFW0pi4reKGbkc9pK83Eunwj/k0G8ZTioMMPbZmW99GivMibwa\n"
+                                                       "xDM9RDWabEMyUtGoQC2ZcDeLWRK3W8jMP6dnEKAlvLkDLfC4fXYHzFO5KHEqF06i\n"
+                                                       "qAqBdmI1iBGdQv/OQCBcbXIWCGDY2AsiqLhlGQfPOI7/vvKc188rTriocgUtoTUc\n"
+                                                       "/n/sIUzkgwTqRyvWYynWARWzQg0I9olLBBC2q5RQJJlnYXZwyTL3y9tdb7zOHkks\n"
+                                                       "WV9IMQmZmyZh/N7sMbGWQpt4NMchGpPGeJ2e5gHBjDnlIf2p1yZOYeUYrdbwcS0t\n"
+                                                       "UiggS4UeE8TzIuXFQxw7fzEIlmhIaq3FnwIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0x71e025b6c76033e3LL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAruw2yP/BCcsJliRoW5eBVBVle9dtjJw+OYED160Wybum9SXtBBLX\n"
+                                                       "riwt4rROd9csv0t0OHCaTmRqBcQ0J8fxhN6/cpR1GWgOZRUAiQxoMnlt0R93LCX/\n"
+                                                       "j1dnVa/gVbCjdSxpbrfY2g2L4frzjJvdl84Kd9ORYjDEAyFnEA7dD556OptgLQQ2\n"
+                                                       "e2iVNq8NZLYTzLp5YpOdO1doK+ttrltggTCy5SrKeLoCPPbOgGsdxJxyz5KKcZnS\n"
+                                                       "Lj16yE5HvJQn0CNpRdENvRUXe6tBP78O39oJ8BTHp9oIjd6XWXAsp2CvK45Ol8wF\n"
+                                                       "XGF710w9lwCGNbmNxNYhtIkdqfsEcwR5JwIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0xbc35f3509f7b7a5LL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAvfLHfYH2r9R70w8prHblWt/nDkh+XkgpflqQVcnAfSuTtO05lNPs\n"
+                                                       "pQmL8Y2XjVT4t8cT6xAkdgfmmvnvRPOOKPi0OfJXoRVylFzAQG/j83u5K3kRLbae\n"
+                                                       "7fLccVhKZhY46lvsueI1hQdLgNV9n1cQ3TDS2pQOCtovG4eDl9wacrXOJTG2990V\n"
+                                                       "jgnIKNA0UMoP+KF03qzryqIt3oTvZq03DyWdGK+AZjgBLaDKSnC6qD2cFY81UryR\n"
+                                                       "WOab8zKkWAnhw2kFpcqhI0jdV5QaSCExvnsjVaX0Y1N0870931/5Jb9ICe4nweZ9\n"
+                                                       "kSDF/gip3kWLG0o8XQpChDfyvsqB9OLV/wIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0x15ae5fa8b5529542LL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAs/ditzm+mPND6xkhzwFIz6J/968CtkcSE/7Z2qAJiXbmZ3UDJPGr\n"
+                                                       "zqTDHkO30R8VeRM/Kz2f4nR05GIFiITl4bEjvpy7xqRDspJcCFIOcyXm8abVDhF+\n"
+                                                       "th6knSU0yLtNKuQVP6voMrnt9MV1X92LGZQLgdHZbPQz0Z5qIpaKhdyA8DEvWWvS\n"
+                                                       "Uwwc+yi1/gGaybwlzZwqXYoPOhwMebzKUk0xW14htcJrRrq+PXXQbRzTMynseCoP\n"
+                                                       "Ioke0dtCodbA3qQxQovE16q9zz4Otv2k4j63cz53J+mhkVWAeWxVGI0lltJmWtEY\n"
+                                                       "K6er8VqqWot3nqmWMXogrgRLggv/NbbooQIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0xaeae98e13cd7f94fLL);
+
+                    serverPublicKeys.push_back("-----BEGIN RSA PUBLIC KEY-----\n"
+                                                       "MIIBCgKCAQEAvmpxVY7ld/8DAjz6F6q05shjg8/4p6047bn6/m8yPy1RBsvIyvuD\n"
+                                                       "uGnP/RzPEhzXQ9UJ5Ynmh2XJZgHoE9xbnfxL5BXHplJhMtADXKM9bWB11PU1Eioc\n"
+                                                       "3+AXBB8QiNFBn2XI5UkO5hPhbb9mJpjA9Uhw8EdfqJP8QetVsI/xrCEbwEXe0xvi\n"
+                                                       "fRLJbY08/Gp66KpQvy7g8w7VB8wlgePexW3pT13Ap6vuC+mQuJPyiHvSxjEKHgqe\n"
+                                                       "Pji9NP3tJUFQjcECqcm0yV7/2d0t/pbCm+ZH1sadZspQCEPPrtbkQBlvHb4OLiIW\n"
+                                                       "PGHKSMeRFvp3IWcmdJqXahxLCUS1Eh6MAQIDAQAB\n"
+                                                       "-----END RSA PUBLIC KEY-----");
+                    serverPublicKeysFingerprints.push_back(0x5a181b2235057d98LL);
+                }
+
+                size_t count2 = serverPublicKeysFingerprints.size();
+                for (uint32_t a = 0; a < count1; a++) {
+                    for (uint32_t b = 0; b < count2; b++) {
+                        if ((uint64_t) result->server_public_key_fingerprints[a] == serverPublicKeysFingerprints[b]) {
+                            keyFingerprint = result->server_public_key_fingerprints[a];
+                            key = serverPublicKeys[a];
+                            break;
+                        }
+                    }
+                    if (keyFingerprint != 0) {
+                        break;
+                    }
+                }
+            }
+
+            if (keyFingerprint == 0) {
+                if (isCdnDatacenter) {
+                    DEBUG_D("dc%u handshake: can't find valid cdn server public key", datacenterId);
+                    loadCdnConfig(this);
+                } else {
+                    DEBUG_E("dc%u handshake: can't find valid server public key", datacenterId);
+                    beginHandshake(false);
+                }
                 return;
             }
 
@@ -1014,7 +1154,7 @@ void Datacenter::processHandshakeResponse(TLObject *message, int64_t messageId)
             request->q->bytes[2] = (uint8_t) (q >> 8);
             request->q->bytes[1] = (uint8_t) (q >> 16);
             request->q->bytes[0] = (uint8_t) (q >> 24);
-            request->public_key_fingerprint = (int64_t) serverPublicKeysFingerprints[keyIndex];
+            request->public_key_fingerprint = keyFingerprint;
 
             TL_p_q_inner_data *innerData = new TL_p_q_inner_data();
             innerData->nonce = std::unique_ptr<ByteArray>(new ByteArray(authNonce));
@@ -1038,8 +1178,6 @@ void Datacenter::processHandshakeResponse(TLObject *message, int64_t messageId)
                 RAND_bytes(innerDataBuffer->bytes() + SHA_DIGEST_LENGTH + innerDataSize, additionalSize);
             }
 
-            std::string &key = serverPublicKeys[keyIndex];
-
             BIO *keyBio = BIO_new(BIO_s_mem());
             BIO_write(keyBio, key.c_str(), (int) key.length());
             RSA *rsaKey = PEM_read_bio_RSAPublicKey(keyBio, NULL, NULL, NULL);
@@ -1521,6 +1659,9 @@ NativeByteBuffer *Datacenter::createRequestsData(std::vector<std::unique_ptr<Net
 }
 
 bool Datacenter::decryptServerResponse(int64_t keyId, uint8_t *key, uint8_t *data, uint32_t length) {
+    if (authKey == nullptr) {
+        return false;
+    }
     bool error = false;
     if (authKeyId != keyId) {
         error = true;
@@ -1531,8 +1672,11 @@ bool Datacenter::decryptServerResponse(int64_t keyId, uint8_t *key, uint8_t *dat
 
     uint32_t messageLength;
     memcpy(&messageLength, data + 28, sizeof(uint32_t));
+    uint32_t paddingLength = (int32_t) length - (messageLength + 32);
     if (messageLength > length - 32) {
         error = true;
+    } else if (paddingLength < 12 || paddingLength > 1024) {
+        error = true;
     }
     messageLength += 32;
     if (messageLength > length) {
@@ -1572,6 +1716,8 @@ Connection *Datacenter::createConnectionByType(uint32_t connectionType) {
             return createUploadConnection(connectionNum);
         case ConnectionTypePush:
             return createPushConnection();
+        case ConnectionTypeTemp:
+            return createTempConnection();
         default:
             return nullptr;
     }
@@ -1584,7 +1730,7 @@ Connection *Datacenter::getDownloadConnection(uint8_t num, bool create) {
     if (create) {
         createDownloadConnection(num)->connect();
     }
-    return downloadConnections[num];
+    return downloadConnection[num];
 }
 
 Connection *Datacenter::getUploadConnection(uint8_t num, bool create) {
@@ -1617,6 +1763,16 @@ Connection *Datacenter::getPushConnection(bool create) {
     return pushConnection;
 }
 
+Connection *Datacenter::getTempConnection(bool create) {
+    if (authKey == nullptr) {
+        return nullptr;
+    }
+    if (create) {
+        createTempConnection()->connect();
+    }
+    return tempConnection;
+}
+
 Connection *Datacenter::getConnectionByType(uint32_t connectionType, bool create) {
     uint8_t connectionNum = (uint8_t) (connectionType >> 16);
     connectionType = connectionType & 0x0000ffff;
@@ -1629,13 +1785,15 @@ Connection *Datacenter::getConnectionByType(uint32_t connectionType, bool create
             return getUploadConnection(connectionNum, create);
         case ConnectionTypePush:
             return getPushConnection(create);
+        case ConnectionTypeTemp:
+            return getTempConnection(create);
         default:
             return nullptr;
     }
 }
 
 void Datacenter::exportAuthorization() {
-    if (exportingAuthorization) {
+    if (exportingAuthorization || isCdnDatacenter) {
         return;
     }
     exportingAuthorization = true;
@@ -1668,3 +1826,201 @@ void Datacenter::exportAuthorization() {
 bool Datacenter::isExportingAuthorization() {
     return exportingAuthorization;
 }
+
+void Datacenter::saveCdnConfigInternal(NativeByteBuffer *buffer) {
+    buffer->writeInt32(1);
+    buffer->writeInt32(cdnPublicKeys.size());
+    for (std::map<int32_t, std::string>::iterator iter = cdnPublicKeys.begin(); iter != cdnPublicKeys.end(); iter++) {
+        buffer->writeInt32(iter->first);
+        buffer->writeString(iter->second);
+        buffer->writeInt64(cdnPublicKeysFingerprints[iter->first]);
+    }
+}
+
+void Datacenter::saveCdnConfig() {
+    if (cdnConfig == nullptr) {
+        cdnConfig = new Config("cdnkeys.dat");
+    }
+    static NativeByteBuffer *sizeCalculator = new NativeByteBuffer(true);
+    sizeCalculator->clearCapacity();
+    saveCdnConfigInternal(sizeCalculator);
+    NativeByteBuffer *buffer = BuffersStorage::getInstance().getFreeBuffer(sizeCalculator->capacity());
+    saveCdnConfigInternal(buffer);
+    cdnConfig->writeConfig(buffer);
+    buffer->reuse();
+}
+
+void Datacenter::loadCdnConfig(Datacenter *datacenter) {
+    if (std::find(cdnWaitingDatacenters.begin(), cdnWaitingDatacenters.end(), datacenter) != cdnWaitingDatacenters.end()) {
+        return;
+    }
+    cdnWaitingDatacenters.push_back(datacenter);
+    if (loadingCdnKeys) {
+        return;
+    }
+    if (cdnPublicKeysFingerprints.empty()) {
+        if (cdnConfig == nullptr) {
+            cdnConfig = new Config("cdnkeys.dat");
+        }
+        NativeByteBuffer *buffer = cdnConfig->readConfig();
+        if (buffer != nullptr) {
+            uint32_t version = buffer->readUint32(nullptr);
+            if (version >= 1) {
+                size_t count = buffer->readUint32(nullptr);
+                for (uint32_t a = 0; a < count; a++) {
+                    int dcId = buffer->readInt32(nullptr);
+                    cdnPublicKeys[dcId] = buffer->readString(nullptr);
+                    cdnPublicKeysFingerprints[dcId] = buffer->readUint64(nullptr);
+                }
+            }
+            buffer->reuse();
+            if (!cdnPublicKeysFingerprints.empty()) {
+                size_t count = cdnWaitingDatacenters.size();
+                for (uint32_t a = 0; a < count; a++) {
+                    cdnWaitingDatacenters[a]->beginHandshake(false);
+                }
+                cdnWaitingDatacenters.clear();
+                return;
+            }
+        }
+    }
+    loadingCdnKeys = true;
+    TL_help_getCdnConfig *request = new TL_help_getCdnConfig();
+
+    ConnectionsManager::getInstance().sendRequest(request, [&](TLObject *response, TL_error *error, int32_t networkType) {
+        if (response != nullptr) {
+            TL_cdnConfig *config = (TL_cdnConfig *) response;
+            size_t count = config->public_keys.size();
+            BIO *keyBio = BIO_new(BIO_s_mem());
+            NativeByteBuffer *buffer = BuffersStorage::getInstance().getFreeBuffer(1024);
+            static uint8_t sha1Buffer[20];
+            for (uint32_t a = 0; a < count; a++) {
+                TL_cdnPublicKey *publicKey = config->public_keys[a].get();
+                cdnPublicKeys[publicKey->dc_id] = publicKey->public_key;
+
+                BIO_write(keyBio, publicKey->public_key.c_str(), (int) publicKey->public_key.length());
+                RSA *rsaKey = PEM_read_bio_RSAPublicKey(keyBio, NULL, NULL, NULL);
+
+                int nBytes = BN_num_bytes(rsaKey->n);
+                int eBytes = BN_num_bytes(rsaKey->e);
+                std::string nStr(nBytes, 0), eStr(eBytes, 0);
+                BN_bn2bin(rsaKey->n, (uint8_t *)&nStr[0]);
+                BN_bn2bin(rsaKey->e, (uint8_t *)&eStr[0]);
+                buffer->writeString(nStr);
+                buffer->writeString(eStr);
+                SHA1(buffer->bytes(), buffer->position(), sha1Buffer);
+                cdnPublicKeysFingerprints[publicKey->dc_id] = ((uint64_t) sha1Buffer[19]) << 56 |
+                                                              ((uint64_t) sha1Buffer[18]) << 48 |
+                                                              ((uint64_t) sha1Buffer[17]) << 40 |
+                                                              ((uint64_t) sha1Buffer[16]) << 32 |
+                                                              ((uint64_t) sha1Buffer[15]) << 24 |
+                                                              ((uint64_t) sha1Buffer[14]) << 16 |
+                                                              ((uint64_t) sha1Buffer[13]) << 8 |
+                                                              ((uint64_t) sha1Buffer[12]);
+                RSA_free(rsaKey);
+                if (a != count - 1) {
+                    buffer->position(0);
+                    BIO_reset(keyBio);
+                }
+            }
+            buffer->reuse();
+            BIO_free(keyBio);
+            count = cdnWaitingDatacenters.size();
+            for (uint32_t a = 0; a < count; a++) {
+                cdnWaitingDatacenters[a]->beginHandshake(false);
+            }
+            cdnWaitingDatacenters.clear();
+            saveCdnConfig();
+        }
+        loadingCdnKeys = false;
+    }, nullptr, RequestFlagEnableUnauthorized | RequestFlagWithoutLogin, DEFAULT_DATACENTER_ID, ConnectionTypeGeneric, true);
+}
+
+TL_help_configSimple *Datacenter::decodeSimpleConfig(NativeByteBuffer *buffer) {
+    TL_help_configSimple *result = nullptr;
+
+    static std::string public_key =
+            "-----BEGIN RSA PUBLIC KEY-----\n"
+                    "MIIBCgKCAQEAyr+18Rex2ohtVy8sroGPBwXD3DOoKCSpjDqYoXgCqB7ioln4eDCF\n"
+                    "fOBUlfXUEvM/fnKCpF46VkAftlb4VuPDeQSS/ZxZYEGqHaywlroVnXHIjgqoxiAd\n"
+                    "192xRGreuXIaUKmkwlM9JID9WS2jUsTpzQ91L8MEPLJ/4zrBwZua8W5fECwCCh2c\n"
+                    "9G5IzzBm+otMS/YKwmR1olzRCyEkyAEjXWqBI9Ftv5eG8m0VkBzOG655WIYdyV0H\n"
+                    "fDK/NWcvGqa0w/nriMD6mDjKOryamw0OP9QuYgMN0C9xMW9y8SmP4h92OAWodTYg\n"
+                    "Y1hZCxdv6cs5UnW9+PWvS+WIbkh+GaWYxwIDAQAB\n"
+                    "-----END RSA PUBLIC KEY-----";
+
+    BIO *keyBio = BIO_new(BIO_s_mem());
+    BIO_write(keyBio, public_key.c_str(), (int) public_key.length());
+
+    RSA *rsaKey = PEM_read_bio_RSAPublicKey(keyBio, NULL, NULL, NULL);
+    if (rsaKey == nullptr) {
+        if (rsaKey == nullptr) {
+            DEBUG_E("Invalid rsa public key");
+            return nullptr;
+        }
+    }
+
+    BIGNUM x, y;
+    uint8_t *bytes = buffer->bytes();
+    if (bnContext == nullptr) {
+        bnContext = BN_CTX_new();
+    }
+    BN_init(&x);
+    BN_init(&y);
+    BN_bin2bn(bytes, 256, &x);
+
+    if (BN_mod_exp(&y, &x, rsaKey->e, rsaKey->n, bnContext) == 1) {
+        /*uint8_t temp[256];
+        BN_bn2bin(&y, temp);
+        std::string res = "";
+        for (int a = 0; a < 256; a++) {
+            char buf[20];
+            sprintf(buf, "%x", temp[a]);
+            res += buf;
+        }
+        DEBUG_D("hex = %s", res.c_str());*/
+        unsigned l = 256 - BN_num_bytes(&y);
+        memset(bytes, 0, l);
+        if (BN_bn2bin(&y, bytes + l) == 256 - l) {
+            AES_KEY aeskey;
+            unsigned char iv[16];
+            memcpy(iv, bytes + 16, 16);
+            AES_set_decrypt_key(bytes, 256, &aeskey);
+            AES_cbc_encrypt(bytes + 32, bytes + 32, 256 - 32, &aeskey, iv, AES_DECRYPT);
+
+            EVP_MD_CTX ctx;
+            unsigned char sha256_out[32];
+            unsigned olen = 0;
+            EVP_MD_CTX_init(&ctx);
+            EVP_DigestInit_ex(&ctx, EVP_sha256(), NULL);
+            EVP_DigestUpdate(&ctx, bytes + 32, 256 - 32 - 16);
+            EVP_DigestFinal_ex(&ctx, sha256_out, &olen);
+            EVP_MD_CTX_cleanup(&ctx);
+            if (olen == 32) {
+                if (memcmp(bytes + 256 - 16, sha256_out, 16) == 0) {
+                    unsigned data_len = *(unsigned *) (bytes + 32);
+                    if (data_len && data_len <= 256 - 32 - 16 && !(data_len & 3)) {
+                        buffer->position(32 + 4);
+                        bool error = false;
+                        result = TL_help_configSimple::TLdeserialize(buffer, buffer->readUint32(&error), error);
+                        if (error) {
+                            if (result != nullptr) {
+                                delete result;
+                                result = nullptr;
+                            }
+                        }
+                    } else {
+                        DEBUG_E("TL data length field invalid - %d", data_len);
+                    }
+                } else {
+                    DEBUG_E("RSA signature check FAILED (SHA256 mismatch)");
+                }
+            }
+        }
+    }
+    BN_free(&x);
+    BN_free(&y);
+    RSA_free(rsaKey);
+    BIO_free(keyBio);
+    return result;
+}
diff --git a/TMessagesProj/jni/tgnet/Datacenter.h b/TMessagesProj/jni/tgnet/Datacenter.h
index 13338ad93..32748a8fd 100644
--- a/TMessagesProj/jni/tgnet/Datacenter.h
+++ b/TMessagesProj/jni/tgnet/Datacenter.h
@@ -19,6 +19,7 @@ class TL_future_salt;
 class Connection;
 class NativeByteBuffer;
 class TL_future_salt;
+class TL_help_configSimple;
 class ByteArray;
 class TLObject;
 class Config;
@@ -28,14 +29,13 @@ class Datacenter {
 public:
     Datacenter(uint32_t id);
     Datacenter(NativeByteBuffer *data);
-    void switchTo443Port();
     uint32_t getDatacenterId();
     std::string getCurrentAddress(uint32_t flags);
     int32_t getCurrentPort(uint32_t flags);
     void addAddressAndPort(std::string address, uint32_t port, uint32_t flags);
     void nextAddressOrPort(uint32_t flags);
     void storeCurrentAddressAndPortNum();
-    void replaceAddressesAndPorts(std::vector<std::string> &newAddresses, std::map<std::string, uint32_t> &newPorts, uint32_t flags);
+    void replaceAddresses(std::vector<TcpAddress> &newAddresses, uint32_t flags);
     void serializeToStream(NativeByteBuffer *stream);
     void clear();
     void clearServerSalts();
@@ -55,6 +55,7 @@ class Datacenter {
     Connection *getUploadConnection(uint8_t num, bool create);
     Connection *getGenericConnection(bool create);
     Connection *getPushConnection(bool create);
+    Connection *getTempConnection(bool create);
     Connection *getConnectionByType(uint32_t connectionType, bool create);
 
     static void aesIgeEncryption(uint8_t *buffer, uint8_t *key, uint8_t *iv, bool encrypt, bool changeIv, uint32_t length);
@@ -67,26 +68,29 @@ class Datacenter {
     bool decryptServerResponse(int64_t keyId, uint8_t *key, uint8_t *data, uint32_t length);
     TLObject *getCurrentHandshakeRequest();
 
-    const int32_t *defaultPorts = new int32_t[11] {-1, 80, -1, 443, -1, 443, -1, 80, -1, 443, -1};
-    const int32_t *defaultPorts8888 = new int32_t[11] {-1, 8888, -1, 443, -1, 8888,  -1, 80, -1, 8888, -1};
+    const int32_t *defaultPorts = new int32_t[15] {-1, 80, -1, 443, -1, 5222, -1, 443, -1, 80, -1,  -1, 5222, 443, -1};
+    const int32_t *defaultPorts8888 = new int32_t[15] {-1, 8888, -1, 443, -1, 5222, -1, 8888,  -1, 80, -1, 5222, -1, 8888, -1};
 
     uint32_t datacenterId;
     Connection *genericConnection = nullptr;
-    Connection *downloadConnections[DOWNLOAD_CONNECTIONS_COUNT];
+    Connection *tempConnection = nullptr;
+    Connection *downloadConnection[DOWNLOAD_CONNECTIONS_COUNT];
     Connection *uploadConnection[UPLOAD_CONNECTIONS_COUNT];
     Connection *pushConnection = nullptr;
 
     uint32_t lastInitVersion = 0;
     bool authorized = false;
 
-    std::vector<std::string> addressesIpv4;
-    std::vector<std::string> addressesIpv6;
-    std::vector<std::string> addressesIpv4Download;
-    std::vector<std::string> addressesIpv6Download;
-    std::map<std::string, uint32_t> ports;
+    std::vector<TcpAddress> addressesIpv4;
+    std::vector<TcpAddress> addressesIpv6;
+    std::vector<TcpAddress> addressesIpv4Download;
+    std::vector<TcpAddress> addressesIpv6Download;
+    std::vector<TcpAddress> addressesIpv4Temp;
     std::vector<std::unique_ptr<TL_future_salt>> serverSalts;
     uint32_t currentPortNumIpv4 = 0;
     uint32_t currentAddressNumIpv4 = 0;
+    uint32_t currentPortNumIpv4Temp = 0;
+    uint32_t currentAddressNumIpv4Temp = 0;
     uint32_t currentPortNumIpv6 = 0;
     uint32_t currentAddressNumIpv6 = 0;
     uint32_t currentPortNumIpv4Download = 0;
@@ -97,13 +101,15 @@ class Datacenter {
     int64_t authKeyId = 0;
     int32_t overridePort = -1;
     Config *config = nullptr;
+    bool isCdnDatacenter = false;
 
-    const uint32_t configVersion = 5;
+    const uint32_t configVersion = 7;
     const uint32_t paramsConfigVersion = 1;
 
     Connection *createDownloadConnection(uint8_t num);
     Connection *createUploadConnection(uint8_t num);
     Connection *createGenericConnection();
+    Connection *createTempConnection();
     Connection *createPushConnection();
     Connection *createConnectionByType(uint32_t connectionType);
 
@@ -120,11 +126,16 @@ class Datacenter {
     void sendRequestData(TLObject *object, bool important);
     void cleanupHandshake();
     void sendAckRequest(int64_t messageId);
-    int32_t selectPublicKey(std::vector<int64_t> &fingerprints);
 
     bool exportingAuthorization = false;
     void exportAuthorization();
 
+    static void saveCdnConfig();
+    static void saveCdnConfigInternal(NativeByteBuffer *buffer);
+    static void loadCdnConfig(Datacenter *datacenter);
+
+    static TL_help_configSimple *decodeSimpleConfig(NativeByteBuffer *buffer);
+
     friend class ConnectionsManager;
 };
 
diff --git a/TMessagesProj/jni/tgnet/Defines.h b/TMessagesProj/jni/tgnet/Defines.h
index a33177315..2a331e0d7 100644
--- a/TMessagesProj/jni/tgnet/Defines.h
+++ b/TMessagesProj/jni/tgnet/Defines.h
@@ -21,7 +21,7 @@
 #define DEFAULT_DATACENTER_ID INT_MAX
 #define DC_UPDATE_TIME 60 * 60
 #define DOWNLOAD_CONNECTIONS_COUNT 2
-#define UPLOAD_CONNECTIONS_COUNT 2
+#define UPLOAD_CONNECTIONS_COUNT 4
 #define CONNECTION_BACKGROUND_KEEP_TIME 10000
 
 #define DOWNLOAD_CHUNK_SIZE 1024 * 32
@@ -44,6 +44,7 @@ class FileLoadOperation;
 
 typedef std::function<void(TLObject *response, TL_error *error, int32_t networkType)> onCompleteFunc;
 typedef std::function<void()> onQuickAckFunc;
+typedef std::function<void()> onWriteToSocketFunc;
 typedef std::list<std::unique_ptr<Request>> requestsList;
 typedef requestsList::iterator requestsIter;
 
@@ -59,12 +60,23 @@ enum ConnectionType {
     ConnectionTypeDownload = 2,
     ConnectionTypeUpload = 4,
     ConnectionTypePush = 8,
+    ConnectionTypeTemp = 16
+};
+
+enum TcpAddressFlag {
+    TcpAddressFlagIpv6 = 1,
+    TcpAddressFlagDownload = 2,
+    TcpAddressFlagO = 4,
+    TcpAddressFlagCdn = 8,
+    TcpAddressFlagStatic = 16,
+    TcpAddressFlagTemp = 2048
 };
 
 enum ConnectionState {
     ConnectionStateConnecting = 1,
     ConnectionStateWaitingForNetwork = 2,
-    ConnectionStateConnected = 3
+    ConnectionStateConnected = 3,
+    ConnectionStateConnectingViaProxy = 4
 };
 
 enum EventObjectType {
@@ -87,6 +99,20 @@ enum FileLoadFailReason {
     FileLoadFailReasonRetryLimit
 };
 
+class TcpAddress {
+
+public:
+    std::string address;
+    int32_t flags;
+    int32_t port;
+
+    TcpAddress(std::string addr, int32_t p, int32_t f) {
+        address = addr;
+        port = p;
+        flags = f;
+    }
+};
+
 typedef std::function<void(std::string path)> onFinishedFunc;
 typedef std::function<void(FileLoadFailReason reason)> onFailedFunc;
 typedef std::function<void(float progress)> onProgressChangedFunc;
@@ -101,6 +127,7 @@ typedef struct ConnectiosManagerDelegate {
     virtual void onInternalPushReceived() = 0;
     virtual void onBytesSent(int32_t amount, int32_t networkType) = 0;
     virtual void onBytesReceived(int32_t amount, int32_t networkType) = 0;
+    virtual void onRequestNewServerIpAndPort(int32_t second) = 0;
 } ConnectiosManagerDelegate;
 
 #define AllConnectionTypes ConnectionTypeGeneric | ConnectionTypeDownload | ConnectionTypeUpload
diff --git a/TMessagesProj/jni/tgnet/MTProtoScheme.cpp b/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
index cf06ce96e..ebe8a3bbe 100644
--- a/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
+++ b/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
@@ -7,6 +7,7 @@
  */
 
 #include <memory.h>
+#include <arpa/inet.h>
 #include "MTProtoScheme.h"
 #include "ApiScheme.h"
 #include "FileLog.h"
@@ -30,6 +31,9 @@ TLObject *TLClassStore::TLdeserialize(NativeByteBuffer *stream, uint32_t bytes,
         case TL_new_session_created::constructor:
             object = new TL_new_session_created();
             break;
+        case MsgsStateInfo::constructor:
+            object = new MsgsStateInfo();
+            break;
         case TL_rpc_result::constructor:
             object = new TL_rpc_result();
             ((TL_rpc_result *) object)->readParamsEx(stream, bytes, error);
@@ -663,6 +667,11 @@ void TL_msg_resend_req::serializeToStream(NativeByteBuffer *stream) {
     }
 }
 
+void MsgsStateInfo::readParams(NativeByteBuffer *stream, bool &error) {
+    req_msg_id = stream->readInt64(&error);
+    info = stream->readString(&error);
+}
+
 void TL_rpc_error::readParams(NativeByteBuffer *stream, bool &error) {
     error_code = stream->readInt32(&error);
     error_message = stream->readString(&error);
@@ -852,6 +861,47 @@ void initConnection::serializeToStream(NativeByteBuffer *stream) {
     stream->writeString(device_model);
     stream->writeString(system_version);
     stream->writeString(app_version);
+    stream->writeString(system_lang_code);
+    stream->writeString(lang_pack);
     stream->writeString(lang_code);
     query->serializeToStream(stream);
 }
+
+void TL_ipPort::readParams(NativeByteBuffer *stream, bool &error) {
+    struct in_addr ip_addr;
+    ip_addr.s_addr = htonl(stream->readUint32(&error));
+    ipv4 = inet_ntoa(ip_addr);
+    port = stream->readUint32(&error);
+}
+
+TL_help_configSimple *TL_help_configSimple::TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error) {
+    if (TL_help_configSimple::constructor != constructor) {
+        error = true;
+        DEBUG_E("can't parse magic %x in TL_help_configSimple", constructor);
+        return nullptr;
+    }
+    TL_help_configSimple *result = new TL_help_configSimple();
+    result->readParams(stream, error);
+    return result;
+}
+
+void TL_help_configSimple::readParams(NativeByteBuffer *stream, bool &error) {
+    date = stream->readInt32(&error);
+    expires = stream->readInt32(&error);
+    dc_id = stream->readUint32(&error);
+    int32_t magic = stream->readInt32(&error);
+    if (magic != 0x1cb5c415) {
+        error = true;
+        DEBUG_E("wrong Vector magic, got %x", magic);
+        return;
+    }
+    uint32_t count = stream->readUint32(&error);
+    for (uint32_t a = 0; a < count; a++) {
+        TL_ipPort *object = new TL_ipPort();
+        object->readParams(stream, error);
+        if (error) {
+            return;
+        }
+        ip_port_list.push_back(std::unique_ptr<TL_ipPort>(object));
+    }
+}
diff --git a/TMessagesProj/jni/tgnet/MTProtoScheme.h b/TMessagesProj/jni/tgnet/MTProtoScheme.h
index 1426e3c59..45c2fda93 100644
--- a/TMessagesProj/jni/tgnet/MTProtoScheme.h
+++ b/TMessagesProj/jni/tgnet/MTProtoScheme.h
@@ -411,6 +411,17 @@ class TL_msg_resend_req : public TLObject {
     void serializeToStream(NativeByteBuffer *stream);
 };
 
+class MsgsStateInfo : public TLObject {
+
+public:
+    static const uint32_t constructor = 0x04deb57d;
+
+    int64_t req_msg_id;
+    std::string info;
+
+    void readParams(NativeByteBuffer *stream, bool &error);
+};
+
 class RpcError : public TLObject {
 
 public:
@@ -614,16 +625,41 @@ class invokeWithLayer : public TLObject {
 class initConnection : public TLObject {
 
 public:
-    static const uint32_t constructor = 0x69796de9;
+    static const uint32_t constructor = 0xc7481da6;
 
     int32_t api_id;
     std::string device_model;
     std::string system_version;
     std::string app_version;
+    std::string system_lang_code;
+    std::string lang_pack;
     std::string lang_code;
     std::unique_ptr<TLObject> query;
 
     void serializeToStream(NativeByteBuffer *stream);
 };
 
+class TL_ipPort : public TLObject {
+
+public:
+    std::string ipv4;
+    uint32_t port;
+
+    void readParams(NativeByteBuffer *stream, bool &error);
+};
+
+class TL_help_configSimple : public TLObject {
+
+public:
+    static const uint32_t constructor = 0xd997c3c5;
+
+    int32_t date;
+    int32_t expires;
+    uint32_t dc_id;
+    std::vector<std::unique_ptr<TL_ipPort>> ip_port_list;
+
+    static TL_help_configSimple *TLdeserialize(NativeByteBuffer *stream, uint32_t constructor, bool &error);
+    void readParams(NativeByteBuffer *stream, bool &error);
+};
+
 #endif
diff --git a/TMessagesProj/jni/tgnet/NativeByteBuffer.cpp b/TMessagesProj/jni/tgnet/NativeByteBuffer.cpp
index 19f36f067..d182713bf 100644
--- a/TMessagesProj/jni/tgnet/NativeByteBuffer.cpp
+++ b/TMessagesProj/jni/tgnet/NativeByteBuffer.cpp
@@ -476,7 +476,7 @@ int32_t NativeByteBuffer::readBigInt32(bool *error) {
 }
 
 int64_t NativeByteBuffer::readInt64(bool *error) {
-    if (_position + 4 > _limit) {
+    if (_position + 8 > _limit) {
         if (error != nullptr) {
             *error = true;
         }
@@ -521,7 +521,7 @@ bool NativeByteBuffer::readBool(bool *error) {
 }
 
 void NativeByteBuffer::readBytes(uint8_t *b, uint32_t length, bool *error) {
-    if (_position + length > _limit) {
+    if (length > _limit - _position) {
         if (error != nullptr) {
             *error = true;
         }
@@ -533,7 +533,7 @@ void NativeByteBuffer::readBytes(uint8_t *b, uint32_t length, bool *error) {
 }
 
 ByteArray *NativeByteBuffer::readBytes(uint32_t length, bool *error) {
-    if (_position + length > _limit) {
+    if (length > _limit - _position) {
         if (error != nullptr) {
             *error = true;
         }
diff --git a/TMessagesProj/jni/tgnet/Request.cpp b/TMessagesProj/jni/tgnet/Request.cpp
index 29a5fdf14..76c19f564 100644
--- a/TMessagesProj/jni/tgnet/Request.cpp
+++ b/TMessagesProj/jni/tgnet/Request.cpp
@@ -12,13 +12,14 @@
 #include "MTProtoScheme.h"
 #include "ConnectionsManager.h"
 
-Request::Request(int32_t token, ConnectionType type, uint32_t flags, uint32_t datacenter, onCompleteFunc completeFunc, onQuickAckFunc quickAckFunc) {
+Request::Request(int32_t token, ConnectionType type, uint32_t flags, uint32_t datacenter, onCompleteFunc completeFunc, onQuickAckFunc quickAckFunc, onWriteToSocketFunc writeToSocketFunc) {
     requestToken = token;
     connectionType = type;
     requestFlags = flags;
     datacenterId = datacenter;
     onCompleteRequestCallback = completeFunc;
     onQuickAckCallback = quickAckFunc;
+    onWriteToSocketCallback = writeToSocketFunc;
     dataType = (uint8_t) (requestFlags >> 24);
 }
 
@@ -32,6 +33,10 @@ Request::~Request() {
         jniEnv->DeleteGlobalRef(ptr2);
         ptr2 = nullptr;
     }
+    if (ptr3 != nullptr) {
+        jniEnv->DeleteGlobalRef(ptr3);
+        ptr3 = nullptr;
+    }
 #endif
 }
 
@@ -59,6 +64,12 @@ void Request::onComplete(TLObject *result, TL_error *error, int32_t networkType)
     }
 }
 
+void Request::onWriteToSocket() {
+    if (onWriteToSocketCallback != nullptr) {
+        onWriteToSocketCallback();
+    }
+}
+
 void Request::onQuickAck() {
     if (onQuickAckCallback != nullptr) {
         onQuickAckCallback();
diff --git a/TMessagesProj/jni/tgnet/Request.h b/TMessagesProj/jni/tgnet/Request.h
index 4c66b142d..96062c27e 100644
--- a/TMessagesProj/jni/tgnet/Request.h
+++ b/TMessagesProj/jni/tgnet/Request.h
@@ -24,7 +24,7 @@ class TL_error;
 class Request {
 
 public:
-    Request(int32_t token, ConnectionType type, uint32_t flags, uint32_t datacenter, onCompleteFunc completeFunc, onQuickAckFunc quickAckFunc);
+    Request(int32_t token, ConnectionType type, uint32_t flags, uint32_t datacenter, onCompleteFunc completeFunc, onQuickAckFunc quickAckFunc, onWriteToSocketFunc writeToSocketFunc);
     ~Request();
 
     int64_t messageId = 0;
@@ -50,17 +50,20 @@ class Request {
     std::unique_ptr<TLObject> rpcRequest;
     onCompleteFunc onCompleteRequestCallback;
     onQuickAckFunc onQuickAckCallback;
+    onWriteToSocketFunc onWriteToSocketCallback;
 
     void addRespondMessageId(int64_t id);
     bool respondsToMessageId(int64_t id);
     void clear(bool time);
     void onComplete(TLObject *result, TL_error *error, int32_t networkType);
     void onQuickAck();
+    void onWriteToSocket();
     TLObject *getRpcRequest();
 
 #ifdef ANDROID
     jobject ptr1 = nullptr;
     jobject ptr2 = nullptr;
+    jobject ptr3 = nullptr;
 #endif
 
 private:
